/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_app_announcement_components_FaceDetectorComponent_tsx"],{

/***/ "(app-pages-browser)/../node_modules/@vladmandic/face-api/dist sync recursive":
/*!*******************************************************!*\
  !*** ../node_modules/@vladmandic/face-api/dist/ sync ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "(app-pages-browser)/../node_modules/@vladmandic/face-api/dist sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "(app-pages-browser)/../node_modules/@vladmandic/face-api/dist/face-api.esm.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@vladmandic/face-api/dist/face-api.esm.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("var __filename = \"/index.js\";\nvar __dirname = \"/\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgeGenderNet: () => (/* binding */ ug),\n/* harmony export */   BoundingBox: () => (/* binding */ bp),\n/* harmony export */   Box: () => (/* binding */ mn),\n/* harmony export */   ComposableTask: () => (/* binding */ Oa),\n/* harmony export */   ComputeAllFaceDescriptorsTask: () => (/* binding */ Bs),\n/* harmony export */   ComputeFaceDescriptorsTaskBase: () => (/* binding */ yg),\n/* harmony export */   ComputeSingleFaceDescriptorTask: () => (/* binding */ Vs),\n/* harmony export */   DetectAllFaceLandmarksTask: () => (/* binding */ vg),\n/* harmony export */   DetectAllFacesTask: () => (/* binding */ Gd),\n/* harmony export */   DetectFaceLandmarksTaskBase: () => (/* binding */ xg),\n/* harmony export */   DetectFacesTaskBase: () => (/* binding */ kg),\n/* harmony export */   DetectSingleFaceLandmarksTask: () => (/* binding */ wg),\n/* harmony export */   DetectSingleFaceTask: () => (/* binding */ Ig),\n/* harmony export */   Dimensions: () => (/* binding */ aa),\n/* harmony export */   FACE_EXPRESSION_LABELS: () => (/* binding */ rD),\n/* harmony export */   FaceDetection: () => (/* binding */ Ft),\n/* harmony export */   FaceDetectionNet: () => (/* binding */ TD),\n/* harmony export */   FaceExpressionNet: () => (/* binding */ sg),\n/* harmony export */   FaceExpressions: () => (/* binding */ Os),\n/* harmony export */   FaceLandmark68Net: () => (/* binding */ Dp),\n/* harmony export */   FaceLandmark68TinyNet: () => (/* binding */ cg),\n/* harmony export */   FaceLandmarkNet: () => (/* binding */ fD),\n/* harmony export */   FaceLandmarks: () => (/* binding */ ka),\n/* harmony export */   FaceLandmarks5: () => (/* binding */ H$),\n/* harmony export */   FaceLandmarks68: () => (/* binding */ vp),\n/* harmony export */   FaceMatch: () => (/* binding */ Dd),\n/* harmony export */   FaceMatcher: () => (/* binding */ WD),\n/* harmony export */   FaceRecognitionNet: () => (/* binding */ Rp),\n/* harmony export */   Gender: () => (/* binding */ Ck),\n/* harmony export */   LabeledBox: () => (/* binding */ Rd),\n/* harmony export */   LabeledFaceDescriptors: () => (/* binding */ rl),\n/* harmony export */   NetInput: () => (/* binding */ Wr),\n/* harmony export */   NeuralNetwork: () => (/* binding */ fn),\n/* harmony export */   ObjectDetection: () => (/* binding */ yp),\n/* harmony export */   Point: () => (/* binding */ He),\n/* harmony export */   PredictedBox: () => (/* binding */ j$),\n/* harmony export */   Rect: () => (/* binding */ xp),\n/* harmony export */   SsdMobilenetv1: () => (/* binding */ ll),\n/* harmony export */   SsdMobilenetv1Options: () => (/* binding */ Ma),\n/* harmony export */   TinyFaceDetector: () => (/* binding */ zp),\n/* harmony export */   TinyFaceDetectorOptions: () => (/* binding */ fg),\n/* harmony export */   TinyYolov2: () => (/* binding */ Pp),\n/* harmony export */   TinyYolov2Options: () => (/* binding */ yr),\n/* harmony export */   allFaces: () => (/* binding */ OAe),\n/* harmony export */   allFacesSsdMobilenetv1: () => (/* binding */ mge),\n/* harmony export */   allFacesTinyYolov2: () => (/* binding */ MAe),\n/* harmony export */   awaitMediaLoaded: () => (/* binding */ q$),\n/* harmony export */   bufferToImage: () => (/* binding */ K$),\n/* harmony export */   computeFaceDescriptor: () => (/* binding */ v_e),\n/* harmony export */   createCanvas: () => (/* binding */ Np),\n/* harmony export */   createCanvasFromMedia: () => (/* binding */ Zf),\n/* harmony export */   createFaceDetectionNet: () => (/* binding */ YCe),\n/* harmony export */   createFaceRecognitionNet: () => (/* binding */ Y2e),\n/* harmony export */   createSsdMobilenetv1: () => (/* binding */ lge),\n/* harmony export */   createTinyFaceDetector: () => (/* binding */ eFe),\n/* harmony export */   createTinyYolov2: () => (/* binding */ BEe),\n/* harmony export */   detectAllFaces: () => (/* binding */ Dk),\n/* harmony export */   detectFaceLandmarks: () => (/* binding */ dge),\n/* harmony export */   detectFaceLandmarksTiny: () => (/* binding */ x_e),\n/* harmony export */   detectLandmarks: () => (/* binding */ $_e),\n/* harmony export */   detectSingleFace: () => (/* binding */ _Ae),\n/* harmony export */   draw: () => (/* binding */ iD),\n/* harmony export */   env: () => (/* binding */ at),\n/* harmony export */   euclideanDistance: () => (/* binding */ zD),\n/* harmony export */   extendWithAge: () => (/* binding */ Fk),\n/* harmony export */   extendWithFaceDescriptor: () => (/* binding */ Ak),\n/* harmony export */   extendWithFaceDetection: () => (/* binding */ wp),\n/* harmony export */   extendWithFaceExpressions: () => (/* binding */ Nk),\n/* harmony export */   extendWithFaceLandmarks: () => (/* binding */ Vd),\n/* harmony export */   extendWithGender: () => (/* binding */ $k),\n/* harmony export */   extractFaceTensors: () => (/* binding */ Ld),\n/* harmony export */   extractFaces: () => (/* binding */ Pd),\n/* harmony export */   fetchImage: () => (/* binding */ sIe),\n/* harmony export */   fetchJson: () => (/* binding */ Z$),\n/* harmony export */   fetchNetWeights: () => (/* binding */ pIe),\n/* harmony export */   fetchOrThrow: () => (/* binding */ Ms),\n/* harmony export */   fetchVideo: () => (/* binding */ gIe),\n/* harmony export */   getContext2dOrThrow: () => (/* binding */ ra),\n/* harmony export */   getMediaDimensions: () => (/* binding */ Sp),\n/* harmony export */   imageTensorToCanvas: () => (/* binding */ X$),\n/* harmony export */   imageToSquare: () => (/* binding */ Y$),\n/* harmony export */   inverseSigmoid: () => (/* binding */ v0e),\n/* harmony export */   iou: () => (/* binding */ B$),\n/* harmony export */   isMediaElement: () => (/* binding */ Sk),\n/* harmony export */   isMediaLoaded: () => (/* binding */ Yf),\n/* harmony export */   isWithAge: () => (/* binding */ eCe),\n/* harmony export */   isWithFaceDetection: () => (/* binding */ zr),\n/* harmony export */   isWithFaceExpressions: () => (/* binding */ sD),\n/* harmony export */   isWithFaceLandmarks: () => (/* binding */ Fp),\n/* harmony export */   isWithGender: () => (/* binding */ rCe),\n/* harmony export */   loadAgeGenderModel: () => (/* binding */ __e),\n/* harmony export */   loadFaceDetectionModel: () => (/* binding */ A_e),\n/* harmony export */   loadFaceExpressionModel: () => (/* binding */ E_e),\n/* harmony export */   loadFaceLandmarkModel: () => (/* binding */ N_e),\n/* harmony export */   loadFaceLandmarkTinyModel: () => (/* binding */ T_e),\n/* harmony export */   loadFaceRecognitionModel: () => (/* binding */ C_e),\n/* harmony export */   loadSsdMobilenetv1Model: () => (/* binding */ hge),\n/* harmony export */   loadTinyFaceDetectorModel: () => (/* binding */ I_e),\n/* harmony export */   loadTinyYolov2Model: () => (/* binding */ S_e),\n/* harmony export */   loadWeightMap: () => (/* binding */ Q$),\n/* harmony export */   locateFaces: () => (/* binding */ F_e),\n/* harmony export */   matchDimensions: () => (/* binding */ IIe),\n/* harmony export */   minBbox: () => (/* binding */ V$),\n/* harmony export */   nets: () => (/* binding */ rt),\n/* harmony export */   nonMaxSuppression: () => (/* binding */ U$),\n/* harmony export */   normalize: () => (/* binding */ br),\n/* harmony export */   padToSquare: () => (/* binding */ G$),\n/* harmony export */   predictAgeAndGender: () => (/* binding */ k_e),\n/* harmony export */   recognizeFaceExpressions: () => (/* binding */ w_e),\n/* harmony export */   resizeResults: () => (/* binding */ fge),\n/* harmony export */   resolveInput: () => (/* binding */ kp),\n/* harmony export */   shuffleArray: () => (/* binding */ y0e),\n/* harmony export */   sigmoid: () => (/* binding */ qf),\n/* harmony export */   ssdMobilenetv1: () => (/* binding */ cge),\n/* harmony export */   tf: () => (/* binding */ Pe),\n/* harmony export */   tinyFaceDetector: () => (/* binding */ b_e),\n/* harmony export */   tinyYolov2: () => (/* binding */ y_e),\n/* harmony export */   toNetInput: () => (/* binding */ vt),\n/* harmony export */   utils: () => (/* binding */ W$),\n/* harmony export */   validateConfig: () => (/* binding */ DD),\n/* harmony export */   version: () => (/* binding */ cFe)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/../node_modules/next/dist/build/polyfills/process.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/../node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n/*\n  Face-API\n  homepage: <https://github.com/vladmandic/face-api>\n  author: <https://github.com/vladmandic>'\n*/\n\nvar vR=Object.defineProperty;var wR=(e=> true?__webpack_require__(\"(app-pages-browser)/../node_modules/@vladmandic/face-api/dist sync recursive\"):0)(function(e){if(true)return __webpack_require__(\"(app-pages-browser)/../node_modules/@vladmandic/face-api/dist sync recursive\").apply(this,arguments);throw Error('Dynamic require of \"'+e+'\" is not supported')});var ax=(e,t)=>{for(var n in t)vR(e,n,{get:t[n],enumerable:!0})};var Pe={};ax(Pe,{Abs:()=>Yl,Acos:()=>Ni,Acosh:()=>Ti,AdadeltaOptimizer:()=>Vw,AdagradOptimizer:()=>Uw,AdamOptimizer:()=>Gw,AdamaxOptimizer:()=>Hw,Add:()=>vs,AddN:()=>Ci,All:()=>Zl,Any:()=>Jl,ArgMax:()=>Ql,ArgMin:()=>eu,Asin:()=>Ei,Asinh:()=>_i,Atan:()=>Ai,Atan2:()=>$i,Atanh:()=>Fi,AvgPool:()=>Di,AvgPool3D:()=>tu,AvgPool3DGrad:()=>Rc,AvgPoolGrad:()=>Dc,BackendWasm:()=>L$,BatchMatMul:()=>Ri,BatchToSpaceND:()=>nu,Bincount:()=>au,BitwiseAnd:()=>ru,BroadcastArgs:()=>Mc,BroadcastTo:()=>HS,Callback:()=>PC,CallbackList:()=>A2,Cast:()=>Mi,Ceil:()=>Oi,ClipByValue:()=>ws,Complex:()=>wm,ComplexAbs:()=>Oc,Concat:()=>su,Conv2D:()=>Pi,Conv2DBackpropFilter:()=>km,Conv2DBackpropInput:()=>Li,Conv3D:()=>zi,Conv3DBackpropFilterV2:()=>iu,Conv3DBackpropInputV2:()=>ou,Cos:()=>Wi,Cosh:()=>Bi,CropAndResize:()=>uu,Cumprod:()=>lu,Cumsum:()=>Vi,CustomCallback:()=>$2,DataStorage:()=>ym,DenseBincount:()=>Pc,DepthToSpace:()=>pu,DepthwiseConv2dNative:()=>Ui,DepthwiseConv2dNativeBackpropFilter:()=>Im,DepthwiseConv2dNativeBackpropInput:()=>Sm,Diag:()=>Lc,Dilation2D:()=>Gi,Dilation2DBackpropFilter:()=>Rl,Dilation2DBackpropInput:()=>Dl,Draw:()=>Nm,ENV:()=>Tv,EarlyStopping:()=>LC,Einsum:()=>Tm,Elu:()=>ji,EluGrad:()=>cu,Environment:()=>US,Equal:()=>du,Erf:()=>qi,Exp:()=>Ki,ExpandDims:()=>hu,Expm1:()=>Xi,FFT:()=>Cm,Fill:()=>zc,FlipLeftRight:()=>mu,Floor:()=>Yi,FloorDiv:()=>Zi,FromPixels:()=>Hh,FusedBatchNorm:()=>Ji,FusedConv2D:()=>oi,FusedDepthwiseConv2D:()=>li,GPGPUContext:()=>Wh,GatherNd:()=>gu,GatherV2:()=>fu,GraphModel:()=>F1,Greater:()=>bu,GreaterEqual:()=>Qi,History:()=>F2,IFFT:()=>Em,Identity:()=>eo,Imag:()=>_m,InputSpec:()=>zt,IsFinite:()=>to,IsInf:()=>no,IsNan:()=>ao,KernelBackend:()=>Fc,LRN:()=>oo,LRNGrad:()=>Su,LayerVariable:()=>k2,LayersModel:()=>Er,LeakyRelu:()=>ro,Less:()=>yu,LessEqual:()=>xu,LinSpace:()=>vu,Log:()=>so,Log1p:()=>io,LogSoftmax:()=>qS,LogicalAnd:()=>wu,LogicalNot:()=>ku,LogicalOr:()=>Iu,LogicalXor:()=>jS,LowerBound:()=>dM,MathBackendCPU:()=>R1,MathBackendWebGL:()=>lk,MatrixBandPart:()=>hM,Max:()=>lo,MaxPool:()=>po,MaxPool3D:()=>Nu,MaxPool3DGrad:()=>Bc,MaxPoolGrad:()=>Wc,MaxPoolWithArgmax:()=>Vc,Maximum:()=>uo,Mean:()=>co,Min:()=>ho,Minimum:()=>mo,MirrorPad:()=>fo,Mod:()=>go,MomentumOptimizer:()=>jw,Multinomial:()=>Tu,Multiply:()=>bo,Neg:()=>Cu,NonMaxSuppressionV3:()=>_u,NonMaxSuppressionV4:()=>Au,NonMaxSuppressionV5:()=>Fu,NotEqual:()=>Eu,OP_SCOPE_SUFFIX:()=>Fv,OneHot:()=>yo,OnesLike:()=>$u,Optimizer:()=>Rr,OptimizerConstructors:()=>t2,Pack:()=>Du,PadV2:()=>xo,Pool:()=>mM,Pow:()=>vo,Prelu:()=>wo,Prod:()=>ko,RMSPropOptimizer:()=>qw,RNN:()=>Mr,RaggedGather:()=>Am,RaggedRange:()=>Fm,RaggedTensorToTensor:()=>$m,Range:()=>Uc,Rank:()=>kx,Real:()=>Dm,RealDiv:()=>Hi,Reciprocal:()=>Io,Reduction:()=>kn,Relu:()=>So,Relu6:()=>Co,Reshape:()=>Ru,ResizeBilinear:()=>To,ResizeBilinearGrad:()=>Ou,ResizeNearestNeighbor:()=>No,ResizeNearestNeighborGrad:()=>Mu,Reverse:()=>Eo,RotateWithOffset:()=>Zu,Round:()=>_o,Rsqrt:()=>Ao,SGDOptimizer:()=>ff,ScatterNd:()=>Pu,SearchSorted:()=>zu,Select:()=>Wu,Selu:()=>Fo,Sequential:()=>Ef,Sigmoid:()=>Mo,Sign:()=>Ro,Sin:()=>$o,Sinh:()=>Do,Slice:()=>Bu,Softmax:()=>zo,Softplus:()=>Oo,SpaceToBatchND:()=>Vu,SparseFillEmptyRows:()=>Gc,SparseReshape:()=>Gu,SparseSegmentMean:()=>Hc,SparseSegmentSum:()=>jc,SparseToDense:()=>Hu,SplitV:()=>Uu,Sqrt:()=>Po,Square:()=>qc,SquaredDifference:()=>Wo,StaticRegexReplace:()=>Kc,Step:()=>Is,StridedSlice:()=>ju,StringNGrams:()=>Xc,StringSplit:()=>Yc,StringToHashBucketFast:()=>Zc,Sub:()=>Bo,Sum:()=>Lo,SymbolicTensor:()=>Ha,Tan:()=>Vo,Tanh:()=>Uo,Tensor:()=>Ce,TensorBuffer:()=>Wt,TensorScatterUpdate:()=>Lu,Tile:()=>ks,TopK:()=>qu,Transform:()=>Ku,Transpose:()=>Cr,Unique:()=>Jc,Unpack:()=>Xu,UnsortedSegmentSum:()=>Qc,UpperBound:()=>fM,Variable:()=>os,ZerosLike:()=>Yu,_FusedMatMul:()=>ii,abs:()=>Lt,acos:()=>Pv,acosh:()=>Lv,add:()=>X,addN:()=>vN,all:()=>Lm,any:()=>yc,argMax:()=>di,argMin:()=>zv,asin:()=>Wv,asinh:()=>Bv,atan:()=>Vv,atan2:()=>Uv,atanh:()=>Gv,avgPool:()=>ya,avgPool3d:()=>jv,backend:()=>Dv,backend_util:()=>T,basicLSTMCell:()=>SN,batchNorm:()=>Ns,batchNorm2d:()=>qv,batchNorm3d:()=>Kv,batchNorm4d:()=>Xv,batchToSpaceND:()=>id,bincount:()=>Yv,bitwiseAnd:()=>NN,booleanMaskAsync:()=>mT,broadcastArgs:()=>TN,broadcastTo:()=>ai,broadcast_util:()=>Ju,browser:()=>qo,buffer:()=>Oe,callbacks:()=>dq,cast:()=>re,ceil:()=>Zv,clipByValue:()=>an,clone:()=>sr,complex:()=>_r,concat:()=>et,concat1d:()=>Jv,concat2d:()=>Qv,concat3d:()=>ew,concat4d:()=>tw,constraints:()=>T2,conv1d:()=>zm,conv2d:()=>$t,conv2dTranspose:()=>Wm,conv3d:()=>aw,conv3dTranspose:()=>rw,copyRegisteredKernels:()=>xM,cos:()=>od,cosh:()=>Bm,cosineWindow:()=>pf,cumprod:()=>wc,cumsum:()=>Vm,customGrad:()=>pr,data:()=>lE,denseBincount:()=>Xh,deprecationWarn:()=>$v,depthToSpace:()=>sw,depthwiseConv2d:()=>Ts,deregisterOp:()=>fq,device_util:()=>ad,diag:()=>EN,dilation2d:()=>iw,disableDeprecationWarnings:()=>ZM,dispose:()=>Ee,disposeVariables:()=>JM,div:()=>he,divNoNan:()=>ow,dot:()=>lw,dropout:()=>Pw,einsum:()=>Zs,elu:()=>Qu,enableDebugMode:()=>YM,enableProdMode:()=>XM,enclosingPowerOfTwo:()=>Lw,engine:()=>Ta,ensureShape:()=>AN,env:()=>G,equal:()=>Jn,erf:()=>Um,euclideanNorm:()=>cw,exp:()=>dn,expandDims:()=>Gt,expm1:()=>dw,eye:()=>Gm,fft:()=>bd,fill:()=>yn,findBackend:()=>rO,findBackendFactory:()=>sO,floor:()=>tp,floorDiv:()=>Pm,forceHalfFloat:()=>$A,fused:()=>Vl,gather:()=>np,gatherND:()=>yT,gather_util:()=>Yw,getBackend:()=>oN,getGradient:()=>vx,getKernel:()=>fc,getKernelsForBackend:()=>jh,getThreadsCount:()=>_fe,gpgpu_util:()=>uA,grad:()=>P3,grads:()=>L3,greater:()=>Cn,greaterEqual:()=>$r,ifft:()=>Bl,imag:()=>ld,image:()=>Zn,inTopKAsync:()=>xT,initializers:()=>C2,input:()=>j2,io:()=>jt,irfft:()=>af,isFinite:()=>hw,isInf:()=>mw,isNaN:()=>fw,keep:()=>Ht,kernel_impls:()=>mr,layers:()=>E2,leakyRelu:()=>ud,less:()=>Pl,lessEqual:()=>Cs,linalg:()=>Bw,linspace:()=>MN,loadGraphModel:()=>w5,loadGraphModelSync:()=>k5,loadLayersModel:()=>oj,localResponseNormalization:()=>gw,log:()=>Qn,log1p:()=>pd,logSigmoid:()=>bw,logSoftmax:()=>jm,logSumExp:()=>cd,logicalAnd:()=>_a,logicalNot:()=>dd,logicalOr:()=>qm,logicalXor:()=>yw,losses:()=>FT,lowerBound:()=>PN,matMul:()=>$e,math:()=>VT,max:()=>ma,maxPool:()=>Dt,maxPool3d:()=>xw,maxPoolWithArgmax:()=>LN,maximum:()=>hr,mean:()=>Ct,memory:()=>Kh,meshgrid:()=>zN,metrics:()=>RC,min:()=>Ol,minimum:()=>ds,mirrorPad:()=>vw,mod:()=>ww,model:()=>pj,models:()=>MC,moments:()=>hd,movingAverage:()=>fT,mul:()=>z,multiRNNCell:()=>WN,multinomial:()=>BN,neg:()=>yt,nextFrame:()=>Zw,norm:()=>ep,notEqual:()=>fi,oneHot:()=>Ll,ones:()=>Pn,onesLike:()=>ea,op:()=>L,outerProduct:()=>VN,pad:()=>xa,pad1d:()=>UN,pad2d:()=>GN,pad3d:()=>HN,pad4d:()=>jN,pool:()=>kw,pow:()=>ur,prelu:()=>fd,print:()=>Ov,prod:()=>Iw,profile:()=>QM,raggedGather:()=>qN,raggedRange:()=>KN,raggedTensorToTensor:()=>XN,rand:()=>YN,randomGamma:()=>eT,randomNormal:()=>Xm,randomStandardNormal:()=>tT,randomUniform:()=>Es,randomUniformInt:()=>nT,range:()=>gi,ready:()=>nO,real:()=>zl,reciprocal:()=>Ew,registerBackend:()=>Om,registerCallbackConstructor:()=>dj,registerGradient:()=>KS,registerKernel:()=>ed,registerOp:()=>mq,regularizers:()=>OC,relu:()=>Ke,relu6:()=>Ym,removeBackend:()=>aO,reshape:()=>W,reverse:()=>ba,reverse1d:()=>aT,reverse2d:()=>rT,reverse3d:()=>sT,reverse4d:()=>iT,rfft:()=>yd,round:()=>Zm,rsqrt:()=>Jm,scalar:()=>xe,scatterND:()=>gT,scatter_util:()=>sf,searchSorted:()=>Km,selu:()=>Qm,separableConv2d:()=>_s,sequential:()=>cj,serialization:()=>ne,setBackend:()=>tO,setPlatform:()=>iO,setThreadsCount:()=>Efe,setWasmPath:()=>Tfe,setWasmPaths:()=>Cfe,setWebGLContext:()=>D_,setdiff1dAsync:()=>oT,shared:()=>M1,sigmoid:()=>ha,sign:()=>_w,signal:()=>AT,sin:()=>ef,sinh:()=>tf,slice:()=>Ve,slice1d:()=>gd,slice2d:()=>nf,slice3d:()=>Ho,slice4d:()=>Wl,slice_util:()=>Kt,softmax:()=>qa,softplus:()=>Go,spaceToBatchND:()=>md,sparse:()=>$T,sparseToDense:()=>bT,spectral:()=>_T,split:()=>Ln,sqrt:()=>rn,square:()=>pt,squaredDifference:()=>rf,squeeze:()=>As,stack:()=>At,step:()=>jo,stridedSlice:()=>Aw,string:()=>DT,sub:()=>pe,sum:()=>fe,sumOutType:()=>Mm,tan:()=>Fw,tanh:()=>cs,tensor:()=>bn,tensor1d:()=>je,tensor2d:()=>Ea,tensor3d:()=>xd,tensor4d:()=>Fa,tensor5d:()=>lT,tensor6d:()=>uT,tensorScatterUpdate:()=>cT,tensor_util:()=>Wa,test_util:()=>ZN,tidy:()=>O,tile:()=>On,time:()=>eO,topk:()=>Dw,train:()=>Xs,transpose:()=>De,truncatedNormal:()=>lf,unique:()=>Rw,unregisterGradient:()=>yM,unregisterKernel:()=>bM,unsortedSegmentSum:()=>uf,unstack:()=>dt,upcastType:()=>fa,upperBound:()=>dT,util:()=>w,valueAndGrad:()=>z3,valueAndGrads:()=>W3,variable:()=>Mw,variableGrads:()=>ON,version:()=>Ofe,version_converter:()=>S5,version_core:()=>p4,version_cpu:()=>NK,version_layers:()=>v0,version_wasm:()=>Afe,version_webgl:()=>mee,webgl:()=>fee,webgl_util:()=>$_,where:()=>nn,whereAsync:()=>Ow,zeros:()=>It,zerosLike:()=>qe});var kR=Object.create,kv=Object.defineProperty,IR=Object.getOwnPropertyDescriptor,SR=Object.getOwnPropertyNames,NR=Object.getPrototypeOf,TR=Object.prototype.hasOwnProperty,Vt=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),_e=(e,t)=>{for(var n in t)kv(e,n,{get:t[n],enumerable:!0})},CR=(e,t,n,a)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let r of SR(t))!TR.call(e,r)&&r!==n&&kv(e,r,{get:()=>t[r],enumerable:!(a=IR(t,r))||a.enumerable});return e},xs=(e,t,n)=>(n=e!=null?kR(NR(e)):{},CR(t||!e||!e.__esModule?kv(n,\"default\",{value:e,enumerable:!0}):n,e)),ER=Vt((e,t)=>{t.exports=a;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(S){}function a(S,M,B){this.low=S|0,this.high=M|0,this.unsigned=!!B}a.prototype.__isLong__,Object.defineProperty(a.prototype,\"__isLong__\",{value:!0});function r(S){return(S&&S.__isLong__)===!0}a.isLong=r;var s={},i={};function o(S,M){var B,U,H;return M?(S>>>=0,(H=0<=S&&S<256)&&(U=i[S],U)?U:(B=u(S,(S|0)<0?-1:0,!0),H&&(i[S]=B),B)):(S|=0,(H=-128<=S&&S<128)&&(U=s[S],U)?U:(B=u(S,S<0?-1:0,!1),H&&(s[S]=B),B))}a.fromInt=o;function l(S,M){if(isNaN(S))return M?v:x;if(M){if(S<0)return v;if(S>=g)return F}else{if(S<=-b)return D;if(S+1>=b)return _}return S<0?l(-S,M).neg():u(S%f|0,S/f|0,M)}a.fromNumber=l;function u(S,M,B){return new a(S,M,B)}a.fromBits=u;var p=Math.pow;function d(S,M,B){if(S.length===0)throw Error(\"empty string\");if(S===\"NaN\"||S===\"Infinity\"||S===\"+Infinity\"||S===\"-Infinity\")return x;if(typeof M==\"number\"?(B=M,M=!1):M=!!M,B=B||10,B<2||36<B)throw RangeError(\"radix\");var U;if((U=S.indexOf(\"-\"))>0)throw Error(\"interior hyphen\");if(U===0)return d(S.substring(1),M,B).neg();for(var H=l(p(B,8)),q=x,K=0;K<S.length;K+=8){var Z=Math.min(8,S.length-K),J=parseInt(S.substring(K,K+Z),B);if(Z<8){var ee=l(p(B,Z));q=q.mul(ee).add(l(J))}else q=q.mul(H),q=q.add(l(J))}return q.unsigned=M,q}a.fromString=d;function c(S,M){return typeof S==\"number\"?l(S,M):typeof S==\"string\"?d(S,M):u(S.low,S.high,typeof M==\"boolean\"?M:S.unsigned)}a.fromValue=c;var h=65536,m=1<<24,f=h*h,g=f*f,b=g/2,y=o(m),x=o(0);a.ZERO=x;var v=o(0,!0);a.UZERO=v;var I=o(1);a.ONE=I;var N=o(1,!0);a.UONE=N;var C=o(-1);a.NEG_ONE=C;var _=u(-1,2147483647,!1);a.MAX_VALUE=_;var F=u(-1,-1,!0);a.MAX_UNSIGNED_VALUE=F;var D=u(0,-2147483648,!1);a.MIN_VALUE=D;var $=a.prototype;$.toInt=function(){return this.unsigned?this.low>>>0:this.low},$.toNumber=function(){return this.unsigned?(this.high>>>0)*f+(this.low>>>0):this.high*f+(this.low>>>0)},$.toString=function(S){if(S=S||10,S<2||36<S)throw RangeError(\"radix\");if(this.isZero())return\"0\";if(this.isNegative())if(this.eq(D)){var M=l(S),B=this.div(M),U=B.mul(M).sub(this);return B.toString(S)+U.toInt().toString(S)}else return\"-\"+this.neg().toString(S);for(var H=l(p(S,6),this.unsigned),q=this,K=\"\";;){var Z=q.div(H),J=q.sub(Z.mul(H)).toInt()>>>0,ee=J.toString(S);if(q=Z,q.isZero())return ee+K;for(;ee.length<6;)ee=\"0\"+ee;K=\"\"+ee+K}},$.getHighBits=function(){return this.high},$.getHighBitsUnsigned=function(){return this.high>>>0},$.getLowBits=function(){return this.low},$.getLowBitsUnsigned=function(){return this.low>>>0},$.getNumBitsAbs=function(){if(this.isNegative())return this.eq(D)?64:this.neg().getNumBitsAbs();for(var S=this.high!=0?this.high:this.low,M=31;M>0&&!(S&1<<M);M--);return this.high!=0?M+33:M+1},$.isZero=function(){return this.high===0&&this.low===0},$.eqz=$.isZero,$.isNegative=function(){return!this.unsigned&&this.high<0},$.isPositive=function(){return this.unsigned||this.high>=0},$.isOdd=function(){return(this.low&1)===1},$.isEven=function(){return(this.low&1)===0},$.equals=function(S){return r(S)||(S=c(S)),this.unsigned!==S.unsigned&&this.high>>>31===1&&S.high>>>31===1?!1:this.high===S.high&&this.low===S.low},$.eq=$.equals,$.notEquals=function(S){return!this.eq(S)},$.neq=$.notEquals,$.ne=$.notEquals,$.lessThan=function(S){return this.comp(S)<0},$.lt=$.lessThan,$.lessThanOrEqual=function(S){return this.comp(S)<=0},$.lte=$.lessThanOrEqual,$.le=$.lessThanOrEqual,$.greaterThan=function(S){return this.comp(S)>0},$.gt=$.greaterThan,$.greaterThanOrEqual=function(S){return this.comp(S)>=0},$.gte=$.greaterThanOrEqual,$.ge=$.greaterThanOrEqual,$.compare=function(S){if(r(S)||(S=c(S)),this.eq(S))return 0;var M=this.isNegative(),B=S.isNegative();return M&&!B?-1:!M&&B?1:this.unsigned?S.high>>>0>this.high>>>0||S.high===this.high&&S.low>>>0>this.low>>>0?-1:1:this.sub(S).isNegative()?-1:1},$.comp=$.compare,$.negate=function(){return!this.unsigned&&this.eq(D)?D:this.not().add(I)},$.neg=$.negate,$.add=function(S){r(S)||(S=c(S));var M=this.high>>>16,B=this.high&65535,U=this.low>>>16,H=this.low&65535,q=S.high>>>16,K=S.high&65535,Z=S.low>>>16,J=S.low&65535,ee=0,ae=0,te=0,se=0;return se+=H+J,te+=se>>>16,se&=65535,te+=U+Z,ae+=te>>>16,te&=65535,ae+=B+K,ee+=ae>>>16,ae&=65535,ee+=M+q,ee&=65535,u(te<<16|se,ee<<16|ae,this.unsigned)},$.subtract=function(S){return r(S)||(S=c(S)),this.add(S.neg())},$.sub=$.subtract,$.multiply=function(S){if(this.isZero())return x;if(r(S)||(S=c(S)),n){var M=n.mul(this.low,this.high,S.low,S.high);return u(M,n.get_high(),this.unsigned)}if(S.isZero())return x;if(this.eq(D))return S.isOdd()?D:x;if(S.eq(D))return this.isOdd()?D:x;if(this.isNegative())return S.isNegative()?this.neg().mul(S.neg()):this.neg().mul(S).neg();if(S.isNegative())return this.mul(S.neg()).neg();if(this.lt(y)&&S.lt(y))return l(this.toNumber()*S.toNumber(),this.unsigned);var B=this.high>>>16,U=this.high&65535,H=this.low>>>16,q=this.low&65535,K=S.high>>>16,Z=S.high&65535,J=S.low>>>16,ee=S.low&65535,ae=0,te=0,se=0,ie=0;return ie+=q*ee,se+=ie>>>16,ie&=65535,se+=H*ee,te+=se>>>16,se&=65535,se+=q*J,te+=se>>>16,se&=65535,te+=U*ee,ae+=te>>>16,te&=65535,te+=H*J,ae+=te>>>16,te&=65535,te+=q*Z,ae+=te>>>16,te&=65535,ae+=B*ee+U*J+H*Z+q*K,ae&=65535,u(se<<16|ie,ae<<16|te,this.unsigned)},$.mul=$.multiply,$.divide=function(S){if(r(S)||(S=c(S)),S.isZero())throw Error(\"division by zero\");if(n){if(!this.unsigned&&this.high===-2147483648&&S.low===-1&&S.high===-1)return this;var M=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,S.low,S.high);return u(M,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?v:x;var B,U,H;if(this.unsigned){if(S.unsigned||(S=S.toUnsigned()),S.gt(this))return v;if(S.gt(this.shru(1)))return N;H=v}else{if(this.eq(D)){if(S.eq(I)||S.eq(C))return D;if(S.eq(D))return I;var q=this.shr(1);return B=q.div(S).shl(1),B.eq(x)?S.isNegative()?I:C:(U=this.sub(S.mul(B)),H=B.add(U.div(S)),H)}else if(S.eq(D))return this.unsigned?v:x;if(this.isNegative())return S.isNegative()?this.neg().div(S.neg()):this.neg().div(S).neg();if(S.isNegative())return this.div(S.neg()).neg();H=x}for(U=this;U.gte(S);){B=Math.max(1,Math.floor(U.toNumber()/S.toNumber()));for(var K=Math.ceil(Math.log(B)/Math.LN2),Z=K<=48?1:p(2,K-48),J=l(B),ee=J.mul(S);ee.isNegative()||ee.gt(U);)B-=Z,J=l(B,this.unsigned),ee=J.mul(S);J.isZero()&&(J=I),H=H.add(J),U=U.sub(ee)}return H},$.div=$.divide,$.modulo=function(S){if(r(S)||(S=c(S)),n){var M=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,S.low,S.high);return u(M,n.get_high(),this.unsigned)}return this.sub(this.div(S).mul(S))},$.mod=$.modulo,$.rem=$.modulo,$.not=function(){return u(~this.low,~this.high,this.unsigned)},$.and=function(S){return r(S)||(S=c(S)),u(this.low&S.low,this.high&S.high,this.unsigned)},$.or=function(S){return r(S)||(S=c(S)),u(this.low|S.low,this.high|S.high,this.unsigned)},$.xor=function(S){return r(S)||(S=c(S)),u(this.low^S.low,this.high^S.high,this.unsigned)},$.shiftLeft=function(S){return r(S)&&(S=S.toInt()),(S&=63)===0?this:S<32?u(this.low<<S,this.high<<S|this.low>>>32-S,this.unsigned):u(0,this.low<<S-32,this.unsigned)},$.shl=$.shiftLeft,$.shiftRight=function(S){return r(S)&&(S=S.toInt()),(S&=63)===0?this:S<32?u(this.low>>>S|this.high<<32-S,this.high>>S,this.unsigned):u(this.high>>S-32,this.high>=0?0:-1,this.unsigned)},$.shr=$.shiftRight,$.shiftRightUnsigned=function(S){if(r(S)&&(S=S.toInt()),S&=63,S===0)return this;var M=this.high;if(S<32){var B=this.low;return u(B>>>S|M<<32-S,M>>>S,this.unsigned)}else return S===32?u(M,0,this.unsigned):u(M>>>S-32,0,this.unsigned)},$.shru=$.shiftRightUnsigned,$.shr_u=$.shiftRightUnsigned,$.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},$.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},$.toBytes=function(S){return S?this.toBytesLE():this.toBytesBE()},$.toBytesLE=function(){var S=this.high,M=this.low;return[M&255,M>>>8&255,M>>>16&255,M>>>24,S&255,S>>>8&255,S>>>16&255,S>>>24]},$.toBytesBE=function(){var S=this.high,M=this.low;return[S>>>24,S>>>16&255,S>>>8&255,S&255,M>>>24,M>>>16&255,M>>>8&255,M&255]},a.fromBytes=function(S,M,B){return B?a.fromBytesLE(S,M):a.fromBytesBE(S,M)},a.fromBytesLE=function(S,M){return new a(S[0]|S[1]<<8|S[2]<<16|S[3]<<24,S[4]|S[5]<<8|S[6]<<16|S[7]<<24,M)},a.fromBytesBE=function(S,M){return new a(S[4]<<24|S[5]<<16|S[6]<<8|S[7],S[0]<<24|S[1]<<16|S[2]<<8|S[3],M)}}),_R=Vt(()=>{}),AR=Vt(()=>{}),FR=Vt((e,t)=>{(function(n,a,r){function s(u){var p=this,d=l();p.next=function(){var c=2091639*p.s0+p.c*23283064365386963e-26;return p.s0=p.s1,p.s1=p.s2,p.s2=c-(p.c=c|0)},p.c=1,p.s0=d(\" \"),p.s1=d(\" \"),p.s2=d(\" \"),p.s0-=d(u),p.s0<0&&(p.s0+=1),p.s1-=d(u),p.s1<0&&(p.s1+=1),p.s2-=d(u),p.s2<0&&(p.s2+=1),d=null}function i(u,p){return p.c=u.c,p.s0=u.s0,p.s1=u.s1,p.s2=u.s2,p}function o(u,p){var d=new s(u),c=p&&p.state,h=d.next;return h.int32=function(){return d.next()*4294967296|0},h.double=function(){return h()+(h()*2097152|0)*11102230246251565e-32},h.quick=h,c&&(typeof c==\"object\"&&i(c,d),h.state=function(){return i(d,{})}),h}function l(){var u=4022871197,p=function(d){d=String(d);for(var c=0;c<d.length;c++){u+=d.charCodeAt(c);var h=.02519603282416938*u;u=h>>>0,h-=u,h*=u,u=h>>>0,h-=u,u+=h*4294967296}return(u>>>0)*23283064365386963e-26};return p}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.alea=o})(e,typeof t==\"object\"&&t,typeof define==\"function\"&&define)}),$R=Vt((e,t)=>{(function(n,a,r){function s(l){var u=this,p=\"\";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var c=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^c^c>>>8},l===(l|0)?u.x=l:p+=l;for(var d=0;d<p.length+64;d++)u.x^=p.charCodeAt(d)|0,u.next()}function i(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u}function o(l,u){var p=new s(l),d=u&&u.state,c=function(){return(p.next()>>>0)/4294967296};return c.double=function(){do var h=p.next()>>>11,m=(p.next()>>>0)/4294967296,f=(h+m)/(1<<21);while(f===0);return f},c.int32=p.next,c.quick=c,d&&(typeof d==\"object\"&&i(d,p),c.state=function(){return i(p,{})}),c}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xor128=o})(e,typeof t==\"object\"&&t,typeof define==\"function\"&&define)}),DR=Vt((e,t)=>{(function(n,a,r){function s(l){var u=this,p=\"\";u.next=function(){var c=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(c^c<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,l===(l|0)?u.x=l:p+=l;for(var d=0;d<p.length+64;d++)u.x^=p.charCodeAt(d)|0,d==p.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function i(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u.v=l.v,u.d=l.d,u}function o(l,u){var p=new s(l),d=u&&u.state,c=function(){return(p.next()>>>0)/4294967296};return c.double=function(){do var h=p.next()>>>11,m=(p.next()>>>0)/4294967296,f=(h+m)/(1<<21);while(f===0);return f},c.int32=p.next,c.quick=c,d&&(typeof d==\"object\"&&i(d,p),c.state=function(){return i(p,{})}),c}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xorwow=o})(e,typeof t==\"object\"&&t,typeof define==\"function\"&&define)}),RR=Vt((e,t)=>{(function(n,a,r){function s(l){var u=this;u.next=function(){var d=u.x,c=u.i,h,m,f;return h=d[c],h^=h>>>7,m=h^h<<24,h=d[c+1&7],m^=h^h>>>10,h=d[c+3&7],m^=h^h>>>3,h=d[c+4&7],m^=h^h<<7,h=d[c+7&7],h=h^h<<13,m^=h^h<<9,d[c]=m,u.i=c+1&7,m};function p(d,c){var h,m,f=[];if(c===(c|0))m=f[0]=c;else for(c=\"\"+c,h=0;h<c.length;++h)f[h&7]=f[h&7]<<15^c.charCodeAt(h)+f[h+1&7]<<13;for(;f.length<8;)f.push(0);for(h=0;h<8&&f[h]===0;++h);for(h==8?m=f[7]=-1:m=f[h],d.x=f,d.i=0,h=256;h>0;--h)d.next()}p(u,l)}function i(l,u){return u.x=l.x.slice(),u.i=l.i,u}function o(l,u){l==null&&(l=+new Date);var p=new s(l),d=u&&u.state,c=function(){return(p.next()>>>0)/4294967296};return c.double=function(){do var h=p.next()>>>11,m=(p.next()>>>0)/4294967296,f=(h+m)/(1<<21);while(f===0);return f},c.int32=p.next,c.quick=c,d&&(d.x&&i(d,p),c.state=function(){return i(p,{})}),c}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xorshift7=o})(e,typeof t==\"object\"&&t,typeof define==\"function\"&&define)}),MR=Vt((e,t)=>{(function(n,a,r){function s(l){var u=this;u.next=function(){var d=u.w,c=u.X,h=u.i,m,f;return u.w=d=d+1640531527|0,f=c[h+34&127],m=c[h=h+1&127],f^=f<<13,m^=m<<17,f^=f>>>15,m^=m>>>12,f=c[h]=f^m,u.i=h,f+(d^d>>>16)|0};function p(d,c){var h,m,f,g,b,y=[],x=128;for(c===(c|0)?(m=c,c=null):(c=c+\"\\0\",m=0,x=Math.max(x,c.length)),f=0,g=-32;g<x;++g)c&&(m^=c.charCodeAt((g+32)%c.length)),g===0&&(b=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,g>=0&&(b=b+1640531527|0,h=y[g&127]^=m+b,f=h==0?f+1:0);for(f>=128&&(y[(c&&c.length||0)&127]=-1),f=127,g=4*128;g>0;--g)m=y[f+34&127],h=y[f=f+1&127],m^=m<<13,h^=h<<17,m^=m>>>15,h^=h>>>12,y[f]=m^h;d.w=b,d.X=y,d.i=f}p(u,l)}function i(l,u){return u.i=l.i,u.w=l.w,u.X=l.X.slice(),u}function o(l,u){l==null&&(l=+new Date);var p=new s(l),d=u&&u.state,c=function(){return(p.next()>>>0)/4294967296};return c.double=function(){do var h=p.next()>>>11,m=(p.next()>>>0)/4294967296,f=(h+m)/(1<<21);while(f===0);return f},c.int32=p.next,c.quick=c,d&&(d.X&&i(d,p),c.state=function(){return i(p,{})}),c}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xor4096=o})(e,typeof t==\"object\"&&t,typeof define==\"function\"&&define)}),OR=Vt((e,t)=>{(function(n,a,r){function s(l){var u=this,p=\"\";u.next=function(){var c=u.b,h=u.c,m=u.d,f=u.a;return c=c<<25^c>>>7^h,h=h-m|0,m=m<<24^m>>>8^f,f=f-c|0,u.b=c=c<<20^c>>>12^h,u.c=h=h-m|0,u.d=m<<16^h>>>16^f,u.a=f-c|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,l===Math.floor(l)?(u.a=l/4294967296|0,u.b=l|0):p+=l;for(var d=0;d<p.length+20;d++)u.b^=p.charCodeAt(d)|0,u.next()}function i(l,u){return u.a=l.a,u.b=l.b,u.c=l.c,u.d=l.d,u}function o(l,u){var p=new s(l),d=u&&u.state,c=function(){return(p.next()>>>0)/4294967296};return c.double=function(){do var h=p.next()>>>11,m=(p.next()>>>0)/4294967296,f=(h+m)/(1<<21);while(f===0);return f},c.int32=p.next,c.quick=c,d&&(typeof d==\"object\"&&i(d,p),c.state=function(){return i(p,{})}),c}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.tychei=o})(e,typeof t==\"object\"&&t,typeof define==\"function\"&&define)}),PR=Vt(()=>{}),LR=Vt((e,t)=>{(function(n,a,r){var s=256,i=6,o=52,l=\"random\",u=r.pow(s,i),p=r.pow(2,o),d=p*2,c=s-1,h;function m(I,N,C){var _=[];N=N==!0?{entropy:!0}:N||{};var F=y(b(N.entropy?[I,v(a)]:I==null?x():I,3),_),D=new f(_),$=function(){for(var S=D.g(i),M=u,B=0;S<p;)S=(S+B)*s,M*=s,B=D.g(1);for(;S>=d;)S/=2,M/=2,B>>>=1;return(S+B)/M};return $.int32=function(){return D.g(4)|0},$.quick=function(){return D.g(4)/4294967296},$.double=$,y(v(D.S),a),(N.pass||C||function(S,M,B,U){return U&&(U.S&&g(U,D),S.state=function(){return g(D,{})}),B?(r[l]=S,M):S})($,F,\"global\"in N?N.global:this==r,N.state)}function f(I){var N,C=I.length,_=this,F=0,D=_.i=_.j=0,$=_.S=[];for(C||(I=[C++]);F<s;)$[F]=F++;for(F=0;F<s;F++)$[F]=$[D=c&D+I[F%C]+(N=$[F])],$[D]=N;(_.g=function(S){for(var M,B=0,U=_.i,H=_.j,q=_.S;S--;)M=q[U=c&U+1],B=B*s+q[c&(q[U]=q[H=c&H+M])+(q[H]=M)];return _.i=U,_.j=H,B})(s)}function g(I,N){return N.i=I.i,N.j=I.j,N.S=I.S.slice(),N}function b(I,N){var C=[],_=typeof I,F;if(N&&_==\"object\")for(F in I)try{C.push(b(I[F],N-1))}catch(D){}return C.length?C:_==\"string\"?I:I+\"\\0\"}function y(I,N){for(var C=I+\"\",_,F=0;F<C.length;)N[c&F]=c&(_^=N[c&F]*19)+C.charCodeAt(F++);return v(N)}function x(){try{var I;return h&&(I=h.randomBytes)?I=I(s):(I=new Uint8Array(s),(n.crypto||n.msCrypto).getRandomValues(I)),v(I)}catch(_){var N=n.navigator,C=N&&N.plugins;return[+new Date,n,C,n.screen,v(a)]}}function v(I){return String.fromCharCode.apply(0,I)}if(y(r.random(),a),typeof t==\"object\"&&t.exports){t.exports=m;try{h=PR()}catch(I){}}else typeof define==\"function\"&&__webpack_require__.amdO?define(function(){return m}):r[\"seed\"+l]=m})(typeof self!=\"undefined\"?self:e,[],Math)}),bm=Vt((e,t)=>{var n=FR(),a=$R(),r=DR(),s=RR(),i=MR(),o=OR(),l=LR();l.alea=n,l.xor128=a,l.xorwow=r,l.xorshift7=s,l.xor4096=i,l.tychei=o,t.exports=l}),FS=Vt(()=>{}),Iv=Vt(()=>{}),$S=Vt(()=>{}),zR=Vt(()=>{}),WR=Vt(()=>{}),BR=Vt(()=>{}),VR=Vt((e,t)=>{var n=(()=>{var a=typeof document!=\"undefined\"&&document.currentScript?document.currentScript.src:void 0;return  true&&(a=a||__filename),function(r){r=r||{};function s(){return ue.buffer!=Re&&ut(ue.buffer),gt}function i(){return ue.buffer!=Re&&ut(ue.buffer),Gn}function o(){return ue.buffer!=Re&&ut(ue.buffer),Ot}function l(){return ue.buffer!=Re&&ut(ue.buffer),un}function u(){return ue.buffer!=Re&&ut(ue.buffer),Fn}function p(){return ue.buffer!=Re&&ut(ue.buffer),oa}function d(){return ue.buffer!=Re&&ut(ue.buffer),$n}var c=typeof r!=\"undefined\"?r:{},h,m;c.ready=new Promise(function(R,j){h=R,m=j});var f;typeof process!=\"undefined\"&&process.listeners&&(f={uncaughtException:process.listeners(\"uncaughtException\"),unhandledRejection:process.listeners(\"unhandledRejection\")});var g=Object.assign({},c),b=[],y=\"./this.program\",x=(R,j)=>{throw j},v=typeof window==\"object\",I=typeof importScripts==\"function\",N=typeof process==\"object\"&&typeof process.versions==\"object\"&&typeof process.versions.node==\"string\",C=c.ENVIRONMENT_IS_PTHREAD||!1,_=\"\";function F(R){return c.locateFile?c.locateFile(R,_):_+R}var D,$,S,M;function B(R){R instanceof Gs||J(\"exiting due to exception: \"+R)}if(N){var U=Iv(),H=$S();I?_=H.dirname(_)+\"/\":_=__dirname+\"/\",D=(j,le)=>(j=gl(j)?new URL(j):H.normalize(j),U.readFileSync(j,le?void 0:\"utf8\")),S=j=>{var le=D(j,!0);return le.buffer||(le=new Uint8Array(le)),le},$=(j,le,Ne)=>{j=gl(j)?new URL(j):H.normalize(j),U.readFile(j,function(Me,Fe){Me?Ne(Me):le(Fe.buffer)})},process.argv.length>1&&(y=process.argv[1].replace(/\\\\/g,\"/\")),b=process.argv.slice(2),process.on(\"uncaughtException\",function(j){if(!(j instanceof Gs))throw j}),process.on(\"unhandledRejection\",function(j){throw j}),x=(j,le)=>{if(Ia())throw process.exitCode=j,le;B(le),process.exit(j)},c.inspect=function(){return\"[Emscripten Module object]\"};let R;try{R=zR()}catch(j){throw console.error('The \"worker_threads\" module is not supported in this node.js build - perhaps a newer version is needed?'),j}__webpack_require__.g.Worker=R.Worker}else(v||I)&&(I?_=self.location.href:typeof document!=\"undefined\"&&document.currentScript&&(_=document.currentScript.src),typeof a!=\"undefined\"&&a&&(_=a),_.indexOf(\"blob:\")!==0?_=_.substr(0,_.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):_=\"\",N||(D=R=>{var j=new XMLHttpRequest;return j.open(\"GET\",R,!1),j.send(null),j.responseText},I&&(S=R=>{var j=new XMLHttpRequest;return j.open(\"GET\",R,!1),j.responseType=\"arraybuffer\",j.send(null),new Uint8Array(j.response)}),$=(R,j,le)=>{var Ne=new XMLHttpRequest;Ne.open(\"GET\",R,!0),Ne.responseType=\"arraybuffer\",Ne.onload=()=>{if(Ne.status==200||Ne.status==0&&Ne.response){j(Ne.response);return}le()},Ne.onerror=le,Ne.send(null)}),M=R=>document.title=R);N&&typeof performance==\"undefined\"&&(__webpack_require__.g.performance=WR().performance);var q=console.log.bind(console),K=console.warn.bind(console);N&&(q=R=>U.writeSync(1,R+`\n`),K=R=>U.writeSync(2,R+`\n`));var Z=c.print||q,J=c.printErr||K;Object.assign(c,g),g=null,c.arguments&&(b=c.arguments),c.thisProgram&&(y=c.thisProgram),c.quit&&(x=c.quit);var ee=4,ae=Atomics.load,te=Atomics.store,se=Atomics.compareExchange,ie;c.wasmBinary&&(ie=c.wasmBinary);var ve=c.noExitRuntime||!0;typeof WebAssembly!=\"object\"&&Us(\"no native wasm support detected\");var ue,ye,ke=!1,Se;function Le(R,j){R||Us(j)}var Ue=typeof TextDecoder!=\"undefined\"?new TextDecoder(\"utf8\"):void 0;function mt(R,j,le){j>>>=0;for(var Ne=j+le,Me=j;R[Me]&&!(Me>=Ne);)++Me;if(Me-j>16&&R.buffer&&Ue)return Ue.decode(R.buffer instanceof SharedArrayBuffer?R.slice(j,Me):R.subarray(j,Me));for(var Fe=\"\";j<Me;){var me=R[j++];if(!(me&128)){Fe+=String.fromCharCode(me);continue}var we=R[j++]&63;if((me&224)==192){Fe+=String.fromCharCode((me&31)<<6|we);continue}var Tt=R[j++]&63;if((me&240)==224?me=(me&15)<<12|we<<6|Tt:me=(me&7)<<18|we<<12|Tt<<6|R[j++]&63,me<65536)Fe+=String.fromCharCode(me);else{var ua=me-65536;Fe+=String.fromCharCode(55296|ua>>10,56320|ua&1023)}}return Fe}function st(R,j){return R>>>=0,R?mt(i(),R,j):\"\"}function tt(R,j,le,Ne){if(le>>>=0,!(Ne>0))return 0;for(var Me=le,Fe=le+Ne-1,me=0;me<R.length;++me){var we=R.charCodeAt(me);if(we>=55296&&we<=57343){var Tt=R.charCodeAt(++me);we=65536+((we&1023)<<10)|Tt&1023}if(we<=127){if(le>=Fe)break;j[le++>>>0]=we}else if(we<=2047){if(le+1>=Fe)break;j[le++>>>0]=192|we>>6,j[le++>>>0]=128|we&63}else if(we<=65535){if(le+2>=Fe)break;j[le++>>>0]=224|we>>12,j[le++>>>0]=128|we>>6&63,j[le++>>>0]=128|we&63}else{if(le+3>=Fe)break;j[le++>>>0]=240|we>>18,j[le++>>>0]=128|we>>12&63,j[le++>>>0]=128|we>>6&63,j[le++>>>0]=128|we&63}}return j[le>>>0]=0,le-Me}function nt(R,j,le){return tt(R,i(),j,le)}var Re,gt,Gn,Ot,ia,un,Fn,oa,$n;C&&(Re=c.buffer);function ut(R){Re=R,c.HEAP8=gt=new Int8Array(R),c.HEAP16=Ot=new Int16Array(R),c.HEAP32=un=new Int32Array(R),c.HEAPU8=Gn=new Uint8Array(R),c.HEAPU16=ia=new Uint16Array(R),c.HEAPU32=Fn=new Uint32Array(R),c.HEAPF32=oa=new Float32Array(R),c.HEAPF64=$n=new Float64Array(R)}var Dn=c.INITIAL_MEMORY||16777216;if(C)ue=c.wasmMemory,Re=c.buffer;else if(c.wasmMemory)ue=c.wasmMemory;else if(ue=new WebAssembly.Memory({initial:Dn/65536,maximum:65536,shared:!0}),!(ue.buffer instanceof SharedArrayBuffer))throw J(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"),N&&J(\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)\"),Error(\"bad memory\");ue&&(Re=ue.buffer),Dn=Re.byteLength,ut(Re);var Hn,xr=[],ml=[],Za=[],Wp=!1;function Ia(){return ve}function Ur(){if(c.preRun)for(typeof c.preRun==\"function\"&&(c.preRun=[c.preRun]);c.preRun.length;)Sg(c.preRun.shift());Vp(xr)}function Jt(){Wp=!0,!C&&Vp(ml)}function Hd(){if(!C){if(c.postRun)for(typeof c.postRun==\"function\"&&(c.postRun=[c.postRun]);c.postRun.length;)Rk(c.postRun.shift());Vp(Za)}}function Sg(R){xr.unshift(R)}function Ng(R){ml.unshift(R)}function Rk(R){Za.unshift(R)}var Gr=0,fl=null,vr=null;function Tg(R){Gr++,c.monitorRunDependencies&&c.monitorRunDependencies(Gr)}function jd(R){if(Gr--,c.monitorRunDependencies&&c.monitorRunDependencies(Gr),Gr==0&&(fl!==null&&(clearInterval(fl),fl=null),vr)){var j=vr;vr=null,j()}}function Us(R){c.onAbort&&c.onAbort(R),R=\"Aborted(\"+R+\")\",J(R),ke=!0,Se=1,R+=\". Build with -sASSERTIONS for more info.\";var j=new WebAssembly.RuntimeError(R);throw m(j),j}var Cg=\"data:application/octet-stream;base64,\";function qd(R){return R.startsWith(Cg)}function gl(R){return R.startsWith(\"file://\")}var gn;gn=\"tfjs-backend-wasm-threaded-simd.wasm\",qd(gn)||(gn=F(gn));function Kd(R){try{if(R==gn&&ie)return new Uint8Array(ie);if(S)return S(R);throw\"both async and sync fetching of the wasm failed\"}catch(j){Us(j)}}function Eg(){if(!ie&&(v||I)){if(typeof fetch==\"function\"&&!gl(gn))return fetch(gn,{credentials:\"same-origin\"}).then(function(R){if(!R.ok)throw\"failed to load wasm binary file at '\"+gn+\"'\";return R.arrayBuffer()}).catch(function(){return Kd(gn)});if($)return new Promise(function(R,j){$(gn,function(le){R(new Uint8Array(le))},j)})}return Promise.resolve().then(function(){return Kd(gn)})}function _g(){var R={env:oh,wasi_snapshot_preview1:oh};function j(me,we){var Tt=me.exports;if(c.asm=Tt,Lg(c.asm._emscripten_tls_init),Hn=c.asm.__indirect_function_table,Ng(c.asm.__wasm_call_ctors),ye=we,!C){var ua=Ae.unusedWorkers.length;Ae.unusedWorkers.forEach(function(kr){Ae.loadWasmModuleToWorker(kr,function(){--ua||jd(\"wasm-instantiate\")})})}}C||Tg(\"wasm-instantiate\");function le(me){j(me.instance,me.module)}function Ne(me){return Eg().then(function(we){return WebAssembly.instantiate(we,R)}).then(function(we){return we}).then(me,function(we){J(\"failed to asynchronously prepare wasm: \"+we),Us(we)})}function Me(){return!ie&&typeof WebAssembly.instantiateStreaming==\"function\"&&!qd(gn)&&!gl(gn)&&!N&&typeof fetch==\"function\"?fetch(gn,{credentials:\"same-origin\"}).then(function(me){var we=WebAssembly.instantiateStreaming(me,R);return we.then(le,function(Tt){return J(\"wasm streaming compile failed: \"+Tt),J(\"falling back to ArrayBuffer instantiation\"),Ne(le)})}):Ne(le)}if(c.instantiateWasm)try{var Fe=c.instantiateWasm(R,j);return Fe}catch(me){J(\"Module.instantiateWasm callback failed with error: \"+me),m(me)}return Me().catch(m),{}}var Mk,Ok,Xd={};function Gs(R){this.name=\"ExitStatus\",this.message=\"Program terminated with exit(\"+R+\")\",this.status=R}function Ag(R){var j=Ae.pthreads[R];delete Ae.pthreads[R],j.terminate(),ex(R),Ae.runningWorkers.splice(Ae.runningWorkers.indexOf(j),1),j.pthread_ptr=0}function Fg(R){var j=Ae.pthreads[R];j.postMessage({cmd:\"cancel\"})}function Bp(R){var j=Ae.pthreads[R];Le(j),Ae.returnWorkerToPool(j)}function $g(R){var j=Ae.getNewWorker();if(!j)return 6;Ae.runningWorkers.push(j),Ae.pthreads[R.pthread_ptr]=j,j.pthread_ptr=R.pthread_ptr;var le={cmd:\"run\",start_routine:R.startRoutine,arg:R.arg,pthread_ptr:R.pthread_ptr};return j.runPthread=()=>{N&&j.ref(),j.postMessage(le,R.transferList),delete j.runPthread},j.loaded&&j.runPthread(),0}var Yd={varargs:void 0,get:function(){Yd.varargs+=4;var R=l()[Yd.varargs-4>>>2];return R},getStr:function(R){var j=st(R);return j}};function Zd(R){if(C)return Hr(1,1,R);Se=R,Ia()||(Ae.terminateAllThreads(),c.onExit&&c.onExit(R),ke=!0),x(R,new Gs(R))}function Dg(R,j){if(Se=R,!j&&C)throw Qd(R),\"unwind\";Zd(R)}var Jd=Dg;function Rg(R){if(R instanceof Gs||R==\"unwind\")return Se;x(1,R)}var Ae={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){C?Ae.initWorker():Ae.initMainThread()},initMainThread:function(){for(var R=8;R--;)Ae.allocateUnusedWorker()},initWorker:function(){ve=!1},setExitStatus:function(R){Se=R},terminateAllThreads:function(){for(var R of Object.values(Ae.pthreads))Ae.returnWorkerToPool(R);for(var R of Ae.unusedWorkers)R.terminate();Ae.unusedWorkers=[]},returnWorkerToPool:function(R){var j=R.pthread_ptr;delete Ae.pthreads[j],Ae.unusedWorkers.push(R),Ae.runningWorkers.splice(Ae.runningWorkers.indexOf(R),1),R.pthread_ptr=0,N&&R.unref(),ex(j)},receiveObjectTransfer:function(R){},threadInitTLS:function(){Ae.tlsInitFunctions.forEach(R=>R())},loadWasmModuleToWorker:function(R,j){R.onmessage=Fe=>{var me=Fe.data,we=me.cmd;if(R.pthread_ptr&&(Ae.currentProxiedOperationCallerThread=R.pthread_ptr),me.targetThread&&me.targetThread!=hh()){var Tt=Ae.pthreads[me.targetThread];Tt?Tt.postMessage(me,me.transferList):J('Internal error! Worker sent a message \"'+we+'\" to target pthread '+me.targetThread+\", but that thread no longer exists!\"),Ae.currentProxiedOperationCallerThread=void 0;return}we===\"processProxyingQueue\"?Up(me.queue):we===\"spawnThread\"?$g(me):we===\"cleanupThread\"?Bp(me.thread):we===\"killThread\"?Ag(me.thread):we===\"cancelThread\"?Fg(me.thread):we===\"loaded\"?(R.loaded=!0,N&&R.unref(),j&&j(R),R.runPthread&&R.runPthread()):we===\"print\"?Z(\"Thread \"+me.threadId+\": \"+me.text):we===\"printErr\"?J(\"Thread \"+me.threadId+\": \"+me.text):we===\"alert\"?alert(\"Thread \"+me.threadId+\": \"+me.text):me.target===\"setimmediate\"?R.postMessage(me):we===\"callHandler\"?c[me.handler](...me.args):we&&J(\"worker sent an unknown command \"+we),Ae.currentProxiedOperationCallerThread=void 0},R.onerror=Fe=>{var me=\"worker sent an error!\";throw J(me+\" \"+Fe.filename+\":\"+Fe.lineno+\": \"+Fe.message),Fe},N&&(R.on(\"message\",function(Fe){R.onmessage({data:Fe})}),R.on(\"error\",function(Fe){R.onerror(Fe)}),R.on(\"detachedExit\",function(){}));var le=[],Ne=[\"onExit\",\"onAbort\",\"print\",\"printErr\"];for(var Me of Ne)c.hasOwnProperty(Me)&&le.push(Me);R.postMessage({cmd:\"load\",handlers:le,urlOrBlob:c.mainScriptUrlOrBlob||a,wasmMemory:ue,wasmModule:ye})},allocateUnusedWorker:function(){var R,j=F(\"tfjs-backend-wasm-threaded-simd.worker.js\");R=new Worker(j),Ae.unusedWorkers.push(R)},getNewWorker:function(){return Ae.unusedWorkers.length==0&&(Ae.allocateUnusedWorker(),Ae.loadWasmModuleToWorker(Ae.unusedWorkers[0])),Ae.unusedWorkers.pop()}};c.PThread=Ae;function Vp(R){for(;R.length>0;)R.shift()(c)}function Mg(){var R=hh(),j=l()[R+52>>>2],le=l()[R+56>>>2],Ne=j-le;Vk(j,Ne),mh(j)}c.establishStackSpace=Mg;function Qd(R){if(C)return Hr(2,0,R);try{Jd(R)}catch(j){Rg(j)}}var bl=[];function Og(R){var j=bl[R];return j||(R>=bl.length&&(bl.length=R+1),bl[R]=j=Hn.get(R)),j}function Pg(R,j){var le=Og(R)(j);Ia()?Ae.setExitStatus(le):Bk(le)}c.invokeEntryPoint=Pg;function Lg(R){Ae.tlsInitFunctions.push(R)}function zg(R){Lk(R,!I,1,!v),Ae.threadInitTLS()}function Wg(R){C?postMessage({cmd:\"cleanupThread\",thread:R}):Bp(R)}function eh(R,j,le,Ne){return C?Hr(3,1,R,j,le,Ne):th(R,j,le,Ne)}function th(R,j,le,Ne){if(typeof SharedArrayBuffer==\"undefined\")return J(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"),6;var Me=[],Fe=0;if(C&&(Me.length===0||Fe))return eh(R,j,le,Ne);if(Fe)return Fe;var me={startRoutine:le,pthread_ptr:R,arg:Ne,transferList:Me};return C?(me.cmd=\"spawnThread\",postMessage(me,Me),0):$g(me)}function Bg(){return 65536}var Vg=!0;function Ug(){return Vg}function Up(R){Atomics.store(l(),R>>2,1),hh()&&Wk(R),Atomics.compareExchange(l(),R>>2,1,0)}c.executeNotifiedProxyingQueue=Up;function Gg(R,j,le,Ne){if(R==j)setTimeout(()=>Up(Ne));else if(C)postMessage({targetThread:R,cmd:\"processProxyingQueue\",queue:Ne});else{var Me=Ae.pthreads[R];if(!Me)return;Me.postMessage({cmd:\"processProxyingQueue\",queue:Ne})}return 1}function Hg(R,j,le){return-1}function jg(){Us(\"\")}function Hs(R){Hs.shown||(Hs.shown={}),Hs.shown[R]||(Hs.shown[R]=1,N&&(R=\"warning: \"+R),J(R))}function qg(){N||I||Hs(\"Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread\")}function Kg(){return Date.now()}function nh(){return 4294901760}function Xg(){return nh()}var Gp;N?Gp=()=>{var R=process.hrtime();return R[0]*1e3+R[1]/1e6}:Gp=()=>performance.timeOrigin+performance.now();function Yg(R,j,le){i().copyWithin(R>>>0,j>>>0,j+le>>>0)}function Zg(){return N?BR().cpus().length:navigator.hardwareConcurrency}function Jg(R){var j=tx(),le=R();return mh(j),le}function Hr(R,j){var le=arguments.length-2,Ne=arguments;return Jg(()=>{for(var Me=le,Fe=fh(Me*8),me=Fe>>3,we=0;we<le;we++){var Tt=Ne[2+we];d()[me+we>>>0]=Tt}return zk(R,Me,Fe,j)})}var Hp=[];function Qg(R,j,le){Hp.length=j;for(var Ne=le>>3,Me=0;Me<j;Me++)Hp[Me]=d()[Ne+Me>>>0];var Fe=R<0,me=Fe?Xd[-R-1]:lb[R];return me.apply(null,Hp)}function eb(R){try{return ue.grow(R-Re.byteLength+65535>>>16),ut(ue.buffer),1}catch(j){}}function tb(R){var j=i().length;if(R=R>>>0,R<=j)return!1;var le=nh();if(R>le)return!1;let Ne=(Tt,ua)=>Tt+(ua-Tt%ua)%ua;for(var Me=1;Me<=4;Me*=2){var Fe=j*(1+.2/Me);Fe=Math.min(Fe,R+100663296);var me=Math.min(le,Ne(Math.max(R,Fe),65536)),we=eb(me);if(we)return!0}return!1}function nb(){throw\"unwind\"}function ah(R){return C?Hr(4,1,R):52}function rh(R,j,le,Ne,Me){return C?Hr(5,1,R,j,le,Ne,Me):70}var ab=[null,[],[]];function rb(R,j){var le=ab[R];j===0||j===10?((R===1?Z:J)(mt(le,0)),le.length=0):le.push(j)}function sh(R,j,le,Ne){if(C)return Hr(6,1,R,j,le,Ne);for(var Me=0,Fe=0;Fe<le;Fe++){var me=u()[j>>>2],we=u()[j+4>>>2];j+=8;for(var Tt=0;Tt<we;Tt++)rb(R,i()[me+Tt>>>0]);Me+=we}return u()[Ne>>>2]=Me,0}function ih(R){var j=c[\"_\"+R];return j}function sb(R,j){s().set(R,j>>>0)}function ib(R,j,le,Ne,Me){var Fe={string:pa=>{var wl=0;if(pa!=null&&pa!==0){var Hk=(pa.length<<2)+1;wl=fh(Hk),nt(pa,wl,Hk)}return wl},array:pa=>{var wl=fh(pa.length);return sb(pa,wl),wl}};function me(pa){return j===\"string\"?st(pa):j===\"boolean\"?!!pa:pa}var we=ih(R),Tt=[],ua=0;if(Ne)for(var kr=0;kr<Ne.length;kr++){var Gk=Fe[le[kr]];Gk?(ua===0&&(ua=tx()),Tt[kr]=Gk(Ne[kr])):Tt[kr]=Ne[kr]}var nx=we.apply(null,Tt);function xR(pa){return ua!==0&&mh(ua),me(pa)}return nx=xR(nx),nx}function ob(R,j,le,Ne){le=le||[];var Me=le.every(me=>me===\"number\"||me===\"boolean\"),Fe=j!==\"string\";return Fe&&Me&&!Ne?ih(R):function(){return ib(R,j,le,arguments,Ne)}}Ae.init();var lb=[null,Zd,Qd,eh,ah,rh,sh],oh={__emscripten_init_main_thread_js:zg,__emscripten_thread_cleanup:Wg,__pthread_create_js:th,_emscripten_default_pthread_stack_size:Bg,_emscripten_get_now_is_monotonic:Ug,_emscripten_notify_task_queue:Gg,_emscripten_set_offscreencanvas_size:Hg,abort:jg,emscripten_check_blocking_allowed:qg,emscripten_date_now:Kg,emscripten_get_heap_max:Xg,emscripten_get_now:Gp,emscripten_memcpy_big:Yg,emscripten_num_logical_cores:Zg,emscripten_receive_on_main_thread_js:Qg,emscripten_resize_heap:tb,emscripten_unwind_to_js_event_loop:nb,exit:Jd,fd_close:ah,fd_seek:rh,fd_write:sh,memory:ue||c.wasmMemory},Pk=_g(),ub=c.___wasm_call_ctors=function(){return(ub=c.___wasm_call_ctors=c.asm.__wasm_call_ctors).apply(null,arguments)},pb=c._init=function(){return(pb=c._init=c.asm.init).apply(null,arguments)},cb=c._init_with_threads_count=function(){return(cb=c._init_with_threads_count=c.asm.init_with_threads_count).apply(null,arguments)},db=c._get_threads_count=function(){return(db=c._get_threads_count=c.asm.get_threads_count).apply(null,arguments)},hb=c._register_tensor=function(){return(hb=c._register_tensor=c.asm.register_tensor).apply(null,arguments)},mb=c._dispose_data=function(){return(mb=c._dispose_data=c.asm.dispose_data).apply(null,arguments)},fb=c._dispose=function(){return(fb=c._dispose=c.asm.dispose).apply(null,arguments)},gb=c._Abs=function(){return(gb=c._Abs=c.asm.Abs).apply(null,arguments)},bb=c._Acos=function(){return(bb=c._Acos=c.asm.Acos).apply(null,arguments)},yb=c._Acosh=function(){return(yb=c._Acosh=c.asm.Acosh).apply(null,arguments)},xb=c._Add=function(){return(xb=c._Add=c.asm.Add).apply(null,arguments)},vb=c._AddN=function(){return(vb=c._AddN=c.asm.AddN).apply(null,arguments)},wb=c._All=function(){return(wb=c._All=c.asm.All).apply(null,arguments)},kb=c._Any=function(){return(kb=c._Any=c.asm.Any).apply(null,arguments)},Ib=c._ArgMax=function(){return(Ib=c._ArgMax=c.asm.ArgMax).apply(null,arguments)},Sb=c._ArgMin=function(){return(Sb=c._ArgMin=c.asm.ArgMin).apply(null,arguments)},Nb=c._Asin=function(){return(Nb=c._Asin=c.asm.Asin).apply(null,arguments)},Tb=c._Asinh=function(){return(Tb=c._Asinh=c.asm.Asinh).apply(null,arguments)},Cb=c._Atan=function(){return(Cb=c._Atan=c.asm.Atan).apply(null,arguments)},Eb=c._Atan2=function(){return(Eb=c._Atan2=c.asm.Atan2).apply(null,arguments)},_b=c._Atanh=function(){return(_b=c._Atanh=c.asm.Atanh).apply(null,arguments)},Ab=c._AvgPool=function(){return(Ab=c._AvgPool=c.asm.AvgPool).apply(null,arguments)},Fb=c._AvgPool3D=function(){return(Fb=c._AvgPool3D=c.asm.AvgPool3D).apply(null,arguments)},$b=c._AvgPool3DGrad=function(){return($b=c._AvgPool3DGrad=c.asm.AvgPool3DGrad).apply(null,arguments)},Db=c._AvgPoolGrad=function(){return(Db=c._AvgPoolGrad=c.asm.AvgPoolGrad).apply(null,arguments)},Rb=c._BatchMatMul=function(){return(Rb=c._BatchMatMul=c.asm.BatchMatMul).apply(null,arguments)},Mb=c._Bincount=function(){return(Mb=c._Bincount=c.asm.Bincount).apply(null,arguments)},Ob=c._BitwiseAnd=function(){return(Ob=c._BitwiseAnd=c.asm.BitwiseAnd).apply(null,arguments)},Pb=c._Ceil=function(){return(Pb=c._Ceil=c.asm.Ceil).apply(null,arguments)},Lb=c._ClipByValue=function(){return(Lb=c._ClipByValue=c.asm.ClipByValue).apply(null,arguments)},zb=c._Conv2D=function(){return(zb=c._Conv2D=c.asm.Conv2D).apply(null,arguments)},Wb=c._Conv2DBackpropInput=function(){return(Wb=c._Conv2DBackpropInput=c.asm.Conv2DBackpropInput).apply(null,arguments)},Bb=c._Conv3D=function(){return(Bb=c._Conv3D=c.asm.Conv3D).apply(null,arguments)},Vb=c._Conv3DBackpropFilterV2=function(){return(Vb=c._Conv3DBackpropFilterV2=c.asm.Conv3DBackpropFilterV2).apply(null,arguments)},Ub=c._Conv3DBackpropInputV2=function(){return(Ub=c._Conv3DBackpropInputV2=c.asm.Conv3DBackpropInputV2).apply(null,arguments)},Gb=c._Cos=function(){return(Gb=c._Cos=c.asm.Cos).apply(null,arguments)},Hb=c._Cosh=function(){return(Hb=c._Cosh=c.asm.Cosh).apply(null,arguments)},jb=c._CropAndResize=function(){return(jb=c._CropAndResize=c.asm.CropAndResize).apply(null,arguments)},qb=c._Cumprod=function(){return(qb=c._Cumprod=c.asm.Cumprod).apply(null,arguments)},Kb=c._Cumsum=function(){return(Kb=c._Cumsum=c.asm.Cumsum).apply(null,arguments)},Xb=c._DenseBincount=function(){return(Xb=c._DenseBincount=c.asm.DenseBincount).apply(null,arguments)},Yb=c._DepthToSpace=function(){return(Yb=c._DepthToSpace=c.asm.DepthToSpace).apply(null,arguments)},Zb=c._DepthwiseConv2dNative=function(){return(Zb=c._DepthwiseConv2dNative=c.asm.DepthwiseConv2dNative).apply(null,arguments)},Jb=c._Diag=function(){return(Jb=c._Diag=c.asm.Diag).apply(null,arguments)},Qb=c._Dilation2D=function(){return(Qb=c._Dilation2D=c.asm.Dilation2D).apply(null,arguments)},ey=c._Dilation2DBackpropFilter=function(){return(ey=c._Dilation2DBackpropFilter=c.asm.Dilation2DBackpropFilter).apply(null,arguments)},ty=c._Dilation2DBackpropInput=function(){return(ty=c._Dilation2DBackpropInput=c.asm.Dilation2DBackpropInput).apply(null,arguments)},ny=c._Elu=function(){return(ny=c._Elu=c.asm.Elu).apply(null,arguments)},ay=c._EluGrad=function(){return(ay=c._EluGrad=c.asm.EluGrad).apply(null,arguments)},ry=c._Equal=function(){return(ry=c._Equal=c.asm.Equal).apply(null,arguments)},sy=c._Erf=function(){return(sy=c._Erf=c.asm.Erf).apply(null,arguments)},iy=c._Exp=function(){return(iy=c._Exp=c.asm.Exp).apply(null,arguments)},oy=c._Expm1=function(){return(oy=c._Expm1=c.asm.Expm1).apply(null,arguments)},ly=c._FlipLeftRight=function(){return(ly=c._FlipLeftRight=c.asm.FlipLeftRight).apply(null,arguments)},uy=c._Floor=function(){return(uy=c._Floor=c.asm.Floor).apply(null,arguments)},py=c._FloorDiv=function(){return(py=c._FloorDiv=c.asm.FloorDiv).apply(null,arguments)},cy=c._FusedBatchNorm=function(){return(cy=c._FusedBatchNorm=c.asm.FusedBatchNorm).apply(null,arguments)},dy=c._FusedConv2D=function(){return(dy=c._FusedConv2D=c.asm.FusedConv2D).apply(null,arguments)},hy=c._FusedDepthwiseConv2D=function(){return(hy=c._FusedDepthwiseConv2D=c.asm.FusedDepthwiseConv2D).apply(null,arguments)},my=c._Gather=function(){return(my=c._Gather=c.asm.Gather).apply(null,arguments)},fy=c._GatherNd=function(){return(fy=c._GatherNd=c.asm.GatherNd).apply(null,arguments)},gy=c._Greater=function(){return(gy=c._Greater=c.asm.Greater).apply(null,arguments)},by=c._GreaterEqual=function(){return(by=c._GreaterEqual=c.asm.GreaterEqual).apply(null,arguments)},yy=c._IsFinite=function(){return(yy=c._IsFinite=c.asm.IsFinite).apply(null,arguments)},xy=c._IsInf=function(){return(xy=c._IsInf=c.asm.IsInf).apply(null,arguments)},vy=c._IsNan=function(){return(vy=c._IsNan=c.asm.IsNan).apply(null,arguments)},wy=c._LRN=function(){return(wy=c._LRN=c.asm.LRN).apply(null,arguments)},ky=c._LRNGrad=function(){return(ky=c._LRNGrad=c.asm.LRNGrad).apply(null,arguments)},Iy=c._LeakyRelu=function(){return(Iy=c._LeakyRelu=c.asm.LeakyRelu).apply(null,arguments)},Sy=c._Less=function(){return(Sy=c._Less=c.asm.Less).apply(null,arguments)},Ny=c._LessEqual=function(){return(Ny=c._LessEqual=c.asm.LessEqual).apply(null,arguments)},Ty=c._LinSpace=function(){return(Ty=c._LinSpace=c.asm.LinSpace).apply(null,arguments)},Cy=c._Log=function(){return(Cy=c._Log=c.asm.Log).apply(null,arguments)},Ey=c._Log1p=function(){return(Ey=c._Log1p=c.asm.Log1p).apply(null,arguments)},_y=c._LogicalAnd=function(){return(_y=c._LogicalAnd=c.asm.LogicalAnd).apply(null,arguments)},Ay=c._LogicalNot=function(){return(Ay=c._LogicalNot=c.asm.LogicalNot).apply(null,arguments)},Fy=c._LogicalOr=function(){return(Fy=c._LogicalOr=c.asm.LogicalOr).apply(null,arguments)},$y=c._LogicalXor=function(){return($y=c._LogicalXor=c.asm.LogicalXor).apply(null,arguments)},Dy=c._Max=function(){return(Dy=c._Max=c.asm.Max).apply(null,arguments)},Ry=c._MaxPool=function(){return(Ry=c._MaxPool=c.asm.MaxPool).apply(null,arguments)},My=c._MaxPool3D=function(){return(My=c._MaxPool3D=c.asm.MaxPool3D).apply(null,arguments)},Oy=c._MaxPool3DGrad=function(){return(Oy=c._MaxPool3DGrad=c.asm.MaxPool3DGrad).apply(null,arguments)},Py=c._MaxPoolGrad=function(){return(Py=c._MaxPoolGrad=c.asm.MaxPoolGrad).apply(null,arguments)},Ly=c._MaxPoolWithArgmax=function(){return(Ly=c._MaxPoolWithArgmax=c.asm.MaxPoolWithArgmax).apply(null,arguments)},zy=c._Maximum=function(){return(zy=c._Maximum=c.asm.Maximum).apply(null,arguments)},Wy=c._Mean=function(){return(Wy=c._Mean=c.asm.Mean).apply(null,arguments)},By=c._Min=function(){return(By=c._Min=c.asm.Min).apply(null,arguments)},Vy=c._Minimum=function(){return(Vy=c._Minimum=c.asm.Minimum).apply(null,arguments)},Uy=c._MirrorPad=function(){return(Uy=c._MirrorPad=c.asm.MirrorPad).apply(null,arguments)},Gy=c._Mod=function(){return(Gy=c._Mod=c.asm.Mod).apply(null,arguments)},Hy=c._Multinomial=function(){return(Hy=c._Multinomial=c.asm.Multinomial).apply(null,arguments)},jy=c._Multiply=function(){return(jy=c._Multiply=c.asm.Multiply).apply(null,arguments)},qy=c._Neg=function(){return(qy=c._Neg=c.asm.Neg).apply(null,arguments)},Ky=c._NonMaxSuppressionV3=function(){return(Ky=c._NonMaxSuppressionV3=c.asm.NonMaxSuppressionV3).apply(null,arguments)},Xy=c._NonMaxSuppressionV4=function(){return(Xy=c._NonMaxSuppressionV4=c.asm.NonMaxSuppressionV4).apply(null,arguments)},lh=c._NonMaxSuppressionV5=function(){return(lh=c._NonMaxSuppressionV5=c.asm.NonMaxSuppressionV5).apply(null,arguments)},uh=c._NotEqual=function(){return(uh=c._NotEqual=c.asm.NotEqual).apply(null,arguments)},jp=c._OneHot=function(){return(jp=c._OneHot=c.asm.OneHot).apply(null,arguments)},Yy=c._PadV2=function(){return(Yy=c._PadV2=c.asm.PadV2).apply(null,arguments)},Zy=c._Pow=function(){return(Zy=c._Pow=c.asm.Pow).apply(null,arguments)},yl=c._Prelu=function(){return(yl=c._Prelu=c.asm.Prelu).apply(null,arguments)},ph=c._Prod=function(){return(ph=c._Prod=c.asm.Prod).apply(null,arguments)},xl=c._RealDiv=function(){return(xl=c._RealDiv=c.asm.RealDiv).apply(null,arguments)},vl=c._Reciprocal=function(){return(vl=c._Reciprocal=c.asm.Reciprocal).apply(null,arguments)},Jy=c._Relu=function(){return(Jy=c._Relu=c.asm.Relu).apply(null,arguments)},Y=c._Relu6=function(){return(Y=c._Relu6=c.asm.Relu6).apply(null,arguments)},oe=c._ResizeBilinear=function(){return(oe=c._ResizeBilinear=c.asm.ResizeBilinear).apply(null,arguments)},Ie=c._ResizeBilinearGrad=function(){return(Ie=c._ResizeBilinearGrad=c.asm.ResizeBilinearGrad).apply(null,arguments)},Ye=c._ResizeNearestNeighbor=function(){return(Ye=c._ResizeNearestNeighbor=c.asm.ResizeNearestNeighbor).apply(null,arguments)},wt=c._ResizeNearestNeighborGrad=function(){return(wt=c._ResizeNearestNeighborGrad=c.asm.ResizeNearestNeighborGrad).apply(null,arguments)},kt=c._Reverse=function(){return(kt=c._Reverse=c.asm.Reverse).apply(null,arguments)},Ge=c._RotateWithOffset=function(){return(Ge=c._RotateWithOffset=c.asm.RotateWithOffset).apply(null,arguments)},Be=c._Round=function(){return(Be=c._Round=c.asm.Round).apply(null,arguments)},Pt=c._Rsqrt=function(){return(Pt=c._Rsqrt=c.asm.Rsqrt).apply(null,arguments)},la=c._ScatterNd=function(){return(la=c._ScatterNd=c.asm.ScatterNd).apply(null,arguments)},wr=c._SearchSorted=function(){return(wr=c._SearchSorted=c.asm.SearchSorted).apply(null,arguments)},ch=c._SelectV2=function(){return(ch=c._SelectV2=c.asm.SelectV2).apply(null,arguments)},qp=c._Selu=function(){return(qp=c._Selu=c.asm.Selu).apply(null,arguments)},Qy=c._Sigmoid=function(){return(Qy=c._Sigmoid=c.asm.Sigmoid).apply(null,arguments)},Rn=c._Sign=function(){return(Rn=c._Sign=c.asm.Sign).apply(null,arguments)},jr=c._Sin=function(){return(jr=c._Sin=c.asm.Sin).apply(null,arguments)},dh=c._Sinh=function(){return(dh=c._Sinh=c.asm.Sinh).apply(null,arguments)},BD=c._Softmax=function(){return(BD=c._Softmax=c.asm.Softmax).apply(null,arguments)},VD=c._Softplus=function(){return(VD=c._Softplus=c.asm.Softplus).apply(null,arguments)},UD=c._SparseFillEmptyRows=function(){return(UD=c._SparseFillEmptyRows=c.asm.SparseFillEmptyRows).apply(null,arguments)},GD=c._SparseReshape=function(){return(GD=c._SparseReshape=c.asm.SparseReshape).apply(null,arguments)},HD=c._SparseSegmentReduction=function(){return(HD=c._SparseSegmentReduction=c.asm.SparseSegmentReduction).apply(null,arguments)},jD=c._SparseToDense=function(){return(jD=c._SparseToDense=c.asm.SparseToDense).apply(null,arguments)},qD=c._Sqrt=function(){return(qD=c._Sqrt=c.asm.Sqrt).apply(null,arguments)},KD=c._Square=function(){return(KD=c._Square=c.asm.Square).apply(null,arguments)},XD=c._SquaredDifference=function(){return(XD=c._SquaredDifference=c.asm.SquaredDifference).apply(null,arguments)},YD=c._Step=function(){return(YD=c._Step=c.asm.Step).apply(null,arguments)},ZD=c._StridedSlice=function(){return(ZD=c._StridedSlice=c.asm.StridedSlice).apply(null,arguments)},JD=c._Sub=function(){return(JD=c._Sub=c.asm.Sub).apply(null,arguments)},QD=c._Sum=function(){return(QD=c._Sum=c.asm.Sum).apply(null,arguments)},eR=c._Tan=function(){return(eR=c._Tan=c.asm.Tan).apply(null,arguments)},tR=c._Tanh=function(){return(tR=c._Tanh=c.asm.Tanh).apply(null,arguments)},nR=c._TensorScatterUpdate=function(){return(nR=c._TensorScatterUpdate=c.asm.TensorScatterUpdate).apply(null,arguments)},aR=c._Tile=function(){return(aR=c._Tile=c.asm.Tile).apply(null,arguments)},rR=c._TopK=function(){return(rR=c._TopK=c.asm.TopK).apply(null,arguments)},sR=c._Transform=function(){return(sR=c._Transform=c.asm.Transform).apply(null,arguments)},iR=c._Transpose=function(){return(iR=c._Transpose=c.asm.Transpose).apply(null,arguments)},oR=c.__FusedMatMul=function(){return(oR=c.__FusedMatMul=c.asm._FusedMatMul).apply(null,arguments)},lR=c._malloc=function(){return(lR=c._malloc=c.asm.malloc).apply(null,arguments)},uR=c._free=function(){return(uR=c._free=c.asm.free).apply(null,arguments)},pR=c.__emscripten_tls_init=function(){return(pR=c.__emscripten_tls_init=c.asm._emscripten_tls_init).apply(null,arguments)},hh=c._pthread_self=function(){return(hh=c._pthread_self=c.asm.pthread_self).apply(null,arguments)},cR=c.___errno_location=function(){return(cR=c.___errno_location=c.asm.__errno_location).apply(null,arguments)},Lk=c.__emscripten_thread_init=function(){return(Lk=c.__emscripten_thread_init=c.asm._emscripten_thread_init).apply(null,arguments)},dR=c.__emscripten_thread_crashed=function(){return(dR=c.__emscripten_thread_crashed=c.asm._emscripten_thread_crashed).apply(null,arguments)},hR=c._emscripten_main_thread_process_queued_calls=function(){return(hR=c._emscripten_main_thread_process_queued_calls=c.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},mR=c._emscripten_main_browser_thread_id=function(){return(mR=c._emscripten_main_browser_thread_id=c.asm.emscripten_main_browser_thread_id).apply(null,arguments)},zk=c._emscripten_run_in_main_runtime_thread_js=function(){return(zk=c._emscripten_run_in_main_runtime_thread_js=c.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)},fR=c._emscripten_dispatch_to_thread_=function(){return(fR=c._emscripten_dispatch_to_thread_=c.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},Wk=c.__emscripten_proxy_execute_task_queue=function(){return(Wk=c.__emscripten_proxy_execute_task_queue=c.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},ex=c.__emscripten_thread_free_data=function(){return(ex=c.__emscripten_thread_free_data=c.asm._emscripten_thread_free_data).apply(null,arguments)},Bk=c.__emscripten_thread_exit=function(){return(Bk=c.__emscripten_thread_exit=c.asm._emscripten_thread_exit).apply(null,arguments)},Vk=c._emscripten_stack_set_limits=function(){return(Vk=c._emscripten_stack_set_limits=c.asm.emscripten_stack_set_limits).apply(null,arguments)},tx=c.stackSave=function(){return(tx=c.stackSave=c.asm.stackSave).apply(null,arguments)},mh=c.stackRestore=function(){return(mh=c.stackRestore=c.asm.stackRestore).apply(null,arguments)},fh=c.stackAlloc=function(){return(fh=c.stackAlloc=c.asm.stackAlloc).apply(null,arguments)},gR=c.dynCall_iijjiiii=function(){return(gR=c.dynCall_iijjiiii=c.asm.dynCall_iijjiiii).apply(null,arguments)},bR=c.dynCall_jiji=function(){return(bR=c.dynCall_jiji=c.asm.dynCall_jiji).apply(null,arguments)};c.keepRuntimeAlive=Ia,c.wasmMemory=ue,c.cwrap=ob,c.ExitStatus=Gs,c.PThread=Ae;var gh;vr=function R(){gh||Uk(),gh||(vr=R)};function Uk(R){if(R=R||b,Gr>0)return;if(C){h(c),Jt(),startWorker(c);return}if(Ur(),Gr>0)return;function j(){gh||(gh=!0,c.calledRun=!0,!ke&&(Jt(),h(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),Hd()))}c.setStatus?(c.setStatus(\"Running...\"),setTimeout(function(){setTimeout(function(){c.setStatus(\"\")},1),j()},1)):j()}if(c.preInit)for(typeof c.preInit==\"function\"&&(c.preInit=[c.preInit]);c.preInit.length>0;)c.preInit.pop()();Uk();var bh;f&&(bh={uncaughtException:process.listeners(\"uncaughtException\").filter(function(R){return!f.uncaughtException.indexOf(R)>-1}),unhandledRejection:process.listeners(\"unhandledRejection\").filter(function(R){return!f.unhandledRejection.indexOf(R)>-1})});var yh;if(typeof WasmBackendModule!=\"undefined\")yh=WasmBackendModule;else if(typeof r!=\"undefined\")yh=r;else throw new Error(\"Could not find wasm module in post.js\");if(bh){var yR=yh._dispose;yh._dispose=function(){yR(),bh.uncaughtException.forEach(function(R){process.removeListener(\"uncaughtException\",R)}),bh.unhandledRejection.forEach(function(R){process.removeListener(\"unhandledRejection\",R)})}}return r.ready}})();typeof e==\"object\"&&typeof t==\"object\"?t.exports=n:typeof define==\"function\"&&__webpack_require__.amdO?define([],function(){return n}):typeof e==\"object\"&&(e.WasmBackendModuleThreadedSimd=n)}),UR=Vt((e,t)=>{t.exports.wasmWorkerContents=`\"use strict\";var Module={};var ENVIRONMENT_IS_NODE=typeof process==\"object\"&&typeof process.versions==\"object\"&&typeof process.versions.node==\"string\";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require(\"worker_threads\");var parentPort=nodeWorkerThreads.parentPort;parentPort.on(\"message\",data=>onmessage({data:data}));var fs=require(\"fs\");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,\"utf8\")+\"//# sourceURL=\"+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(\" \");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+\"\n\");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(\" \");postMessage({cmd:\"alert\",text:text,threadId:Module[\"_pthread_self\"]()})}var err=threadPrintErr;self.alert=threadAlert;Module[\"instantiateWasm\"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module[\"wasmModule\"],info);receiveInstance(instance);Module[\"wasmModule\"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({\"cmd\":\"loaded\"})};self.onmessage=e=>{try{if(e.data.cmd===\"load\"){Module[\"wasmModule\"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:\"callHandler\",handler:handler,args:[...arguments]})}}Module[\"wasmMemory\"]=e.data.wasmMemory;Module[\"buffer\"]=Module[\"wasmMemory\"].buffer;Module[\"ENVIRONMENT_IS_PTHREAD\"]=true;if(typeof e.data.urlOrBlob==\"string\"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd===\"run\"){Module[\"__emscripten_thread_init\"](e.data.pthread_ptr,0,0,1);Module[\"establishStackSpace\"]();Module[\"PThread\"].receiveObjectTransfer(e.data);Module[\"PThread\"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module[\"executeNotifiedProxyingQueue\"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module[\"invokeEntryPoint\"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!=\"unwind\"){if(ex instanceof Module[\"ExitStatus\"]){if(Module[\"keepRuntimeAlive\"]()){}else{Module[\"__emscripten_thread_exit\"](ex.status)}}else{throw ex}}}}else if(e.data.cmd===\"cancel\"){if(Module[\"_pthread_self\"]()){Module[\"__emscripten_thread_exit\"](-1)}}else if(e.data.target===\"setimmediate\"){}else if(e.data.cmd===\"processProxyingQueue\"){if(initializedJS){Module[\"executeNotifiedProxyingQueue\"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err(\"worker.js received unknown command \"+e.data.cmd);err(e.data)}}catch(ex){if(Module[\"__emscripten_thread_crashed\"]){Module[\"__emscripten_thread_crashed\"]()}throw ex}};`}),GR=Vt((e,t)=>{var n=(()=>{var a=typeof document!=\"undefined\"&&document.currentScript?document.currentScript.src:void 0;return  true&&(a=a||__filename),function(r){r=r||{};var s=typeof r!=\"undefined\"?r:{},i,o;s.ready=new Promise(function(Y,oe){i=Y,o=oe});var l;typeof process!=\"undefined\"&&process.listeners&&(l={uncaughtException:process.listeners(\"uncaughtException\"),unhandledRejection:process.listeners(\"unhandledRejection\")});var u=Object.assign({},s),p=[],d=\"./this.program\",c=(Y,oe)=>{throw oe},h=typeof window==\"object\",m=typeof importScripts==\"function\",f=typeof process==\"object\"&&typeof process.versions==\"object\"&&typeof process.versions.node==\"string\",g=\"\";function b(Y){return s.locateFile?s.locateFile(Y,g):g+Y}var y,x,v,I;function N(Y){Y instanceof fl||D(\"exiting due to exception: \"+Y)}if(f){var C=Iv(),_=$S();m?g=_.dirname(g)+\"/\":g=__dirname+\"/\",y=(Y,oe)=>(Y=Ur(Y)?new URL(Y):_.normalize(Y),C.readFileSync(Y,oe?void 0:\"utf8\")),v=Y=>{var oe=y(Y,!0);return oe.buffer||(oe=new Uint8Array(oe)),oe},x=(Y,oe,Ie)=>{Y=Ur(Y)?new URL(Y):_.normalize(Y),C.readFile(Y,function(Ye,wt){Ye?Ie(Ye):oe(wt.buffer)})},process.argv.length>1&&(d=process.argv[1].replace(/\\\\/g,\"/\")),p=process.argv.slice(2),process.on(\"uncaughtException\",function(Y){if(!(Y instanceof fl))throw Y}),process.on(\"unhandledRejection\",function(Y){throw Y}),c=(Y,oe)=>{if(Gn())throw process.exitCode=Y,oe;N(oe),process.exit(Y)},s.inspect=function(){return\"[Emscripten Module object]\"}}else(h||m)&&(m?g=self.location.href:typeof document!=\"undefined\"&&document.currentScript&&(g=document.currentScript.src),a&&(g=a),g.indexOf(\"blob:\")!==0?g=g.substr(0,g.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):g=\"\",y=Y=>{var oe=new XMLHttpRequest;return oe.open(\"GET\",Y,!1),oe.send(null),oe.responseText},m&&(v=Y=>{var oe=new XMLHttpRequest;return oe.open(\"GET\",Y,!1),oe.responseType=\"arraybuffer\",oe.send(null),new Uint8Array(oe.response)}),x=(Y,oe,Ie)=>{var Ye=new XMLHttpRequest;Ye.open(\"GET\",Y,!0),Ye.responseType=\"arraybuffer\",Ye.onload=()=>{if(Ye.status==200||Ye.status==0&&Ye.response){oe(Ye.response);return}Ie()},Ye.onerror=Ie,Ye.send(null)},I=Y=>document.title=Y);var F=s.print||console.log.bind(console),D=s.printErr||console.warn.bind(console);Object.assign(s,u),u=null,s.arguments&&(p=s.arguments),s.thisProgram&&(d=s.thisProgram),s.quit&&(c=s.quit);var $=4,S;s.wasmBinary&&(S=s.wasmBinary);var M=s.noExitRuntime||!0;typeof WebAssembly!=\"object\"&&Za(\"no native wasm support detected\");var B,U=!1,H;function q(Y,oe){Y||Za(oe)}var K=typeof TextDecoder!=\"undefined\"?new TextDecoder(\"utf8\"):void 0;function Z(Y,oe,Ie){oe>>>=0;for(var Ye=oe+Ie,wt=oe;Y[wt]&&!(wt>=Ye);)++wt;if(wt-oe>16&&Y.buffer&&K)return K.decode(Y.subarray(oe,wt));for(var kt=\"\";oe<wt;){var Ge=Y[oe++];if(!(Ge&128)){kt+=String.fromCharCode(Ge);continue}var Be=Y[oe++]&63;if((Ge&224)==192){kt+=String.fromCharCode((Ge&31)<<6|Be);continue}var Pt=Y[oe++]&63;if((Ge&240)==224?Ge=(Ge&15)<<12|Be<<6|Pt:Ge=(Ge&7)<<18|Be<<12|Pt<<6|Y[oe++]&63,Ge<65536)kt+=String.fromCharCode(Ge);else{var la=Ge-65536;kt+=String.fromCharCode(55296|la>>10,56320|la&1023)}}return kt}function J(Y,oe){return Y>>>=0,Y?Z(ie,Y,oe):\"\"}function ee(Y,oe,Ie,Ye){if(Ie>>>=0,!(Ye>0))return 0;for(var wt=Ie,kt=Ie+Ye-1,Ge=0;Ge<Y.length;++Ge){var Be=Y.charCodeAt(Ge);if(Be>=55296&&Be<=57343){var Pt=Y.charCodeAt(++Ge);Be=65536+((Be&1023)<<10)|Pt&1023}if(Be<=127){if(Ie>=kt)break;oe[Ie++>>>0]=Be}else if(Be<=2047){if(Ie+1>=kt)break;oe[Ie++>>>0]=192|Be>>6,oe[Ie++>>>0]=128|Be&63}else if(Be<=65535){if(Ie+2>=kt)break;oe[Ie++>>>0]=224|Be>>12,oe[Ie++>>>0]=128|Be>>6&63,oe[Ie++>>>0]=128|Be&63}else{if(Ie+3>=kt)break;oe[Ie++>>>0]=240|Be>>18,oe[Ie++>>>0]=128|Be>>12&63,oe[Ie++>>>0]=128|Be>>6&63,oe[Ie++>>>0]=128|Be&63}}return oe[Ie>>>0]=0,Ie-wt}function ae(Y,oe,Ie){return ee(Y,ie,oe,Ie)}var te,se,ie,ve,ue,ye,ke,Se,Le;function Ue(Y){te=Y,s.HEAP8=se=new Int8Array(Y),s.HEAP16=ve=new Int16Array(Y),s.HEAP32=ye=new Int32Array(Y),s.HEAPU8=ie=new Uint8Array(Y),s.HEAPU16=ue=new Uint16Array(Y),s.HEAPU32=ke=new Uint32Array(Y),s.HEAPF32=Se=new Float32Array(Y),s.HEAPF64=Le=new Float64Array(Y)}var mt=s.INITIAL_MEMORY||16777216,st,tt=[],nt=[],Re=[],gt=!1;function Gn(){return M}function Ot(){if(s.preRun)for(typeof s.preRun==\"function\"&&(s.preRun=[s.preRun]);s.preRun.length;)Fn(s.preRun.shift());vr(tt)}function ia(){gt=!0,vr(nt)}function un(){if(s.postRun)for(typeof s.postRun==\"function\"&&(s.postRun=[s.postRun]);s.postRun.length;)$n(s.postRun.shift());vr(Re)}function Fn(Y){tt.unshift(Y)}function oa(Y){nt.unshift(Y)}function $n(Y){Re.unshift(Y)}var ut=0,Dn=null,Hn=null;function xr(Y){ut++,s.monitorRunDependencies&&s.monitorRunDependencies(ut)}function ml(Y){if(ut--,s.monitorRunDependencies&&s.monitorRunDependencies(ut),ut==0&&(Dn!==null&&(clearInterval(Dn),Dn=null),Hn)){var oe=Hn;Hn=null,oe()}}function Za(Y){s.onAbort&&s.onAbort(Y),Y=\"Aborted(\"+Y+\")\",D(Y),U=!0,H=1,Y+=\". Build with -sASSERTIONS for more info.\";var oe=new WebAssembly.RuntimeError(Y);throw o(oe),oe}var Wp=\"data:application/octet-stream;base64,\";function Ia(Y){return Y.startsWith(Wp)}function Ur(Y){return Y.startsWith(\"file://\")}var Jt;Jt=\"tfjs-backend-wasm.wasm\",Ia(Jt)||(Jt=b(Jt));function Hd(Y){try{if(Y==Jt&&S)return new Uint8Array(S);if(v)return v(Y);throw\"both async and sync fetching of the wasm failed\"}catch(oe){Za(oe)}}function Sg(){if(!S&&(h||m)){if(typeof fetch==\"function\"&&!Ur(Jt))return fetch(Jt,{credentials:\"same-origin\"}).then(function(Y){if(!Y.ok)throw\"failed to load wasm binary file at '\"+Jt+\"'\";return Y.arrayBuffer()}).catch(function(){return Hd(Jt)});if(x)return new Promise(function(Y,oe){x(Jt,function(Ie){Y(new Uint8Array(Ie))},oe)})}return Promise.resolve().then(function(){return Hd(Jt)})}function Ng(){var Y={env:Bp,wasi_snapshot_preview1:Bp};function oe(Ge,Be){var Pt=Ge.exports;s.asm=Pt,B=s.asm.memory,Ue(B.buffer),st=s.asm.__indirect_function_table,oa(s.asm.__wasm_call_ctors),ml(\"wasm-instantiate\")}xr(\"wasm-instantiate\");function Ie(Ge){oe(Ge.instance)}function Ye(Ge){return Sg().then(function(Be){return WebAssembly.instantiate(Be,Y)}).then(function(Be){return Be}).then(Ge,function(Be){D(\"failed to asynchronously prepare wasm: \"+Be),Za(Be)})}function wt(){return!S&&typeof WebAssembly.instantiateStreaming==\"function\"&&!Ia(Jt)&&!Ur(Jt)&&!f&&typeof fetch==\"function\"?fetch(Jt,{credentials:\"same-origin\"}).then(function(Ge){var Be=WebAssembly.instantiateStreaming(Ge,Y);return Be.then(Ie,function(Pt){return D(\"wasm streaming compile failed: \"+Pt),D(\"falling back to ArrayBuffer instantiation\"),Ye(Ie)})}):Ye(Ie)}if(s.instantiateWasm)try{var kt=s.instantiateWasm(Y,oe);return kt}catch(Ge){D(\"Module.instantiateWasm callback failed with error: \"+Ge),o(Ge)}return wt().catch(o),{}}var Rk,Gr;function fl(Y){this.name=\"ExitStatus\",this.message=\"Program terminated with exit(\"+Y+\")\",this.status=Y}function vr(Y){for(;Y.length>0;)Y.shift()(s)}function Tg(){Za(\"\")}function jd(){return 4294901760}function Us(){return jd()}function Cg(Y,oe,Ie){ie.copyWithin(Y>>>0,oe>>>0,oe+Ie>>>0)}function qd(Y){try{return B.grow(Y-te.byteLength+65535>>>16),Ue(B.buffer),1}catch(oe){}}function gl(Y){var oe=ie.length;Y=Y>>>0;var Ie=jd();if(Y>Ie)return!1;let Ye=(Pt,la)=>Pt+(la-Pt%la)%la;for(var wt=1;wt<=4;wt*=2){var kt=oe*(1+.2/wt);kt=Math.min(kt,Y+100663296);var Ge=Math.min(Ie,Ye(Math.max(Y,kt),65536)),Be=qd(Ge);if(Be)return!0}return!1}var gn={varargs:void 0,get:function(){gn.varargs+=4;var Y=ye[gn.varargs-4>>>2];return Y},getStr:function(Y){var oe=J(Y);return oe}};function Kd(Y){return 52}function Eg(Y,oe,Ie,Ye,wt){return 70}var _g=[null,[],[]];function Mk(Y,oe){var Ie=_g[Y];oe===0||oe===10?((Y===1?F:D)(Z(Ie,0)),Ie.length=0):Ie.push(oe)}function Ok(Y,oe,Ie,Ye){for(var wt=0,kt=0;kt<Ie;kt++){var Ge=ke[oe>>>2],Be=ke[oe+4>>>2];oe+=8;for(var Pt=0;Pt<Be;Pt++)Mk(Y,ie[Ge+Pt>>>0]);wt+=Be}return ke[Ye>>>2]=wt,0}function Xd(Y){var oe=s[\"_\"+Y];return oe}function Gs(Y,oe){se.set(Y,oe>>>0)}function Ag(Y,oe,Ie,Ye,wt){var kt={string:Rn=>{var jr=0;if(Rn!=null&&Rn!==0){var dh=(Rn.length<<2)+1;jr=jp(dh),ae(Rn,jr,dh)}return jr},array:Rn=>{var jr=jp(Rn.length);return Gs(Rn,jr),jr}};function Ge(Rn){return oe===\"string\"?J(Rn):oe===\"boolean\"?!!Rn:Rn}var Be=Xd(Y),Pt=[],la=0;if(Ye)for(var wr=0;wr<Ye.length;wr++){var ch=kt[Ie[wr]];ch?(la===0&&(la=lh()),Pt[wr]=ch(Ye[wr])):Pt[wr]=Ye[wr]}var qp=Be.apply(null,Pt);function Qy(Rn){return la!==0&&uh(la),Ge(Rn)}return qp=Qy(qp),qp}function Fg(Y,oe,Ie,Ye){Ie=Ie||[];var wt=Ie.every(Ge=>Ge===\"number\"||Ge===\"boolean\"),kt=oe!==\"string\";return kt&&wt&&!Ye?Xd(Y):function(){return Ag(Y,oe,Ie,arguments,Ye)}}var Bp={abort:Tg,emscripten_get_heap_max:Us,emscripten_memcpy_big:Cg,emscripten_resize_heap:gl,fd_close:Kd,fd_seek:Eg,fd_write:Ok},$g=Ng(),Yd=s.___wasm_call_ctors=function(){return(Yd=s.___wasm_call_ctors=s.asm.__wasm_call_ctors).apply(null,arguments)},Zd=s._init=function(){return(Zd=s._init=s.asm.init).apply(null,arguments)},Dg=s._init_with_threads_count=function(){return(Dg=s._init_with_threads_count=s.asm.init_with_threads_count).apply(null,arguments)},Jd=s._get_threads_count=function(){return(Jd=s._get_threads_count=s.asm.get_threads_count).apply(null,arguments)},Rg=s._register_tensor=function(){return(Rg=s._register_tensor=s.asm.register_tensor).apply(null,arguments)},Ae=s._dispose_data=function(){return(Ae=s._dispose_data=s.asm.dispose_data).apply(null,arguments)},Vp=s._dispose=function(){return(Vp=s._dispose=s.asm.dispose).apply(null,arguments)},Mg=s._Abs=function(){return(Mg=s._Abs=s.asm.Abs).apply(null,arguments)},Qd=s._Acos=function(){return(Qd=s._Acos=s.asm.Acos).apply(null,arguments)},bl=s._Acosh=function(){return(bl=s._Acosh=s.asm.Acosh).apply(null,arguments)},Og=s._Add=function(){return(Og=s._Add=s.asm.Add).apply(null,arguments)},Pg=s._AddN=function(){return(Pg=s._AddN=s.asm.AddN).apply(null,arguments)},Lg=s._All=function(){return(Lg=s._All=s.asm.All).apply(null,arguments)},zg=s._Any=function(){return(zg=s._Any=s.asm.Any).apply(null,arguments)},Wg=s._ArgMax=function(){return(Wg=s._ArgMax=s.asm.ArgMax).apply(null,arguments)},eh=s._ArgMin=function(){return(eh=s._ArgMin=s.asm.ArgMin).apply(null,arguments)},th=s._Asin=function(){return(th=s._Asin=s.asm.Asin).apply(null,arguments)},Bg=s._Asinh=function(){return(Bg=s._Asinh=s.asm.Asinh).apply(null,arguments)},Vg=s._Atan=function(){return(Vg=s._Atan=s.asm.Atan).apply(null,arguments)},Ug=s._Atan2=function(){return(Ug=s._Atan2=s.asm.Atan2).apply(null,arguments)},Up=s._Atanh=function(){return(Up=s._Atanh=s.asm.Atanh).apply(null,arguments)},Gg=s._AvgPool=function(){return(Gg=s._AvgPool=s.asm.AvgPool).apply(null,arguments)},Hg=s._AvgPool3D=function(){return(Hg=s._AvgPool3D=s.asm.AvgPool3D).apply(null,arguments)},jg=s._AvgPool3DGrad=function(){return(jg=s._AvgPool3DGrad=s.asm.AvgPool3DGrad).apply(null,arguments)},Hs=s._AvgPoolGrad=function(){return(Hs=s._AvgPoolGrad=s.asm.AvgPoolGrad).apply(null,arguments)},qg=s._BatchMatMul=function(){return(qg=s._BatchMatMul=s.asm.BatchMatMul).apply(null,arguments)},Kg=s._Bincount=function(){return(Kg=s._Bincount=s.asm.Bincount).apply(null,arguments)},nh=s._BitwiseAnd=function(){return(nh=s._BitwiseAnd=s.asm.BitwiseAnd).apply(null,arguments)},Xg=s._Ceil=function(){return(Xg=s._Ceil=s.asm.Ceil).apply(null,arguments)},Gp=s._ClipByValue=function(){return(Gp=s._ClipByValue=s.asm.ClipByValue).apply(null,arguments)},Yg=s._Conv2D=function(){return(Yg=s._Conv2D=s.asm.Conv2D).apply(null,arguments)},Zg=s._Conv2DBackpropInput=function(){return(Zg=s._Conv2DBackpropInput=s.asm.Conv2DBackpropInput).apply(null,arguments)},Jg=s._Conv3D=function(){return(Jg=s._Conv3D=s.asm.Conv3D).apply(null,arguments)},Hr=s._Conv3DBackpropFilterV2=function(){return(Hr=s._Conv3DBackpropFilterV2=s.asm.Conv3DBackpropFilterV2).apply(null,arguments)},Hp=s._Conv3DBackpropInputV2=function(){return(Hp=s._Conv3DBackpropInputV2=s.asm.Conv3DBackpropInputV2).apply(null,arguments)},Qg=s._Cos=function(){return(Qg=s._Cos=s.asm.Cos).apply(null,arguments)},eb=s._Cosh=function(){return(eb=s._Cosh=s.asm.Cosh).apply(null,arguments)},tb=s._CropAndResize=function(){return(tb=s._CropAndResize=s.asm.CropAndResize).apply(null,arguments)},nb=s._Cumprod=function(){return(nb=s._Cumprod=s.asm.Cumprod).apply(null,arguments)},ah=s._Cumsum=function(){return(ah=s._Cumsum=s.asm.Cumsum).apply(null,arguments)},rh=s._DenseBincount=function(){return(rh=s._DenseBincount=s.asm.DenseBincount).apply(null,arguments)},ab=s._DepthToSpace=function(){return(ab=s._DepthToSpace=s.asm.DepthToSpace).apply(null,arguments)},rb=s._DepthwiseConv2dNative=function(){return(rb=s._DepthwiseConv2dNative=s.asm.DepthwiseConv2dNative).apply(null,arguments)},sh=s._Diag=function(){return(sh=s._Diag=s.asm.Diag).apply(null,arguments)},ih=s._Dilation2D=function(){return(ih=s._Dilation2D=s.asm.Dilation2D).apply(null,arguments)},sb=s._Dilation2DBackpropFilter=function(){return(sb=s._Dilation2DBackpropFilter=s.asm.Dilation2DBackpropFilter).apply(null,arguments)},ib=s._Dilation2DBackpropInput=function(){return(ib=s._Dilation2DBackpropInput=s.asm.Dilation2DBackpropInput).apply(null,arguments)},ob=s._Elu=function(){return(ob=s._Elu=s.asm.Elu).apply(null,arguments)},lb=s._EluGrad=function(){return(lb=s._EluGrad=s.asm.EluGrad).apply(null,arguments)},oh=s._Equal=function(){return(oh=s._Equal=s.asm.Equal).apply(null,arguments)},Pk=s._Erf=function(){return(Pk=s._Erf=s.asm.Erf).apply(null,arguments)},ub=s._Exp=function(){return(ub=s._Exp=s.asm.Exp).apply(null,arguments)},pb=s._Expm1=function(){return(pb=s._Expm1=s.asm.Expm1).apply(null,arguments)},cb=s._FlipLeftRight=function(){return(cb=s._FlipLeftRight=s.asm.FlipLeftRight).apply(null,arguments)},db=s._Floor=function(){return(db=s._Floor=s.asm.Floor).apply(null,arguments)},hb=s._FloorDiv=function(){return(hb=s._FloorDiv=s.asm.FloorDiv).apply(null,arguments)},mb=s._FusedBatchNorm=function(){return(mb=s._FusedBatchNorm=s.asm.FusedBatchNorm).apply(null,arguments)},fb=s._FusedConv2D=function(){return(fb=s._FusedConv2D=s.asm.FusedConv2D).apply(null,arguments)},gb=s._FusedDepthwiseConv2D=function(){return(gb=s._FusedDepthwiseConv2D=s.asm.FusedDepthwiseConv2D).apply(null,arguments)},bb=s._Gather=function(){return(bb=s._Gather=s.asm.Gather).apply(null,arguments)},yb=s._GatherNd=function(){return(yb=s._GatherNd=s.asm.GatherNd).apply(null,arguments)},xb=s._Greater=function(){return(xb=s._Greater=s.asm.Greater).apply(null,arguments)},vb=s._GreaterEqual=function(){return(vb=s._GreaterEqual=s.asm.GreaterEqual).apply(null,arguments)},wb=s._IsFinite=function(){return(wb=s._IsFinite=s.asm.IsFinite).apply(null,arguments)},kb=s._IsInf=function(){return(kb=s._IsInf=s.asm.IsInf).apply(null,arguments)},Ib=s._IsNan=function(){return(Ib=s._IsNan=s.asm.IsNan).apply(null,arguments)},Sb=s._LRN=function(){return(Sb=s._LRN=s.asm.LRN).apply(null,arguments)},Nb=s._LRNGrad=function(){return(Nb=s._LRNGrad=s.asm.LRNGrad).apply(null,arguments)},Tb=s._LeakyRelu=function(){return(Tb=s._LeakyRelu=s.asm.LeakyRelu).apply(null,arguments)},Cb=s._Less=function(){return(Cb=s._Less=s.asm.Less).apply(null,arguments)},Eb=s._LessEqual=function(){return(Eb=s._LessEqual=s.asm.LessEqual).apply(null,arguments)},_b=s._LinSpace=function(){return(_b=s._LinSpace=s.asm.LinSpace).apply(null,arguments)},Ab=s._Log=function(){return(Ab=s._Log=s.asm.Log).apply(null,arguments)},Fb=s._Log1p=function(){return(Fb=s._Log1p=s.asm.Log1p).apply(null,arguments)},$b=s._LogicalAnd=function(){return($b=s._LogicalAnd=s.asm.LogicalAnd).apply(null,arguments)},Db=s._LogicalNot=function(){return(Db=s._LogicalNot=s.asm.LogicalNot).apply(null,arguments)},Rb=s._LogicalOr=function(){return(Rb=s._LogicalOr=s.asm.LogicalOr).apply(null,arguments)},Mb=s._LogicalXor=function(){return(Mb=s._LogicalXor=s.asm.LogicalXor).apply(null,arguments)},Ob=s._Max=function(){return(Ob=s._Max=s.asm.Max).apply(null,arguments)},Pb=s._MaxPool=function(){return(Pb=s._MaxPool=s.asm.MaxPool).apply(null,arguments)},Lb=s._MaxPool3D=function(){return(Lb=s._MaxPool3D=s.asm.MaxPool3D).apply(null,arguments)},zb=s._MaxPool3DGrad=function(){return(zb=s._MaxPool3DGrad=s.asm.MaxPool3DGrad).apply(null,arguments)},Wb=s._MaxPoolGrad=function(){return(Wb=s._MaxPoolGrad=s.asm.MaxPoolGrad).apply(null,arguments)},Bb=s._MaxPoolWithArgmax=function(){return(Bb=s._MaxPoolWithArgmax=s.asm.MaxPoolWithArgmax).apply(null,arguments)},Vb=s._Maximum=function(){return(Vb=s._Maximum=s.asm.Maximum).apply(null,arguments)},Ub=s._Mean=function(){return(Ub=s._Mean=s.asm.Mean).apply(null,arguments)},Gb=s._Min=function(){return(Gb=s._Min=s.asm.Min).apply(null,arguments)},Hb=s._Minimum=function(){return(Hb=s._Minimum=s.asm.Minimum).apply(null,arguments)},jb=s._MirrorPad=function(){return(jb=s._MirrorPad=s.asm.MirrorPad).apply(null,arguments)},qb=s._Mod=function(){return(qb=s._Mod=s.asm.Mod).apply(null,arguments)},Kb=s._Multinomial=function(){return(Kb=s._Multinomial=s.asm.Multinomial).apply(null,arguments)},Xb=s._Multiply=function(){return(Xb=s._Multiply=s.asm.Multiply).apply(null,arguments)},Yb=s._Neg=function(){return(Yb=s._Neg=s.asm.Neg).apply(null,arguments)},Zb=s._NonMaxSuppressionV3=function(){return(Zb=s._NonMaxSuppressionV3=s.asm.NonMaxSuppressionV3).apply(null,arguments)},Jb=s._NonMaxSuppressionV4=function(){return(Jb=s._NonMaxSuppressionV4=s.asm.NonMaxSuppressionV4).apply(null,arguments)},Qb=s._NonMaxSuppressionV5=function(){return(Qb=s._NonMaxSuppressionV5=s.asm.NonMaxSuppressionV5).apply(null,arguments)},ey=s._NotEqual=function(){return(ey=s._NotEqual=s.asm.NotEqual).apply(null,arguments)},ty=s._OneHot=function(){return(ty=s._OneHot=s.asm.OneHot).apply(null,arguments)},ny=s._PadV2=function(){return(ny=s._PadV2=s.asm.PadV2).apply(null,arguments)},ay=s._Pow=function(){return(ay=s._Pow=s.asm.Pow).apply(null,arguments)},ry=s._Prelu=function(){return(ry=s._Prelu=s.asm.Prelu).apply(null,arguments)},sy=s._Prod=function(){return(sy=s._Prod=s.asm.Prod).apply(null,arguments)},iy=s._RealDiv=function(){return(iy=s._RealDiv=s.asm.RealDiv).apply(null,arguments)},oy=s._Reciprocal=function(){return(oy=s._Reciprocal=s.asm.Reciprocal).apply(null,arguments)},ly=s._Relu=function(){return(ly=s._Relu=s.asm.Relu).apply(null,arguments)},uy=s._Relu6=function(){return(uy=s._Relu6=s.asm.Relu6).apply(null,arguments)},py=s._ResizeBilinear=function(){return(py=s._ResizeBilinear=s.asm.ResizeBilinear).apply(null,arguments)},cy=s._ResizeBilinearGrad=function(){return(cy=s._ResizeBilinearGrad=s.asm.ResizeBilinearGrad).apply(null,arguments)},dy=s._ResizeNearestNeighbor=function(){return(dy=s._ResizeNearestNeighbor=s.asm.ResizeNearestNeighbor).apply(null,arguments)},hy=s._ResizeNearestNeighborGrad=function(){return(hy=s._ResizeNearestNeighborGrad=s.asm.ResizeNearestNeighborGrad).apply(null,arguments)},my=s._Reverse=function(){return(my=s._Reverse=s.asm.Reverse).apply(null,arguments)},fy=s._RotateWithOffset=function(){return(fy=s._RotateWithOffset=s.asm.RotateWithOffset).apply(null,arguments)},gy=s._Round=function(){return(gy=s._Round=s.asm.Round).apply(null,arguments)},by=s._Rsqrt=function(){return(by=s._Rsqrt=s.asm.Rsqrt).apply(null,arguments)},yy=s._ScatterNd=function(){return(yy=s._ScatterNd=s.asm.ScatterNd).apply(null,arguments)},xy=s._SearchSorted=function(){return(xy=s._SearchSorted=s.asm.SearchSorted).apply(null,arguments)},vy=s._SelectV2=function(){return(vy=s._SelectV2=s.asm.SelectV2).apply(null,arguments)},wy=s._Selu=function(){return(wy=s._Selu=s.asm.Selu).apply(null,arguments)},ky=s._Sigmoid=function(){return(ky=s._Sigmoid=s.asm.Sigmoid).apply(null,arguments)},Iy=s._Sign=function(){return(Iy=s._Sign=s.asm.Sign).apply(null,arguments)},Sy=s._Sin=function(){return(Sy=s._Sin=s.asm.Sin).apply(null,arguments)},Ny=s._Sinh=function(){return(Ny=s._Sinh=s.asm.Sinh).apply(null,arguments)},Ty=s._Softmax=function(){return(Ty=s._Softmax=s.asm.Softmax).apply(null,arguments)},Cy=s._Softplus=function(){return(Cy=s._Softplus=s.asm.Softplus).apply(null,arguments)},Ey=s._SparseFillEmptyRows=function(){return(Ey=s._SparseFillEmptyRows=s.asm.SparseFillEmptyRows).apply(null,arguments)},_y=s._SparseReshape=function(){return(_y=s._SparseReshape=s.asm.SparseReshape).apply(null,arguments)},Ay=s._SparseSegmentReduction=function(){return(Ay=s._SparseSegmentReduction=s.asm.SparseSegmentReduction).apply(null,arguments)},Fy=s._SparseToDense=function(){return(Fy=s._SparseToDense=s.asm.SparseToDense).apply(null,arguments)},$y=s._Sqrt=function(){return($y=s._Sqrt=s.asm.Sqrt).apply(null,arguments)},Dy=s._Square=function(){return(Dy=s._Square=s.asm.Square).apply(null,arguments)},Ry=s._SquaredDifference=function(){return(Ry=s._SquaredDifference=s.asm.SquaredDifference).apply(null,arguments)},My=s._Step=function(){return(My=s._Step=s.asm.Step).apply(null,arguments)},Oy=s._StridedSlice=function(){return(Oy=s._StridedSlice=s.asm.StridedSlice).apply(null,arguments)},Py=s._Sub=function(){return(Py=s._Sub=s.asm.Sub).apply(null,arguments)},Ly=s._Sum=function(){return(Ly=s._Sum=s.asm.Sum).apply(null,arguments)},zy=s._Tan=function(){return(zy=s._Tan=s.asm.Tan).apply(null,arguments)},Wy=s._Tanh=function(){return(Wy=s._Tanh=s.asm.Tanh).apply(null,arguments)},By=s._TensorScatterUpdate=function(){return(By=s._TensorScatterUpdate=s.asm.TensorScatterUpdate).apply(null,arguments)},Vy=s._Tile=function(){return(Vy=s._Tile=s.asm.Tile).apply(null,arguments)},Uy=s._TopK=function(){return(Uy=s._TopK=s.asm.TopK).apply(null,arguments)},Gy=s._Transform=function(){return(Gy=s._Transform=s.asm.Transform).apply(null,arguments)},Hy=s._Transpose=function(){return(Hy=s._Transpose=s.asm.Transpose).apply(null,arguments)},jy=s.__FusedMatMul=function(){return(jy=s.__FusedMatMul=s.asm._FusedMatMul).apply(null,arguments)},qy=s._malloc=function(){return(qy=s._malloc=s.asm.malloc).apply(null,arguments)},Ky=s._free=function(){return(Ky=s._free=s.asm.free).apply(null,arguments)},Xy=s.___errno_location=function(){return(Xy=s.___errno_location=s.asm.__errno_location).apply(null,arguments)},lh=s.stackSave=function(){return(lh=s.stackSave=s.asm.stackSave).apply(null,arguments)},uh=s.stackRestore=function(){return(uh=s.stackRestore=s.asm.stackRestore).apply(null,arguments)},jp=s.stackAlloc=function(){return(jp=s.stackAlloc=s.asm.stackAlloc).apply(null,arguments)},Yy=s.dynCall_iijjiiii=function(){return(Yy=s.dynCall_iijjiiii=s.asm.dynCall_iijjiiii).apply(null,arguments)},Zy=s.dynCall_jiji=function(){return(Zy=s.dynCall_jiji=s.asm.dynCall_jiji).apply(null,arguments)};s.cwrap=Fg;var yl;Hn=function Y(){yl||ph(),yl||(Hn=Y)};function ph(Y){if(Y=Y||p,ut>0||(Ot(),ut>0))return;function oe(){yl||(yl=!0,s.calledRun=!0,!U&&(ia(),i(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),un()))}s.setStatus?(s.setStatus(\"Running...\"),setTimeout(function(){setTimeout(function(){s.setStatus(\"\")},1),oe()},1)):oe()}if(s.preInit)for(typeof s.preInit==\"function\"&&(s.preInit=[s.preInit]);s.preInit.length>0;)s.preInit.pop()();ph();var xl;l&&(xl={uncaughtException:process.listeners(\"uncaughtException\").filter(function(Y){return!l.uncaughtException.indexOf(Y)>-1}),unhandledRejection:process.listeners(\"unhandledRejection\").filter(function(Y){return!l.unhandledRejection.indexOf(Y)>-1})});var vl;if(typeof r!=\"undefined\")vl=r;else if(typeof WasmBackendModuleThreadedSimd!=\"undefined\")vl=WasmBackendModuleThreadedSimd;else throw new Error(\"Could not find wasm module in post.js\");if(xl){var Jy=vl._dispose;vl._dispose=function(){Jy(),xl.uncaughtException.forEach(function(Y){process.removeListener(\"uncaughtException\",Y)}),xl.unhandledRejection.forEach(function(Y){process.removeListener(\"unhandledRejection\",Y)})}}return r.ready}})();typeof e==\"object\"&&typeof t==\"object\"?t.exports=n:typeof define==\"function\"&&__webpack_require__.amdO?define([],function(){return n}):typeof e==\"object\"&&(e.WasmBackendModule=n)}),ym=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},Fc=class{refCount(e){return jn(\"refCount\")}incRef(e){return jn(\"incRef\")}timerAvailable(){return!0}time(e){return jn(\"time\")}read(e){return jn(\"read\")}readSync(e){return jn(\"readSync\")}readToGPU(e,t){return jn(\"readToGPU\")}numDataIds(){return jn(\"numDataIds\")}disposeData(e,t){return jn(\"disposeData\")}write(e,t,n){return jn(\"write\")}move(e,t,n,a,r){return jn(\"move\")}createTensorFromGPUData(e,t,n){return jn(\"createTensorFromGPUData\")}memory(){return jn(\"memory\")}floatPrecision(){return jn(\"floatPrecision\")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return jn(\"dispose\")}};function jn(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function DS(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Vh(e,t,n)}function HR(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,a=0;for(;n>0;)a=Math.random()*n|0,n--,Vh(e,n,a),Vh(t,n,a)}function hc(e,t,n){return Math.max(e,Math.min(t,n))}function jR(e){return e%2===0?e:e+1}function Vh(e,t,n){let a=e[t];e[t]=e[n],e[n]=a}function qR(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function KR(e,t){let n=Math.random();return t*n+(1-n)*e}function XR(e,t){let n=0;for(let a=0;a<e.length;a++){let r=Number(e[a])-Number(t[a]);n+=r*r}return n}function A(e,t){if(!e)throw new Error(typeof t==\"string\"?t:t())}function Nn(e,t,n=\"\"){A(Ar(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function Si(e){A(e!=null,()=>\"The input to the tensor constructor must be a non-null value.\")}function ot(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function YR(e){return e.length===0}function RS(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==null&&t[n]!==null&&e[n]!==t[n])return!1;return!0}function Ar(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function $l(e){return e%1===0}function ZR(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function JR(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function QR(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return DS(t),t}function uc(e,t){return t<=e.length?e:e+\" \".repeat(t-e.length)}function eM(e,t=r=>0,n,a){return new Promise((r,s)=>{let i=0,o=()=>{if(e()){r();return}i++;let l=t(i);if(n!=null&&i>=n){s();return}a!=null?a(o,l):setTimeout(o,l)};o()})}function tM(e,t){let n=1,a=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(e[s]===-1){if(a!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${a} and dim ${s}`);a=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(a===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let r=e.slice();return r[a]=t/n,r}function Aa(e,t){let n=t.length;return e=e==null?t.map((a,r)=>r):[].concat(e),A(e.every(a=>a>=-n&&a<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),A(e.every(a=>$l(a)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(a=>a<0?n+a:a)}function MS(e,t){let n=[],a=[],r=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||r?null:Aa(t,e).sort(),i=0;for(let o=0;o<e.length;++o){if(s!=null){if(s[i]===o&&e[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(s[i]==null||s[i]>o)&&e[o]===1&&(n.push(e[o]),a.push(o)),s[i]<=o&&i++}e[o]!==1&&(n.push(e[o]),a.push(o))}return{newShape:n,keptDims:a}}function OS(e,t){return Sv(e,t)}function Sv(e,t){let n=null;if(e==null||e===\"float32\")n=new Float32Array(t);else if(e===\"int32\")n=new Int32Array(t);else if(e===\"bool\")n=new Uint8Array(t);else if(e===\"string\")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function PS(e,t){for(let n=0;n<e.length;n++){let a=e[n];if(isNaN(a)||!isFinite(a))throw Error(`A tensor of type ${t} being uploaded contains ${a}.`)}}function LS(e){return e===\"bool\"||e===\"complex64\"||e===\"float32\"||e===\"int32\"||e===\"string\"}function nM(e,t){return!(t===\"complex64\"||t===\"float32\"&&e!==\"complex64\"||t===\"int32\"&&e!==\"float32\"&&e!==\"complex64\"||t===\"bool\"&&e===\"bool\")}function Uh(e){if(e===\"float32\"||e===\"int32\")return 4;if(e===\"complex64\")return 8;if(e===\"bool\")return 1;throw new Error(`Unknown dtype ${e}`)}function zS(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function Jr(e){return typeof e==\"string\"||e instanceof String}function WS(e){return typeof e==\"boolean\"}function BS(e){return typeof e==\"number\"}function $c(e){return Array.isArray(e)?$c(e[0]):e instanceof Float32Array?\"float32\":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?\"int32\":BS(e)?\"float32\":Jr(e)?\"string\":WS(e)?\"bool\":\"float32\"}function ss(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Gh(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function Xl(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let a=t-3;a>=0;--a)n[a]=n[a+1]*e[a+1];return n}function VS(e,t,n,a=!1){let r=new Array;if(t.length===1){let s=t[0]*(a?2:1);for(let i=0;i<s;i++)r[i]=n[e+i]}else{let s=t[0],i=t.slice(1),o=i.reduce((l,u)=>l*u)*(a?2:1);for(let l=0;l<s;l++)r[l]=VS(e+l*o,i,n,a)}return r}function El(e,t,n=!1){if(e.length===0)return t[0];let a=e.reduce((r,s)=>r*s)*(n?2:1);if(a===0)return[];if(a!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?\" for a complex tensor\":\"\"}.`);return VS(0,e,t,n)}function aM(e,t){if(Array.isArray(e))return e;if(t===\"float32\")return e instanceof Float32Array?e:new Float32Array(e);if(t===\"int32\")return e instanceof Int32Array?e:new Int32Array(e);if(t===\"bool\"||t===\"string\")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function Nv(e,t){let n=xm(e,t);for(let a=0;a<n.length;a++)n[a]=1;return n}function xm(e,t){if(t==null||t===\"float32\"||t===\"complex64\")return new Float32Array(e);if(t===\"int32\")return new Int32Array(e);if(t===\"bool\")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function rM(e,t){let n=e.reduce((a,r)=>a*r,1);if(t==null||t===\"float32\")return El(e,new Float32Array(n));if(t===\"int32\")return El(e,new Int32Array(n));if(t===\"bool\")return El(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function na(e){e.forEach(t=>{A(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function sM(e,t,n){if(t===0)return 0;if(t===1)return e[0];let a=e[e.length-1];for(let r=0;r<e.length-1;++r)a+=n[r]*e[r];return a}function iM(e,t,n){if(t===0)return[];if(t===1)return[e];let a=new Array(t);for(let r=0;r<a.length-1;++r)a[r]=Math.floor(e/n[r]),e-=a[r]*n[r];return a[a.length-1]=e,a}function vm(e){return e&&e.then&&typeof e.then==\"function\"}var jk=\"tfjsflags\",US=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=oM,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(G().getBool(\"IS_TEST\")||G().getBool(\"PROD\")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let a=this.urlFlags[e];G().getBool(\"IS_TEST\")||G().getBool(\"PROD\")||console.warn(`Setting feature override from URL ${e}: ${a}.`),this.set(e,a)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(vm(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global==\"undefined\"||typeof this.global.location==\"undefined\"||typeof this.global.location.search==\"undefined\")return;let e=this.getQueryParams(this.global.location.search);jk in e&&e[jk].split(\",\").forEach(t=>{let[n,a]=t.split(\":\");this.urlFlags[n]=uM(n,a)})}};function oM(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...a)=>(lM(t,a[0],a[1]),a.join(\"=\"))),t}function lM(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||\"\")}function uM(e,t){let n=t.toLowerCase();return n===\"true\"||n===\"false\"?n===\"true\":`${+n}`===n?+n:t}function G(){return Tv}var Tv=null;function pM(e){Tv=e}var rx;function GS(){if(rx==null){let e;if(typeof window!=\"undefined\")e=window;else if(typeof __webpack_require__.g!=\"undefined\")e=__webpack_require__.g;else if(typeof process!=\"undefined\")e=process;else if(typeof self!=\"undefined\")process=self;else throw new Error(\"Could not find a global object\");rx=e}return rx}function cM(){let e=GS();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function Cv(e,t){let n=cM();if(n.has(e))return n.get(e);{let a=t();return n.set(e,a),n.get(e)}}var Yl=\"Abs\",Ni=\"Acos\",Ti=\"Acosh\",vs=\"Add\",Ci=\"AddN\",Zl=\"All\",Jl=\"Any\",Ql=\"ArgMax\",eu=\"ArgMin\",Ei=\"Asin\",_i=\"Asinh\",Ai=\"Atan\",Fi=\"Atanh\",$i=\"Atan2\",Di=\"AvgPool\",Dc=\"AvgPoolGrad\",tu=\"AvgPool3D\",Rc=\"AvgPool3DGrad\",Ri=\"BatchMatMul\",nu=\"BatchToSpaceND\",au=\"Bincount\",ru=\"BitwiseAnd\",HS=\"BroadcastTo\",Mc=\"BroadcastArgs\",Mi=\"Cast\",Oi=\"Ceil\",ws=\"ClipByValue\",wm=\"Complex\",Oc=\"ComplexAbs\",su=\"Concat\",Pi=\"Conv2D\",km=\"Conv2DBackpropFilter\",Li=\"Conv2DBackpropInput\",zi=\"Conv3D\",iu=\"Conv3DBackpropFilterV2\",ou=\"Conv3DBackpropInputV2\",Wi=\"Cos\",Bi=\"Cosh\",lu=\"Cumprod\",Vi=\"Cumsum\",uu=\"CropAndResize\",Pc=\"DenseBincount\",pu=\"DepthToSpace\",Ui=\"DepthwiseConv2dNative\",Im=\"DepthwiseConv2dNativeBackpropFilter\",Sm=\"DepthwiseConv2dNativeBackpropInput\",Lc=\"Diag\",Gi=\"Dilation2D\",Dl=\"Dilation2DBackpropInput\",Rl=\"Dilation2DBackpropFilter\",Nm=\"Draw\",Hi=\"RealDiv\",Tm=\"Einsum\",ji=\"Elu\",cu=\"EluGrad\",qi=\"Erf\",du=\"Equal\",Ki=\"Exp\",hu=\"ExpandDims\",Xi=\"Expm1\",Cm=\"FFT\",zc=\"Fill\",mu=\"FlipLeftRight\",Yi=\"Floor\",Zi=\"FloorDiv\",Ji=\"FusedBatchNorm\",fu=\"GatherV2\",gu=\"GatherNd\",bu=\"Greater\",Qi=\"GreaterEqual\",eo=\"Identity\",Em=\"IFFT\",_m=\"Imag\",to=\"IsFinite\",no=\"IsInf\",ao=\"IsNan\",ro=\"LeakyRelu\",yu=\"Less\",xu=\"LessEqual\",vu=\"LinSpace\",so=\"Log\",io=\"Log1p\",wu=\"LogicalAnd\",ku=\"LogicalNot\",Iu=\"LogicalOr\",jS=\"LogicalXor\",qS=\"LogSoftmax\",dM=\"LowerBound\",oo=\"LRN\",Su=\"LRNGrad\",hM=\"MatrixBandPart\",lo=\"Max\",uo=\"Maximum\",po=\"MaxPool\",Wc=\"MaxPoolGrad\",Nu=\"MaxPool3D\",Bc=\"MaxPool3DGrad\",Vc=\"MaxPoolWithArgmax\",co=\"Mean\",ho=\"Min\",mo=\"Minimum\",fo=\"MirrorPad\",go=\"Mod\",Tu=\"Multinomial\",bo=\"Multiply\",Cu=\"Neg\",Eu=\"NotEqual\",_u=\"NonMaxSuppressionV3\",Au=\"NonMaxSuppressionV4\",Fu=\"NonMaxSuppressionV5\",$u=\"OnesLike\",yo=\"OneHot\",Du=\"Pack\",xo=\"PadV2\",mM=\"Pool\",vo=\"Pow\",wo=\"Prelu\",ko=\"Prod\",Am=\"RaggedGather\",Fm=\"RaggedRange\",$m=\"RaggedTensorToTensor\",Uc=\"Range\",Dm=\"Real\",Io=\"Reciprocal\",So=\"Relu\",Ru=\"Reshape\",No=\"ResizeNearestNeighbor\",Mu=\"ResizeNearestNeighborGrad\",To=\"ResizeBilinear\",Ou=\"ResizeBilinearGrad\",Co=\"Relu6\",Eo=\"Reverse\",_o=\"Round\",Ao=\"Rsqrt\",Pu=\"ScatterNd\",Lu=\"TensorScatterUpdate\",zu=\"SearchSorted\",Wu=\"Select\",Fo=\"Selu\",Bu=\"Slice\",$o=\"Sin\",Do=\"Sinh\",Ro=\"Sign\",Mo=\"Sigmoid\",Oo=\"Softplus\",Po=\"Sqrt\",Lo=\"Sum\",Vu=\"SpaceToBatchND\",Uu=\"SplitV\",zo=\"Softmax\",Gc=\"SparseFillEmptyRows\",Gu=\"SparseReshape\",Hc=\"SparseSegmentMean\",jc=\"SparseSegmentSum\",Hu=\"SparseToDense\",Wo=\"SquaredDifference\",qc=\"Square\",Kc=\"StaticRegexReplace\",ju=\"StridedSlice\",Xc=\"StringNGrams\",Yc=\"StringSplit\",Zc=\"StringToHashBucketFast\",Bo=\"Sub\",Vo=\"Tan\",Uo=\"Tanh\",ks=\"Tile\",qu=\"TopK\",Ku=\"Transform\",Cr=\"Transpose\",Jc=\"Unique\",Xu=\"Unpack\",Qc=\"UnsortedSegmentSum\",fM=\"UpperBound\",Yu=\"ZerosLike\",Is=\"Step\",Hh=\"FromPixels\",Zu=\"RotateWithOffset\",ii=\"_FusedMatMul\",oi=\"FusedConv2D\",li=\"FusedDepthwiseConv2D\";function Zr(...e){G().getBool(\"IS_TEST\")||G().getBool(\"PROD\")||console.warn(...e)}function gM(...e){G().getBool(\"IS_TEST\")||G().getBool(\"PROD\")||console.log(...e)}var Ml=Cv(\"kernelRegistry\",()=>new Map),mc=Cv(\"gradRegistry\",()=>new Map);function fc(e,t){let n=Ev(e,t);return Ml.get(n)}function vx(e){return mc.get(e)}function jh(e){let t=Ml.entries(),n=[];for(;;){let{done:a,value:r}=t.next();if(a)break;let[s,i]=r,[o]=s.split(\"_\");o===e&&n.push(i)}return n}function ed(e){let{kernelName:t,backendName:n}=e,a=Ev(t,n);Ml.has(a)&&Zr(`The kernel '${t}' for backend '${n}' is already registered`),Ml.set(a,e)}function KS(e){let{kernelName:t}=e;mc.has(t)&&G().getBool(\"DEBUG\")&&Zr(`Overriding the gradient for '${t}'`),mc.set(t,e)}function bM(e,t){let n=Ev(e,t);if(!Ml.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);Ml.delete(n)}function yM(e){if(!mc.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);mc.delete(e)}function xM(e,t){jh(e).forEach(n=>{let a=Object.assign({},n,{backendName:t});ed(a)})}function Ev(e,t){return`${t}_${e}`}var w={};_e(w,{arraysEqual:()=>Ar,arraysEqualWithNull:()=>RS,assert:()=>A,assertNonNegativeIntegerDimensions:()=>na,assertNonNull:()=>Si,assertShapesMatch:()=>Nn,bytesFromStringArray:()=>zS,bytesPerElement:()=>Uh,checkConversionForErrors:()=>PS,clamp:()=>hc,computeStrides:()=>Xl,convertBackendValuesAndArrayBuffer:()=>aM,createScalarValue:()=>NM,createShuffledIndices:()=>QR,decodeString:()=>qh,distSquared:()=>XR,encodeString:()=>nd,fetch:()=>CM,fingerPrint64:()=>SM,flatten:()=>is,getArrayFromDType:()=>Sv,getTypedArrayFromDType:()=>OS,hasEncodingLoss:()=>nM,hexToLong:()=>td,indexToLoc:()=>iM,inferDtype:()=>$c,inferFromImplicitShape:()=>tM,isBoolean:()=>WS,isFunction:()=>ss,isInt:()=>$l,isNumber:()=>BS,isPromise:()=>vm,isScalarShape:()=>YR,isString:()=>Jr,isTypedArray:()=>en,isValidDtype:()=>LS,locToIndex:()=>sM,makeOnesTypedArray:()=>Nv,makeZerosNestedTypedArray:()=>rM,makeZerosTypedArray:()=>xm,nearestDivisor:()=>Gh,nearestLargerEven:()=>jR,now:()=>gc,parseAxisParam:()=>Aa,randUniform:()=>KR,repeatedTry:()=>eM,rightPad:()=>uc,shuffle:()=>DS,shuffleCombo:()=>HR,sizeFromShape:()=>ot,sizeToSquarishShape:()=>JR,squeezeShape:()=>MS,sum:()=>qR,swap:()=>Vh,tanh:()=>ZR,toNestedArray:()=>El,toTypedArray:()=>Rm});function XS(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var qk=xs(ER()),Ys=qk.default||qk;function td(e){return Ys.fromString(e,!0,16)}var YS=td(\"c3a5c85c97cb3127\"),Ks=td(\"b492b66fbe98f273\"),wn=td(\"9ae16a3b2f90404f\");function wx(e){return e.xor(e.shru(47))}function ZS(e,t,n){let a=e.slice(t,t+n);return Ys.fromBytes(Array.from(a),!0,!0)}function bt(e,t){return ZS(e,t,8)}function Kk(e,t){return ZS(e,t,4)}function Qt(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function ns(e,t,n=td(\"9ddfea08eb382d69\")){let a=e.xor(t).mul(n);a=a.xor(a.shru(47));let r=t.xor(a).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function vM(e,t,n,a,r,s){r=r.add(e),s=Qt(s.add(r).add(a),21);let i=r;return r=r.add(t),r=r.add(n),s=s.add(Qt(r,44)),[r.add(a),s.add(i)]}function xh(e,t,n,a){return vM(bt(e,t),bt(e,t+8),bt(e,t+16),bt(e,t+24),n,a)}function wM(e,t=e.length){if(t>=8){let n=wn.add(t*2),a=bt(e,0).add(wn),r=bt(e,t-8),s=Qt(r,37).mul(n).add(a),i=Qt(a,25).add(r).mul(n);return ns(s,i,n)}if(t>=4){let n=wn.add(t*2),a=Kk(e,0);return ns(a.shl(3).add(t),Kk(e,t-4),n)}if(t>0){let n=e[0],a=e[t>>1],r=e[t-1],s=n+(a<<8),i=t+(r<<2);return wx(wn.mul(s).xor(YS.mul(i))).mul(wn)}return wn}function kM(e,t=e.length){let n=wn.add(t*2),a=bt(e,0).mul(Ks),r=bt(e,8),s=bt(e,t-8).mul(n),i=bt(e,t-16).mul(wn);return ns(Qt(a.add(r),43).add(Qt(s,30)).add(i),a.add(Qt(r.add(wn),18)).add(s),n)}function IM(e,t=e.length){let n=wn.add(t*2),a=bt(e,0).mul(wn),r=bt(e,8),s=bt(e,t-8).mul(n),i=bt(e,t-16).mul(wn),o=Qt(a.add(r),43).add(Qt(s,30)).add(i),l=ns(o,a.add(Qt(r.add(wn),18)).add(s),n),u=bt(e,16).mul(n),p=bt(e,24),d=o.add(bt(e,t-32)).mul(n),c=l.add(bt(e,t-24)).mul(n);return ns(Qt(u.add(p),43).add(Qt(d,30)).add(c),u.add(Qt(p.add(a),18)).add(d),n)}function SM(e,t=e.length){let n=Ys.fromNumber(81,!0);if(t<=32)return t<=16?wM(e,t):kM(e,t);if(t<=64)return IM(e,t);let a=n,r=n.mul(Ks).add(113),s=wx(r.mul(wn).add(113)).mul(wn),i=[Ys.UZERO,Ys.UZERO],o=[Ys.UZERO,Ys.UZERO];a=a.mul(wn).add(bt(e,0));let l=0,u=(t-1>>6)*64,p=u+(t-1&63)-63;do a=Qt(a.add(r).add(i[0]).add(bt(e,l+8)),37).mul(Ks),r=Qt(r.add(i[1]).add(bt(e,l+48)),42).mul(Ks),a=a.xor(o[1]),r=r.add(i[0]).add(bt(e,l+40)),s=Qt(s.add(o[0]),33).mul(Ks),i=xh(e,l,i[1].mul(Ks),a.add(o[0])),o=xh(e,l+32,s.add(o[1]),r.add(bt(e,l+16))),[s,a]=[a,s],l+=64;while(l!==u);let d=Ks.add(s.and(255).shl(1));return l=p,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),a=Qt(a.add(r).add(i[0]).add(bt(e,l+8)),37).mul(d),r=Qt(r.add(i[1]).add(bt(e,l+48)),42).mul(d),a=a.xor(o[1].mul(9)),r=r.add(i[0].mul(9).add(bt(e,l+40))),s=Qt(s.add(o[0]),33).mul(d),i=xh(e,l,i[1].mul(d),a.add(o[0])),o=xh(e,l+32,s.add(o[1]),r.add(bt(e,l+16))),[s,a]=[a,s],ns(ns(i[0],o[0],d).add(wx(r).mul(YS)).add(s),ns(i[1],o[1],d).add(a),d)}function NM(e,t){return t===\"string\"?nd(e):Rm([e],t)}function TM(e,t){return e instanceof Float32Array&&t===\"float32\"||e instanceof Int32Array&&t===\"int32\"||e instanceof Uint8Array&&t===\"bool\"}function Rm(e,t){if(t===\"string\")throw new Error(\"Cannot convert a string[] to a TypedArray\");if(Array.isArray(e)&&(e=is(e)),G().getBool(\"DEBUG\")&&PS(e,t),TM(e,t))return e;if(t==null||t===\"float32\"||t===\"complex64\")return new Float32Array(e);if(t===\"int32\")return new Int32Array(e);if(t===\"bool\"){let n=new Uint8Array(e.length);for(let a=0;a<n.length;++a)Math.round(e[a])!==0&&(n[a]=1);return n}else throw new Error(`Unknown data type ${t}`)}function gc(){return G().platform.now()}function CM(e,t){return G().platform.fetch(e,t)}function nd(e,t=\"utf-8\"){return t=t||\"utf-8\",G().platform.encode(e,t)}function qh(e,t=\"utf-8\"){return t=t||\"utf-8\",G().platform.decode(e,t)}function en(e){return G().platform.isTypedArray!=null?G().platform.isTypedArray(e):XS(e)}function is(e,t=[],n=!1){if(t==null&&(t=[]),typeof e==\"boolean\"||typeof e==\"number\"||typeof e==\"string\"||vm(e)||e==null||en(e)&&n)t.push(e);else if(Array.isArray(e)||en(e))for(let a=0;a<e.length;++a)is(e[a],t,n);else{let a=-1;for(let r of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(r)&&(a=Math.max(a,Number(r)));for(let r=0;r<=a;r++)is(e[r],t,n)}return t}var EM=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new AM)}profileKernel(e,t,n){let a,r=()=>{a=n()},s,i=gc();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(r);else{r();for(let o of a)o.dataSync();s=Promise.resolve({kernelMs:gc()-i})}if(G().getBool(\"CHECK_COMPUTATION_FOR_ERRORS\"))for(let o=0;o<a.length;o++){let l=a[o];l.data().then(u=>{_M(u,l.dtype,e)})}return{kernelName:e,outputs:a,inputs:t,timeMs:s.then(o=>o.kernelMs),extraInfo:s.then(o=>o.getExtraProfileInfo!=null?o.getExtraProfileInfo():\"\")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:a,inputs:r,extraInfo:s}=e;n.forEach(i=>{Promise.all([i.data(),a,s]).then(o=>{this.logger.logKernelProfile(t,i,o[0],o[1],r,o[2])})})}};function _M(e,t,n){if(t!==\"float32\")return!1;for(let a=0;a<e.length;a++){let r=e[a];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}var AM=class{logKernelProfile(e,t,n,a,r,s){let i=typeof a==\"number\"?uc(`${a}ms`,9):a.error,o=uc(e,25),l=t.rank,u=t.size,p=uc(t.shape.toString(),14),d=\"\";for(let c in r){let h=r[c];if(h!=null){let m=h.shape||t.shape,f=m.length;d+=`${c}: ${f}D ${f>0?m:\"\"} `}}console.log(`%c${o}\t%c${i}\t%c${l}D ${p}\t%c${u}\t%c${d}\t%c${s}`,\"font-weight:bold\",\"color:red\",\"color:blue\",\"color: orange\",\"color: green\",\"color: steelblue\")}};function FM(e,t,n){let a={},r={};for(let l=0;l<t.length;l++)a[t[l].id]=!0;for(let l=0;l<e.length;l++){let u=e[l],p=u.inputs;for(let d in p){let c=p[d],h=!1;for(let m=0;m<t.length;m++)if(a[c.id]){u.outputs.forEach(f=>a[f.id]=!0),h=!0,r[u.id]=!0;break}if(h)break}}let s={};s[n.id]=!0;let i={};for(let l=e.length-1;l>=0;l--){let u=e[l],p=u.inputs;for(let d=0;d<u.outputs.length;d++)if(s[u.outputs[d].id]){for(let c in p)s[p[c].id]=!0,i[u.id]=!0;break}}let o=[];for(let l=0;l<e.length;l++){let u=e[l];if(r[u.id]&&i[u.id]){let p={};for(let c in u.inputs){let h=u.inputs[c];a[h.id]&&(p[c]=h)}let d=Object.assign({},u);d.inputs=p,d.outputs=u.outputs,o.push(d)}}return o}function $M(e,t,n,a){for(let r=t.length-1;r>=0;r--){let s=t[r],i=[];if(s.outputs.forEach(l=>{let u=e[l.id];u!=null?i.push(u):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let o=s.gradient(i);for(let l in s.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);let u=n(()=>o[l]());if(u.dtype!==\"float32\")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);let p=s.inputs[l];if(!Ar(u.shape,p.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${p.shape}'`);if(e[p.id]==null)e[p.id]=u;else{let d=e[p.id];e[p.id]=a(d,u),d.dispose()}}}}var Xk=20,Kp=3,sx=7;function DM(e,t,n,a){let r=Xl(t),s=RM(e,t,n,r),i=t.length,o=Dh(e,t,n,r,s),l=[\"Tensor\"];return a&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push(\"  values:\")),l.push(o.map(u=>\"    \"+u).join(`\n`)),l.join(`\n`)}function RM(e,t,n,a){let r=ot(t),s=a[a.length-1],i=new Array(s).fill(0),o=t.length,l=n===\"complex64\"?ec(e):e;if(o>1)for(let u=0;u<r/s;u++){let p=u*s;for(let d=0;d<s;d++)i[d]=Math.max(i[d],Qp(l[p+d],0,n).length)}return i}function Qp(e,t,n){let a;return Array.isArray(e)?a=`${parseFloat(e[0].toFixed(sx))} + ${parseFloat(e[1].toFixed(sx))}j`:Jr(e)?a=`'${e}'`:n===\"bool\"?a=JS(e):a=parseFloat(e.toFixed(sx)).toString(),uc(a,t)}function JS(e){return e===0?\"false\":\"true\"}function Dh(e,t,n,a,r,s=!0){let i=n===\"complex64\"?2:1,o=t[0],l=t.length;if(l===0){if(n===\"complex64\"){let f=ec(e);return[Qp(f[0],0,n)]}return n===\"bool\"?[JS(e[0])]:[e[0].toString()]}if(l===1){if(o>Xk){let f=Kp*i,g=Array.from(e.slice(0,f)),b=Array.from(e.slice((o-Kp)*i,o*i));return n===\"complex64\"&&(g=ec(g),b=ec(b)),[\"[\"+g.map((y,x)=>Qp(y,r[x],n)).join(\", \")+\", ..., \"+b.map((y,x)=>Qp(y,r[o-Kp+x],n)).join(\", \")+\"]\"]}return[\"[\"+(n===\"complex64\"?ec(e):Array.from(e)).map((f,g)=>Qp(f,r[g],n)).join(\", \")+\"]\"]}let u=t.slice(1),p=a.slice(1),d=a[0]*i,c=[];if(o>Xk){for(let f=0;f<Kp;f++){let g=f*d,b=g+d;c.push(...Dh(e.slice(g,b),u,n,p,r,!1))}c.push(\"...\");for(let f=o-Kp;f<o;f++){let g=f*d,b=g+d;c.push(...Dh(e.slice(g,b),u,n,p,r,f===o-1))}}else for(let f=0;f<o;f++){let g=f*d,b=g+d;c.push(...Dh(e.slice(g,b),u,n,p,r,f===o-1))}let h=l===2?\",\":\"\";c[0]=\"[\"+(o>0?c[0]+h:\"\");for(let f=1;f<c.length-1;f++)c[f]=\" \"+c[f]+h;let m=`,\n`;for(let f=2;f<l;f++)m+=`\n`;return c[c.length-1]=\" \"+c[c.length-1]+\"]\"+(s?\"\":m),c}function ec(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var Wt=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=ot(e),n!=null){let a=n.length;A(a===this.size,()=>`Length of values '${a}' does not match the size inferred by the shape '${this.size}'.`)}if(t===\"complex64\")throw new Error(\"complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).\");this.values=n||Sv(t,this.size),this.strides=Xl(e)}set(e,...t){t.length===0&&(t=[0]),A(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let a of e){if(a<0||a>=this.shape[t]){let r=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(r)}t++}let n=e[e.length-1];for(let a=0;a<e.length-1;++a)n+=this.strides[a]*e[a];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return za().makeTensor(this.values,this.shape,this.dtype)}},za=null,Sl=null,MM=null;function OM(e){za=e}function PM(e){Sl=e}function LM(e){MM=e}var Ce=class{constructor(e,t,n,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||\"float32\",this.size=ot(e),this.strides=Xl(e),this.dataId=n,this.id=a,this.rankType=this.rank<5?this.rank.toString():\"higher\"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return Sl.buffer(this.shape,this.dtype,e)}bufferSync(){return Sl.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return El(this.shape,e,this.dtype===\"complex64\")}arraySync(){return El(this.shape,this.dataSync(),this.dtype===\"complex64\")}async data(){this.throwIfDisposed();let e=za().read(this.dataId);if(this.dtype===\"string\"){let t=await e;try{return t.map(n=>qh(n))}catch(n){throw new Error(\"Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().\")}}return e}dataToGPU(e){return this.throwIfDisposed(),za().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=za().readSync(this.dataId);if(this.dtype===\"string\")try{return e.map(t=>qh(t))}catch(t){throw new Error(\"Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().\")}return e}async bytes(){this.throwIfDisposed();let e=await za().read(this.dataId);return this.dtype===\"string\"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),za().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error(\"Tensor is disposed.\")}print(e=!1){return Sl.print(this,e)}clone(){return this.throwIfDisposed(),Sl.clone(this)}toString(e=!1){let t=this.dataSync();return DM(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Sl.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),za().makeVariable(this,e,t,n)}};Object.defineProperty(Ce,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function Q(){return Cv(\"Tensor\",()=>Ce)}Q();var os=class extends Ce{constructor(e,t,n,a){super(e.shape,e.dtype,e.dataId,a),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Ar(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);za().disposeTensor(this),this.dataId=e.dataId,za().incRef(this,null)}dispose(){za().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(os,Symbol.hasInstance,{value:e=>e instanceof Ce&&e.assign!=null&&e.assign instanceof Function});var Wa={};_e(Wa,{assertTypesMatch:()=>tN,getTensorsInContainer:()=>_v,isTensorInList:()=>WM,makeTypesMatch:()=>_t});var kx;(function(e){e.R0=\"R0\",e.R1=\"R1\",e.R2=\"R2\",e.R3=\"R3\",e.R4=\"R4\",e.R5=\"R5\",e.R6=\"R6\"})(kx||(kx={}));var Ix;(function(e){e.float32=\"float32\",e.int32=\"int32\",e.bool=\"int32\",e.complex64=\"complex64\"})(Ix||(Ix={}));var Sx;(function(e){e.float32=\"float32\",e.int32=\"int32\",e.bool=\"bool\",e.complex64=\"complex64\"})(Sx||(Sx={}));var Nx;(function(e){e.float32=\"float32\",e.int32=\"float32\",e.bool=\"float32\",e.complex64=\"complex64\"})(Nx||(Nx={}));var Tx;(function(e){e.float32=\"complex64\",e.int32=\"complex64\",e.bool=\"complex64\",e.complex64=\"complex64\"})(Tx||(Tx={}));var zM={float32:Nx,int32:Ix,bool:Sx,complex64:Tx};function fa(e,t){if(e===\"string\"||t===\"string\"){if(e===\"string\"&&t===\"string\")return\"string\";throw new Error(`Can not upcast ${e} with ${t}`)}return zM[e][t]}function Mm(e){return fa(e,\"int32\")}function QS(e){return e!=null&&typeof e==\"object\"&&\"texture\"in e&&e.texture instanceof WebGLTexture}function eN(e){return typeof GPUBuffer!=\"undefined\"&&e!=null&&typeof e==\"object\"&&\"buffer\"in e&&e.buffer instanceof GPUBuffer}function _t(e,t){if(e.dtype===t.dtype)return[e,t];let n=fa(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function tN(e,t){A(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function WM(e,t){return t.some(n=>n.id===e.id)}function _v(e){let t=[];return nN(e,t,new Set),t}function nN(e,t,n){if(e==null)return;if(e instanceof Ce){t.push(e);return}if(!BM(e))return;let a=e;for(let r in a){let s=a[r];n.has(s)||(n.add(s),nN(s,t,n))}}function BM(e){return Array.isArray(e)||typeof e==\"object\"}function ix(e){return e.kernelName!=null}var Yk=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},Av=class Cx{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Yk}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let a=t[n];if(await this.initializeBackend(a).success){await this.setBackend(a);return}}throw new Error(\"Could not initialize any backends, all backend initializations failed.\")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,a=1){return t in this.registryFactory?(Zr(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:a},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:n,asyncInit:a}=this.initializeBackend(t);if(!(a?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new EM(this.backendInstance),!0}setupRegisteredKernels(){jh(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){jh(t).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[t])})}initializeBackend(t){let n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let a=n.factory();if(a&&!(a instanceof Fc)&&typeof a.then==\"function\"){let r=++this.pendingBackendInitId,s=a.then(i=>r<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Zr(`Initialization of backend ${t} failed`),Zr(i.stack||i.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[t]=a,{success:!0,asyncInit:!1}}catch(a){return Zr(`Initialization of backend ${t} failed`),Zr(a.stack||a.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error(\"No backend found in registry.\");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let a=t[n],{success:r,asyncInit:s}=this.initializeBackend(a);if(s||r)return{name:a,asyncInit:s}}throw new Error(\"Could not initialize any backends, all backend initializations failed.\")}moveData(t,n){let a=this.state.tensorInfo.get(n),r=a.backend,s=this.readSync(n),i=r.refCount(n);r.disposeData(n,!0),a.backend=t,t.move(n,s,a.shape,a.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let a=null;if(n==null){if(typeof t!=\"function\")throw new Error(\"Please provide a function to tidy()\");n=t}else{if(typeof t!=\"string\"&&!(t instanceof String))throw new Error(\"When calling with two arguments, the first argument to tidy() must be a string\");if(typeof n!=\"function\")throw new Error(\"When calling with two arguments, the 2nd argument to tidy() must be a function\");a=t}let r;return this.scopedRun(()=>this.startScope(a),()=>this.endScope(r),()=>(r=n(),r instanceof Promise&&console.error(\"Cannot return a Promise inside of tidy.\"),r))}scopedRun(t,n,a){t();try{let r=a();return n(),r}catch(r){throw n(),r}}nextTensorId(){return Cx.nextTensorId++}nextVariableId(){return Cx.nextVariableId++}clone(t){let n=P.runKernel(eo,{x:t}),a={x:t},r=i=>({x:()=>{let o=\"float32\",l={x:i},u={dtype:o};return P.runKernel(Mi,l,u)}}),s=[];return this.addTapeNode(this.state.activeScope.name,a,[n],r,s,{}),n}runKernel(t,n,a){if(this.backendName==null&&this.backend,fc(t,this.backendName)==null)throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:a})}shouldCheckForMemLeaks(){return this.ENV.getBool(\"IS_TEST\")}checkKernelForMemLeak(t,n,a){let r=this.backend.numDataIds(),s=0;a.forEach(l=>{s+=l.dtype===\"complex64\"?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-n-s-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let n,a=[],r=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l,u=ix(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:\"\";if(ix(t)){let{kernelName:m,inputs:f,attrs:g}=t;this.backendName==null&&this.backend;let b=fc(m,this.backendName);A(b!=null,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),o=()=>{let y=this.backend.numDataIds();l=b.kernelFunc({inputs:f,attrs:g,backend:this.backend});let x=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,y,x);let v=x.map(I=>I.rank!=null?I:this.makeTensorFromTensorInfo(I));if(r){let I=this.getTensorsForGradient(m,f,v);a=this.saveTensorsForBackwardMode(I)}return v}}else{let{forwardFunc:m}=t,f=g=>{r&&(a=g.map(b=>this.keep(this.clone(b))))};o=()=>{let g=this.backend.numDataIds();l=this.tidy(()=>m(this.backend,f));let b=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,g,b),b}}let{inputs:p,attrs:d}=t,c=ix(t)?null:t.backwardsFunc,h;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool(\"DEBUG\")&&!this.state.profiling?n=o():(h=this.profiler.profileKernel(u,p,()=>o()),this.ENV.getBool(\"DEBUG\")&&this.profiler.logKernelProfile(h),n=h.outputs)}),r&&this.addTapeNode(u,p,n,c,a,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map(m=>p[m]!=null?p[m].shape:null),outputShapes:n.map(m=>m.shape),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,n,a){let r=vx(t);if(r!=null){let s=r.inputsToSave||[],i=r.outputsToSave||[],o;r.saveAllInputs?(A(Array.isArray(n),()=>\"saveAllInputs is true, expected inputs to be an array.\"),o=Object.keys(n).map(u=>n[u])):o=s.map(u=>n[u]);let l=a.filter((u,p)=>i[p]);return o.concat(l)}return[]}makeTensor(t,n,a,r){if(t==null)throw new Error(\"Values passed to engine.makeTensor() are null\");a=a||\"float32\",r=r||this.backend;let s=t;a===\"string\"&&Jr(t[0])&&(s=t.map(l=>nd(l)));let i=r.write(s,n,a),o=new Ce(n,a,i,this.nextTensorId());if(this.trackTensor(o,r),a===\"string\"){let l=this.state.tensorInfo.get(i),u=zS(s);this.state.numBytes+=u-l.bytes,l.bytes=u}return o}makeTensorFromDataId(t,n,a,r){a=a||\"float32\";let s={dataId:t,shape:n,dtype:a};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(t,n){let{dataId:a,shape:r,dtype:s}=t,i=new Ce(r,s,a,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(t,n=!0,a,r){a=a||this.nextVariableId().toString(),r!=null&&r!==t.dtype&&(t=t.cast(r));let s=new os(t,n,a,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,n){this.state.numTensors++,t.dtype===\"string\"&&this.state.numStringTensors++;let a=0;t.dtype!==\"complex64\"&&t.dtype!==\"string\"&&(a=t.size*Uh(t.dtype)),this.state.numBytes+=a,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:a})),t instanceof os||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype===\"string\"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!==\"complex64\"&&t.dtype!==\"string\"){let a=t.size*Uh(t.dtype);this.state.numBytes-=a}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push(\"Memory usage by string tensors is approximate (2 bytes per character)\")),t}async profile(t){this.state.profiling=!0;let n=this.state.numBytes,a=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-a;for(let r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,a,r,s,i){let o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:a,saved:s},l=vx(t);l!=null&&(r=l.gradFunc),r!=null&&(o.gradient=u=>(u=u.map((p,d)=>{if(p==null){let c=a[d],h=xm(c.size,c.dtype);return this.makeTensor(h,c.shape,c.dtype)}return p}),r(u.length>1?u:u[0],s,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let n={track:[],name:\"unnamed scope\",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){let n=_v(t),a=new Set(n.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let i=this.state.activeScope.track[s];!i.kept&&!a.has(i.id)&&i.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(s=>{!s.kept&&s.scopeId===r.id&&this.track(s)})}gradients(t,n,a,r=!1){if(A(n.length>0,()=>\"gradients() received an empty list of xs.\"),a!=null&&a.dtype!==\"float32\")throw new Error(`dy must have 'float32' dtype, but has '${a.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy(\"forward\",t));A(s instanceof Ce,()=>\"The result y returned by f() must be a tensor.\");let i=FM(this.state.activeTape,n,s);if(!r&&i.length===0&&n.length>0)throw new Error(\"Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.\");return this.tidy(\"backward\",()=>{let o={};o[s.id]=a==null?VM(s.shape):a,$M(o,i,u=>this.tidy(u),UM);let l=n.map(u=>o[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(let p of u.saved)p.dispose()}),this.state.activeTape=null),{value:s,grads:l}})}customGrad(t){return A(ss(t),()=>\"The f passed in customGrad(f) must be a function.\"),(...n)=>{A(n.every(o=>o instanceof Ce),()=>\"The args passed in customGrad(f)(x1, x2,...) must all be tensors\");let a,r={};n.forEach((o,l)=>{r[l]=o});let s=(o,l)=>(a=t(...n,l),A(a.value instanceof Ce,()=>\"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor\"),A(ss(a.gradFunc),()=>\"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.\"),a.value),i=(o,l)=>{let u=a.gradFunc(o,l),p=Array.isArray(u)?u:[u];A(p.length===n.length,()=>\"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).\"),A(p.every(c=>c instanceof Ce),()=>\"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.\");let d={};return p.forEach((c,h)=>{d[h]=()=>c}),d};return this.runKernelFunc({forwardFunc:s,backwardsFunc:i,inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){let n=gc(),a=await this.backend.time(t);return a.wallMs=gc()-n,a}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Yk;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};Av.nextTensorId=0;Av.nextVariableId=0;function VM(e){let t=Nv(ot(e),\"float32\");return P.makeTensor(t,e,\"float32\")}function aN(){let e=GS();if(e._tfengine==null){let t=new US(e);e._tfengine=new Av(t)}return pM(e._tfengine.ENV),OM(()=>e._tfengine),e._tfengine}var P=aN();function UM(e,t){let n={a:e,b:t};return P.runKernel(vs,n)}var ad={};_e(ad,{isBrowser:()=>rN,isMobile:()=>jM,mockIsMobile:()=>HM});function GM(){return typeof navigator!=\"undefined\"&&navigator!=null}var Ex;function HM(e){Ex=e}function jM(e){if(Ex!==void 0)return Ex;if(e||GM()){if(e||(e=navigator),e.product===\"ReactNative\")return!0;let t=e.userAgent||e.vendor||(typeof window!=\"undefined\"?window.opera:\"\");if(!t){let n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(t.substr(0,4))}return!1}function rN(){return typeof window!=\"undefined\"&&window.document!=null||typeof WorkerGlobalScope!=\"undefined\"}var Wn=G();Wn.registerFlag(\"DEBUG\",()=>!1,e=>{e&&console.warn(\"Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.\")});Wn.registerFlag(\"IS_BROWSER\",()=>rN());Wn.registerFlag(\"IS_NODE\",()=>typeof process!=\"undefined\"&&typeof process.versions!=\"undefined\"&&typeof process.versions.node!=\"undefined\");Wn.registerFlag(\"IS_CHROME\",()=>typeof navigator!=\"undefined\"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Wn.registerFlag(\"IS_SAFARI\",()=>typeof navigator!=\"undefined\"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Wn.registerFlag(\"PROD\",()=>!1);Wn.registerFlag(\"TENSORLIKE_CHECK_SHAPE_CONSISTENCY\",()=>Wn.getBool(\"DEBUG\"));Wn.registerFlag(\"DEPRECATION_WARNINGS_ENABLED\",()=>!0);Wn.registerFlag(\"IS_TEST\",()=>!1);Wn.registerFlag(\"CHECK_COMPUTATION_FOR_ERRORS\",()=>Wn.getBool(\"DEBUG\"));Wn.registerFlag(\"WRAP_TO_IMAGEBITMAP\",()=>!1);Wn.registerFlag(\"CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU\",()=>!1);Wn.registerFlag(\"USE_SETTIMEOUTCUSTOM\",()=>!1);function lr(e,t){let n=e;if(en(e))return t===\"string\"?[]:[e.length];if(QS(e)){let r=e.channels||\"RGBA\";return[e.height,e.width*r.length]}else if(eN(e))return[e.buffer.size/(t==null?4:Uh(t))];if(!Array.isArray(e))return[];let a=[];for(;Array.isArray(n)||en(n)&&t!==\"string\";)a.push(n.length),n=n[0];return Array.isArray(e)&&G().getBool(\"TENSORLIKE_CHECK_SHAPE_CONSISTENCY\")&&sN(e,a,[]),a}function sN(e,t,n){if(n=n||[],!Array.isArray(e)&&!en(e)){A(t.length===0,()=>`Element arr[${n.join(\"][\")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}A(t.length>0,()=>`Element arr[${n.join(\"][\")}] should be a primitive, but is an array of ${e.length} elements`),A(e.length===t[0],()=>`Element arr[${n.join(\"][\")}] should have ${t[0]} elements, but has ${e.length} elements`);let a=t.slice(1);for(let r=0;r<e.length;++r)sN(e[r],a,n.concat(r))}function Zk(e,t,n,a){if(e!==\"string_or_numeric\"){if(e==null)throw new Error(\"Expected dtype cannot be null.\");if(e!==\"numeric\"&&e!==t||e===\"numeric\"&&t===\"string\")throw new Error(`Argument '${n}' passed to '${a}' must be ${e} tensor, but got ${t} tensor`)}}function E(e,t,n,a=\"numeric\"){if(e instanceof Q())return Zk(a,e.dtype,t,n),e;let r=$c(e);if(r!==\"string\"&&[\"bool\",\"int32\",\"float32\"].indexOf(a)>=0&&(r=a),Zk(a,r,t,n),e==null||!en(e)&&!Array.isArray(e)&&typeof e!=\"number\"&&typeof e!=\"boolean\"&&typeof e!=\"string\"){let o=e==null?\"null\":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${o}'`)}let s=lr(e,r);!en(e)&&!Array.isArray(e)&&(e=[e]);let i=r!==\"string\"?Rm(e,r):is(e,[],!0);return P.makeTensor(i,s,r)}function bc(e,t,n,a=\"numeric\"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \\`Tensor[]\\` or \\`TensorLike[]\\``);return e.map((r,s)=>E(r,`${t}[${s}]`,n,a))}var Fv=\"__op\";function L(e){let t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],a=e[n];n.endsWith(\"_\")&&(n=n.substring(0,n.length-1)),n=n+Fv;let r=(...s)=>{P.startScope(n);try{let i=a(...s);return vm(i)&&console.error(\"Cannot return a Promise inside of tidy.\"),P.endScope(i),i}catch(i){throw P.endScope(null),i}};return Object.defineProperty(r,\"name\",{value:n,configurable:!0}),r}function qM(e,t){let n=E(e,\"real\",\"complex\"),a=E(t,\"imag\",\"complex\");Nn(n.shape,a.shape,`real and imag shapes, ${n.shape} and ${a.shape}, must match in call to tf.complex().`);let r={real:n,imag:a};return P.runKernel(wm,r)}var _r=L({complex_:qM});function Ss(e,t,n,a){if(a==null)a=$c(e);else if(a===\"complex64\")throw new Error(\"Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).\");if(eN(e)||QS(e)){if(a!==\"float32\"&&a!==\"int32\")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${a}.`);return P.backend.createTensorFromGPUData(e,t||n,a)}if(!en(e)&&!Array.isArray(e)&&typeof e!=\"number\"&&typeof e!=\"boolean\"&&typeof e!=\"string\")throw new Error(\"values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray\");if(t!=null){na(t);let r=ot(t),s=ot(n);A(r===s,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${s}`);for(let i=0;i<n.length;++i){let o=n[i],l=i===n.length-1?o!==ot(t.slice(i)):!0;A(n[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!en(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=a!==\"string\"?Rm(e,a):is(e,[],!0),P.makeTensor(e,t,a)}function bn(e,t,n){let a=lr(e,n);return Ss(e,t,a,n)}var ui={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Fr=class iN{static join(t){return new iN(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(a=>en(a)?a.buffer:a),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let a=0;a<t.length;a++){let r=t[a];a!==t.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let s=n+r.byteLength;this.shards.push({buffer:r,start:n,end:s}),n=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),n=Math.min(this.byteLength,n),n<=t)return new ArrayBuffer(0);let a=this.findShardForByte(t);if(a===-1)throw new Error(`Could not find start shard for byte ${t}`);let r=n-t,s=new ArrayBuffer(r),i=new Uint8Array(s),o=0;for(let l=a;l<this.shards.length;l++){let u=this.shards[l],p=t+o-u.start,d=o,c=Math.min(n,u.end)-u.start,h=new Uint8Array(u.buffer,p,c-p);if(i.set(h,d),o+=h.length,n<u.end)break}return s}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(r){return t<r.start?-1:t>=r.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let a=KM(this.shards,n);return a===-1?-1:(this.previousShardIndex=a,this.previousShardIndex)}};function KM(e,t){let n=0,a=e.length;for(;n<=a;){let r=Math.floor((a-n)/2)+n,s=t(e[r]);if(s===0)return r;s<0?a=r:n=r+1}return-1}function XM(){G().set(\"PROD\",!0)}function YM(){G().set(\"DEBUG\",!0)}function ZM(){G().set(\"DEPRECATION_WARNINGS_ENABLED\",!1),console.warn(\"TensorFlow.js deprecation warnings have been disabled.\")}function $v(e){G().getBool(\"DEPRECATION_WARNINGS_ENABLED\")&&console.warn(e+\" You can disable deprecation warnings with tf.disableDeprecationWarnings().\")}LM($v);function JM(){P.disposeVariables()}function Ta(){return P}function Kh(){return P.memory()}function QM(e){return P.profile(e)}function O(e,t){return P.tidy(e,t)}function Ee(e){_v(e).forEach(t=>t.dispose())}function Ht(e){return P.keep(e)}function eO(e){return P.time(e)}function tO(e){return P.setBackend(e)}function nO(){return P.ready()}function oN(){return P.backendName}function aO(e){P.removeBackend(e)}function rO(e){return P.findBackend(e)}function sO(e){return P.findBackendFactory(e)}function Om(e,t,n=1){return P.registerBackend(e,t,n)}function Dv(){return P.backend}function iO(e,t){G().setPlatform(e,t)}var ls=4;async function oO(e,t){let n=[],a=[],r=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<r.length;++i){let o=r[i],l=Array.isArray(e)?e[i].tensor:e[o];if(l.dtype!==\"float32\"&&l.dtype!==\"int32\"&&l.dtype!==\"bool\"&&l.dtype!==\"string\"&&l.dtype!==\"complex64\")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);let u={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype===\"string\"){let p=new Promise(async d=>{let c=await l.bytes(),h=c.reduce((g,b)=>g+b.length,0)+ls*c.length,m=new Uint8Array(h),f=0;for(let g=0;g<c.length;g++){let b=c[g],y=new Uint8Array(new Uint32Array([b.length]).buffer);m.set(y,f),f+=ls,m.set(b,f),f+=b.length}d(m)});a.push(p)}else a.push(l.data());t!=null&&(u.group=t),n.push(u)}let s=await Promise.all(a);return{data:pO(s),specs:n}}function lN(e,t){let n=new Fr(e),a={},r=0;for(let s of t){let i=lO(s,(o,l)=>n.slice(r+o,r+l));a[s.name]=uN(s,n.slice(r,r+i)),r+=i}return a}function lO(e,t){let n=ot(e.shape),a;if(\"quantization\"in e){let r=e.quantization;a=ui[r.dtype]}else if(e.dtype===\"string\"){let r=0;for(let s=0;s<n;s++)r+=ls+new Uint32Array(t(r,r+ls))[0];return r}else a=ui[e.dtype];return n*a}async function uO(e,t){let n=ot(e.shape),a;if(\"quantization\"in e){let r=e.quantization;a=ui[r.dtype]}else if(e.dtype===\"string\"){let r=0;for(let s=0;s<n;s++)r+=ls+new Uint32Array(await t(r,r+ls))[0];return r}else a=ui[e.dtype];return n*a}function uN(e,t){let n=e.name,a=e.dtype,r=e.shape,s=ot(r),i,o=0;if(\"quantization\"in e){let l=e.quantization;if(l.dtype===\"uint8\"||l.dtype===\"uint16\"){if(!(\"min\"in l&&\"scale\"in l))throw new Error(`Weight ${e.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype===\"float16\"){if(a!==\"float32\")throw new Error(`Weight ${e.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${e.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let u=ui[l.dtype],p=l.dtype===\"uint8\"?new Uint8Array(t):new Uint16Array(t);if(a===\"float32\")if(l.dtype===\"uint8\"||l.dtype===\"uint16\"){i=new Float32Array(p.length);for(let d=0;d<p.length;d++){let c=p[d];i[d]=c*l.scale+l.min}}else if(l.dtype===\"float16\")i=bO()(p);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(a===\"int32\"){if(l.dtype!==\"uint8\"&&l.dtype!==\"uint16\")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(p.length);for(let d=0;d<p.length;d++){let c=p[d];i[d]=Math.round(c*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${a}`);o+=s*u}else if(a===\"string\"){let l=ot(e.shape);i=[];for(let u=0;u<l;u++){let p=new Uint32Array(t.slice(o,o+ls))[0];o+=ls;let d=new Uint8Array(t.slice(o,o+p));i.push(d),o+=p}}else{let l=ui[a];if(a===\"float32\")i=new Float32Array(t);else if(a===\"int32\")i=new Int32Array(t);else if(a===\"bool\")i=new Uint8Array(t);else if(a===\"complex64\"){i=new Float32Array(t);let u=new Float32Array(i.length/2),p=new Float32Array(i.length/2);for(let m=0;m<u.length;m++)u[m]=i[m*2],p[m]=i[m*2+1];let d=bn(u,r,\"float32\"),c=bn(p,r,\"float32\"),h=_r(d,c);return d.dispose(),c.dispose(),h}else throw new Error(`Unsupported dtype in weight '${n}': ${a}`);o+=s*l}return bn(i,r,a)}async function Jk(e,t,n){let a=new Uint8Array(t);for(;a.byteLength<n;){let{done:r,value:s}=await e.read();if(r&&s==null){let o=n-a.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}let i=new Uint8Array(a.length+s.byteLength);i.set(a,0),i.set(new Uint8Array(s),a.length),a=i}return a.buffer}async function pN(e,t){let n={},a=e.getReader(),r=new ArrayBuffer(0);for(let s of t){let i=await uO(s,async(u,p)=>(r=await Jk(a,r,p),r.slice(u,p)));r=await Jk(a,r,i);let o=r.slice(0,i);r=r.slice(i);let l=uN(s,o);if(n[s.name]=l,oN()===\"webgpu\"){let u=Dv();\"uploadToGPU\"in u&&ot(l.shape)>=G().get(\"WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD\")&&u.uploadToGPU(l.dataId)}}return n}function pO(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(s=>{if(t+=s.byteLength,n.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let a=new Uint8Array(t),r=0;return n.forEach(s=>{a.set(new Uint8Array(s.buffer),r),r+=s.byteLength}),a.buffer}var Rv=typeof Buffer!=\"undefined\"&&(typeof Blob==\"undefined\"||typeof atob==\"undefined\"||typeof btoa==\"undefined\");function Qk(e){return Rv?Buffer.byteLength(e,\"utf8\"):new Blob([e]).size}function cO(e){if(Rv)return Buffer.from(e).toString(\"base64\");let t=new Uint8Array(e),n=\"\";for(let a=0,r=t.length;a<r;a++)n+=String.fromCharCode(t[a]);return btoa(n)}function dO(e){if(Rv){let a=Buffer.from(e,\"base64\");return a.buffer.slice(a.byteOffset,a.byteOffset+a.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let a=0;a<t.length;++a)n.set([t.charCodeAt(a)],a);return n.buffer}function hO(e){return Fr.join(e)}function eI(e){let t=\"/\";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let n=e.split(t);return n[n.length-1]}function cN(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function dN(e,t,n){let a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(a.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error(\"modelJSON has weightsManifest but weightSpecs is null\");if(!n)throw new Error(\"modelJSON has weightsManifest but weightData is null\");a.weightSpecs=t,a.weightData=n}return e.signature!=null&&(a.signature=e.signature),e.userDefinedMetadata!=null&&(a.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(a.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(a.initializerSignature=e.initializerSignature),a}async function Mv(e,t){let n,a;return e.weightsManifest!=null&&([n,a]=await t(e.weightsManifest)),dN(e,n,a)}function rd(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error(\"Expected JSON model topology, received ArrayBuffer.\");return{dateSaved:new Date,modelTopologyType:\"JSON\",modelTopologyBytes:e.modelTopology==null?0:Qk(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:Qk(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new Fr(e.weightData).byteLength}}function _x(e){let t=[];for(let n of e)t.push(...n.weights);return t}function mO(){let e=n=>{let a=n<<13,r=0;for(;!(a&8388608);)r-=8388608,a<<=1;return a&=-8388609,r+=947912704,a|r},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function fO(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function gO(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function bO(){let e=mO(),t=fO(),n=gO();return a=>{let r=new ArrayBuffer(4*a.length),s=new Uint32Array(r);for(let i=0;i<a.length;i++){let o=a[i],l=e[n[o>>10]+(o&1023)]+t[o>>10];s[i]=l}return new Float32Array(r)}}var ga=class La{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return La.instance==null&&(La.instance=new La),La.instance}static registerSaveRouter(t){La.getInstance().saveRouters.push(t)}static registerLoadRouter(t){La.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return La.getHandlers(t,\"save\")}static getLoadHandlers(t,n){return La.getHandlers(t,\"load\",n)}static getHandlers(t,n,a){let r=[];return(n===\"load\"?La.getInstance().loadRouters:La.getInstance().saveRouters).forEach(s=>{let i=s(t,a);i!==null&&r.push(i)}),r}},yO=e=>ga.registerSaveRouter(e),xO=e=>ga.registerLoadRouter(e),vO=e=>ga.getSaveHandlers(e),wO=(e,t)=>ga.getLoadHandlers(e,t),Ax=\"tensorflowjs\",Fx=1,ti=\"models_store\",Qr=\"model_info_store\";function hN(){if(!G().getBool(\"IS_BROWSER\"))throw new Error(\"Failed to obtain IndexedDB factory because the current environmentis not a web browser.\");let e=typeof window==\"undefined\"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error(\"The current browser does not appear to support IndexedDB.\");return t}function $x(e){let t=e.result;t.createObjectStore(ti,{keyPath:\"modelPath\"}),t.createObjectStore(Qr,{keyPath:\"modelPath\"})}var pi=class{constructor(e){if(this.indexedDB=hN(),e==null||!e)throw new Error(\"For IndexedDB, modelPath must not be null, undefined or empty.\");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error(\"BrowserLocalStorage.save() does not support saving model topology in binary formats yet.\");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,a)=>{let r=this.indexedDB.open(Ax,Fx);r.onupgradeneeded=()=>$x(r),r.onsuccess=()=>{let s=r.result;if(t==null){let i=s.transaction(ti,\"readonly\"),o=i.objectStore(ti).get(this.modelPath);o.onsuccess=()=>{if(o.result==null)return s.close(),a(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(o.result.modelArtifacts)},o.onerror=l=>(s.close(),a(o.error)),i.oncomplete=()=>s.close()}else{t.weightData=Fr.join(t.weightData);let i=rd(t),o=s.transaction(Qr,\"readwrite\"),l=o.objectStore(Qr),u;try{u=l.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(d){return a(d)}let p;u.onsuccess=()=>{p=s.transaction(ti,\"readwrite\");let d=p.objectStore(ti),c;try{c=d.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i})}catch(h){return a(h)}c.onsuccess=()=>n({modelArtifactsInfo:i}),c.onerror=h=>{l=o.objectStore(Qr);let m=l.delete(this.modelPath);m.onsuccess=()=>(s.close(),a(c.error)),m.onerror=f=>(s.close(),a(c.error))}},u.onerror=d=>(s.close(),a(u.error)),o.oncomplete=()=>{p==null?s.close():p.oncomplete=()=>s.close()}}},r.onerror=s=>a(r.error)})}};pi.URL_SCHEME=\"indexeddb://\";var mN=e=>G().getBool(\"IS_BROWSER\")&&!Array.isArray(e)&&e.startsWith(pi.URL_SCHEME)?kO(e.slice(pi.URL_SCHEME.length)):null;ga.registerSaveRouter(mN);ga.registerLoadRouter(mN);function kO(e){return new pi(e)}function IO(e){return e.startsWith(pi.URL_SCHEME)?e.slice(pi.URL_SCHEME.length):e}var SO=class{constructor(){this.indexedDB=hN()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(Ax,Fx);n.onupgradeneeded=()=>$x(n),n.onsuccess=()=>{let a=n.result,r=a.transaction(Qr,\"readonly\"),s=r.objectStore(Qr).getAll();s.onsuccess=()=>{let i={};for(let o of s.result)i[o.modelPath]=o.modelArtifactsInfo;e(i)},s.onerror=i=>(a.close(),t(s.error)),r.oncomplete=()=>a.close()},n.onerror=a=>t(n.error)})}async removeModel(e){return e=IO(e),new Promise((t,n)=>{let a=this.indexedDB.open(Ax,Fx);a.onupgradeneeded=()=>$x(a),a.onsuccess=()=>{let r=a.result,s=r.transaction(Qr,\"readwrite\"),i=s.objectStore(Qr),o=i.get(e),l;o.onsuccess=()=>{if(o.result==null)return r.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let u=i.delete(e),p=()=>{l=r.transaction(ti,\"readwrite\");let d=l.objectStore(ti).delete(e);d.onsuccess=()=>t(o.result.modelArtifactsInfo),d.onerror=c=>n(o.error)};u.onsuccess=p,u.onerror=d=>(p(),r.close(),n(o.error))}},o.onerror=u=>(r.close(),n(o.error)),s.oncomplete=()=>{l==null?r.close():l.oncomplete=()=>r.close()}},a.onerror=r=>n(a.error)})}},Tr=\"/\",Nl=\"tensorflowjs_models\",fN=\"info\",NO=\"model_topology\",TO=\"weight_specs\",CO=\"weight_data\",EO=\"model_metadata\";function gN(e){return{info:[Nl,e,fN].join(Tr),topology:[Nl,e,NO].join(Tr),weightSpecs:[Nl,e,TO].join(Tr),weightData:[Nl,e,CO].join(Tr),modelMetadata:[Nl,e,EO].join(Tr)}}function bN(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function _O(e){let t=e.split(Tr);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Tr)}function AO(e){return e.startsWith(ci.URL_SCHEME)?e.slice(ci.URL_SCHEME.length):e}var ci=class{constructor(e){if(!G().getBool(\"IS_BROWSER\")||typeof window==\"undefined\"||typeof window.localStorage==\"undefined\")throw new Error(\"The current environment does not support local storage.\");if(this.LS=window.localStorage,e==null||!e)throw new Error(\"For local storage, modelPath must not be null, undefined or empty.\");this.modelPath=e,this.keys=gN(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error(\"BrowserLocalStorage.save() does not support saving model topology in binary formats yet.\");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),a=rd(e),r=Fr.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,cO(r));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:a}}catch(s){throw bN(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!==\"JSON\")throw new Error(\"BrowserLocalStorage does not support loading non-JSON model topology yet.\");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(a==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=a;let r=this.LS.getItem(this.keys.modelMetadata);if(r!=null){let i=JSON.parse(r);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(t.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(s==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=dO(s),t}};ci.URL_SCHEME=\"localstorage://\";var yN=e=>G().getBool(\"IS_BROWSER\")&&!Array.isArray(e)&&e.startsWith(ci.URL_SCHEME)?FO(e.slice(ci.URL_SCHEME.length)):null;ga.registerSaveRouter(yN);ga.registerLoadRouter(yN);function FO(e){return new ci(e)}var $O=class{constructor(){A(G().getBool(\"IS_BROWSER\"),()=>\"Current environment is not a web browser\"),A(typeof window==\"undefined\"||typeof window.localStorage!=\"undefined\",()=>\"Current browser does not appear to support localStorage\"),this.LS=window.localStorage}async listModels(){let e={},t=Nl+Tr,n=Tr+fN;for(let a=0;a<this.LS.length;++a){let r=this.LS.key(a);if(r.startsWith(t)&&r.endsWith(n)){let s=_O(r);e[s]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){e=AO(e);let t=gN(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return bN(t),n}},_l=\"://\",us=class qr{constructor(){this.managers={}}static getInstance(){return qr.instance==null&&(qr.instance=new qr),qr.instance}static registerManager(t,n){A(t!=null,()=>\"scheme must not be undefined or null.\"),t.endsWith(_l)&&(t=t.slice(0,t.indexOf(_l))),A(t.length>0,()=>\"scheme must not be an empty string.\");let a=qr.getInstance();A(a.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),a.managers[t]=n}static getManager(t){let n=qr.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(qr.getInstance().managers)}};function Rh(e){if(e.indexOf(_l)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${us.getSchemes().join(\",\")}`);return{scheme:e.split(_l)[0],path:e.split(_l)[1]}}async function xN(e,t,n=!1){A(e!==t,()=>`Old path and new path are the same: '${e}'`);let a=ga.getLoadHandlers(e);A(a.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),A(a.length<2,()=>`Copying failed because more than one (${a.length}) load handlers for source URL ${e}.`);let r=a[0],s=ga.getSaveHandlers(t);A(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),A(s.length<2,()=>`Copying failed because more than one (${a.length}) save handlers for destination URL ${t}.`);let i=s[0],o=Rh(e).scheme,l=Rh(e).path,u=o===Rh(e).scheme,p=await r.load();n&&u&&await us.getManager(o).removeModel(l);let d=await i.save(p);return n&&!u&&await us.getManager(o).removeModel(l),d.modelArtifactsInfo}async function DO(){let e=us.getSchemes(),t={};for(let n of e){let a=await us.getManager(n).listModels();for(let r in a){let s=n+_l+r;t[s]=a[r]}}return t}async function RO(e){let t=Rh(e);return us.getManager(t.scheme).removeModel(t.path)}async function MO(e,t){return xN(e,t,!1)}async function OO(e,t){return xN(e,t,!0)}var PO=class{constructor(){this.messageName=\"setTimeoutCustom\",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!==\"utf-8\"&&t!==\"utf8\")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window==\"undefined\"||!G().getBool(\"USE_SETTIMEOUTCUSTOM\")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},\"*\")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener(\"message\",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();let a=this.functionRefs[n.data.index];a(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return XS(e)}};if(G().get(\"IS_BROWSER\")){G().setPlatform(\"browser\",new PO);try{us.registerManager(ci.URL_SCHEME,new $O)}catch(e){}try{us.registerManager(pi.URL_SCHEME,new SO)}catch(e){}}var LO={importFetch:()=>_R()},ox,zO=class{constructor(){this.util=AR(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return G().global.fetch!=null?G().global.fetch(e,t):(ox==null&&(ox=LO.importFetch()),ox(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!==\"utf-8\"&&t!==\"utf8\")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?\"\":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}};G().get(\"IS_NODE\")&&!G().get(\"IS_BROWSER\")&&G().setPlatform(\"node\",new zO);function Oe(e,t=\"float32\",n){return t=t||\"float32\",na(e),new Wt(e,t,n)}function WO(e,t){let n=E(e,\"x\",\"cast\");if(!LS(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t===\"string\"&&n.dtype!==\"string\"||t!==\"string\"&&n.dtype===\"string\")throw new Error(\"Only strings can be casted to strings\");let a={x:n},r={dtype:t};return P.runKernel(Mi,a,r)}var re=L({cast_:WO});function BO(e){let t={x:E(e,\"x\",\"clone\",\"string_or_numeric\")};return P.runKernel(eo,t)}var sr=L({clone_:BO});function Ov(e,t=!1){console.log(e.toString(t))}aN();var VO={buffer:Oe,cast:re,clone:sr,print:Ov};PM(VO);function UO(e,t){let n=E(e,\"a\",\"add\"),a=E(t,\"b\",\"add\");[n,a]=_t(n,a);let r={a:n,b:a};return P.runKernel(vs,r)}var X=L({add_:UO});function GO(e,t){let n=E(e,\"a\",\"floorDiv\"),a=E(t,\"b\",\"floorDiv\");[n,a]=_t(n,a);let r={a:n,b:a};return P.runKernel(Zi,r)}var Pm=L({floorDiv_:GO});function HO(e,t){let n=E(e,\"a\",\"div\"),a=E(t,\"b\",\"div\");if([n,a]=_t(n,a),n.dtype===\"int32\"&&a.dtype===\"int32\")return Pm(n,a);let r={a:n,b:a},s={};return P.runKernel(Hi,r,s)}var he=L({div_:HO});function jO(e,t){let n=E(e,\"a\",\"mul\"),a=E(t,\"b\",\"mul\");[n,a]=_t(n,a);let r={a:n,b:a};return P.runKernel(bo,r)}var z=L({mul_:jO});function qO(e){let t=E(e,\"x\",\"abs\");if(t.dtype===\"complex64\"){let n={x:t};return P.runKernel(Oc,n)}else{let n={x:t};return P.runKernel(Yl,n)}}var Lt=L({abs_:qO});function KO(e){let t={x:E(e,\"x\",\"acos\")};return P.runKernel(Ni,t)}var Pv=L({acos_:KO});function XO(e){let t={x:E(e,\"x\",\"acosh\")};return P.runKernel(Ti,t)}var Lv=L({acosh_:XO});function YO(e){A(Array.isArray(e),()=>\"The argument passed to tf.addN() must be a list of tensors\"),A(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((r,s)=>E(r,`tensors${s}`,\"addN\")),n=t[0];t.forEach(r=>{if(r.dtype!==n.dtype)throw new Error(\"All tensors passed to tf.addN() must have the same dtype\")}),t.forEach(r=>{if(!Ar(r.shape,n.shape))throw new Error(\"All tensors passed to tf.addN() must have the same shape\")});let a=t;return P.runKernel(Ci,a)}var vN=L({addN_:YO});function ZO(e,t=null,n=!1){let a={x:E(e,\"x\",\"all\",\"bool\")},r={axis:t,keepDims:n};return P.runKernel(Zl,a,r)}var Lm=L({all_:ZO});function JO(e,t=null,n=!1){let a={x:E(e,\"x\",\"any\",\"bool\")},r={axis:t,keepDims:n};return P.runKernel(Jl,a,r)}var yc=L({any_:JO});function QO(e,t=0){let n={x:E(e,\"x\",\"argMax\")},a={axis:t};return P.runKernel(Ql,n,a)}var di=L({argMax_:QO});function eP(e,t=0){let n={x:E(e,\"x\",\"argMin\")},a={axis:t};return P.runKernel(eu,n,a)}var zv=L({argMin_:eP});function tP(e){let t={x:E(e,\"x\",\"asin\")};return P.runKernel(Ei,t)}var Wv=L({asin_:tP});function nP(e){let t={x:E(e,\"x\",\"asinh\")};return P.runKernel(_i,t)}var Bv=L({asinh_:nP});function aP(e){let t={x:E(e,\"x\",\"atan\")};return P.runKernel(Ai,t)}var Vv=L({atan_:aP});function rP(e,t){let n=E(e,\"a\",\"atan2\"),a=E(t,\"b\",\"atan2\");[n,a]=_t(n,a);let r={a:n,b:a};return P.runKernel($i,r)}var Uv=L({atan2_:rP});function sP(e){let t={x:E(e,\"x\",\"atanh\")};return P.runKernel(Fi,t)}var Gv=L({atanh_:sP});function iP(e,t,n,a,r=\"NHWC\",s){let i=e[3],o=[...t,i],l=IN(r);return sd(e,o,n,s,a,null,null,l)}function wN(e,t,n,a,r,s,i=\"channelsLast\"){let[o,l]=xc(t),u;if(i===\"channelsLast\")u=[o,l,e[3],e[3]];else if(i===\"channelsFirst\")u=[o,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return sd(e,u,n,a,r,s,!1,i)}function oP(e,t,n,a,r,s,i=\"NDHWC\"){let[o,l,u]=Dx(t),p,d;if(i===\"NDHWC\")d=\"channelsLast\",p=[o,l,u,e[4],e[4]];else if(i===\"NCDHW\")d=\"channelsFirst\",p=[o,l,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return kN(e,p,n,a,r,!1,d,s)}function sd(e,t,n,a,r,s,i=!1,o=\"channelsLast\"){let[l,u,p,d]=[-1,-1,-1,-1];if(o===\"channelsLast\")[l,u,p,d]=e;else if(o===\"channelsFirst\")[l,d,u,p]=e;else throw new Error(`Unknown dataFormat ${o}`);let[c,h,,m]=t,[f,g]=xc(n),[b,y]=xc(a),x=Al(c,b),v=Al(h,y),{padInfo:I,outHeight:N,outWidth:C}=pP(r,u,p,f,g,x,v,s,o),_=i?m*d:m,F;return o===\"channelsFirst\"?F=[l,_,N,C]:o===\"channelsLast\"&&(F=[l,N,C,_]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:p,inChannels:d,outHeight:N,outWidth:C,outChannels:_,padInfo:I,strideHeight:f,strideWidth:g,filterHeight:c,filterWidth:h,effectiveFilterHeight:x,effectiveFilterWidth:v,dilationHeight:b,dilationWidth:y,inShape:e,outShape:F,filterShape:t}}function kN(e,t,n,a,r,s=!1,i=\"channelsLast\",o){let[l,u,p,d,c]=[-1,-1,-1,-1,-1];if(i===\"channelsLast\")[l,u,p,d,c]=e;else if(i===\"channelsFirst\")[l,c,u,p,d]=e;else throw new Error(`Unknown dataFormat ${i}`);let[h,m,f,,g]=t,[b,y,x]=Dx(n),[v,I,N]=Dx(a),C=Al(h,v),_=Al(m,I),F=Al(f,N),{padInfo:D,outDepth:$,outHeight:S,outWidth:M}=cP(r,u,p,d,b,y,x,C,_,F,o),B=s?g*c:g,U;return i===\"channelsFirst\"?U=[l,B,$,S,M]:i===\"channelsLast\"&&(U=[l,$,S,M,B]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:p,inWidth:d,inChannels:c,outDepth:$,outHeight:S,outWidth:M,outChannels:B,padInfo:D,strideDepth:b,strideHeight:y,strideWidth:x,filterDepth:h,filterHeight:m,filterWidth:f,effectiveFilterDepth:C,effectiveFilterHeight:_,effectiveFilterWidth:F,dilationDepth:v,dilationHeight:I,dilationWidth:N,inShape:e,outShape:U,filterShape:t}}function lP(e,t,n,a,r){a==null&&(a=Hv(e,t,n));let s=e[0],i=e[1],o=vc((s-t+2*a)/n+1,r),l=vc((i-t+2*a)/n+1,r);return[o,l]}function uP(e,t,n,a,r,s){r==null&&(r=Hv(e,t[0],a[0]));let i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*r>=t[o]&&(i[o]=vc((e[o]-t[o]+2*r)/a[o]+1,s));return i}function Hv(e,t,n,a=1){let r=Al(t,a);return Math.floor((e[0]*(n-1)-n+r)/2)}function xc(e){return typeof e==\"number\"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function Dx(e){return typeof e==\"number\"?[e,e,e]:e}function Al(e,t){return t<=1?e:e+(e-1)*(t-1)}function pP(e,t,n,a,r,s,i,o,l){let u,p,d;if(typeof e==\"number\"){u={top:e,bottom:e,left:e,right:e,type:e===0?\"VALID\":\"NUMBER\"};let c=lP([t,n],s,a,e,o);p=c[0],d=c[1]}else if(e===\"same\"){p=Math.ceil(t/a),d=Math.ceil(n/r);let c=Math.max(0,(p-1)*a+s-t),h=Math.max(0,(d-1)*r+i-n),m=Math.floor(c/2),f=c-m,g=Math.floor(h/2),b=h-g;u={top:m,bottom:f,left:g,right:b,type:\"SAME\"}}else if(e===\"valid\")u={top:0,bottom:0,left:0,right:0,type:\"VALID\"},p=Math.ceil((t-s+1)/a),d=Math.ceil((n-i+1)/r);else if(typeof e==\"object\"){let c=l===\"channelsLast\"?e[1][0]:e[2][0],h=l===\"channelsLast\"?e[1][1]:e[2][1],m=l===\"channelsLast\"?e[2][0]:e[3][0],f=l===\"channelsLast\"?e[2][1]:e[3][1];u={top:c,bottom:h,left:m,right:f,type:c===0&&h===0&&m===0&&f===0?\"VALID\":\"EXPLICIT\"},p=vc((t-s+c+h)/a+1,o),d=vc((n-i+m+f)/r+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:u,outHeight:p,outWidth:d}}function cP(e,t,n,a,r,s,i,o,l,u,p){let d,c,h,m;if(e===\"valid\"&&(e=0),typeof e==\"number\"){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?\"VALID\":\"NUMBER\"};let f=uP([t,n,a,1],[o,l,u],1,[r,s,i],e,p);c=f[0],h=f[1],m=f[2]}else if(e===\"same\"){c=Math.ceil(t/r),h=Math.ceil(n/s),m=Math.ceil(a/i);let f=(c-1)*r+o-t,g=(h-1)*s+l-n,b=(m-1)*i+u-a,y=Math.floor(f/2),x=f-y,v=Math.floor(g/2),I=g-v,N=Math.floor(b/2),C=b-N;d={top:v,bottom:I,left:N,right:C,front:y,back:x,type:\"SAME\"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:d,outDepth:c,outHeight:h,outWidth:m}}function vc(e,t){if(!t)return Math.trunc(e);switch(t){case\"round\":return Math.round(e);case\"ceil\":return Math.ceil(e);case\"floor\":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function ps(e){let[t,n,a]=xc(e);return t===1&&n===1&&a===1}function dr(e,t){return ps(e)||ps(t)}function hi(e){return xc(e).every(t=>t>0)}function IN(e){if(e===\"NHWC\")return\"channelsLast\";if(e===\"NCHW\")return\"channelsFirst\";throw new Error(`Unknown dataFormat ${e}`)}function Tn(e,t,n){if(n!=null){if(typeof t==\"string\")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t==\"number\")A($l(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t==\"object\")t.forEach(a=>{a.forEach(r=>{A($l(r),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${r}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}function dP(e,t){let n={x:E(e,\"x\",\"reshape\",\"string_or_numeric\")},a={shape:t};return P.runKernel(Ru,n,a)}var W=L({reshape_:dP});function hP(e,t,n,a,r){let s=E(e,\"x\",\"avgPool\",\"float32\"),i=1;A(dr(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let o=s,l=!1;s.rank===3&&(l=!0,o=W(s,[1,s.shape[0],s.shape[1],s.shape[2]])),A(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),Tn(\"avgPool\",a,r);let u={x:o},p={filterSize:t,strides:n,pad:a,dimRoundingMode:r},d=P.runKernel(Di,u,p);return d=re(d,s.dtype),l?W(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var ya=L({avgPool_:hP});function mP(e,t,n,a,r,s=\"NDHWC\"){let i=E(e,\"x\",\"avgPool3d\",\"float32\"),o=i,l=!1;i.rank===4&&(l=!0,o=W(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),A(s===\"NDHWC\",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),A(typeof n==\"number\"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),Tn(\"avgPool3d\",a,r);let u={x:o},p={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s},d=P.runKernel(tu,u,p);return d=re(d,o.dtype),l?W(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var jv=L({avgPool3d_:mP});function fP(e,t=0){A(e.length>=1,()=>\"Pass at least one tensor to concat\");let n=bc(e,\"tensors\",\"concat\",\"string_or_numeric\");if(n[0].dtype===\"complex64\"&&n.forEach(s=>{if(s.dtype!==\"complex64\")throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${s.dtype}. `)}),n.length===1)return sr(n[0]);let a=n,r={axis:t};return P.runKernel(su,a,r)}var et=L({concat_:fP});function gP(e,t,n=!1,a=!1){let r=E(e,\"a\",\"matMul\"),s=E(t,\"b\",\"matMul\");[r,s]=_t(r,s);let i={a:r,b:s},o={transposeA:n,transposeB:a};return P.runKernel(Ri,i,o)}var $e=L({matMul_:gP});function bP(e){let t={x:E(e,\"x\",\"sigmoid\",\"float32\")};return P.runKernel(Mo,t)}var ha=L({sigmoid_:bP});function yP(e,t,n){let a=E(e,\"x\",\"slice\",\"string_or_numeric\");if(a.rank===0)throw new Error(\"Slicing scalar is not possible\");let r={x:a},s={begin:t,size:n};return P.runKernel(Bu,r,s)}var Ve=L({slice_:yP});function xP(e){let t={x:E(e,\"x\",\"tanh\",\"float32\")};return P.runKernel(Uo,t)}var cs=L({tanh_:xP});function vP(e,t,n,a,r,s){let i=E(e,\"forgetBias\",\"basicLSTMCell\"),o=E(t,\"lstmKernel\",\"basicLSTMCell\"),l=E(n,\"lstmBias\",\"basicLSTMCell\"),u=E(a,\"data\",\"basicLSTMCell\"),p=E(r,\"c\",\"basicLSTMCell\"),d=E(s,\"h\",\"basicLSTMCell\"),c=et([u,d],1),h=$e(c,o),m=X(h,l),f=m.shape[0],g=m.shape[1]/4,b=[f,g],y=Ve(m,[0,0],b),x=Ve(m,[0,g],b),v=Ve(m,[0,g*2],b),I=Ve(m,[0,g*3],b),N=X(z(ha(y),cs(x)),z(p,ha(X(i,v)))),C=z(cs(N),ha(I));return[N,C]}var SN=L({basicLSTMCell_:vP});function wP(e,t,n){let a=E(e,\"x\",\"batchToSpaceND\"),r=t.reduce((o,l)=>o*l);A(a.rank>=1+t.length,()=>`input rank is ${a.rank} but should be > than blockShape.length ${t.length}`),A(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),A(a.shape[0]%r===0,()=>`input tensor batch is ${a.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(\" * \")} === ${r}`);let s={x:a},i={blockShape:t,crops:n};return P.runKernel(nu,s,i)}var id=L({batchToSpaceND_:wP});function kP(e){let t;return e.rank===0||e.rank===1?t=W(e,[1,1,1,e.size]):e.rank===2?t=W(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function IP(e,t,n,a,r,s){s==null&&(s=.001);let i=E(e,\"x\",\"batchNorm\"),o=E(t,\"mean\",\"batchNorm\"),l=E(n,\"variance\",\"batchNorm\"),u;r!=null&&(u=E(r,\"scale\",\"batchNorm\"));let p;a!=null&&(p=E(a,\"offset\",\"batchNorm\")),A(o.rank===l.rank,()=>\"Batch normalization gradient requires mean and variance to have equal ranks.\"),A(p==null||o.rank===p.rank,()=>\"Batch normalization gradient requires mean and offset to have equal ranks.\"),A(u==null||o.rank===u.rank,()=>\"Batch normalization gradient requires mean and scale to have equal ranks.\");let d={x:kP(i),scale:u,offset:p,mean:o,variance:l},c={varianceEpsilon:s},h=P.runKernel(Ji,d,c);return W(h,i.shape)}var Ns=L({batchNorm_:IP});function SP(e,t,n,a,r,s){let i=E(e,\"x\",\"batchNorm\"),o=E(t,\"mean\",\"batchNorm\"),l=E(n,\"variance\",\"batchNorm\"),u;r!=null&&(u=E(r,\"scale\",\"batchNorm\"));let p;return a!=null&&(p=E(a,\"offset\",\"batchNorm\")),A(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),A(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),A(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&A(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),p!=null&&A(p.rank===2||p.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${p.rank}.`),Ns(i,o,l,p,u,s)}var qv=L({batchNorm2d_:SP});function NP(e,t,n,a,r,s){let i=E(e,\"x\",\"batchNorm\"),o=E(t,\"mean\",\"batchNorm\"),l=E(n,\"variance\",\"batchNorm\"),u;r!=null&&(u=E(r,\"scale\",\"batchNorm\"));let p;return a!=null&&(p=E(a,\"offset\",\"batchNorm\")),A(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),A(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),A(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&A(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),p!=null&&A(p.rank===3||p.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${p.rank}.`),Ns(i,o,l,p,u,s)}var Kv=L({batchNorm3d_:NP});function TP(e,t,n,a,r,s){let i=E(e,\"x\",\"batchNorm\"),o=E(t,\"mean\",\"batchNorm\"),l=E(n,\"variance\",\"batchNorm\"),u;r!=null&&(u=E(r,\"scale\",\"batchNorm\"));let p;return a!=null&&(p=E(a,\"offset\",\"batchNorm\")),A(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),A(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),A(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&A(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),p!=null&&A(p.rank===4||p.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${p.rank}.`),Ns(i,o,l,p,u,s)}var Xv=L({batchNorm4d_:TP});function CP(e,t,n){let a=E(e,\"x\",\"bincount\"),r=E(t,\"weights\",\"bincount\");A(a.dtype===\"int32\",()=>`Error in bincount: input dtype must be int32, but got ${a.dtype}`),A(n>=0,()=>`size must be non-negative, but got ${n}.`),A(r.size===a.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${a.shape}, weights shape: ${r.shape}.`);let s={x:a,weights:r},i={size:n};return P.runKernel(au,s,i)}var Yv=L({bincount_:CP});function EP(e,t){let n=E(e,\"x\",\"bitwiseAnd\"),a=E(t,\"y\",\"bitwiseAnd\");if(!Ar(n.shape,a.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${a.shape}`);if(n.dtype!==\"int32\"||a.dtype!==\"int32\")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${a.dtype}`);let r={a:n,b:a};return P.runKernel(ru,r)}var NN=L({bitwiseAnd_:EP});function _P(e,t){let n=E(e,\"s0\",\"broadcastArgs\",\"int32\"),a=E(t,\"s1\",\"broadcastArgs\",\"int32\");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(a.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${a.rank}`);let r={s0:n,s1:a};return P.runKernel(Mc,r)}var TN=L({broadcastArgs_:_P});function AP(e,t){let n=E(e,\"broadcastTo\",\"x\"),a=n.shape;if(na(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let l=n.shape.slice();for(;l.length<t.length;)l.unshift(1);n=W(n,l)}let r=n.shape,s=Array.from(t);for(let l=t.length-1;l>=0;l--)if(r[l]===t[l])s[l]=1;else if(n.shape[l]!==1)throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${t}].`);if(s.map((l,u)=>l>1?u:-1).filter(l=>l>=0).length===0)return sr(n);let i={x:n},o={reps:s};return P.runKernel(ks,i,o)}var ai=L({broadcastTo_:AP});function FP(e){let t={x:E(e,\"x\",\"ceil\",\"float32\")};return P.runKernel(Oi,t)}var Zv=L({ceil_:FP});function yn(e,t,n){na(e),n=n||$c(t);let a={shape:e,value:t,dtype:n};return P.runKernel(zc,{},a)}function $P(e,t,n){let a=E(e,\"x\",\"clipByValue\");if(A(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return yn(a.shape,t,a.dtype);let r={x:a},s={clipValueMin:t,clipValueMax:n};return P.runKernel(ws,r,s)}var an=L({clipByValue_:$P});function DP(e){return et(e,0)}var Jv=L({concat1d_:DP});function RP(e,t){return et(e,t)}var Qv=L({concat2d_:RP});function MP(e,t){return et(e,t)}var ew=L({concat3d_:MP});function OP(e,t){return et(e,t)}var tw=L({concat4d_:OP});function PP(e,t,n,a,r=\"NHWC\",s=[1,1],i){let o=E(e,\"x\",\"conv2d\",\"float32\"),l=E(t,\"filter\",\"conv2d\",\"float32\"),u=o,p=!1;o.rank===3&&(p=!0,u=W(o,[1,o.shape[0],o.shape[1],o.shape[2]])),A(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),A(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Tn(\"conv2d\",a,i);let d=r===\"NHWC\"?u.shape[3]:u.shape[1];A(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),A(dr(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),A(hi(s),()=>\"Error in conv2D: Dilated rates should be larger than 0.\"),A(hi(n),()=>\"Error in conv2D: Strides should be larger than 0.\");let c={x:u,filter:l},h={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i},m=P.runKernel(Pi,c,h);return p?W(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var $t=L({conv2d_:PP});function LP(e,t,n,a,r=\"NWC\",s=1,i){let o=E(e,\"x\",\"conv1d\"),l=E(t,\"filter\",\"conv1d\"),u=o,p=!1;o.rank===2&&(p=!0,u=W(o,[1,o.shape[0],o.shape[1]])),A(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),A(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Tn(\"conv1d\",a,i),A(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),A(dr(n,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`),A(hi(s),()=>\"Error in conv1D: Dilated rates should be larger than 0.\"),A(hi(n),()=>\"Error in conv1D: Stride should be larger than 0.\"),A(r===\"NWC\",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);let d=W(l,[1,l.shape[0],l.shape[1],l.shape[2]]),c=W(u,[u.shape[0],1,u.shape[1],u.shape[2]]),h=$t(c,d,[1,n],a,\"NHWC\",[1,s],i);return p?W(h,[h.shape[2],h.shape[3]]):W(h,[h.shape[0],h.shape[2],h.shape[3]])}var zm=L({conv1d_:LP});function zP(e,t,n,a,r,s=\"NHWC\",i){A(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,l=t,u=!1;t.rank===3&&(u=!0,l=W(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),A(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),A(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),A(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let p=s===\"NHWC\"?o[3]:o[1],d=s===\"NHWC\"?l.shape[3]:l.shape[1];A(p===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${p}) must match input depth for filter ${n.shape[2]}.`),A(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),Tn(\"conv2dDerInput\",r,i);let c={dy:l,filter:n},h={strides:a,pad:r,dataFormat:s,dimRoundingMode:i,inputShape:o},m=P.runKernel(Li,c,h);return u?W(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var nw=L({conv2DBackpropInput_:zP});function WP(e,t,n,a,r,s){let i=E(e,\"x\",\"conv2dTranspose\"),o=E(t,\"filter\",\"conv2dTranspose\");return nw(n,i,o,a,r,\"NHWC\",s)}var Wm=L({conv2dTranspose_:WP});function BP(e,t,n,a,r=\"NDHWC\",s=[1,1,1]){let i=E(e,\"x\",\"conv3d\"),o=E(t,\"filter\",\"conv3d\"),l=i,u=!1;i.rank===4&&(u=!0,l=W(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),A(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),A(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),A(dr(n,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),A(r===\"NDHWC\",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),A(hi(s),()=>\"Error in conv3D: Dilated rates should be larger than 0.\"),A(hi(n),()=>\"Error in conv3D: Strides should be larger than 0.\");let p={x:l,filter:o},d={strides:n,pad:a,dataFormat:r,dilations:s},c=P.runKernel(zi,p,d);return u?W(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var aw=L({conv3d_:BP});function VP(e,t,n,a,r){A(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let s=e,i=t,o=!1;t.rank===4&&(o=!0,i=W(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let l=s[4],u=i.shape[4];A(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),A(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),A(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),A(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),A(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);let p={dy:i,filter:n},d={pad:r,strides:a,inputShape:s},c=P.runKernel(ou,p,d);return o?W(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var CN=L({conv3DBackpropInput_:VP});function UP(e,t,n,a,r){let s=E(e,\"x\",\"conv3dTranspose\"),i=E(t,\"filter\",\"conv3dTranspose\");return CN(n,s,i,a,r)}var rw=L({conv3dTranspose_:UP});function GP(e){let t={x:E(e,\"x\",\"cos\",\"float32\")};return P.runKernel(Wi,t)}var od=L({cos_:GP});function HP(e){let t={x:E(e,\"x\",\"cosh\",\"float32\")};return P.runKernel(Bi,t)}var Bm=L({cosh_:HP});function jP(e,t=0,n=!1,a=!1){let r={x:E(e,\"x\",\"cumprod\")},s={axis:t,exclusive:n,reverse:a};return P.runKernel(lu,r,s)}var wc=L({cumprod_:jP});function qP(e,t=0,n=!1,a=!1){let r={x:E(e,\"x\",\"cumsum\")},s={axis:t,exclusive:n,reverse:a};return P.runKernel(Vi,r,s)}var Vm=L({cumsum_:qP});function KP(e,t,n,a=!1){let r=E(e,\"x\",\"denseBincount\"),s=E(t,\"weights\",\"denseBincount\");A(r.dtype===\"int32\",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),A(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),A(n>=0,()=>`size must be non-negative, but got ${n}.`),A(s.size===r.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${s.shape}.`);let i={x:r,weights:s},o={size:n,binaryOutput:a};return P.runKernel(Pc,i,o)}var Xh=L({denseBincount_:KP});function XP(e,t,n=\"NHWC\"){let a=E(e,\"x\",\"depthToSpace\",\"float32\"),r=n===\"NHWC\"?a.shape[1]:a.shape[2],s=n===\"NHWC\"?a.shape[2]:a.shape[3],i=n===\"NHWC\"?a.shape[3]:a.shape[1];A(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),A(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${r} and ${t}  for depthToSpace with input shape\n    ${a.shape}`),A(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t} for depthToSpace with input shape\n        ${a.shape}`),A(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${a.shape}`);let o={x:a},l={blockSize:t,dataFormat:n};return P.runKernel(pu,o,l)}var sw=L({depthToSpace_:XP});function YP(e,t,n,a,r=\"NHWC\",s=[1,1],i){let o=E(e,\"x\",\"depthwiseConv2d\",\"float32\"),l=E(t,\"filter\",\"depthwiseConv2d\",\"float32\"),u=o,p=!1;o.rank===3&&(p=!0,u=W(o,[1,o.shape[0],o.shape[1],o.shape[2]])),A(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),A(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);let d=r===\"NHWC\"?u.shape[3]:u.shape[1];A(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),Tn(\"depthwiseConv2d\",a,i);let c={x:u,filter:l},h={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i},m=P.runKernel(Ui,c,h);return p?W(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Ts=L({depthwiseConv2d_:YP});function ZP(e){let t={x:E(e,\"x\",\"diag\")};return P.runKernel(Lc,t)}var EN=L({diag_:ZP});function JP(e,t,n,a,r=[1,1],s=\"NHWC\"){let i=E(e,\"x\",\"dilation2d\"),o=E(t,\"filter\",\"dilation2d\");A(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),A(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),A(s===\"NHWC\",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=i,u=!1;i.rank===3&&(l=W(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),A(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);let p={x:l,filter:o},d={strides:n,pad:a,dilations:r},c=P.runKernel(Gi,p,d);return u?W(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var iw=L({dilation2d_:JP}),Ju={};_e(Ju,{assertAndGetBroadcastShape:()=>ct,getBroadcastDims:()=>_N,getReductionAxes:()=>Bt});function _N(e,t){let n=e.length,a=[];for(let r=0;r<n;r++){let s=n-1-r,i=e[s]||1;(t[t.length-1-r]||1)>1&&i===1&&a.unshift(s)}return a}function Bt(e,t){let n=[];for(let a=0;a<t.length;a++){let r=e[e.length-a-1],s=t.length-a-1,i=t[s];(r==null||r===1&&i>1)&&n.unshift(s)}return n}function ct(e,t){let n=Math.max(e.length,t.length),a=new Array(n);for(let r=0;r<n;r++){let s=e[e.length-r-1];s==null&&(s=1);let i=t[t.length-r-1];if(i==null&&(i=1),s===1)a[n-r-1]=i;else if(i===1)a[n-r-1]=s;else if(s!==i){let o=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(o)}else a[n-r-1]=s}return a}function QP(e,t){let n=E(e,\"a\",\"equal\",\"string_or_numeric\"),a=E(t,\"b\",\"equal\",\"string_or_numeric\");[n,a]=_t(n,a),ct(n.shape,a.shape);let r={a:n,b:a};return P.runKernel(du,r)}var Jn=L({equal_:QP});function e3(e,t,n){let a=E(t,\"a\",\"where\"),r=E(n,\"b\",\"where\"),s=E(e,\"condition\",\"where\",\"bool\"),i=ct(ct(s.shape,a.shape),r.shape),o=ai(s,i),l=ai(a,i),u=ai(r,i),p={condition:o,t:l,e:u};return P.runKernel(Wu,p)}var nn=L({where_:e3});function t3(e){let t={x:E(e,\"x\",\"zerosLike\")};return P.runKernel(Yu,t)}var qe=L({zerosLike_:t3});function n3(e,t){let n=E(e,\"a\",\"div\"),a=E(t,\"b\",\"div\");[n,a]=_t(n,a);let r=he(n,a),s=qe(r),i=Jn(a,s);return nn(i,s,r)}var ow=L({divNoNan_:n3});function a3(e,t){let n=E(e,\"t1\",\"dot\"),a=E(t,\"t2\",\"dot\");A((n.rank===1||n.rank===2)&&(a.rank===1||a.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${a.rank}.`);let r=n.rank===1?n.size:n.shape[1],s=a.rank===1?a.size:a.shape[0];if(A(r===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${s}.`),n.rank===1&&a.rank===1){let i=W(n,[1,-1]),o=W(a,[-1,1]),l=$e(i,o);return W(l,[])}else if(n.rank===1&&a.rank===2){let i=W(n,[1,-1]),o=W(a,[a.shape[0],a.shape[1]]),l=$e(i,o);return W(l,[l.size])}else if(n.rank===2&&a.rank===1){let i=W(a,[-1,1]),o=$e(n,i);return W(o,[o.size])}else{let i=W(a,[a.shape[0],a.shape[1]]);return $e(n,i)}}var lw=L({dot_:a3});function r3(e,...t){let n=t.map((r,s)=>E(r,`tensors${s}`,\"einsum\")),a={equation:e};return P.runKernel(Tm,n,a)}var Zs=L({einsum_:r3});function s3(e){let t={x:E(e,\"x\",\"elu\",\"float32\")};return P.runKernel(ji,t)}var Qu=L({elu_:s3});function i3(e,t){let n=E(e,\"x\",\"ensureShape\",\"string_or_numeric\");if(!RS(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}var AN=L({ensureShape_:i3});function o3(e){let t=E(e,\"x\",\"erf\");A(t.dtype===\"int32\"||t.dtype===\"float32\",()=>\"Input dtype must be `int32` or `float32`.\"),t.dtype===\"int32\"&&(t=re(t,\"float32\"));let n={x:t};return P.runKernel(qi,n)}var Um=L({erf_:o3});function uw(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function FN(e,t,n){let a=e.length+t.length,r=[],s=0,i=0;for(let o=0;o<a;o++)n.indexOf(o)===-1?r.push(e[s++]):r.push(t[i++]);return r}function $N(e,t){let n=[],a=e.length;for(let s=0;s<a;s++)t.indexOf(s)===-1&&n.push(e[s]);let r=t.map(s=>e[s]);return[n,r]}function mi(e,t){let n=t.map(a=>1);return FN(e,n,t)}function l3(e,t,n){A(uw(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function DN(e,t){if(uw(e,t))return null;let n=[];for(let a=0;a<t;++a)e.indexOf(a)===-1&&n.push(a);return e.forEach(a=>n.push(a)),n}function pw(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function u3(e,t){let n=[];for(let a=t-e;a<t;++a)n.push(a);return n}function p3(e,t=null,n=!1){let a={x:E(e,\"x\",\"max\")},r={reductionIndices:t,keepDims:n};return P.runKernel(lo,a,r)}var ma=L({max_:p3});function c3(e,t=null,n=!1){let a={x:E(e,\"x\",\"min\")},r={axis:t,keepDims:n};return P.runKernel(ho,a,r)}var Ol=L({min_:c3});function d3(e,t){let n=E(e,\"base\",\"pow\"),a=E(t,\"exp\",\"pow\");[n,a]=_t(n,a);let r={a:n,b:a};return P.runKernel(vo,r)}var ur=L({pow_:d3});function xe(e,t){if((en(e)&&t!==\"string\"||Array.isArray(e))&&t!==\"complex64\")throw new Error(\"Error creating a new Scalar: value must be a primitive (number|boolean|string)\");if(t===\"string\"&&en(e)&&!(e instanceof Uint8Array))throw new Error(\"When making a scalar from encoded string, the value must be `Uint8Array`.\");return Ss(e,[],[],t)}function h3(e){let t={x:E(e,\"x\",\"sqrt\",\"float32\")};return P.runKernel(Po,t)}var rn=L({sqrt_:h3});function m3(e){let t=E(e,\"x\",\"square\"),n={};return P.runKernel(\"Square\",{x:t},n)}var pt=L({square_:m3});function f3(e,t=null,n=!1){let a=E(e,\"x\",\"sum\");a.dtype===\"bool\"&&(a=re(a,\"int32\"));let r={x:a},s={axis:t,keepDims:n};return P.runKernel(Lo,r,s)}var fe=L({sum_:f3});function g3(e,t=\"euclidean\",n=null,a=!1){e=E(e,\"x\",\"norm\");let r=RN(e,t,n),s=r.shape;if(a){let i=Aa(n,e.shape);s=mi(r.shape,i)}return W(r,s)}function RN(e,t,n=null){if(e.rank===0)return Lt(e);if(e.rank!==1&&n===null)return RN(W(e,[-1]),t,n);if(e.rank===1||typeof n==\"number\"||Array.isArray(n)&&n.length===1){if(t===1)return fe(Lt(e),n);if(t===1/0)return ma(Lt(e),n);if(t===-1/0)return Ol(Lt(e),n);if(t===\"euclidean\"||t===2)return rn(fe(ur(Lt(e),xe(2,\"int32\")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return ma(fe(Lt(e),n[0]),n[1]-1);if(t===1/0)return ma(fe(Lt(e),n[1]),n[0]);if(t===-1/0)return Ol(fe(Lt(e),n[1]),n[0]);if(t===\"fro\"||t===\"euclidean\")return rn(fe(pt(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var ep=L({norm_:g3});function b3(e,t=null,n=!1){return ep(e,\"euclidean\",t,n)}var cw=L({euclideanNorm_:b3});function y3(e){let t={x:E(e,\"x\",\"exp\")};return P.runKernel(Ki,t)}var dn=L({exp_:y3});function x3(e,t=0){let n=E(e,\"x\",\"expandDims\",\"string_or_numeric\");A(t<=n.rank,()=>\"Axis must be <= rank of the tensor\");let a={input:n},r={dim:t};return P.runKernel(hu,a,r)}var Gt=L({expandDims_:x3});function v3(e){let t={x:E(e,\"x\",\"expm1\")};return P.runKernel(Xi,t)}var dw=L({expm1_:v3});function w3(e,t){let n=E(e,\"x\",\"tile\",\"string_or_numeric\");A(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);let a={x:n},r={reps:t};return P.runKernel(ks,a,r)}var On=L({tile_:w3});function k3(e,t,n,a=\"float32\"){t==null&&(t=e);let r=Oe([e,t],a),s=e<=t?e:t;for(let o=0;o<s;++o)r.set(1,o,o);let i=W(r.toTensor(),[e,t]);if(n==null)return i;if(n.length===1)return On(Gt(i,0),[n[0],1,1]);if(n.length===2)return On(Gt(Gt(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return On(Gt(Gt(Gt(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var Gm=L({eye_:k3});function I3(e){let t={x:E(e,\"x\",\"floor\",\"float32\")};return P.runKernel(Yi,t)}var tp=L({floor_:I3});function S3(e,t,n=0,a=0){let r=E(e,\"x\",\"gather\"),s=E(t,\"indices\",\"gather\",\"int32\"),i={x:r,indices:s},o={axis:n,batchDims:a};return P.runKernel(fu,i,o)}var np=L({gather_:S3});function N3(e,t){let n=E(e,\"a\",\"greater\",\"string_or_numeric\"),a=E(t,\"b\",\"greater\",\"string_or_numeric\");[n,a]=_t(n,a),ct(n.shape,a.shape);let r={a:n,b:a};return P.runKernel(bu,r)}var Cn=L({greater_:N3});function T3(e,t){let n=E(e,\"a\",\"greaterEqual\",\"string_or_numeric\"),a=E(t,\"b\",\"greaterEqual\",\"string_or_numeric\");[n,a]=_t(n,a),ct(n.shape,a.shape);let r={a:n,b:a};return P.runKernel(Qi,r)}var $r=L({greaterEqual_:T3});function C3(e){let t={input:E(e,\"input\",\"imag\")};return P.runKernel(_m,t)}var ld=L({imag_:C3});function E3(e){let t={x:E(e,\"x\",\"isFinite\")};return P.runKernel(to,t)}var hw=L({isFinite_:E3});function _3(e){let t={x:E(e,\"x\",\"isInf\")};return P.runKernel(no,t)}var mw=L({isInf_:_3});function A3(e){let t={x:E(e,\"x\",\"isNaN\")};return P.runKernel(ao,t)}var fw=L({isNaN_:A3});function F3(e,t=.2){let n={x:E(e,\"x\",\"leakyRelu\")},a={alpha:t};return P.runKernel(ro,n,a)}var ud=L({leakyRelu_:F3});function $3(e,t){let n=E(e,\"a\",\"less\",\"string_or_numeric\"),a=E(t,\"b\",\"less\",\"string_or_numeric\");[n,a]=_t(n,a),ct(n.shape,a.shape);let r={a:n,b:a};return P.runKernel(yu,r)}var Pl=L({less_:$3});function D3(e,t){let n=E(e,\"a\",\"lessEqual\",\"string_or_numeric\"),a=E(t,\"b\",\"lessEqual\",\"string_or_numeric\");[n,a]=_t(n,a),ct(n.shape,a.shape);let r={a:n,b:a};return P.runKernel(xu,r)}var Cs=L({lessEqual_:D3});function MN(e,t,n){if(n<=0)throw new Error(\"The number of values should be positive.\");let a={start:e,stop:t,num:n};return P.runKernel(vu,{},a)}function R3(e,t=5,n=1,a=1,r=.5){let s=E(e,\"x\",\"localResponseNormalization\");A(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`),A($l(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=s,o=!1;s.rank===3&&(o=!0,i=W(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},u={depthRadius:t,bias:n,alpha:a,beta:r},p=P.runKernel(oo,l,u);return o?W(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var gw=L({localResponseNormalization_:R3});function M3(e){let t={x:E(e,\"x\",\"log\",\"float32\")};return P.runKernel(so,t)}var Qn=L({log_:M3});function O3(e){let t={x:E(e,\"x\",\"log1p\")};return P.runKernel(io,t)}var pd=L({log1p_:O3});function P3(e){return A(ss(e),()=>\"The f passed in grad(f) must be a function\"),(t,n)=>{let a=E(t,\"x\",\"tf.grad\",\"string_or_numeric\"),r=n!=null?E(n,\"dy\",\"tf.grad\"):null;return P.tidy(()=>{let{value:s,grads:i}=P.gradients(()=>e(a),[a],r);return r!=null&&Nn(s.shape,r.shape,\"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)\"),Hm(i),i[0]})}}function L3(e){return A(ss(e),()=>\"The f passed in grads(f) must be a function\"),(t,n)=>{A(Array.isArray(t),()=>\"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s\");let a=bc(t,\"args\",\"tf.grads\",\"string_or_numeric\"),r=n!=null?E(n,\"dy\",\"tf.grads\"):null;return P.tidy(()=>{let{value:s,grads:i}=P.gradients(()=>e(...a),a,r);return r!=null&&Nn(s.shape,r.shape,\"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])\"),Hm(i),i})}}function z3(e){return A(ss(e),()=>\"The f passed in valueAndGrad(f) must be a function\"),(t,n)=>{A(t instanceof Ce,()=>\"The x passed in valueAndGrad(f)(x) must be a tensor\"),A(n==null||n instanceof Ce,()=>\"The dy passed in valueAndGrad(f)(x, dy) must be a tensor\");let{grads:a,value:r}=P.gradients(()=>e(t),[t],n);return Hm(a),{grad:a[0],value:r}}}function W3(e){return A(ss(e),()=>\"The f passed in valueAndGrads(f) must be a function\"),(t,n)=>{A(Array.isArray(t)&&t.every(r=>r instanceof Ce),()=>\"The args passed in valueAndGrads(f)(args) must be array of tensors\"),A(n==null||n instanceof Ce,()=>\"The dy passed in valueAndGrads(f)(args, dy) must be a tensor\");let a=P.gradients(()=>e(...t),t,n);return n!=null&&Nn(a.value.shape,n.shape,\"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])\"),Hm(a.grads),a}}function ON(e,t){A(ss(e),()=>\"The f passed in variableGrads(f) must be a function\"),A(t==null||Array.isArray(t)&&t.every(u=>u instanceof os),()=>\"The varList passed in variableGrads(f, varList) must be an array of variables\");let n=t!=null;if(!n){t=[];for(let u in P.registeredVariables)t.push(P.registeredVariables[u])}let a=n?t.filter(u=>!u.trainable):null,r=t.length;t=t.filter(u=>u.trainable),A(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);let s=!0,{value:i,grads:o}=P.gradients(e,t,null,s);A(o.some(u=>u!=null),()=>\"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().\"),A(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let l={};return t.forEach((u,p)=>{o[p]!=null&&(l[u.name]=o[p])}),a!=null&&a.forEach(u=>l[u.name]=null),{value:i,grads:l}}function pr(e){return P.customGrad(e)}function Hm(e){if(e.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.`)}function B3(e){let t={x:E(e,\"x\",\"neg\")};return P.runKernel(Cu,t)}var yt=L({neg_:B3});function V3(e){let t={x:E(e,\"x\",\"softplus\")};return P.runKernel(Oo,t)}var Go=L({softplus_:V3});function U3(e){let t=E(e,\"x\",\"logSigmoid\");return pr(n=>({value:yt(Go(yt(n))),gradFunc:a=>z(a,ha(yt(n)))}))(t)}var bw=L({logSigmoid_:U3});function G3(e,t){let n=E(e,\"a\",\"sub\"),a=E(t,\"b\",\"sub\");[n,a]=_t(n,a);let r={a:n,b:a};return P.runKernel(Bo,r)}var pe=L({sub_:G3});function H3(e,t=-1){let n=E(e,\"logits\",\"logSoftmax\");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return pr((a,r)=>{let s=ma(a,t,!0),i=pe(a,s),o=pe(re(i,\"float32\"),Qn(fe(dn(i),t,!0)));return r([o]),{value:o,gradFunc:(l,u)=>{let[p]=u,d=!0,c=dn(p);return pe(l,z(fe(l,t,d),c))}}})(n)}var jm=L({logSoftmax_:H3});function j3(e,t=null,n=!1){let a=E(e,\"x\",\"logSumExp\"),r=Aa(t,a.shape),s=ma(a,r,!0),i=pe(a,s),o=dn(i),l=fe(o,r),u=Qn(l),p=X(W(s,u.shape),u);if(n){let d=mi(p.shape,r);return W(p,d)}return p}var cd=L({logSumExp_:j3});function q3(e,t){let n=E(e,\"a\",\"logicalAnd\",\"bool\"),a=E(t,\"b\",\"logicalAnd\",\"bool\");ct(n.shape,a.shape);let r={a:n,b:a};return P.runKernel(wu,r)}var _a=L({logicalAnd_:q3});function K3(e){let t={x:E(e,\"x\",\"logicalNot\",\"bool\")};return P.runKernel(ku,t)}var dd=L({logicalNot_:K3});function X3(e,t){let n=E(e,\"a\",\"logicalOr\",\"bool\"),a=E(t,\"b\",\"logicalOr\",\"bool\");ct(n.shape,a.shape);let r={a:n,b:a};return P.runKernel(Iu,r)}var qm=L({logicalOr_:X3});function Y3(e,t){let n=E(e,\"a\",\"logicalXor\",\"bool\"),a=E(t,\"b\",\"logicalXor\",\"bool\");return ct(n.shape,a.shape),_a(qm(e,t),dd(_a(e,t)))}var yw=L({logicalXor_:Y3}),vh=2147483648;function Z3(e,t,n=\"left\"){let a=E(e,\"sortedSequence\",\"searchSorted\"),r=E(t,\"values\",\"searchSorted\"),s=a.shape[a.shape.length-1],i=r.shape[r.shape.length-1],o=W(a,[-1,s]),l=W(r,[-1,i]);if(o.rank<2)throw new Error(\"Sorted input argument must be at least 2-dimensional\");if(o.shape[0]!==l.shape[0])throw new Error(\"Leading dimension of 'sortedSequence' and 'values' must match.\");if(ot(l.shape)>=vh)throw new Error(`values tensor size must less than ${vh}`);if(o.shape[1]>=vh)throw new Error(`trailing dim_size must less than ${vh} for int32 output type, was ${o.shape[1]}`);let u={sortedSequence:o,values:l},p={side:n};return P.runKernel(zu,u,p)}var Km=L({searchSorted_:Z3});function PN(e,t){return Km(e,t,\"left\")}function J3(e,t,n,a,r){let s=E(e,\"x\",\"maxPool\"),i=1,o=s,l=!1;s.rank===3&&(l=!0,o=W(s,[1,s.shape[0],s.shape[1],s.shape[2]])),A(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),A(dr(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),Tn(\"maxPool\",a,r);let u={x:o},p={filterSize:t,strides:n,pad:a,dimRoundingMode:r},d=P.runKernel(po,u,p);return l?W(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var Dt=L({maxPool_:J3});function Q3(e,t=[1,1,1],n,a,r,s=\"NDHWC\"){let i=E(e,\"x\",\"maxPool3d\"),o=i,l=!1;i.rank===4&&(l=!0,o=W(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),A(s===\"NDHWC\",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Tn(\"maxPool3d\",a,r);let u={x:o},p={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s},d=P.runKernel(Nu,u,p);return l?W(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var xw=L({maxPool3d_:Q3});function eL(e,t,n,a,r=!1){let s={x:E(e,\"x\",\"maxPoolWithArgmax\")},i={filterSize:t,strides:n,pad:a,includeBatchInIndex:r},o=P.runKernel(Vc,s,i);return{result:o[0],indexes:o[1]}}var LN=L({maxPoolWithArgmax_:eL});function tL(e,t){let n=E(e,\"a\",\"maximum\"),a=E(t,\"b\",\"maximum\");[n,a]=_t(n,a),n.dtype===\"bool\"&&(n=re(n,\"int32\"),a=re(a,\"int32\")),ct(n.shape,a.shape);let r={a:n,b:a};return P.runKernel(uo,r)}var hr=L({maximum_:tL});function nL(e,t=null,n=!1){let a={x:E(e,\"x\",\"mean\")},r={axis:t,keepDims:n};return P.runKernel(co,a,r)}var Ct=L({mean_:nL});function It(e,t=\"float32\"){if(na(e),t===\"complex64\"){let a=It(e,\"float32\"),r=It(e,\"float32\");return _r(a,r)}let n=xm(ot(e),t);return P.makeTensor(n,e,t)}function Pn(e,t=\"float32\"){if(na(e),t===\"complex64\"){let a=Pn(e,\"float32\"),r=It(e,\"float32\");return _r(a,r)}let n=Nv(ot(e),t);return P.makeTensor(n,e,t)}function zN(e,t,{indexing:n=\"xy\"}={}){if(n!==\"xy\"&&n!==\"ij\")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let a=E(e,\"x\",\"meshgrid\",e instanceof Ce?e.dtype:\"float32\");if(t===void 0)return[a];let r=E(t,\"y\",\"meshgrid\",t instanceof Ce?t.dtype:\"float32\"),s=ot(a.shape),i=ot(r.shape);return n===\"xy\"?(a=W(a,[1,-1]),r=W(r,[-1,1]),[$e(Pn([i,1],a.dtype),a),$e(r,Pn([1,s],r.dtype))]):(a=W(a,[-1,1]),r=W(r,[1,-1]),[$e(a,Pn([1,i],a.dtype)),$e(Pn([s,1],r.dtype),r)])}function aL(e,t){let n=E(e,\"a\",\"minimum\"),a=E(t,\"b\",\"minimum\");[n,a]=_t(n,a),n.dtype===\"bool\"&&(n=re(n,\"int32\"),a=re(a,\"int32\")),ct(n.shape,a.shape);let r={a:n,b:a};return P.runKernel(mo,r)}var ds=L({minimum_:aL});function rL(e,t,n){A(n===\"reflect\"||n===\"symmetric\",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let a=E(e,\"x\",\"mirrorPad\");if(a.rank===0)throw new Error(\"mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad\");A(t.length===a.rank,()=>`Padding doesn't match input. Must be ${a.rank}. Got ${t.length}.`);let r=n===\"reflect\"?1:0;for(let o=0;o<a.rank;o++)A(t[o].length===2,()=>\"Invalid number of paddings. Must be length of 2 each.\"),A(t[o][0]>=0&&t[o][0]<=a.shape[o]-r&&t[o][1]>=0&&t[o][1]<=a.shape[o]-r,()=>`Padding in dimension ${o} cannot be greater than or equal to ${a.shape[o]-r} or less than 0 for input of shape ${a.shape}`);let s={paddings:t,mode:n},i={x:a};return P.runKernel(fo,i,s)}var vw=L({mirrorPad_:rL});function sL(e,t){let n=E(e,\"a\",\"mod\"),a=E(t,\"b\",\"mod\");[n,a]=_t(n,a);let r={a:n,b:a};return P.runKernel(go,r)}var ww=L({mod_:sL});function iL(e,t=null,n=!1){e=E(e,\"x\",\"moments\");let a=Aa(t,e.shape),r=Ct(e,a,n),s=r.shape;n||(s=mi(r.shape,a));let i=pt(pe(re(e,\"float32\"),W(r,s))),o=Ct(i,a,n);return{mean:r,variance:o}}var hd=L({moments_:iL});function oL(e,t,n,a){let r=E(t,\"data\",\"multiRNNCell\"),s=bc(n,\"c\",\"multiRNNCell\"),i=bc(a,\"h\",\"multiRNNCell\"),o=r,l=[];for(let d=0;d<e.length;d++){let c=e[d](o,s[d],i[d]);l.push(c[0]),l.push(c[1]),o=c[1]}let u=[],p=[];for(let d=0;d<l.length;d+=2)u.push(l[d]),p.push(l[d+1]);return[u,p]}var WN=L({multiRNNCell_:oL});function lL(e,t,n,a=!1){let r=E(e,\"logits\",\"multinomial\"),s=r.size,i=r.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();let o={logits:i===1?W(r,[1,-1]):r},l={numSamples:t,seed:n,normalized:a},u=P.runKernel(Tu,o,l);return i===1?W(u,[u.size]):u}var BN=L({multinomial_:lL});function uL(e,t){let n=E(e,\"a\",\"notEqual\",\"string_or_numeric\"),a=E(t,\"b\",\"notEqual\",\"string_or_numeric\");[n,a]=_t(n,a),ct(n.shape,a.shape);let r={a:n,b:a};return P.runKernel(Eu,r)}var fi=L({notEqual_:uL});function pL(e,t,n=1,a=0,r=\"int32\"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s={indices:E(e,\"indices\",\"oneHot\",\"int32\")},i={dtype:r,depth:t,onValue:n,offValue:a};return P.runKernel(yo,s,i)}var Ll=L({oneHot_:pL});function cL(e){let t={x:E(e,\"x\",\"onesLike\")};return P.runKernel($u,t)}var ea=L({onesLike_:cL});function dL(e,t){let n=E(e,\"v1\",\"outerProduct\"),a=E(t,\"v2\",\"outerProduct\");A(n.rank===1&&a.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${a.rank}.`);let r=W(n,[-1,1]),s=W(a,[1,-1]);return $e(r,s)}var VN=L({outerProduct_:dL});function hL(e,t,n=0){let a=E(e,\"x\",\"pad\");if(a.rank===0)throw new Error(\"pad(scalar) is not defined. Pass non-scalar to pad\");let r={paddings:t,constantValue:n},s={x:a};return P.runKernel(xo,s,r)}var xa=L({pad_:hL});function mL(e,t,n=0){return A(t.length===2,()=>\"Invalid number of paddings. Must be length of 2.\"),xa(e,[t],n)}var UN=L({pad1d_:mL});function fL(e,t,n=0){return A(t.length===2&&t[0].length===2&&t[1].length===2,()=>\"Invalid number of paddings. Must be length of 2 each.\"),xa(e,t,n)}var GN=L({pad2d_:fL});function gL(e,t,n=0){return A(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>\"Invalid number of paddings. Must be length of 2 each.\"),xa(e,t,n)}var HN=L({pad3d_:gL});function bL(e,t,n=0){return A(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>\"Invalid number of paddings. Must be length of 2 each.\"),xa(e,t,n)}var jN=L({pad4d_:bL});function yL(e,t,n){let a=E(e,\"x\",\"spaceToBatchND\");A(a.rank>=1+t.length,()=>`input rank ${a.rank} should be > than [blockShape] ${t.length}`),A(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),A(a.shape.reduce((i,o,l)=>l>0&&l<=t.length?i&&(o+n[l-1][0]+n[l-1][1])%t[l-1]===0:i,!0),()=>`input spatial dimensions ${a.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);let r={x:a},s={blockShape:t,paddings:n};return P.runKernel(Vu,r,s)}var md=L({spaceToBatchND_:yL});function xL(e,t,n,a,r,s,i){r==null&&(r=[1,1]),s==null&&(s=1),a===0&&(a=\"valid\");let o=E(e,\"x\",\"maxPool\"),l=o,u=!1;o.rank===3&&(u=!0,l=W(o,[1,o.shape[0],o.shape[1],o.shape[2]])),A(dr(s,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${r}'`);let p=wN(l.shape,t,s,r,a),d=[p.dilationHeight,p.dilationWidth],c;a===\"same\"?c=wL([p.filterHeight,p.filterWidth],d):c=[[0,0],[0,0]];let h=d[0]===1&&d[1]===1,[m,f]=vL([p.inHeight,p.inWidth],d,c),g=h?a:\"valid\",b=h?l:md(l,d,m),y=(n===\"avg\"?()=>ya(b,t,s,g,i):()=>Dt(b,t,s,g,i))(),x=h?y:id(y,d,f);return u?W(x,[x.shape[1],x.shape[2],x.shape[3]]):x}function vL(e,t,n){let a=n.map(p=>p[0]),r=n.map(p=>p[1]),s=e.concat(a,r),i=t.map((p,d)=>(p-s[d]%p)%p),o=r.map((p,d)=>p+i[d]),l=t.map((p,d)=>[a[d],o[d]]),u=t.map((p,d)=>[0,i[d]]);return[l,u]}function wL(e,t){let n=e.map((s,i)=>s+(s-1)*(t[i]-1)).map(s=>s-1),a=n.map(s=>Math.floor(s/2)),r=n.map((s,i)=>s-a[i]);return n.map((s,i)=>[a[i],r[i]])}var kw=L({pool_:xL});function kL(e,t){let n=E(e,\"x\",\"prelu\"),a=E(t,\"alpha\",\"prelu\"),r={x:n,alpha:a};return P.runKernel(wo,r)}var fd=L({prelu_:kL});function IL(e,t=null,n=!1){let a=E(e,\"x\",\"prod\");a.dtype===\"bool\"&&(a=re(a,\"int32\"));let r={x:a},s={axis:t,keepDims:n};return P.runKernel(ko,r,s)}var Iw=L({prod_:IL});function SL(e,t,n,a){let r=e.map((p,d)=>E(p,`tensors${d}`,\"raggedGather\",\"int32\")),s=E(t,\"paramsDenseValues\",\"raggedGather\"),i=E(n,\"indices\",\"raggedGather\",\"int32\"),o={paramsNestedSplits:r,paramsDenseValues:s,indices:i},l={outputRaggedRank:a},u=P.runKernel(Am,o,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}var qN=L({raggedGather_:SL});function NL(e,t,n){let a=E(e,\"starts\",\"raggedRange\"),r=E(t,\"limits\",\"raggedRange\",a.dtype),s=E(n,\"deltas\",\"raggedRange\",a.dtype),i={starts:a,limits:r,deltas:s},o=P.runKernel(Fm,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}var KN=L({raggedRange_:NL});function TL(e,t,n,a,r){let s=E(e,\"shape\",\"raggedTensorToTensor\",\"int32\"),i=E(t,\"values\",\"raggedTensorToTensor\"),o=E(n,\"defaultValue\",\"raggedTensorToTensor\",i.dtype),l=a.map((d,c)=>E(d,`tensors${c}`,\"raggedTensorToTensor\",\"int32\")),u={shape:s,values:i,defaultValue:o,rowPartitionTensors:l},p={rowPartitionTypes:r};return P.runKernel($m,u,p)}var XN=L({raggedTensorToTensor_:TL});function CL(e,t,n){na(e);let a=ot(e),r=null;if(n==null||n===\"float32\")r=new Float32Array(a);else if(n===\"int32\")r=new Int32Array(a);else if(n===\"bool\")r=new Uint8Array(a);else throw new Error(`Unknown data type ${n}`);for(let s=0;s<a;s++)r[s]=t();return P.makeTensor(r,e,n)}var YN=L({rand_:CL}),Sw=xs(bm()),ZN={};_e(ZN,{TEST_EPSILON_FLOAT16:()=>JN,createVideoElement:()=>ML,encodeStrings:()=>QN,expectArrayBuffersEqual:()=>RL,expectArraysClose:()=>_L,expectArraysEqual:()=>FL,expectNumbersClose:()=>$L,expectPromiseToFail:()=>AL,expectValuesInRange:()=>DL,play:()=>OL,testEpsilon:()=>Nw});var EL=.001,JN=.1;function _L(e,t,n){return n==null&&(n=Nw()),Rx(e,t,(a,r)=>Tw(a,r,n))}function Nw(){return P.backend.floatPrecision()===32?EL:JN}function Rx(e,t,n){let a=!0;if((en(e)||en(t))&&(a=!1),en(e)&&en(t)&&(a=!0),a){let i=e.constructor.name,o=t.constructor.name;if(i!==o)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${o}`)}if(Array.isArray(e)&&Array.isArray(t)){let i=lr(e),o=lr(t);if(!Ar(i,o))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${o}]`)}let r=en(e)?e:is(e),s=en(t)?t:is(t);if(r.length!==s.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${s.length}.\nActual:   ${r}.\nExpected: ${s}.`);for(let i=0;i<s.length;++i){let o=r[i],l=s[i];if(!n(o,l))throw new Error(`Arrays differ: actual[${i}] = ${o}, expected[${i}] = ${l}.\nActual:   ${r}.\nExpected: ${s}.`)}typeof expect!=\"undefined\"&&expect().nothing()}function AL(e,t){e().then(()=>t.fail(),()=>t()),typeof expect!=\"undefined\"&&expect().nothing()}function FL(e,t){let n=typeof t==\"string\"||typeof t==\"number\"||typeof t==\"boolean\"?[t]:t;return Jr(e)||Jr(e[0])||Jr(t)||Jr(t[0])?Rx(e,n,(a,r)=>a==r):Rx(e,t,(a,r)=>Tw(a,r,0))}function $L(e,t,n){if(n==null&&(n=Nw()),!Tw(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);typeof expect!=\"undefined\"&&expect().nothing()}function Tw(e,t,n){return!isFinite(e)&&!isFinite(t)?!0:!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function DL(e,t,n){for(let a=0;a<e.length;a++)if(e[a]<t||e[a]>n)throw new Error(`Value out of range:${e[a]} low: ${t}, high: ${n}`)}function RL(e,t){let n=new Float32Array(e),a=new Float32Array(t);if(n.length!==a.length)throw new Error(`Expected ArrayBuffer to be of length ${a.length}, but it was ${n.length}`);for(let r=0;r<a.length;r++)if(n[r]!==a[r])throw new Error(`Expected ArrayBuffer value at ${r} to be ${a[r]} but got ${n[r]} instead`)}function QN(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?QN(n):e[t]=nd(n)}return e}function ML(e){let t=document.createElement(\"video\");return\"playsInline\"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position=\"fixed\",t.style.left=\"0px\",t.style.top=\"0px\",t.preload=\"auto\",t.appendChild(e),new Promise(n=>{t.addEventListener(\"loadeddata\",a=>n(t)),t.load()})}async function OL(e){await e.play(),\"requestVideoFrameCallback\"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}var Cw=class{constructor(e,t,n,a,r){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let s=r||Math.random();this.random=Sw.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){let a=this.nextVal;return this.nextVal=NaN,a}let e,t,n=!1;for(;!n;){let a,r,s;do a=2*this.random()-1,r=2*this.random()-1,s=a*a+r*r;while(s>=1||s===0);let i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*a*i,t=this.mean+this.stdDev*r*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype===\"float32\"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},PL=class{constructor(e,t,n,a){this.alpha=e,this.beta=1/t,this.dtype=n;let r=a||Math.random();this.randu=Sw.alea(r.toString()),this.randn=new Cw(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,a,r,s;for(;;){do a=this.randn.nextValue(),s=1+this.c*a;while(s<=0);if(s*=s*s,e=a*a,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),r=this.randu(),r<t||Math.log(r)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return this.dtype===\"float32\"?e:Math.round(e)}},LL=class{constructor(e=0,t=1,n,a){if(this.canReturnFloat=()=>this.dtype==null||this.dtype===\"float32\",this.min=e,this.range=t-e,this.dtype=n,a==null&&(a=Math.random()),typeof a==\"number\"&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Sw.alea(a)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function zL(e,t,n=1,a=\"float32\",r){if(na(e),n==null&&(n=1),a==null&&(a=\"float32\"),a!==\"float32\"&&a!==\"int32\")throw new Error(`Unsupported data type ${a}`);let s=new PL(t,n,a,r),i=Oe(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var eT=L({randomGamma_:zL});function WL(e,t=0,n=1,a,r){if(na(e),a!=null&&a===\"bool\")throw new Error(`Unsupported data type ${a}`);let s=new Cw(t,n,a,!1,r),i=Oe(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var Xm=L({randomNormal_:WL});function BL(e,t,n){if(t!=null&&t===\"bool\")throw new Error(`Unsupported data type ${t}`);return Xm(e,0,1,t,n)}var tT=L({randomStandardNormal_:BL});function VL(e,t=0,n=1,a=\"float32\",r){na(e);let s=Oe(e,a),i=new LL(t,n,null,r);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}var Es=L({randomUniform_:VL});function UL(e,t,n,a){return Es(e,t,n,\"int32\",a)}var nT=L({randomUniformInt_:UL});function gi(e,t,n=1,a=\"float32\"){if(n===0)throw new Error(\"Cannot have a step of zero\");let r={start:e,stop:t,step:n,dtype:a};return P.runKernel(Uc,{},r)}function GL(e){let t={input:E(e,\"input\",\"real\")};return P.runKernel(Dm,t)}var zl=L({real_:GL});function HL(e){let t={x:E(e,\"x\",\"reciprocal\")};return P.runKernel(Io,t)}var Ew=L({reciprocal_:HL});function jL(e){let t={x:E(e,\"x\",\"relu\")};return P.runKernel(So,t)}var Ke=L({relu_:jL});function qL(e){let t={x:E(e,\"x\",\"relu6\")};return P.runKernel(Co,t)}var Ym=L({relu6_:qL});function KL(e,t){let n={x:E(e,\"x\",\"reverse\")},a={dims:t};return P.runKernel(Eo,n,a)}var ba=L({reverse_:KL});function XL(e){let t=E(e,\"x\",\"reverse\");return A(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),ba(t,0)}var aT=L({reverse1d_:XL});function YL(e,t){let n=E(e,\"x\",\"reverse\");return A(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),ba(n,t)}var rT=L({reverse2d_:YL});function ZL(e,t){let n=E(e,\"x\",\"reverse\");return A(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),ba(n,t)}var sT=L({reverse3d_:ZL});function JL(e,t){let n=E(e,\"x\",\"reverse\");return A(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),ba(n,t)}var iT=L({reverse4d_:JL});function QL(e){let t={x:E(e,\"x\",\"round\")};return P.runKernel(_o,t)}var Zm=L({round_:QL});function ez(e){let t={x:E(e,\"x\",\"rsqrt\",\"float32\")};return P.runKernel(Ao,t)}var Jm=L({rsqrt_:ez});function tz(e){let t={x:E(e,\"x\",\"selu\")};return P.runKernel(Fo,t)}var Qm=L({selu_:tz});function nz(e,t,n,a,r,s=[1,1],i=\"NHWC\"){let o=E(e,\"x\",\"separableConv2d\"),l=E(t,\"depthwiseFilter\",\"separableConv2d\"),u=E(n,\"pointwiseFilter\",\"separableConv2d\"),p=o,d=!1;if(o.rank===3&&(d=!0,p=W(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i===\"NCHW\")throw new Error(\"separableConv2d currently does not support dataFormat NCHW; only NHWC is supported\");A(p.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${p.rank}.`),A(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),A(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),A(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),A(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);let c=l.shape[2],h=l.shape[3];A(u.shape[2]===c*h,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${c*h}, but got ${u.shape[2]}.`);let m=Ts(p,l,a,r,i,s),f=$t(m,u,1,\"valid\",i);return d?W(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var _s=L({separableConv2d_:nz});async function az(e,t){let n=E(e,\"x\",\"setdiff1d\"),a=E(t,\"y\",\"setdiff1d\");A(n.dtype===a.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${a.dtype}).`),A(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),A(a.rank===1,()=>`y should be 1D tensor, but got y (${a.shape}).`);let r=await n.data(),s=await a.data(),i=new Set(s),o=0;for(let p=0;p<r.length;p++)i.has(r[p])||o++;let l=new Wt([o],n.dtype),u=new Wt([o],\"int32\");for(let p=0,d=0;p<r.length;p++)i.has(r[p])||(l.values[d]=r[p],u.values[d]=p,d++);return[l.toTensor(),u.toTensor()]}var oT=az;function rz(e){let t={x:E(e,\"x\",\"sign\")};return P.runKernel(Ro,t)}var _w=L({sign_:rz});function sz(e){let t={x:E(e,\"x\",\"sin\",\"float32\")};return P.runKernel($o,t)}var ef=L({sin_:sz});function iz(e){let t={x:E(e,\"x\",\"sinh\")};return P.runKernel(Do,t)}var tf=L({sinh_:iz});function oz(e,t,n){let a=E(e,\"x\",\"slice1d\");return A(a.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${a.rank} tensor`),Ve(a,[t],[n])}var gd=L({slice1d_:oz});function lz(e,t,n){let a=E(e,\"x\",\"slice2d\");return A(a.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${a.rank} tensor`),Ve(a,t,n)}var nf=L({slice2d_:lz});function uz(e,t,n){let a=E(e,\"x\",\"slice3d\");return A(a.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${a.rank} tensor`),Ve(a,t,n)}var Ho=L({slice3d_:uz});function pz(e,t,n){let a=E(e,\"x\",\"slice4d\");return A(a.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${a.rank} tensor`),Ve(a,t,n)}var Wl=L({slice4d_:pz});function cz(e,t=-1){let n=E(e,\"logits\",\"softmax\",\"float32\");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let a={logits:n},r={dim:t};return P.runKernel(zo,a,r)}var qa=L({softmax_:cz});function dz(e){A(e.dtype===\"complex64\",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let t={input:e};return P.runKernel(Cm,t)}var bd=L({fft_:dz});function hz(e){A(e.dtype===\"complex64\",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let t={input:e};return P.runKernel(Em,t)}var Bl=L({ifft_:hz});function mz(e){let t=e.shape[e.shape.length-1],n=e.size/t,a;if(t<=2){let r=W(e,[n,t]);a=Bl(r)}else{let r=[n,2*(t-1)],s=W(zl(e),[n,t]),i=W(ld(e),[n,t]),o=ba(Ve(s,[0,1],[n,t-2]),1),l=z(ba(Ve(i,[0,1],[n,t-2]),1),xe(-1)),u=et([s,o],1),p=et([i,l],1),d=W(_r(u,p),[r[0],r[1]]);a=Bl(d)}if(a=zl(a),e.rank===3&&e.shape[0]!==0){let r=a,s=e.shape[0];a=W(a,[s,a.shape[0]/s,a.shape[1]]),r.dispose()}return a}var af=L({irfft_:mz});function fz(e,t,n=0){let a={x:E(e,\"x\",\"split\")},r={numOrSizeSplits:t,axis:n};return P.runKernel(Uu,a,r)}var Ln=L({split_:fz});function gz(e,t){A(e.dtype===\"float32\",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1],a=e.size/n,r;if(t!=null&&t<n){let m=e.shape.map(g=>0),f=e.shape.map(g=>g);f[e.shape.length-1]=t,r=Ve(e,m,f),n=t}else if(t!=null&&t>n){let m=e.shape.map(f=>f);m[e.shape.length-1]=t-n,r=et([e,It(m)],e.shape.length-1),n=t}else r=e;let s=qe(r),i=W(_r(r,s),[a,n]),o=bd(i),l=Math.floor(n/2)+1,u=zl(o),p=ld(o),d=Ln(u,[l,n-l],u.shape.length-1),c=Ln(p,[l,n-l],p.shape.length-1),h=r.shape.slice();return h[r.shape.length-1]=l,W(_r(d[0],c[0]),h)}var yd=L({rfft_:gz});function bz(e,t){let n=E(e,\"a\",\"squaredDifference\"),a=E(t,\"b\",\"squaredDifference\");[n,a]=_t(n,a),ct(n.shape,a.shape);let r={a:n,b:a},s={};return P.runKernel(Wo,r,s)}var rf=L({squaredDifference_:bz});function yz(e,t){let n=E(e,\"x\",\"squeeze\",\"string_or_numeric\");return W(n,MS(n.shape,t).newShape)}var As=L({squeeze_:yz});function xz(e,t=0){let n=bc(e,\"tensors\",\"stack\",\"string_or_numeric\");A(n.length>=1,()=>\"Pass at least one tensor to tf.stack\"),n.length>0&&A(t<=n[0].rank,()=>\"Axis must be <= rank of the tensor\");let a=n,r={axis:t};return P.runKernel(Du,a,r)}var At=L({stack_:xz});function vz(e,t=0){let n={x:E(e,\"x\",\"step\")},a={alpha:t};return P.runKernel(Is,n,a)}var jo=L({step_:vz});function wz(e,t,n,a,r=0,s=0,i=0,o=0,l=0){let u={x:E(e,\"x\",\"stridedSlice\",\"string_or_numeric\")},p={begin:t,end:n,strides:a,beginMask:r,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return P.runKernel(ju,u,p)}var Aw=L({stridedSlice_:wz});function kz(e){let t={x:E(e,\"x\",\"tan\",\"float32\")};return P.runKernel(Vo,t)}var Fw=L({tan_:kz});function je(e,t){Si(e);let n=lr(e,t);if(n.length!==1)throw new Error(\"tensor1d() requires values to be a flat/TypedArray\");return Ss(e,null,n,t)}function Ea(e,t,n){if(Si(e),t!=null&&t.length!==2)throw new Error(\"tensor2d() requires shape to have two numbers\");let a=lr(e,n);if(a.length!==2&&a.length!==1)throw new Error(\"tensor2d() requires values to be number[][] or flat/TypedArray\");if(a.length===1&&t==null)throw new Error(\"tensor2d() requires shape to be provided when `values` are a flat/TypedArray\");return Ss(e,t,a,n)}function xd(e,t,n){if(Si(e),t!=null&&t.length!==3)throw new Error(\"tensor3d() requires shape to have three numbers\");let a=lr(e,n);if(a.length!==3&&a.length!==1)throw new Error(\"tensor3d() requires values to be number[][][] or flat/TypedArray\");if(a.length===1&&t==null)throw new Error(\"tensor3d() requires shape to be provided when `values` are a flat array\");return Ss(e,t,a,n)}function Fa(e,t,n){if(Si(e),t!=null&&t.length!==4)throw new Error(\"tensor4d() requires shape to have four numbers\");let a=lr(e,n);if(a.length!==4&&a.length!==1)throw new Error(\"tensor4d() requires values to be number[][][][] or flat/TypedArray\");if(a.length===1&&t==null)throw new Error(\"tensor4d() requires shape to be provided when `values` are a flat array\");return Ss(e,t,a,n)}function lT(e,t,n){if(Si(e),t!=null&&t.length!==5)throw new Error(\"tensor5d() requires shape to have five numbers\");let a=lr(e,n);if(a.length!==5&&a.length!==1)throw new Error(\"tensor5d() requires values to be number[][][][][] or flat/TypedArray\");if(a.length===1&&t==null)throw new Error(\"tensor5d() requires shape to be provided when `values` are a flat array\");return Ss(e,t,a,n)}function uT(e,t,n){if(Si(e),t!=null&&t.length!==6)throw new Error(\"tensor6d() requires shape to have six numbers\");let a=lr(e,n);if(a.length!==6&&a.length!==1)throw new Error(\"tensor6d() requires values to be number[][][][][][] or flat/TypedArray\");if(a.length===1&&t==null)throw new Error(\"tensor6d() requires shape to be provided when `values` are a flat array\");return t=t||a,Ss(e,t,a,n)}var sf={};_e(sf,{calculateShapes:()=>pT,validateInput:()=>of,validateUpdateShape:()=>$w});function $w(e,t,n){let a=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${a}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(s+` update.rank < ${r}. `);if(e.length<a+(n.rank-r))throw new Error(s+` Output shape length < ${a+(n.rank-r)}`);if(n.rank!==r+e.length-a)throw new Error(s+` update.rank != ${r+e.length-a}`);for(let i=0;i<r;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-r;++i)if(n.shape[i+r]!==e[i+a])throw new Error(s+` updates.shape[${i+r}] (${n.shape[i+r]}) != shape[${i+r}] (${e[i+r]})`)}function of(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!==\"int32\")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}$w(n,t,e)}function pT(e,t,n){let a=t.shape.length,r=a>1?t.shape[a-1]:1,s=n.length,i=1;for(let d=r;d<s;++d)i*=n[d];let o=r<1?1:r,l=ot(t.shape)/o,u=[...Xl(n.slice(0,r)),1],p=ot(n);return{sliceRank:r,numUpdates:l,sliceSize:i,strides:u,outputSize:p}}function Iz(e,t,n){let a=E(e,\"tensor\",\"tensorScatterupdate\"),r=E(t,\"indices\",\"tensorScatterupdate\",\"int32\"),s=E(n,\"updates\",\"tensorScatterupdate\");if(of(s,r,a.shape),a.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${a.dtype} and ${s.dtype}.`);let i={tensor:a,indices:r,updates:s},o={};return P.runKernel(Lu,i,o)}var cT=L({tensorScatterUpdate_:Iz});function Sz(e,t=1,n=!0){let a=E(e,\"x\",\"topk\");if(a.rank===0)throw new Error(\"topk() expects the input to be of rank 1 or higher\");let r=a.shape[a.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);let s={x:a},i={k:t,sorted:n},[o,l]=P.runKernel(qu,s,i);return{values:o,indices:l}}var Dw=L({topk_:Sz});function Nz(e,t=0,n=1,a,r){if(na(e),a!=null&&a===\"bool\")throw new Error(\"Unsupported data type $ { dtype }\");let s=new Cw(t,n,a,!0,r),i=Oe(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var lf=L({truncatedNormal_:Nz});function Tz(e,t=0){let n=E(e,\"x\",\"unique\",\"string_or_numeric\");A(n.rank>0,()=>\"The input tensor must be at least 1D\");let a={x:n},r={axis:t},[s,i]=P.runKernel(Jc,a,r);return{values:s,indices:i}}var Rw=L({unique_:Tz});function Cz(e,t,n){let a=E(e,\"x\",\"unsortedSegmentSum\"),r=E(t,\"segmentIds\",\"unsortedSegmentSum\",\"int32\");A($l(n),()=>\"numSegments must be of dtype int\");let s={x:a,segmentIds:r},i={numSegments:n};return P.runKernel(Qc,s,i)}var uf=L({unsortedSegmentSum_:Cz});function Ez(e,t=0){let n=E(e,\"x\",\"unstack\",\"string_or_numeric\");A(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);let a={value:n},r={axis:t};return P.runKernel(Xu,a,r)}var dt=L({unstack_:Ez});function dT(e,t){return Km(e,t,\"right\")}function Mw(e,t=!0,n,a){return P.makeVariable(e,t,n,a)}function hT(e,t){let n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);let a=Oe(e,\"int32\"),r=Oe([n.length,e.length],\"int32\");for(let s=0;s<n.length;s++){let i=a.indexToLoc(n[s]),o=s*e.length;r.values.set(i,o)}return r.toTensor()}async function _z(e){let t=E(e,\"condition\",\"whereAsync\",\"bool\"),n=await t.data(),a=hT(t.shape,n);return e!==t&&t.dispose(),a}var Ow=_z;async function Az(e,t,n){let a=E(e,\"tensor\",\"boolMask\"),r=E(t,\"mask\",\"boolMask\",\"bool\"),s=n==null?0:n,i=r.rank,o=a.shape;A(i>0,()=>\"mask cannot be scalar\"),Nn(o.slice(s,s+i),r.shape,\"mask's shape must match the first K dimensions of tensor's shape,\");let l=1;for(let f=s;f<s+i;f++)l*=o[f];let u=o.slice(0,s).concat([l],o.slice(s+i)),p=W(a,u),d=W(r,[-1]),c=await Ow(d),h=As(c,[1]),m=np(p,h,s);return e!==a&&a.dispose(),t!==r&&r.dispose(),h.dispose(),p.dispose(),d.dispose(),c.dispose(),m}var mT=Az;function Fz(e,t,n){let a=E(e,\"x\",\"transpose\");if(t==null&&(t=a.shape.map((i,o)=>o).reverse()),A(a.rank===t.length,()=>`Error in transpose: rank of input ${a.rank} must match length of perm ${t}.`),t.forEach(i=>{A(i>=0&&i<a.rank,()=>`All entries in 'perm' must be between 0 and ${a.rank-1} but got ${t}`)}),a.rank<=1)return a.clone();let r={x:a},s={perm:t};return a.dtype===\"complex64\"?O(()=>{let i=zl(a),o=ld(a);return i=P.runKernel(Cr,{x:i},s),o=P.runKernel(Cr,{x:o},s),n&&(o=yt(o)),_r(i,o)}):P.runKernel(Cr,r,s)}var De=L({transpose_:Fz});function $z(e,t,n,a,r=!0){let s=E(e,\"v\",\"movingAverage\"),i=E(t,\"x\",\"movingAverage\"),o=E(n,\"decay\",\"movingAverage\");tN(s,i),A(Ar(s.shape,i.shape),()=>\"Shape mismatch in v and x\");let l=xe(1),u=pe(l,o),p=z(pe(i,s),u);if(r){A(a!=null,()=>\"When using zeroDebias: true, step is required.\");let d=E(a,\"step\",\"movingAverage\");p=he(p,pe(l,ur(o,d)))}return X(s,p)}var fT=L({movingAverage_:$z});function Dz(e,t,n){na(n);let a=E(e,\"indices\",\"scatterND\",\"int32\"),r=E(t,\"updates\",\"scatterND\");of(r,a,n);let s={indices:a,updates:r},i={shape:n};return P.runKernel(Pu,s,i)}var gT=L({scatterND_:Dz});function Rz(e,t,n,a){if(e.dtype!==\"int32\")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let r=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);let i=t.size;if(!(t.rank===0||t.rank===1&&i===r))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${r}]`);if(t.dtype!==a.dtype)throw new Error(\"sparseValues.dtype must match defaultValues.dtype\")}function Mz(e,t,n,a=0){na(n);let r=E(e,\"sparseIndices\",\"sparseToDense\",\"int32\"),s=E(t,\"sparseValues\",\"sparseToDense\",\"string_or_numeric\"),i=E(a,\"defaultValue\",\"sparseToDense\",s.dtype);Rz(r,s,n,i);let o={sparseIndices:r,sparseValues:s,defaultValue:i},l={outputShape:n};return P.runKernel(Hu,o,l)}var bT=L({sparseToDense_:Mz});function Oz(e,t){let n=E(t,\"indices\",\"gatherND\",\"int32\"),a={params:E(e,\"x\",\"gatherND\",\"string_or_numeric\"),indices:n};return P.runKernel(gu,a)}var yT=L({gatherND_:Oz});function Pz(e,t){if(t==null)return e.shape.slice();if(Ar(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let a=0;a<e.shape.length;a++)t[a]==null&&e.shape[a]!=null?n.push(e.shape[a]):n.push(t[a]);return n}return t}function Lz(e,t,n,a){let r=E(e,\"x\",\"dropout\");if(A(r.dtype===\"float32\",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),A(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof Ce?r.clone():r;let s=Pz(r,n),i=1-t,o=he(tp(X(Es(s,0,1,\"float32\",a),i)),i);return z(r,o)}var Pw=L({dropout_:Lz});function Lw(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function pf(e,t,n){let a=1-e%2,r=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+a-1);r[s]=t-n*Math.cos(i)}return je(r,\"float32\")}async function zz(e,t,n=1){let a=E(e,\"predictions\",\"inTopK\"),r=E(t,\"targets\",\"inTopK\");A(a.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${a.rank}`),A(a.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${a.rank} and targets rank ${r.rank}`),Nn(a.shape.slice(0,a.shape.length-1),r.shape,\"predictions's shape should be align with the targets' shape, except the last dimension.\");let s=a.shape[a.shape.length-1];A(n>0&&n<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`);let i=await a.data(),o=await r.data(),[l,u]=[i.length/s,s],p=OS(\"bool\",l);for(let d=0;d<l;d++){let c=d*u,h=i.subarray(c,c+u),m=[];for(let f=0;f<h.length;f++)m.push({value:h[f],index:f});m.sort((f,g)=>g.value-f.value),p[d]=0;for(let f=0;f<n;f++)if(m[f].index===o[d]){p[d]=1;break}}return e!==a&&a.dispose(),t!==r&&r.dispose(),bn(p,r.shape,\"bool\")}var xT=zz,Vl={};_e(Vl,{conv2d:()=>Vz,depthwiseConv2d:()=>jz,matMul:()=>Kz});function Wz(e,t,n,a,r,s=\"NHWC\",i){let o=e;e.rank===3&&(o=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=W(t,[1,t.shape[0],t.shape[1],t.shape[2]])),A(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),A(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),A(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let u=s===\"NHWC\"?o.shape[3]:o.shape[1],p=s===\"NHWC\"?l.shape[3]:l.shape[1];A(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),A(p===n[3],()=>`Error in conv2dDerFilter: depth of dy (${p}) must match output depth for filter (${n[3]}).`),Tn(\"conv2dDerFilter\",r,i);let d={x:o,dy:l},c={strides:a,pad:r,dataFormat:s,dimRoundingMode:i,filterShape:n};return P.runKernel(km,d,c)}var zw=L({conv2DBackpropFilter_:Wz});function cf(e,t,n){if(n==null||n===\"linear\")return e;if(n===\"relu\")return z(e,jo(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function df(e,t){let n=t,a=Bt(e.shape,t.shape);return a.length>0&&(n=fe(n,a)),W(n,e.shape)}function hf(e,t,n,a){if(t===\"linear\")return e;if(t===\"relu\")return Ke(e);if(t===\"elu\")return Qu(e);if(t===\"relu6\")return Ym(e);if(t===\"prelu\")return fd(e,n);if(t===\"leakyrelu\")return ud(e,a);if(t===\"sigmoid\")return ha(e);throw new Error(`Unknown fused activation ${t}.`)}var mf=(e,t)=>!(e>0)||t===\"linear\";function Bz({x:e,filter:t,strides:n,pad:a,dataFormat:r=\"NHWC\",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l=\"linear\",preluActivationWeights:u,leakyreluAlpha:p}){if(l=l||\"linear\",mf(P.state.gradientDepth,l)===!1){A(r===\"NHWC\",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let N=$t(e,t,n,a,r,s,i);return o!=null&&(N=X(N,o)),hf(N,l,u,p)}let d=E(e,\"x\",\"conv2d\",\"float32\"),c=E(t,\"filter\",\"conv2d\",\"float32\"),h=d,m=!1;d.rank===3&&(m=!0,h=W(d,[1,d.shape[0],d.shape[1],d.shape[2]])),A(h.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`),A(c.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${c.rank}.`),Tn(\"fused conv2d\",a,i);let f=r===\"NHWC\"?h.shape[3]:h.shape[1];A(c.shape[2]===f,()=>`Error in conv2d: depth of input (${f}) must match input depth for filter ${c.shape[2]}.`),A(dr(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`);let g=sd(h.shape,c.shape,n,s,a,i),b;o!=null&&(b=E(o,\"bias\",\"fused conv2d\"),[b]=_t(b,d),r===\"NHWC\"?ct(g.outShape,b.shape):(A(b.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`),A(b.shape.length===0||b.shape[0]===g.outChannels||b.shape[0]===1,()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let y;if(u!=null){let N=u.shape;if(A(N.length<=1||N.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${N.length}.`),N.length===1)A(N[0]===1||N[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the number of output channels (${g.outChannels}).`);else if(N.length===3)try{ct(N,g.outShape)}catch(C){let _=`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(_)}y=E(u,\"prelu weights\",\"fused conv2d\")}let x=(N,C)=>{A(r===\"NHWC\",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);let[_,F,D,$]=C,S=cf(N,D,l);A(ps(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let M=nw(F.shape,S,_,n,a),B=zw(F,S,_.shape,n,a),U=[M,B];if($!=null){let H=df($,S);U.push(H)}return U},v={x:h,filter:c,bias:b,preluActivationWeights:y},I={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:p};return o==null?pr((N,C,_)=>{let F=P.runKernel(oi,v,I);return _([C,N,F]),m&&(F=W(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:x}})(h,c):pr((N,C,_,F)=>{let D=P.runKernel(oi,v,I);return F([C,N,D,_]),m&&(D=W(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:x}})(h,c,b)}var Vz=L({fusedConv2d_:Bz});function Uz(e,t,n,a,r,s=[1,1],i){let o=e;e.rank===3&&(o=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=W(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:o,dy:l},p={strides:a,pad:r,dimRoundingMode:i,dilations:s,filterShape:n};return P.runKernel(Im,u,p)}var vT=L({depthwiseConv2dNativeBackpropFilter_:Uz});function Gz(e,t,n,a,r,s=[1,1],i){let o=t,l=!1;t.rank===3&&(l=!0,o=W(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:o,filter:n},p={strides:a,pad:r,dimRoundingMode:i,dilations:s,inputShape:e},d=P.runKernel(Sm,u,p);return l?W(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var wT=L({depthwiseConv2dNativeBackpropInput_:Gz});function Hz({x:e,filter:t,strides:n,pad:a,dataFormat:r=\"NHWC\",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l=\"linear\",preluActivationWeights:u,leakyreluAlpha:p}){if(mf(P.state.gradientDepth,l)===!1){let I=Ts(e,t,n,a,r,s,i);return o!=null&&(I=X(I,o)),hf(I,l,u,p)}let d=E(e,\"x\",\"depthwiseConv2d\",\"float32\"),c=E(t,\"filter\",\"depthwiseConv2d\",\"float32\"),h=d,m=!1;d.rank===3&&(m=!0,h=W(d,[1,d.shape[0],d.shape[1],d.shape[2]])),A(h.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),A(c.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`),A(h.shape[3]===c.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),s==null&&(s=[1,1]),A(dr(n,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),Tn(\"fused depthwiseConv2d\",a,i);let f=sd(h.shape,c.shape,n,s,a,i,!0),g;o!=null&&(g=E(o,\"bias\",\"fused conv2d\"),[g]=_t(g,d),ct(f.outShape,g.shape));let b;u!=null&&(b=E(u,\"prelu weights\",\"fused depthwiseConv2d\"));let y=(I,N)=>{A(ps(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[C,_,F,D]=N,$=cf(I,F,l),S=wT(_.shape,$,C,n,a,s,i),M=vT(_,$,C.shape,n,a,s,i);if(D!=null){let B=df(g,$);return[S,M,B]}return[S,M]},x={x:h,filter:c,bias:g,preluActivationWeights:b},v={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:p};return o==null?pr((I,N,C)=>{let _=P.runKernel(li,x,v);return C([N,I,_]),m&&(_=W(_,[_.shape[1],_.shape[2],_.shape[3]])),{value:_,gradFunc:y}})(h,c):pr((I,N,C,_)=>{let F=P.runKernel(li,x,v);return _([N,I,F,C]),m&&(F=W(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:y}})(h,c,g)}var jz=L({fusedDepthwiseConv2d_:Hz});function qz({a:e,b:t,transposeA:n=!1,transposeB:a=!1,bias:r,activation:s=\"linear\",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(mf(P.state.gradientDepth,s)===!1){let D=$e(e,t,n,a);return r!=null&&(D=X(D,r)),hf(D,s,i,o)}let l=E(e,\"a\",\"fused matMul\"),u=E(t,\"b\",\"fused matMul\");[l,u]=_t(l,u);let p=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=a?u.shape[u.rank-1]:u.shape[u.rank-2],c=n?l.shape[l.rank-1]:l.shape[l.rank-2],h=a?u.shape[u.rank-2]:u.shape[u.rank-1],m=l.shape.slice(0,-2),f=u.shape.slice(0,-2),g=ot(m),b=ot(f);A(p===d,()=>`Error in fused matMul: inner shapes (${p}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${a} must match.`);let y=ct(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([c,h]),x=n?W(l,[g,p,c]):W(l,[g,c,p]),v=a?W(u,[b,h,d]):W(u,[b,d,h]),I;r!=null&&(I=E(r,\"bias\",\"fused matMul\"),[I]=_t(I,l),ct(y,I.shape));let N;i!=null&&(N=E(i,\"prelu weights\",\"fused matMul\"));let C=(D,$)=>{let[S,M,B,U]=$,H=cf(W(D,B.shape),B,s),q,K;if(!n&&!a?(q=$e(H,M,!1,!0),K=$e(S,H,!0,!1)):!n&&a?(q=$e(H,M,!1,!1),K=$e(H,S,!0,!1)):n&&!a?(q=$e(M,H,!1,!0),K=$e(S,H,!1,!1)):(q=$e(M,H,!0,!0),K=$e(H,S,!0,!0)),r!=null){let Z=df(U,H);return[q,K,Z]}else return[q,K]},_={a:x,b:v,bias:I,preluActivationWeights:N},F={transposeA:n,transposeB:a,activation:s,leakyreluAlpha:o};return r==null?pr((D,$,S)=>{let M=P.runKernel(ii,_,F);return S([D,$,M]),{value:W(M,y),gradFunc:C}})(x,v):pr((D,$,S,M)=>{let B=P.runKernel(ii,_,F);return M([D,$,B,S]),{value:W(B,y),gradFunc:C}})(x,v,I)}var Kz=L({fusedMatMul_:qz});function Xz(e){return pf(e,.54,.46)}var Yz=L({hammingWindow_:Xz});function Zz(e){return pf(e,.5,.5)}var kT=L({hannWindow_:Zz});function Jz(e,t,n,a=!1,r=0){let s=0,i=[];for(;s+t<=e.size;)i.push(Ve(e,s,t)),s+=n;if(a)for(;s<e.size;){let o=s+t-e.size,l=et([Ve(e,s,t-o),yn([o],r)]);i.push(l),s+=n}return i.length===0?Ea([],[0,t]):W(et(i),[i.length,t])}var IT=L({frame_:Jz});function Qz(e,t,n,a,r=kT){a==null&&(a=Lw(t));let s=IT(e,t,n),i=z(s,r(t));return yd(i,a)}var eW=L({stft_:Qz});function tW(e,t,n,a,r=\"bilinear\",s=0){let i=E(e,\"image\",\"cropAndResize\"),o=E(t,\"boxes\",\"cropAndResize\",\"float32\"),l=E(n,\"boxInd\",\"cropAndResize\",\"int32\"),u=o.shape[0];A(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),A(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`),A(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`),A(a.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${a.length}.`),A(a[0]>=1&&a[1]>=1,()=>`cropSize must be atleast [1,1], but was ${a}`),A(r===\"bilinear\"||r===\"nearest\",()=>`method must be bilinear or nearest, but was ${r}`);let p={image:i,boxes:o,boxInd:l},d={method:r,extrapolationValue:s,cropSize:a};return P.runKernel(uu,p,d)}var nW=L({cropAndResize_:tW});function aW(e){let t=E(e,\"image\",\"flipLeftRight\",\"float32\");A(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let n={image:t};return P.runKernel(mu,n,{})}var rW=L({flipLeftRight_:aW});function sW(e){let t=E(e,\"image\",\"grayscaleToRGB\"),n=t.rank-1,a=t.shape[n];A(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),A(a===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${a}.`);let r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,On(t,r)}var iW=L({grayscaleToRGB_:sW});function oW(e){let t=E(e,\"image\",\"RGBToGrayscale\"),n=t.rank-1,a=t.shape[n];A(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),A(a===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${a}.`);let r=t.dtype,s=re(t,\"float32\"),i=je([.2989,.587,.114]),o;switch(t.rank){case 2:o=Zs(\"ij,j->i\",s,i);break;case 3:o=Zs(\"ijk,k->ij\",s,i);break;case 4:o=Zs(\"ijkl,l->ijk\",s,i);break;case 5:o=Zs(\"ijklm,m->ijkl\",s,i);break;case 6:o=Zs(\"ijklmn,n->ijklm\",s,i);break;default:throw new Error(\"Not a valid tensor rank.\")}return o=Gt(o,-1),re(o,r)}var lW=L({rgbToGrayscale_:oW});function uW(e,t,n=0,a=.5){let r=E(e,\"image\",\"rotateWithOffset\",\"float32\");A(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);let s={image:r},i={radians:t,fillValue:n,center:a};return P.runKernel(Zu,s,i)}var pW=L({rotateWithOffset_:uW});function ap(e,t,n,a,r,s){a==null&&(a=.5),r==null&&(r=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=e.shape[0];return n=Math.min(n,i),A(0<=a&&a<=1,()=>`iouThreshold must be in [0, 1], but was '${a}'`),A(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),A(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),A(t.rank===1,()=>\"scores must be a 1D tensor\"),A(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),A(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s}}function cW(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY){let s=E(e,\"boxes\",\"nonMaxSuppression\",\"float32\"),i=E(t,\"scores\",\"nonMaxSuppression\",\"float32\"),o=ap(s,i,n,a,r);n=o.maxOutputSize,a=o.iouThreshold,r=o.scoreThreshold;let l={maxOutputSize:n,iouThreshold:a,scoreThreshold:r};return P.runKernel(_u,{boxes:s,scores:i},l)}var dW=L({nonMaxSuppression_:cW});function hW(e,t,n){let a=mW(e,t,n),r=a<0?-(a+1):a;e.splice(r,0,t)}function mW(e,t,n){return gW(e,t,n||fW)}function fW(e,t){return e>t?1:e<t?-1:0}function gW(e,t,n){let a=0,r=e.length,s=0,i=!1;for(;a<r;){s=a+(r-a>>>1);let o=n(t,e[s]);o>0?a=s+1:(r=s,i=!o)}return i?a:-a-1}function ST(e,t,n,a,r){return Ww(e,t,n,a,r,0)}function NT(e,t,n,a,r,s){return Ww(e,t,n,a,r,0,!1,s,!0)}function TT(e,t,n,a,r,s){return Ww(e,t,n,a,r,s,!0)}function Ww(e,t,n,a,r,s,i=!1,o=!1,l=!1){let u=[];for(let g=0;g<t.length;g++)t[g]>r&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(tI);let p=s>0?-.5/s:0,d=[],c=[];for(;d.length<n&&u.length>0;){let g=u.pop(),{score:b,boxIndex:y,suppressBeginIndex:x}=g;if(b<r)break;let v=!1;for(let I=d.length-1;I>=x;--I){let N=bW(e,y,d[I]);if(N>=a){v=!0;break}if(g.score=g.score*yW(a,p,N),g.score<=r)break}g.suppressBeginIndex=d.length,v||(g.score===b?(d.push(y),c.push(g.score)):g.score>r&&hW(u,g,tI))}let h=d.length,m=n-h;o&&m>0&&(d.push(...new Array(m).fill(0)),c.push(...new Array(m).fill(0)));let f={selectedIndices:d};return i&&(f.selectedScores=c),l&&(f.validOutputs=h),f}function bW(e,t,n){let a=e.subarray(t*4,t*4+4),r=e.subarray(n*4,n*4+4),s=Math.min(a[0],a[2]),i=Math.min(a[1],a[3]),o=Math.max(a[0],a[2]),l=Math.max(a[1],a[3]),u=Math.min(r[0],r[2]),p=Math.min(r[1],r[3]),d=Math.max(r[0],r[2]),c=Math.max(r[1],r[3]),h=(o-s)*(l-i),m=(d-u)*(c-p);if(h<=0||m<=0)return 0;let f=Math.max(s,u),g=Math.max(i,p),b=Math.min(o,d),y=Math.min(l,c),x=Math.max(b-f,0)*Math.max(y-g,0);return x/(h+m-x)}function yW(e,t,n){let a=Math.exp(t*n*n);return n<=e?a:0}function tI(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function xW(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY){let s=E(e,\"boxes\",\"nonMaxSuppressionAsync\"),i=E(t,\"scores\",\"nonMaxSuppressionAsync\"),o=ap(s,i,n,a,r);n=o.maxOutputSize,a=o.iouThreshold,r=o.scoreThreshold;let l=await Promise.all([s.data(),i.data()]),u=l[0],p=l[1],{selectedIndices:d}=ST(u,p,n,a,r);return s!==e&&s.dispose(),i!==t&&i.dispose(),je(d,\"int32\")}var vW=xW;function wW(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=0){let i=E(e,\"boxes\",\"nonMaxSuppression\"),o=E(t,\"scores\",\"nonMaxSuppression\"),l=ap(i,o,n,a,r,s);n=l.maxOutputSize,a=l.iouThreshold,r=l.scoreThreshold,s=l.softNmsSigma;let u={boxes:i,scores:o},p={maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s},d=P.runKernel(Fu,u,p);return{selectedIndices:d[0],selectedScores:d[1]}}var kW=L({nonMaxSuppressionWithScore_:wW});async function IW(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=0){let i=E(e,\"boxes\",\"nonMaxSuppressionAsync\"),o=E(t,\"scores\",\"nonMaxSuppressionAsync\"),l=ap(i,o,n,a,r,s);n=l.maxOutputSize,a=l.iouThreshold,r=l.scoreThreshold,s=l.softNmsSigma;let u=await Promise.all([i.data(),o.data()]),p=u[0],d=u[1],{selectedIndices:c,selectedScores:h}=TT(p,d,n,a,r,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:je(c,\"int32\"),selectedScores:je(h)}}var SW=IW;function NW(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=!1){let i=E(e,\"boxes\",\"nonMaxSuppression\"),o=E(t,\"scores\",\"nonMaxSuppression\"),l=ap(i,o,n,a,r,null),u=l.maxOutputSize,p=l.iouThreshold,d=l.scoreThreshold,c={boxes:i,scores:o},h={maxOutputSize:u,iouThreshold:p,scoreThreshold:d,padToMaxOutputSize:s},m=P.runKernel(Au,c,h);return{selectedIndices:m[0],validOutputs:m[1]}}var TW=L({nonMaxSuppressionPadded_:NW});async function CW(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=!1){let i=E(e,\"boxes\",\"nonMaxSuppressionAsync\"),o=E(t,\"scores\",\"nonMaxSuppressionAsync\"),l=ap(i,o,n,a,r,null),u=l.maxOutputSize,p=l.iouThreshold,d=l.scoreThreshold,[c,h]=await Promise.all([i.data(),o.data()]),{selectedIndices:m,validOutputs:f}=NT(c,h,u,p,d,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:je(m,\"int32\"),validOutputs:xe(f,\"int32\")}}var EW=CW;function _W(e,t,n=!1,a=!1){let r=E(e,\"images\",\"resizeBilinear\");A(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),A(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),A(a===!1||n===!1,()=>\"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.\");let s=r,i=!1;r.rank===3&&(i=!0,s=W(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:a,size:t},u=P.runKernel(To,o,l);return i?W(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var CT=L({resizeBilinear_:_W});function AW(e,t,n=!1,a=!1){let r=E(e,\"images\",\"resizeNearestNeighbor\");A(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),A(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),A(r.dtype===\"float32\"||r.dtype===\"int32\",()=>\"`images` must have `int32` or `float32` as dtype\"),A(a===!1||n===!1,()=>\"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.\");let s=r,i=!1;r.rank===3&&(i=!0,s=W(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:a,size:t},u=P.runKernel(No,o,l);return i?W(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var ET=L({resizeNearestNeighbor_:AW});function FW(e,t=\"binary\",n=!1,a=.5){let r=E(e,\"image\",\"threshold\"),s=.2989,i=.587,o=.114,l=r.shape[0]*r.shape[1],u=z(je([a]),255),p,d,c,h;if(A(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),A(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),A(r.dtype===\"int32\"||r.dtype===\"float32\",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),A(t===\"otsu\"||t===\"binary\",()=>`Method must be binary or otsu, but was ${t}`),r.shape[2]===3){[p,d,c]=Ln(r,[1,1,1],-1);let f=z(p,s),g=z(d,i),b=z(c,o);h=X(X(f,g),b)}else h=e;if(t===\"otsu\"){let f=Yv(re(Zm(h),\"int32\"),bn([]),256);u=$W(f,l)}let m=n?Cs(h,u):Cn(h,u);return re(z(m,255),\"int32\")}function $W(e,t){let n=je([-1]),a=je([0]),r=je([0]),s,i,o,l,u,p;for(let d=0;d<e.size-1;d++){s=Ve(e,0,d+1),i=Ve(e,d+1),u=he(fe(s),t),p=he(fe(i),t);let c=fe(z(s,gi(0,s.size)));o=he(c,fe(s));let h=yn(i.shape,s.size),m=X(gi(0,i.size),h),f=z(i,m);l=he(fe(f),fe(i));let g=pe(o,l),b=pe(o,l),y=z(u,p);r=z(z(y,g),b);let x=Cn(r,a);a=nn(x,r,a),n=nn(x,je([d]),n)}return n}var DW=L({threshold_:FW});function RW(e,t,n=\"nearest\",a=\"constant\",r=0,s){let i=E(e,\"image\",\"transform\",\"float32\"),o=E(t,\"transforms\",\"transform\",\"float32\");A(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),A(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>\"Error in transform: Input transform should be batch x 8 or 1 x 8\"),A(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let l={image:i,transforms:o},u={interpolation:n,fillMode:a,fillValue:r,outputShape:s};return P.runKernel(Ku,l,u)}var MW=L({transform_:RW});function OW(e,t,n){let a=E(e,\"a\",\"bandPart\");A(a.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${a.rank}.`);let r=a.shape,[s,i]=a.shape.slice(-2),o,l;typeof t==\"number\"?(A(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),A(t<=s,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`),o=E(t<0?s:t,\"numLower\",\"bandPart\")):(A(t.dtype===\"int32\",()=>\"bandPart(): numLower's dtype must be an int32.\"),o=nn(Pl(t,0),s,ds(t,s))),typeof n==\"number\"?(A(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),A(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),l=E(n<0?i:n,\"numUpper\",\"bandPart\")):(A(n.dtype===\"int32\",()=>\"bandPart(): numUpper's dtype must be an int32.\"),l=nn(Pl(n,0),i,ds(n,i)));let u=W(gi(0,s,1,\"int32\"),[-1,1]),p=gi(0,i,1,\"int32\"),d=pe(u,p),c=_a(Cs(d,o),$r(d,yt(l))),h=It([s,i],a.dtype);return W(At(dt(W(a,[-1,s,i])).map(m=>nn(c,m,h))),r)}var PW=L({bandPart_:OW});function LW(e){let t;if(Array.isArray(e)){t=!1,A(e!=null&&e.length>0,()=>\"Gram-Schmidt process: input must not be null, undefined, or empty\");let r=e[0].shape[0];for(let s=1;s<e.length;++s)A(e[s].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[s].shape[0]} vs. ${r})`)}else t=!0,e=Ln(e,e.shape[0],0).map(r=>As(r,[0]));A(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],a=e;for(let r=0;r<e.length;++r)n.push(P.tidy(()=>{let s=a[r];if(r>0)for(let i=0;i<r;++i){let o=z(fe(z(n[i],s)),n[i]);s=pe(s,o)}return he(s,ep(s,\"euclidean\"))}));return t?At(n,0):n}var zW=L({gramSchmidt_:LW});function WW(e,t=!1){if(A(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return nI(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((l,u)=>l*u),a=dt(W(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],s=[];a.forEach(l=>{let[u,p]=nI(l,t);r.push(u),s.push(p)});let i=W(At(r,0),e.shape),o=W(At(s,0),e.shape);return[i,o]}}function nI(e,t=!1){return P.tidy(()=>{A(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],a=e.shape[1],r=Gm(n),s=sr(e),i=Ea([[1]],[1,1]),o=sr(i),l=n>=a?a:n;for(let u=0;u<l;++u){let p=s,d=o,c=r;[o,s,r]=P.tidy(()=>{let h=Ve(s,[u,u],[n-u,1]),m=ep(h),f=Ve(s,[u,u],[1,1]),g=nn(Cn(f,0),Ea([[-1]]),Ea([[1]])),b=pe(f,z(g,m)),y=he(h,b);y.shape[0]===1?o=sr(i):o=et([i,Ve(y,[1,0],[y.shape[0]-1,y.shape[1]])],0);let x=yt(he($e(g,b),m)),v=Ve(s,[u,0],[n-u,a]),I=z(x,o),N=De(o);if(u===0)s=pe(v,$e(I,$e(N,v)));else{let F=pe(v,$e(I,$e(N,v)));s=et([Ve(s,[0,0],[u,a]),F],0)}let C=De(I),_=Ve(r,[0,u],[n,r.shape[1]-u]);if(u===0)r=pe(_,$e($e(_,o),C));else{let F=pe(_,$e($e(_,o),C));r=et([Ve(r,[0,0],[n,u]),F],1)}return[o,s,r]}),Ee([p,d,c])}return!t&&n>a&&(r=Ve(r,[0,0],[n,a]),s=Ve(s,[0,0],[a,a])),[r,s]})}var BW=L({qr_:WW}),kn;(function(e){e[e.NONE=0]=\"NONE\",e[e.MEAN=1]=\"MEAN\",e[e.SUM=2]=\"SUM\",e[e.SUM_BY_NONZERO_WEIGHTS=3]=\"SUM_BY_NONZERO_WEIGHTS\"})(kn||(kn={}));function VW(e,t,n=kn.SUM_BY_NONZERO_WEIGHTS){let a=E(e,\"losses\",\"computeWeightedLoss\"),r=null;t!=null&&(r=E(t,\"weights\",\"computeWeightedLoss\"));let s=r==null?a:z(a,r);if(n===kn.NONE)return s;if(n===kn.SUM)return fe(s);if(n===kn.MEAN){if(r==null)return Ct(s);{let i=a.size/r.size,o=he(fe(s),fe(r));return i>1?he(o,xe(i)):o}}if(n===kn.SUM_BY_NONZERO_WEIGHTS){if(r==null)return he(fe(s),xe(a.size));{let i=z(r,Pn(a.shape)),o=re(fe(fi(i,xe(0))),\"float32\");return he(fe(s),o)}}throw Error(`Unknown reduction: ${n}`)}var Dr=L({computeWeightedLoss_:VW});function UW(e,t,n,a=kn.SUM_BY_NONZERO_WEIGHTS){let r=E(e,\"labels\",\"absoluteDifference\"),s=E(t,\"predictions\",\"absoluteDifference\"),i=null;n!=null&&(i=E(n,\"weights\",\"absoluteDifference\")),Nn(r.shape,s.shape,\"Error in absoluteDifference: \");let o=Lt(pe(r,s));return Dr(o,i,a)}var GW=L({absoluteDifference_:UW});function HW(e,t,n,a,r=kn.SUM_BY_NONZERO_WEIGHTS){let s=E(e,\"labels\",\"cosineDistance\"),i=E(t,\"predictions\",\"cosineDistance\"),o=null;a!=null&&(o=E(a,\"weights\",\"cosineDistance\")),Nn(s.shape,i.shape,\"Error in cosineDistance: \");let l=xe(1),u=pe(l,fe(z(s,i),n,!0));return Dr(u,o,r)}var jW=L({cosineDistance_:HW});function qW(e,t,n,a=kn.SUM_BY_NONZERO_WEIGHTS){let r=E(e,\"labels\",\"hingeLoss\"),s=E(t,\"predictions\",\"hingeLoss\"),i=null;n!=null&&(i=E(n,\"weights\",\"hingeLoss\")),Nn(r.shape,s.shape,\"Error in hingeLoss: \");let o=xe(1);r=pe(z(xe(2),r),o);let l=Ke(pe(o,z(r,s)));return Dr(l,i,a)}var KW=L({hingeLoss_:qW});function XW(e,t,n,a=1,r=kn.SUM_BY_NONZERO_WEIGHTS){let s=E(e,\"labels\",\"huberLoss\"),i=E(t,\"predictions\",\"huberLoss\"),o=null;n!=null&&(o=E(n,\"weights\",\"huberLoss\")),Nn(s.shape,i.shape,\"Error in huberLoss: \");let l=xe(a),u=Lt(pe(i,s)),p=ds(u,l),d=pe(u,p),c=X(z(xe(.5),pt(p)),z(l,d));return Dr(c,o,r)}var YW=L({huberLoss_:XW});function ZW(e,t,n,a=1e-7,r=kn.SUM_BY_NONZERO_WEIGHTS){let s=E(e,\"labels\",\"logLoss\"),i=E(t,\"predictions\",\"logLoss\"),o=null;n!=null&&(o=E(n,\"weights\",\"logLoss\")),Nn(s.shape,i.shape,\"Error in logLoss: \");let l=xe(1),u=xe(a),p=yt(z(s,Qn(X(i,u)))),d=z(pe(l,s),Qn(X(pe(l,i),u))),c=pe(p,d);return Dr(c,o,r)}var JW=L({logLoss_:ZW});function QW(e,t,n,a=kn.SUM_BY_NONZERO_WEIGHTS){let r=E(e,\"labels\",\"meanSquaredError\"),s=E(t,\"predictions\",\"meanSquaredError\"),i=null;n!=null&&(i=E(n,\"weights\",\"meanSquaredError\")),Nn(r.shape,s.shape,\"Error in meanSquaredError: \");let o=rf(r,s);return Dr(o,i,a)}var eB=L({meanSquaredError_:QW});function tB(e,t){let n=E(e,\"labels\",\"sigmoidCrossEntropyWithLogits\"),a=E(t,\"logits\",\"sigmoidCrossEntropyWithLogits\");Nn(n.shape,a.shape,\"Error in sigmoidCrossEntropyWithLogits: \");let r=Ke(a),s=z(a,n),i=pd(dn(yt(Lt(a))));return X(pe(r,s),i)}function nB(e,t,n,a=0,r=kn.SUM_BY_NONZERO_WEIGHTS){let s=E(e,\"multiClassLabels\",\"sigmoidCrossEntropy\"),i=E(t,\"logits\",\"sigmoidCrossEntropy\"),o=null;if(n!=null&&(o=E(n,\"weights\",\"sigmoidCrossEntropy\")),Nn(s.shape,i.shape,\"Error in sigmoidCrossEntropy: \"),a>0){let u=xe(a),p=xe(1),d=xe(.5);s=X(z(s,pe(p,u)),z(d,u))}let l=tB(s,i);return Dr(l,o,r)}var aB=L({sigmoidCrossEntropy_:nB});function rB(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return pr((a,r,s)=>{let i=cd(r,[n],!0),o=pe(re(r,\"float32\"),i);s([a,o]);let l=yt(z(o,a));return{value:fe(l,[n]),gradFunc:(u,p)=>{let[d,c]=p,h=mi(u.shape,[n]);return[z(W(u,h),pe(re(d,\"float32\"),dn(c))),z(W(u,h),pe(dn(c),re(d,\"float32\")))]}}})(e,t)}function sB(e,t,n,a=0,r=kn.SUM_BY_NONZERO_WEIGHTS){let s=E(e,\"onehotLabels\",\"softmaxCrossEntropy\"),i=E(t,\"logits\",\"softmaxCrossEntropy\"),o=null;if(n!=null&&(o=E(n,\"weights\",\"softmaxCrossEntropy\")),Nn(s.shape,i.shape,\"Error in softmaxCrossEntropy: \"),a>0){let u=xe(a),p=xe(1),d=xe(s.shape[1]);s=X(z(s,pe(p,u)),he(u,d))}let l=rB(s,i);return Dr(l,o,r)}var iB=L({softmaxCrossEntropy_:sB});function oB(e,t,n,a){let r=E(e,\"indices\",\"sparseFillEmptyRows\",\"int32\"),s=E(t,\"values\",\"sparseFillEmptyRows\"),i=E(n,\"denseShape\",\"sparseFillEmptyRows\",\"int32\"),o=E(a,\"defaultValue\",\"sparseFillEmptyRows\",s.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape\n        ${r.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let l={indices:r,values:s,denseShape:i,defaultValue:o},u=P.runKernel(Gc,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}var lB=L({sparseFillEmptyRows_:oB});function uB(e,t,n){let a=E(e,\"inputIndices\",\"sparseReshape\",\"int32\"),r=E(t,\"inputShape\",\"sparseReshape\",\"int32\"),s=E(n,\"newShape\",\"sparseReshape\",\"int32\");if(a.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape\n        ${a.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:a,inputShape:r,newShape:s},o=P.runKernel(Gu,i);return{outputIndices:o[0],outputShape:o[1]}}var pB=L({sparseReshape_:uB});function cB(e,t,n){let a=E(e,\"data\",\"sparseSegmentMean\"),r=E(t,\"indices\",\"sparseSegmentMean\",\"int32\"),s=E(n,\"segmentIds\",\"sparseSegmentMean\",\"int32\");if(a.rank<1)throw new Error(\"Data should be at least 1 dimensional but received scalar\");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape\n          ${r.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${s.shape}`);let i={data:a,indices:r,segmentIds:s};return P.runKernel(Hc,i)}var dB=L({sparseSegmentMean_:cB});function hB(e,t,n){let a=E(e,\"data\",\"sparseSegmentSum\"),r=E(t,\"indices\",\"sparseSegmentSum\",\"int32\"),s=E(n,\"segmentIds\",\"sparseSegmentSum\",\"int32\");if(a.rank<1)throw new Error(\"Data should be at least 1 dimensional but received scalar\");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape\n         ${r.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${s.shape}`);let i={data:a,indices:r,segmentIds:s};return P.runKernel(jc,i)}var mB=L({sparseSegmentSum_:hB});function fB(e,t,n,a,r,s,i,o){let l=E(e,\"data\",\"stringNGrams\",\"string\");if(l.dtype!==\"string\")throw new Error(\"Data must be of datatype string\");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);let u=E(t,\"dataSplits\",\"stringNGrams\");if(u.dtype!==\"int32\")throw new Error(\"Data splits must be of datatype int32\");let p={separator:n,nGramWidths:a,leftPad:r,rightPad:s,padWidth:i,preserveShortSequences:o},d={data:l,dataSplits:u},c=P.runKernel(Xc,d,p);return{nGrams:c[0],nGramsSplits:c[1]}}var gB=L({stringNGrams_:fB});function bB(e,t,n=!0){let a=E(e,\"input\",\"stringSplit\",\"string\"),r=E(t,\"delimiter\",\"stringSplit\",\"string\");if(a.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${a.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);let s={skipEmpty:n},i={input:a,delimiter:r},o=P.runKernel(Yc,i,s);return{indices:o[0],values:o[1],shape:o[2]}}var yB=L({stringSplit_:bB});function xB(e,t){let n=E(e,\"input\",\"stringToHashBucketFast\",\"string\"),a={numBuckets:t};if(t<=0)throw new Error(\"Number of buckets must be at least 1\");let r={input:n};return P.runKernel(Zc,r,a)}var vB=L({stringToHashBucketFast_:xB});function wB(e,t,n,a=!0){let r=E(e,\"input\",\"staticRegexReplace\",\"string\"),s={pattern:t,rewrite:n,replaceGlobal:a};return P.runKernel(Kc,{x:r},s)}var kB=L({staticRegexReplace_:wB}),_T={fft:bd,ifft:Bl,rfft:yd,irfft:af},AT={hammingWindow:Yz,hannWindow:kT,frame:IT,stft:eW},Zn={flipLeftRight:rW,grayscaleToRGB:iW,resizeNearestNeighbor:ET,resizeBilinear:CT,rgbToGrayscale:lW,rotateWithOffset:pW,cropAndResize:nW,nonMaxSuppression:dW,nonMaxSuppressionAsync:vW,nonMaxSuppressionWithScore:kW,nonMaxSuppressionWithScoreAsync:SW,nonMaxSuppressionPadded:TW,nonMaxSuppressionPaddedAsync:EW,threshold:DW,transform:MW},Bw={bandPart:PW,gramSchmidt:zW,qr:BW},FT={absoluteDifference:GW,computeWeightedLoss:Dr,cosineDistance:jW,hingeLoss:KW,huberLoss:YW,logLoss:JW,meanSquaredError:eB,sigmoidCrossEntropy:aB,softmaxCrossEntropy:iB},$T={sparseFillEmptyRows:lB,sparseReshape:pB,sparseSegmentMean:dB,sparseSegmentSum:mB},DT={stringNGrams:gB,stringSplit:yB,stringToHashBucketFast:vB,staticRegexReplace:kB},ne={};_e(ne,{Serializable:()=>RT,SerializationMap:()=>MT,getRegisteredName:()=>SB,registerClass:()=>OT});var IB=new Map,Mx=new Map,RT=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},MT=class Tl{constructor(){this.classNameMap={}}static getMap(){return Tl.instance==null&&(Tl.instance=new Tl),Tl.instance}static register(t){Tl.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function OT(e,t,n){A(e.className!=null,()=>\"Class being registered does not have the static className property defined.\"),A(typeof e.className==\"string\",()=>\"className is required to be a string, but got type \"+typeof e.className),A(e.className.length>0,()=>\"Class being registered has an empty-string as its className, which is disallowed.\"),typeof t==\"undefined\"&&(t=\"Custom\"),typeof n==\"undefined\"&&(n=e.className);let a=n,r=t+\">\"+a;return MT.register(e),IB.set(r,e),Mx.set(e,r),e}function SB(e){return Mx.has(e)?Mx.get(e):e.className}var Rr=class extends RT{minimize(e,t=!1,n){let{value:a,grads:r}=this.computeGradients(e,n);if(n!=null){let s=n.map(i=>({name:i.name,tensor:r[i.name]}));this.applyGradients(s)}else this.applyGradients(r);return Ee(r),t?a:(a.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return ON(e,t)}dispose(){this.iterations_!=null&&Ee(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:\"iter\",tensor:xe(this.iterations_,\"int32\")}}async getWeights(){throw new Error(\"getWeights() is not implemented for this optimizer yet.\")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(Rr,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});var Vw=class extends Rr{static get className(){return\"Adadelta\"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=P.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=P.registeredVariables[t],r=!1;this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:O(()=>qe(a).variable(r))}),this.accumulatedUpdates[n]==null&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:O(()=>qe(a).variable(r))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;O(()=>{let l=X(z(i,this.rho),z(pt(s),1-this.rho)),u=z(he(rn(X(o,this.epsilon)),rn(X(i,this.epsilon))),s),p=X(z(o,this.rho),z(pt(u),1-this.rho));i.assign(l),o.assign(p);let d=X(z(u,-this.learningRate),a);a.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Ee(this.accumulatedGrads.map(e=>e.variable)),Ee(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(a=>({originalName:a.name,variable:a.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},Uw=class extends Rr{static get className(){return\"Adagrad\"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=P.registeredVariables[t];this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:O(()=>yn(a.shape,this.initialAccumulatorValue).variable(!1))});let r=Array.isArray(e)?e[n].tensor:e[t];if(r==null)return;let s=this.accumulatedGrads[n].variable;O(()=>{let i=X(s,pt(r));s.assign(i);let o=X(z(he(r,rn(X(i,P.backend.epsilon()))),-this.learningRate),a);a.assign(o)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Ee(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},Gw=class extends Rr{static get className(){return\"Adam\"}constructor(e,t,n,a=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],O(()=>{this.accBeta1=xe(t).variable(),this.accBeta2=xe(n).variable()}),a==null&&(this.epsilon=P.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);O(()=>{let n=pe(1,this.accBeta1),a=pe(1,this.accBeta2);t.forEach((r,s)=>{let i=P.registeredVariables[r],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${r}/m`,variable:O(()=>qe(i).variable(o))}),this.accumulatedSecondMoment[s]==null&&(this.accumulatedSecondMoment[s]={originalName:`${r}/v`,variable:O(()=>qe(i).variable(o))});let l=Array.isArray(e)?e[s].tensor:e[r];if(l==null)return;let u=this.accumulatedFirstMoment[s].variable,p=this.accumulatedSecondMoment[s].variable,d=X(z(u,this.beta1),z(l,1-this.beta1)),c=X(z(p,this.beta2),z(pt(l),1-this.beta2)),h=he(d,n),m=he(c,a);u.assign(d),p.assign(c);let f=X(z(he(h,X(rn(m),this.epsilon)),-this.learningRate),i);i.assign(f)}),this.accBeta1.assign(z(this.accBeta1,this.beta1)),this.accBeta2.assign(z(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Ee(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Ee(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),O(()=>{this.accBeta1.assign(ur(this.beta1,this.iterations_+1)),this.accBeta2.assign(ur(this.beta2,this.iterations_+1))});let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(a=>({originalName:a.name,variable:a.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},Hw=class extends Rr{static get className(){return\"Adamax\"}constructor(e,t,n,a=null,r=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],O(()=>{this.iteration=xe(0).variable(),this.accBeta1=xe(t).variable()}),a==null&&(this.epsilon=P.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);O(()=>{let n=pe(1,this.accBeta1),a=he(-this.learningRate,X(z(this.iteration,this.decay),1));t.forEach((r,s)=>{let i=P.registeredVariables[r],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${r}/m`,variable:qe(i).variable(o)}),this.accumulatedWeightedInfNorm[s]==null&&(this.accumulatedWeightedInfNorm[s]={originalName:`${r}/v`,variable:qe(i).variable(o)});let l=Array.isArray(e)?e[s].tensor:e[r];if(l==null)return;let u=this.accumulatedFirstMoment[s].variable,p=this.accumulatedWeightedInfNorm[s].variable,d=X(z(u,this.beta1),z(l,1-this.beta1)),c=z(p,this.beta2),h=Lt(l),m=hr(c,h);u.assign(d),p.assign(m);let f=X(z(he(a,n),he(d,X(m,this.epsilon))),i);i.assign(f)}),this.iteration.assign(X(this.iteration,1)),this.accBeta1.assign(z(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Ee(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Ee(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error(\"getWeights() is not implemented for Adamax yet.\")}async setWeights(e){throw new Error(\"setWeights() is not implemented for Adamax yet.\")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},ff=class extends Rr{static get className(){return\"SGD\"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=Array.isArray(e)?e[n].tensor:e[t];if(a==null)return;let r=P.registeredVariables[t];O(()=>{let s=X(z(this.c,a),r);r.assign(s)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Ht(xe(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error(\"SGD optimizer does not have settable weights.\")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},jw=class extends ff{static get className(){return\"Momentum\"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=xe(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=P.registeredVariables[t];this.accumulations[n]==null&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:O(()=>qe(a).variable(!1))});let r=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];s!=null&&O(()=>{let i,o=X(z(this.m,r),s);this.useNesterov?i=X(z(this.c,X(s,z(o,this.m))),a):i=X(z(this.c,o),a),r.assign(o),a.assign(i)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Ee(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},qw=class extends Rr{static get className(){return\"RMSProp\"}constructor(e,t=.9,n=0,a=null,r=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,a==null&&(this.epsilon=P.backend.epsilon()),e==null)throw new Error(\"learningRate for RMSPropOptimizer must be defined.\")}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=P.registeredVariables[t],r=!1;this.accumulatedMeanSquares[n]==null&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:O(()=>qe(a).variable(r))}),this.accumulatedMoments[n]==null&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:O(()=>qe(a).variable(r))}),this.accumulatedMeanGrads[n]==null&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:O(()=>qe(a).variable(r))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;O(()=>{let l=X(z(i,this.decay),z(pt(s),1-this.decay));if(this.centered){let u=this.accumulatedMeanGrads[n].variable,p=X(z(u,this.decay),z(s,1-this.decay)),d=he(z(s,this.learningRate),rn(pe(l,X(pt(p),this.epsilon)))),c=X(z(o,this.momentum),d);i.assign(l),u.assign(p),o.assign(c);let h=pe(a,c);a.assign(h)}else{let u=X(z(i,this.decay),z(pt(s),1-this.decay)),p=X(z(o,this.momentum),he(z(s,this.learningRate),rn(X(u,this.epsilon))));i.assign(u),o.assign(p);let d=pe(a,p);a.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Ee(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Ee(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Ee(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},NB=[Vw,Uw,Gw,Hw,jw,qw,ff];function TB(){for(let e of NB)OT(e)}var jt={};_e(jt,{CompositeArrayBuffer:()=>Fr,browserFiles:()=>DB,browserHTTPRequest:()=>zB,concatenateArrayBuffers:()=>hO,copyModel:()=>MO,decodeWeights:()=>lN,decodeWeightsStream:()=>pN,encodeWeights:()=>oO,fromMemory:()=>BB,fromMemorySync:()=>BT,getLoadHandlers:()=>wO,getModelArtifactsForJSON:()=>Mv,getModelArtifactsForJSONSync:()=>dN,getModelArtifactsInfoForJSON:()=>rd,getSaveHandlers:()=>vO,getWeightSpecs:()=>_x,http:()=>Xw,isHTTPScheme:()=>Px,listModels:()=>DO,loadWeights:()=>MB,moveModel:()=>OO,registerLoadRouter:()=>xO,registerSaveRouter:()=>yO,removeModel:()=>RO,weightsLoaderFactory:()=>LT,withSaveHandler:()=>VB,withSaveHandlerSync:()=>UB});var CB=\"model\",EB=\".json\",_B=\".weights.bin\";function aI(e){return new Promise(t=>setTimeout(t)).then(e)}var Yh=class Ox{constructor(t){if(!G().getBool(\"IS_BROWSER\"))throw new Error(\"browserDownloads() cannot proceed because the current environment is not a browser.\");t.startsWith(Ox.URL_SCHEME)&&(t=t.slice(Ox.URL_SCHEME.length)),(t==null||t.length===0)&&(t=CB),this.modelJsonFileName=t+EB,this.weightDataFileName=t+_B}async save(t){if(typeof document==\"undefined\")throw new Error(\"Browser downloads are not supported in this environment since `document` is not present\");let n=Fr.join(t.weightData),a=window.URL.createObjectURL(new Blob([n],{type:\"application/octet-stream\"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error(\"BrowserDownloads.save() does not support saving model topology in binary formats yet.\");{let r=[{paths:[\"./\"+this.weightDataFileName],weights:t.weightSpecs}],s=cN(t,r),i=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:\"application/json\"})),o=this.modelJsonAnchor==null?document.createElement(\"a\"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await aI(()=>o.dispatchEvent(new MouseEvent(\"click\"))),t.weightData!=null){let l=this.weightDataAnchor==null?document.createElement(\"a\"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=a,await aI(()=>l.dispatchEvent(new MouseEvent(\"click\")))}return{modelArtifactsInfo:rd(t)}}}};Yh.URL_SCHEME=\"downloads://\";var AB=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=a=>{let r=JSON.parse(a.target.result),s=r.modelTopology;if(s==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(r.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:s});return}let i=Mv(r,o=>this.loadWeights(o));e(i)},n.onerror=a=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let s of e)t.push(...s.weights),n.push(...s.paths);let a=this.checkManifestAndWeightFiles(e),r=n.map(s=>this.loadWeightsFile(s,a[s]));return Promise.all(r).then(s=>[t,s])}loadWeightsFile(e,t){return new Promise((n,a)=>{let r=new FileReader;r.onload=s=>{let i=s.target.result;n(i)},r.onerror=s=>a(`Failed to weights data from file of path '${e}'.`),r.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(r=>eI(r.name)),a={};for(let r of e)r.paths.forEach(s=>{let i=eI(s);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),n.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);a[s]=this.weightsFiles[n.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return a}},FB=e=>G().getBool(\"IS_BROWSER\")&&!Array.isArray(e)&&e.startsWith(Yh.URL_SCHEME)?$B(e.slice(Yh.URL_SCHEME.length)):null;ga.registerSaveRouter(FB);function $B(e=\"model\"){return new Yh(e)}function DB(e){return new AB(e)}function rI(e,t,n,a){i(e),n=n==null?0:n,a=a==null?1:a,o(n,a);let r=0,s=l=>(l.then(u=>{let p=n+ ++r/e.length*(a-n);return t(p),u}),l);function i(l){A(l!=null&&Array.isArray(l)&&l.length>0,()=>\"promises must be a none empty array\")}function o(l,u){A(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),A(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),A(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(e.map(s))}async function PT(e,t){t==null&&(t={});let n=t.fetchFunc==null?G().platform.fetch:t.fetchFunc,a=e.map(s=>n(s,t.requestInit,{isBinary:!0})),r=(t.onProgress==null?await Promise.all(a):await rI(a,t.onProgress,0,.5)).map(s=>s.arrayBuffer());return t.onProgress==null?await Promise.all(r):await rI(r,t.onProgress,.5,1)}function RB(e,t){var n;let a=t.fetchFunc==null?G().platform.fetch:t.fetchFunc,r=0,s;return(n=t.onProgress)===null||n===void 0||n.call(t,0),new ReadableStream({pull:async i=>{for(var o;r<e.length;){s||(s=(await a(e[r],t.requestInit,{isBinary:!0})).body.getReader());let{done:l,value:u}=await s.read();if(l){r++,s=void 0,(o=t.onProgress)===null||o===void 0||o.call(t,r/e.length);continue}i.enqueue(u);return}i.close()}})}async function MB(e,t=\"\",n,a){return LT(r=>PT(r,{requestInit:a}))(e,t,n)}function LT(e){return async(t,n=\"\",a)=>{let r=t.map(()=>!1),s={},i=a!=null?a.map(()=>!1):[],o=[];if(t.forEach((h,m)=>{let f=0;h.weights.forEach(g=>{let b=\"quantization\"in g?g.quantization.dtype:g.dtype,y=ui[b]*ot(g.shape),x=()=>{r[m]=!0,s[m]==null&&(s[m]=[]),s[m].push({manifestEntry:g,groupOffset:f,sizeBytes:y})};a!=null?a.forEach((v,I)=>{v===g.name&&(x(),i[I]=!0)}):x(),o.push(g.name),f+=y})}),!i.every(h=>h)){let h=a.filter((m,f)=>!i[f]);throw new Error(`Could not find weights in manifest with names: ${h.join(\", \")}. \nManifest JSON has weights with names: ${o.join(\", \")}.`)}let l=r.reduce((h,m,f)=>(m&&h.push(f),h),[]),u=[];l.forEach(h=>{t[h].paths.forEach(m=>{let f=n+(n.endsWith(\"/\")?\"\":\"/\")+m;u.push(f)})});let p=await e(u),d={},c=0;return l.forEach(h=>{let m=t[h].paths.length,f=new Fr(p.slice(c,c+m));s[h].forEach(g=>{let b=f.slice(g.groupOffset,g.groupOffset+g.sizeBytes),y=lN(b,[g.manifestEntry]);for(let x in y)d[x]=y[x]}),c+=m}),d}}var OB=\"application/octet-stream\",PB=\"application/json\",Kw=class{constructor(e,t){if(this.DEFAULT_METHOD=\"POST\",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(A(typeof t.fetchFunc==\"function\",()=>\"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)\"),this.fetch=t.fetchFunc):this.fetch=G().platform.fetch,A(e!=null&&e.length>0,()=>\"URL path for http must not be null, undefined or empty.\"),Array.isArray(e)&&A(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error(\"requestInit is expected to have no pre-existing body, but has one.\");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error(\"BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.\");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:[\"./model.weights.bin\"],weights:e.weightSpecs}],a=cN(e,n);if(t.body.append(\"model.json\",new Blob([JSON.stringify(a)],{type:PB}),\"model.json\"),e.weightData!=null){let s=Fr.join(e.weightData);t.body.append(\"model.weights.bin\",new Blob([s],{type:OB}),\"model.weights.bin\")}let r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:rd(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(r){let s=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(\".pb\")?s+=\" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.\":s+=\" Please make sure the server is serving valid JSON for this request.\",new Error(s)}let n=t.modelTopology,a=t.weightsManifest;if(n==null&&a==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let e=await this.loadModelJSON();return Mv(e,t=>this.loadWeights(t))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=_x(e.weightsManifest),a=()=>RB(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:a})}async getWeightUrls(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,a]=LB(t),r=this.weightPathPrefix||n,s=[],i=[];for(let o of e)for(let l of o.paths)this.weightUrlConverter!=null?i.push(this.weightUrlConverter(l)):s.push(r+l+a);return this.weightUrlConverter&&s.push(...await Promise.all(i)),s}async loadWeights(e){let t=await this.getWeightUrls(e),n=_x(e),a=await PT(t,this.loadOptions);return[n,a]}};Kw.URL_SCHEME_REGEX=/^https?:\\/\\//;function LB(e){let t=e.lastIndexOf(\"/\"),n=e.lastIndexOf(\"?\"),a=e.substring(0,t),r=n>t?e.substring(n):\"\";return[a+\"/\",r]}function Px(e){return e.match(Kw.URL_SCHEME_REGEX)!=null}var zT=(e,t)=>{if(typeof fetch==\"undefined\"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(a=>Px(a)):n=Px(e),n)return Xw(e,t)}return null};ga.registerSaveRouter(zT);ga.registerLoadRouter(zT);function Xw(e,t){return new Kw(e,t)}function zB(e,t){return Xw(e,t)}var lx=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},WT=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},WB=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function BB(e,t,n,a){let r=arguments;return new WB(BT(...r))}function BT(e,t,n,a){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new lx(e):(console.warn(\"Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.\"),new lx({modelTopology:e})):(console.warn(\"Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.\"),new lx({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:a}))}function VB(e){return new WT(e)}function UB(e){return new WT(e)}var VT={};_e(VT,{confusionMatrix:()=>HB});function GB(e,t,n){let a=E(e,\"labels\",\"confusionMatrix\"),r=E(t,\"predictions\",\"confusionMatrix\");A(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),A(a.rank===1,()=>`Expected the rank of labels to be 1, but got ${a.rank}`),A(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),A(a.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${a.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),A(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let s=Ll(re(a,\"int32\"),n),i=Ll(re(r,\"int32\"),n),o=De(s),l=$e(o,i);return re(l,\"int32\")}var HB=L({confusionMatrix_:GB}),qo={};_e(qo,{draw:()=>QB,fromPixels:()=>e4,fromPixelsAsync:()=>YB,toPixels:()=>JB});var js,sI=!1;function UT(e,t=3){if(t>4)throw new Error(\"Cannot construct Tensor with more than 4 channels from pixels.\");if(e==null)throw new Error(\"pixels passed to tf.browser.fromPixels() can not be null\");let n=!1,a=!1,r=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData!=\"undefined\"&&e instanceof ImageData)a=!0;else if(typeof HTMLVideoElement!=\"undefined\"&&e instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement!=\"undefined\"&&e instanceof HTMLImageElement)s=!0;else if(e.getContext!=null)i=!0;else if(typeof ImageBitmap!=\"undefined\"&&e instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(fc(Hh,P.backendName)!=null){let c={pixels:e},h={numChannels:t};return P.runKernel(Hh,c,h)}let[l,u]=r?[e.videoWidth,e.videoHeight]:[e.width,e.height],p;if(i)p=e.getContext(\"2d\").getImageData(0,0,l,u).data;else if(a||n)p=e.data;else if(s||r||o){if(js==null)if(typeof document==\"undefined\")if(typeof OffscreenCanvas!=\"undefined\"&&typeof OffscreenCanvasRenderingContext2D!=\"undefined\")js=new OffscreenCanvas(1,1).getContext(\"2d\");else throw new Error(\"Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.\");else js=document.createElement(\"canvas\").getContext(\"2d\",{willReadFrequently:!0});js.canvas.width=l,js.canvas.height=u,js.drawImage(e,0,0,l,u),p=js.getImageData(0,0,l,u).data}let d;if(t===4)d=new Int32Array(p);else{let c=l*u;d=new Int32Array(c*t);for(let h=0;h<c;h++)for(let m=0;m<t;++m)d[h*t+m]=p[h*4+m]}return xd(d,[u,l,t],\"int32\")}function jB(e){return e!=null&&e.data instanceof Uint8Array}function qB(){return typeof window!=\"undefined\"&&typeof ImageBitmap!=\"undefined\"&&window.hasOwnProperty(\"createImageBitmap\")}function KB(e){return e!=null&&e.width!==0&&e.height!==0}function XB(e){return qB()&&!(e instanceof ImageBitmap)&&KB(e)&&!jB(e)}async function YB(e,t=3){let n=null;if(G().getBool(\"WRAP_TO_IMAGEBITMAP\")&&XB(e)){let a;try{a=await createImageBitmap(e,{premultiplyAlpha:\"none\"})}catch(r){a=null}a!=null&&a.width===e.width&&a.height===e.height?n=a:n=e}else n=e;return UT(n,t)}function GT(e){if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=e.rank===2?1:e.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(e.dtype!==\"float32\"&&e.dtype!==\"int32\")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}function ZB(e){let t=(e==null?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function JB(e,t){let n=E(e,\"img\",\"toPixels\");if(!(e instanceof Ce)){let u=n;n=re(u,\"int32\"),u.dispose()}GT(n);let[a,r]=n.shape.slice(0,2),s=n.rank===2?1:n.shape[2],i=await n.data(),o=n.dtype===\"float32\"?255:1,l=new Uint8ClampedArray(r*a*4);for(let u=0;u<a*r;++u){let p=[0,0,0,255];for(let c=0;c<s;c++){let h=i[u*s+c];if(n.dtype===\"float32\"){if(h<0||h>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${h}.`)}else if(n.dtype===\"int32\"&&(h<0||h>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${h}.`);s===1?(p[0]=h*o,p[1]=h*o,p[2]=h*o):p[c]=h*o}let d=u*4;l[d+0]=Math.round(p[0]),l[d+1]=Math.round(p[1]),l[d+2]=Math.round(p[2]),l[d+3]=Math.round(p[3])}if(t!=null){sI||fc(Nm,P.backendName)!=null&&(console.warn(\"tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead.\"),sI=!0),t.width=r,t.height=a;let u=t.getContext(\"2d\"),p=new ImageData(l,r,a);u.putImageData(p,0,0)}return n!==e&&n.dispose(),l}function QB(e,t,n){let a=E(e,\"img\",\"draw\");if(!(e instanceof Ce)){let i=a;a=re(i,\"int32\"),i.dispose()}GT(a),ZB(n==null?void 0:n.imageOptions);let r={image:a},s={canvas:t,options:n};P.runKernel(Nm,r,s)}var e4=L({fromPixels_:UT}),Yw={};_e(Yw,{prepareAndValidate:()=>HT});function HT(e,t){let n=e.shape.length,a=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(a<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${a}.`);if(t.dtype!==\"int32\")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[a-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[a-1]} vs. ${n}`);if(ot(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let r=t.shape,s=r[r.length-1],i=1;for(let d=0;d<r.length-1;++d)i*=r[d];let o=e.shape,l=r.slice();l.pop();let u=1;for(let d=s;d<n;++d)u*=o[d],l.push(o[d]);let p=[...Xl(e.shape).map(d=>d/u),1].slice(0,s);return[l,i,u,p]}var Kt={};_e(Kt,{assertParamsValid:()=>n4,computeFlatOffset:()=>o4,computeOutShape:()=>r4,getNormalizedAxes:()=>s4,isSliceContinous:()=>i4,maskToAxes:()=>a4,parseSliceParams:()=>e2,sliceInfo:()=>l4,startForAxis:()=>JT,startIndicesWithElidedDims:()=>XT,stopForAxis:()=>QT,stopIndicesWithElidedDims:()=>YT,stridesForAxis:()=>ZT,stridesWithElidedDims:()=>jT});var Lx=-2,t4=-1;function n4(e,t,n){let a=e.shape.length;A(a===t.length,()=>`Error in slice${a}D: Length of begin ${t} must match the rank of the array (${a}).`),A(a===n.length,()=>`Error in slice${a}D: Length of size ${n} must match the rank of the array (${a}).`);for(let r=0;r<a;++r)A(t[r]+n[r]<=e.shape[r],()=>`Error in slice${a}D: begin[${r}] + size[${r}] (${t[r]+n[r]}) would overflow input.shape[${r}] (${e.shape[r]})`)}function a4(e){let t=[],n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function r4(e,t,n){let a=[];for(let r=0;r<e.length;r++)a[r]=Math.ceil((t[r]-e[r])/n[r]);return a}function jT(e,t,n,a){let r=[...e];for(let s=r.length;s<a.length;s++)r.push(1);for(let s=0;s<n;s++)s===0?r[t]=1:(r.splice(t,0,1),r.pop());return r}function qT(e,t,n){return n<=e?n:n-(t-1)}function KT(e,t){let n=[];for(let a=0;a<e;a++)n.push(t+a);return n}function s4(e,t,n,a,r,s,i,o,l){let u=e.length,p=new Array(u),d=new Array(u),c=new Array(u);if(t.length&&n>0){let h=t[0],m=n+1;p=XT(i,h,m,a,e),d=YT(o,h,m,r,e),c=jT(s,h,m,e)}else for(let h=0;h<u;h++)p[h]=JT(i,a,s,e,h,l),d[h]=QT(o,r,s,e,h,l),c[h]=ZT(s,h,l);return{begin:p,end:d,strides:c}}function XT(e,t,n,a,r){let s=[...r],i=KT(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{let l=qT(t,n,o),u=a[l];e&1<<l&&(u=0),s[o]=u}return s}function YT(e,t,n,a,r){let s=[...r],i=KT(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{let l=qT(t,n,o),u=a[l];e&1<<l&&(u=Number.MAX_SAFE_INTEGER),s[o]=u}for(let o=0;o<s.length;o++){let l=r[o];s[o]<0&&(s[o]+=l),s[o]=hc(0,s[o],r[o])}return s}function ZT(e,t,n){let a=e[t];return(n&1<<t||a==null)&&(a=1),a}function JT(e,t,n,a,r,s){let i=t[r],o=n[r]||1;(e&1<<r||s&1<<r||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let l=a[r];return i<0&&(i+=l),i=hc(0,i,l-1),i}function QT(e,t,n,a,r,s){let i=t[r],o=n[r]||1;(e&1<<r||s&1<<r||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let l=a[r];return i<0&&(i+=l),o>0?i=hc(0,i,l):i=hc(-1,i,l-1),i}function i4(e,t,n){let a=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){a=r;break}for(let r=a+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function o4(e,t){let n=e.length>0?e[e.length-1]:1;for(let a=0;a<e.length-1;a++)n+=e[a]*t[a];return n}function e2(e,t,n){let a,r=e.shape.length;typeof t==\"number\"?a=[t,...new Array(r-1).fill(0)]:t.length<r?a=t.concat(new Array(r-t.length).fill(0)):a=t.slice(),a.forEach(i=>{A(i!==-1,()=>\"slice() does not support negative begin indexing.\")});let s;return n==null?s=new Array(r).fill(-1):typeof n==\"number\"?s=[n,...new Array(r-1).fill(-1)]:n.length<r?s=n.concat(new Array(r-n.length).fill(-1)):s=n,s=s.map((i,o)=>i>=0?i:(A(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),e.shape[o]-a[o])),[a,s]}function l4(e,t,n,a,r,s,i,o,l){let u;if(a==null?(u=new Array(t.length),u.fill(1)):u=a,i!=null&&i&i-1)throw new Error(\"Multiple ellipses in slice is not allowed.\");let p=!1,d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:r,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let y=0;y<d.dims;y++)p&&1<<y&o&&d.numAddAxisAfterEllipsis++,1<<y&i&&(p=!0);p||(d.ellipsisMask|=1<<d.dims,d.dims++);let c={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};u4(d,c);let h=!0,m=!0,f=!0,g=[],b=[];for(let y=0;y<e.length;++y){if(c.strides[y]===0)throw Error(`strides[${y}] must be non-zero`);let x=!!(c.shrinkAxisMask&1<<y),v=e[y];if(v===-1){g.push(x?1:-1);continue}let I=[c.beginMask&1<<y,c.endMask&1<<y],N=[c.strides[y]>0?0:-1,c.strides[y]>0?v:v-1];if(x&&c.strides[y]<=0)throw Error(\"only stride 1 allowed on non-range indexing.\");f=f&&c.strides[y]===1;let C=!!(c.beginMask&1<<y&&c.endMask&1<<y);if(c.beginValid&&c.endValid){if(x){let $=c.begin[y]<0?v+c.begin[y]:c.begin[y];if(c.begin[y]=$,c.end[y]=c.begin[y]+1,$<0||$>=v)throw Error(`slice index ${c.begin[y]} of dimension ${y} out of bounds.`)}else c.begin[y]=iI(c.begin[y],0,c.strides[y],v,I,N),c.end[y]=iI(c.end[y],1,c.strides[y],v,I,N);let D=c.strides[y]===1&&c.begin[y]===0&&c.end[y]===v;h=h&&D,m=m&&(y===0&&c.strides[y]===1||D)}else h=h&&c.strides[y]===1&&C,m=m&&(y===0&&c.strides[y]===1||C);let _,F=!1;if(c.beginValid&&c.endValid?(_=c.end[y]-c.begin[y],F=!0):x?(_=1,F=!0):C&&v>=0&&(c.strides[y]<0?_=-v:_=v,F=!0),F){let D;_===0||_<0!=c.strides[y]<0?D=0:D=Math.trunc(_/c.strides[y])+(_%c.strides[y]!==0?1:0),g.push(D)}else g.push(-1)}for(let y=0;y<c.finalShapeGatherIndices.length;++y){let x=c.finalShapeGatherIndices[y];x>=0?b.push(g[x]):x===Lx&&b.push(1)}return{finalShapeSparse:b.filter((y,x)=>c.finalShapeGatherIndices[x]!==Lx),finalShape:b,isIdentity:h,sliceDim0:m,isSimpleSlice:f,begin:c.begin,end:c.end,strides:c.strides}}function u4(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let a=0;a<e.dims;a++)if(1<<a&e.ellipsisMask){let r=Math.min(t.dims-(e.dims-a)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=a}else if(1<<a&e.newAxisMask)t.finalShapeGatherIndices.push(Lx),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[a]),e.end!=null&&(t.end[n]=e.end[a]),t.strides[n]=e.strides[a],e.beginMask&1<<a&&(t.beginMask|=1<<n),e.endMask&1<<a&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<a?(t.finalShapeGatherIndices.push(t4),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(a)),t.inputShapeGatherIndicesSparse[n]=a,n++}}function iI(e,t,n,a,r,s){if(r[t])return n>0?s[t]:s[t+1&1];{let i=e<0?a+e:e;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var p4=\"4.22.0\",t2=class{static sgd(e){return new ff(e)}static momentum(e,t,n=!1){return new jw(e,t,n)}static rmsprop(e,t=.9,n=0,a=null,r=!1){return new qw(e,t,n,a,r)}static adam(e=.001,t=.9,n=.999,a=null){return new Gw(e,t,n,a)}static adadelta(e=.001,t=.95,n=null){return new Vw(e,t,n)}static adamax(e=.002,t=.9,n=.999,a=null,r=0){return new Hw(e,t,n,a,r)}static adagrad(e,t=.1){return new Uw(e,t)}},Xs=t2,c4=typeof requestAnimationFrame!=\"undefined\"?requestAnimationFrame:typeof setImmediate!=\"undefined\"?setImmediate:e=>e();function Zw(){return new Promise(e=>c4(()=>e()))}var T={};_e(T,{ERF_A1:()=>T4,ERF_A2:()=>C4,ERF_A3:()=>E4,ERF_A4:()=>_4,ERF_A5:()=>A4,ERF_P:()=>N4,PARALLELIZE_THRESHOLD:()=>Jw,RowPartitionType:()=>er,SELU_SCALE:()=>a2,SELU_SCALEALPHA:()=>n2,applyActivation:()=>hf,assertAndGetBroadcastShape:()=>ct,assertAxesAreInnerMostDims:()=>l3,assertParamsConsistent:()=>d4,assignToTypedArray:()=>O4,axesAreInnerMostDims:()=>uw,calculateShapes:()=>pT,checkEinsumDimSizes:()=>V4,checkPadOnDimRoundingMode:()=>Tn,combineLocations:()=>FN,combineRaggedTensorToTensorShapes:()=>m4,complexWithEvenIndex:()=>D4,complexWithOddIndex:()=>R4,computeConv2DInfo:()=>sd,computeConv3DInfo:()=>kN,computeDefaultPad:()=>Hv,computeDilation2DInfo:()=>iP,computeOptimalWindowSize:()=>y4,computeOutAndReduceShapes:()=>$N,computeOutShape:()=>h4,computePool2DInfo:()=>wN,computePool3DInfo:()=>oP,convertConv2DDataFormat:()=>IN,decodeEinsumEquation:()=>W4,eitherStridesOrDilationsAreOne:()=>dr,expandShapeToKeepDim:()=>mi,exponent:()=>L4,exponents:()=>P4,fromStringArrayToUint8:()=>uV,fromUint8ToStringArray:()=>lV,getAxesPermutation:()=>DN,getBroadcastDims:()=>_N,getComplexWithIndex:()=>M4,getEinsumComputePath:()=>U4,getEinsumPermutation:()=>B4,getFusedBiasGradient:()=>df,getFusedDyActivation:()=>cf,getImageCenter:()=>x4,getInnerMostAxes:()=>u3,getPermuted:()=>w4,getRaggedRank:()=>g4,getReductionAxes:()=>Bt,getReshaped:()=>v4,getReshapedPermuted:()=>k4,getRowPartitionTypesHelper:()=>f4,getSliceBeginCoords:()=>I4,getSliceSize:()=>S4,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>q4,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>K4,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>X4,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>J4,getSparseReshapeInputOutputMismatchErrorMessage:()=>eV,getSparseReshapeInputOutputMultipleErrorMessage:()=>Q4,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Y4,getSparseReshapeNegativeOutputDimErrorMessage:()=>Z4,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>rV,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>tV,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>nV,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>aV,getUndoAxesPermutation:()=>pw,isIdentityPermutation:()=>G4,log:()=>gM,mergeRealAndImagArrays:()=>F4,prepareAndValidate:()=>HT,prepareSplitSize:()=>j4,segment_util:()=>r2,shouldFuse:()=>mf,slice_util:()=>Kt,splitRealAndImagArrays:()=>$4,stridesOrDilationsArePositive:()=>hi,tupleValuesAreOne:()=>ps,upcastType:()=>fa,validateDefaultValueShape:()=>b4,validateInput:()=>of,validateUpdateShape:()=>$w,warn:()=>Zr});function d4(e,t){let n=e[0].length;e.forEach((r,s)=>{A(r.length===n,()=>`Error in concat${n}D: rank of tensors[${s}] must be the same as the rank of the rest (${n})`)}),A(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let a=e[0];e.forEach((r,s)=>{for(let i=0;i<n;i++)A(i===t||r[i]===a[i],()=>`Error in concat${n}D: Shape of tensors[${s}] (${r}) does not match the shape of the rest (${a}) along the non-concatenated axis ${s}.`)})}function h4(e,t){let n=e[0].slice();for(let a=1;a<e.length;a++)n[t]+=e[a][t];return n}var er;(function(e){e[e.FIRST_DIM_SIZE=0]=\"FIRST_DIM_SIZE\",e[e.VALUE_ROWIDS=1]=\"VALUE_ROWIDS\",e[e.ROW_LENGTHS=2]=\"ROW_LENGTHS\",e[e.ROW_SPLITS=3]=\"ROW_SPLITS\",e[e.ROW_LIMITS=4]=\"ROW_LIMITS\",e[e.ROW_STARTS=5]=\"ROW_STARTS\"})(er||(er={}));function m4(e,t,n){let a=new Array;if(n==null&&t==null)return a;if(t==null)for(;a.length<e+n.length;)a.push(-1);else a=t.slice();if(n==null)return a;if(e+n.length!==a.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${a.length}`);for(let r=1;r<n.length;++r){let s=n[r],i=a[a.length-n.length+r],o=a[i];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${r+e}] = ${s} but shape[${r+e}] = ${o}`)}else a[i]=s}return a}function f4(e){let t={FIRST_DIM_SIZE:er.FIRST_DIM_SIZE,VALUE_ROWIDS:er.VALUE_ROWIDS,ROW_LENGTHS:er.ROW_LENGTHS,ROW_SPLITS:er.ROW_SPLITS,ROW_LIMITS:er.ROW_LIMITS,ROW_STARTS:er.ROW_STARTS},n=[];for(let a of e)if(a in t)n.push(t[a]);else break;return n}function g4(e){return e.length===0?0:e[0]===er.FIRST_DIM_SIZE?e.length-1:e.length}function b4(e,t){if(e==null||t==null)return;let n=e.length,a=t.length;if(n>=a)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${a})`);for(let r=0;r<Math.min(n,a-1);++r){let s=e[r],i=t[r+1];if(s>=0&&i>=0&&s!==1&&s!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${r-e.length}] = ${s} but ragged tensor input.flatValues.shape[${r-e.length}] = ${i}`)}}var Jw=30;function y4(e){return e<=Jw?e:Gh(e,Math.floor(Math.sqrt(e)))}function x4(e,t,n){let a=n*(typeof e==\"number\"?e:e[0]),r=t*(typeof e==\"number\"?e:e[1]);return[a,r]}function v4(e,t,n,a=!0){let r=[];if(a)r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);let s=t.length;for(let i=0;i<s;++i)r=r.concat([e[i+1]/t[i],t[i]]);r=r.concat(e.slice(s+1))}return r}function w4(e,t,n=!0){let a=[];if(n){a.push(t);for(let r=t+1;r<e;++r)r<=2*t?(a.push(r),a.push(r-(t+1))):a.push(r)}else{let r=[],s=[];for(let i=1;i<e;++i)i>=t*2+1||i%2===1?s.push(i):r.push(i);a.push(...r),a.push(0),a.push(...s)}return a}function k4(e,t,n,a=!0){let r=[];a?r.push(e[0]/n):r.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?a?r.push(t[s-1]*e[s]):r.push(e[s]/t[s-1]):r.push(e[s]);return r}function I4(e,t){let n=[0];for(let a=0;a<t;++a)n.push(e[a][0]);return n}function S4(e,t,n){let a=e.slice(0,1);for(let r=0;r<n;++r)a.push(e[r+1]-t[r][0]-t[r][1]);return a}var n2=1.7580993408473768,a2=1.0507009873554805,N4=.3275911,T4=.254829592,C4=-.284496736,E4=1.421413741,_4=-1.453152027,A4=1.061405429;function F4(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(e.length*2);for(let a=0;a<n.length;a+=2)n[a]=e[a/2],n[a+1]=t[a/2];return n}function $4(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let a=0;a<e.length;a+=2)t[a/2]=e[a],n[a/2]=e[a+1];return{real:t,imag:n}}function D4(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function R4(e){let t=Math.floor(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function M4(e,t){let n=e[t*2],a=e[t*2+1];return{real:n,imag:a}}function O4(e,t,n,a){e[a*2]=t,e[a*2+1]=n}function P4(e,t){let n=new Float32Array(e/2),a=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){let s=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(s),a[r]=Math.sin(s)}return{real:n,imag:a}}function L4(e,t,n){let a=(n?2:-2)*Math.PI*(e/t),r=Math.cos(a),s=Math.sin(a);return{real:r,imag:s}}var ux=\"->\",z4=/->/g,oI=\",\",lI=\"...\";function W4(e,t){e=e.replace(/\\s/g,\"\");let n=(e.length-e.replace(z4,\"\").length)/ux.length;if(n<1)throw new Error(\"Equations without an arrow are not supported.\");if(n>1)throw new Error(`Equation must contain exactly one arrow (\"${ux}\").`);let[a,r]=e.split(ux);A(a.indexOf(lI)===-1,()=>`The ellipsis notation (\"${lI}\") is not supported yet.`);let s=a.split(oI),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error(\"Support for more than 2 input tensors is not implemented yet.\");let o=[];for(let c=0;c<r.length;++c){let h=r[c];if(!s.some(m=>m.indexOf(h)!==-1))throw new Error(`Output subscripts contain the label ${h} not present in the input subscripts.`);o.indexOf(h)===-1&&o.push(h)}for(let c=0;c<a.length;++c){let h=a[c];o.indexOf(h)===-1&&h!==oI&&o.push(h)}let l=new Array(s.length);for(let c=0;c<i;++c){if(new Set(s[c].split(\"\")).size!==s[c].length)throw new Error(`Found duplicate axes in input component ${s[c]}. Support for duplicate axes in input is not implemented yet.`);l[c]=[];for(let h=0;h<s[c].length;++h)l[c].push(o.indexOf(s[c][h]))}let u=o.length,p=r.length,d=[];for(let c=p;c<u;++c)d.push(c);return{allDims:o,summedDims:d,idDims:l}}function B4(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;let a=[];for(let r=0;r<e;++r)n[r]===-1&&a.push(r);return n=n.filter(r=>r!==-1),{permutationIndices:n,expandDims:a}}function V4(e,t,n){let a=new Array(e);for(let r=0;r<n.length;++r){let s=n[r].shape;for(let i=0;i<t[r].length;++i)a[t[r][i]]===void 0?a[t[r][i]]=s[i]:A(a[t[r][i]]===s[i],()=>`Expected dimension ${a[t[r][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function U4(e,t){let n=e,a=[],r=0;e.length===0&&n.push(-1),r=e.length+1;for(let i=0;i<r;++i)a.push([]);let s=[];for(let i=0;i<n.length;++i){let o=n[i],l=H4(t,o);for(let u of l)s.indexOf(u)===-1&&(a[i].push(u),s.push(u))}return{path:n,steps:a}}function G4(e){return e.every((t,n)=>t===n)}function H4(e,t){let n=[];for(let a=0;a<e.length;++a)(e[a].length===0||e[a].indexOf(t)!==-1||t===-1)&&n.push(a);return n}function j4(e,t,n=0){let a=[];if(typeof t==\"number\")A(e.shape[n]%t===0,()=>\"Number of splits must evenly divide the axis.\"),a=new Array(t).fill(e.shape[n]/t);else{let r=t.reduce((i,o)=>(o===-1&&(i+=1),i),0);A(r<=1,()=>\"There should be only one negative value in split array.\");let s=t.indexOf(-1);if(s!==-1){let i=t.reduce((o,l)=>l>0?o+l:o);t[s]=e.shape[n]-i}A(e.shape[n]===t.reduce((i,o)=>i+o),()=>\"The sum of sizes must match the size of the axis dimension.\"),a=t}return a}function q4(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function K4(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function X4(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function Y4(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function Z4(e,t){return`size ${e} must be non-negative, not ${t}`}function J4(){return\"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero\"}function Q4(e,t){let n=ot(e),a=ot(t);return`Input to reshape is a SparseTensor with ${n}\n  dense values, but the requested shape requires a multiple of ${a}. inputShape=${e} outputShape= ${t}`}function eV(e,t){let n=ot(e),a=ot(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${a}. inputShape=${e} outputShape=${t}`}function tV(){return\"segment ids must be >= 0\"}function nV(){return\"segment ids are not increasing\"}function aV(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function rV(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var r2={};_e(r2,{collectGatherOpShapeInfo:()=>oV,computeOutShape:()=>iV,segOpComputeOptimalWindowSize:()=>sV});function sV(e,t){let n=!1,a;for(e<=Jw?(a=e,n=!0):a=Gh(e,Math.floor(Math.sqrt(e)));!n;)a>t||a===e?n=!0:a=Gh(e,a+1);return a}function iV(e,t,n){let a=[],r=e.length;for(let s=0;s<r;s++)s!==t?a.push(e[s]):a.push(n);return a}function oV(e,t,n,a){let r=t.shape.length,s=e.shape.length;if(a!==0&&(a<-r||a>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${a}`);if(a<0&&(a+=r),a>s)throw new Error(`batchDims (${a}) must be less than rank(x) (\n    ${s}).`);if(n<a)throw new Error(`batchDims (${a}) must be less than or equal to axis (${n}).`);for(let d=0;d<a;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);let i=e.shape[n],o=[],l=1,u=1,p=1;for(let d=0;d<a;++d)o.push(e.shape[d]),l*=e.shape[d];for(let d=a;d<n;d++)o.push(e.shape[d]),u*=e.shape[d];for(let d=a;d<r;d++)o.push(t.shape[d]);for(let d=n+1;d<s;d++)o.push(e.shape[d]),p*=e.shape[d];return{batchSize:l,sliceSize:p,outerSize:u,dimSize:i,outputShape:o}}function lV(e){try{return e.map(t=>qh(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function uV(e){return e.map(t=>nd(t))}var mr={};_e(mr,{nonMaxSuppressionV3Impl:()=>ST,nonMaxSuppressionV4Impl:()=>NT,nonMaxSuppressionV5Impl:()=>TT,whereImpl:()=>hT});TB();var s2={kernelName:Yl,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,jo(re(n,\"float32\"),-1))}}},pV={kernelName:Ni,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=pt(re(n,\"float32\")),r=rn(pe(xe(1),a));return yt(he(e,r))}}}},cV={kernelName:Ti,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=rn(pe(pt(re(n,\"float32\")),1));return he(e,a)}}}},dV={kernelName:vs,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t)=>{let[n,a]=t,r=ct(n.shape,a.shape);return{a:()=>{let s=e,i=Bt(n.shape,r);return i.length>0&&(s=fe(s,i)),W(s,n.shape)},b:()=>{let s=e,i=Bt(a.shape,r);return i.length>0&&(s=fe(s,i)),W(s,a.shape)}}}},hV={kernelName:Ci,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((a,r)=>{n[r]=()=>e.clone()}),n}},mV={kernelName:Ql,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>qe(n)}}},fV={kernelName:eu,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>qe(n)}}},gV={kernelName:Ei,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>he(e,rn(pe(xe(1),pt(re(n,\"float32\")))))}}},bV={kernelName:_i,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=rn(X(xe(1),pt(re(n,\"float32\"))));return he(e,a)}}}},yV={kernelName:$i,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t)=>{let[n,a]=t,r=ct(n.shape,a.shape);return{a:()=>{let s=X(pt(n),pt(a)),i=z(e,he(a,s)),o=Bt(n.shape,r);return o.length>0&&(i=fe(i,o)),W(i,n.shape)},b:()=>{let s=X(pt(n),pt(a)),i=yt(z(e,he(n,s))),o=Bt(a.shape,r);return o.length>0&&(i=fe(i,o)),W(i,a.shape)}}}},xV={kernelName:Ai,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>he(e,X(pt(re(n,\"float32\")),1))}}},vV={kernelName:Fi,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>he(e,pe(xe(1),pt(re(n,\"float32\"))))}}};function wV(e,t,n,a,r,s){let i=E(e,\"dy\",\"avgPool3dGrad\"),o=E(t,\"input\",\"avgPool3dGrad\"),l=i,u=o,p=!1;o.rank===4&&(p=!0,l=W(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=W(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),A(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),A(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),Tn(\"avgPool3dGrad\",r,s);let d={dy:l,input:u},c={filterSize:n,strides:a,pad:r,dimRoundingMode:s},h=P.runKernel(Rc,d,c);return p?W(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var kV=L({avgPool3dGrad_:wV}),IV={kernelName:tu,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let[a]=t,{filterSize:r,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>kV(e,a,r,s,i,o)}}};function SV(e,t,n,a,r){let s=E(e,\"dy\",\"avgPoolGrad\"),i=E(t,\"input\",\"avgPoolGrad\");A(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let o=i,l=s,u=!1;i.rank===3&&(u=!0,o=W(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=W(s,[1,s.shape[0],s.shape[1],s.shape[2]])),A(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),A(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);let p={dy:l,input:o},d={filterSize:n,strides:a,pad:r},c=P.runKernel(Dc,p,d);return u?W(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var NV=L({avgPoolGrad_:SV}),TV={kernelName:Di,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let[a]=t,{filterSize:r,strides:s,pad:i}=n;return{x:()=>NV(e,a,r,s,i)}}},CV={kernelName:Ri,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t,n)=>{let[a,r]=t,{transposeA:s,transposeB:i}=n;return!s&&!i?{a:()=>$e(e,r,!1,!0),b:()=>$e(a,e,!0,!1)}:!s&&i?{a:()=>$e(e,r,!1,!1),b:()=>$e(e,a,!0,!1)}:s&&!i?{a:()=>$e(r,e,!1,!0),b:()=>$e(a,e,!1,!1)}:{a:()=>$e(r,e,!0,!0),b:()=>$e(e,a,!0,!0)}}},EV={kernelName:nu,gradFunc:(e,t,n)=>{let{blockShape:a,crops:r}=n;return{x:()=>md(e,a,r)}}},_V={kernelName:HS,gradFunc:(e,t,n)=>{let a=n,r=a.inputShape,s=a.shape,i=Array.from(s);for(let l=r.length-1;l>=0;l--)if(r[l]===s[l])i[l]=1;else if(r[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${s}].`);let o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>fe(e,o,!0)}}},AV={kernelName:Mi,gradFunc:e=>({x:()=>e.clone()})},FV={kernelName:Oi,gradFunc:e=>({x:()=>qe(e)})},$V={kernelName:ws,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let[a]=t,{clipValueMin:r,clipValueMax:s}=n;return{x:()=>nn(_a($r(a,r),Cs(a,s)),e,qe(e))}}},DV={kernelName:Oc,inputsToSave:[\"x\"],gradFunc:s2.gradFunc},RV={kernelName:su,saveAllInputs:!0,gradFunc:(e,t,n)=>{let a=t.map(o=>o.shape),{axis:r}=n,s=Aa(r,t[0].shape)[0],i=a.map(o=>o[s]);return Ln(e,i,s).map(o=>()=>o)}},MV={kernelName:Pi,inputsToSave:[\"x\",\"filter\"],gradFunc:(e,t,n)=>{let[a,r]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=n;return A(ps(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>nw(a.shape,e,r,i,o,l),filter:()=>zw(a,e,r.shape,i,o,l)}}},OV={kernelName:Li,inputsToSave:[\"dy\",\"filter\"],gradFunc:(e,t,n)=>{let[a,r]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>$t(e,r,s,i,o,1,l),filter:()=>zw(e,a,r.shape,s,i,o,l)}}};function PV(e,t,n,a,r){let s=e;e.rank===4&&(s=W(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;i.rank===4&&(i=W(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),A(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),A(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),A(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),A(s.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`),A(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);let o={x:s,dy:i},l={strides:a,pad:r,filterShape:n};return P.runKernel(iu,o,l)}var LV=L({conv3DBackpropFilter_:PV}),zV={kernelName:zi,inputsToSave:[\"x\",\"filter\"],gradFunc:(e,t,n)=>{let{dilations:a,strides:r,pad:s}=n;A(ps(a),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);let[i,o]=t;return{x:()=>CN(i.shape,e,o,r,s),filter:()=>LV(i,e,o.shape,r,s)}}},WV={kernelName:Wi,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(yt(ef(re(n,\"float32\"))),e)}}},BV={kernelName:Bi,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(tf(re(n,\"float32\")),e)}}},VV={kernelName:Vi,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let[a]=t,{axis:r,exclusive:s,reverse:i}=n;return{x:()=>{let o=DN([r],a.rank),l=Vm(e,r,s,!i);return o!=null&&(l=De(l,o)),l}}}},UV={kernelName:Ui,inputsToSave:[\"x\",\"filter\"],gradFunc:(e,t,n)=>{let{dilations:a,strides:r,pad:s,dimRoundingMode:i}=n,o=a==null?[1,1]:a;A(ps(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[l,u]=t;return A(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),A(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),A(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),A(dr(r,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${o}'.`),Tn(\"depthwiseConv2d\",s,i),{x:()=>wT(l.shape,e,u,r,s,o,i),filter:()=>vT(l,e,u.shape,r,s,o,i)}}},GV={kernelName:Gi,inputsToSave:[\"x\",\"filter\"],gradFunc:(e,t,n)=>{let[a,r]=t,s={x:a,filter:r,dy:e},i={x:a,filter:r,dy:e};return{x:()=>P.runKernel(Dl,s,n),filter:()=>P.runKernel(Rl,i,n)}}},HV={kernelName:ji,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,a={dy:e,y:n};return{x:()=>P.runKernel(cu,a)}}},jV={kernelName:qi,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t,a=z(dn(yt(pt(n))),2/Math.sqrt(Math.PI));return{x:()=>z(e,a)}}},qV={kernelName:Ki,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,n)}}},KV={kernelName:hu,inputsToSave:[\"input\"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>W(e,n.shape)}}},XV={kernelName:Xi,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,dn(n))}}},YV={kernelName:Yi,gradFunc:e=>({x:()=>qe(e)})},ZV={kernelName:Zi,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t)=>{let[n,a]=t,r=ct(n.shape,a.shape);return{a:()=>{let s=he(e,re(a,\"float32\")),i=Bt(n.shape,r);return i.length>0?W(fe(s,i),n.shape):s},b:()=>{let s=z(e,re(n,\"float32\")),i=Bt(a.shape,r);i.length>0&&(s=W(fe(s,i),a.shape));let o=pt(a);return yt(he(s,re(o,\"float32\")))}}}},JV={kernelName:Ji,inputsToSave:[\"x\",\"mean\",\"variance\",\"scale\"],gradFunc:(e,t,n)=>{let{varianceEpsilon:a}=n,[r,s,i,o]=t,l=o==null?xe(1):o,u=Bt(s.shape,r.shape),p=[];if(s.rank===1){for(let f=0;f<r.shape.length-1;++f)p.push(r.shape[f]);p.push(1)}let d=pe(r,s),c=z(e,l),h=Jm(X(i,xe(a))),m=z(z(z(h,h),h),xe(-.5));return{x:()=>s.rank===1?W(z(z(e,On(W(h,[1,1,1,s.shape[0]]),p)),l),r.shape):W(z(z(e,h),l),r.shape),mean:()=>{let f=z(z(h,xe(-1)),c);return s.rank===1&&(f=fe(f,u)),W(f,s.shape)},variance:()=>{let f=z(z(m,d),c);return s.rank===1&&(f=fe(f,u)),W(f,s.shape)},scale:()=>{let f=z(d,h),g=z(e,f);return s.rank===1&&(g=fe(g,u)),W(g,s.shape)},offset:()=>{let f=e;return s.rank===1&&(f=fe(f,u)),W(f,s.shape)}}}},QV={kernelName:fu,inputsToSave:[\"x\",\"indices\"],gradFunc:(e,t,n)=>{let[a,r]=t,{axis:s,batchDims:i}=n,o=Aa(s,a.shape)[0],l=(u,p,d)=>()=>{let c=u.shape,h=p.size,m=c.slice(0,o),f=m.length,g=c.slice(s,c.length).slice(1),b=g.length,y=uI(0,f),x=uI(f+1,f+1+b),v=pI([m,[h],g]),I=W(d,v),N=W(p,[h]),C=pI([[f],y,x]),_=De(I,C),F=uf(_,N,u.shape[o]),D=pw(C);return F=De(F,D),F};if(i===1){let u=a.shape[0],p=a.split(u,0);return{x:()=>At(p.map((d,c)=>l(d,r.slice(c,1),e.slice(c,1))())).reshape(a.shape),indices:()=>r}}else return{x:l(a,r,e),indices:()=>r}}};function uI(e,t){let n=[];for(let a=e;a<t;++a)n.push(a);return n}function pI(e){let t=[];for(let n=0;n<e.length;++n)for(let a=0;a<e[n].length;++a)t.push(e[n][a]);return t}var eU={kernelName:Qi,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t)=>{let[n,a]=t;return{a:()=>qe(n),b:()=>qe(a)}}},tU={kernelName:eo,gradFunc:e=>({x:()=>re(e,\"float32\")})},nU={kernelName:to,gradFunc:e=>({x:()=>qe(e)})},aU={kernelName:no,gradFunc:e=>({x:()=>qe(e)})},rU={kernelName:ao,gradFunc:e=>({x:()=>qe(e)})},sU={kernelName:ro,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let[a]=t,{alpha:r}=n,s=Cn(a,0);return{x:()=>nn(s,e,z(e,r))}}},iU={kernelName:io,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>he(e,X(n,1))}}},oU={kernelName:so,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>he(e,re(n,\"float32\"))}}},lU={kernelName:qS,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a]=t,{axis:r}=n;return{logits:()=>{let s=dn(a);return pe(e,z(fe(e,r,!0),s))}}}};function uU(e,t,n,a=5,r=1,s=1,i=.5){let o={x:e,y:t,dy:n},l={depthRadius:a,bias:r,alpha:s,beta:i};return P.runKernel(Su,o,l)}var pU=L({localResponseNormalizationBackprop_:uU}),cU={kernelName:oo,inputsToSave:[\"x\"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a,r]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;return{x:()=>pU(a,r,e,s,i,o,l)}}};function i2(e,t,n,a){return t.rank<n.rank&&(t=W(t,mi(t.shape,a))),e.rank<n.rank&&(e=W(e,mi(e.shape,a))),{x:()=>z(e,re(Jn(n,t),e.dtype))}}var cI={kernelName:lo,inputsToSave:[\"x\"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let a=n,{reductionIndices:r}=a,s=t[0],i=t[1],o=Aa(r,s.shape),l=i2(e,i,s,o);return{x:()=>l.x()}}},dU={kernelName:uo,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t)=>{let[n,a]=t;return{a:()=>z(e,re($r(n,a),\"float32\")),b:()=>z(e,re(Pl(n,a),\"float32\"))}}};function hU(e,t,n,a,r,s,i){let o=E(e,\"dy\",\"maxPool3dGrad\"),l=E(t,\"input\",\"maxPool3dGrad\"),u=E(n,\"output\",\"maxPool3dGrad\"),p=o,d=l,c=u,h=!1;l.rank===4&&(h=!0,p=W(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=W(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),c=W(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),A(p.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${p.rank}.`),A(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),A(c.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${c.rank}.`),Tn(\"maxPool3dGrad\",s,i);let m={dy:p,input:d,output:c},f={filterSize:a,strides:r,pad:s,dimRoundingMode:i},g=P.runKernel(Bc,m,f);return h?W(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var mU=L({maxPool3dGrad_:hU}),fU={kernelName:Nu,inputsToSave:[\"x\"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a,r]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>mU(e,a,r,s,i,o,l)}}};function gU(e,t,n,a,r,s,i){let o=E(e,\"dy\",\"maxPoolGrad\"),l=E(t,\"input\",\"maxPoolGrad\"),u=E(n,\"output\",\"maxPoolGrad\");A(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),A(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),A(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Tn(\"maxPoolGrad\",s,i);let p={dy:o,input:l,output:u},d={filterSize:a,strides:r,pad:s,dimRoundingMode:i};return P.runKernel(Wc,p,d)}var bU=L({maxPoolGrad_:gU}),yU={kernelName:po,inputsToSave:[\"x\"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a,r]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>bU(e,a,r,s,i,o)}}},xU={kernelName:co,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let[a]=t,{axis:r}=n,s=Aa(r,a.shape),i=$N(a.shape,s)[1],o=ot(i);return{x:()=>{let l=a.shape.slice();s.forEach(p=>{l[p]=1});let u=W(e,l);return he(z(u,Pn(a.shape,\"float32\")),o)}}}},vU={kernelName:ho,inputsToSave:[\"x\"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let a=n,{axis:r}=a,[s,i]=t,o=Aa(r,s.shape),l=i2(e,i,s,o);return{x:()=>l.x()}}},wU={kernelName:mo,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t)=>{let[n,a]=t;return{a:()=>z(e,re(Cs(n,a),\"float32\")),b:()=>z(e,re(Cn(n,a),\"float32\"))}}},kU={kernelName:fo,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let a=t[0],{paddings:r}=n,s=r.map(i=>i[0]);return{x:()=>Ve(e,s,a.shape)}}},IU={kernelName:go,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t)=>{let[n,a]=t,r=ct(n.shape,a.shape);return{a:()=>{let s=Bt(n.shape,r);return s.length>0?W(fe(e,s),n.shape):e},b:()=>{let s=z(e,yt(tp(he(n,a)))),i=Bt(a.shape,r);return i.length>0?W(fe(s,i),a.shape):s}}}},SU={kernelName:bo,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t)=>{let[n,a]=t,r=ct(n.shape,a.shape);return{a:()=>{let s=z(e,re(a,\"float32\")),i=Bt(n.shape,r);return i.length>0?W(fe(s,i),n.shape):s},b:()=>{let s=z(e,re(n,\"float32\")),i=Bt(a.shape,r);return i.length>0?W(fe(s,i),a.shape):s}}}},NU={kernelName:Cu,gradFunc:e=>({x:()=>yt(e)})},TU={kernelName:yo,inputsToSave:[\"indices\"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>It(n.shape,\"float32\")}}},CU={kernelName:$u,gradFunc:e=>({x:()=>qe(e)})},EU={kernelName:Du,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:a}=n;return dt(e,a).map(r=>()=>r)}},dI={kernelName:xo,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let a=t[0],{paddings:r}=n,s=r.map(i=>i[0]);return{x:()=>Ve(e,s,a.shape)}}},_U={kernelName:vo,inputsToSave:[\"a\",\"b\"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,a,r]=t,s=n,i=a,o=ct(s.shape,i.shape);return{a:()=>{let l=re(i,\"float32\"),u=z(e,z(l,ur(s,pe(l,xe(1))))),p=Bt(s.shape,o);return p.length>0&&(u=fe(u,p)),W(u,s.shape)},b:()=>{let l=Cn(s,0),u=nn(l,Qn(s),qe(s)),p=z(e,z(r,u)),d=Bt(i.shape,o);return d.length>0&&(p=fe(p,d)),W(p,i.shape)}}}},AU={kernelName:wo,inputsToSave:[\"x\",\"alpha\"],gradFunc:(e,t)=>{let[n,a]=t,r=Cn(n,0);return{x:()=>nn(r,e,z(e,a)),alpha:()=>{let s=nn(r,qe(e),z(e,n)),i=Bt(a.shape,e.shape);return i.length>0&&(s=fe(s,i)),W(s,a.shape)}}}};function FU(e,t,n){let a=e.shape.slice();a[n]=1;let r=W(t,a),s=wc(e,n,!0,!1),i=wc(e,n,!0,!0),o=z(s,i);return z(r,o)}function $U(e,t,n){let a=e.shape.length,r=a-n.length,s=T.getAxesPermutation(n,a),i=e;s!=null&&(i=De(e,s));let o=i.shape.slice(),l=o.splice(a-n.length,n.length).reduce((d,c)=>d*c,1);o.push(l);let u=i.reshape(o),p=FU(u,t,r);if(p=p.reshape(i.shape),s!=null){let d=T.getUndoAxesPermutation(s);p=De(p,d)}return p}var DU={kernelName:ko,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let[a]=t,{axis:r}=n,s=[];return r==null?s=a.shape.map((i,o)=>o):typeof r==\"number\"?s=[r]:s=r,{x:()=>$U(a,e,s)}}},RU={kernelName:Hi,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t)=>{let[n,a]=t,r=ct(n.shape,a.shape);return{a:()=>{let s=he(e,re(a,\"float32\")),i=Bt(n.shape,r);return i.length>0?W(fe(s,i),n.shape):s},b:()=>{let s=z(e,re(n,\"float32\")),i=Bt(a.shape,r);i.length>0&&(s=W(fe(s,i),a.shape));let o=pt(a);return yt(he(s,re(o,\"float32\")))}}}},MU={kernelName:Io,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>he(e,yt(pt(n)))}}},OU={kernelName:Co,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t,a=z(Cs(n,6),jo(n));return{x:()=>z(e,re(a,\"float32\"))}}},PU={kernelName:So,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,re(jo(n),\"float32\"))}}},LU={kernelName:Ru,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>W(e,n.shape)}}},zU={kernelName:To,inputsToSave:[\"images\"],gradFunc:(e,t,n)=>{let[a]=t,r={dy:e,images:a};return{images:()=>P.runKernel(Ou,r,n)}}},WU={kernelName:No,inputsToSave:[\"images\"],gradFunc:(e,t,n)=>{let[a]=t,r={dy:e,images:a};return{images:()=>P.runKernel(Mu,r,n)}}},BU={kernelName:Eo,gradFunc:(e,t,n)=>{let{dims:a}=n,r=Aa(a,e.shape);return{x:()=>ba(e,r)}}},VU={kernelName:_o,gradFunc:e=>({x:()=>qe(e)})},UU={kernelName:Ao,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>yt(he(e,z(ur(n,1.5),2)))}}},GU={kernelName:Wu,inputsToSave:[\"condition\"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>re(qe(n),\"float32\"),t:()=>z(e,re(n,e.dtype)),e:()=>z(e,re(dd(n),e.dtype))}}},HU={kernelName:Fo,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=Cn(n,xe(0)),r=xe(n2),s=xe(a2),i=z(e,s),o=z(z(e,r),dn(re(n,\"float32\")));return nn(a,i,o)}}}},jU={kernelName:Mo,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,z(n,pe(xe(1),n)))}}},qU={kernelName:Ro,gradFunc:e=>({x:()=>qe(e)})},KU={kernelName:$o,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(od(re(n,\"float32\")),e)}}},XU={kernelName:Do,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(Bm(re(n,\"float32\")),e)}}},YU={kernelName:Bu,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let[a]=t,{begin:r,size:s}=n,i=a.shape,[o,l]=e2(a,r,s),u=[];for(let p=0;p<e.rank;p++)u.push([o[p],i[p]-o[p]-l[p]]);return{x:()=>xa(e,u)}}},ZU={kernelName:zo,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a]=t,{dim:r}=n,s=!0,i=z(e,a);return{logits:()=>pe(i,z(fe(i,[r],s),a))}}},JU={kernelName:Oo,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,ha(n))}}},hI={kernelName:Vu,gradFunc:(e,t,n)=>{let{blockShape:a,paddings:r}=n;return{x:()=>id(e,a,r)}}},mI={kernelName:Uu,gradFunc:(e,t,n)=>{let{axis:a}=n;return{x:()=>et(e,a)}}},QU={kernelName:Po,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>he(e,z(rn(re(n,\"float32\")),2))}}},eG={kernelName:qc,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,z(re(n,\"float32\"),2))}}},tG={kernelName:Wo,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t)=>{let[n,a]=t,r=xe(2);return{a:()=>z(e,z(r,pe(n,a))),b:()=>z(e,z(r,pe(a,n)))}}},nG={kernelName:Is,gradFunc:e=>({x:()=>qe(e)})},aG={kernelName:Bo,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t)=>{let[n,a]=t,r=ct(n.shape,a.shape);return{a:()=>{let s=e,i=Bt(n.shape,r);return i.length>0&&(s=fe(s,i)),W(s,n.shape)},b:()=>{let s=e,i=Bt(a.shape,r);return i.length>0&&(s=fe(s,i)),W(yt(s),a.shape)}}}},rG={kernelName:Lo,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let[a]=t,r=a.shape.slice(),{axis:s}=n;Aa(s,a.shape).forEach(l=>{r[l]=1});let i=W(e,r),o=z(i,Pn(a.shape,\"float32\"));return{x:()=>o}}},sG={kernelName:Vo,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>he(e,pt(od(n)))}}},iG={kernelName:Uo,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(pe(xe(1),pt(n)),e)}}},oG={kernelName:ks,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let[a]=t,{reps:r}=n;return{x:()=>{let s=qe(a);if(a.rank===1)for(let i=0;i<r[0];++i)s=X(s,Ve(e,[i*a.shape[0]],[a.shape[0]]));else if(a.rank===2)for(let i=0;i<r[0];++i)for(let o=0;o<r[1];++o)s=X(s,Ve(e,[i*a.shape[0],o*a.shape[1]],[a.shape[0],a.shape[1]]));else if(a.rank===3)for(let i=0;i<r[0];++i)for(let o=0;o<r[1];++o)for(let l=0;l<r[2];++l)s=X(s,Ve(e,[i*a.shape[0],o*a.shape[1],l*a.shape[2]],[a.shape[0],a.shape[1],a.shape[2]]));else if(a.rank===4)for(let i=0;i<r[0];++i)for(let o=0;o<r[1];++o)for(let l=0;l<r[2];++l)for(let u=0;u<r[3];++u)s=X(s,Ve(e,[i*a.shape[0],o*a.shape[1],l*a.shape[2],u*a.shape[3]],[a.shape[0],a.shape[1],a.shape[2],a.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${a.rank} tensors yet.`);return s}}}},lG={kernelName:Cr,gradFunc:(e,t,n)=>{let a=n,{perm:r}=a,s=pw(r);return{x:()=>De(e,s)}}},uG={kernelName:Xu,gradFunc:(e,t,n)=>{let a=n,{axis:r}=a;return{value:()=>At(e,r)}}},pG={kernelName:Qc,inputsToSave:[\"segmentIds\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>cG(e,n)}}};function cG(e,t){let n=hr(t,qe(t)),a=np(e,n),r=$r(t,xe(0,\"int32\")),s=a.rank-r.rank;for(let o=0;o<s;++o)r=Gt(r,o+1);r=_a(r,Pn(a.shape,\"bool\"));let i=qe(a);return nn(r,a,i)}var dG={kernelName:Yu,gradFunc:e=>({x:()=>qe(e)})},hG=[s2,pV,cV,dV,hV,mV,fV,gV,bV,yV,xV,vV,IV,TV,CV,EV,_V,AV,FV,$V,DV,RV,OV,MV,zV,WV,BV,VV,UV,GV,RU,HV,jV,qV,KV,XV,ZV,YV,JV,QV,eU,tU,nU,aU,rU,sU,iU,oU,lU,cU,cI,cI,dU,fU,yU,xU,vU,wU,kU,IU,SU,NU,TU,CU,EU,dI,dI,_U,AU,DU,MU,OU,PU,LU,zU,WU,BU,VU,UU,GU,HU,jU,qU,KU,XU,YU,ZU,JU,hI,hI,mI,mI,QU,tG,eG,nG,aG,rG,sG,iG,oG,lG,uG,pG,dG];for(let e of hG)KS(e);Q().prototype.abs=function(){return this.throwIfDisposed(),Lt(this)};Q().prototype.acos=function(){return this.throwIfDisposed(),Pv(this)};Q().prototype.acosh=function(){return this.throwIfDisposed(),Lv(this)};Q().prototype.add=function(e){return this.throwIfDisposed(),X(this,e)};Q().prototype.all=function(e,t){return this.throwIfDisposed(),Lm(this,e,t)};Q().prototype.any=function(e,t){return this.throwIfDisposed(),yc(this,e,t)};Q().prototype.argMax=function(e){return this.throwIfDisposed(),di(this,e)};Q().prototype.argMin=function(e){return this.throwIfDisposed(),zv(this,e)};Q().prototype.asScalar=function(){return this.throwIfDisposed(),A(this.size===1,()=>\"The array must have only 1 element.\"),W(this,[])};Q().prototype.asType=function(e){return this.throwIfDisposed(),re(this,e)};Q().prototype.as1D=function(){return this.throwIfDisposed(),W(this,[this.size])};Q().prototype.as2D=function(e,t){return this.throwIfDisposed(),W(this,[e,t])};Q().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),W(this,[e,t,n])};Q().prototype.as4D=function(e,t,n,a){return this.throwIfDisposed(),W(this,[e,t,n,a])};Q().prototype.as5D=function(e,t,n,a,r){return this.throwIfDisposed(),W(this,[e,t,n,a,r])};Q().prototype.asin=function(){return this.throwIfDisposed(),Wv(this)};Q().prototype.asinh=function(){return this.throwIfDisposed(),Bv(this)};Q().prototype.atan=function(){return this.throwIfDisposed(),Vv(this)};Q().prototype.atan2=function(e){return this.throwIfDisposed(),Uv(this,e)};Q().prototype.atanh=function(){return this.throwIfDisposed(),Gv(this)};Q().prototype.avgPool=function(e,t,n,a){return this.throwIfDisposed(),ya(this,e,t,n,a)};Q().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),id(this,e,t)};Q().prototype.batchNorm=function(e,t,n,a,r){return this.throwIfDisposed(),Ns(this,e,t,n,a,r)};Q().prototype.broadcastTo=function(e){return this.throwIfDisposed(),ai(this,e)};Q().prototype.cast=function(e){return this.throwIfDisposed(),re(this,e)};Q().prototype.ceil=function(){return this.throwIfDisposed(),Zv(this)};Q().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),an(this,e,t)};Q().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Ce&&(e=[e]),et([this,...e],t)};Q().prototype.conv1d=function(e,t,n,a,r,s){return this.throwIfDisposed(),zm(this,e,t,n,a,r,s)};Q().prototype.conv2dTranspose=function(e,t,n,a,r){return this.throwIfDisposed(),Wm(this,e,t,n,a,r)};Q().prototype.conv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),$t(this,e,t,n,a,r,s)};Q().prototype.cos=function(){return this.throwIfDisposed(),od(this)};Q().prototype.cosh=function(){return this.throwIfDisposed(),Bm(this)};Q().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),wc(this,e,t,n)};Q().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),Vm(this,e,t,n)};Q().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),sw(this,e,t)};Q().prototype.depthwiseConv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),Ts(this,e,t,n,a,r,s)};Q().prototype.dilation2d=function(e,t,n,a,r){return this.throwIfDisposed(),iw(this,e,t,n,a,r)};Q().prototype.divNoNan=function(e){return this.throwIfDisposed(),ow(this,e)};Q().prototype.div=function(e){return this.throwIfDisposed(),he(this,e)};Q().prototype.dot=function(e){return this.throwIfDisposed(),lw(this,e)};Q().prototype.elu=function(){return this.throwIfDisposed(),Qu(this)};Q().prototype.equal=function(e){return this.throwIfDisposed(),Jn(this,e)};Q().prototype.erf=function(){return this.throwIfDisposed(),Um(this)};Q().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),cw(this,e,t)};Q().prototype.exp=function(){return this.throwIfDisposed(),dn(this)};Q().prototype.expandDims=function(e){return this.throwIfDisposed(),Gt(this,e)};Q().prototype.expm1=function(){return this.throwIfDisposed(),dw(this)};Q().prototype.fft=function(){return this.throwIfDisposed(),bd(this)};Q().prototype.flatten=function(){return this.throwIfDisposed(),W(this,[this.size])};Q().prototype.floor=function(){return this.throwIfDisposed(),tp(this)};Q().prototype.floorDiv=function(e){return this.throwIfDisposed(),Pm(this,e)};Q().prototype.gather=function(e,t,n){return this.throwIfDisposed(),np(this,e,t,n)};Q().prototype.greaterEqual=function(e){return this.throwIfDisposed(),$r(this,e)};Q().prototype.greater=function(e){return this.throwIfDisposed(),Cn(this,e)};Q().prototype.ifft=function(){return this.throwIfDisposed(),Bl(this)};Q().prototype.irfft=function(){return this.throwIfDisposed(),af(this)};Q().prototype.isFinite=function(){return this.throwIfDisposed(),hw(this)};Q().prototype.isInf=function(){return this.throwIfDisposed(),mw(this)};Q().prototype.isNaN=function(){return this.throwIfDisposed(),fw(this)};Q().prototype.leakyRelu=function(e){return this.throwIfDisposed(),ud(this,e)};Q().prototype.lessEqual=function(e){return this.throwIfDisposed(),Cs(this,e)};Q().prototype.less=function(e){return this.throwIfDisposed(),Pl(this,e)};Q().prototype.localResponseNormalization=function(e,t,n,a){return this.throwIfDisposed(),gw(this,e,t,n,a)};Q().prototype.logSigmoid=function(){return this.throwIfDisposed(),bw(this)};Q().prototype.logSoftmax=function(e){return this.throwIfDisposed(),jm(this,e)};Q().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),cd(this,e,t)};Q().prototype.log=function(){return this.throwIfDisposed(),Qn(this)};Q().prototype.log1p=function(){return this.throwIfDisposed(),pd(this)};Q().prototype.logicalAnd=function(e){return this.throwIfDisposed(),_a(this,e)};Q().prototype.logicalNot=function(){return this.throwIfDisposed(),dd(this)};Q().prototype.logicalOr=function(e){return this.throwIfDisposed(),qm(this,e)};Q().prototype.logicalXor=function(e){return this.throwIfDisposed(),yw(this,e)};Q().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),$e(this,e,t,n)};Q().prototype.maxPool=function(e,t,n,a){return this.throwIfDisposed(),Dt(this,e,t,n,a)};Q().prototype.max=function(e,t){return this.throwIfDisposed(),ma(this,e,t)};Q().prototype.maximum=function(e){return this.throwIfDisposed(),hr(this,e)};Q().prototype.mean=function(e,t){return this.throwIfDisposed(),Ct(this,e,t)};Q().prototype.min=function(e,t){return this.throwIfDisposed(),Ol(this,e,t)};Q().prototype.minimum=function(e){return this.throwIfDisposed(),ds(this,e)};Q().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),vw(this,e,t)};Q().prototype.mod=function(e){return this.throwIfDisposed(),ww(this,e)};Q().prototype.mul=function(e){return this.throwIfDisposed(),z(this,e)};Q().prototype.neg=function(){return this.throwIfDisposed(),yt(this)};Q().prototype.norm=function(e,t,n){return this.throwIfDisposed(),ep(this,e,t,n)};Q().prototype.notEqual=function(e){return this.throwIfDisposed(),fi(this,e)};Q().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),Ll(this,e,t,n)};Q().prototype.onesLike=function(){return this.throwIfDisposed(),ea(this)};Q().prototype.pad=function(e,t){return this.throwIfDisposed(),xa(this,e,t)};Q().prototype.pool=function(e,t,n,a,r,s){return this.throwIfDisposed(),kw(this,e,t,n,a,r,s)};Q().prototype.pow=function(e){return this.throwIfDisposed(),ur(this,e)};Q().prototype.prelu=function(e){return this.throwIfDisposed(),fd(this,e)};Q().prototype.prod=function(e,t){return this.throwIfDisposed(),Iw(this,e,t)};Q().prototype.reciprocal=function(){return this.throwIfDisposed(),Ew(this)};Q().prototype.relu=function(){return this.throwIfDisposed(),Ke(this)};Q().prototype.relu6=function(){return this.throwIfDisposed(),Ym(this)};Q().prototype.reshapeAs=function(e){return this.throwIfDisposed(),W(this,e.shape)};Q().prototype.reshape=function(e){return this.throwIfDisposed(),W(this,e)};Q().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),CT(this,e,t,n)};Q().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),ET(this,e,t,n)};Q().prototype.reverse=function(e){return this.throwIfDisposed(),ba(this,e)};Q().prototype.rfft=function(){return this.throwIfDisposed(),yd(this)};Q().prototype.round=function(){return this.throwIfDisposed(),Zm(this)};Q().prototype.rsqrt=function(){return this.throwIfDisposed(),Jm(this)};Q().prototype.selu=function(){return this.throwIfDisposed(),Qm(this)};Q().prototype.separableConv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),_s(this,e,t,n,a,r,s)};Q().prototype.sigmoid=function(){return this.throwIfDisposed(),ha(this)};Q().prototype.sign=function(){return this.throwIfDisposed(),_w(this)};Q().prototype.sin=function(){return this.throwIfDisposed(),ef(this)};Q().prototype.sinh=function(){return this.throwIfDisposed(),tf(this)};Q().prototype.slice=function(e,t){return this.throwIfDisposed(),Ve(this,e,t)};Q().prototype.softmax=function(e){return this.throwIfDisposed(),qa(this,e)};Q().prototype.softplus=function(){return this.throwIfDisposed(),Go(this)};Q().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),md(this,e,t)};Q().prototype.split=function(e,t){return this.throwIfDisposed(),Ln(this,e,t)};Q().prototype.sqrt=function(){return this.throwIfDisposed(),rn(this)};Q().prototype.square=function(){return this.throwIfDisposed(),pt(this)};Q().prototype.squaredDifference=function(e){return this.throwIfDisposed(),rf(this,e)};Q().prototype.squeeze=function(e){return this.throwIfDisposed(),As(this,e)};Q().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof Ce?[this,e]:[this,...e];return At(n,t)};Q().prototype.step=function(e){return this.throwIfDisposed(),jo(this,e)};Q().prototype.stridedSlice=function(e,t,n,a,r,s,i,o){return this.throwIfDisposed(),Aw(this,e,t,n,a,r,s,i,o)};Q().prototype.sub=function(e){return this.throwIfDisposed(),pe(this,e)};Q().prototype.sum=function(e,t){return this.throwIfDisposed(),fe(this,e,t)};Q().prototype.tan=function(){return this.throwIfDisposed(),Fw(this)};Q().prototype.tanh=function(){return this.throwIfDisposed(),cs(this)};Q().prototype.tile=function(e){return this.throwIfDisposed(),On(this,e)};Q().prototype.toBool=function(){return this.throwIfDisposed(),re(this,\"bool\")};Q().prototype.toFloat=function(){return this.throwIfDisposed(),re(this,\"float32\")};Q().prototype.toInt=function(){return this.throwIfDisposed(),re(this,\"int32\")};Q().prototype.topk=function(e,t){return this.throwIfDisposed(),Dw(this,e,t)};Q().prototype.transpose=function(e){return this.throwIfDisposed(),De(this,e)};Q().prototype.unique=function(e){return this.throwIfDisposed(),Rw(this,e)};Q().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),uf(this,e,t)};Q().prototype.unstack=function(e){return this.throwIfDisposed(),dt(this,e)};Q().prototype.where=function(e,t){return this.throwIfDisposed(),nn(e,this,t)};Q().prototype.zerosLike=function(){return this.throwIfDisposed(),qe(this)};var Xr=class o2 extends Error{constructor(t){super(t),Object.setPrototypeOf(this,o2.prototype)}},ar=class l2 extends Error{constructor(t){super(t),Object.setPrototypeOf(this,l2.prototype)}},V=class u2 extends Error{constructor(t){super(t),Object.setPrototypeOf(this,u2.prototype)}},ze=class p2 extends Error{constructor(t){super(t),Object.setPrototypeOf(this,p2.prototype)}},mG=class c2 extends Error{constructor(t){super(t),Object.setPrototypeOf(this,c2.prototype)}},d2=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=e}};function bi(e,t){if(Array.isArray(e)){let n=[];for(let a=0;a<t;a++)n=n.concat(e);return n}else{let n=new Array(t);return n.fill(e),n}}function tr(e,t){if(!e)throw new mG(t)}function fI(e,t){let n=0;for(let a of e)a===t&&n++;return n}function Mn(e){return e.length===1?e[0]:e}function it(e){return Array.isArray(e)?e:[e]}function Ir(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,\"$1_$2\").replace(/([a-z])([A-Z])/g,\"$1_$2\").toLowerCase();return t[0]!==\"_\"?t:\"private\"+t}function Js(e){return e.length<=1||e.indexOf(\"_\")===-1?e:e.replace(/[_]+(\\w|$)/g,(t,n)=>n.toUpperCase())}var Sa={};function Qw(e){if(e==null)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function zx(e){if(!(e==null||typeof e!=\"object\"))if(Array.isArray(e))e.forEach(t=>zx(t));else{let t=Object.keys(e);for(let n of t){let a=e[n];a!=null&&typeof a==\"object\"&&(!Array.isArray(a)&&a.type===\"ndarray\"&&typeof a.value==\"number\"?e[n]=a.value:zx(a))}}}function vd(e,t={},n={},a=\"object\",r=!1){if(typeof e==\"string\"){let s=e,i;if(s in n)i=n[s];else if(s in Sa)i=Sa[s];else if(i=t[s],i==null)throw new V(`Unknown ${a}: ${e}. This may be due to one of the following reasons:\n1. The ${a} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${a} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let s=e;if(s.className==null||s.config==null)throw new V(`${a}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);let i=s.className,o,l;if(i in n?[o,l]=n[i]:i in Sa?[o,l]=Sa.className:i in t&&([o,l]=t[i]),o==null)throw new V(`Unknown ${a}: ${i}. This may be due to one of the following reasons:\n1. The ${a} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${a} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let u={};for(let h of Object.keys(Sa))u[h]=Sa[h];for(let h of Object.keys(n))u[h]=n[h];let p=s.config;p.customObjects=u;let d=Object.assign({},Sa);for(let h of Object.keys(n))Sa[h]=n[h];zx(s.config);let c=l(o,s.config,n,r);return Sa=Object.assign({},d),c}else{let u=Object.assign({},Sa);for(let d of Object.keys(n))Sa[d]=n[d];let p=new o(s.config);return Sa=Object.assign({},u),p}}}function fG(e,t){return e<t?-1:e>t?1:0}function wh(e,t){return-1*fG(e,t)}function as(e){if(e==null)return e;let t=[];for(let n of e)t.indexOf(n)===-1&&t.push(n);return t}function gG(e){if(e==null)throw new V(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function Ko(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new V(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function e0(e,t,n=0,a=1/0){return tr(n>=0),tr(a>=n),Array.isArray(e)&&e.length>=n&&e.length<=a&&e.every(r=>typeof r===t)}function tn(e,t){Array.isArray(e)?(w.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,a)=>tn(n,`element ${a+1} of ${t}`))):w.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${h2(e)}.`)}function h2(e){return e===null?\"null\":Array.isArray(e)?\"[\"+e.map(t=>h2(t)).join(\",\")+\"]\":typeof e==\"string\"?`\"${e}\"`:`${e}`}function bG(e,t,n){let a=n!=null?n():w.now(),r;return(...s)=>{let i=n!=null?n():w.now();return i-a<t||(a=i,r=e(...s)),r}}function m2(e){return e===\"relu\"?\"relu\":e===\"linear\"?\"linear\":e===\"elu\"?\"elu\":null}var yG=0;function f2(){return yG++}var kh={};function gf(e=\"\"){return e in kh||(kh[e]=0),kh[e]+=1,e+kh[e].toString()}var xG=[\"channelsFirst\",\"channelsLast\"],vG=[\"nearest\",\"bilinear\"],wG=[\"valid\",\"same\",\"causal\"],kG=[\"max\",\"avg\"],IG=[\"sum\",\"mul\",\"concat\",\"ave\"],kl=new Map;function Rt(e){Ko(xG,\"DataFormat\",e)}function SG(e){Ko(vG,\"InterpolationFormat\",e)}function va(e){Ko(wG,\"PaddingMode\",e)}function g2(e){Ko(kG,\"PoolMode\",e)}var pc=[],gI=\"/\";function ri(e,t){pc.push(e);try{let n=t();return pc.pop(),n}catch(n){throw pc.pop(),n}}function NG(){return pc.length===0?\"\":pc.join(gI)+gI}function b2(e){if(!x2(e))throw new Error(\"Not a valid tensor name: '\"+e+\"'\");return NG()+e}function y2(e){if(!x2(e))throw new Error(\"Not a valid tensor name: '\"+e+\"'\");kl.has(e)||kl.set(e,0);let t=kl.get(e);if(kl.set(e,kl.get(e)+1),t>0){let n=`${e}_${t}`;return kl.set(n,1),n}else return e}var TG=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\\._\\/]*$/);function x2(e){return!!e.match(TG)}function CG(e){return e===parseInt(e.toString(),10)}function rs(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let a=1;for(let r=t;r<n;++r)a*=e[r];return a}function Ul(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let a=e[n];a<t&&(t=a)}return t}function hs(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let a=e[n];a>t&&(t=a)}return t}function Ua(e,t){if(t<e)throw new V(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let a=e;a<t;++a)n.push(a);return n}var px;function qt(){return px==null&&(px=Dv().epsilon()),px}function Ga(){return\"channelsLast\"}function ir(e,t){return re(e,t)}function wd(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),W(e,n)}function EG(e,t){return O(()=>{if(e.shape.length!==2)throw new V(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=wd(e,1);return Wx(n,[1,t,1])})}function _G(e){let t=[rs(e.shape)];return W(e,t)}function AG(e){if(e.rank<=1)throw new V(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],rs(e.shape,1)];return W(e,t)}function si(e,t,n){return O(()=>{switch(e.rank){case 1:return gd(e,t,n);case 2:return nf(e,[t,0],[n,e.shape[1]]);case 3:return Ho(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Wl(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Ve(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Ve(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new V(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function cx(e,t,n){return O(()=>{switch(e.rank){case 1:return gd(e,t,n);case 2:return nf(e,[0,t],[e.shape[0],n]);case 3:return Ho(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Wl(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new V(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Ih(e,t,n,a){return O(()=>{switch(e.rank){case 1:return gd(e,t,n);case 2:switch(a){case 1:return si(e,t,n);case 2:return cx(e,t,n);default:throw new V(`The axis is not within the rank of the tensor ${a}`)}case 3:switch(a){case 1:return si(e,t,n);case 2:return Ho(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return cx(e,t,n);default:throw new V(`The axis is not within the rank of the tensor ${a}`)}case 4:switch(a){case 1:return si(e,t,n);case 2:return Wl(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Wl(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return cx(e,t,n);default:throw new V(`The axis is not within the rank of the tensor ${a}`)}default:throw new V(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function t0(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),et(e,t)}function bI(e,t){switch(e.rank){case 1:return Jv([e,t]);case 2:return Qv([e,t],0);case 3:return ew([e,t],0);case 4:return tw([e,t],0);default:throw new V(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function Wx(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new V(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return On(e,t)}function bf(e,t=0,n=1,a,r){return Xm(e,t,n,a,r)}function or(e,t,n,a){if(e.rank<2||t.rank<2)throw new ze(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let r=e.shape.slice(-1)[0],s=t.shape.slice(-2)[0];if(r!==s)throw new ze(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return Vl.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?Bx(e.rank,a,Ga()):null,activation:n});{let r=e.shape.slice(),s=r.pop();e=W(e,[-1,s]);let i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],p=Array.from({length:t.rank},(c,h)=>h===0?t.rank-2:h<=t.rank-2?h-1:h);t=W(De(t,p),[l,-1]);let d=[...r,...u];return W(Vl.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?Bx(e.rank,a,Ga()):null,activation:n}),d)}}function v2(e,t,n){return O(()=>(Array.isArray(t)?t=je(t,\"int32\"):t=re(t,\"int32\"),np(e,t,n)))}function kd(e){return z(e,e)}function Bx(e,t,n){let a=t.shape;if(t.rank!==1&&t.rank!==e)throw new V(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n===\"channelsFirst\")return a.length===1?W(t,[1,a[0],1,1,1]):W(t,[1,a[3],a[0],a[1],a[2]]);if(n===\"channelsLast\")return a.length===1?W(t,[1,1,1,1,a[0]]):W(t,[1].concat(a))}else if(e===4){if(n===\"channelsFirst\")return a.length===1?W(t,[1,a[0],1,1]):W(t,[1,a[2],a[0],a[1]]);if(n===\"channelsLast\")return a.length===1?W(t,[1,1,1,a[0]]):W(t,[1].concat(a))}else if(e===3){if(n===\"channelsFirst\")return a.length===1?W(t,[1,a[0],1]):W(t,[1,a[1],a[0]]);if(n===\"channelsLast\")return a.length===1?W(t,[1,1,a[0]]):W(t,[1].concat(a))}else if(e<3)return t;throw new V(`Unsupported input rank by biasAdd: ${t.rank}`)}function Ka(e,t,n){return O(()=>(n==null&&(n=Ga()),Rt(n),X(e,Bx(e.rank,t,n))))}function FG(e,t=1){if(t!==1)throw new ze(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Qu(e)}function $G(e){return O(()=>he(e,X(Lt(e),1)))}function w2(e,t,n,a){return O(()=>Pw(e,t,n,a))}function DG(e){return O(()=>{let t=X(.5,z(.2,e));return an(t,0,1)})}function Id(e,t,n=!1){return n?e():t()}var RG=[\"fanIn\",\"fanOut\",\"fanAvg\"],MG=[\"normal\",\"uniform\",\"truncatedNormal\"];function OG(e){Ko(RG,\"FanMode\",e)}function PG(e){Ko(MG,\"Distribution\",e)}var $a=class extends ne.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},n0=class extends $a{apply(e,t){return It(e,t)}};n0.className=\"Zeros\";ne.registerClass(n0);var yf=class extends $a{apply(e,t){return Pn(e,t)}};yf.className=\"Ones\";ne.registerClass(yf);var a0=class extends $a{constructor(e){if(super(),typeof e!=\"object\")throw new V(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new V(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return O(()=>z(xe(this.value),Pn(e,t)))}getConfig(){return{value:this.value}}};a0.className=\"Constant\";ne.registerClass(a0);var r0=class extends $a{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Es(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};r0.className=\"RandomUniform\";ne.registerClass(r0);var s0=class extends $a{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||\"float32\",t!==\"float32\"&&t!==\"int32\")throw new ze(`randomNormal does not support dType ${t}.`);return bf(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};s0.className=\"RandomNormal\";ne.registerClass(s0);var i0=class extends $a{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||\"float32\",t!==\"float32\"&&t!==\"int32\")throw new ze(`truncatedNormal does not support dType ${t}.`);return lf(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};i0.className=\"TruncatedNormal\";ne.registerClass(i0);var o0=class extends $a{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return O(()=>{if(e.length!==2||e[0]!==e[1])throw new V(\"Identity matrix initializer can only be used for 2D square matrices.\");return z(this.gain,Gm(e[0]))})}getConfig(){return{gain:this.gain}}};o0.className=\"Identity\";ne.registerClass(o0);function LG(e,t=\"channelsLast\"){let n,a;if(Rt(t),e.length===2)n=e[0],a=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t===\"channelsFirst\"){let r=rs(e,2);n=e[1]*r,a=e[0]*r}else if(t===\"channelsLast\"){let r=rs(e,0,e.length-2);n=e[e.length-2]*r,a=e[e.length-1]*r}}else{let r=rs(e);n=Math.sqrt(r),a=Math.sqrt(r)}return[n,a]}var Bn=class extends $a{constructor(e){if(super(),e.scale<0)throw new V(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?\"fanIn\":e.mode,OG(this.mode),this.distribution=e.distribution==null?\"normal\":e.distribution,PG(this.distribution),this.seed=e.seed}apply(e,t){let n=LG(e),a=n[0],r=n[1],s=this.scale;if(this.mode===\"fanIn\"?s/=Math.max(1,a):this.mode===\"fanOut\"?s/=Math.max(1,r):s/=Math.max(1,(a+r)/2),this.distribution===\"normal\"){let i=Math.sqrt(s);if(t=t||\"float32\",t!==\"float32\"&&t!==\"int32\")throw new ze(`${this.getClassName()} does not support dType ${t}.`);return lf(e,0,i,t,this.seed)}else{let i=Math.sqrt(3*s);return Es(e,-i,i,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};Bn.className=\"VarianceScaling\";ne.registerClass(Bn);var xf=class extends Bn{constructor(e){super({scale:1,mode:\"fanAvg\",distribution:\"uniform\",seed:e==null?null:e.seed})}getClassName(){return Bn.className}};xf.className=\"GlorotUniform\";ne.registerClass(xf);var vf=class extends Bn{constructor(e){super({scale:1,mode:\"fanAvg\",distribution:\"normal\",seed:e==null?null:e.seed})}getClassName(){return Bn.className}};vf.className=\"GlorotNormal\";ne.registerClass(vf);var wf=class extends Bn{constructor(e){super({scale:2,mode:\"fanIn\",distribution:\"normal\",seed:e==null?null:e.seed})}getClassName(){return Bn.className}};wf.className=\"HeNormal\";ne.registerClass(wf);var kf=class extends Bn{constructor(e){super({scale:2,mode:\"fanIn\",distribution:\"uniform\",seed:e==null?null:e.seed})}getClassName(){return Bn.className}};kf.className=\"HeUniform\";ne.registerClass(kf);var If=class extends Bn{constructor(e){super({scale:1,mode:\"fanIn\",distribution:\"normal\",seed:e==null?null:e.seed})}getClassName(){return Bn.className}};If.className=\"LeCunNormal\";ne.registerClass(If);var Sf=class extends Bn{constructor(e){super({scale:1,mode:\"fanIn\",distribution:\"uniform\",seed:e==null?null:e.seed})}getClassName(){return Bn.className}};Sf.className=\"LeCunUniform\";ne.registerClass(Sf);var l0=class extends $a{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return O(()=>{if(e.length<2)throw new ze(\"Shape must be at least 2D.\");if(t!==\"int32\"&&t!==\"float32\"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;let n=w.sizeFromShape(e.slice(0,-1)),a=e[e.length-1],r=n*a;r>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${r}) elements: Slowness may result.`);let s=[Math.max(a,n),Math.min(a,n)],i=bf(s,0,1,t,this.seed),o=Bw.qr(i,!1),l=o[0],u=o[1].flatten().stridedSlice([0],[Math.min(a,n)*Math.min(a,n)],[Math.min(a,n)+1]);return l=z(l,u.sign()),n<a&&(l=l.transpose()),z(xe(this.gain),l.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}};l0.className=\"Orthogonal\";ne.registerClass(l0);var yI={constant:\"Constant\",glorotNormal:\"GlorotNormal\",glorotUniform:\"GlorotUniform\",heNormal:\"HeNormal\",heUniform:\"HeUniform\",identity:\"Identity\",leCunNormal:\"LeCunNormal\",leCunUniform:\"LeCunUniform\",ones:\"Ones\",orthogonal:\"Orthogonal\",randomNormal:\"RandomNormal\",randomUniform:\"RandomUniform\",truncatedNormal:\"TruncatedNormal\",varianceScaling:\"VarianceScaling\",zeros:\"Zeros\"};function xI(e,t={}){return vd(e,ne.SerializationMap.getMap().classNameMap,t,\"initializer\")}function Et(e){return Qw(e)}function St(e){if(typeof e==\"string\"){let t=e in yI?yI[e]:e;if(t===\"GlorotNormal\")return new vf;if(t===\"GlorotUniform\")return new xf;if(t===\"HeNormal\")return new wf;if(t===\"HeUniform\")return new kf;if(t===\"LeCunNormal\")return new If;if(t===\"LeCunUniform\")return new Sf;{let n={};return n.className=t,n.config={},xI(n)}}else return e instanceof $a?e:xI(e)}function Vx(e){return Array.isArray(e)&&Array.isArray(e[0])}function Zh(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function Te(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new V(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function Je(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new V(`Expected exactly 1 Shape; got ${e.length}`)}else return e}function Jh(e){let t=0;for(let n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((a,r)=>a*r);return t}var vI=\"Variable\",k2=class{constructor(e,t=\"float32\",n=vI,a=!0,r=null){this.dtype=t==null?\"float32\":t,this.shape=e.shape,this.id=f2(),n=n==null?vI:n,this.originalName=b2(n),this.name=y2(this.originalName),this.trainable_=a,this.constraint=r,this.val=Mw(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),zG(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function zG(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error(\"Shape mismatch: \"+JSON.stringify(e.shape)+\" vs. \"+JSON.stringify(t.shape))}function Ux(e){return e.map(t=>t.read())}function u0(e){e.forEach(t=>{t[0].write(t[1])})}var zt=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},Ha=class{constructor(e,t,n,a,r,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=a,this.callArgs=r,this.outputTensorIndex=i,this.id=f2(),s!=null&&(this.originalName=b2(s),this.name=y2(this.originalName)),this.rank=t.length}},WG=0,Nf=class{constructor(e,t){this.callArgs=t,this.id=WG++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n!=null&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},BG=0,We=class extends ne.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=BG++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=Ir(n)+\"_\"+gf(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let r=null;e.batchSize!=null&&(r=e.batchSize),n=[r].concat(e.inputShape)}this.batchInputShape=n;let a=e.dtype;a==null&&(a=e.inputDType),a==null&&(a=\"float32\"),this.dtype=a}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+\"_ib-\"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new ar(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new V(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Mn(this.getNodeAtIndex(e,\"input\").inputTensors)}getOutputAt(e){return Mn(this.getNodeAtIndex(e,\"output\").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Xr(`Layer ${this.name} has multiple inbound nodes, hence the notion of \"layer input\" is ill-defined. Use \\`getInputAt(nodeIndex)\\` instead.`);if(this.inboundNodes.length===0)throw new Xr(`Layer ${this.name} is not connected, no input to return.`);return Mn(this.getNodeAtIndex(0,\"input\").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Xr(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Xr(`Layer ${this.name} has multiple inbound nodes, hence the notion of \"layer output\" is ill-defined. Use \\`getOutputAt(nodeIndex)\\` instead.`);return Mn(this.getNodeAtIndex(0,\"output\").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error(\"Cannot call the resetStates() method of a non-stateful Layer object.\")}assertInputCompatibility(e){let t=it(e);if(this.inputSpec==null||this.inputSpec.length===0)return;let n=it(this.inputSpec);if(t.length!==n.length)throw new V(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let a=0;a<t.length;a++){let r=t[a],s=n[a];if(s==null)continue;let i=r.rank;if(s.ndim!=null&&i!==s.ndim)throw new V(`Input ${a} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${i}`);if(s.maxNDim!=null&&i>s.maxNDim)throw new V(`Input ${a} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${i}`);if(s.minNDim!=null&&i<s.minNDim)throw new V(`Input ${a} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${i}.`);if(s.dtype!=null&&r.dtype!==s.dtype)throw new V(`Input ${a} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){let o=r.shape;for(let l in s.axes){let u=Number(l),p=s.axes[l],d=u>=0?o[u]:o[o.length+u];if(p!=null&&[p,null].indexOf(d)===-1)throw new V(`Input ${a} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${p} but got shape ${o}.`)}}if(s.shape!=null)for(let o=0;o<s.shape.length;++o){let l=s.shape[o],u=r.shape[o];if(l!=null&&u!=null&&l!==u)throw new V(`Input ${a} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=it(e),a=GG(e),r=HG(e);if(a===r)throw new V(\"Arguments to apply() must be all SymbolicTensors or all Tensors\");return ri(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let s=[];for(let i of it(e))s.push(i.shape);this.build(Mn(s)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let s=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,s);let i=it(s),o=[];for(let l of i)n.indexOf(l)!==-1&&(l=l.clone()),o.push(l);if(s=Mn(o),this.activityRegularizer!=null)throw new ze(\"Layer invocation in the presence of activity regularizer(s) is not supported yet.\");return s}else{let s=VG(e),i=this.computeOutputShape(s),o,l=UG(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?s[0]:s),i!=null&&i.length>0&&Array.isArray(i[0])?o=i.map((u,p)=>new Ha(l,u,this,it(e),t,this.name,p)):o=new Ha(l,i,this,it(e),t,this.name),this.addInboundNode(e,o,null,null,s,i,t),this._refCount++,this.activityRegularizer!=null)throw new ze(\"Layer invocation in the presence of activity regularizer(s) is not supported yet.\");return o}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,a)=>{n!=null&&e[a]!=null&&e[a]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Xr(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new Xr(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of \"output shape\" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new ar(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Jh(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Ux(e?this.trainableWeights:this.weights)}setWeights(e){O(()=>{let t=this.weights;if(t.length!==e.length)throw new V(`You called setWeights(weights) on layer \"${this.name}\" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],a=Ux(t);for(let r=0;r<a.length;++r){let s=a[r],i=t[r],o=e[r];if(!w.arraysEqual(s.shape,o.shape))throw new V(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}u0(n)})}addWeight(e,t,n,a,r,s,i,o){if(this._addedWeightNames.indexOf(e)!==-1)throw new V(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n=\"float32\"),this.fastWeightInitDuringBuild&&(a=o!=null?o():St(\"zeros\"));let l=a.apply(t,n),u=new k2(l,n,e,s,i);return l.dispose(),r!=null&&this.addLoss(()=>r.apply(u.read())),s==null&&(s=!0),s?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=it(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;let a=this.computeMask(e,n),r=it(t),s=it(a);if(r.length!==s.length)throw new Error(`${this.name} outputs ${r.length} tensors but ${r.length} masks for those tensors`);for(let i=0;i<r.length;i++)r[i].kerasMask=s[i]}addInboundNode(e,t,n,a,r,s,i=null){let o=it(e);t=it(t),n=it(n),a=it(a),r=Zh(r),s=Zh(s);let l=[],u=[],p=[];for(let d of o)l.push(d.sourceLayer),u.push(d.nodeIndex),p.push(d.tensorIndex);new Nf({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:p,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:a,inputShapes:r,outputShapes:s},i);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function VG(e){e=it(e);let t=[];for(let n of e)t.push(n.shape);return Mn(t)}function UG(e){return\"float32\"}function I2(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{let a=t.inboundNodes[n];if(a.inboundLayers.length===0)return a.inputTensors;{let r=[];for(let s=0;s<a.inboundLayers.length;s++){let i=a.inputTensors[s],o=a.inboundLayers[s],l=a.nodeIndices[s],u=I2(i,o,l);for(let p of u)r.indexOf(p)===-1&&r.push(p)}return r}}}function GG(e){let t=!0;for(let n of it(e))if(!(n instanceof Ha)){t=!1;break}return t}function HG(e){let t=!0;for(let n of it(e))if(n instanceof Ha){t=!1;break}return t}var rp=class extends We{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:gf(\"input\").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new V(\"Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.\");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new V(\"An InputLayer should be passed either a `batchInputShape` or an `inputShape`.\");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new V(\"Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.\");let n=e.dtype||\"float32\";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let a=new Ha(this.dtype,this.batchInputShape,this,[],{},this.name);a.nodeIndex=0,a.tensorIndex=0,new Nf({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new V(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};rp.className=\"InputLayer\";ne.registerClass(rp);function S2(e){if(e.batchShape==null&&e.shape==null)throw new Error(\"Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.\");if(e.batchShape!=null&&e.shape!=null)throw new V(\"Please provide either a `shape` or `batchShape` argument to Input, but not both.\");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n=\"float32\"),new rp({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function jG(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return re(t,e.dtype)}catch(n){throw new V(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}var Cl=class N2{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof N2)for(let n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(t==null)return;for(let n of t)this.add(n.key,n.value)}}add(t,n,a){if(this.id2Value[t.id]==null)this.id2Value[t.id]=jG(t,n),this.name2Id[t.name]=t.id,a!=null&&(this.id2Mask[t.id]=a);else throw new V(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Ha){if(this.id2Value[t.id]==null)throw new V(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let n=this.name2Id[t];if(n==null)throw new V(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof Ha){if(this.id2Value[t.id]==null)throw new V(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let n=this.name2Id[t];if(n==null)throw new V(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&Ee(this.id2Mask)}},Qh=new d2,em=new d2;function qG(e){Qh!=null&&Qh.setMaxEntries(e),em!=null&&em.setMaxEntries(e)}function tc(e,t,n,a){let r=n==null?!1:n.training,s=Array.isArray(e),i=s?e:[e],o=i.map(m=>m.name),l=[],u=t.names();for(let m of o)u.indexOf(m)!==-1?l.push(t.getValue(m)):l.push(null);a!=null&&(a.maxNumTensors=-1/0,a.minNumTensors=1/0);let p=o.join(\",\")+\"|\"+t.names().sort().join(\",\"),d=Qh.get(p),c;if(d==null){let m=KG(i,t);d=m.sorted,c=m.recipientCounts,Qh.put(p,d),em.put(p,c)}c={},r||Object.assign(c,em.get(p));let h=new Cl(t);for(let m=0;m<d.length;++m){if(a!=null){let F=Kh().numTensors;F>a.maxNumTensors&&(a.maxNumTensors=F),F<a.minNumTensors&&(a.minNumTensors=F)}let f=d[m],g=f.sourceLayer;if(g instanceof rp)continue;let b=[],y=[],x=[],v=!1;for(let F of f.inputs){let D=h.getValue(F),$=h.getMask(F);b.push(D),y.push($),$!=null&&(v=!0),r||(c[F.name]--,c[F.name]===0&&!t.hasKey(F)&&o.indexOf(F.name)===-1&&!D.isDisposed&&F.sourceLayer.stateful!==!0&&x.push(D))}v&&(n=n||{},n.mask=y[0]);let I=it(g.apply(b,n)),N=null;g.supportsMasking&&(N=g.computeMask(b,y));let C=YG(f),_=Array.isArray(C)?C:[C];for(let F=0;F<_.length;++F){h.hasKey(_[F])||h.add(_[F],I[F],Array.isArray(N)?N[0]:N);let D=o.indexOf(_[F].name);D!==-1&&(l[D]=I[F])}r||Ee(x)}return h.disposeMasks(),s?l:l[0]}function KG(e,t){w.assert(e!=null&&e.length>0,()=>\"Expected at least one fetch, got none\");let n=[],a={};if(e.length===1){let r=wI(e[0],t);n=r.sorted,a=r.recipientMap}else{let r=new Set;for(let s of e){let{sorted:i,recipientMap:o}=wI(s,t);for(let l of i)r.has(l.name)||(n.push(l),r.add(l.name));for(let l in o)a[l]==null&&(a[l]=new Set),o[l].forEach(u=>a[l].add(u))}}return{sorted:n,recipientCounts:XG(a)}}function XG(e){let t={};for(let n in e)t[n]=e[n].size;return t}function wI(e,t){let n=new Set,a=[],r={};for(let o of t.names())n.add(o);let s=[],i=[];for(s.push(e);s.length>0;){let o=s[s.length-1];if(n.has(o.name)){s.pop();continue}let l=i[i.length-1]===s.length-1;if(o.inputs.length===0||l)s.pop(),a.push(o),n.add(o.name),l&&i.pop();else{i.push(s.length-1);for(let u of o.inputs)r[u.name]==null&&(r[u.name]=new Set),r[u.name].add(o.name),!n.has(u.name)&&s.push(u)}}return{sorted:a,recipientMap:r}}function YG(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let a=0;a<e.sourceLayer.inboundNodes.length;++a)for(let r of e.sourceLayer.inboundNodes[a].outputTensors)if(r.id===e.id){n=a;break}t=e.sourceLayer.getOutputAt(n)}return t}var ZG=G();ZG.registerFlag(\"TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES\",()=>100,qG);var T2={};_e(T2,{maxNorm:()=>JG,minMaxNorm:()=>tH,nonNeg:()=>eH,unitNorm:()=>QG});function p0(e,t){return O(()=>rn(fe(z(e,e),t,!0)))}var Sd=class extends ne.Serializable{getConfig(){return{}}},c0=class extends Sd{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return O(()=>{let t=p0(e,this.axis),n=an(t,0,this.maxValue);return z(e,he(n,X(qt(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};c0.className=\"MaxNorm\";ne.registerClass(c0);var d0=class extends Sd{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return O(()=>he(e,X(qt(),p0(e,this.axis))))}getConfig(){return{axis:this.axis}}};d0.className=\"UnitNorm\";ne.registerClass(d0);var h0=class extends Sd{apply(e){return Ke(e)}};h0.className=\"NonNeg\";ne.registerClass(h0);var m0=class extends Sd{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return O(()=>{let t=p0(e,this.axis),n=X(z(this.rate,an(t,this.minValue,this.maxValue)),z(1-this.rate,t));return z(e,he(n,X(qt(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};m0.className=\"MinMaxNorm\";ne.registerClass(m0);var kI={maxNorm:\"MaxNorm\",minMaxNorm:\"MinMaxNorm\",nonNeg:\"NonNeg\",unitNorm:\"UnitNorm\"};function Xt(e){return Qw(e)}function II(e,t={}){return vd(e,ne.SerializationMap.getMap().classNameMap,t,\"constraint\")}function Yt(e){if(e==null)return null;if(typeof e==\"string\"){let t={className:e in kI?kI[e]:e,config:{}};return II(t)}else return e instanceof Sd?e:II(e)}function JG(e){return new c0(e)}function QG(e){return new d0(e)}function eH(){return new h0}function tH(e){return new m0(e)}var C2={};_e(C2,{constant:()=>rH,glorotNormal:()=>cH,glorotUniform:()=>pH,heNormal:()=>dH,heUniform:()=>hH,identity:()=>lH,leCunNormal:()=>mH,leCunUniform:()=>fH,ones:()=>aH,orthogonal:()=>gH,randomNormal:()=>iH,randomUniform:()=>sH,truncatedNormal:()=>oH,varianceScaling:()=>uH,zeros:()=>nH});function nH(){return new n0}function aH(){return new yf}function rH(e){return new a0(e)}function sH(e){return new r0(e)}function iH(e){return new s0(e)}function oH(e){return new i0(e)}function lH(e){return new o0(e)}function uH(e){return new Bn(e)}function pH(e){return new xf(e)}function cH(e){return new vf(e)}function dH(e){return new wf(e)}function hH(e){return new kf(e)}function mH(e){return new If(e)}function fH(e){return new Sf(e)}function gH(e){return new l0(e)}var E2={};_e(E2,{Layer:()=>We,RNN:()=>Mr,RNNCell:()=>Td,activation:()=>qj,add:()=>n6,alphaDropout:()=>z6,average:()=>a6,averagePooling1d:()=>T1,averagePooling2d:()=>C1,averagePooling3d:()=>E1,avgPool1d:()=>d6,avgPool2d:()=>m6,avgPool3d:()=>g6,avgPooling1d:()=>h6,avgPooling2d:()=>f6,avgPooling3d:()=>b6,batchNormalization:()=>u6,bidirectional:()=>F6,categoryEncoding:()=>G6,centerCrop:()=>V6,concatenate:()=>r6,conv1d:()=>Lj,conv2d:()=>zj,conv2dTranspose:()=>Wj,conv3d:()=>Bj,conv3dTranspose:()=>Vj,convLstm2d:()=>C6,convLstm2dCell:()=>E6,cropping2D:()=>Gj,dense:()=>Kj,depthwiseConv2d:()=>jj,dot:()=>l6,dropout:()=>Xj,elu:()=>$j,embedding:()=>t6,flatten:()=>Zj,gaussianDropout:()=>L6,gaussianNoise:()=>P6,globalAveragePooling1d:()=>y6,globalAveragePooling2d:()=>x6,globalMaxPool1d:()=>D6,globalMaxPool2d:()=>R6,globalMaxPooling1d:()=>AC,globalMaxPooling2d:()=>FC,gru:()=>w6,gruCell:()=>k6,input:()=>j2,inputLayer:()=>Fj,layerNormalization:()=>p6,leakyReLU:()=>Rj,lstm:()=>I6,lstmCell:()=>S6,masking:()=>W6,maxPool1d:()=>M6,maxPool2d:()=>O6,maxPooling1d:()=>$C,maxPooling2d:()=>DC,maxPooling3d:()=>v6,maximum:()=>s6,minimum:()=>i6,multiply:()=>o6,permute:()=>e6,prelu:()=>Mj,randomWidth:()=>H6,reLU:()=>Dj,repeatVector:()=>Jj,rescaling:()=>B6,reshape:()=>Qj,resizing:()=>U6,rnn:()=>_6,separableConv2d:()=>Uj,simpleRNN:()=>N6,simpleRNNCell:()=>T6,softmax:()=>Oj,spatialDropout1d:()=>Yj,stackedRNNCells:()=>A6,thresholdedReLU:()=>Pj,timeDistributed:()=>$6,upSampling2d:()=>Hj,zeroPadding2d:()=>c6});async function Kr(e){if(e==null)return;let t=[],n=[],a=[];for(let r in e){let s=e[r];if(typeof s!=\"number\"){let i=s;t.push(i.data()),n.push(r),a.push(i)}}if(t.length>0){let r=await Promise.all(t);for(let s=0;s<r.length;++s)e[n[s]]=r[s][0];Ee(a)}}function _2(e){if(e!=null)for(let t in e){let n=e[t];typeof n!=\"number\"&&n.dispose()}}var SI;(function(e){e[e.SILENT=0]=\"SILENT\",e[e.VERBOSE=1]=\"VERBOSE\"})(SI||(SI={}));var bH=125,Gl=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},A2=class{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},yH=class extends Gl{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let a in t){let r=t[a];if(typeof r==\"number\")this.totals.hasOwnProperty(a)||(this.totals[a]=0),this.totals[a]=this.totals[a]+r*n;else{let s;a in this.totals?s=this.totals[a]:this.totals[a]=0;let i=O(()=>X(this.totals[a],z(r,n)));this.totals[a]=i,s!=null&&s.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]==\"number\"?t[n]=this.totals[n]/this.seen:O(()=>{let a=z(he(1,this.seen),this.totals[n]);t[n]=a,this.totals[n].dispose(),Ht(t[n])}))}},F2=class extends Gl{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let r in this.history){let s=this.history[r];for(let i=0;i<s.length;++i)if(typeof s[i]!=\"number\"){let o=s[i];e.push(o.data()),t.push(r),n.push(i)}}let a=await Promise.all(e);for(let r=0;r<a.length;++r)this.history[t[r]][n[r]].dispose(),this.history[t[r]][n[r]]=a[r][0]}},$2=class extends Gl{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Zw,this.yieldEvery=t||\"auto\",this.yieldEvery===\"auto\"&&(this.yieldEvery=bH),this.yieldEvery===\"never\"&&e.onYield!=null)throw new Error(\"yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback\");w.isNumber(this.yieldEvery)&&(this.maybeWait=bG(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let a=[];this.yield!=null&&(await Kr(n),a.push(this.yield(e,t,n))),a.push(this.nextFrameFunc()),await Promise.all(a)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Kr(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await Kr(t),n.push(this.epochEnd(e,t))),this.yieldEvery===\"epoch\"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Kr(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await Kr(t),n.push(this.batchEnd(e,t))),this.yieldEvery===\"batch\"?n.push(this.nextFrameFunc()):w.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await Kr(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Kr(e),await this.trainEnd(e))}};function D2(e,t){return e==null&&(e={}),e instanceof Gl?[e]:Array.isArray(e)&&e[0]instanceof Gl?e:it(e).map(n=>new $2(n,t))}var f0=class Ja{constructor(){}static registerCallbackConstructor(t,n){w.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),Ja.checkForDuplicate(n),Ja.constructors[t]==null&&(Ja.constructors[t]=[]),Ja.constructors[t].push(n)}static checkForDuplicate(t){for(let n in Ja.constructors)Ja.constructors[+n].forEach(a=>{if(a===t)throw new V(\"Duplicate callback constructor.\")})}static clear(){Ja.constructors={}}static createCallbacks(t){let n=[];for(let a in Ja.constructors){let r=+a;t>=r&&n.push(...Ja.constructors[r])}return n.map(a=>new a)}};f0.constructors={};function R2(e,t,n,a,r,s,i,o,l){let u=new F2,p=[new yH,...f0.createCallbacks(t)];e!=null&&p.push(...e),p.push(u);let d=new A2(p);return d.setParams({epochs:n,initialEpoch:a,samples:r,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:d,history:u}}function Ba(e,t={},n=!1){return vd(e,ne.SerializationMap.getMap().classNameMap,t,\"layer\",n)}function tm(e,t){return O(()=>{e.dtype!==\"float32\"&&(e=re(e,\"float32\"));let n=fe(kd(e),t,!0),a=yn(n.shape,qt()),r=rn(hr(n,a));return he(e,r)})}function Xo(e,t){return O(()=>Ct(kd(pe(t,e)),-1))}function Tf(e,t){return O(()=>Ct(Lt(pe(t,e)),-1))}function sp(e,t){return O(()=>{let n=pe(e,t),a=an(Lt(e),qt(),Number.MAX_VALUE),r=Lt(he(n,a));return z(100,Ct(r,-1))})}function xH(e,t){return O(()=>{let n=an(t,qt(),Number.MAX_VALUE),a=Qn(X(1,n)),r=an(e,qt(),Number.MAX_VALUE),s=Qn(X(1,r));return Ct(kd(pe(a,s)),-1)})}function vH(e,t){return O(()=>{let n=hr(0,pe(1,z(e,t)));return Ct(kd(n),-1)})}function wH(e,t){return O(()=>{let n=hr(0,pe(1,z(e,t)));return Ct(n,-1)})}function kH(e,t){return O(()=>{let n=fe(z(e,t),-1),a=ma(z(pe(1,e),t),-1);return hr(0,X(1,pe(a,n)))})}function IH(e,t){return O(()=>{let n=Math.log(2),a=pe(t,e),r=pe(X(a,Go(z(-2,a))),n);return Ct(r,-1)})}function kc(e,t,n=!1){return O(()=>{if(n)t=qa(t);else{let a=fe(t,t.shape.length-1,!0);t=he(t,a)}return t=an(t,qt(),1-qt()),yt(fe(z(re(e,\"float32\"),Qn(t)),t.shape.length-1))})}function nm(e,t,n=!1){return O(()=>{let a=re(tp(_G(e)),\"int32\");t=an(t,qt(),1-qt());let r=t.shape,s=W(Ll(a,r[r.length-1]),r);return kc(s,t,n)})}function SH(e,t){if(!w.arraysEqual(e.shape,t.shape))throw new V(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return O(()=>{let n=Ke(t),a=yt(Lt(t));return X(pe(n,z(t,e)),pd(dn(a)))})}function Cf(e,t){return O(()=>{let n;return n=an(t,qt(),1-qt()),n=Qn(he(n,pe(1,n))),Ct(SH(e,n),-1)})}function NH(e,t){return O(()=>{let n=an(e,qt(),1),a=an(t,qt(),1);return fe(z(e,Qn(he(n,a))),-1)})}function TH(e,t){return O(()=>{let n=Qn(X(qt(),t));return Ct(pe(t,z(e,n)),-1)})}function g0(e,t){return O(()=>{let n=tm(e,-1),a=tm(t,-1),r=z(n,a);return yt(fe(r,-1))})}var am={meanSquaredError:Xo,meanAbsoluteError:Tf,meanAbsolutePercentageError:sp,meanSquaredLogarithmicError:xH,squaredHinge:vH,hinge:wH,categoricalHinge:kH,logcosh:IH,categoricalCrossentropy:kc,sparseCategoricalCrossentropy:nm,binaryCrossentropy:Cf,kullbackLeiblerDivergence:NH,poisson:TH,cosineProximity:g0};function dx(e){if(typeof e==\"string\"){if(e in am)return am[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes(\"softmaxcrossentropy\")&&(t=`Unknown loss ${e}. Use \"categoricalCrossentropy\" as the string name for tf.losses.softmaxCrossEntropy`),new V(t)}else return e}function b0(e,t){return O(()=>{let n=z(.5,ea(t)),a=ir(Cn(t,n),e.dtype);return Ct(Jn(e,a),-1)})}function y0(e,t){return O(()=>ir(Jn(di(e,-1),di(t,-1)),\"float32\"))}function M2(e,t){return O(()=>re(fe(_a(Jn(e,1),Jn(t,1))),\"float32\"))}function CH(e,t){return O(()=>re(fe(_a(Jn(e,1),Jn(t,0))),\"float32\"))}function EH(e,t){return O(()=>re(fe(_a(Jn(e,0),Jn(t,1))),\"float32\"))}function O2(e,t){return O(()=>{let n=M2(e,t),a=EH(e,t),r=X(n,a);return re(nn(Cn(r,0),he(n,r),0),\"float32\")})}function _H(e,t){return O(()=>{let n=M2(e,t),a=CH(e,t),r=X(n,a);return re(nn(Cn(r,0),he(n,r),0),\"float32\")})}function P2(e,t){return Cf(e,t)}function L2(e,t){return e.rank===t.rank&&(e=As(e,[e.rank-1])),t=di(t,-1),t.dtype!==e.dtype&&(t=re(t,e.dtype)),re(Jn(e,t),\"float32\")}function AH(e,t){return O(()=>{let n=e.sub(t).square().sum(),a=e.sub(e.mean()).square().sum();return xe(1).sub(n.div(a))})}var FH=Xo,$H=Xo,DH=Tf,RH=Tf,MH=sp,OH=sp,x0=kc,PH=g0,z2=nm,rm={binaryAccuracy:b0,categoricalAccuracy:y0,precision:O2,categoricalCrossentropy:x0,sparseCategoricalCrossentropy:z2,mse:FH,MSE:$H,mae:DH,MAE:RH,mape:MH,MAPE:OH,cosine:PH};function LH(e){if(typeof e==\"string\"&&e in rm)return rm[e];if(typeof e!=\"string\"&&e!=null)return e;throw new V(`Unknown metric ${e}`)}function Sh(e){if(tr(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e==\"string\")return e;{let t;for(let n of Object.keys(am))if(am[n]===e){t=n;break}if(t!==void 0)return t;for(let n of Object.keys(rm))if(rm[n]===e){t=n;break}return t!==void 0?t:e.name}}function zH(e){let t={Adagrad:()=>Xs.adagrad(.01),Adadelta:()=>Xs.adadelta(1,.95,qt()),Adam:()=>Xs.adam(.001,.9,.999,qt()),Adamax:()=>Xs.adamax(.002,.9,.999,qt(),0),RMSProp:()=>Xs.rmsprop(.001,.9,0,qt()),SGD:()=>Xs.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new V(`Unknown Optimizer ${e}`)}function NI(e,t,n=!1){if(e==null||typeof e!=\"object\"||Object.getPrototypeOf(e)!==Object.prototype||!Gx(e))throw new Error(\"User-defined metadata is expected to be a JSON object, but is not.\");if(n){let a=JSON.stringify(e);a.length>1048576&&console.warn(`User-defined metadata of model \"${t}\" is too large in size (length=${a.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function Gx(e){if(e===null)return!0;if(typeof e==\"object\")if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if(typeof n!=\"string\"||!Gx(e[n]))return!1;return!0}else if(Array.isArray(e)){for(let t of e)if(!Gx(t))return!1;return!0}else return!1;else{let t=typeof e;return t===\"string\"||t===\"number\"||t===\"boolean\"}}function WH(e,t,n,a=console.log){let r=VH(e),s=[\"Layer (type)\",\"Input Shape\",\"Output shape\",\"Param #\"];r?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(p=>Math.floor(t*p)));let i;if(!r){s.push(\"Receives inputs\"),i=[];for(let p in e.nodesByDepth)i.push(...e.nodesByDepth[p])}a(\"_\".repeat(t)),sm(s,n,a),a(\"=\".repeat(t));let o=e.layers;for(let p=0;p<o.length;++p)r?UH(o[p],n,a):GH(o[p],n,i,a),a((p===o.length-1?\"=\":\"_\").repeat(t));e.checkTrainableWeightsConsistency();let l=BH(e),u=Jh(e.nonTrainableWeights);a(`Total params: ${l+u}`),a(`Trainable params: ${l}`),a(`Non-trainable params: ${u}`),a(\"_\".repeat(t))}function BH(e){let t;return e.collectedTrainableWeights!=null?t=Jh(e.collectedTrainableWeights):t=Jh(e.trainableWeights),t}function VH(e){let t=!0,n=[],a=[];for(let r in e.nodesByDepth)n.push(e.nodesByDepth[r]);for(let r of n){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){t=!1;break}a.push(...r)}if(t)for(let r of e.layers){let s=!1;for(let i of r.inboundNodes)if(a.indexOf(i)!==-1)if(s){t=!1;break}else s=!0;if(!t)break}return t}function sm(e,t,n=console.log){let a=\"\";for(let r=0;r<e.length;++r)r>0&&(a=a.slice(0,a.length-1)+\" \"),a+=e[r],a=a.slice(0,t[r]),a+=\" \".repeat(t[r]-a.length);n(a)}function UH(e,t,n){let a,r;try{r=e.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(\",\")}catch(l){r=\"multiple\"}try{a=JSON.stringify(e.outputShape)}catch(l){a=\"multiple\"}let s=e.name,i=e.getClassName(),o=[`${s} (${i})`,r,a,e.countParams().toString()];sm(o,t,n)}function GH(e,t,n,a){let r,s;try{s=e.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(\",\")}catch(d){s=\"multiple\"}try{r=JSON.stringify(e.outputShape)}catch(d){r=\"multiple\"}let i=[];for(let d of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(d)===-1))for(let c=0;c<d.inboundLayers.length;++c){let h=d.inboundLayers[c].name,m=d.nodeIndices[c],f=d.tensorIndices[c];i.push(`${h}[${m}][${f}]`)}let o=e.name,l=e.getClassName(),u=i.length===0?\"\":i[0],p=[`${o} (${l})`,s,r,e.countParams().toString(),u];sm(p,t,a);for(let d=1;d<i.length;++d)sm([\"\",\"\",\"\",\"\",i[d]],t,a)}function W2(e,t,n){return(e===\"inboundNodes\"||e===\"outputLayers\"||e===\"inputLayers\")&&t===0&&typeof n==\"string\"}function Ic(e,t){if(e===null)return null;if(typeof e==\"string\")return Js(e);if(typeof e==\"number\"||typeof e==\"boolean\")return e;if(e instanceof Array){let n=[],a=e.length;for(let r=0;r<a;++r){let s=e[r];W2(t,r,s)?n.push(s):n.push(Ic(s,t))}return n}else{let n={};for(let a of Object.keys(e)){let r=e[a];if(a===\"name\"&&typeof r==\"string\")n[a]=r;else{let s=Js(a);n[s]=Ic(r,s)}}return n}}function Hx(e,t){if(e==null)return null;if(typeof e==\"string\")return Ir(e);if(typeof e==\"number\"||typeof e==\"boolean\")return e;if(e instanceof Array){let n=[],a=e.length;for(let r=0;r<a;++r){let s=e[r];W2(t,r,s)?n.push(s):n.push(Hx(s,t))}return n}else{let n={};for(let a of Object.keys(e)){let r=e[a],s=Ir(a);(a===\"name\"||a===\"className\")&&typeof r==\"string\"?n[s]=r:n[s]=Hx(r,a)}return n}}var v0=\"4.22.0\",HH=e=>{let t=Object.keys(e);if(t.length===0)return!1;let n=t[0].split(\"/\");return!isNaN(parseInt(n[n.length-1],10))},jH=class Qa extends We{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let y=this.getClassName().toLowerCase();this.name=gf(y)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],as(this.inputs).length!==this.inputs.length)throw new V(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(y=>y.name)}`);as(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(y=>y.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let y of this.outputs){let x=y.sourceLayer,v=y.nodeIndex,I=y.tensorIndex;this.outputLayers.push(x),this.outputLayersNodeIndices.push(v),this.outputLayersTensorIndices.push(I)}for(let y of this.inputs){let x=y.sourceLayer,v=y.nodeIndex,I=y.tensorIndex;tr(v===0,\"input layer has >1 nodes\"),tr(I===0,\"input layer has >1 tensors\"),this.inputLayers.push(x),this.inputLayersNodeIndices.push(v),this.inputLayersTensorIndices.push(I)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){let x=this.inputLayers[y];if(!(x instanceof rp))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${y} (0-based) originates from layer type ${x.getClassName()}.`);this.inputNames.push(x.name),this.feedInputShapes.push(x.batchInputShape),this.feedInputNames.push(x.name)}for(let y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(y=>y.shape),this.internalOutputShapes=this.outputs.map(y=>y.shape);let n={},a={},r={},s={},i={},o=[],l=(y,x,v,I,N,C)=>{(I==null||N==null||C==null)&&(I=y.sourceLayer,N=y.nodeIndex,C=y.tensorIndex);let _=I.inboundNodes[N];if(v.indexOf(_)!==-1)throw new ar(`The tensor ${y.name} at layer \"${I.name}\" is part of a cycle.`);if(x.indexOf(_)!==-1)return;this.containerNodes.add(Qa.nodeKey(I,N)),I.id in i||(i[I.id]=Object.keys(i).length),v.indexOf(_)===-1&&v.push(_);let F=_.inboundLayers.length;for(let D=0;D<F;D++){let $=_.inputTensors[D],S=_.inboundLayers[D],M=_.nodeIndices[D],B=_.tensorIndices[D];l($,x,v,S,M,B)}for(x.push(_);v.indexOf(_)>=0;)v.splice(v.indexOf(_),1);o.push(_)},u=[],p=[];for(let y of this.outputs)l(y,u,p);let d=o.slice().reverse();for(let y of d){a[y.id]=y,y.id in n||(n[y.id]=0);let x=n[y.id],v=r[y.outboundLayer.id]==null?0:r[y.outboundLayer.id];x=Math.max(x,v),r[y.outboundLayer.id]=x,s[y.outboundLayer.id]=y.outboundLayer,n[y.id]=x;for(let I=0;I<y.inboundLayers.length;I++){let N=y.inboundLayers[I],C=y.nodeIndices[I],_=N.inboundNodes[C],F=n[_.id]==null?0:n[_.id];n[_.id]=Math.max(x+1,F),a[_.id]=_}}let c={};for(let y in n){let x=n[y];x in c||(c[x]=[]),c[x].push(a[y])}let h={};for(let y in r){let x=r[y];x in h||(h[x]=[]),h[x].push(s[y])}let m=Object.keys(h).map(y=>parseInt(y,10)).sort(wh);this.layers=[];for(let y of m){let x=h[y];x.sort((v,I)=>{let N=i[v.id],C=i[I.id];return N<C?-1:N>C?1:0});for(let v of x)v instanceof Qa&&this.internalContainerRefs.push(v),this.layers.push(v)}this.layersByDepth=h,m=Object.keys(c).map(y=>parseInt(y,10)).sort(wh);let f=this.inputs.slice(),g=[];for(let y of m)for(let x of c[y]){let v=x.outboundLayer;if(v!=null){for(let I of x.inputTensors)if(f.indexOf(I)===-1)throw new ar(`Graph disconnected: cannot obtain value for tensor ${I} at layer \"${v.name}\". The following previous layers were accessed without issue: ${g}`);for(let I of x.outputTensors)f.push(I);g.push(v.name)}}this.nodesByDepth=c;let b=this.layers.map(y=>y.name);for(let y of b){let x=b.filter(v=>v===y).length;if(x!==1)throw new ar(`The name \"${y}\" is used ${x} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(b))}this.outboundNodes=[],this.inboundNodes=[],new Nf({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(y=>null),outputMasks:this.outputs.map(y=>null),inputShapes:this.inputs.map(y=>y.shape),outputShapes:this.outputs.map(y=>y.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(let n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(a=>a.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new V(\"Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.\");if(!this.trainable)return[];let t=[];for(let n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){let n=[];for(let a of this.layers)n.push(...a.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){let a={},r=0,s=HH(t);s&&this.parseWeights(t);for(let o of this.layers)for(let[l,u]of o.weights.entries()){let p=s?`${u.name.split(\"/\").slice(0,-1).join(\"/\")+\"/\"}${l}`:u.originalName;if(a[p]!=null)throw new V(`Duplicate weight name: ${p}`);a[p]=u,r++}let i=[];for(let o in t){let l=o;if(a[o]==null){let u=o.split(\"/\");l=u.slice(0,-2).concat([u[u.length-1]]).join(\"/\")}if(a[l]!=null)i.push([a[l],t[o]]);else if(n)throw new V(`Provided weight data has no target variable: ${o}`);delete a[l]}if(n){let o=[];for(let l in a)o.push(l);if(o.length>0)throw new V(`${o.length} of ${r} weights are not set: ${o}`)}u0(i)}parseWeights(t){for(let n in Object.keys(t)){let a=n.split(\"/\"),r=[\"vars\",\"layer_checkpoint_dependencies\"],s=a.map(i=>i.startsWith(\"_\")?i.slice(1):i).filter(i=>!r.includes(i)).join(\"/\");s!==n&&(t[s]=t[n],delete t[n])}}updatedConfig(){let t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${v0}`,n.backend=\"TensorFlow.js\",n}toJSON(t,n=!0){let a=Hx(this.updatedConfig());return n?JSON.stringify(a):a}call(t,n){return O(()=>{t=it(t);let a=new Cl;for(let r=0;r<this.inputs.length;++r)a.add(this.inputs[r],t[r]);return tc(this.outputs,a,n)})}computeMask(t,n){return O(()=>{t=it(t);let a;return n==null?a=bi(null,t.length):a=it(n),this.runInternalGraph(t,a)[1]})}computeOutputShape(t){let n=Zh(t);if(n.length!==this.inputLayers.length)throw new V(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let a={};for(let o=0;o<n.length;o++){let l=this.inputLayers[o],u=n[o],p=l.name+\"_0_0\";a[p]=u}let r=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(wh);if(r.length>1)for(let o of r){let l=this.nodesByDepth[o];for(let u of l){let p=u.outboundLayer;if(this.inputLayers.map(f=>f.id).indexOf(p.id)!==-1)continue;let d=[];for(let f=0;f<u.inboundLayers.length;f++){let g=u.inboundLayers[f],b=u.nodeIndices[f],y=u.tensorIndices[f],x=`${g.name}_${b}_${y}`,v=a[x];d.push(v)}let c=p.computeOutputShape(Mn(d)),h=Zh(c),m=p.inboundNodes.indexOf(u);for(let f=0;f<h.length;f++){let g=`${p.name}_${m}_${f}`;a[g]=h[f]}}}let s=[],i=[];for(let o=0;o<this.outputLayers.length;o++){let l=this.outputLayers[o],u=this.outputLayersNodeIndices[o],p=this.outputLayersTensorIndices[o],d=`${l.name}_${u}_${p}`;i.push(d)}for(let o=0;o<i.length;o++){let l=i[o];tr(l in a),s.push(a[l])}return Mn(s)}runInternalGraph(t,n){n==null&&(n=bi(null,t.length));let a={};for(let l=0;l<this.inputs.length;++l){let u=this.inputs[l],p=t[l],d=n[l];a[u.id]=[p,d]}let r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(wh);for(let l of r){let u=this.nodesByDepth[l];for(let p of u){let d=p.outboundLayer,c=p.inputTensors,h=p.outputTensors,m=new Array;for(let f of c)f.id in a&&m.push(a[f.id]);if(m.length===c.length){let f={},g,b,y,x;if(p.callArgs!=null&&(f=p.callArgs),m.length===1){let[v,I]=m[0];f.mask==null&&(f.mask=I),y=it(d.call(v,f)),x=it(d.computeMask(v,I)),g=[v],b=[I]}else g=m.map(v=>v[0]),b=m.map(v=>v[1]),f.mask==null&&(f.mask=b),y=it(d.call(g,f)),x=it(d.computeMask(g,b));if(d.activityRegularizer)throw new ze(\"LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.\");for(let v=0;v<h.length;++v){let I=h[v],N=y[v],C=x[v];a[I.id]=[N,C]}}}}let s=[],i=[],o=[];for(let l of this.outputs){tr(l.id in a,`Could not compute output ${l.name} : ${l.id}`);let[u,p]=a[l.id];o.push(u.shape),s.push(u),i.push(p)}return[s,i,o]}buildNodeConversionMap(t){let n={},a;for(let r of this.layers){a=r instanceof Qa?1:0;for(let s=0;s<r.inboundNodes.length;s++){let i=Qa.nodeKey(r,s);this.containerNodes.has(i)&&(n[i]=a,a+=1)}}return n}getLayer(t,n){if(n!=null)return this.findLayer(n);if(t==null)throw new V(\"Provide either a layer name or layer index\");if(typeof t==\"number\")return this.findLayer(t);for(let a of this.layers)if(a.name===t)return a;throw new V(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new V(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return O(()=>{let t=[];for(let n of this.layers)for(let a=0;a<n.inboundNodes.length;++a){let r=Qa.nodeKey(n,a);this.containerNodes.has(r)&&t.push(...n.calculateLosses())}return t})}getConfig(){let t={name:this.name},n=this.buildNodeConversionMap(this.layers),a=[];for(let i of this.layers){let o=i.getClassName(),l=i.getConfig(),u=[];for(let d=0;d<i.inboundNodes.length;d++){let c=i.inboundNodes[d],h=Qa.nodeKey(i,d),m={};if(this.containerNodes.has(h)){if(c.callArgs)try{JSON.stringify(c.callArgs),m=c.callArgs}catch(f){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${c.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),m={}}if(c.inboundLayers.length>0){let f=[];for(let g=0;g<c.inboundLayers.length;g++){let b=c.inboundLayers[g],y=c.nodeIndices[g],x=c.tensorIndices[g],v=Qa.nodeKey(b,y),I=n[v];I==null&&(I=0),f.push([b.name,I,x,m])}u.push(f)}}}let p={};p.name=i.name,p.className=o,p.config=l,p.inboundNodes=u,a.push(p)}t.layers=a;let r=[];for(let i=0;i<this.inputLayers.length;i++){let o=this.inputLayers[i],l=this.inputLayersNodeIndices[i],u=Qa.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let p=n[u];p==null&&(p=0);let d=this.inputLayersTensorIndices[i];r.push([o.name,p,d])}t.inputLayers=r;let s=[];for(let i=0;i<this.outputLayers.length;i++){let o=this.outputLayers[i],l=this.outputLayersNodeIndices[i],u=Qa.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let p=n[u];p==null&&(p=0);let d=this.outputLayersTensorIndices[i];s.push([o.name,p,d])}return t.outputLayers=s,t}static fromConfig(t,n,a={},r=!1){let s={},i={};function o(g,b){g.name in i?i[g.name].push(b):i[g.name]=[b]}function l(g,b){let y=[],x;for(let v of b){let I=v[0],N=v[1],C=v[2];if(x=v[3]==null?{}:v[3],!(I in s)){o(g,b);return}let _=s[I];if(_.inboundNodes.length<=N){o(g,b);return}let F=_.inboundNodes[N];y.push(F.outputTensors[C])}y.length>0&&g.apply(Mn(y),x)}function u(g){let b=g.name,y=Ba(g,n.customObjects!=null?n.customObjects:{});y.setFastWeightInitDuringBuild(r),s[b]=y,g.inboundNodes.forEach(x=>{if(!(x instanceof Array))throw new V(`Corrupted configuration, expected array for nodeData: ${x}`);o(y,x)})}let p=n.name,d=n.layers;for(let g of d)u(g);for(;!gG(i);)for(let g of d){let b=s[g.name];if(b.name in i){let y=i[b.name];delete i[b.name];for(let x of y)l(b,x)}}let c=[],h=[],m=n.inputLayers;for(let g of m){let b=g[0],y=g[1],x=g[2];tr(b in s);let v=s[b].inboundNodes[y].outputTensors;c.push(v[x])}let f=n.outputLayers;for(let g of f){let b=g[0],y=g[1],x=g[2];tr(b in s);let v=s[b].inboundNodes[y].outputTensors;h.push(v[x])}return new t({inputs:c,outputs:h,name:p})}get stateful(){if(this._stateful)throw new V(\"Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.\");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){O(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function qH(e,t,n){let a=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>null);if(a===1)return Array.isArray(e)&&e.length===1?e:typeof e==\"object\"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==a)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${a} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e==\"object\"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]==\"object\"){let r=[];return t.forEach(s=>{s in e?r.push(e[s]):r.push(null)}),r}else throw new Error(`The model has multiple (${a}) outputs, so ${n} must be either an array with ${a} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function B2(e,t){return qH(e,t,\"classWeight\")}async function V2(e,t,n,a){if(t!=null||a!=null)throw new Error(\"Support sampleWeight is not implemented yet\");if(n!=null){let r=O(()=>{if(e.shape.length===1)return sr(e);if(e.shape.length===2){if(e.shape[1]>1)return di(e,1);if(e.shape[1]===1)return W(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await r.data());Ee(r);let i=[];return s.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(n[o])}),je(i,\"float32\")}else return null}function KH(e,t){return z(e,t)}var XH=32;function U2(e,t){let n,a,r=t;n=r.xs,a=r.ys,w.assert(n!=null&&a!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \\`{xs: xVal, ys: yVal}\\`, where the two values may be \\`tf.Tensor\\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let s=TI(\"input\",e.inputNames,n),i=TI(\"output\",e.outputNames,a),o=s[0].shape[0];w.assert(s.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),w.assert(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let l=0;l<s.length;l++)w.assert(s[l].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let l=0;l<i.length;l++)w.assert(i[l].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:s,ys:i}}function TI(e,t,n){if(n instanceof Ce)return[n];if(Array.isArray(n))return w.assert(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{let a=[];for(let r of t){if(n[r]==null)throw new V(`The feature data generated by the dataset lacks the required ${e} key '${r}'.`);a.push(n[r])}return a}}function YH(e){if(e.length===3)throw new ze(\"Validation with sample weights is not implemented yet.\");return{xs:e[0],ys:e[1]}}async function ZH(e,t,n){let a=n.batchesPerEpoch!=null;if(w.assert(e.optimizer!=null,()=>\"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).\"),w.assert(n!=null,()=>\"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.\"),w.assert(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),w.assert(!a||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),w.assert(n.validationSplit==null,()=>\"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.\"),e.isTraining)throw new Error(\"Cannot start training because another fit() call is ongoing.\");e.isTraining=!0;try{let r=n.validationData!=null,s,i;if(r)if(CI(n.validationData))w.assert(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let g=YH(n.validationData);s=g.xs,i=g.ys}let o=e.makeTrainFunction(),l=e.getDedupedMetricsNames(),u;r?u=l.slice().concat(l.map(g=>\"val_\"+g)):u=l.slice();let p=D2(n.callbacks,n.yieldEvery),d=n.verbose==null?1:n.verbose,{callbackList:c,history:h}=R2(p,d,n.epochs,null,null,JH(t,n),null,r,u);c.setModel(e),e.history=h,await c.onTrainBegin(),e.stopTraining_=!1;let m=n.initialEpoch==null?0:n.initialEpoch,f=await t.iterator();for(;m<n.epochs;){let g={};await c.onEpochBegin(m);let b=0,y=0;for(a||(f=await t.iterator());!a||b<n.batchesPerEpoch;){let x=await f.next();if(a&&x.done){console.warn(`You provided \\`batchesPerEpoch\\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${b} batches; interrupting training. Make sure that your dataset can generate at least \\`batchesPerEpoch * epochs\\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(x.value!=null){let{xs:v,ys:I}=U2(e,x.value),N={};N.batch=y,N.size=v[0].shape[0],await c.onBatchBegin(y,N);let C=[];if(n.classWeight!=null){let D=B2(n.classWeight,e.outputNames);for(let $=0;$<D.length;++$)C.push(await V2(I[$],null,D[$]))}let _=v.concat(I).concat(C),F=o(_);Ee(_);for(let D=0;D<l.length;++D){let $=l[D],S=F[D];N[$]=S,Ht(S)}await c.onBatchEnd(y,N),_2(N),y++,b++}if(a?b>=n.batchesPerEpoch:x.done){if(r){let v;CI(n.validationData)?v=it(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):v=it(e.evaluate(s,i,{batchSize:n.validationBatchSize==null?XH:n.validationBatchSize,verbose:0}));for(let I=0;I<e.metricsNames.length;++I)g[`val_${e.metricsNames[I]}`]=v[I]}break}if(e.stopTraining_)break}if(await c.onEpochEnd(m,g),m++,e.stopTraining_)break}return await c.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function JH(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function CI(e){return typeof e.iterator==\"function\"}function QH(e){return typeof e.next==\"function\"}async function ej(e,t,n){n=n||{};let a=n.batches!=null,r=e.testFunction,s=[];if(n.verbose>0)throw new ze(\"Verbose mode is not implemented yet.\");w.assert(!a||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \\`batches\\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let i=QH(t)?t:await t.iterator(),o=0,l=0;for(;!a||l<n.batches;){let u=await i.next();if(s=O(()=>{if(u.value){let{xs:p,ys:d}=U2(e,u.value),c=p.concat(d),h=O(()=>r(c));if(Ee(c),l===0)for(let f=0;f<h.length;++f)s.push(xe(0));let m=c[0].shape[0];for(let f=0;f<h.length;++f){let g=h[f],b=s[f];s[f]=O(()=>X(s[f],z(m,g))),l>0&&Ee(b)}Ee(h),o+=m,++l}return s}),u.done){a&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \\`batches\\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<s.length;++u){let p=s[u];s[u]=he(s[u],o),Ee(p)}return Mn(s)}function hx(e){w.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function Xp(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(a=>si(a,t,n-t)):si(e,t,n-t)}function jx(e,t){return O(()=>e==null?null:Array.isArray(e)?e.map(n=>jx(n,t)):v2(e,t.dtype===\"int32\"?t:re(t,\"int32\")))}function mx(e,t){let n=[],a=0,r=null;for(;a<e;)r=a+t,r>=e&&(r=e),n.push([a,r]),a=r;return n}function G2(e){let t=[];e instanceof Ce&&(e=[e]);for(let n=0;n<e.length;++n){let a=e[n];if(a.rank===1)t.push(wd(a,1));else{if(a.rank===0)throw new Error(\"Expected tensor to be at least 1D, but received a 0D tensor (scalar).\");t.push(a)}}return t}function Pa(e,t){if(e==null)return;let n=[];if(t instanceof Ce)n.push(t.id);else if(Array.isArray(t))t.forEach(r=>n.push(r.id));else if(t!=null)for(let r in t){let s=t[r];n.push(s.id)}let a=[];if(e instanceof Ce)n.indexOf(e.id)===-1&&a.push(e);else if(Array.isArray(e))e.forEach(r=>{n.indexOf(r.id)===-1&&a.push(r)});else if(e!=null)for(let r in e){let s=e[r];n.indexOf(s.id)===-1&&a.push(s)}a.forEach(r=>{r.isDisposed||r.dispose()})}function tj(e){return e instanceof Ce}function qx(e){return Array.isArray(e)}function EI(e){return!tj(e)&&!qx(e)}function _I(e,t,n,a=!0,r=\"\"){if(t==null||t.length===0){if(e!=null){let i=!1;if(qx(e)&&e.length>0)i=!0;else if(EI(e)){for(let o in e)if(e.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new V(`Error when checking model ${r} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(i=>null);let s;if(EI(e)){e=e,s=[];for(let i of t){if(e[i]==null)throw new V(`No data provided for \"${i}\". Need data for each key in: ${t}`);s.push(e[i])}}else if(qx(e)){if(e=e,e.length!==t.length)throw new V(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(e=e,t.length>1)throw new V(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=G2(s),n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=s[i];if(o.shape.length!==n[i].length)throw new V(`Error when checking ${r}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<n[i].length;++l){if(l===0&&!a)continue;let u=o.shape[l],p=n[i][l];if(p!=null&&p>=0&&u!==p)throw new V(`${r} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${r} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return s}function nj(e,t,n){let a=as(e.map(s=>s.shape[0]));a.sort();let r=as(t.map(s=>s.shape[0]));if(r.sort(),a.length>1)throw new V(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(s=>s.shape))}`);if(r.length>1)throw new V(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(a.length>0&&r.length>0&&!w.arraysEqual(a,r))throw new V(`Input Tensors should have the same number of samples as target Tensors. Found ${a[0]} input sample(s) and ${r[0]} target sample(s).`)}function aj(e,t,n){let a=[Xo,Cf,kc];for(let r=0;r<e.length;++r){let s=e[r],i=t[r],o=n[r];if(i!=null){if(i===kc&&s.shape[s.shape.length-1]===1)throw new V(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(a.indexOf(i)!==-1){let l=s.shape.slice(1),u=o.slice(1);for(let p=0;p<l.length;++p){let d=l[p],c=u[p];if(c!=null&&d!==c)throw new V(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function AI(e,t,n,a=!0,r=\"\"){let s;if(Array.isArray(e)){if(e.length!==t.length)throw new V(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new V(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=s[i];if(o.shape.length!==n[i].length)throw new V(`Error when checking ${r}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<n[i].length;++l){if(l===0&&!a)continue;let u=o.shape[l],p=n[i][l];if(p!=null&&p!==u)throw new V(`Error when checking ${r}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function rj(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(a=>[]);let n;if(typeof e==\"string\"||typeof e==\"function\")n=[e];else if(Array.isArray(e)||typeof e==\"object\")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(a=>n);{let a=[];for(let r of t){let s=n.hasOwnProperty(r)?n[r]:[];Array.isArray(s)||(s=[s]),a.push(s)}return a}}var sj=\"layers-model\",Er=class extends jH{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new V(\"This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).\");WH(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer==\"string\")this.optimizer_=zH(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Rr))throw new V(\"User-defined optimizer must be an instance of tf.Optimizer.\");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!=\"string\"&&typeof e.loss!=\"function\"){e.loss=e.loss;for(let s in e.loss)if(this.outputNames.indexOf(s)===-1)throw new V(`Unknown entry in loss dictionary: \"${s}\". Only expected the following keys: ${this.outputNames}`);for(let s of this.outputNames)e.loss[s]==null&&console.warn(`Output \"${s}\" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${s} during training`),t.push(dx(e.loss[s]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new V(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(s=>dx(s))}else{let s=dx(e.loss);this.outputs.forEach(i=>{t.push(s)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){let i=this.internalOutputShapes[s],o=this.outputNames[s];this.feedOutputNames.push(o),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[s])}let n=[];this.metrics=e.metrics,this.metricsNames=[\"loss\"],this.metricsTensors=[],ri(\"loss\",()=>{for(let s=0;s<this.outputs.length;++s){if(n.indexOf(s)!==-1)continue;let i=this.lossFunctions[s];this.outputs.length>1&&(this.metricsTensors.push([i,s]),this.metricsNames.push(this.outputNames[s]+\"_loss\"))}});let a=rj(e.metrics,this.outputNames),r=(s,i,o)=>{this.outputNames.length>1&&(i=this.outputNames[s]+\"_\"+i),this.metricsNames.push(i),this.metricsTensors.push([o,s])};ri(\"metric\",()=>{for(let s=0;s<this.outputs.length;++s){if(n.indexOf(s)!==-1)continue;let i=a[s];(o=>{let l=\"\",u,p,d;for(let c of o){if(typeof c==\"string\"&&[\"accuracy\",\"acc\",\"crossentropy\",\"ce\"].indexOf(c)!==-1){let m=this.internalOutputShapes[s];m[m.length-1]===1||this.lossFunctions[s]===Cf?[\"accuracy\",\"acc\"].indexOf(c)!==-1?p=b0:[\"crossentropy\",\"ce\"].indexOf(c)!==-1&&(p=P2):this.lossFunctions[s]===nm?[\"accuracy\",\"acc\"].indexOf(c)!==-1?p=L2:[\"crossentropy\",\"ce\"].indexOf(c)!==-1&&(p=z2):[\"accuracy\",\"acc\"].indexOf(c)!==-1?p=y0:[\"crossentropy\",\"ce\"].indexOf(c)!==-1&&(p=x0);let f;[\"accuracy\",\"acc\"].indexOf(c)!==-1?f=\"acc\":[\"crossentropy\",\"ce\"].indexOf(c)!==-1&&(f=\"ce\"),d=p,u=l+f}else d=LH(c),u=l+Sh(c);let h;ri(u,()=>{h=d}),r(s,u,h)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn(\"Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?\")}evaluate(e,t,n={}){let a=n.batchSize==null?32:n.batchSize;hx(a);let r=this.standardizeUserDataXY(e,t,!0,a);try{let s=r[0].concat(r[1]);this.makeTestFunction();let i=this.testFunction,o=this.testLoop(i,s,a,n.verbose,n.steps);return Mn(o)}finally{Pa(r[0],e),Pa(r[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),ej(this,e,t)}checkNumSamples(e,t,n,a=\"steps\"){let r;if(n!=null){if(r=null,t!=null)throw new V(`If ${a} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?r=e[0].shape[0]:r=e.shape[0];else throw new V(`Either the input data should have a defined shape, or ${a} shoud be specified.`);return r}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new V(\"`outputs` is an empty Array, which is not allowed.\");let n=Array.isArray(t),a=n?t:[t],r=this.retrieveSymbolicTensors(a),s=new Cl;if(e instanceof Ce&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new V(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let o=0;o<this.inputs.length;++o)s.add(this.inputs[o],e[o])}else for(let o of this.inputs){let l=e[o.name];if(l==null)throw new V(`No value is provided for the model's input ${o.name}`);s.add(o,l)}let i=tc(r,s);return n?i:i[0]}retrieveSymbolicTensors(e){let t=bi(null,e.length),n=e.length;for(let a of this.layers){let r=Array.isArray(a.output)?a.output:[a.output],s=r.map(i=>i.name);for(let i=0;i<e.length;++i){let o=s.indexOf(e[i]);if(o!==-1&&(t[i]=r[o],n--),n===0)break}if(n===0)break}if(n>0){let a=[];throw t.forEach((r,s)=>{r==null&&a.push(e[s])}),new V(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(a)}`)}return t}predictLoop(e,t=32,n=!1){return O(()=>{let a=this.checkNumSamples(e);if(n)throw new ze(\"Verbose predictLoop() is not implemented yet.\");let r=mx(a,t),s=this.outputs.map(i=>[]);for(let i=0;i<r.length;++i)O(()=>{let o=r[i][0],l=r[i][1],u=Xp(e,o,l),p=[];if(Array.isArray(u))for(let c=0;c<u.length;++c)p.push({key:this.inputs[c],value:u[c]});else p.push({key:this.inputs[0],value:u});let d=new Cl(p);return tc(this.outputs,d)}).forEach((o,l)=>s[l].push(o));return Mn(s.map(i=>et(i,0)))})}predict(e,t={}){let n=G2(e);AI(n,this.inputNames,this.feedInputShapes,!1);try{let a=t.batchSize==null?32:t.batchSize;return hx(a),this.predictLoop(n,a)}finally{Pa(n,e)}}predictOnBatch(e){AI(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,a){if(this.optimizer_==null)throw new ar(\"You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).\");let r=[];for(let s=0;s<this.feedOutputShapes.length;++s){let i=this.feedOutputShapes[s];this.feedLossFns[s]===nm?r.push(i.slice(0,i.length-1).concat([1])):r.push(i)}if(e=_I(e,this.feedInputNames,this.feedInputShapes,!1,\"input\"),t=_I(t,this.feedOutputNames,r,!1,\"target\"),nj(e,t,null),aj(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&a!=null&&a>0&&e[0].shape[0]%a!==0)throw new V(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${a}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,a,r=!0,s){let[i,o]=this.standardizeUserDataXY(e,t,r,s);if(n!=null)throw new Error(\"sample weight is not supported yet.\");let l=null;if(a!=null){let u=B2(a,this.outputNames);l=[];for(let p=0;p<u.length;++p)l.push(await V2(o[p],null,u[p]))}return[i,o,l]}testLoop(e,t,n,a=0,r){return O(()=>{let s=this.checkNumSamples(t,n,r,\"steps\"),i=[];if(a>0)throw new ze(\"Verbose mode is not implemented yet.\");if(r!=null)throw new ze(\"steps mode in testLoop() is not implemented yet\");{let o=mx(s,n),l=je(Ua(0,s));for(let u=0;u<o.length;++u){let p=o[u][0],d=o[u][1],c=si(l,p,d-p),h=jx(t,c),m=e(h);if(u===0)for(let f=0;f<m.length;++f)i.push(xe(0));for(let f=0;f<m.length;++f){let g=m[f];i[f]=X(i[f],z(d-p,g))}}for(let u=0;u<i.length;++u)i[u]=he(i[u],s)}return i})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let a=e[n],r=a;if(fI(e,a)>1){let s=fI(e.slice(0,n),a);r+=`_${s}`}t.push(r)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),s=[],i=()=>{let l=[];for(let c=0;c<this.inputs.length;++c)l.push({key:this.inputs[c],value:n[c]});let u=new Cl(l),p=tc(this.outputs,u,{training:!0}),d;for(let c=0;c<this.lossFunctions.length;++c){let h=this.lossFunctions[c],m=h(a[c],p[c]);r[c]!=null&&(m=KH(m,r[c]));let f=Ct(m);t.push(f),c===0?d=m:d=X(d,m)}for(let c=0;c<this.metricsTensors.length;++c){let h;if(this.outputs.length>1&&c<this.outputs.length)h=t[c];else{let m=this.metricsTensors[c][0],f=this.metricsTensors[c][1];h=Ct(m(a[f],p[f]))}Ht(h),s.push(h)}return d=Ct(d),this.calculateLosses().forEach(c=>{d=X(d,c)}),d},o=this.collectedTrainableWeights.map(l=>l.read());return[this.optimizer_.minimize(i,!0,o)].concat(s)}}makeTestFunction(){this.testFunction=e=>O(()=>{let t=[],n,a=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let l=0;l<this.inputs.length;++l)s.push({key:this.inputs[l],value:a[l]});let i=new Cl(s),o=tc(this.outputs,i);for(let l=0;l<this.lossFunctions.length;++l){let u=this.lossFunctions[l],p=Ct(u(r[l],o[l]));l===0?n=p:n=X(n,p),t.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let u=this.metricsTensors[l][0],p=this.metricsTensors[l][1],d=Ct(u(r[p],o[p]));t.push(d)}return t})}async fit(e,t,n={}){if(this.isTraining)throw new Error(\"Cannot start training because another fit() call is ongoing.\");this.isTraining=!0;let a,r,s,i,o,l,u,p,d;try{let c=n.batchSize==null?32:n.batchSize;hx(c);let h=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,!1,c);a=h[0],r=h[1],d=h[2];let m=!1,f;if(n.validationData!=null&&n.validationData.length>0){if(m=!0,n.validationData.length===2)o=n.validationData[0],l=n.validationData[1];else throw n.validationData.length===3?new ze(\"validationData including sample weights is not supported yet.\"):new V(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let N=await this.standardizeUserData(o,l,null,null,!0,c);u=N[0],p=N[1],f=u.concat(p)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){m=!0;let N=Math.floor(a[0].shape[0]*(1-n.validationSplit)),C=a[0].shape[0];u=Xp(a,N,C),s=a,a=Xp(a,0,N),p=Xp(r,N,C),i=r,r=Xp(r,0,N),f=u.concat(p)}else n.validationSteps!=null&&(m=!0);let g=a.concat(r).concat(d);this.checkTrainableWeightsConsistency();let b=this.makeTrainFunction(),y=this.getDedupedMetricsNames(),x,v;m?(this.makeTestFunction(),x=this.testFunction,v=y.slice().concat(y.map(N=>\"val_\"+N))):(x=null,f=[],v=y.slice());let I=D2(n.callbacks,n.yieldEvery);return await this.fitLoop(b,g,y,c,n.epochs,n.verbose,I,x,f,n.shuffle,v,n.initialEpoch,null,null)}finally{this.isTraining=!1,Pa(a,e),Pa(r,t),Pa(s,e),Pa(i,t),Pa(u,o),Pa(p,l),d!=null&&Ee(d)}}async fitLoop(e,t,n,a,r,s,i,o,l,u,p,d,c,h){a==null&&(a=32),r==null&&(r=1),u==null&&(u=!0),d==null&&(d=0);let m=!1;if(o!=null&&l!=null&&(m=!0),h!=null&&(m=!0,c==null))throw new V(\"Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.\");let f=this.checkNumSamples(t,a,c,\"steps_per_epoch\"),g;f!=null&&(g=Ua(0,f)),s==null&&(s=1);let{callbackList:b,history:y}=R2(i,s,r,d,f,c,a,m,p);b.setModel(this),this.history=y,await b.onTrainBegin(),this.stopTraining_=!1;for(let x=d;x<r;++x){await b.onEpochBegin(x);let v={};if(c!=null)throw new ze(\"stepsPerEpoch mode is not implemented yet.\");{if(u===\"batch\")throw new ze(\"batch shuffling is not implemneted yet\");u&&w.shuffle(g);let I=je(g),N=mx(f,a);for(let C=0;C<N.length;++C){let _={};if(await b.onBatchBegin(C,_),O(()=>{let F=N[C][0],D=N[C][1],$=si(I,F,D-F);_.batch=C,_.size=D-F;let S=jx(t,$),M=e(S);for(let B=0;B<n.length;++B){let U=n[B],H=M[B];_[U]=H,Ht(H)}if(C===N.length-1&&m){let B=this.testLoop(o,l,a);for(let U=0;U<n.length;++U){let H=n[U],q=B[U];Ht(q),v[\"val_\"+H]=q}}}),await b.onBatchEnd(C,_),_2(_),this.stopTraining_)break}I.dispose()}if(await b.onEpochEnd(x,v),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return ZH(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),a=n[0],r=n[1],s=this.makeTrainFunction()(a.concat(r)),i=[];for(let o of s){let l=await o.data();i.push(l[0])}return Ee(s),Pa(n[0],e),Pa(n[1],t),Mn(i)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,a=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let s=0;s<a.length;++s)n&&!a[s].trainable||t.push({name:a[s].originalName,tensor:r[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=Kh().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Kh().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss==\"string\")e=Ir(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!=\"string\")throw new Error(\"Serialization of non-string loss is not supported.\");e=this.loss.map(t=>Ir(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let a of t)if(typeof n[a]==\"string\")e[a]=Ir(n[a]);else throw new Error(\"Serialization of non-string loss is not supported.\")}return e}getMetricIdentifiers(){if(typeof this.metrics==\"string\"||typeof this.metrics==\"function\")return[Ir(Sh(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Ir(Sh(e)));{let e={};for(let t in this.metrics)e[t]=Ir(Sh(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error(\"Loading weight_metrics is not supported yet.\");if(e.loss_weights!=null)throw new Error(\"Loading loss_weights is not supported yet.\");if(e.sample_weight_mode!=null)throw new Error(\"Loading sample_weight_mode is not supported yet.\");let t=Ic(e.optimizer_config),n=Ba(t),a;if(typeof e.loss==\"string\")a=Js(e.loss);else if(Array.isArray(e.loss))a=e.loss.map(s=>Js(s));else if(e.loss!=null){a={};for(let s in e.loss)a[s]=Js(e.loss[s])}let r;if(Array.isArray(e.metrics))r=e.metrics.map(s=>Js(s));else if(e.metrics!=null){r={};for(let s in e.metrics)r[s]=Js(e.metrics[s])}this.compile({loss:a,metrics:r,optimizer:n})}async save(e,t){if(typeof e==\"string\"){let r=jt.getSaveHandlers(e);if(r.length===0)throw new V(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new V(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new V(\"LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.\");let n=await jt.encodeWeights(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:sj,generatedBy:`TensorFlow.js tfjs-layers v${v0}`,convertedBy:null};if(t!=null&&t.includeOptimizer&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();let r=\"optimizer\",{data:s,specs:i}=await jt.encodeWeights(await this.optimizer.getWeights(),r);n.specs.push(...i),n.data=jt.concatenateArrayBuffers([n.data,s])}return this.userDefinedMetadata!=null&&(NI(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=n.data,a.weightSpecs=n.specs,e.save(a)}setUserDefinedMetadata(e){NI(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};Er.className=\"Model\";ne.registerClass(Er);var H2=class extends Er{};H2.className=\"Functional\";ne.registerClass(H2);async function ij(e,t){\"modelTopology\"in e||(e={modelTopology:e}),e=e;let n=e.modelTopology;n.model_config!=null&&(n=n.model_config);let a=Ic(n),r=Ba(a,t);if(e.weightsManifest!=null){let s=await jt.loadWeights(e.weightsManifest,e.pathPrefix,r.weights.map(o=>o.originalName)),i={};for(let o of r.weights)i[o.originalName]=s[o.originalName];r.loadWeights(i),Ee(s)}return r}async function oj(e,t){if(t==null&&(t={}),typeof e==\"string\"){let n=jt.getLoadHandlers(e,t);if(n.length===0)n.push(jt.browserHTTPRequest(e,t));else if(n.length>1)throw new V(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return lj(e,void 0,t)}async function lj(e,t,n){if(n==null&&(n={}),e.load==null)throw new V(\"Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.\");let a=await e.load(),r=a.modelTopology;r.model_config!=null&&(r=r.model_config);let s=n.strict==null?!0:n.strict,i=a.weightData!=null&&a.weightSpecs!=null&&s,o=Ba(Ic(r),t,i),l=a.trainingConfig;if(l!=null&&o.loadTrainingConfig(l),a.userDefinedMetadata!=null&&o.setUserDefinedMetadata(a.userDefinedMetadata),a.weightData!=null){if(a.weightSpecs==null)throw new V(\"LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.\");let{modelWeights:u,optimizerWeights:p}=uj(a.weightData,a.weightSpecs);o.loadWeights(u,s),o.optimizer!=null&&p.length>0&&await o.optimizer.setWeights(p),Ee(u),Ee(p.map(d=>d.tensor))}return o}function uj(e,t){let n=jt.decodeWeights(e,t),a={},r=[];return t.forEach(s=>{s.group===\"optimizer\"?r.push({name:s.name,tensor:n[s.name]}):a[s.name]=n[s.name]}),{modelWeights:a,optimizerWeights:r}}var Ef=class Kx extends Er{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:gf(\"sequential_\"),t.layers!=null)for(let n of t.layers)this.add(n)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new V(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let n=t instanceof Kx||t instanceof Er,a;if(n){if(a=t,a.outputs.length!==1)throw new V(\"All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.\");if(a.inputs.length!==1)throw new V(\"All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.\")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new V(\"The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.\");let r=S2({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+\"_input\"});t.apply(r)}if(n)this.outputs=a.outputs,this.inputs=a.inputs;else{if(t.inboundNodes.length!==1)throw new V(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new V(\"All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.\");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=I2(this.outputs[0])}this.inboundNodes=[],new Nf({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:bi(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{let r=t.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError(\"All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.\");this.checkShape(t),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError(\"There are no layers in the model.\");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){return this.model==null&&this.build(),this.model.call(t,n)}build(t){if(Je(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError(\"Sequential model cannot be built: model is empty. Add some layers first.\");this.model=new Er({inputs:this.inputs,outputs:this.outputs[0],name:this.name+\"_model\"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,n,a=console.log){this.built||this.build(),super.summary(t,n,a)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,n,a={}){if(!this.built)throw new ar(\"The model needs to be compiled before being used.\");return this.model.evaluate(t,n,a)}async evaluateDataset(t,n){if(!this.built)throw new ar(\"The model needs to be compiled before being used.\");return this.model.evaluateDataset(t,n)}predict(t,n={}){return this.model==null&&this.build(),this.model.predict(t,n)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,a={}){if(!this.built)throw new ar(\"The model needs to be compiled before being used.\");return this.model.fit(t,n,a)}async fitDataset(t,n){if(!this.built)throw new ar(\"The model needs to be compiled before being used.\");return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,a={},r=!1){let s,i={};if(n instanceof Array){if(n[0].className==null||n[0].className===\"Merge\")throw new V(\"Legacy serialization format not supported yet.\");s=n}else w.assert(n.layers!=null,()=>\"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.\"),s=n.layers,delete n.layers,i=n;let o=new t(i);if(!(o instanceof Kx))throw new ze(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(let l of s){let u=Ba(l,void 0,r);r&&u.setFastWeightInitDuringBuild(!0),o.add(u)}return o}set stopTraining(t){if(this.model==null)throw new V(\"Cannot set the stopTraining property of a sequential model before it is compiled.\");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new V(\"Cannot get the stopTraining property of a sequential model before it is compiled.\");return this.model.stopTraining}getConfig(){let t=[];for(let n of this.layers){let a={};a.className=n.getClassName(),a.config=n.getConfig(),t.push(a)}return{name:this.name,layers:t}}};Ef.className=\"Sequential\";ne.registerClass(Ef);function pj(e){return new Er(e)}function cj(e){return new Ef(e)}function j2(e){return S2(e)}function dj(e,t){f0.registerCallbackConstructor(e,t)}var xn=class extends ne.Serializable{getConfig(){return{}}},q2=class extends xn{apply(e,t=1){return FG(e,t)}};q2.className=\"elu\";ne.registerClass(q2);var K2=class extends xn{apply(e){return Qm(e)}};K2.className=\"selu\";ne.registerClass(K2);var X2=class extends xn{apply(e){return Ke(e)}};X2.className=\"relu\";ne.registerClass(X2);var Y2=class extends xn{apply(e){return O(()=>ds(6,Ke(e)))}};Y2.className=\"relu6\";ne.registerClass(Y2);var Z2=class extends xn{apply(e){return e}};Z2.className=\"linear\";ne.registerClass(Z2);var J2=class extends xn{apply(e){return ha(e)}};J2.className=\"sigmoid\";ne.registerClass(J2);var Q2=class extends xn{apply(e){return DG(e)}};Q2.className=\"hardSigmoid\";ne.registerClass(Q2);var eC=class extends xn{apply(e){return Go(e)}};eC.className=\"softplus\";ne.registerClass(eC);var tC=class extends xn{apply(e){return $G(e)}};tC.className=\"softsign\";ne.registerClass(tC);var nC=class extends xn{apply(e){return cs(e)}};nC.className=\"tanh\";ne.registerClass(nC);var w0=class extends xn{apply(e,t=-1){return qa(e,t)}};w0.className=\"softmax\";ne.registerClass(w0);var aC=class extends xn{apply(e,t=-1){return jm(e,t)}};aC.className=\"logSoftmax\";ne.registerClass(aC);var rC=class extends xn{apply(e){return O(()=>O(()=>{let t=Math.sqrt(2),n=z(.5,X(1,Um(he(e,t))));return z(e,n)}))}};rC.className=\"gelu\";ne.registerClass(rC);var sC=class extends xn{apply(e){return O(()=>z(.5,z(e,X(1,cs(z(rn(he(2,Math.PI)),X(e,z(.044715,ur(e,3)))))))))}};sC.className=\"gelu_new\";ne.registerClass(sC);var iC=class extends xn{apply(e){return O(()=>z(e,cs(Go(e))))}};iC.className=\"mish\";ne.registerClass(iC);var oC=class extends xn{apply(e,t=1){return O(()=>z(ha(z(e,t)),e))}};oC.className=\"swish\";ne.registerClass(oC);function ms(e){return e.getClassName()}function fx(e,t={}){return vd(e,ne.SerializationMap.getMap().classNameMap,t,\"activation\")}function fs(e){if(e==null){let t={};return t.className=\"linear\",t.config={},fx(t)}if(typeof e==\"string\"){let t={};return t.className=e,t.config={},fx(t)}else return e instanceof xn?e:fx(e)}function k0(e){if(e!=null&&typeof e!=\"object\")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}var lC=class extends ne.Serializable{},Nd=class extends lC{constructor(e){super(),k0(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return O(()=>{let t=It([1]);return this.hasL1&&(t=X(t,fe(z(this.l1,Lt(e))))),this.hasL2&&(t=X(t,fe(z(this.l2,kd(e))))),W(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};Nd.className=\"L1L2\";ne.registerClass(Nd);function hj(e){return k0(e),new Nd({l1:e!=null?e.l1:null,l2:0})}function mj(e){return k0(e),new Nd({l2:e!=null?e.l2:null,l1:0})}var FI={l1l2:\"L1L2\"};function ft(e){return Qw(e)}function $I(e,t={}){return vd(e,ne.SerializationMap.getMap().classNameMap,t,\"regularizer\")}function Nt(e){if(e==null)return null;if(typeof e==\"string\"){let t={className:e in FI?FI[e]:e,config:{}};return $I(t)}else return e instanceof lC?e:$I(e)}var I0=class extends We{constructor(e){super(e==null?{}:e),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Te(e);let n=Ke(e);return this.maxValue!=null&&(n=an(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};I0.className=\"ReLU\";ne.registerClass(I0);var S0=class extends We{constructor(e){super(e==null?{}:e),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Te(e);return ud(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};S0.className=\"LeakyReLU\";ne.registerClass(S0);var N0=class extends We{constructor(e){if(super(e==null?{}:e),this.DEFAULT_ALPHA_INITIALIZER=\"zeros\",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=St(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Nt(e.alphaRegularizer),this.alphaConstraint=Yt(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes==\"number\")this.sharedAxes=[e.sharedAxes];else throw new V(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Je(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let a of this.sharedAxes)t[a-1]=1;this.alpha=this.addWeight(\"alpha\",t,\"float32\",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let a=1;a<e.length;++a)n[a]=e[a];this.inputSpec=[new zt({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Te(e),fd(e,this.alpha.read())}getConfig(){let e={alphaInitializer:Et(this.alphaInitializer),alphaRegularizer:ft(this.alphaRegularizer),alphaConstraint:Xt(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};N0.className=\"PReLU\";ne.registerClass(N0);var T0=class extends We{constructor(e){if(super(e==null?{}:e),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new ze(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Te(e);return Qu(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};T0.className=\"ELU\";ne.registerClass(T0);var C0=class extends We{constructor(e){super(e==null?{}:e),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=Te(e);return z(n,re(Cn(n,this.theta),\"float32\"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};C0.className=\"ThresholdedReLU\";ne.registerClass(C0);var E0=class extends We{constructor(e){super(e==null?{}:e),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new w0().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return O(()=>{let n=Te(e),a=t.mask;if(a!=null){let r=z(pe(Pn(n.shape),re(a,n.dtype)),xe(-1e9));n=X(n,r)}return this.axis instanceof Array?this.axis.length>1?dn(pe(n,cd(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)})}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};E0.className=\"Softmax\";ne.registerClass(E0);function Fl(e,t,n){if(typeof e==\"number\")return bi(e,t);if(e.length!==t)throw new V(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let a=0;a<t;++a){let r=e[a];if(!CG(r))throw new V(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${r}`)}return e}function Va(e,t,n,a,r=1){if(e==null)return e;let s=t+(t-1)*(r-1),i;return n===\"same\"?i=e:i=e-s+1,Math.floor((i+a-1)/a)}function nr(e,t,n,a){if(e==null)return null;if(a===\"valid\")e=e*t+hs([n-t,0]);else if(a===\"same\")e=e*t;else throw new V(`Unsupport padding mode: ${a}.`);return e}function _0(e,t){return O(()=>(Rt(t),t===\"channelsFirst\"?De(e,[0,2,3,1]):e))}function uC(e,t){return O(()=>(Rt(t),t===\"channelsFirst\"?De(e,[0,2,3,4,1]):e))}function fj(e,t,n,a=1,r=\"valid\",s,i=1){return O(()=>{if(s==null&&(s=Ga()),Rt(s),e.shape.length!==3)throw new V(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new V(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new V(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(s===\"channelsFirst\"&&(e=De(e,[0,2,1])),r===\"causal\")throw new ze(\"The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.\");let o=zm(e,t,a,r===\"same\"?\"same\":\"valid\",\"NWC\",i);return n!=null&&(o=Ka(o,n)),o})}function DI(e,t,n,a=[1,1],r=\"valid\",s,i,o=null){return O(()=>{if(s==null&&(s=Ga()),Rt(s),e.rank!==3&&e.rank!==4)throw new V(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new V(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=_0(e,s);if(r===\"causal\")throw new ze(\"The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.\");return l=Vl.conv2d({x:l,filter:t,strides:a,pad:r===\"same\"?\"same\":\"valid\",dilations:i,dataFormat:\"NHWC\",bias:n,activation:o}),s===\"channelsFirst\"&&(l=De(l,[0,3,1,2])),l})}function gj(e,t,n,a=[1,1,1],r=\"valid\",s,i){return O(()=>{if(s==null&&(s=Ga()),Rt(s),e.rank!==4&&e.rank!==5)throw new V(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new V(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=uC(e,s);if(r===\"causal\")throw new ze(\"The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.\");return o=aw(o,t,a,r===\"same\"?\"same\":\"valid\",\"NDHWC\",i),n!=null&&(o=Ka(o,n)),s===\"channelsFirst\"&&(o=De(o,[0,4,1,2,3])),o})}var pC=class cC extends We{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER=\"glorotNormal\",this.DEFAULT_BIAS_INITIALIZER=\"zeros\",cC.verifyArgs(n),this.rank=t,tn(this.rank,\"rank\"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new ze(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Fl(n.kernelSize,t,\"kernelSize\"),this.strides=Fl(n.strides==null?1:n.strides,t,\"strides\"),this.padding=n.padding==null?\"valid\":n.padding,va(this.padding),this.dataFormat=n.dataFormat==null?\"channelsLast\":n.dataFormat,Rt(this.dataFormat),this.activation=fs(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=St(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Yt(n.biasConstraint),this.biasRegularizer=Nt(n.biasRegularizer),this.activityRegularizer=Nt(n.activityRegularizer),this.dilationRate=Fl(n.dilationRate==null?1:n.dilationRate,t,\"dilationRate\"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new V(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate==\"number\")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new V(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate==\"number\")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new V(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(tr(\"kernelSize\"in t,\"required key 'kernelSize' not in config\"),typeof t.kernelSize!=\"number\"&&!e0(t.kernelSize,\"number\",1,3))throw new V(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:ms(this.activation),useBias:this.useBias,biasInitializer:Et(this.biasInitializer),biasRegularizer:ft(this.biasRegularizer),activityRegularizer:ft(this.activityRegularizer),biasConstraint:Xt(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}},_f=class dC extends pC{constructor(t,n){super(t,n),this.kernel=null,dC.verifyArgs(n),this.filters=n.filters,tn(this.filters,\"filters\"),this.kernelInitializer=St(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Yt(n.kernelConstraint),this.kernelRegularizer=Nt(n.kernelRegularizer)}build(t){t=Je(t);let n=this.dataFormat===\"channelsFirst\"?1:t.length-1;if(t[n]==null)throw new V(`The channel dimension of the input should be defined. Found ${t[n]}`);let a=t[n],r=this.kernelSize.concat([a,this.filters]);this.kernel=this.addWeight(\"kernel\",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight(\"bias\",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:a}}],this.built=!0}call(t,n){return O(()=>{t=Te(t);let a,r=this.bias==null?null:this.bias.read(),s=m2(this.activation.getClassName());if(s!=null&&this.rank===2)a=DI(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)a=fj(t,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)a=DI(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)a=gj(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new ze(\"convolutions greater than 3D are not implemented yet.\");this.activation!=null&&(a=this.activation.apply(a))}return a})}computeOutputShape(t){t=Je(t);let n=[],a=this.dataFormat===\"channelsLast\"?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<a.length;++s){let i=Va(a[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate==\"number\"?this.dilationRate:this.dilationRate[s]);n.push(i)}let r=[t[0]];return this.dataFormat===\"channelsLast\"?(r=r.concat(n),r.push(this.filters)):(r.push(this.filters),r=r.concat(n)),r}getConfig(){let t={filters:this.filters,kernelInitializer:Et(this.kernelInitializer),kernelRegularizer:ft(this.kernelRegularizer),kernelConstraint:Xt(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!(\"filters\"in t)||typeof t.filters!=\"number\"||t.filters<1)throw new V(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},Af=class hC extends _f{constructor(t){super(2,t),hC.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!=\"number\"&&!e0(t.kernelSize,\"number\",1,2))throw new V(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};Af.className=\"Conv2D\";ne.registerClass(Af);var Ff=class mC extends _f{constructor(t){super(3,t),mC.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!=\"number\"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new V(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};Ff.className=\"Conv3D\";ne.registerClass(Ff);var A0=class extends Af{constructor(e){if(super(e),this.inputSpec=[new zt({ndim:4})],this.padding!==\"same\"&&this.padding!==\"valid\")throw new V(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Je(e),e.length!==4)throw new V(\"Input should have rank 4; Received input shape: \"+JSON.stringify(e));let t=this.dataFormat===\"channelsFirst\"?1:e.length-1;if(e[t]==null)throw new V(\"The channel dimension of the inputs should be defined. Found `None`.\");let n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight(\"kernel\",a,\"float32\",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight(\"bias\",[this.filters],\"float32\",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new zt({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return O(()=>{let n=Te(e);if(n.shape.length!==4)throw new V(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let a=n.shape,r=a[0],s,i;this.dataFormat===\"channelsFirst\"?(s=2,i=3):(s=1,i=2);let o=a[s],l=a[i],u=this.kernelSize[0],p=this.kernelSize[1],d=this.strides[0],c=this.strides[1],h=nr(o,d,u,this.padding),m=nr(l,c,p,this.padding),f=[r,h,m,this.filters];this.dataFormat!==\"channelsLast\"&&(n=De(n,[0,2,3,1]));let g=Wm(n,this.kernel.read(),f,this.strides,this.padding);return this.dataFormat!==\"channelsLast\"&&(g=De(g,[0,3,1,2])),this.bias!=null&&(g=Ka(g,this.bias.read(),this.dataFormat)),this.activation!=null&&(g=this.activation.apply(g)),g})}computeOutputShape(e){e=Je(e);let t=e.slice(),n,a,r;this.dataFormat===\"channelsFirst\"?(n=1,a=2,r=3):(n=3,a=1,r=2);let s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[a]=nr(t[a],o,s,this.padding),t[r]=nr(t[r],l,i,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};A0.className=\"Conv2DTranspose\";ne.registerClass(A0);var F0=class extends Ff{constructor(e){if(super(e),this.inputSpec=[new zt({ndim:5})],this.padding!==\"same\"&&this.padding!==\"valid\")throw new V(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Je(e),e.length!==5)throw new V(\"Input should have rank 5; Received input shape: \"+JSON.stringify(e));let t=this.dataFormat===\"channelsFirst\"?1:e.length-1;if(e[t]==null)throw new V(\"The channel dimension of the inputs should be defined. Found `None`.\");let n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight(\"kernel\",a,\"float32\",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight(\"bias\",[this.filters],\"float32\",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new zt({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return O(()=>{let n=Te(e);if(n.shape.length!==5)throw new V(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let a=n.shape,r=a[0],s,i,o;this.dataFormat===\"channelsFirst\"?(o=2,s=3,i=4):(o=1,s=2,i=3);let l=a[o],u=a[s],p=a[i],d=this.kernelSize[0],c=this.kernelSize[1],h=this.kernelSize[2],m=this.strides[0],f=this.strides[1],g=this.strides[2],b=nr(l,m,d,this.padding),y=nr(u,f,c,this.padding),x=nr(p,g,h,this.padding),v=[r,b,y,x,this.filters];this.dataFormat!==\"channelsLast\"&&(n=De(n,[0,2,3,4,1]));let I=rw(n,this.kernel.read(),v,this.strides,this.padding);return this.dataFormat!==\"channelsLast\"&&(I=De(I,[0,4,1,2,3])),this.bias!==null&&(I=Ka(I,this.bias.read(),this.dataFormat)),this.activation!==null&&(I=this.activation.apply(I)),I})}computeOutputShape(e){e=Je(e);let t=e.slice(),n,a,r,s;this.dataFormat===\"channelsFirst\"?(n=1,a=2,r=3,s=4):(n=4,a=1,r=2,s=3);let i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],p=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[a]=nr(t[a],u,i,this.padding),t[r]=nr(t[r],p,o,this.padding),t[s]=nr(t[s],d,l,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};F0.className=\"Conv3DTranspose\";ne.registerClass(F0);var fC=class extends _f{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER=\"glorotUniform\",this.DEFAULT_POINTWISE_INITIALIZER=\"glorotUniform\",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new V(\"The `filters` configuration field is required by SeparableConv, but is unspecified.\");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new V(\"Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.\");if(t.padding!=null&&t.padding!==\"same\"&&t.padding!==\"valid\")throw new V(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=St(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Nt(t.depthwiseRegularizer),this.depthwiseConstraint=Yt(t.depthwiseConstraint),this.pointwiseInitializer=St(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Nt(t.pointwiseRegularizer),this.pointwiseConstraint=Yt(t.pointwiseConstraint)}build(e){if(e=Je(e),e.length<this.rank+2)throw new V(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat===\"channelsFirst\"?1:e.length-1;if(e[t]==null||e[t]<0)throw new V(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],a=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let i=0;i<this.rank;++i)r.push(1);r.push(n*this.depthMultiplier,this.filters);let s=!0;this.depthwiseKernel=this.addWeight(\"depthwise_kernel\",a,\"float32\",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight(\"pointwise_kernel\",r,\"float32\",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight(\"bias\",[this.filters],\"float32\",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new zt({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return O(()=>{e=Te(e);let n;if(this.rank===1)throw new ze(\"1D separable convolution is not implemented yet.\");return this.rank===2&&(this.dataFormat===\"channelsFirst\"&&(e=De(e,[0,2,3,1])),n=_s(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,\"NHWC\")),this.useBias&&(n=Ka(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat===\"channelsFirst\"&&(n=De(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Et(this.depthwiseInitializer),e.pointwiseInitializer=Et(this.pointwiseInitializer),e.depthwiseRegularizer=ft(this.depthwiseRegularizer),e.pointwiseRegularizer=ft(this.pointwiseRegularizer),e.depthwiseConstraint=Xt(this.depthwiseConstraint),e.pointwiseConstraint=Xt(this.pointwiseConstraint),e}};fC.className=\"SeparableConv\";var $0=class extends fC{constructor(e){super(2,e)}};$0.className=\"SeparableConv2D\";ne.registerClass($0);var D0=class gC extends _f{constructor(t){super(1,t),gC.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!=\"number\"&&!e0(t.kernelSize,\"number\",1,1))throw new V(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};D0.className=\"Conv1D\";ne.registerClass(D0);var R0=class extends We{constructor(e){super(e),typeof e.cropping==\"number\"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]==\"number\"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?\"channelsLast\":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat===\"channelsFirst\"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return O(()=>{if(e=Te(e),this.dataFormat===\"channelsLast\"){let n=Ih(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Ih(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=Ih(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Ih(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};R0.className=\"Cropping2D\";ne.registerClass(R0);var M0=class extends We{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?\"channelsLast\":e.dataFormat,Rt(this.dataFormat),this.interpolation=e.interpolation==null?\"nearest\":e.interpolation,SG(this.interpolation)}computeOutputShape(e){if(this.dataFormat===\"channelsFirst\"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return O(()=>{let n=Te(e),a=n.shape;if(this.dataFormat===\"channelsFirst\"){n=De(n,[0,2,3,1]);let r=this.size[0]*a[2],s=this.size[1]*a[3],i=this.interpolation===\"nearest\"?Zn.resizeNearestNeighbor(n,[r,s]):Zn.resizeBilinear(n,[r,s]);return De(i,[0,3,1,2])}else{let r=this.size[0]*a[1],s=this.size[1]*a[2];return this.interpolation===\"nearest\"?Zn.resizeNearestNeighbor(n,[r,s]):Zn.resizeBilinear(n,[r,s])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};M0.className=\"UpSampling2D\";ne.registerClass(M0);function bj(e,t,n=[1,1],a=\"valid\",r,s){return O(()=>{r==null&&(r=Ga()),Rt(r);let i=_0(e,r);if(e.rank!==4)throw new V(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new V(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=Ts(i,t,n,a===\"same\"?\"same\":\"valid\",\"NHWC\",s),r===\"channelsFirst\"&&(i=De(i,[0,3,1,2])),i})}var O0=class extends pC{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=St(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Yt(e.depthwiseConstraint),this.depthwiseRegularizer=Nt(e.depthwiseRegularizer)}build(e){if(e=Je(e),e.length<4)throw new V(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat===\"channelsFirst\"?1:3;if(e[t]==null||e[t]<0)throw new V(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],a=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight(\"depthwise_kernel\",a,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight(\"bias\",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return O(()=>{e=Te(e);let n=bj(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=Ka(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=Je(e);let t=this.dataFormat===\"channelsFirst\"?e[2]:e[1],n=this.dataFormat===\"channelsFirst\"?e[3]:e[2],a=this.dataFormat===\"channelsFirst\"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=Va(t,this.kernelSize[0],this.padding,this.strides[0]),s=Va(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat===\"channelsFirst\"?[e[0],a,r,s]:[e[0],r,s,a]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Et(this.depthwiseInitializer),e.depthwiseRegularizer=ft(this.depthwiseRegularizer),e.depthwiseConstraint=Xt(this.depthwiseRegularizer),e}};O0.className=\"DepthwiseConv2D\";ne.registerClass(O0);function bC(e,t,n,a){if(Array.isArray(e)){if(t!=null||n!=null)throw new V(\"When inputs is an array, neither initialState or constants should be provided\");a!=null&&(n=e.slice(e.length-a,e.length),e=e.slice(0,e.length-a)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function r(s){return s==null||Array.isArray(s)?s:[s]}return t=r(t),n=r(n),{inputs:e,initialState:t,constants:n}}function yC(e,t,n,a=!1,r,s,i=!1,o=!1){return O(()=>{let l=t.shape.length;if(l<3)throw new V(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(Ua(2,l));if(t=De(t,u),s!=null)throw new ze(\"The rnn() functoin of the deeplearn.js backend does not support constants yet.\");i&&console.warn(\"Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend.\"),r!=null&&(r=re(re(r,\"bool\"),\"float32\"),r.rank===l-1&&(r=Gt(r,-1)),r=De(r,u)),a&&(t=ba(t,0),r!=null&&(r=ba(r,0)));let p=[],d,c=n,h=t.shape[0],m=dt(t),f;r!=null&&(f=dt(r));for(let b=0;b<h;++b){let y=m[b],x=O(()=>e(y,c));if(r==null)d=x[0],c=x[1];else{let v=O(()=>{let I=f[b],N=pe(ea(I),I),C=X(z(x[0],I),z(c[0],N)),_=c.map((F,D)=>X(z(x[1][D],I),z(F,N)));return{output:C,newStates:_}});d=v.output,c=v.newStates}o&&p.push(d)}let g;return o&&(g=At(p,1)),[d,g,c]})}var Mr=class xC extends We{constructor(t){super(t);let n;if(t.cell==null)throw new V(\"cell property is missing for the constructor of RNN.\");if(Array.isArray(t.cell)?n=new Rf({cells:t.cell}):n=t.cell,n.stateSize==null)throw new V(\"The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).\");this.cell=n,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new zt({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Ua(0,t).map(n=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){Vx(t)&&(t=t[0]),t=t;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);let a=n[0],r;if(this.returnSequences?r=[t[0],t[1],a]:r=[t[0],a],this.returnState){let s=[];for(let i of n)s.push([t[0],i]);return[r].concat(s)}else return r}computeMask(t,n){return O(()=>{Array.isArray(n)&&(n=n[0]);let a=this.returnSequences?n:null;if(this.returnState){let r=this.states.map(s=>null);return[a].concat(r)}else return a})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let a=0;a<t;++a)n.push(null);return n}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new ze(\"Constants support is not implemented in RNN yet.\");Vx(t)&&(t=t[0]),t=t;let n=this.stateful?t[0]:null,a=t.slice(2);this.inputSpec[0]=new zt({shape:[n,null,...a]});let r=[t[0]].concat(t.slice(2));this.cell.build(r);let s;if(Array.isArray(this.cell.stateSize)?s=this.cell.stateSize:s=[this.cell.stateSize],this.stateSpec!=null){if(!w.arraysEqual(this.stateSpec.map(i=>i.shape[i.shape.length-1]),s))throw new V(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(i=>new zt({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(t,n=!1){O(()=>{if(!this.stateful)throw new Xr(\"Cannot call resetStates() on an RNN Layer that is not stateful.\");let a=this.inputSpec[0].shape[0];if(a==null)throw new V(\"If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \\n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.\");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>It([a,r])):this.states_=[It([a,this.cell.stateSize])];else if(t==null)Ee(this.states_),this.keptStates!=null&&(Ee(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>It([a,r])):this.states_[0]=It([a,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new V(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n===!0?this.keptStates.push(this.states_.slice()):Ee(this.states_);for(let r=0;r<this.states_.length;++r){let s=t[r],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,o=[a,i];if(!w.arraysEqual(s.shape,o))throw new V(`State ${r} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${s.shape}`);this.states_[r]=s}}this.states_=this.states_.map(r=>Ht(r.clone()))})}apply(t,n){let a=n==null?null:n.initialState,r=n==null?null:n.constants;n==null&&(n={});let s=bC(t,a,r,this.numConstants);t=s.inputs,a=s.initialState,r=s.constants;let i=[],o=[];if(a!=null){n.initialState=a,i=i.concat(a),this.stateSpec=[];for(let l of a)this.stateSpec.push(new zt({shape:l.shape}));o=o.concat(this.stateSpec)}if(r!=null&&(n.constants=r,i=i.concat(r),this.numConstants=r.length),i[0]instanceof Ha){let l=[t].concat(i),u=this.inputSpec.concat(o),p=this.inputSpec;this.inputSpec=u;let d=super.apply(l,n);return this.inputSpec=p,d}else return super.apply(t,n)}call(t,n){return O(()=>{let a=n==null?null:n.mask,r=n==null?null:n.training,s=n==null?null:n.initialState;t=Te(t),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(t));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==i)throw new V(`RNN Layer has ${i} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn(\"Ignoring unroll = true for RNN layer, due to imperative backend.\");let o={training:r},l=yC((h,m)=>{let f=this.cell.call([h].concat(m),o);return[f[0],f.slice(1)]},t,s,this.goBackwards,a,null,this.unroll,this.returnSequences),u=l[0],p=l[1],d=l[2];this.stateful&&this.resetStates(d,r);let c=this.returnSequences?p:u;return this.returnState?[c].concat(d):c})}getInitialState(t){return O(()=>{let n=It(t.shape);return n=fe(n,[1,2]),n=wd(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(a=>a>1?Wx(n,[1,a]):n):this.cell.stateSize>1?[Wx(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);let a=this.cell.getConfig();return this.getClassName()===xC.className&&(n.cell={className:this.cell.getClassName(),config:a}),Object.assign(Object.assign(Object.assign({},a),t),n)}static fromConfig(t,n,a={}){let r=n.cell,s=Ba(r,a);return new t(Object.assign(n,{cell:s}))}};Mr.className=\"RNN\";ne.registerClass(Mr);var Td=class extends We{},$f=class extends Td{constructor(e){super(e),this.DEFAULT_ACTIVATION=\"tanh\",this.DEFAULT_KERNEL_INITIALIZER=\"glorotNormal\",this.DEFAULT_RECURRENT_INITIALIZER=\"orthogonal\",this.DEFAULT_BIAS_INITIALIZER=\"zeros\",this.units=e.units,tn(this.units,\"units\"),this.activation=fs(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=St(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=St(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=St(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Nt(e.kernelRegularizer),this.recurrentRegularizer=Nt(e.recurrentRegularizer),this.biasRegularizer=Nt(e.biasRegularizer),this.kernelConstraint=Yt(e.kernelConstraint),this.recurrentConstraint=Yt(e.recurrentConstraint),this.biasConstraint=Yt(e.biasConstraint),this.dropout=Ul([1,hs([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Ul([1,hs([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Je(e),this.kernel=this.addWeight(\"kernel\",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight(\"recurrent_kernel\",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight(\"bias\",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return O(()=>{if(e=e,e.length!==2)throw new V(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let a=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=gs({ones:()=>ea(e),rate:this.dropout,training:a,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=gs({ones:()=>ea(n),rate:this.recurrentDropout,training:a,dropoutFunc:this.dropoutFunc}));let r,s=this.dropoutMask,i=this.recurrentDropoutMask;s!=null?r=or(z(e,s),this.kernel.read()):r=or(e,this.kernel.read()),this.bias!=null&&(r=Ka(r,this.bias.read())),i!=null&&(n=z(n,i));let o=X(r,or(n,this.recurrentKernel.read()));return this.activation!=null&&(o=this.activation.apply(o)),[o,o]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:ms(this.activation),useBias:this.useBias,kernelInitializer:Et(this.kernelInitializer),recurrentInitializer:Et(this.recurrentInitializer),biasInitializer:Et(this.biasInitializer),kernelRegularizer:ft(this.kernelRegularizer),recurrentRegularizer:ft(this.recurrentRegularizer),biasRegularizer:ft(this.biasRegularizer),activityRegularizer:ft(this.activityRegularizer),kernelConstraint:Xt(this.kernelConstraint),recurrentConstraint:Xt(this.recurrentConstraint),biasConstraint:Xt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};$f.className=\"SimpleRNNCell\";ne.registerClass($f);var P0=class extends Mr{constructor(e){e.cell=new $f(e),super(e)}call(e,t){return O(()=>{this.cell.dropoutMask!=null&&(Ee(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ee(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return new e(t)}};P0.className=\"SimpleRNN\";ne.registerClass(P0);var Df=class extends Td{constructor(e){if(super(e),this.DEFAULT_ACTIVATION=\"tanh\",this.DEFAULT_RECURRENT_ACTIVATION=\"hardSigmoid\",this.DEFAULT_KERNEL_INITIALIZER=\"glorotNormal\",this.DEFAULT_RECURRENT_INITIALIZER=\"orthogonal\",this.DEFAULT_BIAS_INITIALIZER=\"zeros\",e.resetAfter)throw new V(\"GRUCell does not support reset_after parameter set to true.\");this.units=e.units,tn(this.units,\"units\"),this.activation=fs(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=fs(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=St(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=St(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=St(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Nt(e.kernelRegularizer),this.recurrentRegularizer=Nt(e.recurrentRegularizer),this.biasRegularizer=Nt(e.biasRegularizer),this.kernelConstraint=Yt(e.kernelConstraint),this.recurrentConstraint=Yt(e.recurrentConstraint),this.biasConstraint=Yt(e.biasConstraint),this.dropout=Ul([1,hs([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Ul([1,hs([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Je(e);let t=e[e.length-1];this.kernel=this.addWeight(\"kernel\",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight(\"recurrent_kernel\",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight(\"bias\",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return O(()=>{if(e=e,e.length!==2)throw new V(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,a=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=gs({ones:()=>ea(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=gs({ones:()=>ea(a),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let r=this.dropoutMask,s=this.recurrentDropoutMask,i,o,l;0<this.dropout&&this.dropout<1&&(e=z(e,r[0]));let u=or(e,this.kernel.read());this.useBias&&(u=Ka(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(a=z(a,s[0]));let p=this.recurrentKernel.read(),[d,c]=Ln(p,[2*this.units,this.units],p.rank-1),h=or(a,d),[m,f,g]=Ln(u,3,u.rank-1),[b,y]=Ln(h,2,h.rank-1);i=this.recurrentActivation.apply(X(m,b)),o=this.recurrentActivation.apply(X(f,y));let x=or(z(o,a),c);l=this.activation.apply(X(g,x));let v=X(z(i,a),z(X(1,yt(i)),l));return[v,v]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:ms(this.activation),recurrentActivation:ms(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Et(this.kernelInitializer),recurrentInitializer:Et(this.recurrentInitializer),biasInitializer:Et(this.biasInitializer),kernelRegularizer:ft(this.kernelRegularizer),recurrentRegularizer:ft(this.recurrentRegularizer),biasRegularizer:ft(this.biasRegularizer),activityRegularizer:ft(this.activityRegularizer),kernelConstraint:Xt(this.kernelConstraint),recurrentConstraint:Xt(this.recurrentConstraint),biasConstraint:Xt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};Df.className=\"GRUCell\";ne.registerClass(Df);var L0=class extends Mr{constructor(e){e.implementation===0&&console.warn(\"`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call.\"),e.cell=new Df(e),super(e)}call(e,t){return O(()=>{this.cell.dropoutMask!=null&&(Ee(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ee(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};L0.className=\"GRU\";ne.registerClass(L0);var Cd=class extends Td{constructor(e){super(e),this.DEFAULT_ACTIVATION=\"tanh\",this.DEFAULT_RECURRENT_ACTIVATION=\"hardSigmoid\",this.DEFAULT_KERNEL_INITIALIZER=\"glorotNormal\",this.DEFAULT_RECURRENT_INITIALIZER=\"orthogonal\",this.DEFAULT_BIAS_INITIALIZER=\"zeros\",this.units=e.units,tn(this.units,\"units\"),this.activation=fs(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=fs(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=St(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=St(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=St(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Nt(e.kernelRegularizer),this.recurrentRegularizer=Nt(e.recurrentRegularizer),this.biasRegularizer=Nt(e.biasRegularizer),this.kernelConstraint=Yt(e.kernelConstraint),this.recurrentConstraint=Yt(e.recurrentConstraint),this.biasConstraint=Yt(e.biasConstraint),this.dropout=Ul([1,hs([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Ul([1,hs([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=Je(e);let n=e[e.length-1];this.kernel=this.addWeight(\"kernel\",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight(\"recurrent_kernel\",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let a;if(this.useBias){if(this.unitForgetBias){let r=this.biasInitializer,s=this.units;a=new(t=class extends $a{apply(i,o){let l=r.apply([s]),u=new yf().apply([s]),p=r.apply([s*2]);return bI(bI(l,u),p)}},t.className=\"CustomInit\",t)}else a=this.biasInitializer;this.bias=this.addWeight(\"bias\",[this.units*4],null,a,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return O(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new V(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let a=e[1],r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=gs({ones:()=>ea(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=gs({ones:()=>ea(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,i=this.recurrentDropoutMask,o,l,u,p;0<this.dropout&&this.dropout<1&&(e=z(e,s[0]));let d=or(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(a=z(a,i[0])),d=X(d,or(a,this.recurrentKernel.read())),this.useBias&&(d=Ka(d,this.bias.read()));let[c,h,m,f]=Ln(d,4,d.rank-1);o=this.recurrentActivation.apply(c),l=this.recurrentActivation.apply(h),u=X(z(l,r),z(o,this.activation.apply(m))),p=this.recurrentActivation.apply(f);let g=z(p,this.activation.apply(u));return[g,g,u]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:ms(this.activation),recurrentActivation:ms(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Et(this.kernelInitializer),recurrentInitializer:Et(this.recurrentInitializer),biasInitializer:Et(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:ft(this.kernelRegularizer),recurrentRegularizer:ft(this.recurrentRegularizer),biasRegularizer:ft(this.biasRegularizer),activityRegularizer:ft(this.activityRegularizer),kernelConstraint:Xt(this.kernelConstraint),recurrentConstraint:Xt(this.recurrentConstraint),biasConstraint:Xt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};Cd.className=\"LSTMCell\";ne.registerClass(Cd);var z0=class extends Mr{constructor(e){e.implementation===0&&console.warn(\"`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call.\"),e.cell=new Cd(e),super(e)}call(e,t){return O(()=>{this.cell.dropoutMask!=null&&(Ee(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ee(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};z0.className=\"LSTM\";ne.registerClass(z0);var Rf=class extends Td{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return O(()=>{e=e;let n=e.slice(1),a=[];for(let i of this.cells.slice().reverse())Array.isArray(i.stateSize)?a.push(n.splice(0,i.stateSize.length)):a.push(n.splice(0,1));a.reverse();let r=[],s;for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=a[i],i===0?s=[e[0]].concat(n):s=[s[0]].concat(n),s=o.call(s,t),r.push(s.slice(1))}n=[];for(let i of r.slice().reverse())n.push(...i);return[s[0]].concat(n)})}build(e){Vx(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,a)=>{ri(`RNNCell_${a}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=a=>({className:a.getClassName(),config:a.getConfig()}),n={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),n)}static fromConfig(e,t,n={}){let a=[];for(let r of t.cells)a.push(Ba(r,n));return new e({cells:a})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return Ux(e)}setWeights(e){let t=[];for(let n of this.cells){let a=n.weights.length,r=e.splice(a);for(let s=0;s<n.weights.length;++s)t.push([n.weights[s],r[s]])}u0(t)}};Rf.className=\"StackedRNNCells\";ne.registerClass(Rf);function gs(e){let{ones:t,rate:n,training:a=!1,count:r=1,dropoutFunc:s}=e,i=()=>s!=null?s(t(),n):w2(t(),n),o=()=>Id(i,t,a);return!r||r<=1?Ht(o().clone()):Array(r).fill(void 0).map(o).map(l=>Ht(l.clone()))}var yj=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(e!=null&&typeof Object.getOwnPropertySymbols==\"function\")for(var r=0,a=Object.getOwnPropertySymbols(e);r<a.length;r++)t.indexOf(a[r])<0&&Object.prototype.propertyIsEnumerable.call(e,a[r])&&(n[a[r]]=e[a[r]]);return n},vC=class extends Mr{constructor(e){if(e.unroll)throw new ze(\"Unrolling is not possible with convolutional RNNs.\");if(Array.isArray(e.cell))throw new ze(\"It is not possible at the moment to stack convolutional cells.\");super(e),this.inputSpec=[new zt({ndim:5})]}call(e,t){return O(()=>{if(this.cell.dropoutMask!=null&&(Ee(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ee(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new V(\"ConvRNN2D cell does not support constants\");let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return O(()=>{let{stateSize:t}=this.cell,n=e.shape,a=this.computeSingleOutputShape(n),r=[a[0],...a.slice(2)],s=It(r);return Array.isArray(t)?Array(t.length).fill(s):[s]})}resetStates(e,t=!1){O(()=>{if(!this.stateful)throw new Xr(\"Cannot call resetStates() on an RNN Layer that is not stateful.\");let n=this.inputSpec[0].shape,a=this.computeSingleOutputShape(n),r=[a[0],...a.slice(2)];if(n[0]==null)throw new V(\"If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \\n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.\");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>It(r)):this.states_=[It(r)];else if(e==null)Ee(this.states_),this.keptStates!=null&&(Ee(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>It(r)):this.states_[0]=It(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new V(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Ee(this.states_);for(let s=0;s<this.states_.length;++s){let i=e[s],o=r;if(!w.arraysEqual(i.shape,o))throw new V(`State ${s} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${i.shape}`);this.states_[s]=i}}this.states_=this.states_.map(s=>Ht(s.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:a,padding:r,strides:s,dilationRate:i}=this.cell,o=t===\"channelsFirst\",l=e[o?3:2],u=e[o?4:3],p=Va(l,a[0],r,s[0],i[0]),d=Va(u,a[1],r,s[1],i[1]);return[...e.slice(0,2),...o?[n,p,d]:[p,d,n]]}};vC.className=\"ConvRNN2D\";var Mf=class extends Cd{constructor(e){let{filters:t,kernelSize:n,strides:a,padding:r,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,tn(this.filters,\"filters\"),this.kernelSize=Fl(n,2,\"kernelSize\"),this.kernelSize.forEach(o=>tn(o,\"kernelSize\")),this.strides=Fl(a||1,2,\"strides\"),this.strides.forEach(o=>tn(o,\"strides\")),this.padding=r||\"valid\",va(this.padding),this.dataFormat=s||\"channelsLast\",Rt(this.dataFormat),this.dilationRate=Fl(i||1,2,\"dilationRate\"),this.dilationRate.forEach(o=>tn(o,\"dilationRate\"))}build(e){var t;e=Je(e);let n=this.dataFormat===\"channelsFirst\"?1:e.length-1;if(e[n]==null)throw new V(`The channel dimension of the input should be defined. Found ${e[n]}`);let a=e[n],r=4,s=this.kernelSize.concat([a,this.filters*r]);this.kernel=this.addWeight(\"kernel\",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*r]);if(this.recurrentKernel=this.addWeight(\"recurrent_kernel\",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let o;if(this.unitForgetBias){let l=this.biasInitializer,u=this.filters;o=new(t=class extends $a{apply(p,d){let c=l.apply([u]),h=Pn([u]),m=l.apply([u*2]);return t0([c,h,m])}},t.className=\"CustomInit\",t)}else o=this.biasInitializer;this.bias=this.addWeight(\"bias\",[this.filters*r],null,o,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return O(()=>{if(e.length!==3)throw new V(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,a=e[0],r=e[1],s=e[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=gs({ones:()=>ea(a),rate:this.dropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,l=(Z,J,ee)=>!J||!J[ee]?Z:z(J[ee],Z),u=l(a,o,0),p=l(a,o,1),d=l(a,o,2),c=l(a,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=gs({ones:()=>ea(r),rate:this.recurrentDropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let h=this.recurrentDropoutMask,m=l(r,h,0),f=l(r,h,1),g=l(r,h,2),b=l(r,h,3),y=3,[x,v,I,N]=Ln(this.kernel.read(),i,y),[C,_,F,D]=this.useBias?Ln(this.bias.read(),i):[null,null,null,null];u=this.inputConv(u,x,C,this.padding),p=this.inputConv(p,v,_,this.padding),d=this.inputConv(d,I,F,this.padding),c=this.inputConv(c,N,D,this.padding);let[$,S,M,B]=Ln(this.recurrentKernel.read(),i,y);m=this.recurrentConv(m,$),f=this.recurrentConv(f,S),g=this.recurrentConv(g,M),b=this.recurrentConv(b,B);let U=this.recurrentActivation.apply(X(u,m)),H=this.recurrentActivation.apply(X(p,f)),q=X(z(H,s),z(U,this.activation.apply(X(d,g)))),K=z(this.recurrentActivation.apply(X(c,b)),this.activation.apply(q));return[K,K,q]})}getConfig(){let e=super.getConfig(),{units:t}=e,n=yj(e,[\"units\"]),a={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),a)}inputConv(e,t,n,a){let r=$t(e,t,this.strides,a||\"valid\",this.dataFormat===\"channelsFirst\"?\"NCHW\":\"NHWC\",this.dilationRate);return n?Ka(r,n,this.dataFormat):r}recurrentConv(e,t){return $t(e,t,1,\"same\",this.dataFormat===\"channelsFirst\"?\"NCHW\":\"NHWC\")}};Mf.className=\"ConvLSTM2DCell\";ne.registerClass(Mf);var W0=class extends vC{constructor(e){let t=new Mf(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};W0.className=\"ConvLSTM2D\";ne.registerClass(W0);var Of=class extends We{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let a=0;a<this.noiseShape.length;++a)n.push(this.noiseShape[a]==null?t[a]:this.noiseShape[a]);return n}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Te(e);if(0<this.rate&&this.rate<1){let a=t.training==null?!1:t.training,r=this.getNoiseShape(n);return Id(()=>w2(n,this.rate,r,this.seed),()=>n,a)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};Of.className=\"Dropout\";ne.registerClass(Of);var B0=class extends Of{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};B0.className=\"SpatialDropout1D\";ne.registerClass(B0);var V0=class extends We{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER=\"glorotNormal\",this.DEFAULT_BIAS_INITIALIZER=\"zeros\",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,tn(this.units,\"units\"),this.activation=fs(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=St(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=St(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Yt(e.kernelConstraint),this.biasConstraint=Yt(e.biasConstraint),this.kernelRegularizer=Nt(e.kernelRegularizer),this.biasRegularizer=Nt(e.biasRegularizer),this.activityRegularizer=Nt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Je(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight(\"kernel\",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight(\"bias\",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=Je(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Te(e),a=m2(this.activation.getClassName()),r;return a!=null?r=or(n,this.kernel.read(),a,this.bias?this.bias.read():null):(r=or(n,this.kernel.read()),this.bias!=null&&(r=Ka(r,this.bias.read())),this.activation!=null&&(r=this.activation.apply(r))),r})}getConfig(){let e={units:this.units,activation:ms(this.activation),useBias:this.useBias,kernelInitializer:Et(this.kernelInitializer),biasInitializer:Et(this.biasInitializer),kernelRegularizer:ft(this.kernelRegularizer),biasRegularizer:ft(this.biasRegularizer),activityRegularizer:ft(this.activityRegularizer),kernelConstraint:Xt(this.kernelConstraint),biasConstraint:Xt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};V0.className=\"Dense\";ne.registerClass(V0);var U0=class extends We{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Je(e);for(let t of e.slice(1))if(t==null)throw new V(`The shape of the input to \"Flatten\" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete \"input_shape\" or \"batch_input_shape\" argument to the first layer in your model.`);return[e[0],rs(e,1)]}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Te(e);if(this.dataFormat===\"channelsFirst\"&&n.rank>1){let a=[0];for(let r=2;r<n.rank;++r)a.push(r);a.push(1),n=De(n,a)}return AG(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};U0.className=\"Flatten\";ne.registerClass(U0);var G0=class extends We{constructor(e){super(e),this.supportsMasking=!0,this.activation=fs(e.activation)}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Te(e);return this.activation.apply(n)})}getConfig(){let e={activation:ms(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};G0.className=\"Activation\";ne.registerClass(G0);var H0=class extends We{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return O(()=>(e=Te(e),EG(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};H0.className=\"RepeatVector\";ne.registerClass(H0);var j0=class extends We{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n=\"Total size of new array must be unchanged.\",a=t.slice(),r=1,s=null;for(let o=0;o<a.length;++o){let l=a[o];if(this.isUnknown(l))if(s===null)s=o;else throw new V(\"Can only specifiy one unknown dimension.\");else r*=l}let i=rs(e);if(s!==null){if(r===0||i%r!==0)throw new V(n);a[s]=i/r}else if(i!==r)throw new V(n);return a}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Te(e),a=n.shape,r=a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape));return W(n,r)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};j0.className=\"Reshape\";ne.registerClass(j0);var q0=class extends We{constructor(e){if(super(e),e.dims==null)throw new Error(\"Required configuration field `dims` is missing during Permute constructor call.\");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \\`dims\\` to be an Array, but received ${e.dims} instead.`);let t=Ua(1,e.dims.length+1);if(!w.arraysEqual(e.dims.slice().sort(),t))throw new Error(\"Invalid permutation `dims`: \"+JSON.stringify(e.dims)+\" `dims` must contain consecutive integers starting from 1.\");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new zt({ndim:this.dims.length+1})]}computeOutputShape(e){e=Je(e);let t=e.slice();return this.dims.forEach((n,a)=>{t[a+1]=e[n]}),t}call(e,t){return De(Te(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};q0.className=\"Permute\";ne.registerClass(q0);var K0=class extends We{constructor(e){super(e==null?{}:e),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=Te(e);return yc(fi(n,this.maskValue),-1)}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Te(e),a=yc(fi(n,this.maskValue),-1,!0);return z(n,re(a,n.dtype))})}};K0.className=\"Masking\";ne.registerClass(K0);var X0=class extends We{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER=\"randomUniform\",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(it(e.inputLength))}this.inputDim=e.inputDim,tn(this.inputDim,\"inputDim\"),this.outputDim=e.outputDim,tn(this.outputDim,\"outputDim\"),this.embeddingsInitializer=St(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Nt(e.embeddingsRegularizer),this.activityRegularizer=Nt(e.activityRegularizer),this.embeddingsConstraint=Yt(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight(\"embeddings\",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return O(()=>this.maskZero?(e=Te(e),fi(e,qe(e))):null)}computeOutputShape(e){if(e=Je(e),this.inputLength==null)return[...e,this.outputDim];let t=it(this.inputLength);if(t.length!==e.length-1)throw new V(`\"inputLength\" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let a=0;a<t.length;++a){let r=t[a],s=e[a+1];if(r!=null&&s!=null&&r!==s)throw new V(`\"inputLength\" is ${this.inputLength}, but received input shape has shape ${e}`);r==null&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Te(e);n.dtype!==\"int32\"&&(n=ir(n,\"int32\"));let a=v2(this.embeddings.read(),W(n,[n.size]));return W(a,Je(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Et(this.embeddingsInitializer),embeddingsRegularizer:ft(this.embeddingsRegularizer),activityRegularizer:ft(this.activityRegularizer),embeddingsConstraint:Xt(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};X0.className=\"Embedding\";ne.registerClass(X0);var Yo=class extends We{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new ze}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let a=0;a<t.length;++a){let r=e[e.length-t.length+a],s=t[a];if(r==null||s==null||r<0||s<0)n.push(null);else if(r===1)n.push(s);else if(s===1)n.push(r);else{if(r!==s)throw new V(\"Operands could not be broadcast together with shapes \"+JSON.stringify(e)+\" \"+JSON.stringify(t));n.push(r)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Je(e)]),e=e,e.length<2)throw new V(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let r of e)r!=null&&r[0]!==null&&t.push(r[0]);if(t=as(t),t.length>1)throw new V(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let r=1;r<e.length;++r){let s=e[r]==null?null:e[r].slice(1);n=this.computeElementwiseOpOutputShape(n,s)}let a=e.map(r=>r.length);e.indexOf(null)===-1&&as(a).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return O(()=>{if(e=e,this.reshapeRequired){let n=[],a=e.map(r=>r.rank);if(a.indexOf(null)===-1){let r=hs(a);for(let s of e){let i=s.rank;for(let o=0;o<r-i;++o)s=wd(s,1);n.push(s)}return this.mergeFunction(n)}else{let r=!1;for(let o of e){let l=o.rank;if(l==null){let u=o.shape,p=u[0],d=u.slice(1).concat([p]),c=W(o,[p].concat(rs(u.slice(1))));c=De(c,[1,0]),c=W(c,d),n.push(c),r=!0}else if(l>1){let u=Ua(1,l).concat([0]);n.push(De(o,u)),r=!0}else n.push(o)}let s=this.mergeFunction(n),i=s.rank;if(r){if(i==null){let o=s.shape,l=o.length,u=o[l-1],p=[u].concat(o.slice(0,o.length-1));s=W(De(W(s,[-1,u]),[1,0]),p)}else if(i>1){let o=[i-1].concat(Ua(0,i-1));s=De(s,o)}}return s}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let a=1;a<e.length;++a){let r=e[a]==null?null:e[a].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let n=[];for(let a of e)a!=null&&a[0]!==null&&n.push(a[0]);return n=as(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return O(()=>{if(t==null)return null;if(!Array.isArray(t))throw new V(\"`mask` should be an Array\");if(!Array.isArray(e))throw new V(\"`inputs` should be an Array\");if(t.length!==e.length)throw new V(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(a=>a==null))return null;t=t.map(a=>a==null?a:Gt(a,0));let n=t[0];for(let a=1;a<t.length-1;++a)n=_a(n,t[a]);return n})}},Y0=class extends Yo{constructor(e){super(e)}mergeFunction(e){return O(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=X(t,e[n]);return t})}};Y0.className=\"Add\";ne.registerClass(Y0);var Z0=class extends Yo{constructor(e){super(e)}mergeFunction(e){return O(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=z(t,e[n]);return t})}};Z0.className=\"Multiply\";ne.registerClass(Z0);var J0=class extends Yo{constructor(e){super(e)}mergeFunction(e){return O(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=X(t,e[n]);return z(1/e.length,t)})}};J0.className=\"Average\";ne.registerClass(J0);var Q0=class extends Yo{constructor(e){super(e)}mergeFunction(e){return O(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=hr(t,e[n]);return t})}};Q0.className=\"Maximum\";ne.registerClass(Q0);var e1=class extends Yo{constructor(e){super(e)}mergeFunction(e){return O(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=ds(t,e[n]);return t})}};e1.className=\"Minimum\";ne.registerClass(e1);var t1=class extends Yo{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new V(\"A `Concatenate` layer should be called on a list of at least 2 inputs\");e=e;let t=!0;for(let a of e)if(a!=null){t=!1;break}if(t)return;let n=[];for(let a=0;a<e.length;++a){let r=e[a].slice();r.splice(this.axis,1);let s=!1;for(let i of n)if(w.arraysEqual(i,r)){s=!0;break}s||n.push(r)}if(n.length>1)throw new V(\"A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: \"+JSON.stringify(e))}mergeFunction(e){return O(()=>t0(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new V(\"A `Concatenate` layer should be called on a list of inputs.\");let t=e,n=t[0].slice(),a=this.axis<0?n.length+this.axis:this.axis;for(let r of t.slice(1)){if(n[a]==null||r[a]==null){n[a]=null;break}n[a]+=r[a]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new V(\"`mask` should be an array for Concatenate\");if(!Array.isArray(e))throw new V(\"`inputs` should be an array for Concatenate\");if(t.length!==e.length)throw new V(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return O(()=>{let n=!0;if(t.forEach(s=>{if(s!=null){n=!1;return}}),n)return null;let a=[];for(let s=0;s<e.length;++s)t[s]==null?a.push(re(ea(e[s]),\"bool\")):t[s].rank<e[s].rank?a.push(Gt(t[s],-1)):a.push(t[s]);let r=et(a,this.axis);return Lm(r,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};t1.className=\"Concatenate\";ne.registerClass(t1);function Yp(e,t){for(;e<0;)e+=t;return e}function xj(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new ze(\"batchDot is not implemented for tensors of 4D or higher rank yet\");if(w.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),w.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n==\"number\"&&(n=[n,n]),e.dtype===\"complex64\"||t.dtype===\"complex64\")throw new ze(\"batchDot is not implemented for complex64-type Tensors yet.\");let a=e.shape.length,r=t.shape.length;n==null&&(n=[a-1,r-2]);let s=n;return O(()=>{let i;if(a>r){i=a-r;let l=[];for(let u=0;u<i;++u)l.push(1);t=W(t,t.shape.concat(l))}else if(r>a){i=r-a;let l=[];for(let u=0;u<i;++u)l.push(1);e=W(e,e.shape.concat(l))}else i=0;let o;if(e.shape.length===2&&t.shape.length===2)s[0]===s[1]?o=fe(z(e,t),s[0]):o=fe(z(De(e,[1,0]),t),s[1]);else{let l=s[0]!==e.shape.length-1,u=s[1]===t.shape.length-1;o=$e(e,t,l,u)}if(i>0){let l;a>r?l=a+r-3:l=a-1;let u=[];for(let p=l;p<l+i;++p)u.push(p);o=As(o,u)}return o.shape.length===1&&(o=Gt(o,1)),o})}var n1=class extends Yo{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){w.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>\"A `Dot` layer should be called on a list of exactly 2 inputs.\");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new ze(\"Dot layer does not support tensors of 4D or higher rank yet.\");let a=this.interpretAxes(t,n);if(t[a[0]]!==n[a[1]])throw new V(`Dimension incompatibility: ${t[a[0]]} !== ${n[a[1]]}`)}mergeFunction(e){if(e.length!==2)throw new V(`A \\`Dot\\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],a;return Array.isArray(this.axes)?a=this.axes.map((r,s)=>Yp(r,e[s].shape.length)):a=[Yp(this.axes,t.shape.length),Yp(this.axes,n.shape.length)],this.normalize&&(t=tm(t,a[0]),n=tm(n,a[1])),xj(t,n,a)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[Yp(this.axes,e.length),Yp(this.axes,t.length)],n}computeOutputShape(e){w.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>\"A `Dot` layer should be called on a list of exactly 2 inputs.\");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new ze(\"Dot layer does not support tensors of 4D or higher rank yet.\");let a=this.interpretAxes(t,n);t.splice(a[0],1),n.splice(a[1],1),n.splice(0,1);let r=t.concat(n);return r.length===1&&r.push(1),r}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};n1.className=\"Dot\";ne.registerClass(n1);var a1=class extends We{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Te(e);return Id(()=>X(bf(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}};a1.className=\"GaussianNoise\";ne.registerClass(a1);var r1=class extends We{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Te(e);return this.rate>0&&this.rate<1?Id(()=>{let a=Math.sqrt(this.rate/(1-this.rate));return z(n,bf(n.shape,1,a))},()=>n,t.training||!1):n})}};r1.className=\"GaussianDropout\";ne.registerClass(r1);var s1=class extends We{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Te(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return O(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return Id(()=>{let a=Te(e),r=-1.6732632423543772*1.0507009873554805,s=$r(Es(n),this.rate);s=ir(s,\"float32\");let i=((1-this.rate)*(1+this.rate*r**2))**-.5,o=-i*r*this.rate,l=X(z(a,s),z(X(s,-1),r));return X(z(l,i),o)},()=>Te(e),t.training||!1)}return e})}};s1.className=\"AlphaDropout\";ne.registerClass(s1);function Sc(e,t,n,a,r,s=.001){let i;if(e.rank===2)i=qv(e,t,n,a,r,s);else if(e.rank===3)i=Kv(e,t,n,a,r,s);else if(e.rank===4)i=Xv(e,t,n,a,r,s);else throw new ze(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}function vj(e,t,n,a,r=.001){return O(()=>{let s=hd(e,a),i=s.mean,o=s.variance;return[Sc(e,i,o,n,t,r),i,o]})}function wj(e,t,n,a,r=.001){return O(()=>{let s=hd(e,a),i=s.mean,o=s.variance,l=[];for(let h of Ua(0,e.rank))a.indexOf(h)!==-1?l.push(1):l.push(e.shape[h]);let u=W(i,l),p=W(o,l),d=t==null?null:W(t,l),c=n==null?null:W(n,l);return[Sc(e,u,p,c,d,r),i,o]})}function kj(e,t,n,a,r=.001){return w.arraysEqual(a.slice().sort(),Ua(0,e.rank-1))?vj(e,t,n,a,r):wj(e,t,n,a,r)}var i1=class extends We{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=St(e.betaInitializer||\"zeros\"),this.gammaInitializer=St(e.gammaInitializer||\"ones\"),this.movingMeanInitializer=St(e.movingMeanInitializer||\"zeros\"),this.movingVarianceInitializer=St(e.movingVarianceInitializer||\"ones\"),this.betaConstraint=Yt(e.betaConstraint),this.gammaConstraint=Yt(e.gammaConstraint),this.betaRegularizer=Nt(e.betaRegularizer),this.gammaRegularizer=Nt(e.gammaRegularizer)}build(e){e=Je(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new V(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new zt({ndim:e.length,axes:{[t]:n}})];let a=[n];this.scale&&(this.gamma=this.addWeight(\"gamma\",a,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight(\"beta\",a,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight(\"moving_mean\",a,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight(\"moving_variance\",a,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return O(()=>{let n=t.training==null?!1:t.training,a=Te(e),r=a.shape,s=r.length,i=Ua(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);let l=bi(1,s);l[o]=r[o];let u=i.slice();u.sort();let p=!w.arraysEqual(u,Ua(0,s).slice(0,s-1)),d=()=>{if(p){let g=W(this.movingMean.read(),l),b=W(this.movingVariance.read(),l),y=this.center?W(this.beta.read(),l):null,x=this.scale?W(this.gamma.read(),l):null;return Sc(a,g,b,y,x,this.epsilon)}else return Sc(a,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return d();let[c,h,m]=kj(a,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(g,b,y)=>{O(()=>{let x=1-y,v=g.read(),I=z(pe(v,b),x);g.write(pe(v,I))})};return f(this.movingMean,h,this.momentum),f(this.movingVariance,m,this.momentum),c})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Et(this.betaInitializer),gammaInitializer:Et(this.gammaInitializer),movingMeanInitializer:Et(this.movingMeanInitializer),movingVarianceInitializer:Et(this.movingVarianceInitializer),betaRegularizer:ft(this.betaRegularizer),gammaRegularizer:ft(this.gammaRegularizer),betaConstraint:Xt(this.betaConstraint),gammaConstraint:Xt(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};i1.className=\"BatchNormalization\";ne.registerClass(i1);var o1=class extends We{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis==\"number\"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=St(e.betaInitializer||\"zeros\"),this.gammaInitializer=St(e.gammaInitializer||\"ones\"),this.betaRegularizer=Nt(e.betaRegularizer),this.gammaRegularizer=Nt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Je(e);let t=e.length;typeof this.axis==\"number\"&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=t);for(let r of this.axis)if(r<0||r>=t)throw new Error(`Invalid axis: ${r}`);if(this.axis.length!==as(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(r=>e[r]),a=!0;this.scale?this.gamma=this.addWeight(\"gamma\",n,\"float32\",this.gammaInitializer,this.gammaRegularizer,a):this.gamma=null,this.center?this.beta=this.addWeight(\"beta\",n,\"float32\",this.betaInitializer,this.betaRegularizer,a):this.beta=null,this.built=!0}call(e,t){let n=Te(e),a=n.shape,r=a.length;return O(()=>{let{mean:s,variance:i}=hd(n,this.axis,!0),o=bi(1,r);for(let h of this.axis)o[h]=a[h];let l=h=>h!=null&&h.shape.length!==r?W(h,o):h,u=this.scale?l(this.gamma.read()):null,p=this.center?l(this.beta.read()):null,d=[],c=[];for(let h=0;h<r;++h)this.axis.indexOf(h)!==-1?(d.push(a[h]),c.push(1)):(d.push(1),c.push(a[h]));return s=On(s,d),i=On(i,d),u!=null&&(u=On(u,c)),p!=null&&(p=On(p,c)),Sc(n,s,i,p,u,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Et(this.betaInitializer),gammaInitializer:Et(this.gammaInitializer),betaRegularizer:ft(this.betaRegularizer),gammaRegularizer:ft(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};o1.className=\"LayerNormalization\";ne.registerClass(o1);function Ij(e,t,n){return O(()=>{if(e.rank!==4)throw new V(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new V(\"spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.\");if(n==null&&(n=Ga()),n!==\"channelsLast\"&&n!==\"channelsFirst\")throw new V(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let a;return n===\"channelsFirst\"?a=[[0,0],[0,0],t[0],t[1]]:a=[[0,0],t[0],t[1],[0,0]],xa(e,a)})}var l1=class extends We{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Ga():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding==\"number\")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new V(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]==\"number\")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new V(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new V(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new zt({ndim:4})]}computeOutputShape(e){e=Je(e);let t,n;return this.dataFormat===\"channelsFirst\"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return O(()=>Ij(Te(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};l1.className=\"ZeroPadding2D\";ne.registerClass(l1);function Pf(e,t,n,a,r,s){return O(()=>{Rt(r),g2(s),va(a),n==null&&(n=[1,1]),a==null&&(a=\"valid\"),r==null&&(r=Ga()),s==null&&(s=\"max\"),e=_0(e,r);let i,o=a===\"same\"?\"same\":\"valid\";return s===\"max\"?i=Dt(e,t,n,o):i=ya(e,t,n,o),r===\"channelsFirst\"&&(i=De(i,[0,3,1,2])),i})}function wC(e,t,n,a,r,s){return O(()=>{Rt(r),g2(s),va(a),n==null&&(n=[1,1,1]),a==null&&(a=\"valid\"),r==null&&(r=Ga()),s==null&&(s=\"max\"),e=uC(e,r);let i,o=a===\"same\"?\"same\":\"valid\";return s===\"max\"?i=xw(e,t,n,o):i=jv(e,t,n,o),r===\"channelsFirst\"&&(i=De(i,[0,4,1,2,3])),i})}var kC=class extends We{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize==\"number\")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]==\"number\")this.poolSize=e.poolSize;else throw new V(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(tn(this.poolSize,\"poolSize\"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides==\"number\")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]==\"number\")this.strides=e.strides;else throw new V(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);tn(this.strides,\"strides\"),this.padding=e.padding==null?\"valid\":e.padding,va(this.padding),this.inputSpec=[new zt({ndim:3})]}computeOutputShape(e){e=Je(e);let t=Va(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return O(()=>{this.invokeCallHook(e,t),e=wd(Te(e),2);let n=this.poolingFunction(Te(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,\"channelsLast\");return As(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},u1=class extends kC{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Rt(r),va(a),Pf(e,t,n,a,r,\"max\")}};u1.className=\"MaxPooling1D\";ne.registerClass(u1);var p1=class extends kC{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Rt(r),va(a),Pf(e,t,n,a,r,\"avg\")}};p1.className=\"AveragePooling1D\";ne.registerClass(p1);var IC=class extends We{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new V(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];tn(this.poolSize,\"poolSize\"),tn(this.strides,\"strides\"),this.padding=e.padding==null?\"valid\":e.padding,this.dataFormat=e.dataFormat==null?\"channelsLast\":e.dataFormat,Rt(this.dataFormat),va(this.padding),this.inputSpec=[new zt({ndim:4})]}computeOutputShape(e){e=Je(e);let t=this.dataFormat===\"channelsFirst\"?e[2]:e[1],n=this.dataFormat===\"channelsFirst\"?e[3]:e[2];return t=Va(t,this.poolSize[0],this.padding,this.strides[0]),n=Va(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat===\"channelsFirst\"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return O(()=>(this.invokeCallHook(e,t),this.poolingFunction(Te(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},c1=class extends IC{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Rt(r),va(a),Pf(e,t,n,a,r,\"max\")}};c1.className=\"MaxPooling2D\";ne.registerClass(c1);var d1=class extends IC{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Rt(r),va(a),Pf(e,t,n,a,r,\"avg\")}};d1.className=\"AveragePooling2D\";ne.registerClass(d1);var SC=class extends We{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new V(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];tn(this.poolSize,\"poolSize\"),tn(this.strides,\"strides\"),this.padding=e.padding==null?\"valid\":e.padding,this.dataFormat=e.dataFormat==null?\"channelsLast\":e.dataFormat,Rt(this.dataFormat),va(this.padding),this.inputSpec=[new zt({ndim:5})]}computeOutputShape(e){e=Je(e);let t=this.dataFormat===\"channelsFirst\"?e[2]:e[1],n=this.dataFormat===\"channelsFirst\"?e[3]:e[2],a=this.dataFormat===\"channelsFirst\"?e[4]:e[3];return t=Va(t,this.poolSize[0],this.padding,this.strides[0]),n=Va(n,this.poolSize[1],this.padding,this.strides[1]),a=Va(a,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat===\"channelsFirst\"?[e[0],e[1],t,n,a]:[e[0],t,n,a,e[4]]}call(e,t){return O(()=>(this.invokeCallHook(e,t),this.poolingFunction(Te(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},h1=class extends SC{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Rt(r),va(a),wC(e,t,n,a,r,\"max\")}};h1.className=\"MaxPooling3D\";ne.registerClass(h1);var m1=class extends SC{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Rt(r),va(a),wC(e,t,n,a,r,\"avg\")}};m1.className=\"AveragePooling3D\";ne.registerClass(m1);var NC=class extends We{constructor(e){super(e),this.inputSpec=[new zt({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new ze}},f1=class extends NC{constructor(e){super(e||{})}call(e,t){return O(()=>{let n=Te(e);return Ct(n,1)})}};f1.className=\"GlobalAveragePooling1D\";ne.registerClass(f1);var g1=class extends NC{constructor(e){super(e||{})}call(e,t){return O(()=>{let n=Te(e);return ma(n,1)})}};g1.className=\"GlobalMaxPooling1D\";ne.registerClass(g1);var TC=class extends We{constructor(e){super(e),this.dataFormat=e.dataFormat==null?\"channelsLast\":e.dataFormat,Rt(this.dataFormat),this.inputSpec=[new zt({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat===\"channelsLast\"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new ze}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},b1=class extends TC{call(e,t){return O(()=>{let n=Te(e);return this.dataFormat===\"channelsLast\"?Ct(n,[1,2]):Ct(n,[2,3])})}};b1.className=\"GlobalAveragePooling2D\";ne.registerClass(b1);var y1=class extends TC{call(e,t){return O(()=>{let n=Te(e);return this.dataFormat===\"channelsLast\"?ma(n,[1,2]):ma(n,[2,3])})}};y1.className=\"GlobalMaxPooling2D\";ne.registerClass(y1);var CC=class extends We{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let a=t.layer,r=Ba(a,n);delete t.layer;let s={layer:r};return Object.assign(s,t),new e(s)}},x1=class extends CC{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Je(e),e.length<3)throw new V(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Je(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),a=e[1];return[n[0],a].concat(n.slice(1))}call(e,t){return O(()=>(e=Te(e),yC((n,a)=>[Te(this.layer.call(n,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};x1.className=\"TimeDistributed\";ne.registerClass(x1);function Sj(e){Ko(IG,\"BidirectionalMergeMode\",e)}var Nj=\"concat\",v1=class extends CC{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Ba(n),t.goBackwards=t.goBackwards!==!0;let a={};if(a.className=e.layer.getClassName(),a.config=t,this.backwardLayer=Ba(a),this.forwardLayer.name=\"forward_\"+this.forwardLayer.name,this.backwardLayer.name=\"backward_\"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?Nj:e.mergeMode,Sj(this.mergeMode),e.weights)throw new ze(\"weights support is not implemented for Bidirectional layer yet.\");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,a,r;return this.returnState&&(r=t.slice(1)),n=t[0],n=n,this.mergeMode===\"concat\"?(n[n.length-1]*=2,a=[n]):this.mergeMode==null?a=[n,n.slice()]:a=[n],this.returnState?this.mergeMode==null?a.concat(r).concat(r.slice()):[n].concat(r).concat(r.slice()):Mn(a)}apply(e,t){let n=t==null?null:t.initialState,a=t==null?null:t.constants;t==null&&(t={});let r=bC(e,n,a,this.numConstants);if(e=r.inputs,n=r.initialState,a=r.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&a==null)return super.apply(e,t);let s=[],i=[];if(n!=null){let l=n.length;if(l%2>0)throw new V(\"When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.\");t.initialState=n,s.push(...n);let u=n.map(p=>new zt({shape:p.shape}));this.forwardLayer.stateSpec=u.slice(0,l/2),this.backwardLayer.stateSpec=u.slice(l/2),i.push(...u)}if(a!=null)throw new ze(\"Support for constants in Bidirectional layers is not implemented yet.\");let o=s[0]instanceof Ha;for(let l of s)if(l instanceof Ha!==o)throw new V(\"The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors\");if(o){let l=[e].concat(s),u=this.inputSpec.concat(i),p=this.inputSpec;this.inputSpec=u;let d=super.apply(l,t);return this.inputSpec=p,d}else return super.apply(e,t)}call(e,t){return O(()=>{let n=t.initialState,a,r;if(n==null)a=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{let o=n.slice(0,n.length/2),l=n.slice(n.length/2);a=this.forwardLayer.call(e,Object.assign(t,{initialState:o})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:l}))}let s;this.returnState&&(Array.isArray(a)&&(s=a.slice(1).concat(r.slice(1))),a=a[0],r=r[0]),this.returnSequences&&(r=ba(r,1));let i;return this.mergeMode===\"concat\"?i=t0([a,r]):this.mergeMode===\"sum\"?i=X(a,r):this.mergeMode===\"ave\"?i=z(.5,X(a,r)):this.mergeMode===\"mul\"?i=z(a,r):this.mergeMode==null&&(i=[a,r]),this.returnState?this.mergeMode==null?i.concat(s):[i].concat(s):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){ri(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),ri(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let a=this.forwardLayer.states.map(r=>null);return Array.isArray(n)?n.concat(a).concat(a):[n].concat(a).concat(a)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=Ba(t.layer);if(delete t.layer,t.numConstants!=null)throw new ze(\"Deserialization of a Bidirectional layer with numConstants present is not supported yet.\");let a=t;return a.layer=n,new e(a)}};v1.className=\"Bidirectional\";ne.registerClass(v1);var w1=class extends We{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return O(()=>(e=Te(e),e.dtype!==\"float32\"&&(e=ir(e,\"float32\")),X(z(e,this.scale),this.offset)))}};w1.className=\"Rescaling\";ne.registerClass(w1);var{resizeBilinear:Tj,cropAndResize:Cj}=Zn,k1=class extends We{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,a,r,s,i,o){return O(()=>{let l,u=!1,p=t/s,d=n/i,c=(a+t)/s,h=(r+n)/i,m=[p,d,c,h],f=[];e.rank===3?(u=!0,l=At([e])):l=e;for(let x=0;x<l.shape[0];x++)f.push(m);let g=bn(f,[f.length,4]),b=gi(0,f.length,1,\"int32\"),y=Cj(l,g,b,[a,r],\"nearest\");return ir(u?Te(dt(y)):y,o)})}upsize(e,t,n,a){return O(()=>{let r=Tj(e,[t,n]);return ir(r,a)})}call(e,t){return O(()=>{let n=Te(e),a=n.dtype,r=n.shape,s=r[r.length-3],i=r[r.length-2],o=0;s!==this.height&&(o=Math.floor((s-this.height)/2));let l=0;return i!==this.width&&(l=Math.floor((i-this.width)/2),l===0&&(l=1)),o>=0&&l>=0?this.centerCrop(n,o,l,this.height,this.width,s,i,a):this.upsize(e,this.height,this.width,a)})}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Je(e);let t=e.length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};k1.className=\"CenterCrop\";ne.registerClass(k1);function Ej(e,t,n,a){let r=Te(e);if(r.dtype!==\"int32\"&&(r=ir(r,\"int32\")),t===\"int\")return r;let s=r.shape;if(r.rank===0&&(r=Gt(r,-1)),t===\"oneHot\"&&r.shape[r.shape.length-1]!==1&&(r=Gt(r,-1)),r.rank>2)throw new V(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${r.rank}.`);let i=[\"multiHot\",\"oneHot\"].includes(t),o=r,l;if(typeof a!=\"undefined\"&&t===\"count\"?l=Xh(o,a,n,i):l=Xh(o,[],n,i),t!==\"tfIdf\")return l;if(a)return z(l,a);throw new V(\"When outputMode is 'tfIdf', weights must be provided.\")}var I1=class extends We{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode=\"multiHot\"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=Je(e),e==null?[this.numTokens]:this.outputMode===\"oneHot\"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return O(()=>{e=Te(e),e.dtype!==\"int32\"&&(e=ir(e,\"int32\"));let n;if(typeof t.countWeights!=\"undefined\"){if(this.outputMode!==\"count\")throw new V(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=Te(t.countWeights)}let a=ma(e),r=Ol(e),s=Cn(this.numTokens,a).bufferSync().get(0),i=$r(r,0).bufferSync().get(0);if(!(s&&i))throw new V(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return Ej(e,this.outputMode,this.numTokens,n)})}};I1.className=\"CategoryEncoding\";ne.registerClass(I1);var _j=[\"bilinear\",\"nearest\"],RI=new Set(_j),S1=class extends We{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(RI.has(e.interpolation))this.interpolation=e.interpolation;else throw new V(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation=\"bilinear\";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=Je(e);let t=e[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return O(()=>{let n=[this.height,this.width];if(this.interpolation===\"bilinear\")return Zn.resizeBilinear(e,n,!this.cropToAspectRatio);if(this.interpolation===\"nearest\")return Zn.resizeNearestNeighbor(e,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...RI]} are supported`)})}};S1.className=\"Resizing\";ne.registerClass(S1);var EC=class{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}};EC.className=\"RandomSeed\";var _C=class extends We{constructor(e){super(e),this.randomGenerator=new EC(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}};_C.className=\"BaseRandomLayer\";var Aj=[\"bilinear\",\"nearest\"],MI=new Set(Aj),N1=class extends _C{constructor(e){super(e);let{factor:t,interpolation:n=\"bilinear\"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new V(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new V(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new V(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n)if(MI.has(n))this.interpolation=n;else throw new V(`Invalid interpolation parameter: ${n} is not implemented`)}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Je(e);let t=e[2];return[this.imgHeight,-1,t]}call(e,t){return O(()=>{let n=Te(e);this.imgHeight=n.shape[n.shape.length-3];let a=n.shape[n.shape.length-2];this.widthFactor=Es([1],1+this.widthLower,1+this.widthUpper,\"float32\",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*a;r=Math.round(r);let s=[this.imgHeight,r];switch(this.interpolation){case\"bilinear\":return Zn.resizeBilinear(e,s);case\"nearest\":return Zn.resizeNearestNeighbor(e,s);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...MI]} are supported`)}})}};N1.className=\"RandomWidth\";ne.registerClass(N1);function Fj(e){return new rp(e)}function $j(e){return new T0(e)}function Dj(e){return new I0(e)}function Rj(e){return new S0(e)}function Mj(e){return new N0(e)}function Oj(e){return new E0(e)}function Pj(e){return new C0(e)}function Lj(e){return new D0(e)}function zj(e){return new Af(e)}function Wj(e){return new A0(e)}function Bj(e){return new Ff(e)}function Vj(e){return new F0(e)}function Uj(e){return new $0(e)}function Gj(e){return new R0(e)}function Hj(e){return new M0(e)}function jj(e){return new O0(e)}function qj(e){return new G0(e)}function Kj(e){return new V0(e)}function Xj(e){return new Of(e)}function Yj(e){return new B0(e)}function Zj(e){return new U0(e)}function Jj(e){return new H0(e)}function Qj(e){return new j0(e)}function e6(e){return new q0(e)}function t6(e){return new X0(e)}function n6(e){return new Y0(e)}function a6(e){return new J0(e)}function r6(e){return new t1(e)}function s6(e){return new Q0(e)}function i6(e){return new e1(e)}function o6(e){return new Z0(e)}function l6(e){return new n1(e)}function u6(e){return new i1(e)}function p6(e){return new o1(e)}function c6(e){return new l1(e)}function T1(e){return new p1(e)}function d6(e){return T1(e)}function h6(e){return T1(e)}function C1(e){return new d1(e)}function m6(e){return C1(e)}function f6(e){return C1(e)}function E1(e){return new m1(e)}function g6(e){return E1(e)}function b6(e){return E1(e)}function y6(e){return new f1(e)}function x6(e){return new b1(e)}function AC(e){return new g1(e)}function FC(e){return new y1(e)}function $C(e){return new u1(e)}function DC(e){return new c1(e)}function v6(e){return new h1(e)}function w6(e){return new L0(e)}function k6(e){return new Df(e)}function I6(e){return new z0(e)}function S6(e){return new Cd(e)}function N6(e){return new P0(e)}function T6(e){return new $f(e)}function C6(e){return new W0(e)}function E6(e){return new Mf(e)}function _6(e){return new Mr(e)}function A6(e){return new Rf(e)}function F6(e){return new v1(e)}function $6(e){return new x1(e)}var D6=AC,R6=FC,M6=$C,O6=DC;function P6(e){return new a1(e)}function L6(e){return new r1(e)}function z6(e){return new s1(e)}function W6(e){return new K0(e)}function B6(e){return new w1(e)}function V6(e){return new k1(e)}function U6(e){return new S1(e)}function G6(e){return new I1(e)}function H6(e){return new N1(e)}var RC={};_e(RC,{MAPE:()=>nq,MSE:()=>sq,binaryAccuracy:()=>j6,binaryCrossentropy:()=>q6,categoricalAccuracy:()=>X6,categoricalCrossentropy:()=>Y6,cosineProximity:()=>Q6,mape:()=>aq,meanAbsoluteError:()=>eq,meanAbsolutePercentageError:()=>tq,meanSquaredError:()=>rq,mse:()=>iq,precision:()=>Z6,r2Score:()=>oq,recall:()=>J6,sparseCategoricalAccuracy:()=>K6});function j6(e,t){return b0(e,t)}function q6(e,t){return P2(e,t)}function K6(e,t){return L2(e,t)}function X6(e,t){return y0(e,t)}function Y6(e,t){return x0(e,t)}function Z6(e,t){return O2(e,t)}function J6(e,t){return _H(e,t)}function Q6(e,t){return g0(e,t)}function eq(e,t){return Tf(e,t)}function tq(e,t){return sp(e,t)}function nq(e,t){return sp(e,t)}function aq(e,t){return sp(e,t)}function rq(e,t){return Xo(e,t)}function sq(e,t){return Xo(e,t)}function iq(e,t){return Xo(e,t)}function oq(e,t){return AH(e,t)}var MC={};_e(MC,{modelFromJSON:()=>ij});var OC={};_e(OC,{l1:()=>uq,l1l2:()=>lq,l2:()=>pq});function lq(e){return new Nd(e)}function uq(e){return hj(e)}function pq(e){return mj(e)}var PC=class extends Gl{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof Er))throw new Error(\"model must be a LayersModel, not some other Container\");this.model=e}};function Nh(e,t){return e<t}function OI(e,t){return e>t}var LC=class extends PC{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new ze(\"restoreBestWeights = True is not implemented in EarlyStopping yet.\");this.monitor=e.monitor||\"val_loss\",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||\"auto\",this.baseline=e.baseline,[\"auto\",\"min\",\"max\"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode=\"auto\"),this.mode===\"min\"?this.monitorFunc=Nh:this.mode===\"max\"?this.monitorFunc=OI:this.monitor.indexOf(\"acc\")!==-1?this.monitorFunc=OI:this.monitorFunc=Nh,this.monitorFunc===Nh&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===Nh?1/0:-1/0}async onEpochEnd(e,t){await Kr(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function cq(e){return new LC(e)}var dq={earlyStopping:cq},hq=G();hq.registerFlag(\"KEEP_INTERMEDIATE_TENSORS\",()=>!1,e=>{e&&console.warn(\"Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.\")});var qn;(function(e){e[e.DT_INVALID=0]=\"DT_INVALID\",e[e.DT_FLOAT=1]=\"DT_FLOAT\",e[e.DT_DOUBLE=2]=\"DT_DOUBLE\",e[e.DT_INT32=3]=\"DT_INT32\",e[e.DT_UINT8=4]=\"DT_UINT8\",e[e.DT_INT16=5]=\"DT_INT16\",e[e.DT_INT8=6]=\"DT_INT8\",e[e.DT_STRING=7]=\"DT_STRING\",e[e.DT_COMPLEX64=8]=\"DT_COMPLEX64\",e[e.DT_INT64=9]=\"DT_INT64\",e[e.DT_BOOL=10]=\"DT_BOOL\",e[e.DT_QINT8=11]=\"DT_QINT8\",e[e.DT_QUINT8=12]=\"DT_QUINT8\",e[e.DT_QINT32=13]=\"DT_QINT32\",e[e.DT_BFLOAT16=14]=\"DT_BFLOAT16\",e[e.DT_QINT16=15]=\"DT_QINT16\",e[e.DT_QUINT16=16]=\"DT_QUINT16\",e[e.DT_UINT16=17]=\"DT_UINT16\",e[e.DT_COMPLEX128=18]=\"DT_COMPLEX128\",e[e.DT_HALF=19]=\"DT_HALF\",e[e.DT_RESOURCE=20]=\"DT_RESOURCE\",e[e.DT_VARIANT=21]=\"DT_VARIANT\",e[e.DT_UINT32=22]=\"DT_UINT32\",e[e.DT_UINT64=23]=\"DT_UINT64\",e[e.DT_FLOAT_REF=101]=\"DT_FLOAT_REF\",e[e.DT_DOUBLE_REF=102]=\"DT_DOUBLE_REF\",e[e.DT_INT32_REF=103]=\"DT_INT32_REF\",e[e.DT_UINT8_REF=104]=\"DT_UINT8_REF\",e[e.DT_INT16_REF=105]=\"DT_INT16_REF\",e[e.DT_INT8_REF=106]=\"DT_INT8_REF\",e[e.DT_STRING_REF=107]=\"DT_STRING_REF\",e[e.DT_COMPLEX64_REF=108]=\"DT_COMPLEX64_REF\",e[e.DT_INT64_REF=109]=\"DT_INT64_REF\",e[e.DT_BOOL_REF=110]=\"DT_BOOL_REF\",e[e.DT_QINT8_REF=111]=\"DT_QINT8_REF\",e[e.DT_QUINT8_REF=112]=\"DT_QUINT8_REF\",e[e.DT_QINT32_REF=113]=\"DT_QINT32_REF\",e[e.DT_BFLOAT16_REF=114]=\"DT_BFLOAT16_REF\",e[e.DT_QINT16_REF=115]=\"DT_QINT16_REF\",e[e.DT_QUINT16_REF=116]=\"DT_QUINT16_REF\",e[e.DT_UINT16_REF=117]=\"DT_UINT16_REF\",e[e.DT_COMPLEX128_REF=118]=\"DT_COMPLEX128_REF\",e[e.DT_HALF_REF=119]=\"DT_HALF_REF\",e[e.DT_RESOURCE_REF=120]=\"DT_RESOURCE_REF\",e[e.DT_VARIANT_REF=121]=\"DT_VARIANT_REF\",e[e.DT_UINT32_REF=122]=\"DT_UINT32_REF\",e[e.DT_UINT64_REF=123]=\"DT_UINT64_REF\"})(qn||(qn={}));var PI;(function(e){let t;(function(n){n[n.LEGACY=0]=\"LEGACY\",n[n.V1=1]=\"V1\",n[n.V2=2]=\"V2\"})(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(PI||(PI={}));var _1={};function mq(e,t){let n={tfOpName:e,category:\"custom\",inputs:[],attrs:[],customExecutor:t};_1[e]=n}function zC(e){return _1[e]}function fq(e){delete _1[e]}function k(e,t,n,a,r){let s=t.inputParams[e];if(s&&s.inputIndexStart!==void 0){let o=s.inputIndexStart,l=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?o+1:s.inputIndexEnd,u=o<0?t.inputNames.length+o:o;if(s.type===\"tensor\")return pn(t.inputNames[u],n,a,r);if(s.type===\"tensors\"){let c=t.inputs.slice(o,l);return t.inputNames.slice(o,l).filter((h,m)=>{var f;return((f=c[m])===null||f===void 0?void 0:f.op)!==\"NoOp\"}).map(h=>pn(h,n,a,r))}let p=pn(t.inputNames[u],n,a,r),d=p.dataSync();return s.type===\"number\"?d[0]:w.toNestedArray(p.shape,d)}let i=t.attrParams[e];return i&&i.value}function pn(e,t,n,a){let[r,s]=Xn(e,n);if(a!=null){let o=a.getHashTableHandleByName(r);if(o!=null)return o}let i=n.currentContextIds.find(o=>!!t[im(r,o)]);return i!==void 0?t[im(r,i)][s]:void 0}function LI(e,t,n){return t[im(e,n.currentContextId)]}function Sr(e,t){let[n,a,r]=Xn(e,t);return[im(n,t&&t.currentContextId),a,r]}function im(e,t){return t?`${e}-${t}`:e}function Xn(e,t){if(e===\"\")return[\"\",0,void 0];let n=t!=null&&t.parseNodeNameCache!=null;if(n){let s=t.parseNodeNameCache.get(e);if(s!=null)return s}let a=e.split(\":\"),r;if(a.length===1)r=[e,0,void 0];else{let s=a[0],i=a.length===3?a[1]:void 0,o=Number(a[a.length-1]);r=[s,o,i]}return n&&t.parseNodeNameCache.set(e,r),r}function Mh(e,t,n){let a=k(\"pad\",e,t,n);if(a===\"explicit\"){a=k(\"explicitPaddings\",e,t,n);let r=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)r[s][0]=a[s*2],r[s][1]=a[s*2+1];return r}return a}function Nr(e){return e.kept?e:sr(e)}var WC={};_e(WC,{json:()=>gq});var gq=[{tfOpName:\"Add\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"AddV2\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"AddN\",category:\"arithmetic\",inputs:[{start:0,end:0,name:\"tensors\",type:\"tensors\"}]},{tfOpName:\"BiasAdd\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",notSupported:!0}]},{tfOpName:\"Sub\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"RealDiv\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Div\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"DivNoNan\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"FloorDiv\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Mul\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Maximum\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Minimum\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Pow\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"SquaredDifference\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Mod\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"FloorMod\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]}],BC={};_e(BC,{json:()=>bq});var bq=[{tfOpName:\"Abs\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Acos\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Asin\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Atan\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Atan2\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"y\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Ceil\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"ClipByValue\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"clipValueMin\",type:\"number\"},{start:2,name:\"clipValueMax\",type:\"number\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Complex\",category:\"basic_math\",inputs:[{start:0,name:\"real\",type:\"tensor\"},{start:1,name:\"imag\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"ComplexAbs\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Cos\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Cosh\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Elu\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Exp\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Floor\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Log\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Imag\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0},{tfName:\"Tout\",name:\"outputType\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Neg\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Real\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0},{tfName:\"Tout\",name:\"outputType\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Prelu\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"alpha\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Relu\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Relu6\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Selu\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Sigmoid\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Sin\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Sinh\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Sqrt\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Rsqrt\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Square\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Tan\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Tanh\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Sign\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Round\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Expm1\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Log1p\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Reciprocal\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Softplus\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Asinh\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Acosh\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Atanh\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Erf\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"LeakyRelu\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"alpha\",name:\"alpha\",type:\"number\",defaultValue:.2},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"IsNan\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"IsFinite\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"IsInf\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]}],VC={};_e(VC,{json:()=>yq});var yq=[{tfOpName:\"EmptyTensorList\",category:\"control\",inputs:[{start:0,name:\"elementShape\",type:\"shape\"},{start:1,name:\"maxNumElements\",type:\"number\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"LoopCond\",category:\"control\",inputs:[{start:0,name:\"pred\",type:\"tensor\"}]},{tfOpName:\"Switch\",category:\"control\",inputs:[{start:0,name:\"data\",type:\"tensor\"},{start:1,name:\"pred\",type:\"tensor\"}]},{tfOpName:\"Merge\",category:\"control\",inputs:[{start:0,end:0,name:\"tensors\",type:\"tensors\"}]},{tfOpName:\"Enter\",category:\"control\",inputs:[{start:0,name:\"tensor\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0},{tfName:\"frame_name\",name:\"frameName\",type:\"string\"},{tfName:\"is_constant\",name:\"isConstant\",type:\"bool\"}]},{tfOpName:\"Exit\",category:\"control\",inputs:[{start:0,name:\"tensor\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"NextIteration\",category:\"control\",inputs:[{start:0,name:\"tensor\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"TensorArrayV3\",category:\"control\",inputs:[{start:0,name:\"size\",type:\"number\"}],attrs:[{tfName:\"dtype\",name:\"dtype\",type:\"dtype\"},{tfName:\"element_shape\",name:\"elementShape\",type:\"shape\"},{tfName:\"dynamic_size\",name:\"dynamicSize\",type:\"bool\"},{tfName:\"clear_after_read\",name:\"clearAfterRead\",type:\"bool\"},{tfName:\"identical_element_shapes\",name:\"identicalElementShapes\",type:\"bool\"},{tfName:\"tensor_array_name\",name:\"name\",type:\"string\"}]},{tfOpName:\"TensorArrayWriteV3\",category:\"control\",inputs:[{start:0,name:\"tensorArrayId\",type:\"tensor\"},{start:1,name:\"index\",type:\"number\"},{start:2,name:\"tensor\",type:\"tensor\"},{start:3,name:\"flowIn\",type:\"number\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"TensorArrayReadV3\",category:\"control\",inputs:[{start:0,name:\"tensorArrayId\",type:\"tensor\"},{start:1,name:\"index\",type:\"number\"},{start:2,name:\"flowIn\",type:\"number\"}],attrs:[{tfName:\"dtype\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"TensorArrayGatherV3\",category:\"control\",inputs:[{start:0,name:\"tensorArrayId\",type:\"tensor\"},{start:1,name:\"indices\",type:\"number[]\"},{start:2,name:\"flowIn\",type:\"number\"}],attrs:[{tfName:\"dtype\",name:\"dtype\",type:\"dtype\"},{tfName:\"element_shape\",name:\"elementShape\",type:\"shape\"}]},{tfOpName:\"TensorArrayScatterV3\",category:\"control\",inputs:[{start:0,name:\"tensorArrayId\",type:\"tensor\"},{start:1,name:\"indices\",type:\"number[]\"},{start:2,name:\"tensor\",type:\"tensor\"},{start:3,name:\"flowIn\",type:\"number\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"TensorArrayConcatV3\",category:\"control\",inputs:[{start:0,name:\"tensorArrayId\",type:\"tensor\"},{start:1,name:\"flowIn\",type:\"number\"}],attrs:[{tfName:\"dtype\",name:\"dtype\",type:\"dtype\"},{tfName:\"element_shape_except0\",name:\"elementShapeExcept0\",type:\"shape\",notSupported:!0}]},{tfOpName:\"TensorArraySplitV3\",category:\"control\",inputs:[{start:0,name:\"tensorArrayId\",type:\"tensor\"},{start:1,name:\"tensor\",type:\"tensor\"},{start:2,name:\"lengths\",type:\"number[]\"},{start:3,name:\"flowIn\",type:\"number\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"TensorArraySizeV3\",category:\"control\",inputs:[{start:0,name:\"tensorArrayId\",type:\"tensor\"},{start:1,name:\"flowIn\",type:\"number\"}]},{tfOpName:\"TensorArrayCloseV3\",category:\"control\",inputs:[{start:0,name:\"tensorArrayId\",type:\"tensor\"}]},{tfOpName:\"StatelessIf\",category:\"control\",inputs:[{start:0,name:\"cond\",type:\"tensor\"},{start:1,end:0,name:\"args\",type:\"tensors\"}],attrs:[{tfName:\"then_branch\",name:\"thenBranch\",type:\"func\"},{tfName:\"else_branch\",name:\"elseBranch\",type:\"func\"}]},{tfOpName:\"If\",category:\"control\",inputs:[{start:0,name:\"cond\",type:\"tensor\"},{start:1,end:0,name:\"args\",type:\"tensors\"}],attrs:[{tfName:\"then_branch\",name:\"thenBranch\",type:\"func\"},{tfName:\"else_branch\",name:\"elseBranch\",type:\"func\"}]},{tfOpName:\"StatelessWhile\",category:\"control\",inputs:[{start:0,end:0,name:\"args\",type:\"tensors\"}],attrs:[{tfName:\"cond\",name:\"cond\",type:\"func\"},{tfName:\"body\",name:\"body\",type:\"func\"}]},{tfOpName:\"While\",category:\"control\",inputs:[{start:0,end:0,name:\"args\",type:\"tensors\"}],attrs:[{tfName:\"cond\",name:\"cond\",type:\"func\"},{tfName:\"body\",name:\"body\",type:\"func\"}]},{tfOpName:\"TensorListScatter\",category:\"control\",inputs:[{start:0,name:\"tensor\",type:\"tensor\"},{start:1,name:\"indices\",type:\"number[]\"},{start:2,name:\"elementShape\",type:\"shape\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListScatterV2\",category:\"control\",inputs:[{start:0,name:\"tensor\",type:\"tensor\"},{start:1,name:\"indices\",type:\"number[]\"},{start:2,name:\"elementShape\",type:\"shape\"},{start:3,name:\"numElements\",type:\"number\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListGather\",category:\"control\",inputs:[{start:0,name:\"tensorListId\",type:\"tensor\"},{start:1,name:\"indices\",type:\"number[]\"},{start:2,name:\"elementShape\",type:\"shape\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListGetItem\",category:\"control\",inputs:[{start:0,name:\"tensorListId\",type:\"tensor\"},{start:1,name:\"index\",type:\"number\"},{start:2,name:\"elementShape\",type:\"shape\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListSetItem\",category:\"control\",inputs:[{start:0,name:\"tensorListId\",type:\"tensor\"},{start:1,name:\"index\",type:\"number\"},{start:2,name:\"tensor\",type:\"tensor\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListReserve\",category:\"control\",inputs:[{start:0,name:\"elementShape\",type:\"shape\"},{start:1,name:\"numElements\",type:\"number\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListFromTensor\",category:\"control\",inputs:[{start:0,name:\"tensor\",type:\"tensor\"},{start:1,name:\"elementShape\",type:\"shape\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListStack\",category:\"control\",inputs:[{start:0,name:\"tensorListId\",type:\"tensor\"},{start:1,name:\"elementShape\",type:\"shape\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"},{tfName:\"num_elements\",name:\"numElements\",type:\"dtype\"}]},{tfOpName:\"TensorListSplit\",category:\"control\",inputs:[{start:0,name:\"tensor\",type:\"tensor\"},{start:1,name:\"elementShape\",type:\"shape\"},{start:2,name:\"lengths\",type:\"number[]\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListConcat\",category:\"control\",inputs:[{start:0,name:\"tensorListId\",type:\"tensor\"}],attrs:[{tfName:\"element_shape\",name:\"elementShape\",type:\"shape\"},{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListConcatV2\",category:\"control\",inputs:[{start:0,name:\"tensorListId\",type:\"tensor\"}],attrs:[{tfName:\"element_shape\",name:\"elementShape\",type:\"shape\"},{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListPopBack\",category:\"control\",inputs:[{start:0,name:\"tensorListId\",type:\"tensor\"},{start:1,name:\"elementShape\",type:\"shape\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListPushBack\",category:\"control\",inputs:[{start:0,name:\"tensorListId\",type:\"tensor\"},{start:1,name:\"tensor\",type:\"tensor\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListLength\",category:\"control\",inputs:[{start:0,name:\"tensorListId\",type:\"tensor\"}]},{tfOpName:\"TensorListResize\",category:\"control\",inputs:[{start:0,name:\"tensorListId\",type:\"tensor\"},{start:1,name:\"size\",type:\"number\"}]}],UC={};_e(UC,{json:()=>xq});var xq=[{tfOpName:\"AvgPool\",category:\"convolution\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",notSupported:!0},{tfName:\"ksize\",name:\"kernelSize\",type:\"number[]\"},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"MaxPool\",category:\"convolution\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",notSupported:!0},{tfName:\"ksize\",name:\"kernelSize\",type:\"number[]\"},{tfName:\"explicit_paddings\",name:\"explicitPaddings\",type:\"number[]\",defaultValue:[],notSupported:!0},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"MaxPoolWithArgmax\",category:\"convolution\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"ksize\",name:\"kernelSize\",type:\"number[]\"},{tfName:\"include_batch_in_index\",name:\"includeBatchInIndex\",type:\"bool\"},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"AvgPool3D\",category:\"convolution\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",notSupported:!0},{tfName:\"ksize\",name:\"kernelSize\",type:\"number[]\"},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"MaxPool3D\",category:\"convolution\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",notSupported:!0},{tfName:\"ksize\",name:\"kernelSize\",type:\"number[]\"},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Conv1D\",category:\"convolution\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"filter\",type:\"tensor\"}],attrs:[{tfName:\"stride\",name:\"stride\",type:\"number\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",defaultValue:\"NWC\"},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0},{tfName:\"dilation\",name:\"dilation\",type:\"number\",defaultValue:1}]},{tfOpName:\"Conv2D\",category:\"convolution\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"filter\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0},{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"useCudnnOnGpu\",name:\"useCudnnOnGpu\",type:\"bool\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",defaultValue:\"NHWC\"},{tfName:\"explicit_paddings\",name:\"explicitPaddings\",type:\"number[]\",defaultValue:[]},{tfName:\"dilations\",name:\"dilations\",type:\"number[]\"}]},{tfOpName:\"_FusedConv2D\",category:\"convolution\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"filter\",type:\"tensor\"},{start:2,end:0,name:\"args\",type:\"tensors\"}],attrs:[{tfName:\"num_args\",name:\"numArgs\",type:\"number\"},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0},{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"explicit_paddings\",name:\"explicitPaddings\",type:\"number[]\",defaultValue:[]},{tfName:\"use_cudnn_on_gpu\",name:\"useCudnnOnGpu\",type:\"bool\",defaultValue:!0},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",defaultValue:\"NHWC\"},{tfName:\"dilations\",name:\"dilations\",type:\"number[]\",defaultValue:[1,1,1,1]},{tfName:\"fused_ops\",name:\"fusedOps\",type:\"string[]\",defaultValue:[]},{tfName:\"epsilon\",name:\"epsilon\",type:\"number\",defaultValue:1e-4},{tfName:\"leakyrelu_alpha\",name:\"leakyreluAlpha\",type:\"number\",defaultValue:.2}]},{tfOpName:\"Conv2DBackpropInput\",category:\"convolution\",inputs:[{start:2,name:\"x\",type:\"tensor\"},{start:1,name:\"filter\",type:\"tensor\"},{start:0,name:\"outputShape\",type:\"number[]\"}],attrs:[{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",notSupported:!0},{tfName:\"explicit_paddings\",name:\"explicitPaddings\",type:\"number[]\",defaultValue:[]},{tfName:\"dilations\",name:\"dilations\",type:\"number[]\",notSupported:!0}]},{tfOpName:\"DepthwiseConv2d\",category:\"convolution\",inputs:[{start:0,name:\"input\",type:\"tensor\"},{start:1,name:\"filter\",type:\"tensor\"}],attrs:[{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",defaultValue:\"NHWC\"},{tfName:\"explicit_paddings\",name:\"explicitPaddings\",type:\"number[]\",defaultValue:[]},{tfName:\"dilations\",name:\"dilations\",type:\"number[]\"}]},{tfOpName:\"DepthwiseConv2dNative\",category:\"convolution\",inputs:[{start:0,name:\"input\",type:\"tensor\"},{start:1,name:\"filter\",type:\"tensor\"}],attrs:[{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",defaultValue:\"NHWC\"},{tfName:\"explicit_paddings\",name:\"explicitPaddings\",type:\"number[]\",defaultValue:[]},{tfName:\"dilations\",name:\"dilations\",type:\"number[]\"}]},{tfOpName:\"FusedDepthwiseConv2dNative\",category:\"convolution\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"filter\",type:\"tensor\"},{start:2,end:0,name:\"args\",type:\"tensors\"}],attrs:[{tfName:\"num_args\",name:\"numArgs\",type:\"number\"},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0},{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",defaultValue:\"NHWC\"},{tfName:\"dilations\",name:\"dilations\",type:\"number[]\",defaultValue:[1,1,1,1]},{tfName:\"fused_ops\",name:\"fusedOps\",type:\"string[]\",defaultValue:[]},{tfName:\"explicit_paddings\",name:\"explicitPaddings\",type:\"number[]\",defaultValue:[]}]},{tfOpName:\"Conv3D\",category:\"convolution\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"filter\",type:\"tensor\"}],attrs:[{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",defaultValue:\"NHWC\"},{tfName:\"dilations\",name:\"dilations\",type:\"number[]\"}]},{tfOpName:\"Dilation2D\",category:\"convolution\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"filter\",type:\"tensor\"}],attrs:[{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"rates\",name:\"dilations\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"}]}],GC={};_e(GC,{json:()=>vq});var vq=[{tfOpName:\"Fill\",category:\"creation\",inputs:[{start:0,name:\"shape\",type:\"number[]\"},{start:1,name:\"value\",type:\"number\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"LinSpace\",category:\"creation\",inputs:[{start:0,name:\"start\",type:\"number\"},{start:1,name:\"stop\",type:\"number\"},{start:2,name:\"num\",type:\"number\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"OneHot\",category:\"creation\",inputs:[{start:0,name:\"indices\",type:\"tensor\"},{start:1,name:\"depth\",type:\"number\"},{start:2,name:\"onValue\",type:\"number\",defaultValue:1},{start:3,name:\"offValue\",type:\"number\",defaultValue:0}],attrs:[{tfName:\"axis\",name:\"axis\",type:\"number\",notSupported:!0},{tfName:\"T\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"Ones\",category:\"creation\",inputs:[{start:0,name:\"shape\",type:\"number[]\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"OnesLike\",category:\"creation\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"dtype\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"RandomStandardNormal\",category:\"creation\",inputs:[{start:0,name:\"shape\",type:\"number[]\"}],attrs:[{tfName:\"seed\",name:\"seed\",type:\"number\",defaultValue:0},{tfName:\"seed2\",name:\"seed2\",type:\"number\",defaultValue:0,notSupported:!0},{tfName:\"dtype\",name:\"dtype\",type:\"dtype\"},{tfName:\"T\",name:\"T\",type:\"number\",notSupported:!0}]},{tfOpName:\"RandomUniform\",category:\"creation\",inputs:[{start:0,name:\"shape\",type:\"number[]\"}],attrs:[{tfName:\"minval\",name:\"minval\",type:\"number\",defaultValue:0},{tfName:\"maxval\",name:\"maxval\",type:\"number\",defaultValue:1},{tfName:\"dtype\",name:\"dtype\",type:\"dtype\"},{tfName:\"seed\",name:\"seed\",type:\"number\",defaultValue:0},{tfName:\"seed2\",name:\"seed2\",type:\"number\",defaultValue:0,notSupported:!0},{tfName:\"T\",name:\"T\",type:\"number\",notSupported:!0}]},{tfOpName:\"RandomUniformInt\",category:\"creation\",inputs:[{start:0,name:\"shape\",type:\"number[]\"}],attrs:[{tfName:\"minval\",name:\"minval\",type:\"number\"},{tfName:\"maxval\",name:\"maxval\",type:\"number\"},{tfName:\"seed\",name:\"seed\",type:\"number\",defaultValue:0},{tfName:\"seed2\",name:\"seed2\",type:\"number\",defaultValue:0,notSupported:!0}]},{tfOpName:\"Range\",category:\"creation\",inputs:[{start:0,name:\"start\",type:\"number\"},{start:1,name:\"stop\",type:\"number\"},{start:2,name:\"step\",type:\"number\",defaultValue:0}],attrs:[{tfName:\"Tidx\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"TruncatedNormal\",category:\"creation\",inputs:[{start:0,name:\"shape\",type:\"number[]\"}],attrs:[{tfName:\"means\",name:\"mean\",type:\"number\",defaultValue:0},{tfName:\"stddev\",name:\"stdDev\",type:\"number\",defaultValue:1},{tfName:\"seed\",name:\"seed\",type:\"number\"},{tfName:\"seed2\",name:\"seed2\",type:\"number\",defaultValue:0,notSupported:!0},{tfName:\"dtype\",name:\"dtype\",type:\"dtype\"},{tfName:\"T\",name:\"T\",type:\"number\",notSupported:!0}]},{tfOpName:\"Zeros\",category:\"creation\",inputs:[{start:0,name:\"shape\",type:\"number[]\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"ZerosLike\",category:\"creation\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"Multinomial\",category:\"creation\",inputs:[{start:0,name:\"logits\",type:\"tensor\"},{start:1,name:\"numSamples\",type:\"number\"}],attrs:[{tfName:\"seed\",name:\"seed\",type:\"number\"},{tfName:\"seed2\",name:\"seed2\",type:\"number\"},{tfName:\"T\",name:\"dtype\",type:\"dtype\"},{tfName:\"output_dtype\",name:\"output_dtype\",type:\"dtype\"}]}],HC={};_e(HC,{json:()=>wq});var wq=[{tfOpName:\"NonMaxSuppressionV2\",category:\"dynamic\",inputs:[{start:0,name:\"boxes\",type:\"tensor\"},{start:1,name:\"scores\",type:\"tensor\"},{start:2,name:\"maxOutputSize\",type:\"number\"},{start:3,name:\"iouThreshold\",type:\"number\"}]},{tfOpName:\"NonMaxSuppressionV3\",category:\"dynamic\",inputs:[{start:0,name:\"boxes\",type:\"tensor\"},{start:1,name:\"scores\",type:\"tensor\"},{start:2,name:\"maxOutputSize\",type:\"number\"},{start:3,name:\"iouThreshold\",type:\"number\"},{start:4,name:\"scoreThreshold\",type:\"number\"}]},{tfOpName:\"NonMaxSuppressionV4\",category:\"dynamic\",inputs:[{start:0,name:\"boxes\",type:\"tensor\"},{start:1,name:\"scores\",type:\"tensor\"},{start:2,name:\"maxOutputSize\",type:\"number\"},{start:3,name:\"iouThreshold\",type:\"number\"},{start:4,name:\"scoreThreshold\",type:\"number\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0},{tfName:\"T_threshold\",name:\"threshold\",type:\"dtype\",notSupported:!0},{tfName:\"pad_to_max_output_size\",name:\"padToMaxOutputSize\",type:\"bool\"}]},{tfOpName:\"NonMaxSuppressionV5\",category:\"dynamic\",inputs:[{start:0,name:\"boxes\",type:\"tensor\"},{start:1,name:\"scores\",type:\"tensor\"},{start:2,name:\"maxOutputSize\",type:\"number\"},{start:3,name:\"iouThreshold\",type:\"number\"},{start:4,name:\"scoreThreshold\",type:\"number\"},{start:5,name:\"softNmsSigma\",type:\"number\"}]},{tfOpName:\"Where\",category:\"dynamic\",inputs:[{start:0,name:\"condition\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"ListDiff\",category:\"dynamic\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"y\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]}],jC={};_e(jC,{json:()=>kq});var kq=[{tfOpName:\"LowerBound\",category:\"evaluation\",inputs:[{start:0,name:\"sortedSequence\",type:\"tensor\"},{start:1,name:\"values\",type:\"tensor\"}]},{tfOpName:\"TopKV2\",category:\"evaluation\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"k\",type:\"number\"}],attrs:[{tfName:\"sorted\",name:\"sorted\",type:\"bool\"}]},{tfOpName:\"UpperBound\",category:\"evaluation\",inputs:[{start:0,name:\"sortedSequence\",type:\"tensor\"},{start:1,name:\"values\",type:\"tensor\"}]},{tfOpName:\"Unique\",category:\"evaluation\",inputs:[{start:0,name:\"x\",type:\"tensor\"}]},{tfOpName:\"UniqueV2\",category:\"evaluation\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number\"}]}],qC={};_e(qC,{json:()=>Iq});var Iq=[{tfOpName:\"PlaceholderWithDefault\",category:\"graph\",inputs:[{start:0,name:\"default\",type:\"tensor\"}],attrs:[{tfName:\"shape\",name:\"shape\",type:\"shape\"},{tfName:\"dtype\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"Placeholder\",category:\"graph\",attrs:[{tfName:\"shape\",name:\"shape\",type:\"shape\"},{tfName:\"dtype\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"Const\",category:\"graph\"},{tfOpName:\"Identity\",category:\"graph\",inputs:[{start:0,name:\"x\",type:\"tensor\"}]},{tfOpName:\"IdentityN\",category:\"graph\",inputs:[{start:0,end:0,name:\"x\",type:\"tensors\"}]},{tfOpName:\"Snapshot\",category:\"graph\",inputs:[{start:0,name:\"x\",type:\"tensor\"}]},{tfOpName:\"Rank\",category:\"graph\",inputs:[{start:0,name:\"x\",type:\"tensor\"}]},{tfOpName:\"Size\",category:\"graph\",inputs:[{start:0,name:\"x\",type:\"tensor\"}]},{tfOpName:\"Shape\",category:\"graph\",inputs:[{start:0,name:\"x\",type:\"tensor\"}]},{tfOpName:\"ShapeN\",category:\"graph\",inputs:[{start:0,end:0,name:\"x\",type:\"tensors\"}]},{tfOpName:\"Print\",category:\"graph\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"data\",type:\"tensors\"}],attrs:[{tfName:\"message\",name:\"message\",type:\"string\"},{tfName:\"first_n\",name:\"firstN\",type:\"number\",notSupported:!0},{tfName:\"summarize\",name:\"summarize\",type:\"number\",defaultValue:3}]},{tfOpName:\"NoOp\",category:\"graph\",inputs:[]},{tfOpName:\"StopGradient\",category:\"graph\",inputs:[{start:0,name:\"x\",type:\"tensor\"}]},{tfOpName:\"FakeQuantWithMinMaxVars\",category:\"graph\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"min\",name:\"min\",type:\"number\"},{tfName:\"max\",name:\"max\",type:\"number\"}]}],KC={};_e(KC,{json:()=>Sq});var Sq=[{tfOpName:\"HashTable\",category:\"hash_table\",inputs:[],attrs:[{tfName:\"shared_name\",name:\"sharedName\",type:\"string\"},{tfName:\"use_node_name_sharing\",name:\"useNodeNameSharing\",type:\"bool\"},{tfName:\"key_dtype\",name:\"keyDType\",type:\"dtype\"},{tfName:\"value_dtype\",name:\"valueDType\",type:\"dtype\"}]},{tfOpName:\"HashTableV2\",category:\"hash_table\",inputs:[],attrs:[{tfName:\"shared_name\",name:\"sharedName\",type:\"string\"},{tfName:\"use_node_name_sharing\",name:\"useNodeNameSharing\",type:\"bool\"},{tfName:\"key_dtype\",name:\"keyDType\",type:\"dtype\"},{tfName:\"value_dtype\",name:\"valueDType\",type:\"dtype\"}]},{tfOpName:\"LookupTableImport\",category:\"hash_table\",inputs:[{start:0,name:\"tableHandle\",type:\"tensor\"},{start:1,name:\"keys\",type:\"tensor\"},{start:2,name:\"values\",type:\"tensor\"}],attrs:[{tfName:\"Tin\",name:\"tIn\",type:\"dtype\",notSupported:!0},{tfName:\"Tout\",name:\"tOut\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"LookupTableImportV2\",category:\"hash_table\",inputs:[{start:0,name:\"tableHandle\",type:\"tensor\"},{start:1,name:\"keys\",type:\"tensor\"},{start:2,name:\"values\",type:\"tensor\"}],attrs:[{tfName:\"Tin\",name:\"tIn\",type:\"dtype\",notSupported:!0},{tfName:\"Tout\",name:\"tOut\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"LookupTableFind\",category:\"hash_table\",inputs:[{start:0,name:\"tableHandle\",type:\"tensor\"},{start:1,name:\"keys\",type:\"tensor\"},{start:2,name:\"defaultValue\",type:\"tensor\"}],attrs:[{tfName:\"Tin\",name:\"tIn\",type:\"dtype\",notSupported:!0},{tfName:\"Tout\",name:\"tOut\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"LookupTableFindV2\",category:\"hash_table\",inputs:[{start:0,name:\"tableHandle\",type:\"tensor\"},{start:1,name:\"keys\",type:\"tensor\"},{start:2,name:\"defaultValue\",type:\"tensor\"}],attrs:[{tfName:\"Tin\",name:\"tIn\",type:\"dtype\",notSupported:!0},{tfName:\"Tout\",name:\"tOut\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"LookupTableSize\",category:\"hash_table\",inputs:[{start:0,name:\"tableHandle\",type:\"tensor\"}]},{tfOpName:\"LookupTableSizeV2\",category:\"hash_table\",inputs:[{start:0,name:\"tableHandle\",type:\"tensor\"}]},{tfOpName:\"InitializeTable\",category:\"hash_table\",inputs:[{start:0,name:\"tableHandle\",type:\"tensor\"},{start:1,name:\"keys\",type:\"tensor\"},{start:2,name:\"values\",type:\"tensor\"}]},{tfOpName:\"InitializeTableV2\",category:\"hash_table\",inputs:[{start:0,name:\"tableHandle\",type:\"tensor\"},{start:1,name:\"keys\",type:\"tensor\"},{start:2,name:\"values\",type:\"tensor\"}]}],XC={};_e(XC,{json:()=>Nq});var Nq=[{tfOpName:\"ResizeBilinear\",category:\"image\",inputs:[{start:0,name:\"images\",type:\"tensor\"},{start:1,name:\"size\",type:\"number[]\"}],attrs:[{tfName:\"align_corners\",name:\"alignCorners\",type:\"bool\"},{tfName:\"half_pixel_centers\",name:\"halfPixelCenters\",type:\"bool\"},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"ResizeNearestNeighbor\",category:\"image\",inputs:[{start:0,name:\"images\",type:\"tensor\"},{start:1,name:\"size\",type:\"number[]\"}],attrs:[{tfName:\"align_corners\",name:\"alignCorners\",type:\"bool\"},{tfName:\"half_pixel_centers\",name:\"halfPixelCenters\",type:\"bool\"},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"CropAndResize\",category:\"image\",inputs:[{start:0,name:\"image\",type:\"tensor\"},{start:1,name:\"boxes\",type:\"tensor\"},{start:2,name:\"boxInd\",type:\"tensor\"},{start:3,name:\"cropSize\",type:\"number[]\"}],attrs:[{tfName:\"method\",name:\"method\",type:\"string\"},{tfName:\"extrapolation_value\",name:\"extrapolationValue\",type:\"number\"}]},{tfOpName:\"ImageProjectiveTransformV3\",category:\"image\",inputs:[{start:0,name:\"images\",type:\"tensor\"},{start:1,name:\"transforms\",type:\"tensor\"},{start:2,name:\"outputShape\",type:\"number[]\"},{start:3,name:\"fillValue\",type:\"number\"}],attrs:[{tfName:\"interpolation\",name:\"interpolation\",type:\"string\"},{tfName:\"fill_mode\",name:\"fillMode\",type:\"string\"}]}],YC={};_e(YC,{json:()=>Tq});var Tq=[{tfOpName:\"Equal\",category:\"logical\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"NotEqual\",category:\"logical\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Greater\",category:\"logical\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"GreaterEqual\",category:\"logical\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Less\",category:\"logical\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"LessEqual\",category:\"logical\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"LogicalAnd\",category:\"logical\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"LogicalNot\",category:\"logical\",inputs:[{start:0,name:\"a\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"LogicalOr\",category:\"logical\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Select\",category:\"logical\",inputs:[{start:0,name:\"condition\",type:\"tensor\"},{start:1,name:\"a\",type:\"tensor\"},{start:2,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"SelectV2\",category:\"logical\",inputs:[{start:0,name:\"condition\",type:\"tensor\"},{start:1,name:\"a\",type:\"tensor\"},{start:2,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"BitwiseAnd\",category:\"logical\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"y\",type:\"tensor\"}]}],ZC={};_e(ZC,{json:()=>Cq});var Cq=[{tfOpName:\"_FusedMatMul\",category:\"matrices\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"},{start:2,end:0,name:\"args\",type:\"tensors\"}],attrs:[{tfName:\"num_args\",name:\"numArgs\",type:\"number\"},{tfName:\"fused_ops\",name:\"fusedOps\",type:\"string[]\",defaultValue:[]},{tfName:\"epsilon\",name:\"epsilon\",type:\"number\",defaultValue:1e-4},{tfName:\"transpose_a\",name:\"transposeA\",type:\"bool\",defaultValue:!1},{tfName:\"transpose_b\",name:\"transposeB\",type:\"bool\",defaultValue:!1},{tfName:\"leakyrelu_alpha\",name:\"leakyreluAlpha\",type:\"number\",defaultValue:.2},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"MatMul\",category:\"matrices\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"transpose_a\",name:\"transposeA\",type:\"bool\",defaultValue:!1},{tfName:\"transpose_b\",name:\"transposeB\",type:\"bool\",defaultValue:!1},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"BatchMatMul\",category:\"matrices\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"adj_x\",name:\"transposeA\",type:\"bool\",defaultValue:!1},{tfName:\"adj_y\",name:\"transposeB\",type:\"bool\",defaultValue:!1},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"BatchMatMulV2\",category:\"matrices\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"adj_x\",name:\"transposeA\",type:\"bool\",defaultValue:!1},{tfName:\"adj_y\",name:\"transposeB\",type:\"bool\",defaultValue:!1},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Transpose\",category:\"matrices\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"perm\",type:\"number[]\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Einsum\",category:\"matrices\",inputs:[{start:0,end:0,name:\"tensors\",type:\"tensors\"}],attrs:[{tfName:\"equation\",name:\"equation\",type:\"string\"},{tfName:\"N\",name:\"n\",type:\"number\",defaultValue:2},{tfName:\"T\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"MatrixBandPart\",category:\"matrices\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"numLower\",type:\"tensor\"},{start:1,name:\"numUpper\",type:\"tensor\"}]}],JC={};_e(JC,{json:()=>Eq});var Eq=[{tfOpName:\"EuclideanNorm\",category:\"normalization\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number[]\"}],attrs:[{tfName:\"keep_dims\",name:\"keepDims\",type:\"bool\",defaultValue:!1}]},{tfOpName:\"FusedBatchNorm\",category:\"normalization\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"scale\",type:\"tensor\"},{start:2,name:\"offset\",type:\"tensor\"},{start:3,name:\"mean\",type:\"tensor\"},{start:4,name:\"variance\",type:\"tensor\"}],attrs:[{tfName:\"epsilon\",name:\"epsilon\",type:\"number\",defaultValue:.001},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",notSupported:!0}]},{tfOpName:\"FusedBatchNormV2\",category:\"normalization\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"scale\",type:\"tensor\"},{start:2,name:\"offset\",type:\"tensor\"},{start:3,name:\"mean\",type:\"tensor\"},{start:4,name:\"variance\",type:\"tensor\"}],attrs:[{tfName:\"epsilon\",name:\"epsilon\",type:\"number\",defaultValue:.001},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",notSupported:!0}]},{tfOpName:\"FusedBatchNormV3\",category:\"normalization\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"scale\",type:\"tensor\"},{start:2,name:\"offset\",type:\"tensor\"},{start:3,name:\"mean\",type:\"tensor\"},{start:4,name:\"variance\",type:\"tensor\"}],attrs:[{tfName:\"epsilon\",name:\"epsilon\",type:\"number\",defaultValue:.001},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",notSupported:!0}]},{tfOpName:\"LRN\",category:\"normalization\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"depth_radius\",name:\"radius\",type:\"number\",defaultValue:5},{tfName:\"bias\",name:\"bias\",type:\"number\",defaultValue:1},{tfName:\"alpha\",name:\"alpha\",type:\"number\",defaultValue:1},{tfName:\"beta\",name:\"beta\",type:\"number\",defaultValue:.5}]},{tfOpName:\"Softmax\",category:\"normalization\",inputs:[{start:0,name:\"x\",type:\"tensor\"}]},{tfOpName:\"LogSoftmax\",category:\"normalization\",inputs:[{start:0,name:\"x\",type:\"tensor\"}]}],QC={};_e(QC,{json:()=>_q});var _q=[{tfOpName:\"Bincount\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"size\",type:\"number\"},{start:2,name:\"weights\",type:\"tensor\"}]},{tfOpName:\"DenseBincount\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"size\",type:\"number\"},{start:2,name:\"weights\",type:\"tensor\"}],attrs:[{tfName:\"binary_output\",name:\"binaryOutput\",type:\"bool\"}]},{tfOpName:\"Max\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number[]\"}],attrs:[{tfName:\"keep_dims\",name:\"keepDims\",type:\"bool\"}]},{tfOpName:\"Mean\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number[]\"}],attrs:[{tfName:\"keep_dims\",name:\"keepDims\",type:\"bool\"}]},{tfOpName:\"Min\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number[]\"}],attrs:[{tfName:\"keep_dims\",name:\"keepDims\",type:\"bool\"}]},{tfOpName:\"Sum\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number[]\"}],attrs:[{tfName:\"keep_dims\",name:\"keepDims\",type:\"bool\"}]},{tfOpName:\"All\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number[]\"}],attrs:[{tfName:\"keep_dims\",name:\"keepDims\",type:\"bool\"}]},{tfOpName:\"Any\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number[]\"}],attrs:[{tfName:\"keep_dims\",name:\"keepDims\",type:\"bool\"}]},{tfOpName:\"ArgMax\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number\"}]},{tfOpName:\"ArgMin\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number\"}]},{tfOpName:\"Prod\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number[]\"}],attrs:[{tfName:\"keep_dims\",name:\"keepDims\",type:\"bool\"},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Cumprod\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number\"}],attrs:[{tfName:\"exclusive\",name:\"exclusive\",type:\"bool\"},{tfName:\"reverse\",name:\"reverse\",type:\"bool\"}]},{tfOpName:\"Cumsum\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number\"}],attrs:[{tfName:\"exclusive\",name:\"exclusive\",type:\"bool\"},{tfName:\"reverse\",name:\"reverse\",type:\"bool\"}]}],eE={};_e(eE,{json:()=>Aq});var Aq=[{tfOpName:\"ConcatV2\",category:\"slice_join\",inputs:[{start:0,end:-1,name:\"tensors\",type:\"tensors\"},{start:-1,name:\"axis\",type:\"number\"}],attrs:[{tfName:\"N\",name:\"n\",type:\"number\",defaultValue:2}]},{tfOpName:\"Concat\",category:\"slice_join\",inputs:[{start:1,end:0,name:\"tensors\",type:\"tensors\"},{start:0,name:\"axis\",type:\"number\"}],attrs:[{tfName:\"N\",name:\"n\",type:\"number\",defaultValue:2}]},{tfOpName:\"GatherV2\",category:\"slice_join\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"indices\",type:\"tensor\"},{start:2,name:\"axis\",type:\"number\",defaultValue:0}],attrs:[{tfName:\"batch_dims\",name:\"batchDims\",type:\"number\",defaultValue:0}]},{tfOpName:\"Gather\",category:\"slice_join\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"indices\",type:\"tensor\"}],attrs:[{tfName:\"validate_indices\",name:\"validateIndices\",type:\"bool\",notSupported:!0}]},{tfOpName:\"Reverse\",category:\"slice_join\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"dims\",type:\"bool[]\"}]},{tfOpName:\"ReverseV2\",category:\"slice_join\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number[]\"}]},{tfOpName:\"Slice\",category:\"slice_join\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"begin\",type:\"number[]\"},{start:2,name:\"size\",type:\"number[]\"}]},{tfOpName:\"StridedSlice\",category:\"slice_join\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"begin\",type:\"number[]\"},{start:2,name:\"end\",type:\"number[]\"},{start:3,name:\"strides\",type:\"number[]\"}],attrs:[{tfName:\"begin_mask\",name:\"beginMask\",type:\"number\",defaultValue:0},{tfName:\"end_mask\",name:\"endMask\",type:\"number\",defaultValue:0},{tfName:\"new_axis_mask\",name:\"newAxisMask\",type:\"number\",defaultValue:0},{tfName:\"ellipsis_mask\",name:\"ellipsisMask\",type:\"number\",defaultValue:0},{tfName:\"shrink_axis_mask\",name:\"shrinkAxisMask\",type:\"number\",defaultValue:0}]},{tfOpName:\"Pack\",category:\"slice_join\",inputs:[{start:0,end:0,name:\"tensors\",type:\"tensors\"}],attrs:[{tfName:\"axis\",name:\"axis\",type:\"number\",defaultValue:0}]},{tfOpName:\"Unpack\",category:\"slice_join\",inputs:[{start:0,name:\"tensor\",type:\"tensor\"}],attrs:[{tfName:\"axis\",name:\"axis\",type:\"number\",defaultValue:0},{tfName:\"num\",name:\"num\",type:\"number\",defaultValue:0,notSupported:!0}]},{tfOpName:\"Tile\",category:\"slice_join\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"reps\",type:\"number[]\"}]},{tfOpName:\"Split\",category:\"slice_join\",inputs:[{start:0,name:\"axis\",type:\"number\",defaultValue:0},{start:1,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"num_split\",name:\"numOrSizeSplits\",type:\"number\",defaultValue:1}]},{tfOpName:\"SplitV\",category:\"slice_join\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"numOrSizeSplits\",type:\"number[]\"},{start:2,name:\"axis\",type:\"number\",defaultValue:0}]},{tfOpName:\"ScatterNd\",category:\"slice_join\",inputs:[{start:0,name:\"indices\",type:\"tensor\"},{start:1,name:\"values\",type:\"tensor\"},{start:2,name:\"shape\",type:\"number[]\"}]},{tfOpName:\"GatherNd\",category:\"slice_join\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"indices\",type:\"tensor\"}]},{tfOpName:\"SparseToDense\",category:\"slice_join\",inputs:[{start:0,name:\"sparseIndices\",type:\"tensor\"},{start:1,name:\"outputShape\",type:\"number[]\"},{start:2,name:\"sparseValues\",type:\"tensor\"},{start:3,name:\"defaultValue\",type:\"tensor\"}],attrs:[{tfName:\"validate_indices\",name:\"validateIndices\",type:\"bool\",defaultValue:!1,notSupported:!0}]},{tfOpName:\"TensorScatterUpdate\",category:\"slice_join\",inputs:[{start:0,name:\"tensor\",type:\"tensor\"},{start:1,name:\"indices\",type:\"tensor\"},{start:2,name:\"values\",type:\"tensor\"}]}],tE={};_e(tE,{json:()=>Fq});var Fq=[{tfOpName:\"SparseFillEmptyRows\",category:\"sparse\",inputs:[{start:0,name:\"indices\",type:\"tensor\"},{start:1,name:\"values\",type:\"tensor\"},{start:2,name:\"denseShape\",type:\"tensor\"},{start:3,name:\"defaultValue\",type:\"tensor\"}]},{tfOpName:\"SparseReshape\",category:\"sparse\",inputs:[{start:0,name:\"inputIndices\",type:\"tensor\"},{start:1,name:\"inputShape\",type:\"tensor\"},{start:2,name:\"newShape\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"SparseSegmentMean\",category:\"sparse\",inputs:[{start:0,name:\"data\",type:\"tensor\"},{start:1,name:\"indices\",type:\"tensor\"},{start:2,name:\"segmentIds\",type:\"tensor\"}]},{tfOpName:\"SparseSegmentSum\",category:\"sparse\",inputs:[{start:0,name:\"data\",type:\"tensor\"},{start:1,name:\"indices\",type:\"tensor\"},{start:2,name:\"segmentIds\",type:\"tensor\"}]}],nE={};_e(nE,{json:()=>$q});var $q=[{tfOpName:\"FFT\",category:\"spectral\",inputs:[{start:0,name:\"x\",type:\"tensor\"}]},{tfOpName:\"IFFT\",category:\"spectral\",inputs:[{start:0,name:\"x\",type:\"tensor\"}]},{tfOpName:\"RFFT\",category:\"spectral\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"fft_length\",type:\"number\",notSupported:!0}]},{tfOpName:\"IRFFT\",category:\"spectral\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"fft_length\",type:\"number\",notSupported:!0}]}],aE={};_e(aE,{json:()=>Dq});var Dq=[{tfOpName:\"StaticRegexReplace\",category:\"string\",inputs:[{start:0,name:\"input\",type:\"tensor\"}],attrs:[{tfName:\"pattern\",name:\"pattern\",type:\"string\"},{tfName:\"rewrite\",name:\"rewrite\",type:\"string\"},{tfName:\"replace_global\",name:\"replaceGlobal\",type:\"bool\"}]},{tfOpName:\"StringNGrams\",category:\"string\",inputs:[{start:0,name:\"data\",type:\"tensor\"},{start:1,name:\"dataSplits\",type:\"tensor\"}],attrs:[{tfName:\"separator\",name:\"separator\",type:\"string\"},{tfName:\"ngram_widths\",name:\"nGramWidths\",type:\"number[]\"},{tfName:\"left_pad\",name:\"leftPad\",type:\"string\"},{tfName:\"right_pad\",name:\"rightPad\",type:\"string\"},{tfName:\"pad_width\",name:\"padWidth\",type:\"number\"},{tfName:\"preserve_short_sequences\",name:\"preserveShortSequences\",type:\"bool\"}],outputs:[\"ngrams\",\"ngrams_splits\"]},{tfOpName:\"StringSplit\",category:\"string\",inputs:[{start:0,name:\"input\",type:\"tensor\"},{start:1,name:\"delimiter\",type:\"tensor\"}],attrs:[{tfName:\"skip_empty\",name:\"skipEmpty\",type:\"bool\"}],outputs:[\"indices\",\"values\",\"shape\"]},{tfOpName:\"StringToHashBucketFast\",category:\"string\",inputs:[{start:0,name:\"input\",type:\"tensor\"}],attrs:[{tfName:\"num_buckets\",name:\"numBuckets\",type:\"number\"}]}],rE={};_e(rE,{json:()=>Rq});var Rq=[{tfOpName:\"Cast\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"SrcT\",name:\"sdtype\",type:\"dtype\",notSupported:!0},{tfName:\"DstT\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"ExpandDims\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number\"}]},{tfOpName:\"MirrorPad\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"padding\",type:\"number[]\"}],attrs:[{tfName:\"mode\",name:\"mode\",type:\"string\"}]},{tfOpName:\"Pad\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"padding\",type:\"number[]\"}],attrs:[{tfName:\"constant_value\",name:\"constantValue\",type:\"number\",defaultValue:0}]},{tfOpName:\"PadV2\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"padding\",type:\"number[]\"},{start:2,name:\"constantValue\",type:\"number\",defaultValue:0}]},{tfOpName:\"Reshape\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"shape\",type:\"number[]\"}]},{tfOpName:\"EnsureShape\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"shape\",type:\"number[]\"}]},{tfOpName:\"Squeeze\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"axis\",tfDeprecatedName:\"squeeze_dims\",name:\"axis\",type:\"number[]\"}]},{tfOpName:\"SpaceToBatchND\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"blockShape\",type:\"number[]\"},{start:2,name:\"paddings\",type:\"number[]\"}]},{tfOpName:\"BatchToSpaceND\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"blockShape\",type:\"number[]\"},{start:2,name:\"crops\",type:\"number[]\"}]},{tfOpName:\"DepthToSpace\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"block_size\",name:\"blockSize\",type:\"number\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\"}]},{tfOpName:\"BroadcastTo\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"shape\",type:\"number[]\"}],attrs:[]},{tfOpName:\"BroadcastArgs\",category:\"transformation\",inputs:[{start:0,name:\"s0\",type:\"tensor\"},{start:1,name:\"s1\",type:\"tensor\"}],attrs:[]}],zI=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[WC,BC,VC,UC,GC,HC,jC,qC,KC,XC,YC,ZC,JC,QC,eE,tE,nE,aE,rE],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,a)=>(n[a.tfOpName]=a,n),{})}transformGraph(e,t={}){let n=e.node,a=[],r=[],s=[],i=n.reduce((m,f)=>(m[f.name]=this.mapNode(f),f.op.startsWith(\"Placeholder\")?a.push(m[f.name]):f.op===\"Const\"?r.push(m[f.name]):(f.input==null||f.input.length===0)&&s.push(m[f.name]),m),{}),o=[],l=[],u={},p={};t!=null&&(u=this.mapSignatureEntries(t.inputs),p=this.mapSignatureEntries(t.outputs));let d=Object.keys(i);d.forEach(m=>{let f=i[m];f.inputNames.forEach((g,b)=>{let[y,,x]=Sr(g),v=i[y];if(v.outputs!=null){let I=v.outputs.indexOf(x);if(I!==-1){let N=`${y}:${I}`;f.inputNames[b]=N}}f.inputs.push(v),v.children.push(f)})}),Object.keys(p).length===0?d.forEach(m=>{let f=i[m];f.children.length===0&&l.push(f)}):Object.keys(p).forEach(m=>{let[f]=Sr(m),g=i[f];g!=null&&(g.signatureKey=p[m],l.push(g))}),Object.keys(u).length>0?Object.keys(u).forEach(m=>{let[f]=Sr(m),g=i[f];g&&(g.signatureKey=u[m],o.push(g))}):o=a;let c={};e.library!=null&&e.library.function!=null&&(c=e.library.function.reduce((m,f)=>(m[f.signature.name]=this.mapFunction(f),m),{}));let h={nodes:i,inputs:o,outputs:l,weights:r,placeholders:a,signature:t,functions:c};return s.length>0&&(h.initNodes=s),h}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=zC(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(a=>a.startsWith(\"^\")?a.slice(1):a),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((a,r)=>(a[r.name]={type:r.type,inputIndexStart:r.start,inputIndexEnd:r.end},a),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((a,r)=>{let s=r.type,i;switch(r.type){case\"string\":i=Xx(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=Xx(e.attr,r.tfDeprecatedName,r.defaultValue));break;case\"string[]\":i=nv(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=nv(e.attr,r.tfDeprecatedName,r.defaultValue));break;case\"number\":i=Zx(e.attr,r.tfName,r.defaultValue||0),i===void 0&&r.tfDeprecatedName&&(i=Zx(e.attr,r.tfDeprecatedName,r.defaultValue));break;case\"number[]\":i=tv(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=tv(e.attr,r.tfDeprecatedName,r.defaultValue));break;case\"bool\":i=Yx(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=Yx(e.attr,r.tfDeprecatedName,r.defaultValue));break;case\"bool[]\":i=rv(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=rv(e.attr,r.tfDeprecatedName,r.defaultValue));break;case\"shape\":i=ev(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=ev(e.attr,r.tfDeprecatedName,r.defaultValue));break;case\"shape[]\":i=av(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=av(e.attr,r.tfDeprecatedName,r.defaultValue));break;case\"dtype\":i=Jx(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=Jx(e.attr,r.tfDeprecatedName,r.defaultValue));break;case\"dtype[]\":i=Qx(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=Qx(e.attr,r.tfDeprecatedName,r.defaultValue));break;case\"func\":i=WI(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=WI(e.attr,r.tfDeprecatedName,r.defaultValue));break;case\"tensor\":case\"tensors\":break;default:throw new Error(`Unsupported param type: ${r.type} for op: ${e.op}`)}return a[r.name]={value:i,type:s},a},{})),n}mapFunction(e){let t=e.nodeDef,n=[],a=[],r={};t!=null&&(r=t.reduce((u,p)=>(u[p.name]=this.mapNode(p),p.op===\"Const\"&&a.push(u[p.name]),u),{}));let s=[],i=[];e.signature.inputArg.forEach(u=>{let[p]=Sr(u.name),d={name:p,op:\"Placeholder\",inputs:[],inputNames:[],category:\"graph\",inputParams:{},attrParams:{dtype:{value:A1(u.type),type:\"dtype\"}},children:[]};d.signatureKey=u.name,s.push(d),r[p]=d}),Object.keys(r).forEach(u=>{let p=r[u];p.inputNames.forEach((d,c)=>{let[h,,m]=Sr(d),f=r[h];if(f.outputs!=null){let g=f.outputs.indexOf(m);if(g!==-1){let b=`${h}:${g}`;p.inputNames[c]=b}}p.inputs.push(f),f.children.push(p)})});let o=e.ret;e.signature.outputArg.forEach(u=>{let[p,d]=Sr(o[u.name]),c=r[p];c!=null&&(c.defaultOutput=d,i.push(c))});let l=this.mapArgsToSignature(e);return{nodes:r,inputs:s,outputs:i,weights:a,placeholders:n,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function Mq(e){let t=G().global;if(typeof t.atob!=\"undefined\")return t.atob(e);if(typeof Buffer!=\"undefined\")return new Buffer(e,\"base64\").toString();throw new Error(\"Unable to decode base64 in this environment. Missing built-in atob() or Buffer()\")}function sE(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):Mq(e);return t?n:n.toLowerCase()}function Xx(e,t,n,a=!1){let r=e[t];return r!=null?sE(r.s,a):n}function Yx(e,t,n){let a=e[t];return a?a.b:n}function Zx(e,t,n){let a=e[t]||{},r=a.i!=null?a.i:a.f!=null?a.f:n;return typeof r==\"number\"?r:parseInt(r,10)}function A1(e){switch(typeof e==\"string\"&&(e=qn[e]),e){case qn.DT_FLOAT:case qn.DT_HALF:return\"float32\";case qn.DT_INT32:case qn.DT_INT64:case qn.DT_INT8:case qn.DT_UINT8:return\"int32\";case qn.DT_BOOL:return\"bool\";case qn.DT_DOUBLE:return\"float32\";case qn.DT_STRING:return\"string\";case qn.DT_COMPLEX64:case qn.DT_COMPLEX128:return\"complex64\";default:return null}}function WI(e,t,n){let a=e[t];return a&&a.func?a.func.name:n}function Jx(e,t,n){let a=e[t];return a&&a.type?A1(a.type):n}function Qx(e,t,n){let a=e[t];return a&&a.list&&a.list.type?a.list.type.map(r=>A1(r)):n}function iE(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size==\"number\"?t.size:parseInt(t.size,10)):[]}function ev(e,t,n){let a=e[t];return a&&a.shape?iE(a.shape):n}function tv(e,t,n){let a=e[t];return a?((a.list.f&&a.list.f.length?a.list.f:a.list.i)||[]).map(r=>typeof r==\"number\"?r:parseInt(r,10)):n}function nv(e,t,n,a=!1){let r=e[t];return r&&r.list&&r.list.s?r.list.s.map(s=>sE(s,a)):n}function av(e,t,n){let a=e[t];return a&&a.list&&a.list.shape?a.list.shape.map(r=>iE(r)):n}function rv(e,t,n){let a=e[t];return a&&a.list&&a.list.b?a.list.b:n}var Oq=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(a=>this.getInput(a)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((a,r)=>(a[r]=this.getAttr(r),a),{}))}getInput(e){return pn(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return pn(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return Zx(this.node.rawAttrs,e,t);if(n.s!=null)return Xx(this.node.rawAttrs,e,t);if(n.b!=null)return Yx(this.node.rawAttrs,e,t);if(n.shape!=null)return ev(this.node.rawAttrs,e,t);if(n.type!=null)return Jx(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return tv(this.node.rawAttrs,e,t);if(n.list.s!=null)return nv(this.node.rawAttrs,e,t);if(n.list.shape!=null)return av(this.node.rawAttrs,e,t);if(n.list.b!=null)return rv(this.node.rawAttrs,e,t);if(n.list.type!=null)return Qx(this.node.rawAttrs,e,t)}return t}},on={};_e(on,{OP_SCOPE_SUFFIX:()=>Fv,abs:()=>Lt,acos:()=>Pv,acosh:()=>Lv,add:()=>X,addN:()=>vN,all:()=>Lm,any:()=>yc,argMax:()=>di,argMin:()=>zv,asin:()=>Wv,asinh:()=>Bv,atan:()=>Vv,atan2:()=>Uv,atanh:()=>Gv,avgPool:()=>ya,avgPool3d:()=>jv,basicLSTMCell:()=>SN,batchNorm:()=>Ns,batchNorm2d:()=>qv,batchNorm3d:()=>Kv,batchNorm4d:()=>Xv,batchToSpaceND:()=>id,bincount:()=>Yv,bitwiseAnd:()=>NN,booleanMaskAsync:()=>mT,broadcastArgs:()=>TN,broadcastTo:()=>ai,buffer:()=>Oe,cast:()=>re,ceil:()=>Zv,clipByValue:()=>an,clone:()=>sr,complex:()=>_r,concat:()=>et,concat1d:()=>Jv,concat2d:()=>Qv,concat3d:()=>ew,concat4d:()=>tw,conv1d:()=>zm,conv2d:()=>$t,conv2dTranspose:()=>Wm,conv3d:()=>aw,conv3dTranspose:()=>rw,cos:()=>od,cosh:()=>Bm,cosineWindow:()=>pf,cumprod:()=>wc,cumsum:()=>Vm,denseBincount:()=>Xh,depthToSpace:()=>sw,depthwiseConv2d:()=>Ts,diag:()=>EN,dilation2d:()=>iw,div:()=>he,divNoNan:()=>ow,dot:()=>lw,dropout:()=>Pw,einsum:()=>Zs,elu:()=>Qu,enclosingPowerOfTwo:()=>Lw,ensureShape:()=>AN,equal:()=>Jn,erf:()=>Um,euclideanNorm:()=>cw,exp:()=>dn,expandDims:()=>Gt,expm1:()=>dw,eye:()=>Gm,fft:()=>bd,fill:()=>yn,floor:()=>tp,floorDiv:()=>Pm,fused:()=>Vl,gather:()=>np,gatherND:()=>yT,greater:()=>Cn,greaterEqual:()=>$r,ifft:()=>Bl,imag:()=>ld,image:()=>Zn,inTopKAsync:()=>xT,irfft:()=>af,isFinite:()=>hw,isInf:()=>mw,isNaN:()=>fw,leakyRelu:()=>ud,less:()=>Pl,lessEqual:()=>Cs,linalg:()=>Bw,linspace:()=>MN,localResponseNormalization:()=>gw,log:()=>Qn,log1p:()=>pd,logSigmoid:()=>bw,logSoftmax:()=>jm,logSumExp:()=>cd,logicalAnd:()=>_a,logicalNot:()=>dd,logicalOr:()=>qm,logicalXor:()=>yw,losses:()=>FT,lowerBound:()=>PN,matMul:()=>$e,max:()=>ma,maxPool:()=>Dt,maxPool3d:()=>xw,maxPoolWithArgmax:()=>LN,maximum:()=>hr,mean:()=>Ct,meshgrid:()=>zN,min:()=>Ol,minimum:()=>ds,mirrorPad:()=>vw,mod:()=>ww,moments:()=>hd,movingAverage:()=>fT,mul:()=>z,multiRNNCell:()=>WN,multinomial:()=>BN,neg:()=>yt,norm:()=>ep,notEqual:()=>fi,oneHot:()=>Ll,ones:()=>Pn,onesLike:()=>ea,op:()=>L,outerProduct:()=>VN,pad:()=>xa,pad1d:()=>UN,pad2d:()=>GN,pad3d:()=>HN,pad4d:()=>jN,pool:()=>kw,pow:()=>ur,prelu:()=>fd,print:()=>Ov,prod:()=>Iw,raggedGather:()=>qN,raggedRange:()=>KN,raggedTensorToTensor:()=>XN,rand:()=>YN,randomGamma:()=>eT,randomNormal:()=>Xm,randomStandardNormal:()=>tT,randomUniform:()=>Es,randomUniformInt:()=>nT,range:()=>gi,real:()=>zl,reciprocal:()=>Ew,relu:()=>Ke,relu6:()=>Ym,reshape:()=>W,reverse:()=>ba,reverse1d:()=>aT,reverse2d:()=>rT,reverse3d:()=>sT,reverse4d:()=>iT,rfft:()=>yd,round:()=>Zm,rsqrt:()=>Jm,scalar:()=>xe,scatterND:()=>gT,searchSorted:()=>Km,selu:()=>Qm,separableConv2d:()=>_s,setdiff1dAsync:()=>oT,sigmoid:()=>ha,sign:()=>_w,signal:()=>AT,sin:()=>ef,sinh:()=>tf,slice:()=>Ve,slice1d:()=>gd,slice2d:()=>nf,slice3d:()=>Ho,slice4d:()=>Wl,softmax:()=>qa,softplus:()=>Go,spaceToBatchND:()=>md,sparse:()=>$T,sparseToDense:()=>bT,spectral:()=>_T,split:()=>Ln,sqrt:()=>rn,square:()=>pt,squaredDifference:()=>rf,squeeze:()=>As,stack:()=>At,step:()=>jo,stridedSlice:()=>Aw,string:()=>DT,sub:()=>pe,sum:()=>fe,tan:()=>Fw,tanh:()=>cs,tensor:()=>bn,tensor1d:()=>je,tensor2d:()=>Ea,tensor3d:()=>xd,tensor4d:()=>Fa,tensor5d:()=>lT,tensor6d:()=>uT,tensorScatterUpdate:()=>cT,tile:()=>On,topk:()=>Dw,transpose:()=>De,truncatedNormal:()=>lf,unique:()=>Rw,unsortedSegmentSum:()=>uf,unstack:()=>dt,upperBound:()=>dT,variable:()=>Mw,where:()=>nn,whereAsync:()=>Ow,zeros:()=>It,zerosLike:()=>qe});var Pq=(e,t,n,a=on)=>{switch(e.op){case\"BiasAdd\":case\"AddV2\":case\"Add\":return[a.add(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"AddN\":return[a.addN(k(\"tensors\",e,t,n))];case\"FloorMod\":case\"Mod\":return[a.mod(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"Mul\":return[a.mul(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"RealDiv\":case\"Div\":return[a.div(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"DivNoNan\":return[a.divNoNan(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"FloorDiv\":return[a.floorDiv(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"Sub\":return[a.sub(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"Minimum\":return[a.minimum(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"Maximum\":return[a.maximum(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"Pow\":return[a.pow(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"SquaredDifference\":return[a.squaredDifference(k(\"a\",e,t,n),k(\"b\",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Lq=(e,t,n,a=on)=>{switch(e.op){case\"Abs\":case\"ComplexAbs\":return[a.abs(k(\"x\",e,t,n))];case\"Acos\":return[a.acos(k(\"x\",e,t,n))];case\"Acosh\":return[a.acosh(k(\"x\",e,t,n))];case\"Asin\":return[a.asin(k(\"x\",e,t,n))];case\"Asinh\":return[a.asinh(k(\"x\",e,t,n))];case\"Atan\":return[a.atan(k(\"x\",e,t,n))];case\"Atan2\":return[a.atan2(k(\"x\",e,t,n),k(\"y\",e,t,n))];case\"Atanh\":return[a.atanh(k(\"x\",e,t,n))];case\"Ceil\":return[a.ceil(k(\"x\",e,t,n))];case\"Complex\":return[a.complex(k(\"real\",e,t,n),k(\"imag\",e,t,n))];case\"Cos\":return[a.cos(k(\"x\",e,t,n))];case\"Cosh\":return[a.cosh(k(\"x\",e,t,n))];case\"Elu\":return[a.elu(k(\"x\",e,t,n))];case\"Erf\":return[a.erf(k(\"x\",e,t,n))];case\"Exp\":return[a.exp(k(\"x\",e,t,n))];case\"Expm1\":return[a.expm1(k(\"x\",e,t,n))];case\"Floor\":return[a.floor(k(\"x\",e,t,n))];case\"Log\":return[a.log(k(\"x\",e,t,n))];case\"Log1p\":return[a.log1p(k(\"x\",e,t,n))];case\"Imag\":return[a.imag(k(\"x\",e,t,n))];case\"Neg\":return[a.neg(k(\"x\",e,t,n))];case\"Reciprocal\":return[a.reciprocal(k(\"x\",e,t,n))];case\"Real\":return[a.real(k(\"x\",e,t,n))];case\"Relu\":return[a.relu(k(\"x\",e,t,n))];case\"Round\":return[a.round(k(\"x\",e,t,n))];case\"Selu\":return[a.selu(k(\"x\",e,t,n))];case\"Sigmoid\":return[a.sigmoid(k(\"x\",e,t,n))];case\"Sin\":return[a.sin(k(\"x\",e,t,n))];case\"Sign\":return[a.sign(k(\"x\",e,t,n))];case\"Sinh\":return[a.sinh(k(\"x\",e,t,n))];case\"Softplus\":return[a.softplus(k(\"x\",e,t,n))];case\"Sqrt\":return[a.sqrt(k(\"x\",e,t,n))];case\"Square\":return[a.square(k(\"x\",e,t,n))];case\"Tanh\":return[a.tanh(k(\"x\",e,t,n))];case\"Tan\":return[a.tan(k(\"x\",e,t,n))];case\"ClipByValue\":return[a.clipByValue(k(\"x\",e,t,n),k(\"clipValueMin\",e,t,n),k(\"clipValueMax\",e,t,n))];case\"Relu6\":return[a.relu6(k(\"x\",e,t,n))];case\"Rsqrt\":return[a.rsqrt(pn(e.inputNames[0],t,n))];case\"LeakyRelu\":return[a.leakyRelu(k(\"x\",e,t,n),k(\"alpha\",e,t,n))];case\"Prelu\":return[a.prelu(k(\"x\",e,t,n),k(\"alpha\",e,t,n))];case\"IsNan\":return[a.isNaN(pn(e.inputNames[0],t,n))];case\"IsInf\":return[a.isInf(pn(e.inputNames[0],t,n))];case\"IsFinite\":return[a.isFinite(pn(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Ca(e,t,n=\"\"){if(!(typeof e==\"number\"||typeof t==\"number\")){w.assert(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let a=0;a<e.length;a++){let r=e[a],s=t[a];w.assert(r<0||s<0||r===s,()=>n+` Shapes ${e} and ${t} must match`)}}}function BI(e){return!(typeof e==\"number\"||e.some(t=>t<0))}function Zp(e,t,n){let a=sv(e,n),r=!BI(a);if(r&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${a}`);if(r&&t.forEach(s=>{a=sv(s.shape,a)}),!BI(a))throw new Error(`Non-fully-defined elementShape: ${a}`);return a}function sv(e,t){if(typeof e==\"number\")return t;if(typeof t==\"number\")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let a=0;a<e.length;++a){let r=e[a],s=t[a];if(r>=0&&s>=0&&r!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[a]=r>=0?r:s}return n}var zq=class{constructor(e,t,n,a,r,s,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=a,this.identicalElementShapes=r,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=xe(0),Ht(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Ca(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Ht(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,a)=>this.write(n,t[a]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let a=0;a<this.size();a++)e.push(a)}if(e.length===0)return bn([],[0].concat(this.elementShape));let n=this.readMany(e);return Ca(this.elementShape,n[0].shape,\"TensorArray shape mismatch: \"),At(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return bn([],[0].concat(this.elementShape));let t=[];for(let a=0;a<this.size();a++)t.push(a);let n=this.readMany(t);return Ca(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),et(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,dt(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,a=e.map(o=>(n+=o,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let r=n===0?0:t.size/n,s=[];O(()=>{t=W(t,[1,n,r]);for(let o=0;o<e.length;++o){let l=[0,o===0?0:a[o-1],0],u=[1,e[o],r];s[o]=W(Ve(t,l,u),this.elementShape)}return s});let i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,s)}},Lf=class iv{get id(){return this.idTensor.id}constructor(t,n,a,r=-1){this.tensors=t,this.elementShape=n,this.elementDtype=a,t!=null&&t.forEach(s=>{if(a!==s.dtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${s.dtype}`);Ca(n,s.shape,\"TensorList shape mismatch: \"),Ht(s)}),this.idTensor=xe(0),this.maxNumElements=r,Ht(this.idTensor)}copy(){return new iv([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,a=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(a!==-1&&this.tensors.length!==a)throw new Error(`Operation expected a list with ${a} elements but got a list with ${this.tensors.length} elements.`);Ca(t,this.elementShape,\"TensorList shape mismatch: \");let r=Zp(this.elementShape,this.tensors,t);return O(()=>{let s=this.tensors.map(i=>W(i,r));return At(s,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error(\"Trying to pop from an empty list.\");let a=Zp(this.elementShape,this.tensors,t),r=this.tensors.pop();return r.kept=!1,Ca(r.shape,t,\"TensorList shape mismatch: \"),W(r,a)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Ca(t.shape,this.elementShape,\"TensorList shape mismatch: \"),this.maxNumElements===this.size())throw new Error(\"Trying to push element into a full list.\");Ht(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let n=new iv([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let a=0;a<Math.min(this.tensors.length,t);++a)n.tensors[a]=this.tensors[a];return n}getItem(t,n,a){if(a!==this.elementDtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);Ca(this.tensors[t].shape,n,\"TensorList shape mismatch: \");let r=Zp(this.elementShape,this.tensors,n);return W(this.tensors[t],r)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Ca(this.elementShape,n.shape,\"TensorList shape mismatch: \"),Ht(n),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=n}gather(t,n,a){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);Ca(this.elementShape,a,\"TensorList shape mismatch: \"),t=t.slice(0,this.size());let r=Zp(this.elementShape,this.tensors,a);return t.length===0?bn([],[0].concat(r)):O(()=>{let s=t.map(i=>W(this.tensors[i],r));return At(s,0)})}concat(t,n){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Ca(this.elementShape,n,\"TensorList shape mismatch: \");let a=Zp(this.elementShape,this.tensors,n);return this.size()===0?bn([],[0].concat(a)):O(()=>{let r=this.tensors.map(s=>W(s,a));return et(r,0)})}};function Wq(e,t,n){let a=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let r=e.shape.slice(1);Ca(r,t,\"TensorList shape mismatch: \");let s=dt(e);return new Lf(s,t,a)}function Bq(e,t,n,a){return new Lf([],e,t,a)}function Vq(e,t,n,a){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let r=Math.max(...t);if(a!=null&&a!==-1&&r>=a)throw new Error(`Max index must be < array size (${r}  vs. ${a})`);let s=new Lf([],n,e.dtype,a),i=dt(e,0);return t.forEach((o,l)=>{s.setItem(o,i[l])}),s}function Uq(e,t,n){let a=0,r=t.map(p=>(a+=p,a));if(a!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${a}, and tensor's shape is: ${e.shape}`);let s=e.shape.slice(1),i=sv(s,n),o=a===0?0:e.size/a,l=O(()=>{let p=[];e=W(e,[1,a,o]);for(let d=0;d<t.length;++d){let c=[0,d===0?0:r[d-1],0],h=[1,t[d],o];p[d]=W(Ve(e,c,h),i)}return e.dispose(),p}),u=new Lf([],n,e.dtype,t.length);for(let p=0;p<l.length;p++)u.setItem(p,l[p]);return u}var Gq=async(e,t,n)=>{switch(e.op){case\"If\":case\"StatelessIf\":{let a=k(\"thenBranch\",e,t,n),r=k(\"elseBranch\",e,t,n),s=k(\"cond\",e,t,n),i=k(\"args\",e,t,n);return(await s.data())[0]?n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case\"While\":case\"StatelessWhile\":{let a=k(\"body\",e,t,n),r=k(\"cond\",e,t,n),s=k(\"args\",e,t,n),i=await n.functionMap[r].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map(p=>p.id),l=await i[0].data();i.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&p.dispose()});let u=s;for(;l[0];){let p=u;u=await n.functionMap[a].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);let d=u.map(h=>h.id);p.forEach(h=>{!h.kept&&o.indexOf(h.id)===-1&&d.indexOf(h.id)===-1&&h.dispose()});let c=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await c[0].data(),c.forEach(h=>{!h.kept&&o.indexOf(h.id)===-1&&d.indexOf(h.id)===-1&&h.dispose()})}return u}case\"LoopCond\":{let a=k(\"pred\",e,t,n);return[Nr(a)]}case\"Switch\":{let a=k(\"pred\",e,t,n),r=k(\"data\",e,t,n);return r.kept||(r=Nr(r)),(await a.data())[0]?[void 0,r]:[r,void 0]}case\"Merge\":{let a=e.inputNames.find(r=>pn(r,t,n)!==void 0);if(a){let r=pn(a,t,n);return[Nr(r)]}return}case\"Enter\":{let a=k(\"frameName\",e,t,n),r=k(\"tensor\",e,t,n);return n.enterFrame(a),[Nr(r)]}case\"Exit\":{let a=k(\"tensor\",e,t,n);return n.exitFrame(),[Nr(a)]}case\"NextIteration\":{let a=k(\"tensor\",e,t,n);return n.nextIteration(),[Nr(a)]}case\"TensorArrayV3\":{let a=k(\"size\",e,t,n),r=k(\"dtype\",e,t,n),s=k(\"elementShape\",e,t,n),i=k(\"dynamicSize\",e,t,n),o=k(\"clearAfterRead\",e,t,n),l=k(\"identicalElementShapes\",e,t,n),u=k(\"name\",e,t,n),p=new zq(u,r,a,s,l,i,o);return n.addTensorArray(p),[p.idTensor,xe(1)]}case\"TensorArrayWriteV3\":{let a=k(\"tensorArrayId\",e,t,n),r=k(\"index\",e,t,n),s=k(\"tensor\",e,t,n),i=n.getTensorArray(a.id);return i.write(r,s),[i.idTensor]}case\"TensorArrayReadV3\":{let a=k(\"tensorArrayId\",e,t,n),r=k(\"index\",e,t,n);return[n.getTensorArray(a.id).read(r)]}case\"TensorArrayGatherV3\":{let a=k(\"tensorArrayId\",e,t,n),r=k(\"indices\",e,t,n),s=k(\"dtype\",e,t,n);return[n.getTensorArray(a.id).gather(r,s)]}case\"TensorArrayScatterV3\":{let a=k(\"tensorArrayId\",e,t,n),r=k(\"indices\",e,t,n),s=k(\"tensor\",e,t,n),i=n.getTensorArray(a.id);return i.scatter(r,s),[i.idTensor]}case\"TensorArrayConcatV3\":{let a=k(\"tensorArrayId\",e,t,n),r=n.getTensorArray(a.id),s=k(\"dtype\",e,t,n);return[r.concat(s)]}case\"TensorArraySplitV3\":{let a=k(\"tensorArrayId\",e,t,n),r=k(\"tensor\",e,t,n),s=k(\"lengths\",e,t,n),i=n.getTensorArray(a.id);return i.split(s,r),[i.idTensor]}case\"TensorArraySizeV3\":{let a=k(\"tensorArrayId\",e,t,n),r=n.getTensorArray(a.id);return[xe(r.size(),\"int32\")]}case\"TensorArrayCloseV3\":{let a=k(\"tensorArrayId\",e,t,n),r=n.getTensorArray(a.id);return r.clearAndClose(),[r.idTensor]}case\"TensorListSetItem\":{let a=k(\"tensorListId\",e,t,n),r=k(\"index\",e,t,n),s=k(\"tensor\",e,t,n),i=n.getTensorList(a.id);return i.setItem(r,s),[i.idTensor]}case\"TensorListGetItem\":{let a=k(\"tensorListId\",e,t,n),r=k(\"index\",e,t,n),s=k(\"elementShape\",e,t,n),i=k(\"elementDType\",e,t,n);return[n.getTensorList(a.id).getItem(r,s,i)]}case\"TensorListScatterV2\":case\"TensorListScatter\":{let a=k(\"indices\",e,t,n),r=k(\"tensor\",e,t,n),s=k(\"elementShape\",e,t,n),i=k(\"numElements\",e,t,n),o=Vq(r,a,s,i);return n.addTensorList(o),[o.idTensor]}case\"TensorListReserve\":case\"EmptyTensorList\":{let a=k(\"elementShape\",e,t,n),r=k(\"elementDType\",e,t,n),s;e.op===\"TensorListReserve\"?s=\"numElements\":s=\"maxNumElements\";let i=k(s,e,t,n),o=e.op===\"TensorListReserve\"?-1:i,l=Bq(a,r,i,o);return n.addTensorList(l),[l.idTensor]}case\"TensorListGather\":{let a=k(\"tensorListId\",e,t,n),r=k(\"indices\",e,t,n),s=k(\"elementShape\",e,t,n),i=k(\"elementDType\",e,t,n);return[n.getTensorList(a.id).gather(r,i,s)]}case\"TensorListStack\":{let a=k(\"tensorListId\",e,t,n),r=k(\"elementShape\",e,t,n),s=k(\"elementDType\",e,t,n),i=k(\"numElements\",e,t,n);return[n.getTensorList(a.id).stack(r,s,i)]}case\"TensorListFromTensor\":{let a=k(\"tensor\",e,t,n),r=k(\"elementShape\",e,t,n),s=k(\"elementDType\",e,t,n),i=Wq(a,r,s);return n.addTensorList(i),[i.idTensor]}case\"TensorListConcat\":case\"TensorListConcatV2\":{let a=k(\"tensorListId\",e,t,n),r=n.getTensorList(a.id),s=k(\"dtype\",e,t,n),i=k(\"elementShape\",e,t,n);return[r.concat(s,i)]}case\"TensorListPushBack\":{let a=k(\"tensorListId\",e,t,n),r=k(\"tensor\",e,t,n),s=n.getTensorList(a.id);return s.pushBack(r),[s.idTensor]}case\"TensorListPopBack\":{let a=k(\"tensorListId\",e,t,n),r=k(\"elementShape\",e,t,n),s=k(\"elementDType\",e,t,n);return[n.getTensorList(a.id).popBack(r,s)]}case\"TensorListSplit\":{let a=k(\"tensor\",e,t,n),r=k(\"elementShape\",e,t,n),s=k(\"lengths\",e,t,n),i=Uq(a,s,r);return n.addTensorList(i),[i.idTensor]}case\"TensorListLength\":{let a=k(\"tensorListId\",e,t,n),r=n.getTensorList(a.id);return[xe(r.size(),\"int32\")]}case\"TensorListResize\":{let a=k(\"tensorListId\",e,t,n),r=k(\"size\",e,t,n),s=n.getTensorList(a.id).resize(r);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function VI(e,t,n){let[a,r]=k(\"fusedOps\",e,t,n),s=a===\"biasadd\",i=!s,o=r===\"prelu\",l=a===\"fusedbatchnorm\",u=k(\"numArgs\",e,t,n);if(s){if(o&&u!==2)throw new Error(\"FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.\");if(!o&&s&&u!==1)throw new Error(\"FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.\")}if(l)throw new Error(\"FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported\");let p=k(\"strides\",e,t,n),d=Mh(e,t,n),c=k(\"dataFormat\",e,t,n).toUpperCase(),h=k(\"dilations\",e,t,n),[m,f]=k(\"args\",e,t,n);i&&(f=m,m=void 0);let g=k(\"leakyreluAlpha\",e,t,n);return{stride:p,pad:d,dataFormat:c,dilations:h,biasArg:m,preluArg:f,activationFunc:r,leakyreluAlpha:g}}var Hq=(e,t,n,a=on)=>{switch(e.op){case\"Conv1D\":{let r=k(\"stride\",e,t,n),s=k(\"pad\",e,t,n),i=k(\"dataFormat\",e,t,n).toUpperCase(),o=k(\"dilation\",e,t,n);return[a.conv1d(k(\"x\",e,t,n),k(\"filter\",e,t,n),r,s,i,o)]}case\"Conv2D\":{let r=k(\"strides\",e,t,n),s=Mh(e,t,n),i=k(\"dataFormat\",e,t,n).toUpperCase(),o=k(\"dilations\",e,t,n);return[a.conv2d(k(\"x\",e,t,n),k(\"filter\",e,t,n),[r[1],r[2]],s,i,[o[1],o[2]])]}case\"_FusedConv2D\":{let{stride:r,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:p,leakyreluAlpha:d}=VI(e,t,n);return[a.fused.conv2d({x:k(\"x\",e,t,n),filter:k(\"filter\",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:p,preluActivationWeights:u,leakyreluAlpha:d})]}case\"FusedDepthwiseConv2dNative\":{let{stride:r,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:p,leakyreluAlpha:d}=VI(e,t,n);return[a.fused.depthwiseConv2d({x:k(\"x\",e,t,n),filter:k(\"filter\",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:p,preluActivationWeights:u,leakyreluAlpha:d})]}case\"Conv2DBackpropInput\":case\"Conv2dTranspose\":{let r=k(\"outputShape\",e,t,n),s=k(\"strides\",e,t,n),i=Mh(e,t,n);return[a.conv2dTranspose(k(\"x\",e,t,n),k(\"filter\",e,t,n),r,[s[1],s[2]],i)]}case\"DepthwiseConv2dNative\":case\"DepthwiseConv2d\":{let r=k(\"strides\",e,t,n),s=Mh(e,t,n),i=k(\"dilations\",e,t,n),o=k(\"dataFormat\",e,t,n).toUpperCase();return[a.depthwiseConv2d(k(\"input\",e,t,n),k(\"filter\",e,t,n),[r[1],r[2]],s,o,[i[1],i[2]])]}case\"Conv3D\":{let r=k(\"strides\",e,t,n),s=k(\"pad\",e,t,n),i=k(\"dataFormat\",e,t,n).toUpperCase(),o=k(\"dilations\",e,t,n);return[a.conv3d(k(\"x\",e,t,n),k(\"filter\",e,t,n),[r[1],r[2],r[3]],s,i,[o[1],o[2],o[3]])]}case\"AvgPool\":{let r=k(\"strides\",e,t,n),s=k(\"pad\",e,t,n),i=k(\"kernelSize\",e,t,n);return[a.avgPool(k(\"x\",e,t,n),[i[1],i[2]],[r[1],r[2]],s)]}case\"MaxPool\":{let r=k(\"strides\",e,t,n),s=k(\"pad\",e,t,n),i=k(\"kernelSize\",e,t,n);return[a.maxPool(k(\"x\",e,t,n),[i[1],i[2]],[r[1],r[2]],s)]}case\"MaxPoolWithArgmax\":{let r=k(\"strides\",e,t,n),s=k(\"pad\",e,t,n),i=k(\"kernelSize\",e,t,n),o=k(\"includeBatchInIndex\",e,t,n),{result:l,indexes:u}=a.maxPoolWithArgmax(k(\"x\",e,t,n),[i[1],i[2]],[r[1],r[2]],s,o);return[l,u]}case\"AvgPool3D\":{let r=k(\"strides\",e,t,n),s=k(\"pad\",e,t,n),i=k(\"kernelSize\",e,t,n);return[a.avgPool3d(k(\"x\",e,t,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],s)]}case\"MaxPool3D\":{let r=k(\"strides\",e,t,n),s=k(\"pad\",e,t,n),i=k(\"kernelSize\",e,t,n);return[a.maxPool3d(k(\"x\",e,t,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],s)]}case\"Dilation2D\":{let r=k(\"strides\",e,t,n),s=k(\"pad\",e,t,n),i=k(\"dilations\",e,t,n),o=r[1],l=r[2],u=i[1],p=i[2];return[a.dilation2d(k(\"x\",e,t,n),k(\"filter\",e,t,n),[o,l],s,[u,p],\"NHWC\")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},jq=(e,t,n,a=on)=>{switch(e.op){case\"Fill\":{let r=k(\"shape\",e,t,n),s=k(\"dtype\",e,t,n),i=k(\"value\",e,t,n);return[a.fill(r,i,s)]}case\"LinSpace\":{let r=k(\"start\",e,t,n),s=k(\"stop\",e,t,n),i=k(\"num\",e,t,n);return[a.linspace(r,s,i)]}case\"Multinomial\":{let r=k(\"logits\",e,t,n),s=k(\"numSamples\",e,t,n),i=k(\"seed\",e,t,n);return[a.multinomial(r,s,i)]}case\"OneHot\":{let r=k(\"indices\",e,t,n),s=k(\"depth\",e,t,n),i=k(\"onValue\",e,t,n),o=k(\"offValue\",e,t,n),l=k(\"dtype\",e,t,n);return[a.oneHot(r,s,i,o,l)]}case\"Ones\":return[a.ones(k(\"shape\",e,t,n),k(\"dtype\",e,t,n))];case\"OnesLike\":return[a.onesLike(k(\"x\",e,t,n))];case\"RandomStandardNormal\":return[a.randomStandardNormal(k(\"shape\",e,t,n),k(\"dtype\",e,t,n),k(\"seed\",e,t,n))];case\"RandomUniform\":return[a.randomUniform(k(\"shape\",e,t,n),k(\"minval\",e,t,n),k(\"maxval\",e,t,n),k(\"dtype\",e,t,n))];case\"RandomUniformInt\":return[a.randomUniformInt(k(\"shape\",e,t,n),k(\"minval\",e,t,n),k(\"maxval\",e,t,n),k(\"seed\",e,t,n))];case\"Range\":{let r=k(\"start\",e,t,n),s=k(\"stop\",e,t,n),i=k(\"step\",e,t,n);return[a.range(r,s,i,k(\"dtype\",e,t,n))]}case\"TruncatedNormal\":{let r=k(\"shape\",e,t,n),s=k(\"mean\",e,t,n),i=k(\"stdDev\",e,t,n),o=k(\"seed\",e,t,n);return[a.truncatedNormal(r,s,i,k(\"dtype\",e,t,n),o)]}case\"Zeros\":return[a.zeros(k(\"shape\",e,t,n),k(\"dtype\",e,t,n))];case\"ZerosLike\":return[a.zerosLike(k(\"x\",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function gx(e,t,n){let a=k(\"boxes\",e,t,n),r=k(\"scores\",e,t,n),s=k(\"maxOutputSize\",e,t,n),i=k(\"iouThreshold\",e,t,n),o=k(\"scoreThreshold\",e,t,n),l=k(\"softNmsSigma\",e,t,n);return{boxes:a,scores:r,maxOutputSize:s,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}}var qq=async(e,t,n,a,r=on)=>{switch(e.op){case\"NonMaxSuppressionV5\":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u,softNmsSigma:p}=gx(e,t,n),d=await r.image.nonMaxSuppressionWithScoreAsync(s,i,o,l,u,p);return[d.selectedIndices,d.selectedScores]}case\"NonMaxSuppressionV4\":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=gx(e,t,n),p=k(\"padToMaxOutputSize\",e,t,n),d=await r.image.nonMaxSuppressionPaddedAsync(s,i,o,l,u,p);return[d.selectedIndices,d.validOutputs]}case\"NonMaxSuppressionV3\":case\"NonMaxSuppressionV2\":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=gx(e,t,n);return[await r.image.nonMaxSuppressionAsync(s,i,o,l,u)]}case\"Where\":{let s=r.cast(k(\"condition\",e,t,n),\"bool\"),i=[await r.whereAsync(s)];return s.dispose(),i}case\"ListDiff\":return r.setdiff1dAsync(k(\"x\",e,t,n),k(\"y\",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},Kq=(e,t,n,a=on)=>{switch(e.op){case\"LowerBound\":{let r=k(\"sortedSequence\",e,t,n),s=k(\"values\",e,t,n);return[a.lowerBound(r,s)]}case\"TopKV2\":{let r=k(\"x\",e,t,n),s=k(\"k\",e,t,n),i=k(\"sorted\",e,t,n),o=a.topk(r,s,i);return[o.values,o.indices]}case\"UpperBound\":{let r=k(\"sortedSequence\",e,t,n),s=k(\"values\",e,t,n);return[a.upperBound(r,s)]}case\"Unique\":{let r=k(\"x\",e,t,n),s=a.unique(r);return[s.values,s.indices]}case\"UniqueV2\":{let r=k(\"x\",e,t,n),s=k(\"axis\",e,t,n),i=a.unique(r,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Xq=(e,t,n,a=on)=>{switch(e.op){case\"Const\":return t[e.name];case\"PlaceholderWithDefault\":let r=k(\"default\",e,t,n);return[pn(e.name,t,n)||r];case\"Placeholder\":return[pn(e.name,t,n)];case\"Identity\":case\"StopGradient\":case\"FakeQuantWithMinMaxVars\":{let p=k(\"x\",e,t,n);return[Nr(p)]}case\"IdentityN\":return k(\"x\",e,t,n).map(p=>Nr(p));case\"Snapshot\":let s=k(\"x\",e,t,n);return[Nr(s)];case\"Shape\":return[a.tensor1d(k(\"x\",e,t,n).shape,\"int32\")];case\"ShapeN\":return k(\"x\",e,t,n).map(p=>a.tensor1d(p.shape));case\"Size\":return[a.scalar(k(\"x\",e,t,n).size,\"int32\")];case\"Rank\":return[a.scalar(k(\"x\",e,t,n).rank,\"int32\")];case\"NoOp\":return[a.scalar(1)];case\"Print\":let i=k(\"x\",e,t,n),o=k(\"data\",e,t,n),l=k(\"message\",e,t,n),u=k(\"summarize\",e,t,n);console.warn(\"The graph has a tf.print() operation,usually used for debugging, which slows down performance.\"),console.log(l);for(let p=0;p<o.length;p++)console.log(Array.prototype.slice.call(o[p].dataSync()).slice(0,u));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Yq=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=xe(0),this.tensorMap=new Map,Ht(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return xe(this.size(),\"int32\")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(a=>a.dispose()),this.tensorMap.clear(),O(()=>{let a=dt(t),r=n.length,s=a.length;w.assert(r===s,()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${s} elements.`);for(let i=0;i<r;i++){let o=n[i],l=a[i];Ht(l),this.tensorMap.set(o,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return O(()=>{let a=[];for(let r=0;r<n.length;r++){let s=n[r],i=this.findWithDefault(s,t);a.push(i)}return At(a)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n!=null?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},Zq=async(e,t,n,a)=>{switch(e.op){case\"HashTable\":case\"HashTableV2\":{let r=a.getHashTableHandleByName(e.name);if(r!=null)return[r];{let s=k(\"keyDType\",e,t,n),i=k(\"valueDType\",e,t,n),o=new Yq(s,i);return a.addHashTable(e.name,o),[o.handle]}}case\"InitializeTable\":case\"InitializeTableV2\":case\"LookupTableImport\":case\"LookupTableImportV2\":{let r=k(\"tableHandle\",e,t,n,a),s=k(\"keys\",e,t,n),i=k(\"values\",e,t,n);return[await a.getHashTableById(r.id).import(s,i)]}case\"LookupTableFind\":case\"LookupTableFindV2\":{let r=k(\"tableHandle\",e,t,n,a),s=k(\"keys\",e,t,n),i=k(\"defaultValue\",e,t,n);return[await a.getHashTableById(r.id).find(s,i)]}case\"LookupTableSize\":case\"LookupTableSizeV2\":{let r=k(\"tableHandle\",e,t,n,a);return[a.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Jq=(e,t,n,a=on)=>{switch(e.op){case\"ResizeBilinear\":{let r=k(\"images\",e,t,n),s=k(\"size\",e,t,n),i=k(\"alignCorners\",e,t,n),o=k(\"halfPixelCenters\",e,t,n);return[a.image.resizeBilinear(r,[s[0],s[1]],i,o)]}case\"ResizeNearestNeighbor\":{let r=k(\"images\",e,t,n),s=k(\"size\",e,t,n),i=k(\"alignCorners\",e,t,n),o=k(\"halfPixelCenters\",e,t,n);return[a.image.resizeNearestNeighbor(r,[s[0],s[1]],i,o)]}case\"CropAndResize\":{let r=k(\"image\",e,t,n),s=k(\"boxes\",e,t,n),i=k(\"boxInd\",e,t,n),o=k(\"cropSize\",e,t,n),l=k(\"method\",e,t,n),u=k(\"extrapolationValue\",e,t,n);return[a.image.cropAndResize(r,s,i,o,l,u)]}case\"ImageProjectiveTransformV3\":{let r=k(\"images\",e,t,n),s=k(\"transforms\",e,t,n),i=k(\"outputShape\",e,t,n),o=k(\"fillValue\",e,t,n),l=k(\"interpolation\",e,t,n),u=k(\"fillMode\",e,t,n);return[a.image.transform(r,s,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Qq=(e,t,n,a=on)=>{switch(e.op){case\"Equal\":return[a.equal(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"NotEqual\":return[a.notEqual(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"Greater\":return[a.greater(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"GreaterEqual\":return[a.greaterEqual(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"Less\":return[a.less(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"LessEqual\":return[a.lessEqual(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"LogicalAnd\":return[a.logicalAnd(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"LogicalNot\":return[a.logicalNot(k(\"a\",e,t,n))];case\"LogicalOr\":return[a.logicalOr(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"Select\":case\"SelectV2\":return[a.where(k(\"condition\",e,t,n),k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"BitwiseAnd\":return[a.bitwiseAnd(k(\"a\",e,t,n),k(\"b\",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},e5=(e,t,n,a=on)=>{switch(e.op){case\"BatchMatMul\":case\"BatchMatMulV2\":case\"MatMul\":return[a.matMul(k(\"a\",e,t,n),k(\"b\",e,t,n),k(\"transposeA\",e,t,n),k(\"transposeB\",e,t,n))];case\"Einsum\":return[a.einsum(k(\"equation\",e,t,n),...k(\"tensors\",e,t,n))];case\"Transpose\":return[a.transpose(k(\"x\",e,t,n),k(\"perm\",e,t,n))];case\"_FusedMatMul\":let[r,s]=k(\"fusedOps\",e,t,n),i=r===\"biasadd\",o=s===\"prelu\",l=k(\"numArgs\",e,t,n),u=k(\"leakyreluAlpha\",e,t,n);if(i){if(o&&l!==2)throw new Error(\"Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.\");if(!o&&l!==1)throw new Error(\"Fused MatMul with BiasAdd must have one extra argument: bias.\")}let[p,d]=k(\"args\",e,t,n);return[a.fused.matMul({a:k(\"a\",e,t,n),b:k(\"b\",e,t,n),transposeA:k(\"transposeA\",e,t,n),transposeB:k(\"transposeB\",e,t,n),bias:p,activation:s,preluActivationWeights:d,leakyreluAlpha:u})];case\"MatrixBandPart\":return[a.linalg.bandPart(k(\"a\",e,t,n),k(\"numLower\",e,t,n),k(\"numUpper\",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},t5=(e,t,n,a=on)=>{switch(e.op){case\"EuclideanNorm\":return[a.euclideanNorm(k(\"x\",e,t,n),k(\"axis\",e,t,n),k(\"keepDims\",e,t,n))];case\"FusedBatchNorm\":case\"FusedBatchNormV2\":return[a.batchNorm(k(\"x\",e,t,n),k(\"mean\",e,t,n),k(\"variance\",e,t,n),k(\"offset\",e,t,n),k(\"scale\",e,t,n),k(\"epsilon\",e,t,n))];case\"FusedBatchNormV3\":return[a.batchNorm(k(\"x\",e,t,n),k(\"mean\",e,t,n),k(\"variance\",e,t,n),k(\"offset\",e,t,n),k(\"scale\",e,t,n),k(\"epsilon\",e,t,n))];case\"LRN\":return[a.localResponseNormalization(k(\"x\",e,t,n),k(\"radius\",e,t,n),k(\"bias\",e,t,n),k(\"alpha\",e,t,n),k(\"beta\",e,t,n))];case\"Softmax\":return[a.softmax(k(\"x\",e,t,n))];case\"LogSoftmax\":return[a.logSoftmax(k(\"x\",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},n5=(e,t,n,a=on)=>{switch(e.op){case\"RaggedGather\":{let{outputNestedSplits:r,outputDenseValues:s}=a.raggedGather(k(\"paramsNestedSplits\",e,t,n),k(\"paramsDenseValues\",e,t,n),k(\"indices\",e,t,n),k(\"outputRaggedRank\",e,t,n));return r.concat(s)}case\"RaggedRange\":{let{rtNestedSplits:r,rtDenseValues:s}=a.raggedRange(k(\"starts\",e,t,n),k(\"limits\",e,t,n),k(\"splits\",e,t,n));return[r,s]}case\"RaggedTensorToTensor\":return[a.raggedTensorToTensor(k(\"shape\",e,t,n),k(\"values\",e,t,n),k(\"defaultValue\",e,t,n),k(\"rowPartitionTensors\",e,t,n),k(\"rowPartitionTypes\",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},a5=(e,t,n,a=on)=>{switch(e.op){case\"Max\":{let o=k(\"axis\",e,t,n),l=k(\"keepDims\",e,t,n);return[a.max(k(\"x\",e,t,n),o,l)]}case\"Mean\":{let o=k(\"axis\",e,t,n),l=k(\"keepDims\",e,t,n);return[a.mean(k(\"x\",e,t,n),o,l)]}case\"Min\":{let o=k(\"axis\",e,t,n),l=k(\"keepDims\",e,t,n);return[a.min(k(\"x\",e,t,n),o,l)]}case\"Sum\":{let o=k(\"axis\",e,t,n),l=k(\"keepDims\",e,t,n);return[a.sum(k(\"x\",e,t,n),o,l)]}case\"All\":{let o=k(\"axis\",e,t,n),l=k(\"keepDims\",e,t,n);return[a.all(k(\"x\",e,t,n),o,l)]}case\"Any\":{let o=k(\"axis\",e,t,n),l=k(\"keepDims\",e,t,n);return[a.any(k(\"x\",e,t,n),o,l)]}case\"ArgMax\":{let o=k(\"axis\",e,t,n);return[a.argMax(k(\"x\",e,t,n),o)]}case\"ArgMin\":{let o=k(\"axis\",e,t,n);return[a.argMin(k(\"x\",e,t,n),o)]}case\"Prod\":{let o=k(\"axis\",e,t,n),l=k(\"keepDims\",e,t,n);return[a.prod(k(\"x\",e,t,n),o,l)]}case\"Cumprod\":{let o=k(\"axis\",e,t,n),l=k(\"exclusive\",e,t,n),u=k(\"reverse\",e,t,n);return[a.cumprod(k(\"x\",e,t,n),o,l,u)]}case\"Cumsum\":{let o=k(\"axis\",e,t,n),l=k(\"exclusive\",e,t,n),u=k(\"reverse\",e,t,n);return[a.cumsum(k(\"x\",e,t,n),o,l,u)]}case\"Bincount\":let r=k(\"x\",e,t,n),s=k(\"weights\",e,t,n),i=k(\"size\",e,t,n);return[a.bincount(r,s,i)];case\"DenseBincount\":{let o=k(\"x\",e,t,n),l=k(\"weights\",e,t,n),u=k(\"size\",e,t,n),p=k(\"binaryOutput\",e,t,n);return[a.denseBincount(o,l,u,p)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},r5=(e,t,n,a=on)=>{switch(e.op){case\"ConcatV2\":case\"Concat\":{let r=k(\"n\",e,t,n),s=k(\"axis\",e,t,n),i=k(\"tensors\",e,t,n);return i=i.slice(0,r),[a.concat(i,s)]}case\"Gather\":{let r=k(\"x\",e,t,n),s=k(\"indices\",e,t,n);return[a.gather(r,a.cast(s,\"int32\"),0)]}case\"GatherV2\":{let r=k(\"axis\",e,t,n),s=k(\"batchDims\",e,t,n),i=k(\"x\",e,t,n),o=k(\"indices\",e,t,n);return[a.gather(i,a.cast(o,\"int32\"),r,s)]}case\"Reverse\":{let r=k(\"dims\",e,t,n),s=[];for(let o=0;o<r.length;o++)r[o]&&s.push(o);let i=k(\"x\",e,t,n);return[a.reverse(i,s)]}case\"ReverseV2\":{let r=k(\"axis\",e,t,n),s=k(\"x\",e,t,n);return[a.reverse(s,r)]}case\"Slice\":{let r=k(\"begin\",e,t,n),s=k(\"size\",e,t,n);return[a.slice(k(\"x\",e,t,n),r,s)]}case\"StridedSlice\":{let r=k(\"begin\",e,t,n),s=k(\"end\",e,t,n),i=k(\"strides\",e,t,n),o=k(\"beginMask\",e,t,n),l=k(\"endMask\",e,t,n),u=k(\"ellipsisMask\",e,t,n),p=k(\"newAxisMask\",e,t,n),d=k(\"shrinkAxisMask\",e,t,n),c=k(\"x\",e,t,n);return[a.stridedSlice(c,r,s,i,o,l,u,p,d)]}case\"Pack\":return O(()=>{let r=k(\"axis\",e,t,n),s=k(\"tensors\",e,t,n),i=s[0].shape,o=a.squeeze(s[0]).shape,l=s.map(u=>{let p=w.arraysEqual(u.shape,i);if(!p&&!w.arraysEqual(a.squeeze(u).shape,o))throw new Error(\"the input tensors shape does not match\");return p?u:a.reshape(u,i)});return[a.stack(l,r)]});case\"Unpack\":{let r=k(\"axis\",e,t,n),s=k(\"tensor\",e,t,n);return a.unstack(s,r)}case\"Tile\":{let r=k(\"reps\",e,t,n);return[a.tile(k(\"x\",e,t,n),r)]}case\"Split\":case\"SplitV\":{let r=k(\"axis\",e,t,n),s=k(\"numOrSizeSplits\",e,t,n),i=k(\"x\",e,t,n);return a.split(i,s,r)}case\"ScatterNd\":{let r=k(\"indices\",e,t,n),s=k(\"values\",e,t,n),i=k(\"shape\",e,t,n);return[a.scatterND(r,s,i)]}case\"GatherNd\":{let r=k(\"x\",e,t,n),s=k(\"indices\",e,t,n);return[a.gatherND(r,s)]}case\"SparseToDense\":{let r=k(\"sparseIndices\",e,t,n),s=k(\"outputShape\",e,t,n),i=k(\"sparseValues\",e,t,n),o=k(\"defaultValue\",e,t,n);return[a.sparseToDense(r,i,s,i.dtype===o.dtype?o:a.cast(o,i.dtype))]}case\"TensorScatterUpdate\":{let r=k(\"indices\",e,t,n),s=k(\"values\",e,t,n),i=k(\"tensor\",e,t,n);return[a.tensorScatterUpdate(i,r,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},s5=(e,t,n,a=on)=>{switch(e.op){case\"SparseFillEmptyRows\":{let{outputIndices:r,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=a.sparse.sparseFillEmptyRows(k(\"indices\",e,t,n),k(\"values\",e,t,n),k(\"denseShape\",e,t,n),k(\"defaultValue\",e,t,n));return[r,s,i,o]}case\"SparseReshape\":{let{outputIndices:r,outputShape:s}=a.sparse.sparseReshape(k(\"inputIndices\",e,t,n),k(\"inputShape\",e,t,n),k(\"newShape\",e,t,n));return[r,s]}case\"SparseSegmentMean\":return[a.sparse.sparseSegmentMean(k(\"data\",e,t,n),k(\"indices\",e,t,n),k(\"segmentIds\",e,t,n))];case\"SparseSegmentSum\":return[a.sparse.sparseSegmentSum(k(\"data\",e,t,n),k(\"indices\",e,t,n),k(\"segmentIds\",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},i5=(e,t,n,a=on)=>{switch(e.op){case\"FFT\":return[a.fft(k(\"x\",e,t,n))];case\"IFFT\":return[a.ifft(k(\"x\",e,t,n))];case\"RFFT\":return[a.rfft(k(\"x\",e,t,n))];case\"IRFFT\":return[a.irfft(k(\"x\",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},o5=(e,t,n,a=on)=>{switch(e.op){case\"StaticRegexReplace\":return[a.string.staticRegexReplace(k(\"input\",e,t,n),k(\"pattern\",e,t,n),k(\"rewrite\",e,t,n),k(\"replaceGlobal\",e,t,n))];case\"StringNGrams\":{let{nGrams:r,nGramsSplits:s}=a.string.stringNGrams(k(\"data\",e,t,n),k(\"dataSplits\",e,t,n),k(\"separator\",e,t,n),k(\"nGramWidths\",e,t,n),k(\"leftPad\",e,t,n),k(\"rightPad\",e,t,n),k(\"padWidth\",e,t,n),k(\"preserveShortSequences\",e,t,n));return[r,s]}case\"StringSplit\":{let{indices:r,values:s,shape:i}=a.string.stringSplit(k(\"input\",e,t,n),k(\"delimiter\",e,t,n),k(\"skipEmpty\",e,t,n));return[r,s,i]}case\"StringToHashBucketFast\":return[a.string.stringToHashBucketFast(k(\"input\",e,t,n),k(\"numBuckets\",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},l5=(e,t,n,a=on)=>{switch(e.op){case\"Cast\":return[a.cast(k(\"x\",e,t,n),k(\"dtype\",e,t,n))];case\"ExpandDims\":{let r=k(\"axis\",e,t,n);return[a.expandDims(k(\"x\",e,t,n),r)]}case\"Squeeze\":{let r=k(\"axis\",e,t,n);return[a.squeeze(k(\"x\",e,t,n),r)]}case\"Reshape\":return[a.reshape(k(\"x\",e,t,n),k(\"shape\",e,t,n))];case\"EnsureShape\":return[a.ensureShape(k(\"x\",e,t,n),k(\"shape\",e,t,n))];case\"MirrorPad\":return[a.mirrorPad(k(\"x\",e,t,n),k(\"padding\",e,t,n),k(\"mode\",e,t,n))];case\"PadV2\":case\"Pad\":return[a.pad(k(\"x\",e,t,n),k(\"padding\",e,t,n),k(\"constantValue\",e,t,n))];case\"SpaceToBatchND\":{let r=k(\"blockShape\",e,t,n),s=k(\"paddings\",e,t,n);return[a.spaceToBatchND(k(\"x\",e,t,n),r,s)]}case\"BatchToSpaceND\":{let r=k(\"blockShape\",e,t,n),s=k(\"crops\",e,t,n);return[a.batchToSpaceND(k(\"x\",e,t,n),r,s)]}case\"DepthToSpace\":{let r=k(\"blockSize\",e,t,n),s=k(\"dataFormat\",e,t,n).toUpperCase();return[a.depthToSpace(k(\"x\",e,t,n),r,s)]}case\"BroadcastTo\":return[a.broadcastTo(k(\"x\",e,t,n),k(\"shape\",e,t,n))];case\"BroadcastArgs\":return[a.broadcastArgs(k(\"s0\",e,t,n),k(\"s1\",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function UI(e,t,n,a,r=O){let s=((i,o,l)=>{switch(i.category){case\"arithmetic\":return r(()=>Pq(i,o,l));case\"basic_math\":return r(()=>Lq(i,o,l));case\"control\":return Gq(i,o,l);case\"convolution\":return r(()=>Hq(i,o,l));case\"creation\":return r(()=>jq(i,o,l));case\"dynamic\":return qq(i,o,l);case\"evaluation\":return r(()=>Kq(i,o,l));case\"image\":return r(()=>Jq(i,o,l));case\"graph\":return r(()=>Xq(i,o,l));case\"logical\":return r(()=>Qq(i,o,l));case\"matrices\":return r(()=>e5(i,o,l));case\"normalization\":return r(()=>t5(i,o,l));case\"ragged\":return r(()=>n5(i,o,l));case\"reduction\":return r(()=>a5(i,o,l));case\"slice_join\":return r(()=>r5(i,o,l));case\"sparse\":return r(()=>s5(i,o,l));case\"spectral\":return r(()=>i5(i,o,l));case\"string\":return r(()=>o5(i,o,l));case\"transformation\":return r(()=>l5(i,o,l));case\"hash_table\":return Zq(i,o,l,a);case\"custom\":let u=zC(i.op);if(u&&u.customExecutor)return u.customExecutor(new Oq(i,o,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return w.isPromise(s)?s.then(i=>[].concat(i)):[].concat(s)}var GI=class{constructor(e={},t={},n={},a={},r){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=a,this.parseNodeNameCache=r,this.rootContext={id:0,frameName:\"\",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(\"\"),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?\"\":`${t.frameName}-${t.iterationId}`).join(\"/\"):\"\"}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error(\"Cannot exit frame, the context is empty\")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error(\"Cannot increase frame iteration, the context is empty\")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function HI(e,t,n,a){let r=new Set,s=[],i=null,o=null,l=new Set,u=new Set(Object.keys(e).map(c=>Xn(c)[0]));a=a||[];let p=new Set(a.map(c=>Xn(c.name)[0])),d=[...t];for(;d.length>0;){let c=d.pop();if((Qs(c)||g5(c)||b5(c))&&i==null&&(i=c,o=i.children.map(h=>h.name).filter(h=>r.has(h))),r.add(c.name),n[c.name]==null&&!u.has(c.name)&&!p.has(c.name)){if(c.inputs.length===0){s.push(c.name);continue}c.inputs.forEach(h=>{l.has(h.name)||(l.add(h.name),d.push(h))})}}return{inputs:e,outputs:t,usedNodes:r,missingInputs:s,dynamicNode:i,syncInputs:o}}function u5(e,t){let{usedNodes:n,inputs:a}=t,r=Object.keys(a).map(g=>Xn(g)[0]).map(g=>e.nodes[g]),s=e.initNodes||[],i=g=>n.has(typeof g==\"string\"?g:g.name);function o(g){return[...new Map(g.map(b=>[b.name,b])).values()]}let l=o([...r,...e.weights,...s]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),p=new Map(u.map(g=>[g.name,g])),d={};for(let g of u){d[g.name]=d[g.name]||0;for(let b of g.children)i(b)||(d[b.name]=Number.POSITIVE_INFINITY),d[b.name]=(d[b.name]||0)+1}let c=Object.entries(d).filter(([,g])=>g===0).map(([g])=>g),h=[...c];for(;c.length>0;){let g=c.pop(),b=p.get(g);for(let y of b.children.filter(i))--d[y.name]===0&&(h.push(y.name),c.push(y.name))}let m=h.map(g=>p.get(g)),f=p5(m,l);return c5(f,l),f}function p5(e,t){let n=new Map(e.map(s=>[s.name,s])),a=t.map(s=>s.name),r=new Set(a);for(;a.length>0;){let s=a.pop(),i=n.get(s);for(let o of i.children)!n.has(o.name)||r.has(o.name)||(r.add(o.name),a.push(o.name))}return e.filter(s=>r.has(s.name))}var Th=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};function c5(e,t){let n=new Map(e.map((o,l)=>[o.name,l])),a=new Set(t.map(o=>o.name)),r=o=>a.has(typeof o==\"string\"?o:o.name),s=new Set(e.map(o=>o.name)),i=o=>s.has(typeof o==\"string\"?o:o.name);for(let o of e){for(let l of o.children.filter(i)){if(!n.has(l.name))throw new Th(`Child ${l.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(l.name))throw new Th(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!r(o))for(let l of o.inputs){if(!n.has(l.name))throw new Th(`Input ${l.name} of node ${o.name} is unreachable.`);if(n.get(l.name)>n.get(o.name))throw new Th(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function d5(e){let t=new Map(e.map((o,l)=>[o.name,l])),n=Number.MAX_SAFE_INTEGER,a=e.map((o,l)=>Qs(o)?n:l),r=o=>{let l=a[t.get(o.name)];return l==null?-1:l},s=e.map((o,l)=>o.children.map(r).reduce((u,p)=>Math.max(u,p),a[l])),i=new Map;for(let o=0;o<e.length;++o){let l=s[o];if(l===n)continue;let u=e[o],p=e[l];i.has(p.name)||i.set(p.name,[]),i.get(p.name).push(u)}return i}var h5=new Set([\"Switch\",\"Merge\",\"Enter\",\"Exit\",\"NextIteration\",\"StatelessIf\",\"StatelessWhile\",\"if\",\"While\"]),m5=new Set([\"NonMaxSuppressionV2\",\"NonMaxSuppressionV3\",\"NonMaxSuppressionV5\",\"Where\"]),f5=new Set([\"HashTable\",\"HashTableV2\",\"LookupTableImport\",\"LookupTableImportV2\",\"LookupTableFind\",\"LookupTableFindV2\",\"LookupTableSize\",\"LookupTableSizeV2\"]);function Qs(e){return h5.has(e.op)}function g5(e){return m5.has(e.op)}function b5(e){return f5.has(e.op)}var jI=class oE{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let n=Object.keys(t).map(a=>t[a].map(r=>r.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=\",\",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(a=>{this._functionExecutorMap[a]=new oE(t.functions[a],this)})}getCompilationKey(t,n){let a=t.map(s=>s.name).sort(),r=n.map(s=>s.name).sort();return a.join(this.SEPARATOR)+\"--\"+r.join(this.SEPARATOR)}compile(t,n){let a=HI(t,n,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:i}=a;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(r.length>0){let u=n.map(d=>d.name),p=Object.keys(t);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${p}]. Missing the following inputs: [${r}]`)}let o=u5(this.graph,a),l=d5(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(t){if(t==null)return null;let n=t.clone();return Ht(n),n}cloneTensorList(t){return t?t.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([n,a])=>[n,this.cloneTensorList(a)]))}execute(t,n){this.disposeIntermediateTensors(),t=this.mapInputs(t);let a=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);let r=a.map(c=>this.graph.nodes[Xn(c)[0]]),s=n.map(c=>Xn(c)[0]),i=new Set(s),o=s.map(c=>this.graph.nodes[c]);o.length===0&&(o=this._outputs);let l=this.getCompilationKey(r,o),u=this.compiledMap.get(l);u==null&&(u=this.compile(t,o),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=G().getBool(\"KEEP_INTERMEDIATE_TENSORS\")}catch(c){this.keepIntermediateTensors=!1,console.warn(c.message)}let p={},d={};return O(()=>{let c=new GI(this.weightMap,p,d,this.functionExecutorMap,this.parseNodeNameCache),h=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(b=>{let[y,x]=Xn(b,c),v=[];v[x]=t[b],h[y]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[y]=this.cloneTensorList(v))});let m=this.getFrozenTensorIds(h),{orderedNodes:f,nodeLiveUntilMap:g}=u;for(let b of f){if(h[b.name])continue;let y=UI(b,h,c,this._resourceManager);if(w.isPromise(y))throw new Error(`The execution of the op '${b.op}' returned a promise. Please use model.executeAsync() instead.`);h[b.name]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[b.name]=this.cloneTensorList(y)),this.checkTensorForDisposalWithNodeLiveUntilInfo(b,h,c,m,i,g.get(b.name))}return this.parent==null&&c.dispose(m),n.map(b=>pn(b,h,c))})}getFrozenTensorIds(t){let n=[].concat.apply([],Object.keys(t).map(a=>t[a]).map(a=>a.map(r=>r.id)));return new Set(n)}checkTensorForDisposal(t,n,a,r,s,i,o){if(!(Qs(n)||i.has(t))){for(let l of a[t])l!=null&&(o[l.id]=(o[l.id]||0)+n.children.length);for(let l of n.inputs){if(Qs(l))continue;let u=LI(l.name,a,r);if(u!=null)for(let p of u){if(!p||p.kept||s.has(p.id))continue;let d=o[p.id];d===1?(p.dispose(),delete o[p.id]):d!=null&&o[p.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,n,a,r,s,i){function o(l){return Qs(l)||s.has(l.name)}if(!(Qs(t)||i==null))for(let l of i){if(o(l))continue;let u=LI(l.name,n,a);for(let p of u)!p||p.kept||r.has(p.id)||p.dispose()}}async executeAsync(t,n){return this._executeAsync(t,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(let n of t)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,n,a=!1,r={},s={}){this.disposeIntermediateTensors(),a||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=G().getBool(\"KEEP_INTERMEDIATE_TENSORS\")}catch(c){this.keepIntermediateTensors=!1,console.warn(c.message)}let i=new GI(this.weightMap,r,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let o=await this.executeWithControlFlow(t,i,n,a),l=n.map(c=>pn(c,o,i)),u=l.map(c=>c.id),p=Object.keys(t).map(c=>t[c].id),d=new Set([...u,...p,...this.weightIds]);return Object.values(o).forEach(c=>{c.forEach(h=>{h&&!h.isDisposed&&!d.has(h.id)&&h.dispose()})}),this.parent==null&&i.dispose(d),l}async executeFunctionAsync(t,n,a){let r=t.reduce((s,i,o)=>(s[this.inputs[o].name]=i,s),{});return this._executeAsync(r,this.outputNodes,!0,n,a)}async executeWithControlFlow(t,n,a,r){let s=Object.keys(t),i=s.map(v=>this.graph.nodes[Xn(v)[0]]),o=a.map(v=>Xn(v)[0]),l=new Set(o),u=o.map(v=>this.graph.nodes[v]);u.length===0&&(u=this._outputs);let{usedNodes:p,missingInputs:d,dynamicNode:c,syncInputs:h}=HI(t,u,this.weightMap,this._initNodes),m=[...i,...this.graph.weights,...this._initNodes||[]].map(v=>({node:v,contexts:n.currentContext})),f=Object.assign({},this.weightMap);Object.keys(t).forEach(v=>{let[I,N]=Xn(v),C=[];C[N]=t[v],f[I]=C});let g={},b=this.getFrozenTensorIds(f),y={};for(;m.length>0;){let v=this.processStack(i,m,n,f,y,b,l,g,p);await Promise.all(v)}c==null&&!r&&console.warn(\"This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.\");let x=u.filter(v=>!Qs(v)&&!pn(v.name,f,n)).map(v=>v.name);if(x.length>0){let v=\"\";throw c!=null&&(v=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),new Error(`Cannot compute the outputs [${x}] from the provided inputs [${s}]. Consider providing the following inputs: [${d}]. ${v}`)}return f}processStack(t,n,a,r,s,i,o,l,u){let p=[];for(;n.length>0;){let d=n.pop();a.currentContext=d.contexts;let c=\"\";if(d.node.op===\"Enter\"&&k(\"isConstant\",d.node,r,a)&&([c]=Sr(d.node.name,a)),r[d.node.name]==null){let h=UI(d.node,r,a,this._resourceManager);c||([c]=Sr(d.node.name,a));let m=a.currentContext;w.isPromise(h)?p.push(h.then(f=>(r[c]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(f)),a.currentContext=m,this.checkTensorForDisposal(c,d.node,r,a,i,o,l),this.processChildNodes(d.node,n,a,r,s,u),f))):(r[c]=h,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(h)),this.checkTensorForDisposal(c,d.node,r,a,i,o,l),this.processChildNodes(d.node,n,a,r,s,u))}else this.processChildNodes(d.node,n,a,r,s,u)}return p}processChildNodes(t,n,a,r,s,i){t.children.forEach(o=>{let[l]=Sr(o.name,a);s[l]||!i.has(o.name)||(o.op===\"Merge\"?o.inputNames.some(u=>!!pn(u,r,a))&&(s[l]=!0,n.push({contexts:a.currentContext,node:o})):o.inputNames.every(u=>!!pn(u,r,a))&&(s[l]=!0,n.push({contexts:a.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{let a=t[n],[r]=Xn(n),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,o=i.length===a.shape.length&&a.shape.every((l,u)=>i[u]===-1||i[u]===l);w.assert(o,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${a.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&w.assert(a.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${a.dtype}`)})}mapInputs(t){var n,a;let r={};for(let s in t){let i=(a=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||a===void 0?void 0:a[s];i!=null?r[i.name]=t[s]:r[s]=t[s]}return r}checkInputs(t){let n=Object.keys(t).filter(a=>{let[r]=Xn(a);return this.graph.nodes[r]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>{var a,r;let s=(r=(a=this._signature)===null||a===void 0?void 0:a.outputs)===null||r===void 0?void 0:r[n];return s!=null?s.name:n},{})}checkOutputs(t){t.forEach(n=>{let[a]=Xn(n);if(!this.graph.nodes[a])throw new Error(`The output '${n}' is not found in the graph`)})}},y5=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},x5=\"?tfjs-format=file\",v5=\"model.json\",F1=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=jt){this.modelUrl=e,this.loadOptions=t,this.version=\"n/a\",this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new y5}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error(\"Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.\");let e=this.handler.load();return w.isPromise(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error(\"Model artifacts missing streamWeights function\");let t=await pN(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let n=this.artifacts.modelTopology,a=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let r=this.artifacts.userDefinedMetadata;r.signature!=null&&(a=r.signature),r.structuredOutputKeys!=null&&(this.structuredOutputKeys=r.structuredOutputKeys)}if(this.signature=a,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new jI(zI.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let r=zI.Instance.transformGraph(e.modelInitializer);this.initializer=new jI(r),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e==\"string\"){let n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error(\"GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.\");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof Ce?[e]:e,n={};return t.forEach((a,r)=>n[this.structuredOutputKeys[r]]=a),n}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof Ce)&&!Array.isArray(e)){let r=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(r!=null)for(let s in r){let i=r[s];i.resourceId!=null&&(e[s]=this.resourceIdToCapturedInput[i.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let a=0;return this.inputNodes.reduce((r,s)=>{var i,o,l;let u=(l=(o=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||o===void 0?void 0:o[s])===null||l===void 0?void 0:l.resourceId;return u!=null?r[s]=this.resourceIdToCapturedInput[u]:r[s]=e[a++],r},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let a=0;a<n.length;a++){let r=n[a],s=t[r];this.resourceIdToCapturedInput[s.resourceId]=e[a]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Ee(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function w5(e,t={},n=jt){if(e==null)throw new Error(\"modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model\");t==null&&(t={}),t.fromTFHub&&typeof e==\"string\"&&(e=I5(e));let a=new F1(e,t,n);return await a.load(),a}function k5(e){if(e==null)throw new Error(\"modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model\");let t;if(e instanceof Array){let[a,r]=e;if(!a)throw new Error(\"modelJSON must be the first element of the array\");if(!r||!(r instanceof ArrayBuffer))throw new Error(\"An ArrayBuffer of weights must be the second element of the array\");if(!(\"modelTopology\"in a))throw new Error(\"Model JSON is missing 'modelTopology'\");if(!(\"weightsManifest\"in a))throw new Error(\"Model JSON is missing 'weightsManifest'\");let s=jt.getWeightSpecs(a.weightsManifest),i=jt.getModelArtifactsForJSONSync(a,s,r);t=jt.fromMemorySync(i)}else if(\"load\"in e)t=e;else if(\"modelTopology\"in e&&\"weightSpecs\"in e&&\"weightData\"in e)t=jt.fromMemorySync(e);else throw new Error(\"Unknown model format\");let n=new F1(t);return n.load(),n}function I5(e){return e.endsWith(\"/\")||(e=e+\"/\"),`${e}${v5}${x5}`}var S5=\"4.22.0\",lE={};_e(lE,{CSVDataset:()=>xE,Dataset:()=>ip,FileDataSource:()=>TE,TextLineDataset:()=>yE,URLDataSource:()=>CE,array:()=>q5,csv:()=>i8,func:()=>o8,generator:()=>l8,microphone:()=>p8,version_data:()=>c8,webcam:()=>u8,zip:()=>K5});var N5=xs(bm()),T5=xs(bm());function C5(e,t){return om(e,t)}function om(e,t,n=new Map,a=new Set){if(e==null)return null;if(typeof Blob==\"function\"&&e instanceof Blob)return e.slice();if(a.has(e))throw new Error(\"Circular references are not supported.\");if(n.has(e))return n.get(e);let r=t(e);if(r.recurse&&r.value!==null)throw new Error(\"A deep map function may not return both a value and recurse=true.\");if(r.recurse)if(Hl(e)){let s=Array.isArray(e)?[]:{};a.add(e);for(let i in e){let o=e[i],l=om(o,t,n,a);s[i]=l}return a.delete(e),e.__proto__&&(s.__proto__=e.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${e}`);else return n.set(e,r.value),r.value}function E5(e,t=pE){return uE(e,t)}function uE(e,t,n=new Set){let a=e[0];if(n.has(a))throw new Error(\"Circular references are not supported.\");let r=t(e);if(r.recurse&&r.value!==null)throw new Error(\"A deep zip function may not return both a value and recurse=true.\");if(r.recurse)if(Hl(a)){let s=Array.isArray(a)?[]:{};n.add(a);for(let i in a){let o=e.map(u=>u[i]),l=uE(o,t,n);s[i]=l}return n.delete(a),s}else throw new Error(`Can't recurse into non-iterable type: ${a}`);else return r.value}function pE(e){return e===null?null:Hl(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function cE(e,t){let n=new Map;om(e,t,n);for(let a of Array.from(n.keys())){let r=n.get(a);if(w.isPromise(r)){let s=await r;n.set(a,s)}}return om(e,t,n)}function Hl(e){let t=!1;if(G().get(\"IS_BROWSER\"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=FS();t=e instanceof n}return e!=null&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||typeof e==\"object\"&&!(e instanceof Ce)&&!(e instanceof Promise)&&!t)}function _5(e){return e==null||A5(e)||Array.isArray(e)||typeof e==\"object\"&&e instanceof Ce||w.isTypedArray(e)}function A5(e){return e===null||typeof e!=\"object\"&&typeof e!=\"function\"}function F5(e){return C5(e,$5)}function $5(e){return e instanceof Ce?{value:e.clone(),recurse:!1}:Hl(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var dE=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError(\"Can't create a ring buffer of unknown capacity.\");if(e<1)throw new RangeError(\"Can't create ring buffer of capacity < 1.\");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError(\"Can't get item at a negative index.\");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError(\"Can't set item at a negative index.\");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError(\"Ring buffer is full.\");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError(\"Ring buffer is empty.\");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError(\"Ring buffer is full.\");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError(\"Ring buffer is empty.\");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError(\"Ring buffer is empty.\");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},hE=class mE extends dE{constructor(){super(mE.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,n=new Array(t),a=this.length();for(let r=0;r<a;r++)n[r]=this.get(this.wrap(this.begin+r));this.data=n,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=a}};hE.INITIAL_CAPACITY=32;function fE(e){return new M5(e)}function $1(e){return new O5(e)}function D5(e,t){return new gE(e,t)}function R5(e,t=es.FAIL){return new H5(e,t)}var sn=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new U5(this,e)}filter(e){return new B5(this,e)}map(e){return new V5(this,e)}mapAsync(e){return new qI(this,e)}serialMapAsync(e){return new qI(this,e).serial()}flatmap(e){return new G5(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new W5(this,e,t)}columnMajorBatch(e,t=!0,n=pE){return this.rowMajorBatch(e,t).map(a=>E5(a,n))}concatenate(e,t){return new gE(fE([this,e]),t)}take(e){return e<0||e==null?this:new z5(this,e)}skip(e){return e<0||e==null?this:new L5(this,e)}prefetch(e){return new bE(this,e)}shuffle(e,t){return new j5(this,e,t)}serial(){return new P5(this)}},M5=class extends sn{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:F5(e),done:!1}}},O5=class extends sn{constructor(e){super(),this.nextFn=e}summary(){return\"Function call\"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},P5=class extends sn{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},L5=class extends sn{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;Ee(e.value)}return this.upstream.next()}},z5=class extends sn{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},W5=class extends sn{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},B5=class extends sn{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Ee(e.value)}}},V5=class extends sn{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Wa.getTensorsInContainer(e.value),n=this.transform(e.value),a=Wa.getTensorsInContainer(n);for(let r of t)Wa.isTensorInList(r,a)||r.dispose();return{value:n,done:!1}}},U5=class extends sn{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},qI=class extends sn{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Wa.getTensorsInContainer(e.value),n=await this.transform(e.value),a=Wa.getTensorsInContainer(n);for(let r of t)Wa.isTensorInList(r,a)||r.dispose();return{value:n,done:!1}}},D1=class extends sn{constructor(){super(),this.outputQueue=new hE,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},G5=class extends D1{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=Wa.getTensorsInContainer(e.value),n=this.transform(e.value),a=Wa.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let r of t)Wa.isTensorInList(r,a)||r.dispose();return!0}},gE=class extends sn{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return\"TODO: fill in upstream of chained summaries -> Chained\"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},es;(function(e){e[e.FAIL=0]=\"FAIL\",e[e.SHORTEST=1]=\"SHORTEST\",e[e.LONGEST=2]=\"LONGEST\"})(es||(es={}));var H5=class extends sn{constructor(e,t=es.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return\"{TODO: fill in upstream of zip summaries} -> Zip\"}async nextState(e){await e;let t=0,n=0;function a(s){return s instanceof sn?{value:s.next().then(i=>(t++,i.done&&n++,i.value)),recurse:!1}:{value:null,recurse:!0}}let r=await cE(this.iterators,a);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case es.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case es.SHORTEST:return{value:null,done:!0};case es.LONGEST:default:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},bE=class extends sn{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new dE(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},j5=class extends bE{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=T5.alea(n||w.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}},ip=class{constructor(){this.size=null}batch(e,t=!0){let n=this;w.assert(e>0,()=>`batchSize needs to be positive, but it is\n      ${e}`);let a;return this.size===1/0||this.size==null?a=this.size:t?a=Math.ceil(this.size/e):a=Math.floor(this.size/e),Kn(async()=>(await n.iterator()).columnMajorBatch(e,t,X5),a)}concatenate(e){let t=this,n;return this.size===1/0||e.size===1/0?n=1/0:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,Kn(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===1/0?n=1/0:n=null,Kn(async()=>(await t.iterator()).filter(a=>O(()=>e(a))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return Kn(async()=>(await t.iterator()).map(n=>O(()=>e(n))),this.size)}mapAsync(e){let t=this;return Kn(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError(\"`Dataset.prefetch()` requires bufferSize to be specified.\");let t=this;return Kn(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=1/0:n=null,Kn(async()=>{let a=$1(async()=>({value:await t.iterator(),done:!1}));return D5(a.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,Kn(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError(\"`Dataset.shuffle()` requires bufferSize to be specified.\"):new RangeError(`\\`Dataset.shuffle()\\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \\`tf.Tensor\\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let a=this,r=N5.alea(t||w.now().toString());return Kn(async()=>{let s=r.int32();return n&&(s+=r.int32()),(await a.iterator()).shuffle(e,s.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,Kn(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error(\"Can not convert infinite data stream to array.\");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error(\"Can not convert infinite data stream to array.\");return(await this.iterator()).toArrayForTest()}};ip.MAX_BUFFER_SIZE=1e4;function Kn(e,t=null){return new class extends ip{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function q5(e){return Kn(async()=>fE(e),e.length)}function K5(e){if(!Hl(e))throw new Error(\"The argument to zip() must be an object or array.\");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=t==null?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=t==null?e[n].size:Math.min(t,e[n].size);return Kn(async()=>{let n=await cE(e,a=>{if(a instanceof ip)return{value:a.iterator(),recurse:!1};if(Hl(a))return{value:null,recurse:!0};throw new Error(\"Leaves of the structure passed to zip() must be Datasets, not primitives.\")});return R5(n,es.SHORTEST)},t)}function X5(e){if(e===null)return null;let t=e[0];return _5(t)?{value:Y5(e),recurse:!1}:{value:null,recurse:!0}}function Y5(e){if(e.length===0)throw new Error(\"Can't make a batch of zero elements.\");return e[0]instanceof Ce?At(e):bn(e)}var yE=class extends ip{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`\n`).map(e=>(e.endsWith(\"\\r\")&&(e=e.slice(0,-1)),e))}},Ch='\"',Jp=Symbol(\"out\"),KI=Symbol(\"field\"),Eh=Symbol(\"quote\"),bx=Symbol(\"quoteafterquote\"),XI=Symbol(\"quoteinquote\"),xE=class extends ip{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error(\"Column names must be provided if there is no header line.\");this.fullColumnNames&&e&&w.assert(e.length===this.fullColumnNames.length,()=>\"The length of provided columnNames (\"+this.fullColumnNames.length.toString()+\") does not match the length of the header line read from file (\"+e.length.toString()+\").\"),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((a,r)=>(a[r]=a[r]+1||1,a),{}),n=Object.keys(t).filter(a=>t[a]>1);if(w.assert(n.length===0,()=>\"Duplicate column names found: \"+n.toString()),this.columnConfigs){for(let a of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(a)===-1)throw new Error('The key \"'+a+'\" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+\").\")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error(\"No data was found for CSV parsing.\");let t=e.value;return this.parseRow(t,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=\",\",this.delimWhitespace=!1,this.base=new yE(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(w.assert(t.delimiter==null,()=>\"Delimiter should not be provided when delimWhitespace is true.\"),this.delimWhitespace=!0,this.delimiter=\" \"):this.delimiter=t.delimiter?t.delimiter:\",\"}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){let t=this.parseRow(e),n={},a={};for(let r=0;r<this.fullColumnNames.length;r++){let s=this.fullColumnNames[r],i=this.columnConfigs?this.columnConfigs[s]:null;if(!(this.configuredColumnsOnly&&!i)){let o=t[r],l=null;if(o===\"\")if(i&&i.default!==void 0)l=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${s} is empty in this line: ${e}`);l=void 0}else{let u=Number(o);if(isNaN(u))i&&i.dtype===\"bool\"?l=this.getBoolean(o):l=o;else if(!i||!i.dtype)l=u;else switch(i.dtype){case\"float32\":l=u;break;case\"int32\":l=Math.floor(u);break;case\"bool\":l=this.getBoolean(o);break;default:l=u}}i&&i.isLabel?a[s]=l:n[s]=l}}return Object.keys(a).length===0?n:{xs:n,ys:a}}getBoolean(e){return e===\"1\"||e.toLowerCase()===\"true\"?1:0}parseRow(e,t=!0){let n=[],a=0,r=e.length,s=Jp;for(let i=0;i<r;i++)switch(s){case Jp:switch(e.charAt(i)){case Ch:a=i+1,s=Eh;break;case this.delimiter:if(a=i+1,this.delimiter===\" \"&&this.delimWhitespace)break;n.push(\"\"),s=Jp;break;default:s=KI,a=i;break}break;case KI:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(a,i)),s=Jp,a=i+1;break;default:}break;case Eh:switch(e.charAt(i)){case Ch:s=bx;break;default:}break;case bx:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(a,i-1)),s=Jp,a=i+1;break;case Ch:s=Eh;break;default:s=XI;break}break;case XI:switch(e.charAt(i)){case Ch:s=Eh;break;default:}break;default:}if(s===bx?n.push(e.substring(a,r-1)):n.push(e.substring(a)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},Z5=class vE extends sn{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;let n=Math.log2(this.fftSize);if(this.fftSize<0||n<4||n>14||!Number.isInteger(n))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=t.includeSpectrogram!==!1,this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error(\"Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.\")}summary(){return\"microphone\"}static async create(t={}){if(!G().get(\"IS_BROWSER\"))throw new Error(\"microphone API is only supported in browser environment.\");let n=new vE(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(a){throw new Error(`Error thrown while initializing video stream: ${a.message}`)}if(!this.stream)throw new Error(\"Could not obtain audio from microphone.\");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let n=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,n.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,n,a=await this.getAudioData();if(this.includeSpectrogram){let r=this.flattenQueue(a.freqDataQueue);t=this.getTensorFromAudioDataArray(r,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let r=this.flattenQueue(a.timeDataQueue);n=this.getTensorFromAudioDataArray(r,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:n},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],n=[],a=0;return new Promise(r=>{let s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:t,timeDataQueue:n}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),n.push(this.timeData.slice())),++a===this.numFrames&&(clearInterval(s),r({freqDataQueue:t,timeDataQueue:n}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error(\"Can not convert infinite audio stream to array.\")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let n=t[0].length,a=new Float32Array(t.length*n);return t.forEach((r,s)=>a.set(r,s*n)),a}getTensorFromAudioDataArray(t,n){let a=new Float32Array(w.sizeFromShape(n));return a.set(t,a.length-t.length),bn(a,n)}},J5=class wE extends sn{constructor(t,n){if(super(),this.webcamVideoElement=t,this.webcamConfig=n,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=je([0],\"int32\"),this.webcamConfig.centerCrop){let a=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,r=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-a)/2,i=(1-r)/2,o=s+a,l=r+i;this.cropBox=Ea([i,s,l,o],[1,4])}else this.cropBox=Ea([0,0,1,1],[1,4])}summary(){return\"webcam\"}static async create(t,n={}){if(!G().get(\"IS_BROWSER\"))throw new Error(\"tf.data.webcam is only supported in browser environment.\");if(!t){if(t=document.createElement(\"video\"),!n.resizeWidth||!n.resizeHeight)throw new Error(\"Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.\");t.width=n.resizeWidth,t.height=n.resizeHeight}let a=new wE(t,n);return await a.start(),a}async start(){this.webcamConfig.facingMode&&w.assert(this.webcamConfig.facingMode===\"user\"||this.webcamConfig.facingMode===\"environment\",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:\"user\",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error(\"Could not obtain video from webcam.\");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=qo.fromPixels(this.webcamVideoElement)}catch(n){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(n)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(n){throw new Error(`Error thrown cropping the video: ${n.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return O(()=>{let n=Gt(re(t,\"float32\"),0),a;a=Zn.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,\"bilinear\");let r=a.shape;return W(a,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error(\"Can not convert infinite video stream to array.\")}},kE=class{},IE=class extends sn{split(e){return new Q5(this,e)}},Q5=class extends IE{constructor(e,t){super(),this.upstream=e,this.impl=new e8(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},e8=class extends D1{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=\"\"}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===\"\"?!1:(this.outputQueue.push(this.carryover),this.carryover=\"\",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},t8=class extends sn{decodeUTF8(){return new n8(this)}},n8=class extends IE{constructor(e){super(),this.upstream=e,this.impl=new a8(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},a8=class extends D1{constructor(e){if(super(),this.upstream=e,G().get(\"IS_BROWSER\"))this.decoder=new TextDecoder(\"utf-8\");else{let{StringDecoder:t}=FS();this.decoder=new t(\"utf8\")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let n;return G().get(\"IS_BROWSER\")?n=this.decoder.decode(t,{stream:!0}):n=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}},SE=class extends t8{constructor(e,t={}){super(),this.file=e,this.options=t,w.assert(e instanceof Uint8Array||(G().get(\"IS_BROWSER\")?e instanceof File||e instanceof Blob:!1),()=>\"FileChunkIterator only supports File, Blob and Uint8Array right now.\"),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let a=new FileReader;a.onload=s=>{let i=a.result;if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),!(i instanceof Uint8Array))return t(new TypeError(\"FileReader returned unknown type.\"));e(i)},a.onabort=s=>t(new Error(\"Aborted\")),a.onerror=s=>t(new Error(s.type));let r=this.file.slice(this.offset,n);a.readAsArrayBuffer(r)}this.offset=n}),done:!1}}};async function r8(e,t={},n){let a,r;typeof e==\"string\"?a=e:(a=e.url,r=s8(e));let s=await(n||w.fetch)(a,r);if(s.ok){let i=new Uint8Array(await s.arrayBuffer());return new SE(i,t)}else throw new Error(s.statusText)}var s8=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function NE(e){return typeof e==\"string\"&&e.slice(0,7)===\"file://\"}var TE=class extends kE{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(NE(this.input)&&G().get(\"IS_NODE\")){let e=Iv();this.input=e.readFileSync(this.input.slice(7))}return new SE(this.input,this.options)}},CE=class extends kE{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return NE(this.url)?new TE(this.url,this.fileOptions).iterator():r8(this.url,this.fileOptions)}};function i8(e,t={}){return new xE(new CE(e),t)}function o8(e){let t=$1(e);return Kn(async()=>t)}function l8(e){return Kn(async()=>{let t=await e();return $1(()=>t.next())})}async function u8(e,t){return J5.create(e,t)}async function p8(e){return Z5.create(e)}var c8=\"4.22.0\";function ge(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&w.assert(n.dtype!==\"complex64\",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var d8=mr.whereImpl,R1=class EE extends Fc{nextDataId(){return EE.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new ym(this,Ta())}write(t,n,a){this.firstUse&&(this.firstUse=!1,G().get(\"IS_NODE\")&&T.warn(`\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================`));let r={id:this.nextDataId()};return this.data.set(r,{values:t,dtype:a,refCount:1}),r}makeTensorInfo(t,n,a){let r;if(n===\"string\"&&a!=null&&a.length>0&&w.isString(a[0])){let s=a.map(i=>w.encodeString(i));r=this.write(s,t,n)}else r=this.write(a,t,n);return{dataId:r,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){let n=this.data.get(t);n.refCount--}}move(t,n,a,r,s){this.data.set(t,{values:n,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:n,complexTensorInfos:a}=this.data.get(t);if(n===\"complex64\"){let r=this.readSync(a.real.dataId),s=this.readSync(a.imag.dataId);return T.mergeRealAndImagArrays(r,s)}return w.convertBackendValuesAndArrayBuffer(this.data.get(t).values,n)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype===\"string\")try{let a=n.map(r=>w.decodeString(r));return Oe(t.shape,t.dtype,a)}catch(a){throw new Error(\"Failed to decode encoded string bytes into utf-8\")}return Oe(t.shape,t.dtype,n)}makeOutput(t,n,a){return Ta().makeTensorFromTensorInfo(this.makeTensorInfo(n,a,t),this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:a}=this.data.get(t);a!=null&&(this.disposeData(a.real.dataId,!0),this.disposeData(a.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let n=w.now();return t(),{kernelMs:w.now()-n}}memory(){return{unreliable:!0,reasons:[\"The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less.\"]}}where(t){ge([t],\"where\");let n=this.readSync(t.dataId);return d8(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};R1.nextDataId=0;var M1={};_e(M1,{addImpl:()=>FE,bincountImpl:()=>P1,bincountReduceImpl:()=>$E,bitwiseAndImpl:()=>DE,castImpl:()=>AE,ceilImpl:()=>RE,concatImpl:()=>L1,equalImpl:()=>ME,expImpl:()=>PE,expm1Impl:()=>zE,floorDivImpl:()=>BE,floorImpl:()=>WE,gatherNdImpl:()=>VE,gatherV2Impl:()=>UE,greaterEqualImpl:()=>HE,greaterImpl:()=>GE,lessEqualImpl:()=>qE,lessImpl:()=>jE,linSpaceImpl:()=>KE,logImpl:()=>XE,maxImpl:()=>YE,maximumImpl:()=>ZE,minimumImpl:()=>JE,multiplyImpl:()=>z1,negImpl:()=>QE,notEqualImpl:()=>e_,prodImpl:()=>t_,raggedGatherImpl:()=>n_,raggedRangeImpl:()=>a_,raggedTensorToTensorImpl:()=>r_,rangeImpl:()=>B1,rsqrtImpl:()=>s_,scatterImpl:()=>ni,sigmoidImpl:()=>cK,simpleAbsImpl:()=>_E,sliceImpl:()=>um,sparseFillEmptyRowsImpl:()=>o_,sparseReshapeImpl:()=>l_,sparseSegmentReductionImpl:()=>V1,sqrtImpl:()=>mK,squaredDifferenceImpl:()=>u_,staticRegexReplaceImpl:()=>p_,stridedSliceImpl:()=>c_,stringNGramsImpl:()=>U1,stringSplitImpl:()=>G1,stringToHashBucketFastImpl:()=>H1,subImpl:()=>d_,tileImpl:()=>h_,topKImpl:()=>f_,transposeImpl:()=>W1,uniqueImpl:()=>q1});function _E(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}var h8=e=>{let{x:t}=e.inputs,n=e.backend;ge(t,\"abs\");let a=new Float32Array(w.sizeFromShape(t.shape)),r=n.data.get(t.dataId).values;return a=_E(r),n.makeOutput(a,t.shape,t.dtype)},m8={kernelName:Yl,backendName:\"cpu\",kernelFunc:h8};function Mt(e){return(t,n,a,r,s)=>{let i=T.assertAndGetBroadcastShape(t,n),o=i.length,l=w.computeStrides(i),u=w.sizeFromShape(i),p=w.getTypedArrayFromDType(s,u),d=t.length,c=n.length,h=w.computeStrides(t),m=w.computeStrides(n),f=T.getBroadcastDims(t,i),g=T.getBroadcastDims(n,i);if(f.length+g.length===0)for(let b=0;b<p.length;++b)p[b]=e(a[b%a.length],r[b%r.length]);else for(let b=0;b<p.length;++b){let y=w.indexToLoc(b,o,l),x=y.slice(-d);f.forEach(C=>x[C]=0);let v=w.locToIndex(x,d,h),I=y.slice(-c);g.forEach(C=>I[C]=0);let N=w.locToIndex(I,c,m);p[b]=e(a[v],r[N])}return[p,i]}}function Yn(e){let{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,o=n.makeTensorInfo(a.shape,\"complex64\"),l=n.data.get(o.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(a.shape,\"float32\",s),imag:n.makeTensorInfo(r.shape,\"float32\",i)},o}var f8={kernelName:wm,backendName:\"cpu\",kernelFunc:Yn};function lm(e,t,n=\"float32\"){if(n===\"complex64\"){let r=lm(e,t,\"float32\"),s=lm(e,t,\"float32\");return Yn({inputs:{real:r,imag:s},backend:e})}let a=w.makeZerosTypedArray(w.sizeFromShape(t),n);return e.makeTensorInfo(t,n,a)}function cr(e){let{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}var g8={kernelName:eo,backendName:\"cpu\",kernelFunc:cr};function yi(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.real,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}var b8={kernelName:Dm,backendName:\"cpu\",kernelFunc:yi};function AE(e,t,n,a){if(a===\"int32\"){let r=Int32Array.from(e);return[t,\"int32\",r]}if(a===\"bool\"){let r=w.toTypedArray([0],n),[s,i]=Mt((o,l)=>o!==l?1:0)(t,[],e,r,\"bool\");return[i,\"bool\",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${a}`)}function bs(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:s}=a;if(s===\"complex64\"){if(r.dtype===\"complex64\")return cr({inputs:{x:r},backend:n});let p=lm(n,r.shape,r.dtype),d=bs({inputs:{x:r},backend:n,attrs:{dtype:\"float32\"}}),c=Yn({inputs:{real:d,imag:p},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),c}if(r.dtype===\"complex64\"){let p=yi({inputs:{input:r},backend:n}),d=bs({inputs:{x:p},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(p),d}if(!w.hasEncodingLoss(r.dtype,s)){let p=cr({inputs:{x:r},backend:n});return{dataId:p.dataId,shape:p.shape,dtype:s}}let i=n.data.get(r.dataId).values,[o,l,u]=AE(i,r.shape,r.dtype,s);return n.makeTensorInfo(o,l,u)}var y8={kernelName:Mi,backendName:\"cpu\",kernelFunc:bs};function Zt(e,t,n,a){return n==null?({inputs:r,backend:s})=>{let{a:i,b:o}=r,l=s;ge([i,o],e);let u=l.data.get(i.dataId).values,p=l.data.get(o.dataId).values,d=i.dtype===\"string\"?T.fromUint8ToStringArray(u):u,c=i.dtype===\"string\"?T.fromUint8ToStringArray(p):p,h=a||i.dtype,[m,f]=t(i.shape,o.shape,d,c,h);return l.makeTensorInfo(f,h,m)}:({inputs:r,backend:s})=>{let{a:i,b:o}=r,l=s;if(i.dtype===\"complex64\"||o.dtype===\"complex64\"){let u=bs({inputs:{x:i},backend:l,attrs:{dtype:\"complex64\"}}),p=l.data.get(u.dataId),d=p.complexTensorInfos.real,c=p.complexTensorInfos.imag,h=l.data.get(d.dataId).values,m=l.data.get(c.dataId).values,f=bs({inputs:{x:o},backend:l,attrs:{dtype:\"complex64\"}}),g=l.data.get(f.dataId),b=g.complexTensorInfos.real,y=g.complexTensorInfos.imag,x=l.data.get(b.dataId).values,v=l.data.get(y.dataId).values,[I,N,C]=n(i.shape,o.shape,h,m,x,v),_=l.makeTensorInfo(C,\"float32\",I),F=l.makeTensorInfo(C,\"float32\",N),D=Yn({inputs:{real:_,imag:F},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(f),l.disposeIntermediateTensorInfo(_),l.disposeIntermediateTensorInfo(F),D}else{let u=l.data.get(i.dataId).values,p=l.data.get(o.dataId).values,d=a||i.dtype,[c,h]=t(i.shape,o.shape,u,p,d);return l.makeTensorInfo(h,d,c)}}}function O1(e){return(t,n,a,r,s,i)=>{let o=T.assertAndGetBroadcastShape(t,n),l=w.sizeFromShape(o),u=o.length,p=w.computeStrides(o),d=w.getTypedArrayFromDType(\"float32\",l),c=w.getTypedArrayFromDType(\"float32\",l),h=T.getBroadcastDims(t,o),m=T.getBroadcastDims(n,o),f=T.mergeRealAndImagArrays(a,r),g=T.mergeRealAndImagArrays(s,i),b=t.length,y=w.computeStrides(t),x=n.length,v=w.computeStrides(n);if(h.length+m.length===0)for(let I=0;I<d.length;I++){let N=I%f.length,C=I%g.length,_=e(f[N*2],f[N*2+1],g[C*2],g[C*2+1]);d[I]=_.real,c[I]=_.imag}else for(let I=0;I<d.length;I++){let N=w.indexToLoc(I,u,p),C=N.slice(-b);h.forEach(S=>C[S]=0);let _=w.locToIndex(C,b,y),F=N.slice(-x);m.forEach(S=>F[S]=0);let D=w.locToIndex(F,x,v),$=e(f[_*2],f[_*2+1],g[D*2],g[D*2+1]);d[I]=$.real,c[I]=$.imag}return[d,c,o]}}var FE=Mt((e,t)=>e+t),x8=O1((e,t,n,a)=>({real:e+n,imag:t+a})),jl=Zt(vs,FE,x8),v8={kernelName:vs,backendName:\"cpu\",kernelFunc:jl};function P1(e,t,n,a,r){let s=w.sizeFromShape(a),i=w.makeZerosTypedArray(r,n);for(let o=0;o<e.length;o++){let l=e[o];if(l<0)throw new Error(\"Input x must be non-negative!\");l>=r||(s>0?i[l]+=t[o]:i[l]+=1)}return i}function $E(e,t,n,a=!1){let r=e.shape[0],s=e.shape[1],i=Oe([r,n],t.dtype);for(let o=0;o<r;o++)for(let l=0;l<s;l++){let u=e.get(o,l);if(u<0)throw new Error(\"Input x must be non-negative!\");u>=n||(a?i.set(1,o,u):t.size>0?i.set(i.get(o,u)+t.get(o,l),o,u):i.set(i.get(o,u)+1,o,u))}return i}var DE=Mt((e,t)=>e&t),w8=Zt(ru,DE),k8={kernelName:ru,backendName:\"cpu\",kernelFunc:w8};function fr(e){return(t,n,a)=>{let r=w.getArrayFromDType(n,t.length);for(let s=0;s<t.length;++s)r[s]=e(t[s],a);return r}}function lt(e,t,n){let a=fr(t);return Fs(e,a,n)}function Fs(e,t,n){return({inputs:a,attrs:r,backend:s})=>{let{x:i}=a;ge(i,e);let o=s,l=o.data.get(i.dataId).values,u;if(i.dtype===\"string\"){if(!Array.isArray(l))throw new Error(\"String tensor's value was not an instance of Array\");u=T.fromUint8ToStringArray(l)}else u=l;let p=n||i.dtype,d=t(u,p,r);return o.makeTensorInfo(i.shape,p,d)}}var RE=fr(e=>Math.ceil(e)),I8=Fs(Oi,RE),S8={kernelName:Oi,backendName:\"cpu\",kernelFunc:I8};function L1(e,t,n,a){let r=w.getArrayFromDType(n,w.sizeFromShape(t));if(a&&n!==\"string\"){let s=0;e.forEach(i=>{let o=w.sizeFromShape(i.shape);r.set(i.vals,s),s+=o})}else{let s=0;e.forEach(i=>{let o=n===\"string\"?T.fromUint8ToStringArray(i.vals):i.vals,l=0;for(let u=0;u<i.shape[0];++u){let p=u*t[1]+s;for(let d=0;d<i.shape[1];++d)r[p+d]=o[l++]}s+=i.shape[1]})}return r}var ME=Mt((e,t)=>e===t?1:0),OE=Zt(du,ME,null,\"bool\"),N8={kernelName:du,backendName:\"cpu\",kernelFunc:OE},PE=fr(e=>Math.exp(e)),LE=Fs(Ki,PE,\"float32\"),T8={kernelName:Ki,backendName:\"cpu\",kernelFunc:LE},zE=fr(e=>Math.expm1(e)),C8=Fs(Xi,zE),E8={kernelName:Xi,backendName:\"cpu\",kernelFunc:C8},WE=fr(e=>Math.floor(e)),_8=Fs(Yi,WE),A8={kernelName:Yi,backendName:\"cpu\",kernelFunc:_8},BE=Mt((e,t)=>Math.floor(e/t)),F8=Zt(Zi,BE,null,\"int32\"),$8={kernelName:Zi,backendName:\"cpu\",kernelFunc:F8};function VE(e,t,n,a,r,s,i,o,l){let u=Oe([a,s],n);for(let p=0;p<a;p++){let d=[],c=0;for(let h=0;h<r;h++){let m=e[p*r+h];c+=m*i[h],d.push(m)}if(c<0||c>=l/s)throw new Error(`Invalid indices: ${d} does not index into ${o}`);for(let h=0;h<s;h++)u.values[p*s+h]=t.get(...t.indexToLoc(c*s+h))}return u}function UE(e,t,n){let a=Oe(n,e.dtype);for(let r=0;r<a.size;++r){let s=a.indexToLoc(r).slice(),i=s[0],o=s[2],l=t.locToIndex([i,o]);s[2]=t.values[l];let u=e.locToIndex(s);0<=u&&u<e.values.length&&(a.values[r]=e.values[u])}return a}var GE=Mt((e,t)=>e>t?1:0),D8=Zt(bu,GE,null,\"bool\"),R8={kernelName:bu,backendName:\"cpu\",kernelFunc:D8},HE=Mt((e,t)=>e>=t?1:0),M8=Zt(Qi,HE,null,\"bool\"),O8={kernelName:Qi,backendName:\"cpu\",kernelFunc:M8},jE=Mt((e,t)=>e<t?1:0),P8=Zt(yu,jE,null,\"bool\"),L8={kernelName:yu,backendName:\"cpu\",kernelFunc:P8},qE=Mt((e,t)=>e<=t?1:0),z8=Zt(xu,qE,null,\"bool\"),W8={kernelName:xu,backendName:\"cpu\",kernelFunc:z8};function KE(e,t,n){let a=(t-e)/(n-1),r=w.makeZerosTypedArray(n,\"float32\");r[0]=e;for(let s=1;s<r.length;s++)r[s]=r[s-1]+a;return r}var XE=fr(e=>Math.log(e)),B8=Fs(so,XE),V8={kernelName:so,backendName:\"cpu\",kernelFunc:B8};function YE(e,t,n,a){let r=w.getTypedArrayFromDType(a,w.sizeFromShape(n));for(let s=0;s<r.length;++s){let i=s*t,o=e[i];for(let l=0;l<t;++l){let u=e[i+l];(Number.isNaN(u)||u>o)&&(o=u)}r[s]=o}return r}var ZE=Mt((e,t)=>Math.max(e,t)),U8=Zt(uo,ZE),G8={kernelName:uo,backendName:\"cpu\",kernelFunc:U8},JE=Mt((e,t)=>Math.min(e,t)),H8=Zt(mo,JE),j8={kernelName:mo,backendName:\"cpu\",kernelFunc:H8},z1=Mt((e,t)=>e*t),q8=O1((e,t,n,a)=>({real:e*n-t*a,imag:e*a+t*n})),zf=Zt(bo,z1,q8),K8={kernelName:bo,backendName:\"cpu\",kernelFunc:zf};function QE(e,t,n){let a=w.createScalarValue(-1,n);return z1([],t,a,e,n)}function X8(e){let{inputs:t,backend:n}=e,{x:a}=t;ge(a,\"neg\");let r=n.data.get(a.dataId).values,[s,i]=QE(r,a.shape,a.dtype);return n.makeTensorInfo(i,a.dtype,s)}var Y8={kernelName:Cu,backendName:\"cpu\",kernelFunc:X8},e_=Mt((e,t)=>e!==t?1:0),Z8=Zt(Eu,e_,null,\"bool\"),J8={kernelName:Eu,backendName:\"cpu\",kernelFunc:Z8};function W1(e,t,n,a,r){let s=t.length,i=w.sizeFromShape(t),o=w.computeStrides(t),l=w.computeStrides(r),u=w.getTypedArrayFromDType(n,w.sizeFromShape(r));for(let p=0;p<i;++p){let d=w.indexToLoc(p,s,o),c=new Array(d.length);for(let m=0;m<c.length;m++)c[m]=d[a[m]];let h=w.locToIndex(c,s,l);u[h]=e[p]}return u}function Vn(e){let{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{perm:s}=n;ge(r,\"transpose\");let i=r.shape.length,o=new Array(i);for(let p=0;p<o.length;p++)o[p]=r.shape[s[p]];let l=a.data.get(r.dataId).values,u=W1(l,r.shape,r.dtype,s,o);return{dataId:a.write(u,o,r.dtype),shape:o,dtype:r.dtype}}var Q8={kernelName:Cr,backendName:\"cpu\",kernelFunc:Vn};function t_(e,t,n,a){let[r,s]=T.computeOutAndReduceShapes(e,a),i=fa(t,\"int32\"),o=w.makeZerosTypedArray(w.sizeFromShape(r),i),l=w.sizeFromShape(s);for(let u=0;u<o.length;++u){let p=u*l,d=1;for(let c=0;c<l;++c)d*=n[p+c];o[u]=d}return{outVals:o,outShape:r,outDtype:i}}function eK(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;ge(r,\"prod\");let o=r.shape.length,l=w.parseAxisParam(s,r.shape),u=T.getAxesPermutation(l,o),p=l,d=r,c=[];u!=null&&(d=Vn({inputs:{x:r},backend:n,attrs:{perm:u}}),c.push(d),p=T.getInnerMostAxes(p.length,o));let h=n.data.get(d.dataId).values,{outVals:m,outShape:f,outDtype:g}=t_(d.shape,d.dtype,h,p),b=f;return i&&(b=T.expandShapeToKeepDim(f,l)),c.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.makeTensorInfo(b,g,m)}var tK={kernelName:ko,backendName:\"cpu\",kernelFunc:eK};function nK(e,t,n){e.forEach((a,r)=>{if(a<0||a>=n){let s=w.indexToLoc(r,t.length,w.computeStrides(t)).join(\",\");throw new Error(`indices[${s}] = ${a} is not in [0, ${n})`)}})}function aK(e,t){for(let n=0;n<e.length;++n){let a=e[n],r=n===e.length-1?t:e[n+1].length;if(a.length===0)throw new Error(\"Ragged splits may not be empty\");if(a[0]<0)throw new Error(\"Ragged splits must be non-negative\");if(a[a.length-1]>r)throw new Error(\"Ragged splits must not point past values\");for(let s=1;s<a.length;++s)if(a[s-1]>a[s])throw new Error(\"Ragged splits must be sorted in ascending order\")}}function rK(e,t,n,a){let r=[],s=0,i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);aK(n,a);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];let p=t[u+1];for(let d=1;d<l+1;++d)o[u].push(d*p)}for(let u=0;u<e.length;++u){let p=e[u],d=e[u]+1;for(let c=0;c<n.length;++c){let h=n[c],m=c+t.length-1;if(m>=0){let f=o[m],g=f[f.length-1]-h[p];for(let b=p;b<d;++b)o[m].push(h[b+1]+g)}p=h[p],d=h[d]}d!==p&&(r.push([p,d]),s+=d-p)}return{outSplits:o,valueSlices:r,numValues:s}}function sK(e){let t=[];for(let n=0;n<e.length;++n){let a=e[n].length,r=w.getArrayFromDType(\"int32\",a);t.push(r),e[n].forEach((s,i)=>r[i]=s)}return t}function YI(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let a=t;a<e.length;a++)n[t-1]*=e[a];return n}function iK(e,t,n,a,r,s){let i=YI(t,2)[1],o=YI(s,2)[1],l=0;for(let u of n)for(let p=u[0];p<u[1];++p){for(let d=0;d<a;++d)r[l*o+d]=e[p*i+d];++l}}function oK(e,t,n,a,r){let s=t.slice();s[0]=r;let i=w.getArrayFromDType(n,w.sizeFromShape(s)),o=e.length,l=o===0?0:o/t[0];return iK(e,t,a,l,i,s),[i,s]}function n_(e,t,n,a,r,s,i,o){if(e.length===0)throw new Error(\"paramsNestedSplits must be non empty\");if(t[0].length===0)throw new Error(\"Split tensors must not be scalars\");let l=t[0][0]-1;if(nK(s,i,l),a.length===0)throw new Error(\"params.rank must be nonzero\");let u=a[0],{outSplits:p,valueSlices:d,numValues:c}=rK(s,i,e,u),h=sK(p),m=oK(n,a,r,d,c);return[h,m[0],m[1]]}var ZI=2147483647;function a_(e,t,n,a,r,s,i){if(t.length>1)throw new Error(\"starts must be a scalar or vector\");if(r.length>1)throw new Error(\"limits must be a scalar or vector\");if(i.length>1)throw new Error(\"deltas must be a scalar or vector\");let o=t.length===0,l=r.length===0,u=i.length===0,p=[];o||p.push(t[0]),l||p.push(r[0]),u||p.push(i[0]);for(let g=1;g<p.length;++g)if(p[g]!==p[g-1])throw new Error(\"starts, limits, and deltas must have the same shape\");let d=p.length===0?1:p[0],c=w.getArrayFromDType(\"int32\",d+1);c[0]=0;for(let g=0;g<d;++g){let b=o?e[0]:e[g],y=l?a[0]:a[g],x=u?s[0]:s[g];if(x===0)throw new Error(\"Requires delta != 0\");let v;if(x>0&&y<b||x<0&&y>b)v=0;else if(v=Math.ceil(Math.abs((y-b)/x)),v>ZI)throw new Error(`Requires ((limit - start) / delta) <= ${ZI}`);c[g+1]=c[g]+v}let h=c[d],m=w.getArrayFromDType(n,h),f=0;for(let g=0;g<d;++g){let b=c[g+1]-c[g],y=o?e[0]:e[g],x=u?s[0]:s[g];for(let v=0;v<b;++v)m[f++]=y,y+=x}return[c,m]}var Na=T.RowPartitionType,lK=class ov{constructor(t,n,a,r,s,i,o,l,u,p){this.shape=t,this.shapeShape=n,this.values=a,this.valuesShape=r,this.valuesDType=s,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=T.getRowPartitionTypesHelper(p),this.raggedRank=T.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Na.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Na.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){let n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Na.VALUE_ROWIDS:return ov.getMaxWidthValueRowID(n);case Na.ROW_SPLITS:return ov.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${Na[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){let n=t.length;if(n===0||n===1)return 0;let a=0;for(let r=0;r<n-1;++r){let s=t[r+1]-t[r];s>a&&(a=s)}return a}static getMaxWidthValueRowID(t){let n=t.length;if(n===0)return 0;let a=0,r=t[0],s=0;for(let i=1;i<n;++i){let o=t[i];o!==r&&(r=o,s=Math.max(i-a,s),a=i)}return Math.max(n-a,s)}tensorShapeFromTensor(t,n,a=!0){if(n.length===0){if(t[0]===-1)return[];throw new Error(\"The only valid scalar shape tensor is the fully unknown shape specified as -1.\")}return QI(t,a)}calculateOutputSize(t){let n=this.valuesShape,a=this.defaultValueShape;T.validateDefaultValueShape(a,n);let r=this.tensorShapeFromTensor(this.shape,this.shapeShape),s=T.combineRaggedTensorToTensorShapes(this.raggedRank,r,n);s[0]<0&&(s[0]=t);for(let i=1;i<=this.raggedRank;++i)s[i]<0&&(s[i]=this.getMaxWidth(i));return s}calculateFirstParentOutputIndex(t,n,a){let r=Math.min(t,a),s=[],i=0;for(let o=0;o<r;++o,i+=n)s.push(i);for(let o=r;o<t;++o)s.push(-1);return w.assert(s.length===t,()=>\"Final length of result must be equal to firstDimension.\"),s}calculateOutputIndexRowSplit(t,n,a,r){let s=t.length,i=[];for(let o=0;o<s-1;++o){let l=t[o+1]-t[o],u=Math.min(r,l),p=n[o];p===-1&&(u=0);for(let d=0;d<u;++d)i.push(p),p+=a;for(let d=0;d<l-u;++d)i.push(-1)}if(s>0&&i.length!==t[s-1])throw new Error(\"Invalid row split size.\");return i}calculateOutputIndexValueRowID(t,n,a,r){let s=t.length,i=[];if(s===0)return[];let o=0,l=t[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let u=n[l];i.push(u);for(let p=1;p<s;++p){let d=t[p];if(d===l)u>=0&&(++o,o<r?u+=a:u=-1);else{if(o=0,l=d,d>=n.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${n.length}`);u=n[d]}i.push(u)}if(i.length!==t.length)throw new Error(\"Invalid row ids.\");return i}calculateOutputIndex(t,n,a,r){let s=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case Na.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,n,a,r);case Na.ROW_SPLITS:if(s.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(s,n,a,r);default:throw new Error(`Unsupported partition type: ${Na[i]}`)}}getFirstDimensionSize(){let t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error(\"No row_partition_types given.\");let n=this.rowPartitionTypes[0];switch(n){case Na.FIRST_DIM_SIZE:return t[0];case Na.VALUE_ROWIDS:throw new Error(\"Cannot handle VALUE_ROWIDS in first dimension.\");case Na.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Na[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error(\"Invalid first partition input. Tensor requires at least one element.\");let t=this.getFirstDimensionSize(),n=this.calculateOutputSize(t),a=new Array(this.raggedRank+1);a[a.length-1]=1;for(let i=a.length-2;i>=0;--i)a[i]=a[i+1]*n[i+1];let r=QI(n,!1),s=w.getArrayFromDType(this.valuesDType,w.sizeFromShape(r));if(a[0]*n[0]>0){let i=this.calculateFirstParentOutputIndex(t,a[0],n[0]);for(let o=1;o<=this.raggedRank;++o)i=this.calculateOutputIndex(o-1,i,a[o],n[o]);this.setOutput(this.raggedRank,i,s,r)}return[r,s]}setOutput(t,n,a,r){if(a.length===0)return;let s=this.values,i=a,o=r.slice();o=o.slice(t+1);let l=w.sizeFromShape(o),u=n.length,p=this.defaultValue;if(p.length!==l&&p.length!==1){let m=this.defaultValueShape;O(()=>{let f=W(p,m);p=ai(f,o).dataSync()})}let d=0,c=0,h=0;for(let m=0;m<=u;++m){let f=m<u?n[m]:-1;if(f===h){++h;continue}if(c<h){let g=s.subarray(d*l),b=i.subarray(c*l),y=(h-c)*l;JI(b,g,y)}if(m>=u){let g=a.length;f=Math.floor(g/l)}if(f>h)if(this.defaultValue.length===1)i.subarray(h*l,f*l).fill(this.defaultValue[0]),h=f;else for(;f>h;){let g=i.slice(h*l);JI(g,p,l),++h}f<0?(d=m+1,c=h):(d=m,c=h,h=c+1)}}};function JI(e,t,n){for(let a=0;a<n;a++)e[a]=t[a]}function QI(e,t){let n=[];for(let a of e){if(a<0){if(!t)throw new Error(`Dimension ${a} must be >= 0`);if(a<-1)throw new Error(`Dimension ${a} must be >= -1`);a=-1}n.push(a)}return n}function r_(e,t,n,a,r,s,i,o,l,u){return new lK(e,t,n,a,r,s,i,o,l,u).compute()}function B1(e,t,n,a){let r=e===t,s=e<t&&n<0,i=t<e&&n>1;if(r||s||i)return w.makeZerosTypedArray(0,a);let o=Math.abs(Math.ceil((t-e)/n)),l=w.makeZerosTypedArray(o,a);t<e&&n===1&&(n=-1),l[0]=e;for(let u=1;u<l.length;u++)l[u]=l[u-1]+n;return l}var s_=fr(e=>1/Math.sqrt(e)),uK=Fs(Ao,s_),pK={kernelName:Ao,backendName:\"cpu\",kernelFunc:uK};function ni(e,t,n,a,r,s,i,o,l,u){let p=[a/r,r],d=e.values,c=t.values;if(a===0)return Oe(n,t.dtype);let h=l instanceof Wt?l:Oe(p,t.dtype);typeof l==\"string\"||typeof l==\"number\"?h.values.fill(l):typeof l==\"boolean\"&&h.values.fill(+l);for(let m=0;m<s;m++){let f=[],g=0;for(let b=0;b<i;b++){let y=d[m*i+b];f.push(y),g+=y*o[b]}if(g<0||g>=a/r)throw new Error(`Invalid indices: ${f} does not index into ${n}`);for(let b=0;b<r;b++)u?h.values[g*r+b]+=c[m*r+b]:h.values[g*r+b]=t.rank===0?c[0]:c[m*r+b]}return h}var cK=fr(e=>1/(1+Math.exp(-e))),i_=lt(Mo,e=>1/(1+Math.exp(-e))),dK={kernelName:Mo,backendName:\"cpu\",kernelFunc:i_};function um(e,t,n,a,r){let s=Kt.isSliceContinous(a,t,n),i=w.sizeFromShape(n),o=w.computeStrides(a);if(s){let d=Kt.computeFlatOffset(t,o);return r===\"string\"?e.slice(d,d+i):e.subarray(d,d+i)}let l=r===\"string\"?T.fromUint8ToStringArray(e):e,u=Oe(a,r,l),p=Oe(n,r);for(let d=0;d<p.size;++d){let c=p.indexToLoc(d),h=c.map((m,f)=>m+t[f]);p.set(u.get(...h),...c)}return r===\"string\"?T.fromStringArrayToUint8(p.values):p.values}function xi(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:i}=a;ge(r,\"slice\");let[o,l]=Kt.parseSliceParams(r,s,i);Kt.assertParamsValid(r,o,l);let u=n.data.get(r.dataId).values,p=um(u,o,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,p)}var hK={kernelName:Bu,backendName:\"cpu\",kernelFunc:xi};function o_(e,t,n,a,r,s,i){let o=t[0],l=s[0],u=new Array(l),p=new Array(o),d=t[1];if(l===0){if(o!==0)throw new Error(T.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));let g=w.getArrayFromDType(n,0),b=w.getArrayFromDType(r,0);return[g,[0,d],b,u,p]}let c=!0,h=0,m=new Array(l).fill(0);for(let g=0;g<o;++g){let b=e[g*d];if(b<0)throw new Error(T.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,b));if(b>=l)throw new Error(T.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,b,l));++m[b],c=c&&b>=h,h=b}let f=!0;for(let g=0;g<l;++g){let b=m[g]===0;u[g]=b,f=f&&!b,m[g]=Math.max(m[g],1),g>0&&(m[g]+=m[g-1])}if(f&&c){let g=e,b=a;for(let y=0;y<o;++y)p[y]=y;return[g,[o,d],b,u,p]}else{let g=m[l-1],b=w.getArrayFromDType(n,g*d),y=w.getArrayFromDType(r,g),x=new Array(l).fill(0);for(let v=0;v<o;++v){let I=e[v*d],N=x[I],C=(I===0?0:m[I-1])+N;x[I]++;for(let _=0;_<d;++_)b[C*d+_]=e[v*d+_];y[C]=a[v],p[v]=C}for(let v=0;v<l;++v)if(x[v]===0){let I=v===0?0:m[v-1];b[I*d+0]=v;for(let N=1;N<d;++N)b[I*d+N]=0;y[I]=i}return[b,[g,d],y,u,p]}}function l_(e,t,n,a,r){let s=w.sizeFromShape(a),i=t[0],o=r.length,l=[],u=1,p=-1;for(let f=0;f<o;++f){let g=r[f];if(g===-1){if(p!==-1)throw new Error(T.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(p,f));p=f,l.push(1)}else{if(g<0)throw new Error(T.getSparseReshapeNegativeOutputDimErrorMessage(f,g));u*=g,l.push(g)}}if(p!==-1){if(u<=0)throw new Error(T.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let f=Math.trunc(s/u);if(u*f!==s)throw new Error(T.getSparseReshapeInputOutputMultipleErrorMessage(a,l));l[p]=f}if(w.sizeFromShape(l)!==s)throw new Error(T.getSparseReshapeInputOutputMismatchErrorMessage(a,l));let d=a.length,c=[];if(d>0){c[d-1]=1;for(let f=d-2;f>=0;--f)c[f]=c[f+1]*a[f+1]}let h=[];if(o>0){h[o-1]=1;for(let f=o-2;f>=0;--f)h[f]=h[f+1]*l[f+1]}let m=w.getArrayFromDType(n,i*o);for(let f=0;f<i;++f){let g=0;for(let b=0;b<d;++b)g+=e[f*d+b]*c[b];for(let b=0;b<o;++b)m[f*o+b]=Math.trunc(g/h[b]),g%=h[b]}return[m,[i,o],l]}function V1(e,t,n,a,r,s=!1,i=0){let o=a.length,l=[t[0],e.length/t[0]],u=l[1],p=o>0?r[o-1]+1:0;if(p<0)throw new Error(T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=t.slice();d[0]=p;let c=d.reduce((y,x)=>y*x,1),h=w.getArrayFromDType(n,c);if(o===0)return p>0&&h.fill(i),[h,d];if(p<=0)throw new Error(T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=0,f=1,g=0,b=r[m];for(;;){let y=0;if(f<o){if(y=r[f],b===y){++f;continue}if(b>=y)throw new Error(T.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(b<0||b>=p)throw new Error(T.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b,p));b>g&&h.fill(i,g*u,b*u);for(let x=m;x<f;++x){let v=a[x];if(v<0||v>=l[0])throw new Error(T.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(x,a[x],l[0]));for(let I=0;I<u;I++)h[b*u+I]+=e[v*u+I]}if(s)for(let x=0;x<u;x++)h[b*u+x]/=f-m;if(m=f,++f,g=b+1,b=y,f>o)break}return g<p&&h.fill(i,g*u,p*u),[h,d]}var mK=fr(e=>Math.sqrt(e)),fK=lt(Po,e=>Math.sqrt(e)),gK={kernelName:Po,backendName:\"cpu\",kernelFunc:fK},u_=Mt((e,t)=>{let n=e-t;return n*n}),bK=Zt(Wo,u_),yK={kernelName:Wo,backendName:\"cpu\",kernelFunc:bK},p_=fr((e,t)=>{let{pattern:n,replaceGlobal:a,rewrite:r}=t;return e.replace(new RegExp(n,a?\"g\":\"\"),r)}),xK=Fs(Kc,p_),vK={kernelName:Kc,backendName:\"cpu\",kernelFunc:xK};function c_(e,t,n,a){let r=Oe(e,t.dtype);for(let s=0;s<r.size;s++){let i=r.indexToLoc(s),o=new Array(i.length);for(let l=0;l<o.length;l++)o[l]=i[l]*n[l]+a[l];r.set(t.get(...o),...i)}return r}var wK=class{constructor(e,t,n,a,r,s){this.separator=w.encodeString(e),this.nGramWidths=t,this.leftPad=w.encodeString(n),this.rightPad=w.encodeString(a),this.padWidth=r,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,a,r,s){for(let i=0;i<r;++i){let o=this.getPadWidth(s),l=Math.max(0,o-i),u=Math.max(0,o-(r-(i+1))),p=s-(l+u),d=t+(l>0?0:i-o),c=0;c+=l*this.leftPad.length;for(let b=0;b<p;++b)c+=e[d+b].length;c+=u*this.rightPad.length;let h=l+u+p-1;c+=h*this.separator.length,n[a+i]=new Uint8Array(c);let m=n[a+i],f=0,g=b=>b.forEach(y=>m[f++]=y);for(let b=0;b<l;++b)g(this.leftPad),g(this.separator);for(let b=0;b<p-1;++b)g(e[d+b]),g(this.separator);if(p>0){g(e[d+p-1]);for(let b=0;b<u;++b)g(this.separator),g(this.rightPad)}else{for(let b=0;b<u-1;++b)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){let n=e.length,a=t.length;if(a>0){let o=t[0];if(o!==0)throw new Error(`First split value must be 0, got ${o}`);for(let l=1;l<a;++l){let u=t[l]>=o;if(u=u&&t[l]<=n,!u)throw new Error(`Invalid split value ${t[l]}, must be in [${o}, ${n}]`);o=t[l]}if(o!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${o}`)}let r=a-1,s=w.getArrayFromDType(\"int32\",a);if(n===0||a===0){let o=new Array(n);for(let l=0;l<=r;++l)s[l]=0;return[o,s]}s[0]=0;for(let o=1;o<=r;++o){let l=t[o]-t[o-1],u=0;this.nGramWidths.forEach(p=>{u+=this.getNumNGrams(l,p)}),this.preserveShort&&l>0&&u===0&&(u=1),s[o]=s[o-1]+u}let i=new Array(s[r]);for(let o=0;o<r;++o){let l=t[o],u=s[o];if(this.nGramWidths.forEach(p=>{let d=t[o+1]-t[o],c=this.getNumNGrams(d,p);this.createNGrams(e,l,i,u,c,p),u+=c}),this.preserveShort&&u===s[o]){let p=t[o+1]-t[o];if(p===0)continue;let d=p+2*this.padWidth;this.createNGrams(e,l,i,u,1,d)}}return[i,s]}};function U1(e,t,n,a,r,s,i,o){return new wK(n,a,r,s,i,o).compute(e,t)}function kK(e,t,n,a){if(!e.length)return;if(t.length===0){for(let s=0;s<e.length;++s)a.push(e.subarray(s,s+1));return}if(t.length===1){let s=t[0],i=e.indexOf(s);for(;i!==-1;){let o=e.subarray(0,i);(!n||o.length!==0)&&a.push(o),e=e.subarray(i+1),i=e.indexOf(s)}(!n||e.length!==0)&&a.push(e);return}let r=0;for(let s=0;s<e.length+1;s++)if(s===e.length||t.indexOf(e[s])!==-1){let i=e.subarray(r,s);(!n||i.length!==0)&&a.push(i),r=s+1}}function G1(e,t,n){let a=e.length,r=[],s=0,i=0,o=new Array(a);for(let c=0;c<a;++c){let h=r.length;kK(e[c],t,n,r);let m=r.length-h;o[c]=m,s+=m,i=Math.max(i,m)}let l=w.getArrayFromDType(\"int32\",s*2),u=new Array(s),p=[a,i],d=0;for(let c=0;c<a;++c)for(let h=0;h<o[c];++h)l[d*2]=c,l[d*2+1]=h,u[d]=r[d],++d;return[l,u,p]}function H1(e,t){let n=w.getArrayFromDType(\"int32\",e.length);for(let a=0;a<e.length;++a)n[a]=w.fingerPrint64(e[a]).modulo(t).getLowBitsUnsigned();return n}var d_=Mt((e,t)=>e-t),IK=O1((e,t,n,a)=>({real:e-n,imag:t-a})),j1=Zt(Bo,d_,IK),SK={kernelName:Bo,backendName:\"cpu\",kernelFunc:j1};function h_(e,t){let n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];let a=Oe(n,e.dtype);for(let r=0;r<a.values.length;++r){let s=a.indexToLoc(r),i=new Array(e.rank);for(let l=0;l<i.length;l++)i[l]=s[l]%e.shape[l];let o=e.locToIndex(i);a.values[r]=e.values[o]}return a}var nc=(e,t)=>{let n=t.value-e.value;return n===0?e.index-t.index:n};function m_(e,t,n=0,a=e.length-1){for(;a>n;){if(a-n>600){let o=a-n+1,l=t-n+1,u=Math.log(o),p=.5*Math.exp(2*u/3),d=.5*Math.sqrt(u*p*(o-p)/o)*Math.sign(l-o/2),c=Math.max(n,Math.floor(t-l*p/o+d)),h=Math.min(a,Math.floor(t+(o-l)*p/o+d));m_(e,t,c,h)}let r=e[t],s=n,i=a;for(w.swap(e,n,t),nc(e[a],r)>0&&w.swap(e,n,a);s<i;){for(w.swap(e,s,i),s++,i--;nc(e[s],r)<0;)s=s+1;for(;nc(e[i],r)>0;)i=i-1}nc(e[n],r)===0?w.swap(e,n,i):(i=i+1,w.swap(e,i,a)),i<=t&&(n=i+1),t<=i&&(a=i-1)}}function f_(e,t,n,a,r){let s=t[t.length-1],[i,o]=[e.length/s,s],l=w.getTypedArrayFromDType(n,i*a),u=w.getTypedArrayFromDType(\"int32\",i*a);for(let d=0;d<i;d++){let c=d*o,h=e.subarray(c,c+o),m=new Array(h.length);h.forEach((y,x)=>m[x]={value:y,index:x}),a<m.length&&(m_(m,a),m=m.slice(0,a)),r&&m.sort(nc);let f=d*a,g=l.subarray(f,f+a),b=u.subarray(f,f+a);for(let y=0;y<a;y++)g[y]=m[y].value,b[y]=m[y].index}let p=t.slice();return p[p.length-1]=a,[Oe(p,n,l),Oe(p,\"int32\",u)]}function q1(e,t,n,a){let r=w.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let m=0;m<r;m++)s[0]*=n[m];s[1]=n[r];for(let m=r+1;m<n.length;m++)s[2]*=n[m];let i=new Map,o=new Int32Array(n[r]),l=new Wt(s,a,e),u=[],p=s[0]===1&&s[2]===1;for(let m=0;m<n[r];m++){let f;if(p)f=e[m].toString();else{let b=[];for(let y=0;y<s[0];y++)for(let x=0;x<s[2];x++)b.push(l.get(y,m,x));f=b.join(\",\")}let g=i.get(f);if(g!=null)o[m]=g;else{let b=i.size;i.set(f,b),o[m]=b,u.push(m)}}let d=s.slice();d[1]=i.size;let c=new Wt(d,a);u.forEach((m,f)=>{for(let g=0;g<s[0];g++)for(let b=0;b<s[2];b++)c.set(l.get(g,m,b),g,f,b)});let h=n.slice();return h[r]=d[1],{outputValues:c.values,outputShape:h,indices:o}}var NK=\"4.22.0\";Om(\"cpu\",()=>new R1,1);var g_=lt(ji,e=>e>=0?e:Math.exp(e)-1),TK={kernelName:ji,backendName:\"cpu\",kernelFunc:g_};function b_(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:s}=a;ge([r],\"leakyRelu\");let i=w.sizeFromShape(r.shape),o=n.data.get(r.dataId).values,l=w.getTypedArrayFromDType(\"float32\",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?s*o[u]:o[u];return n.makeTensorInfo(r.shape,\"float32\",l)}var CK={kernelName:ro,backendName:\"cpu\",kernelFunc:b_},EK=Mt((e,t)=>e<0?t*e:e);function y_(e){let{inputs:t,backend:n}=e,{x:a,alpha:r}=t;ge([a,r],\"prelu\");let s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,[o,l]=EK(a.shape,r.shape,s,i,\"float32\");return n.makeTensorInfo(l,\"float32\",o)}var _K={kernelName:wo,backendName:\"cpu\",kernelFunc:y_},x_=lt(So,e=>Math.max(0,e)),AK={kernelName:So,backendName:\"cpu\",kernelFunc:x_},v_=lt(Co,e=>Math.min(Math.max(0,e),6)),FK={kernelName:Co,backendName:\"cpu\",kernelFunc:v_};function pm(e,t,n,a,r){if(n===\"linear\")return cr({inputs:{x:t},backend:e});if(n===\"relu\")return x_({inputs:{x:t},backend:e});if(n===\"elu\")return g_({inputs:{x:t},backend:e});if(n===\"relu6\")return v_({inputs:{x:t},backend:e});if(n===\"prelu\")return y_({inputs:{x:t,alpha:a},backend:e});if(n===\"leakyrelu\")return b_({inputs:{x:t},backend:e,attrs:{alpha:r}});if(n===\"sigmoid\")return i_({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function xt(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:s}=a,i=w.sizeFromShape(r.shape),o=w.inferFromImplicitShape(s,i),l=w.sizeFromShape(o);w.assert(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(r.dataId);let u=n.data.get(r.dataId);if(u.complexTensorInfos!=null){let p=u.complexTensorInfos.real,d=u.complexTensorInfos.imag;p.shape=o,d.shape=o}return{dataId:r.dataId,shape:o,dtype:r.dtype}}var $K={kernelName:Ru,backendName:\"cpu\",kernelFunc:xt};function w_(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=a;ge([r,s],\"matMul\");let l=r.shape.length,u=s.shape.length,p=i?r.shape[l-2]:r.shape[l-1],d=o?s.shape[u-1]:s.shape[u-2],c=i?r.shape[l-1]:r.shape[l-2],h=o?s.shape[u-2]:s.shape[u-1],m=r.shape.slice(0,-2),f=s.shape.slice(0,-2),g=w.sizeFromShape(m),b=w.sizeFromShape(f),y=Ju.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([c,h]);w.assert(p===d,()=>`Error in matMul: inner shapes (${p}) and (${d}) of Tensors with shapes ${r.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let x=i?[g,p,c]:[g,c,p],v=o?[b,h,d]:[b,d,h],I=xt({inputs:{x:r},backend:n,attrs:{shape:x}}),N=xt({inputs:{x:s},backend:n,attrs:{shape:v}}),C=i?I.shape[1]:I.shape[2],_=i?I.shape[2]:I.shape[1],F=o?N.shape[1]:N.shape[2],D=Math.max(g,b),$=n.data.get(I.dataId).values,S=n.data.get(N.dataId).values,M=w.computeStrides(I.shape),B=w.computeStrides(N.shape),[U,H,q]=i?[M[0],1,M[1]]:[M[0],M[1],1],[K,Z,J]=o?[1,B[1],B[0]]:[B[1],1,B[0]],ee=_*F,ae=Oe([D,_,F],I.dtype),te=ae.values,se=n.blockSize;for(let ie=0;ie<D;ie++){let ve=ie%g,ue=ie%b;for(let ye=0;ye<_;ye+=se){let ke=Math.min(ye+se,_);for(let Se=0;Se<F;Se+=se){let Le=Math.min(Se+se,F);for(let Ue=0;Ue<C;Ue+=se){let mt=Math.min(Ue+se,C);for(let st=ye;st<ke;st++)for(let tt=Se;tt<Le;tt++){let nt=0;for(let Re=Ue;Re<mt;Re++){let gt=$[ve*U+st*H+Re*q],Gn=S[Re*K+tt*Z+ue*J];nt+=gt*Gn}te[ie*ee+(st*F+tt)]+=nt}}}}}return n.disposeIntermediateTensorInfo(I),n.disposeIntermediateTensorInfo(N),n.makeTensorInfo(y,ae.dtype,ae.values)}var DK={kernelName:Ri,backendName:\"cpu\",kernelFunc:w_};function RK(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:p,leakyreluAlpha:d}=a,c,h,m,f=[];c=w_({inputs:{a:r,b:s},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(h=jl({inputs:{a:c,b:i},backend:n}),f.push(c),c=h),p&&(m=pm(n,c,p,o,d),f.push(c),c=m);for(let g of f)n.disposeIntermediateTensorInfo(g);return c}var MK={kernelName:ii,backendName:\"cpu\",kernelFunc:RK},OK=lt(Ni,e=>Math.acos(e)),PK={kernelName:Ni,backendName:\"cpu\",kernelFunc:OK},LK=lt(Ti,e=>Math.acosh(e)),zK={kernelName:Ti,backendName:\"cpu\",kernelFunc:LK};function WK(e){let{inputs:t,backend:n}=e,a=t;ge(t,\"addN\");let r=a.map(o=>n.data.get(o.dataId).values),s=Oe(a[0].shape,a[0].dtype),i=s.values;for(let o=0;o<a.length;o++){let l=r[o];for(let u=0;u<i.length;u++)i[u]+=l[u]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}var BK={kernelName:Ci,backendName:\"cpu\",kernelFunc:WK};function VK(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;ge(r,\"all\");let o=w.parseAxisParam(s,r.shape),l=o,u=T.getAxesPermutation(l,r.shape.length),p=r;u!=null&&(p=Vn({inputs:{x:r},backend:n,attrs:{perm:u}}),l=T.getInnerMostAxes(l.length,r.shape.length)),T.assertAxesAreInnerMostDims(\"all\",l,p.shape.length);let[d,c]=T.computeOutAndReduceShapes(p.shape,l),h=w.sizeFromShape(c),m=w.makeZerosTypedArray(w.sizeFromShape(d),p.dtype),f=n.data.get(p.dataId).values;for(let b=0;b<m.length;++b){let y=b*h,x=f[y];for(let v=0;v<h;++v){let I=f[y+v];x=x&&I}m[b]=x}u!=null&&n.disposeIntermediateTensorInfo(p);let g=n.makeTensorInfo(d,p.dtype,m);if(i){let b=T.expandShapeToKeepDim(d,o),y=xt({inputs:{x:g},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(g),y}return g}var UK={kernelName:Zl,backendName:\"cpu\",kernelFunc:VK};function GK(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;ge(r,\"any\");let o=w.parseAxisParam(s,r.shape),l=o,u=T.getAxesPermutation(l,r.shape.length),p=r;u!=null&&(p=Vn({inputs:{x:r},backend:n,attrs:{perm:u}}),l=T.getInnerMostAxes(l.length,r.shape.length)),T.assertAxesAreInnerMostDims(\"any\",l,p.shape.length);let[d,c]=T.computeOutAndReduceShapes(p.shape,l),h=w.sizeFromShape(c),m=w.makeZerosTypedArray(w.sizeFromShape(d),p.dtype),f=n.data.get(p.dataId).values;for(let b=0;b<m.length;++b){let y=b*h,x=f[y];for(let v=0;v<h;++v){let I=f[y+v];x=x||I}m[b]=x}u!=null&&n.disposeIntermediateTensorInfo(p);let g=n.makeTensorInfo(d,p.dtype,m);if(i){let b=T.expandShapeToKeepDim(d,o),y=xt({inputs:{x:g},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(g),y}return g}var HK={kernelName:Jl,backendName:\"cpu\",kernelFunc:GK};function jK(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;ge(r,\"argMax\");let i=w.parseAxisParam(s,r.shape),o=T.getAxesPermutation(i,r.shape.length),l=r,u=[];o!=null&&(l=Vn({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),i=T.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],T.assertAxesAreInnerMostDims(\"argMax\",i,l.shape.length);let[p,d]=T.computeOutAndReduceShapes(l.shape,i),c=w.sizeFromShape(p),h=w.makeZerosTypedArray(c,\"int32\"),m=w.sizeFromShape(d),f=n.data.get(l.dataId).values;for(let g=0;g<h.length;++g){let b=g*m,y=f[b],x=0;for(let v=0;v<m;++v){let I=f[b+v];I>y&&(y=I,x=v)}h[g]=x}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(p,\"int32\",h)}var qK={kernelName:Ql,backendName:\"cpu\",kernelFunc:jK};function KK(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;ge(r,\"argMin\");let i=w.parseAxisParam(s,r.shape),o=T.getAxesPermutation(i,r.shape.length),l=r,u=[];o!=null&&(l=Vn({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),i=T.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],T.assertAxesAreInnerMostDims(\"argMin\",i,l.shape.length);let[p,d]=T.computeOutAndReduceShapes(l.shape,i),c=w.sizeFromShape(p),h=w.makeZerosTypedArray(c,\"int32\"),m=w.sizeFromShape(d),f=n.data.get(l.dataId).values;for(let g=0;g<h.length;++g){let b=g*m,y=f[b],x=0;for(let v=0;v<m;++v){let I=f[b+v];I<y&&(y=I,x=v)}h[g]=x}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(p,\"int32\",h)}var XK={kernelName:eu,backendName:\"cpu\",kernelFunc:KK},YK=lt(Ei,e=>Math.asin(e)),ZK={kernelName:Ei,backendName:\"cpu\",kernelFunc:YK},JK=lt(_i,e=>Math.asinh(e)),QK={kernelName:_i,backendName:\"cpu\",kernelFunc:JK},eX=lt(Ai,e=>Math.atan(e)),tX={kernelName:Ai,backendName:\"cpu\",kernelFunc:eX},nX=Mt((e,t)=>Math.atan2(e,t)),aX=Zt($i,nX),rX={kernelName:$i,backendName:\"cpu\",kernelFunc:aX},sX=lt(Fi,e=>Math.atanh(e)),iX={kernelName:Fi,backendName:\"cpu\",kernelFunc:sX};function K1(e,t,n,a,r,s){let i=r.strideHeight,o=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,p=r.effectiveFilterHeight,d=r.effectiveFilterWidth,c=r.padInfo.top,h=r.padInfo.left,m=s===\"max\"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,f=Oe(r.outShape,n),g=f.values,b=r.outShape[1]*r.outShape[2]*r.outShape[3],y=r.outShape[2]*r.outShape[3],x=r.outShape[3];for(let v=0;v<r.batchSize;++v){let I=v*b,N=v*a[0];for(let C=0;C<r.inChannels;++C)for(let _=0;_<r.outHeight;++_){let F=_*i-c,D=Math.max(0,F),$=Math.min(r.inHeight,p+F),S=I+_*y;for(let M=0;M<r.outWidth;++M){let B=M*o-h,U=Math.max(0,B),H=Math.min(r.inWidth,d+B),q=m,K=0,Z=0;for(let ee=D;ee<$;ee+=l){let ae=N+ee*a[1];for(let te=U;te<H;te+=u){let se=ae+te*a[2],ie=e[se+C];s===\"max\"&&ie>q?q=ie:s===\"avg\"&&(K+=ie,Z++)}if(isNaN(q))break}let J=S+M*x+C;g[J]=s===\"avg\"?K/Z:q}}}return f}function k_(e,t,n,a,r=!1,s=!1){let i=Oe(a.outShape,\"int32\"),o=a.strideHeight,l=a.strideWidth,u=a.dilationHeight,p=a.dilationWidth,d=a.effectiveFilterHeight,c=a.effectiveFilterWidth,h=a.padInfo.top,m=a.padInfo.left,f=Oe(t,n,e);for(let g=0;g<a.batchSize;++g)for(let b=0;b<a.inChannels;++b)for(let y=0;y<a.outHeight;++y){let x=y*o-h,v=x;for(;v<0;)v+=u;let I=Math.min(a.inHeight,d+x);for(let N=0;N<a.outWidth;++N){let C=N*l-m,_=C;for(;_<0;)_+=p;let F=Math.min(a.inWidth,c+C),D=Number.NEGATIVE_INFINITY,$=-1;for(let S=v;S<I;S+=u){let M=S-x;for(let B=_;B<F;B+=p){let U=B-C,H=f.get(g,S,B,b);H>D&&(D=H,r?$=s?((g*a.inHeight+S)*a.inWidth+B)*a.inChannels+b:(S*a.inWidth+B)*a.inChannels+b:$=M*c+U)}}i.set($,g,y,N,b)}}return i}function I_(e,t,n,a,r,s){let i=r.strideDepth,o=r.strideHeight,l=r.strideWidth,u=r.dilationDepth,p=r.dilationHeight,d=r.dilationWidth,c=r.effectiveFilterDepth,h=r.effectiveFilterHeight,m=r.effectiveFilterWidth,f=r.padInfo.front,g=r.padInfo.top,b=r.padInfo.left,y=s===\"max\"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=Oe(r.outShape,n),v=x.values,I=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],N=r.outShape[2]*r.outShape[3]*r.outShape[4],C=r.outShape[3]*r.outShape[4],_=r.outShape[4];for(let F=0;F<r.batchSize;++F){let D=F*I,$=F*a[0];for(let S=0;S<r.inChannels;++S)for(let M=0;M<r.outDepth;++M){let B=M*i-f,U=B;for(;U<0;)U+=u;let H=Math.min(r.inDepth,c+B),q=D+M*N;for(let K=0;K<r.outHeight;++K){let Z=K*o-g,J=Z;for(;J<0;)J+=p;let ee=Math.min(r.inHeight,h+Z),ae=q+K*C;for(let te=0;te<r.outWidth;++te){let se=te*l-b,ie=se;for(;ie<0;)ie+=d;let ve=Math.min(r.inWidth,m+se),ue=ae+te*_,ye=y,ke=0,Se=0;for(let Ue=U;Ue<H;Ue+=u){let mt=$+Ue*a[1];for(let st=J;st<ee;st+=p){let tt=mt+st*a[2];for(let nt=ie;nt<ve;nt+=d){let Re=tt+nt*a[3],gt=e[Re+S];if(s===\"max\"&&gt>ye?ye=gt:s===\"avg\"&&(ke+=gt,Se++),isNaN(ye))break}if(isNaN(ye))break}if(isNaN(ye))break}let Le=ue+S;v[Le]=s===\"avg\"?ke/Math.max(Se,1):ye}}}}return x}function oX(e,t){let n=Oe(t.outShape,\"int32\"),a=t.strideDepth,r=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,p=t.effectiveFilterHeight,d=t.effectiveFilterWidth,c=t.padInfo.front,h=t.padInfo.top,m=t.padInfo.left;for(let f=0;f<t.batchSize;++f)for(let g=0;g<t.inChannels;++g)for(let b=0;b<t.outDepth;++b){let y=b*a-c,x=y;for(;x<0;)x+=i;let v=Math.min(t.inDepth,u+y);for(let I=0;I<t.outHeight;++I){let N=I*r-h,C=N;for(;C<0;)C+=o;let _=Math.min(t.inHeight,p+N);for(let F=0;F<t.outWidth;++F){let D=F*s-m,$=D;for(;$<0;)$+=l;let S=Math.min(t.inWidth,d+D),M=Number.NEGATIVE_INFINITY,B=-1;for(let U=x;U<v;U+=i){let H=U-y;for(let q=C;q<_;q+=o){let K=q-N;for(let Z=$;Z<S;Z+=l){let J=Z-D,ee=e.get(f,U,q,Z,g);ee>=M&&(M=ee,B=H*p*d+K*p+J)}}}n.set(B,f,b,I,F,g)}}}return n}function lX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;ge(r,\"avgPool\");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=a,u=1;w.assert(T.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let p=T.computePool2DInfo(r.shape,s,i,u,o,l),d;if(p.filterWidth===1&&p.filterHeight===1&&w.arraysEqual(p.inShape,p.outShape))d=cr({inputs:{x:r},backend:n});else{let c=n.data.get(r.dataId).values,h=w.computeStrides(r.shape),m=K1(c,r.shape,r.dtype,h,p,\"avg\");d=n.makeTensorInfo(p.outShape,r.dtype,m.values)}return d}var uX={kernelName:Di,backendName:\"cpu\",kernelFunc:lX};function pX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=a;ge(r,\"avgPool3d\");let p=T.computePool3DInfo(r.shape,s,i,1,o,l,u),d=n.data.get(r.dataId).values,c=I_(d,r.shape,r.dtype,w.computeStrides(r.shape),p,\"avg\");return n.makeTensorInfo(c.shape,\"float32\",c.values)}var cX={kernelName:tu,backendName:\"cpu\",kernelFunc:pX};function dX(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=a;ge([r,s],\"avgPool3DGrad\");let p=T.computePool3DInfo(s.shape,i,o,1,l,u),d=p.strideDepth,c=p.strideHeight,h=p.strideWidth,m=p.filterDepth,f=p.filterHeight,g=p.filterWidth,b=p.dilationDepth,y=p.dilationHeight,x=p.dilationWidth,v=p.effectiveFilterDepth,I=p.effectiveFilterHeight,N=p.effectiveFilterWidth,C=v-1-p.padInfo.front,_=N-1-p.padInfo.left,F=I-1-p.padInfo.top,D=Oe(s.shape,\"float32\"),$=1/(m*f*g),S=n.bufferSync(r);for(let M=0;M<p.batchSize;++M)for(let B=0;B<p.inChannels;++B)for(let U=0;U<p.inDepth;++U)for(let H=0;H<p.inHeight;++H)for(let q=0;q<p.inWidth;++q){let K=U-C,Z=H-F,J=q-_,ee=0;for(let ae=0;ae<v;ae+=b){let te=(K+ae)/d;if(!(te<0||te>=p.outDepth||Math.floor(te)!==te))for(let se=0;se<I;se+=y){let ie=(Z+se)/c;if(!(ie<0||ie>=p.outHeight||Math.floor(ie)!==ie))for(let ve=0;ve<N;ve+=x){let ue=(J+ve)/h;if(ue<0||ue>=p.outWidth||Math.floor(ue)!==ue)continue;let ye=S.get(M,te,ie,ue,B);ee+=ye}}}D.set(ee*$,M,U,H,q,B)}return n.makeTensorInfo(D.shape,D.dtype,D.values)}var hX={kernelName:Rc,backendName:\"cpu\",kernelFunc:dX};function mX(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s;ge([r,s],\"avgPoolGrad\");let{filterSize:o,strides:l,pad:u}=a,p=T.computePool2DInfo(i.shape,o,l,1,u),d=p.strideHeight,c=p.strideWidth,h=p.filterHeight,m=p.filterWidth,f=p.dilationHeight,g=p.dilationWidth,b=p.effectiveFilterHeight,y=p.effectiveFilterWidth,x=y-1-p.padInfo.left,v=b-1-p.padInfo.top,I=Oe(i.shape,\"float32\"),N=1/(h*m),C=n.data.get(r.dataId).values,_=Oe(r.shape,\"float32\",C);for(let F=0;F<p.batchSize;++F)for(let D=0;D<p.inChannels;++D)for(let $=0;$<p.inHeight;++$)for(let S=0;S<p.inWidth;++S){let M=$-v,B=S-x,U=0;for(let H=0;H<b;H+=f){let q=(M+H)/d;if(!(q<0||q>=p.outHeight||Math.floor(q)!==q))for(let K=0;K<y;K+=g){let Z=(B+K)/c;if(Z<0||Z>=p.outWidth||Math.floor(Z)!==Z)continue;let J=_.get(F,q,Z,D);U+=J}}I.set(U*N,F,$,S,D)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}var fX={kernelName:Dc,backendName:\"cpu\",kernelFunc:mX};function gX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,scale:s,offset:i,mean:o,variance:l}=t;w.assert(o.shape.length===l.shape.length,()=>\"Batch normalization gradient requires mean and variance to have equal ranks.\"),w.assert(i==null||o.shape.length===i.shape.length,()=>\"Batch normalization gradient requires mean and offset to have equal ranks.\"),w.assert(s==null||o.shape.length===s.shape.length,()=>\"Batch normalization gradient requires mean and scale to have equal ranks.\"),ge([r,o,l,s,i],\"batchNorm\");let{varianceEpsilon:u}=a;u==null&&(u=.001);let p=n.data.get(r.dataId).values,d=n.data.get(o.dataId).values,c=n.data.get(l.dataId).values,h=s?n.data.get(s.dataId).values:new Float32Array([1]),m=i?n.data.get(i.dataId).values:new Float32Array([0]),f=new Float32Array(p.length),g=m.length,b=h.length,y=c.length,x=d.length,v=0,I=0,N=0,C=0;for(let _=0;_<p.length;++_)f[_]=m[v++]+(p[_]-d[I++])*h[N++]/Math.sqrt(c[C++]+u),v>=g&&(v=0),I>=x&&(I=0),N>=b&&(N=0),C>=y&&(C=0);return n.makeTensorInfo(r.shape,r.dtype,f)}var bX={kernelName:Ji,backendName:\"cpu\",kernelFunc:gX};function yX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:i}=a;ge([r],\"batchToSpaceND\");let o=s.reduce((b,y)=>b*y),l=T.getReshaped(r.shape,s,o),u=T.getPermuted(l.length,s.length),p=T.getReshapedPermuted(r.shape,s,o),d=T.getSliceBeginCoords(i,s.length),c=T.getSliceSize(p,i,s.length),h=xt({inputs:{x:r},backend:n,attrs:{shape:l}}),m=Vn({inputs:{x:h},backend:n,attrs:{perm:u}}),f=xt({inputs:{x:m},backend:n,attrs:{shape:p}}),g=xi({inputs:{x:f},backend:n,attrs:{begin:d,size:c}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(f),g}var xX={kernelName:nu,backendName:\"cpu\",kernelFunc:yX};function vX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i}=a,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=P1(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}var wX={kernelName:au,backendName:\"cpu\",kernelFunc:vX};function kX(e){let{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,o=T.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],\"int32\",Int32Array.from(o))}var IX={kernelName:Mc,backendName:\"cpu\",kernelFunc:kX},SX=lt(ws,(e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),NX={kernelName:ws,backendName:\"cpu\",kernelFunc:SX},TX=e=>{let{x:t}=e.inputs,n=e.backend,a=new Float32Array(w.sizeFromShape(t.shape)),r=n.data.get(t.dataId),s=r.complexTensorInfos.real,i=r.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){let p=o[u],d=l[u];a[u]=Math.hypot(p,d)}return n.makeOutput(a,t.shape,\"float32\")},CX={kernelName:Oc,backendName:\"cpu\",kernelFunc:TX};function ql(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.imag,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}var EX={kernelName:_m,backendName:\"cpu\",kernelFunc:ql};function Kl(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=w.parseAxisParam(r,t[0].shape)[0],i=t.map(f=>f.shape);T.assertParamsConsistent(i,s);let o=T.computeOutShape(t.map(f=>f.shape),s);if(w.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(f=>w.sizeFromShape(f.shape)>0);if(l.length===1)return cr({inputs:{x:l[0]},backend:n});if(l[0].dtype===\"complex64\"){let f=l.map(v=>yi({inputs:{input:v},backend:n})),g=l.map(v=>ql({inputs:{input:v},backend:n})),b=Kl({inputs:f,backend:n,attrs:{axis:s}}),y=Kl({inputs:g,backend:n,attrs:{axis:s}}),x=Yn({inputs:{real:b,imag:y},backend:n});return f.forEach(v=>n.disposeIntermediateTensorInfo(v)),g.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(y),x}let u=l.map(f=>{let g=[-1,w.sizeFromShape(f.shape.slice(s))];return xt({inputs:{x:f},backend:n,attrs:{shape:g}})}),p=u.map(f=>({vals:n.data.get(f.dataId).values,shape:f.shape}));o=T.computeOutShape(u.map(f=>f.shape),1);let d=u[0].shape[0]===1,c=L1(p,o,t[0].dtype,d),h=T.computeOutShape(l.map(f=>f.shape),s),m=n.makeTensorInfo(h,t[0].dtype,c);return u.forEach(f=>n.disposeIntermediateTensorInfo(f)),m}var _X={kernelName:su,backendName:\"cpu\",kernelFunc:Kl};function S_(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:p}=a;ge([r,s],\"conv2d\");let d=T.convertConv2DDataFormat(l),c=T.computeConv2DInfo(r.shape,s.shape,i,u,o,p,!1,d),h=c.filterHeight,m=c.filterWidth,f=c.dilationHeight,g=c.dilationWidth,b=c.padInfo.left,y=c.padInfo.top,x=c.dataFormat===\"channelsLast\",v=new Wt(c.outShape,r.dtype),I=w.computeStrides(r.shape),N=w.computeStrides(s.shape),C=I[0],_=x?I[1]:I[2],F=x?I[2]:1,D=x?1:I[1],$=v.strides[0],S=x?v.strides[1]:v.strides[2],M=x?v.strides[2]:1,B=x?1:v.strides[1],U=n.data.get(r.dataId).values,H=n.data.get(s.dataId).values,q=v.values;for(let K=0;K<c.batchSize;++K){let Z=K*C,J=K*$;for(let ee=0;ee<c.outHeight;++ee){let ae=J+ee*S,te=ee*c.strideHeight-y;for(let se=0;se<h;++se){let ie=te+se*f;if(ie<0||ie>=c.inHeight)continue;let ve=se*N[0],ue=Z+ie*_;for(let ye=0;ye<c.outWidth;++ye){let ke=ae+ye*M,Se=ye*c.strideWidth-b;for(let Le=0;Le<m;++Le){let Ue=Se+Le*g;if(Ue<0||Ue>=c.inWidth)continue;let mt=ve+Le*N[1],st=ue+Ue*F,tt=mt;for(let nt=0;nt<c.inChannels;++nt){let Re=U[st+nt*D];for(let gt=0;gt<c.outChannels;++gt)q[ke+gt*B]+=Re*H[tt+gt];tt+=c.outChannels}}}}}}return n.makeTensorInfo(v.shape,v.dtype,q)}var AX={kernelName:Pi,backendName:\"cpu\",kernelFunc:S_};function FX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:p}=a;ge([r,s],\"conv2dBackpropFilter\");let d=T.convertConv2DDataFormat(l),c=T.computeConv2DInfo(r.shape,p,i,1,o,u,!1,d),{strideHeight:h,strideWidth:m,filterHeight:f,filterWidth:g}=c,b=c.dataFormat===\"channelsLast\",y=new Wt(c.filterShape,\"float32\"),x=c.padInfo.left,v=c.padInfo.top,I=n.data.get(r.dataId).values,N=n.data.get(s.dataId).values,C=new Wt(r.shape,r.dtype,I),_=new Wt(s.shape,s.dtype,N);for(let F=0;F<f;++F){let D=Math.max(0,Math.ceil((v-F)/h)),$=Math.min(c.outHeight,(c.inHeight+v-F)/h);for(let S=0;S<g;++S){let M=Math.max(0,Math.ceil((x-S)/m)),B=Math.min(c.outWidth,(c.inWidth+x-S)/m);for(let U=0;U<c.inChannels;++U)for(let H=0;H<c.outChannels;++H){let q=0;for(let K=0;K<c.batchSize;++K)for(let Z=D;Z<$;++Z){let J=F+Z*h-v;for(let ee=M;ee<B;++ee){let ae=S+ee*m-x;b?q+=C.get(K,J,ae,U)*_.get(K,Z,ee,H):q+=C.get(K,U,J,ae)*_.get(K,H,Z,ee)}}y.set(q,F,S,U,H)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var $X={kernelName:km,backendName:\"cpu\",kernelFunc:FX};function DX(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:p}=a;ge([r,s],\"conv2dBackpropInput\");let d=w.computeStrides(s.shape),c=w.computeStrides(r.shape),h=T.convertConv2DDataFormat(u),m=T.computeConv2DInfo(i,s.shape,o,1,l,p,!1,h),f=new Wt(m.inShape,\"float32\"),g=f.values,b=n.data.get(r.dataId).values,y=n.data.get(s.dataId).values,[x,v,I]=d,{batchSize:N,filterHeight:C,filterWidth:_,inChannels:F,inHeight:D,inWidth:$,outChannels:S,outHeight:M,outWidth:B,strideHeight:U,strideWidth:H}=m;h=m.dataFormat;let q=C-1-m.padInfo.top,K=_-1-m.padInfo.left,Z=h===\"channelsLast\",J=f.strides[0],ee=Z?f.strides[1]:f.strides[2],ae=Z?f.strides[2]:1,te=Z?1:f.strides[1],se=c[0],ie=Z?c[1]:c[2],ve=Z?c[2]:1,ue=Z?1:c[1];for(let ye=0;ye<N;++ye)for(let ke=0;ke<F;++ke)for(let Se=0;Se<D;++Se){let Le=Se-q,Ue=Math.max(0,Math.ceil(Le/U)),mt=Math.min(M,(C+Le)/U);for(let st=0;st<$;++st){let tt=st-K,nt=Math.max(0,Math.ceil(tt/H)),Re=Math.min(B,(_+tt)/H),gt=0;for(let Ot=Ue;Ot<mt;++Ot){let ia=Ot*U-Le;for(let un=nt;un<Re;++un){let Fn=un*H-tt,oa=se*ye+ie*Ot+ve*un,$n=x*(C-1-ia)+v*(_-1-Fn)+I*ke;for(let ut=0;ut<S;++ut){let Dn=b[oa+ue*ut],Hn=y[$n+ut];gt+=Dn*Hn}}}let Gn=J*ye+ee*Se+ae*st+te*ke;g[Gn]=gt}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}var RX={kernelName:Li,backendName:\"cpu\",kernelFunc:DX};function MX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a;ge([r,s],\"conv3d\");let u=T.computeConv3DInfo(r.shape,s.shape,i,l,o),{filterDepth:p,filterHeight:d,filterWidth:c,dilationDepth:h,dilationHeight:m,dilationWidth:f,padInfo:g}=u,b=g.front,y=g.left,x=g.top,v=new Wt(u.outShape,r.dtype),I=n.data.get(r.dataId).values,N=n.data.get(s.dataId).values,C=v.values,_=w.computeStrides(r.shape),F=w.computeStrides(s.shape);for(let D=0;D<u.batchSize;++D){let $=D*_[0],S=D*v.strides[0];for(let M=0;M<u.outDepth;++M){let B=S+M*v.strides[1],U=M*u.strideDepth-b;for(let H=0;H<p;++H){let q=U+H*h;if(q<0||q>=u.inDepth)continue;let K=H*F[0],Z=$+q*_[1];for(let J=0;J<u.outHeight;++J){let ee=B+J*v.strides[2],ae=J*u.strideHeight-x;for(let te=0;te<d;++te){let se=ae+te*m;if(se<0||se>=u.inHeight)continue;let ie=K+te*F[1],ve=Z+se*_[2];for(let ue=0;ue<u.outWidth;++ue){let ye=ee+ue*u.outChannels,ke=ue*u.strideWidth-y;for(let Se=0;Se<c;++Se){let Le=ke+Se*f;if(Le<0||Le>=u.inWidth)continue;let Ue=ie+Se*F[2],mt=ve+Le*u.inChannels,st=Ue;for(let tt=0;tt<u.inChannels;++tt){let nt=I[mt+tt];for(let Re=0;Re<u.outChannels;++Re)C[ye+Re]+=nt*N[st+Re];st+=u.outChannels}}}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var OX={kernelName:zi,backendName:\"cpu\",kernelFunc:MX};function PX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:l}=a;ge([r,s],\"conv3dBackpropFilterV2\");let u=w.computeStrides(r.shape),p=w.computeStrides(s.shape),d=T.computeConv3DInfo(r.shape,l,i,1,o),c=d.strideDepth,h=d.strideHeight,m=d.strideWidth,f=d.filterDepth,g=d.filterHeight,b=d.filterWidth,y=new Wt(d.filterShape,\"float32\"),x=y.values,[v,I,N,C]=y.strides,_=n.data.get(s.dataId).values,[F,D,$,S]=p,M=n.data.get(r.dataId).values,[B,U,H,q]=u,K=d.padInfo.front,Z=d.padInfo.left,J=d.padInfo.top;for(let ee=0;ee<f;++ee){let ae=Math.max(0,Math.ceil((K-ee)/c)),te=Math.min(d.outDepth,(d.inDepth+K-ee)/c),se=ee*v;for(let ie=0;ie<g;++ie){let ve=Math.max(0,Math.ceil((J-ie)/h)),ue=Math.min(d.outHeight,(d.inHeight+J-ie)/h),ye=ie*I+se;for(let ke=0;ke<b;++ke){let Se=Math.max(0,Math.ceil((Z-ke)/m)),Le=Math.min(d.outWidth,(d.inWidth+Z-ke)/m),Ue=ke*N+ye;for(let mt=0;mt<d.inChannels;++mt){let st=mt*C+Ue;for(let tt=0;tt<d.outChannels;++tt){let nt=0;for(let Re=0;Re<d.batchSize;++Re){let gt=Re*B,Gn=Re*F;for(let Ot=ae;Ot<te;++Ot){let ia=(ee+Ot*c-K)*U+gt,un=Ot*D+Gn;for(let Fn=ve;Fn<ue;++Fn){let oa=(ie+Fn*h-J)*H+ia,$n=Fn*$+un;for(let ut=Se;ut<Le;++ut){let Dn=(ke+ut*m-Z)*q+oa,Hn=ut*S+$n;nt+=M[Dn+mt]*_[Hn+tt]}}}}x[st+tt]=nt}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var LX={kernelName:iu,backendName:\"cpu\",kernelFunc:PX};function zX(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:l}=a;ge([r],\"conv3dBackpropInputV2\");let u=w.computeStrides(r.shape),p=w.computeStrides(s.shape),d=T.computeConv3DInfo(l,s.shape,o,1,i),c=new Wt(d.inShape,\"float32\"),h=c.values,[m,f,g,b]=c.strides,y=n.data.get(r.dataId).values,[x,v,I,N]=u,C=n.data.get(s.dataId).values,[_,F,D,$]=p,{batchSize:S,filterDepth:M,filterHeight:B,filterWidth:U,inChannels:H,inDepth:q,inHeight:K,inWidth:Z,outChannels:J,outDepth:ee,outHeight:ae,outWidth:te,strideDepth:se,strideHeight:ie,strideWidth:ve}=d,ue=M-1-d.padInfo.front,ye=B-1-d.padInfo.top,ke=U-1-d.padInfo.left;for(let Se=0;Se<S;++Se)for(let Le=0;Le<H;++Le)for(let Ue=0;Ue<q;++Ue){let mt=Ue-ue,st=Math.max(0,Math.ceil(mt/se)),tt=Math.min(ee,(M+mt)/se);for(let nt=0;nt<K;++nt){let Re=nt-ye,gt=Math.max(0,Math.ceil(Re/ie)),Gn=Math.min(ae,(B+Re)/ie);for(let Ot=0;Ot<Z;++Ot){let ia=Ot-ke,un=Math.max(0,Math.ceil(ia/ve)),Fn=Math.min(te,(U+ia)/ve),oa=0;for(let $n=st;$n<tt;++$n){let ut=$n*se-mt;for(let Dn=gt;Dn<Gn;++Dn){let Hn=Dn*ie-Re;for(let xr=un;xr<Fn;++xr){let ml=xr*ve-ia,Za=x*Se+v*$n+I*Dn+N*xr,Wp=_*(M-1-ut)+F*(B-1-Hn)+D*(U-1-ml)+$*Le;for(let Ia=0;Ia<J;++Ia){let Ur=y[Za+Ia],Jt=C[Wp+Ia];oa+=Ur*Jt}}}}h[m*Se+f*Ue+g*nt+b*Ot+Le]=oa}}}return n.makeTensorInfo(c.shape,c.dtype,c.values)}var WX={kernelName:ou,backendName:\"cpu\",kernelFunc:zX},BX=lt(Wi,e=>Math.cos(e)),VX={kernelName:Wi,backendName:\"cpu\",kernelFunc:BX},UX=lt(Bi,e=>Math.cosh(e)),GX={kernelName:Bi,backendName:\"cpu\",kernelFunc:UX};function HX(e){let{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=a,[p,d,c,h]=r.shape,m=s.shape[0],[f,g]=o,b=Oe([m,f,g,h],\"float32\"),y=n.data.get(s.dataId).values,x=n.data.get(i.dataId).values,v=n.data.get(r.dataId).values,I=w.computeStrides(r.shape),N=w.computeStrides(b.shape);for(let C=0;C<m;C++){let _=C*4,F=y[_],D=y[_+1],$=y[_+2],S=y[_+3],M=x[C];if(M>=p)continue;let B=f>1?($-F)*(d-1)/(f-1):0,U=g>1?(S-D)*(c-1)/(g-1):0;for(let H=0;H<f;H++){let q=f>1?F*(d-1)+H*B:.5*(F+$)*(d-1);if(q<0||q>d-1){for(let K=0;K<g;K++)for(let Z=0;Z<h;Z++){let J=Z+K*N[2]+H*N[1]+C*N[0];b.values[J]=u}continue}if(l===\"bilinear\"){let K=Math.floor(q),Z=Math.ceil(q),J=q-K;for(let ee=0;ee<g;ee++){let ae=g>1?D*(c-1)+ee*U:.5*(D+S)*(c-1);if(ae<0||ae>c-1){for(let ve=0;ve<h;ve++){let ue=ve+ee*N[2]+H*N[1]+C*N[0];b.values[ue]=u}continue}let te=Math.floor(ae),se=Math.ceil(ae),ie=ae-te;for(let ve=0;ve<h;ve++){let ue=ve+te*I[2]+K*I[1]+M*I[0],ye=v[ue];ue=ve+se*I[2]+K*I[1]+M*I[0];let ke=v[ue];ue=ve+te*I[2]+Z*I[1]+M*I[0];let Se=v[ue];ue=ve+se*I[2]+Z*I[1]+M*I[0];let Le=v[ue],Ue=ye+(ke-ye)*ie,mt=Se+(Le-Se)*ie;ue=ve+ee*N[2]+H*N[1]+C*N[0],b.values[ue]=Ue+(mt-Ue)*J}}}else for(let K=0;K<g;++K){let Z=g>1?D*(c-1)+K*U:.5*(D+S)*(c-1);if(Z<0||Z>c-1){for(let ae=0;ae<h;ae++){let te=ae+K*N[2]+H*N[1]+C*N[0];b.values[te]=u}continue}let J=Math.round(Z),ee=Math.round(q);for(let ae=0;ae<h;ae++){let te=ae+J*I[2]+ee*I[1]+M*I[0],se=ae+K*N[2]+H*N[1]+C*N[0];b.values[se]=v[te]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var jX={kernelName:uu,backendName:\"cpu\",kernelFunc:HX};function qX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;ge(r,\"cumprod\");let l=T.getAxesPermutation([s],r.shape.length),u=r;l!=null&&(u=Vn({inputs:{x:r},backend:n,attrs:{perm:l}}));let p=T.getInnerMostAxes(1,r.shape.length)[0];if(p!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${p}`);let d=fa(u.dtype,\"int32\"),c=w.makeOnesTypedArray(w.sizeFromShape(u.shape),d),h=n.data.get(u.dataId).values,m=u.shape[u.shape.length-1],f=o?(b,y)=>b+m-y-1:(b,y)=>b+y;for(let b=0;b<h.length;b+=m)for(let y=0;y<m;y++){let x=f(b,y);if(y===0)c[x]=i?1:h[x];else{let v=f(b,y-1);c[x]=i?h[v]*c[v]:h[x]*c[v]}}let g=n.makeTensorInfo(u.shape,d,c);if(l!=null){let b=T.getUndoAxesPermutation(l),y=Vn({inputs:{x:g},backend:n,attrs:{perm:b}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),y}return g}var KX={kernelName:lu,backendName:\"cpu\",kernelFunc:qX};function XX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;ge(r,\"cumsum\");let l=T.getAxesPermutation([s],r.shape.length),u=r;l!=null&&(u=Vn({inputs:{x:r},backend:n,attrs:{perm:l}}));let p=T.getInnerMostAxes(1,r.shape.length)[0];if(p!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${p}`);let d=fa(u.dtype,\"int32\"),c=w.makeZerosTypedArray(w.sizeFromShape(u.shape),d),h=n.data.get(u.dataId).values,m=u.shape[u.shape.length-1],f=o?(b,y)=>b+m-y-1:(b,y)=>b+y;for(let b=0;b<h.length;b+=m)for(let y=0;y<m;y++){let x=f(b,y);if(y===0)c[x]=i?0:h[x];else{let v=f(b,y-1);c[x]=i?h[v]+c[v]:h[x]+c[v]}}let g=n.makeTensorInfo(u.shape,d,c);if(l!=null){let b=T.getUndoAxesPermutation(l),y=Vn({inputs:{x:g},backend:n,attrs:{perm:b}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),y}return g}var YX={kernelName:Vi,backendName:\"cpu\",kernelFunc:XX};function ZX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i,binaryOutput:o}=a;if(r.shape.length===1){let l=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,p=P1(l,u,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,p)}else if(r.shape.length===2){let l=n.bufferSync(r),u=n.bufferSync(s),p=$E(l,u,i,o);return n.makeTensorInfo(p.shape,s.dtype,p.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}var JX={kernelName:Pc,backendName:\"cpu\",kernelFunc:ZX};function QX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:i}=a;w.assert(i===\"NHWC\",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let o=r.shape[0],l=r.shape[1],u=r.shape[2],p=r.shape[3],d=l*s,c=u*s,h=p/(s*s),m=n.data.get(r.dataId).values,f=new Float32Array(o*d*c*h),g=0;for(let b=0;b<o;++b)for(let y=0;y<d;++y){let x=Math.floor(y/s),v=y%s;for(let I=0;I<c;++I){let N=Math.floor(I/s),C=I%s,_=(v*s+C)*h;for(let F=0;F<h;++F){let D=F+_+p*(N+u*(x+l*b));f[g++]=m[D]}}}return n.makeTensorInfo([o,d,c,h],r.dtype,f)}var eY={kernelName:pu,backendName:\"cpu\",kernelFunc:QX};function N_(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=a;ge([r,s],\"depthwiseConv2DNative\");let p=w.computeStrides(r.shape),d=w.computeStrides(s.shape),c=l;c==null&&(c=[1,1]),w.assert(T.eitherStridesOrDilationsAreOne(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let h=T.computeConv2DInfo(r.shape,s.shape,i,c,o,u,!0),{filterHeight:m,filterWidth:f,dilationHeight:g,dilationWidth:b,padInfo:y}=h,x=y.left,v=y.top,I=h.outChannels/h.inChannels,N=new Wt(h.outShape,r.dtype),C=n.data.get(r.dataId).values,_=n.data.get(s.dataId).values,F=N.values;for(let D=0;D<h.batchSize;++D){let $=D*p[0],S=D*N.strides[0];for(let M=0;M<h.outHeight;++M){let B=S+M*N.strides[1],U=M*h.strideHeight-v;for(let H=0;H<m;++H){let q=U+H*g;if(q<0||q>=h.inHeight)continue;let K=H*d[0],Z=$+q*p[1];for(let J=0;J<h.outWidth;++J){let ee=B+J*N.strides[2],ae=J*h.strideWidth-x;for(let te=0;te<f;++te){let se=ae+te*b;if(se<0||se>=h.inWidth)continue;let ie=K+te*d[1],ve=Z+se*h.inChannels,ue=ee,ye=ie;for(let ke=0;ke<h.inChannels;++ke){let Se=C[ve+ke];for(let Le=0;Le<I;++Le)F[ue+Le]+=Se*_[ye+Le];ue+=I,ye+=I}}}}}}return n.makeTensorInfo(N.shape,N.dtype,N.values)}var tY={kernelName:Ui,backendName:\"cpu\",kernelFunc:N_};function nY(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:p}=a;ge([r,s],\"depthwiseConv2dNativeBackpropFilter\");let d=T.computeConv2DInfo(r.shape,p,i,o,l,u,!0),{strideHeight:c,strideWidth:h,filterHeight:m,filterWidth:f}=d,g=new Wt(d.filterShape,\"float32\"),b=d.padInfo.left,y=d.padInfo.top,x=d.outChannels/d.inChannels,v=n.data.get(r.dataId).values,I=new Wt(r.shape,r.dtype,v),N=n.data.get(s.dataId).values,C=new Wt(s.shape,s.dtype,N);for(let _=0;_<m;++_){let F=Math.max(0,Math.ceil((y-_)/c)),D=Math.min(d.outHeight,(d.inHeight+y-_)/c);for(let $=0;$<f;++$){let S=Math.max(0,Math.ceil((b-$)/h)),M=Math.min(d.outWidth,(d.inWidth+b-$)/h);for(let B=0;B<d.outChannels;++B){let U=Math.trunc(B/x),H=B%x,q=0;for(let K=0;K<d.batchSize;++K)for(let Z=F;Z<D;++Z){let J=_+Z*c-y;for(let ee=S;ee<M;++ee){let ae=$+ee*h-b;q+=I.get(K,J,ae,U)*C.get(K,Z,ee,B)}}g.set(q,_,$,U,H)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var aY={kernelName:Im,backendName:\"cpu\",kernelFunc:nY};function rY(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:p}=a;ge([r,s],\"depthwiseConv2DNativeBackpropInput\");let d=w.computeStrides(r.shape),c=w.computeStrides(s.shape),h=T.computeConv2DInfo(p,s.shape,i,o,l,u,!0),m=new Wt(h.inShape,\"float32\"),f=m.values,[g,b,y]=m.strides,x=n.data.get(r.dataId).values,[v,I,N]=d,C=n.data.get(s.dataId).values,[_,F,D]=c,{batchSize:$,filterHeight:S,filterWidth:M,inChannels:B,inHeight:U,inWidth:H,outChannels:q,outHeight:K,outWidth:Z,strideHeight:J,strideWidth:ee}=h,ae=S-1-h.padInfo.top,te=M-1-h.padInfo.left,se=q/B;for(let ie=0;ie<$;++ie)for(let ve=0;ve<B;++ve)for(let ue=0;ue<U;++ue){let ye=ue-ae,ke=Math.max(0,Math.ceil(ye/J)),Se=Math.min(K,(S+ye)/J);for(let Le=0;Le<H;++Le){let Ue=Le-te,mt=Math.max(0,Math.ceil(Ue/ee)),st=Math.min(Z,(M+Ue)/ee),tt=0;for(let nt=ke;nt<Se;++nt){let Re=nt*J-ye;for(let gt=mt;gt<st;++gt){let Gn=gt*ee-Ue,Ot=v*ie+I*nt+N*gt,ia=_*(S-1-Re)+F*(M-1-Gn)+D*ve;for(let un=0;un<se;++un){let Fn=ve*se+un,oa=x[Ot+Fn],$n=C[ia+un];tt+=oa*$n}}}f[g*ie+b*ue+y*Le+ve]=tt}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var sY={kernelName:Sm,backendName:\"cpu\",kernelFunc:rY};function iY(e){let{inputs:t,backend:n}=e,{x:a}=t,r=w.sizeFromShape(a.shape),s=n.data.get(a.dataId).values,i=Oe([r,r],a.dtype),o=i.values;for(let u=0;u<s.length;u++)o[u*r+u]=s[u];let l=[...a.shape,...a.shape];return n.makeTensorInfo(l,i.dtype,i.values)}var oY={kernelName:Lc,backendName:\"cpu\",kernelFunc:iY},lY={kernelName:Gi,backendName:\"cpu\",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:a,filter:r}=e,{strides:s,pad:i,dilations:o}=n,l=t,u=l.data.get(a.dataId).values,p=a.shape.length,d=l.data.get(r.dataId).values,c=r.shape.length,{batchSize:h,inHeight:m,inWidth:f,inChannels:g,outHeight:b,outWidth:y,padInfo:x,strideHeight:v,strideWidth:I,filterHeight:N,filterWidth:C,dilationHeight:_,dilationWidth:F,outShape:D}=T.computeDilation2DInfo(a.shape,r.shape,s,i,\"NHWC\",o),$=w.sizeFromShape(D),S=D.length,M=w.getArrayFromDType(a.dtype,$);for(let B=0;B<h;++B)for(let U=0;U<b;++U){let H=U*v-x.top;for(let q=0;q<y;++q){let K=q*I-x.left;for(let Z=0;Z<g;++Z){let J=Number.MIN_SAFE_INTEGER;for(let ae=0;ae<N;++ae){let te=H+ae*_;if(te>=0&&te<m)for(let se=0;se<C;++se){let ie=K+se*F;if(ie>=0&&ie<f){let ve=w.locToIndex([B,te,ie,Z],p,w.computeStrides(a.shape)),ue=w.locToIndex([ae,se,Z],c,w.computeStrides(r.shape)),ye=u[ve]+d[ue];ye>J&&(J=ye)}}}let ee=w.locToIndex([B,U,q,Z],S,w.computeStrides(D));M[ee]=J}}}return{dataId:l.write(w.toTypedArray(M,a.dtype),D,a.dtype),shape:D,dtype:a.dtype}}},uY={kernelName:Rl,backendName:\"cpu\",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:a,filter:r,dy:s}=e,{strides:i,pad:o,dilations:l}=n,u=t,p=w.toNestedArray(a.shape,u.data.get(a.dataId).values),d=w.toNestedArray(r.shape,u.data.get(r.dataId).values),{batchSize:c,inHeight:h,inWidth:m,inChannels:f,outHeight:g,outWidth:b,padInfo:y,strideHeight:x,strideWidth:v,filterHeight:I,filterWidth:N,dilationHeight:C,dilationWidth:_,outShape:F}=T.computeDilation2DInfo(a.shape,r.shape,i,o,\"NHWC\",l);w.assert(s.rank===F.length,()=>`Error in ${Rl}, dy must have the same rank as output ${F.length}, but got ${s.rank}`);let D=w.toNestedArray(F,u.data.get(s.dataId).values),$=w.makeZerosNestedTypedArray(r.shape,r.dtype);for(let S=0;S<c;++S)for(let M=0;M<g;++M){let B=M*x-y.top;for(let U=0;U<b;++U){let H=U*v-y.left;for(let q=0;q<f;++q){let K=Number.MIN_SAFE_INTEGER,Z=0,J=0;for(let ee=0;ee<I;++ee){let ae=B+ee*C;if(ae>=0&&ae<h)for(let te=0;te<N;++te){let se=H+te*_;if(se>=0&&se<m){let ie=p[S][ae][se][q]+d[ee][te][q];ie>K&&(K=ie,Z=ee,J=te)}}}$[Z][J][q]+=D[S][M][U][q]}}}return{dataId:u.write(w.toTypedArray($,a.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},pY={kernelName:Dl,backendName:\"cpu\",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:a,filter:r,dy:s}=e,{strides:i,pad:o,dilations:l}=n,u=t,p=w.toNestedArray(a.shape,u.data.get(a.dataId).values),d=w.toNestedArray(r.shape,u.data.get(r.dataId).values),{batchSize:c,inHeight:h,inWidth:m,inChannels:f,outHeight:g,outWidth:b,padInfo:y,strideHeight:x,strideWidth:v,filterHeight:I,filterWidth:N,dilationHeight:C,dilationWidth:_,outShape:F}=T.computeDilation2DInfo(a.shape,r.shape,i,o,\"NHWC\",l);w.assert(s.rank===F.length,()=>`Error in ${Dl}, dy must have the same rank as output ${F.length}, but got ${s.rank}`);let D=w.toNestedArray(F,u.data.get(s.dataId).values),$=w.makeZerosNestedTypedArray(a.shape,a.dtype);for(let S=0;S<c;++S)for(let M=0;M<g;++M){let B=M*x-y.top;for(let U=0;U<b;++U){let H=U*v-y.left;for(let q=0;q<f;++q){let K=Number.MIN_SAFE_INTEGER,Z=B<0?0:B,J=H<0?0:H;for(let ee=0;ee<I;++ee){let ae=B+ee*C;if(ae>=0&&ae<h)for(let te=0;te<N;++te){let se=H+te*_;if(se>=0&&se<m){let ie=p[S][ae][se][q]+d[ee][te][q];ie>K&&(K=ie,Z=ae,J=se)}}}$[S][Z][J][q]+=D[S][M][U][q]}}}return{dataId:u.write(w.toTypedArray($,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};function cY(e){let{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{canvas:s,options:i}=a,{contextOptions:o,imageOptions:l}=i||{},u=(l==null?void 0:l.alpha)||1,p=(o==null?void 0:o.contextType)||\"2d\";if(p!==\"2d\")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let d=s.getContext(p,(o==null?void 0:o.contextAttributes)||{});if(d==null)throw new Error(`Could not get the context with ${p} type.`);let[c,h]=r.shape.slice(0,2),m=r.shape.length===2?1:r.shape[2],f=n.data.get(r.dataId).values,g=r.dtype===\"float32\"?255:1,b=new Uint8ClampedArray(h*c*4);for(let x=0;x<c*h;++x){let v=[0,0,0,255*u];for(let N=0;N<m;N++){let C=f[x*m+N];if(r.dtype===\"float32\"){if(C<0||C>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${C}.`)}else if(r.dtype===\"int32\"&&(C<0||C>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${C}.`);m===1?(v[0]=C*g,v[1]=C*g,v[2]=C*g):v[N]=C*g}let I=x*4;b[I+0]=Math.round(v[0]),b[I+1]=Math.round(v[1]),b[I+2]=Math.round(v[2]),b[I+3]=Math.round(v[3])}s.width=h,s.height=c;let y=new ImageData(b,h,c);return d.putImageData(y,0,0),r}var dY={kernelName:Nm,backendName:\"cpu\",kernelFunc:cY};function Ed(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;ge(r,\"sum\");let o;r.dtype===\"bool\"?o=bs({inputs:{x:r},backend:n,attrs:{dtype:\"int32\"}}):o=cr({inputs:{x:r},backend:n});let l=o.shape.length,u=w.parseAxisParam(s,o.shape),p=T.getAxesPermutation(u,l),d=u,c=o;p!=null&&(c=Vn({inputs:{x:o},backend:n,attrs:{perm:p}}),d=T.getInnerMostAxes(d.length,l)),T.assertAxesAreInnerMostDims(\"sum\",d,c.shape.length);let[h,m]=T.computeOutAndReduceShapes(c.shape,d),f=T.upcastType(c.dtype,\"int32\"),g=lm(n,h,f),b=w.sizeFromShape(m),y=n.data.get(g.dataId).values,x=n.data.get(c.dataId).values;for(let v=0;v<y.length;++v){let I=v*b,N=0;for(let C=0;C<b;++C)N+=x[I+C];y[v]=N}if(i){let v=T.expandShapeToKeepDim(g.shape,u),I=g;g=xt({inputs:{x:g},backend:n,attrs:{shape:v}}),n.disposeIntermediateTensorInfo(I)}return n.disposeIntermediateTensorInfo(o),p!=null&&n.disposeIntermediateTensorInfo(c),g}var hY={kernelName:Lo,backendName:\"cpu\",kernelFunc:Ed};function mY(e){let{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,s=t,{allDims:i,summedDims:o,idDims:l}=T.decodeEinsumEquation(r,s.length);T.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:p}=T.getEinsumComputePath(o,l),d=p.length,c=null,h=i.length,m=[];for(let f=0;f<d;++f){for(let g of p[f]){let{permutationIndices:b,expandDims:y}=T.getEinsumPermutation(h,l[g]),x;T.isIdentityPermutation(b)?x=s[g]:(x=Vn({inputs:{x:s[g]},backend:n,attrs:{perm:b}}),m.push(x));let v=x.shape.slice();for(let I=0;I<y.length;++I)v.splice(y[I],0,1);w.arraysEqual(x.shape,v)||(x=xt({inputs:{x},backend:n,attrs:{shape:v}}),m.push(x)),c===null?c=x:(c=zf({inputs:{a:x,b:c},backend:n}),m.push(c))}f<d-1&&(u[f]>=0&&(c=Ed({inputs:{x:c},backend:n,attrs:{axis:u[f]-(i.length-h),keepDims:!1}}),m.push(c)),h--)}for(let f of m)f!==c&&n.disposeIntermediateTensorInfo(f);return c}var fY={kernelName:Tm,backendName:\"cpu\",kernelFunc:mY};function gY(e){let{inputs:t,backend:n}=e,{dy:a,y:r}=t;ge([a,r],\"eluGrad\");let s=new Float32Array(w.sizeFromShape(r.shape)),i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values;for(let l=0;l<i.length;++l){let u=i[l];u>=0?s[l]=o[l]:s[l]=o[l]*(u+1)}return n.makeTensorInfo(r.shape,\"float32\",s)}var bY={kernelName:cu,backendName:\"cpu\",kernelFunc:gY},yY=T.ERF_P,xY=T.ERF_A1,vY=T.ERF_A2,wY=T.ERF_A3,kY=T.ERF_A4,IY=T.ERF_A5,SY=lt(qi,e=>{let t=Math.sign(e),n=Math.abs(e),a=1/(1+yY*n);return t*(1-((((IY*a+kY)*a+wY)*a+vY)*a+xY)*a*Math.exp(-n*n))}),NY={kernelName:qi,backendName:\"cpu\",kernelFunc:SY};function cm(e){let{inputs:t,backend:n,attrs:a}=e,{input:r}=t,{dim:s}=a,i=r.shape.length,o=r.shape.slice(),l=s;return s<0&&(w.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),xt({inputs:{x:r},backend:n,attrs:{shape:o}})}var TY={kernelName:hu,backendName:\"cpu\",kernelFunc:cm},CY=Mt((e,t)=>e/t),X1=Zt(Hi,CY),lv={kernelName:Hi,backendName:\"cpu\",kernelFunc:X1};function T_(e,t,n){let a=e.shape,r=a[0],s=a[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[r,s],p=w.sizeFromShape(u),d=w.getTypedArrayFromDType(\"float32\",p),c=w.getTypedArrayFromDType(\"float32\",p);for(let g=0;g<r;g++){let b=xi({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,s]}}),y=xi({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,s]}}),x=Yn({inputs:{real:b,imag:y},backend:n}),{real:v,imag:I}=EY(x,t,n),N=T.mergeRealAndImagArrays(v,I);for(let C=0;C<s;C++){let _=T.getComplexWithIndex(N,C);d[g*s+C]=_.real,c[g*s+C]=_.imag}n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x)}let h=n.makeTensorInfo(u,\"float32\",d),m=n.makeTensorInfo(u,\"float32\",c),f=Yn({inputs:{real:h,imag:m},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),f}function EY(e,t,n){let a=w.sizeFromShape(e.shape),r=n.data.get(e.dataId),s=n.data.get(r.complexTensorInfos.real.dataId).values,i=n.data.get(r.complexTensorInfos.imag.dataId).values;if(_Y(a)){let o=uv(s,i,a,t,n),l=[e.shape[0],e.shape[1]];if(t){let u=n.makeTensorInfo(l,\"float32\",o.real),p=n.makeTensorInfo(l,\"float32\",o.imag),d=n.makeTensorInfo([],\"float32\",w.createScalarValue(a,\"float32\")),c=cr({inputs:{x:d},backend:n}),h=lv.kernelFunc({inputs:{a:u,b:d},backend:n}),m=lv.kernelFunc({inputs:{a:p,b:c},backend:n}),f=n.data.get(h.dataId).values,g=n.data.get(m.dataId).values;return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),{real:f,imag:g}}return o}else{let o=T.mergeRealAndImagArrays(s,i),l=AY(o,a,t);return T.splitRealAndImagArrays(l)}}function _Y(e){return(e&e-1)===0}function uv(e,t,n,a,r){if(n===1)return{real:e,imag:t};let s=T.mergeRealAndImagArrays(e,t),i=n/2,o=T.complexWithEvenIndex(s),l=o.real,u=o.imag,p=[l.length],d=r.makeTensorInfo(p,\"float32\",l),c=r.makeTensorInfo(p,\"float32\",u),h=Yn({inputs:{real:d,imag:c},backend:r}),m=T.complexWithOddIndex(s),f=m.real,g=m.imag,b=[f.length],y=r.makeTensorInfo(b,\"float32\",f),x=r.makeTensorInfo(b,\"float32\",g),v=Yn({inputs:{real:y,imag:x},backend:r}),I=uv(l,u,i,a,r),N=I.real,C=I.imag,_=[N.length],F=r.makeTensorInfo(_,\"float32\",N),D=r.makeTensorInfo(_,\"float32\",C),$=Yn({inputs:{real:F,imag:D},backend:r}),S=uv(f,g,i,a,r),M=S.real,B=S.imag,U=[M.length],H=r.makeTensorInfo(U,\"float32\",M),q=r.makeTensorInfo(U,\"float32\",B),K=Yn({inputs:{real:H,imag:q},backend:r}),Z=T.exponents(n,a),J=[Z.real.length],ee=r.makeTensorInfo(J,\"float32\",Z.real),ae=r.makeTensorInfo(J,\"float32\",Z.imag),te=Yn({inputs:{real:ee,imag:ae},backend:r}),se=zf({inputs:{a:te,b:K},backend:r}),ie=jl({inputs:{a:$,b:se},backend:r}),ve=j1({inputs:{a:$,b:se},backend:r}),ue=yi({inputs:{input:ie},backend:r}),ye=yi({inputs:{input:ve},backend:r}),ke=ql({inputs:{input:ie},backend:r}),Se=ql({inputs:{input:ve},backend:r}),Le=Kl({inputs:[ue,ye],backend:r,attrs:{axis:0}}),Ue=Kl({inputs:[ke,Se],backend:r,attrs:{axis:0}}),mt=r.data.get(Le.dataId).values,st=r.data.get(Ue.dataId).values;return r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo($),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(K),r.disposeIntermediateTensorInfo(ee),r.disposeIntermediateTensorInfo(ae),r.disposeIntermediateTensorInfo(te),r.disposeIntermediateTensorInfo(se),r.disposeIntermediateTensorInfo(ie),r.disposeIntermediateTensorInfo(ve),r.disposeIntermediateTensorInfo(ue),r.disposeIntermediateTensorInfo(ke),r.disposeIntermediateTensorInfo(ye),r.disposeIntermediateTensorInfo(Se),r.disposeIntermediateTensorInfo(Le),r.disposeIntermediateTensorInfo(Ue),{real:mt,imag:st}}function AY(e,t,n){let a=new Float32Array(t*2);for(let r=0;r<t;r++){let s=0,i=0;for(let o=0;o<t;o++){let l=T.exponent(r*o,t,n),u=T.getComplexWithIndex(e,o);s+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}n&&(s/=t,i/=t),T.assignToTypedArray(a,s,i,r)}return a}function FY(e){let{inputs:t,backend:n}=e,{input:a}=t,r=w.sizeFromShape(a.shape),s=a.shape[a.shape.length-1],i=r/s,o=xt({inputs:{x:a},backend:n,attrs:{shape:[i,s]}}),l=T_(o,!1,n),u=xt({inputs:{x:l},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var $Y={kernelName:Cm,backendName:\"cpu\",kernelFunc:FY};function Y1(e){let{backend:t,attrs:n}=e,{shape:a,value:r,dtype:s}=n,i=s||w.inferDtype(r),o=w.getArrayFromDType(i,w.sizeFromShape(a));return RY(o,r,i),t.makeTensorInfo(a,i,o)}var DY={kernelName:zc,backendName:\"cpu\",kernelFunc:Y1};function RY(e,t,n){e.fill(t)}var MY={kernelName:mu,backendName:\"cpu\",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:a}=e,r=n,s=w.getTypedArrayFromDType(a.dtype,w.sizeFromShape(a.shape)),[i,o,l,u]=a.shape,p=r.data.get(a.dataId).values;for(let d=0;d<i;d++){let c=d*l*o*u;for(let h=0;h<o;h++){let m=h*(l*u);for(let f=0;f<l;f++){let g=f*u;for(let b=0;b<u;b++){let y=Math.round(l-f-1),x=c+m+g+b,v=p[x];if(y>=0&&y<l){let I=y*u,N=c+m+I+b;v=p[N]}s[x]=v}}}}return{dataId:r.write(s,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};function OY(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:p,dilations:d,dimRoundingMode:c,activation:h,leakyreluAlpha:m}=a,f=S_({inputs:{x:r,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:p,dilations:d,dimRoundingMode:c}});if(i){let g=f;if(p===\"NCHW\"&&i.shape.length===1&&i.shape[0]!==1){let b=xt({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});f=jl({inputs:{a:f,b},backend:n}),n.disposeIntermediateTensorInfo(b)}else f=jl({inputs:{a:f,b:i},backend:n});n.disposeIntermediateTensorInfo(g)}if(h){let g=f;if(p===\"NCHW\"&&h===\"prelu\"&&o.shape.length===1&&o.shape[0]!==1){let b=xt({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});f=pm(n,f,h,b,m),n.disposeIntermediateTensorInfo(b)}else f=pm(n,f,h,o,m);n.disposeIntermediateTensorInfo(g)}return f}var PY={kernelName:oi,backendName:\"cpu\",kernelFunc:OY};function LY(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:p,dilations:d,dimRoundingMode:c,activation:h,leakyreluAlpha:m}=a,f=N_({inputs:{x:r,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:p,dilations:d,dimRoundingMode:c}});if(i){let g=f;f=jl({inputs:{a:f,b:i},backend:n}),n.disposeIntermediateTensorInfo(g)}if(h){let g=f;f=pm(n,f,h,o,m),n.disposeIntermediateTensorInfo(g)}return f}var zY={kernelName:li,backendName:\"cpu\",kernelFunc:LY};function WY(e){let{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=w.sizeFromShape(a.shape),i=r.shape,o=i[i.length-1],[l,u,p,d]=T.prepareAndValidate(a,r);if(u===0)return n.makeTensorInfo(l,a.dtype,[]);let c=n.data.get(r.dataId).values,h=n.bufferSync(a),m=VE(c,h,a.dtype,u,o,p,d,a.shape,s);return n.makeTensorInfo(l,a.dtype,m.values)}var BY={kernelName:gu,backendName:\"cpu\",kernelFunc:WY};function VY(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:i,batchDims:o}=a;ge([r,s],\"gatherV2\");let l=w.parseAxisParam(i,r.shape)[0],u=n.data.get(s.dataId).values,p=r.shape[l];for(let v=0;v<u.length;++v){let I=u[v];w.assert(I<=p-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${p-1}]`)}let d=o;o==null&&(d=0);let c=w.sizeFromShape(s.shape),h=T.segment_util.collectGatherOpShapeInfo(r,s,l,d),m=xt({inputs:{x:r},backend:n,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),f=xt({inputs:{x:s},backend:n,attrs:{shape:[h.batchSize,c/h.batchSize]}}),g=[h.batchSize,h.outerSize,c/h.batchSize,h.sliceSize],b=n.bufferSync(f),y=n.bufferSync(m),x=UE(y,b,g);return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(f),n.makeTensorInfo(h.outputShape,x.dtype,x.values)}var UY={kernelName:fu,backendName:\"cpu\",kernelFunc:VY};function GY(e){let{inputs:t,backend:n}=e,{input:a}=t,r=w.sizeFromShape(a.shape),s=a.shape[a.shape.length-1],i=r/s,o=xt({inputs:{x:a},backend:n,attrs:{shape:[i,s]}}),l=T_(o,!0,n),u=xt({inputs:{x:l},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var HY={kernelName:Em,backendName:\"cpu\",kernelFunc:GY},jY=lt(to,e=>Number.isFinite(e)?1:0,\"bool\"),qY={kernelName:to,backendName:\"cpu\",kernelFunc:jY},KY=lt(no,e=>Math.abs(e)===1/0?1:0,\"bool\"),XY={kernelName:no,backendName:\"cpu\",kernelFunc:KY},YY=lt(ao,e=>Number.isNaN(e)?1:0,\"bool\"),ZY={kernelName:ao,backendName:\"cpu\",kernelFunc:YY};function JY(e){let{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,i=KE(a,r,s);return t.makeTensorInfo([i.length],\"float32\",i)}var QY={kernelName:vu,backendName:\"cpu\",kernelFunc:JY},e7=lt(io,e=>Math.log1p(e)),t7={kernelName:io,backendName:\"cpu\",kernelFunc:e7},n7=Mt((e,t)=>e&&t),a7=Zt(wu,n7,null,\"bool\"),r7={kernelName:wu,backendName:\"cpu\",kernelFunc:a7},s7=lt(ku,e=>e?0:1,\"bool\"),i7={kernelName:ku,backendName:\"cpu\",kernelFunc:s7},o7=Mt((e,t)=>e||t),l7=Zt(Iu,o7,null,\"bool\"),u7={kernelName:Iu,backendName:\"cpu\",kernelFunc:l7};function p7(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=a;ge(r,\"LRN\");let u=r.shape[3],p=u-1,d=n.data.get(r.dataId).values,c=w.sizeFromShape(r.shape),h=new Float32Array(c);function m(f){let g=f%u,b=f-g+Math.max(0,g-s),y=f-g+Math.min(g+s,p),x=0;for(;b<=y;b++){let v=d[b];x+=v*v}return x}for(let f=0;f<c;f++){let g=m(f),b=d[f]*Math.pow(i+o*g,-l);h[f]=b}return n.makeTensorInfo(r.shape,r.dtype,h)}var c7={kernelName:oo,backendName:\"cpu\",kernelFunc:p7};function d7(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:p}=a;ge(i,\"LRNGrad\");let d=w.sizeFromShape(i.shape),c=i.shape[3],h=n.data.get(i.dataId).values,m=n.data.get(r.dataId).values,f=n.data.get(s.dataId).values,g=new Float32Array(d),b=d;for(let y=0;y<b;y++){let x=y%c,v=y-x+Math.max(0,x-o),I=y-x+Math.min(c,x+o+1),N=0;for(let C=v;C<I;C++)N+=Math.pow(m[C],2);N=u*N+l;for(let C=v;C<I;C++){let _=-2*u*p*m[C]*f[y]/N;y===C&&(_+=Math.pow(N,-p)),_*=h[y],g[C]+=_}}return n.makeTensorInfo(i.shape,r.dtype,g)}var h7={kernelName:Su,backendName:\"cpu\",kernelFunc:d7};function C_(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:i}=a,o=n,l=r.shape,u=l.length,p=w.parseAxisParam(s,l),d=p,c=T.getAxesPermutation(d,u),h=o.data.get(r.dataId).values;if(c!=null){let v=new Array(u);for(let I=0;I<v.length;I++)v[I]=l[c[I]];h=W1(h,l,r.dtype,c,v),d=T.getInnerMostAxes(d.length,u),l=v}ge(r,\"max\"),T.assertAxesAreInnerMostDims(\"max\",d,u);let[m,f]=T.computeOutAndReduceShapes(l,d),g=w.sizeFromShape(f),b=YE(h,g,m,r.dtype),y=o.write(b,m,r.dtype),x=m;return i&&(x=T.expandShapeToKeepDim(m,p)),{dataId:y,shape:x,dtype:r.dtype}}var m7={kernelName:lo,backendName:\"cpu\",kernelFunc:C_};function f7(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;ge(r,\"maxPool\");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=a,u=1;w.assert(T.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let p=T.computePool2DInfo(r.shape,s,i,u,o,l),d;if(p.filterWidth===1&&p.filterHeight===1&&w.arraysEqual(p.inShape,p.outShape))d=cr({inputs:{x:r},backend:n});else{let c=n.data.get(r.dataId).values,h=w.computeStrides(r.shape),m=K1(c,r.shape,r.dtype,h,p,\"max\");d=n.makeTensorInfo(p.outShape,r.dtype,m.values)}return d}var g7={kernelName:po,backendName:\"cpu\",kernelFunc:f7};function b7(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=a;ge(r,\"maxPool3d\");let p=T.computePool3DInfo(r.shape,s,i,1,o,l,u),d=n.data.get(r.dataId).values,c=I_(d,r.shape,r.dtype,w.computeStrides(r.shape),p,\"max\");return n.makeTensorInfo(c.shape,\"float32\",c.values)}var y7={kernelName:Nu,backendName:\"cpu\",kernelFunc:b7};function x7(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=a;ge([r,s],\"maxPool3DGrad\");let p=T.computePool3DInfo(s.shape,i,o,1,l,u),d=n.bufferSync(s),c=oX(d,p),h=p.strideDepth,m=p.strideHeight,f=p.strideWidth,g=p.dilationDepth,b=p.dilationHeight,y=p.dilationWidth,x=p.effectiveFilterDepth,v=p.effectiveFilterHeight,I=p.effectiveFilterWidth,N=x-1-p.padInfo.front,C=I-1-p.padInfo.left,_=v-1-p.padInfo.top,F=Oe(s.shape,\"float32\"),D=n.bufferSync(r);for(let $=0;$<p.batchSize;++$)for(let S=0;S<p.inChannels;++S)for(let M=0;M<p.inDepth;++M)for(let B=0;B<p.inHeight;++B)for(let U=0;U<p.inWidth;++U){let H=M-N,q=B-_,K=U-C,Z=0;for(let J=0;J<x;J+=g){let ee=(H+J)/h;if(!(ee<0||ee>=p.outDepth||Math.floor(ee)!==ee))for(let ae=0;ae<v;ae+=b){let te=(q+ae)/m;if(!(te<0||te>=p.outHeight||Math.floor(te)!==te))for(let se=0;se<I;se+=y){let ie=(K+se)/f;if(ie<0||ie>=p.outWidth||Math.floor(ie)!==ie)continue;let ve=x*v*I-1-c.get($,ee,te,ie,S),ue=J*v*I+ae*I+se,ye=ve===ue?1:0;if(ye===0)continue;let ke=D.get($,ee,te,ie,S);Z+=ke*ye}}}F.set(Z,$,M,B,U,S)}return n.makeTensorInfo(F.shape,F.dtype,F.values)}var v7={kernelName:Bc,backendName:\"cpu\",kernelFunc:x7};function w7(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s,output:i}=t,o=s;ge([s,i],\"maxPoolGrad\");let{filterSize:l,strides:u,pad:p,dimRoundingMode:d}=a,c=T.computePool2DInfo(o.shape,l,u,1,p,d),h=n.data.get(o.dataId).values,m=Oe(c.outShape,o.dtype,k_(h,o.shape,o.dtype,c).values),f=c.strideHeight,g=c.strideWidth,b=c.dilationHeight,y=c.dilationWidth,x=c.effectiveFilterHeight,v=c.effectiveFilterWidth,I=v-1-c.padInfo.left,N=x-1-c.padInfo.top,C=Oe(o.shape,\"float32\"),_=n.data.get(r.dataId).values,F=Oe(r.shape,\"float32\",_);for(let D=0;D<c.batchSize;++D)for(let $=0;$<c.inChannels;++$)for(let S=0;S<c.inHeight;++S)for(let M=0;M<c.inWidth;++M){let B=S-N,U=M-I,H=0;for(let q=0;q<x;q+=b){let K=(B+q)/f;if(!(K<0||K>=c.outHeight||Math.floor(K)!==K))for(let Z=0;Z<v;Z+=y){let J=(U+Z)/g;if(J<0||J>=c.outWidth||Math.floor(J)!==J)continue;let ee=x*v-1-m.get(D,K,J,$),ae=q*v+Z,te=ee===ae?1:0;if(te===0)continue;let se=F.get(D,K,J,$);H+=se*te}}C.set(H,D,S,M,$)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}var k7={kernelName:Wc,backendName:\"cpu\",kernelFunc:w7};function I7(e,t,n,a,r){let s=w.computeStrides(t),i=K1(e,t,n,s,r,\"max\"),o=k_(e,t,n,r,!0,a);return[i.values,o.values]}var S7={kernelName:Vc,backendName:\"cpu\",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:a}=e,{filterSize:r,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;ge(a,\"MaxPoolWithArgmax\");let u=l.data.get(a.dataId).values,p=T.computePool2DInfo(a.shape,r,s,[1,1],i),[d,c]=I7(u,a.shape,a.dtype,o,p),h=l.write(d,p.outShape,a.dtype),m=l.write(c,p.outShape,a.dtype);return[{dataId:h,shape:p.outShape,dtype:a.dtype},{dataId:m,shape:p.outShape,dtype:\"int32\"}]}};function N7(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=w.parseAxisParam(s,r.shape),l=T.computeOutAndReduceShapes(r.shape,o)[1],u=w.sizeFromShape(l),p=[],d=n.makeTensorInfo([],\"float32\",new Float32Array([u]));p.push(d);let c=bs({inputs:{x:r},backend:n,attrs:{dtype:\"float32\"}});p.push(c);let h=X1({inputs:{a:c,b:d},backend:n});p.push(h);let m=Ed({inputs:{x:h},backend:n,attrs:{axis:s,keepDims:i}});return p.forEach(f=>n.disposeIntermediateTensorInfo(f)),m}var T7={kernelName:co,backendName:\"cpu\",kernelFunc:N7};function C7(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;ge(r,\"min\");let o=w.parseAxisParam(s,r.shape),l=o,u=T.getAxesPermutation(l,r.shape.length),p=r;u!=null&&(p=Vn({inputs:{x:r},backend:n,attrs:{perm:u}}),l=T.getInnerMostAxes(l.length,r.shape.length)),T.assertAxesAreInnerMostDims(\"min\",l,p.shape.length);let[d,c]=T.computeOutAndReduceShapes(p.shape,l),h=w.sizeFromShape(c),m=w.makeZerosTypedArray(w.sizeFromShape(d),p.dtype),f=n.data.get(p.dataId).values;for(let b=0;b<m.length;++b){let y=b*h,x=f[y];for(let v=0;v<h;++v){let I=f[y+v];(Number.isNaN(I)||I<x)&&(x=I)}m[b]=x}u!=null&&n.disposeIntermediateTensorInfo(p);let g=n.makeTensorInfo(d,p.dtype,m);if(i){let b=T.expandShapeToKeepDim(d,o),y=xt({inputs:{x:g},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(g),y}return g}var E7={kernelName:ho,backendName:\"cpu\",kernelFunc:C7};function _7(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,mode:i}=a;ge(r,\"mirrorPad\");let o=s.map((y,x)=>y[0]+r.shape[x]+y[1]),l=s.map(y=>y[0]),u=s.map((y,x)=>y[0]+r.shape[x]),p=i===\"reflect\"?0:1,d=n.data.get(r.dataId).values,c=r.shape.length,h=w.computeStrides(r.shape),m=w.sizeFromShape(o),f=o.length,g=w.computeStrides(o),b=w.getTypedArrayFromDType(r.dtype,m);for(let y=0;y<m;y++){let x=w.indexToLoc(y,f,g);for(let I=0;I<f;I++)x[I]<l[I]?x[I]=l[I]*2-x[I]-p:x[I]>=u[I]&&(x[I]=(u[I]-1)*2-x[I]+p);x=x.map((I,N)=>I-l[N]);let v=w.locToIndex(x,c,h);b[y]=d[v]}return{dataId:n.write(b,o,r.dtype),shape:o,dtype:r.dtype}}var A7={kernelName:fo,backendName:\"cpu\",kernelFunc:_7},F7=Mt((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),$7=Zt(go,F7),D7={kernelName:go,backendName:\"cpu\",kernelFunc:$7},R7=xs(bm());function E_(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,i=r.shape.length,o=s;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let l=w.parseAxisParam([o],r.shape),u=C_({inputs:{x:r},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),p=T.expandShapeToKeepDim(u.shape,l),d=xt({inputs:{x:u},backend:n,attrs:{shape:p}}),c=j1({inputs:{a:r,b:d},backend:n}),h=LE({inputs:{x:c},backend:n}),m=Ed({inputs:{x:h},backend:n,attrs:{axis:l,keepDims:!1}}),f=xt({inputs:{x:m},backend:n,attrs:{shape:p}}),g=X1({inputs:{a:h,b:f},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(f),g}var M7={kernelName:zo,backendName:\"cpu\",kernelFunc:E_};function O7(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=a;ge(r,\"multinomial\");let l=o?r:E_({inputs:{logits:r},backend:n,attrs:{dim:-1}}),u=l.shape[0],p=l.shape[1],d=n.data.get(l.dataId).values,c=[u,s],h=w.makeZerosTypedArray(w.sizeFromShape(c),\"int32\");for(let m=0;m<u;++m){let f=m*p,g=new Float32Array(p-1);g[0]=d[f];for(let x=1;x<g.length;++x)g[x]=g[x-1]+d[f+x];let b=R7.alea(i.toString()),y=m*s;for(let x=0;x<s;++x){let v=b();h[y+x]=g.length;for(let I=0;I<g.length;I++)if(v<g[I]){h[y+x]=I;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(c,\"int32\",h)}var P7={kernelName:Tu,backendName:\"cpu\",kernelFunc:O7},L7=mr.nonMaxSuppressionV3Impl;function z7(e){let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=a;ge(r,\"NonMaxSuppression\");let u=n.data.get(r.dataId).values,p=n.data.get(s.dataId).values,{selectedIndices:d}=L7(u,p,i,o,l);return n.makeTensorInfo([d.length],\"int32\",new Int32Array(d))}var W7={kernelName:_u,backendName:\"cpu\",kernelFunc:z7},B7=mr.nonMaxSuppressionV4Impl;function V7(e){let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=a;ge(r,\"NonMaxSuppressionPadded\");let p=n.data.get(r.dataId).values,d=n.data.get(s.dataId).values,{selectedIndices:c,validOutputs:h}=B7(p,d,i,o,l,u);return[n.makeTensorInfo([c.length],\"int32\",new Int32Array(c)),n.makeTensorInfo([],\"int32\",new Int32Array([h]))]}var U7={kernelName:Au,backendName:\"cpu\",kernelFunc:V7},G7=mr.nonMaxSuppressionV5Impl;function H7(e){let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=a;ge(r,\"NonMaxSuppressionWithScore\");let p=n.data.get(r.dataId).values,d=n.data.get(s.dataId).values,c=i,h=o,m=l,f=u,{selectedIndices:g,selectedScores:b}=G7(p,d,c,h,m,f);return[n.makeTensorInfo([g.length],\"int32\",new Int32Array(g)),n.makeTensorInfo([b.length],\"float32\",new Float32Array(b))]}var j7={kernelName:Fu,backendName:\"cpu\",kernelFunc:H7};function q7(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:l}=a;ge(r,\"oneHot\");let u=w.sizeFromShape(r.shape),p=new Float32Array(u*i);p.fill(l);let d=n.data.get(r.dataId).values;for(let c=0;c<u;++c)d[c]>=0&&d[c]<i&&(p[c*i+d[c]]=o);return n.makeTensorInfo([...r.shape,i],s,p)}var K7={kernelName:yo,backendName:\"cpu\",kernelFunc:q7};function dm(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype===\"string\")throw new Error(\"zerosLike is not supported for string tensors\");if(a.dtype===\"complex64\"){let r=yi({inputs:{input:a},backend:n}),s=dm({inputs:{x:r},backend:n}),i=ql({inputs:{input:a},backend:n}),o=dm({inputs:{x:i},backend:n}),l=Yn({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return Y1({backend:n,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}var X7={kernelName:Yu,backendName:\"cpu\",kernelFunc:dm};function __(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype===\"string\")throw new Error(\"onesLike is not supported for string tensors\");if(a.dtype===\"complex64\"){let r=yi({inputs:{input:a},backend:n}),s=__({inputs:{x:r},backend:n}),i=ql({inputs:{input:a},backend:n}),o=dm({inputs:{x:i},backend:n}),l=Yn({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return Y1({backend:n,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}var Y7={kernelName:$u,backendName:\"cpu\",kernelFunc:__};function A_(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(t.length===1)return cm({inputs:{input:t[0]},backend:n,attrs:{dim:r}});let s=t[0].shape,i=t[0].dtype;t.forEach(p=>{w.assertShapesMatch(s,p.shape,\"All tensors passed to stack must have matching shapes\"),w.assert(i===p.dtype,()=>\"All tensors passed to stack must have matching dtypes\")});let o=[],l=t.map(p=>{let d=cm({inputs:{input:p},backend:n,attrs:{dim:r}});return o.push(d),d}),u=Kl({inputs:l,backend:n,attrs:{axis:r}});return o.forEach(p=>n.disposeIntermediateTensorInfo(p)),u}var Z7={kernelName:Du,backendName:\"cpu\",kernelFunc:A_};function J7(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:i}=a;ge(r,\"pad\");let o=s.map((b,y)=>b[0]+r.shape[y]+b[1]),l=s.map(b=>b[0]),u=n.data.get(r.dataId).values,p=w.sizeFromShape(r.shape),d=r.shape.length,c=w.computeStrides(r.shape),h=w.sizeFromShape(o),m=o.length,f=w.computeStrides(o),g=w.getTypedArrayFromDType(r.dtype,h);i!==0&&g.fill(i);for(let b=0;b<p;b++){let y=w.indexToLoc(b,d,c).map((v,I)=>v+l[I]),x=w.locToIndex(y,m,f);g[x]=u[b]}return{dataId:n.write(g,o,r.dtype),shape:o,dtype:r.dtype}}var F_={kernelName:xo,backendName:\"cpu\",kernelFunc:J7},Q7=Mt((e,t)=>Math.pow(e,t)),eZ=Zt(vo,Q7),tZ={kernelName:vo,backendName:\"cpu\",kernelFunc:eZ};function nZ(e){let{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=a,l=r.map(b=>n.data.get(b.dataId).values),u=r.map(b=>b.shape),p=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,[c,h,m]=n_(l,u,p,s.shape,s.dtype,d,i.shape,o),f=c.map(b=>n.makeTensorInfo([b.length],\"int32\",b)),g=n.makeTensorInfo(m,s.dtype,h);return f.concat([g])}var aZ={kernelName:Am,backendName:\"cpu\",kernelFunc:nZ};function rZ(e){let{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:s}=t,i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[u,p]=a_(i,a.shape,a.dtype,o,r.shape,l,s.shape),d=n.makeTensorInfo([u.length],\"int32\",u),c=n.makeTensorInfo([p.length],a.dtype,p);return[d,c]}var sZ={kernelName:Fm,backendName:\"cpu\",kernelFunc:rZ};function iZ(e){let{inputs:t,backend:n,attrs:a}=e,{shape:r,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=a,u=n.data.get(r.dataId).values,p=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,c=o.map(g=>n.data.get(g.dataId).values),h=o.map(g=>g.shape),[m,f]=r_(u,r.shape,p,s.shape,s.dtype,d,i.shape,c,h,l);return n.makeTensorInfo(m,s.dtype,f)}var oZ={kernelName:$m,backendName:\"cpu\",kernelFunc:iZ};function lZ(e){let{backend:t,attrs:n}=e,{start:a,stop:r,dtype:s,step:i}=n,o=B1(a,r,i,s);return t.makeTensorInfo([o.length],s,o)}var uZ={kernelName:Uc,backendName:\"cpu\",kernelFunc:lZ},pZ=lt(Io,e=>1/e),cZ={kernelName:Io,backendName:\"cpu\",kernelFunc:pZ};function dZ(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a;ge(r,\"resizeBilinear\");let l=w.computeStrides(r.shape),[u,p]=o,[d,c,h,m]=r.shape,f=n.data.get(r.dataId).values,g=new Float32Array(w.sizeFromShape([d,u,p,m])),b=[s&&u>1?c-1:c,s&&p>1?h-1:h],y=[s&&u>1?u-1:u,s&&p>1?p-1:p],x=0,v=b[0]/y[0],I=b[1]/y[1];for(let N=0;N<d;N++)for(let C=0;C<u;C++){let _;i?_=v*(C+.5)-.5:_=v*C;let F=Math.max(0,Math.floor(_)),D=_-F,$=Math.min(c-1,Math.ceil(_)),S=N*l[0]+F*l[1],M=N*l[0]+$*l[1];for(let B=0;B<p;B++){let U;i?U=I*(B+.5)-.5:U=I*B;let H=Math.max(0,Math.floor(U)),q=U-H,K=Math.min(h-1,Math.ceil(U)),Z=S+H*l[2],J=M+H*l[2],ee=S+K*l[2],ae=M+K*l[2];for(let te=0;te<m;te++){let se=f[Z+te],ie=f[J+te],ve=f[ee+te],ue=f[ae+te],ye=se+(ve-se)*q,ke=ie+(ue-ie)*q,Se=ye+(ke-ye)*D;g[x++]=Se}}}return n.makeTensorInfo([d,u,p,m],\"float32\",g)}var hZ={kernelName:To,backendName:\"cpu\",kernelFunc:dZ};function mZ(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a;ge([s,r],\"resizeBilinearGrad\");let o=w.computeStrides(r.shape),[l,u,p,d]=r.shape,[,c,h]=s.shape,m=new Float32Array(l*u*p*d),f=[i&&c>1?u-1:u,i&&h>1?p-1:p],g=[i&&c>1?c-1:c,i&&h>1?h-1:h],b=f[0]/g[0],y=f[1]/g[1],x=n.data.get(s.dataId).values,v=0;for(let I=0;I<l;I++){let N=I*o[0];for(let C=0;C<c;C++){let _=C*b,F=Math.floor(_),D=Math.min(Math.ceil(_),u-1),$=N+F*o[1],S=N+D*o[1],M=_-F,B=1-M;for(let U=0;U<h;U++){let H=U*y,q=Math.floor(H),K=Math.min(Math.ceil(H),p-1),Z=H-q,J=1-Z,ee=$+q*o[2],ae=$+K*o[2],te=S+q*o[2],se=S+K*o[2],ie=B*J,ve=B*Z,ue=M*J,ye=M*Z;for(let ke=0;ke<d;ke++){let Se=x[v++];m[ee+ke]+=Se*ie,m[ae+ke]+=Se*ve,m[te+ke]+=Se*ue,m[se+ke]+=Se*ye}}}}return n.makeTensorInfo([l,p,u,d],\"float32\",m)}var fZ={kernelName:Ou,backendName:\"cpu\",kernelFunc:mZ};function gZ(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a;ge(r,\"resizeNearestNeighbor\");let l=w.computeStrides(r.shape),[u,p]=o,[d,c,h,m]=r.shape,f=n.data.get(r.dataId).values,g=new Float32Array(d*u*p*m),b=[s&&u>1?c-1:c,s&&p>1?h-1:h],y=[s&&u>1?u-1:u,s&&p>1?p-1:p],x=b[0]/y[0],v=b[1]/y[1],I=0;for(let N=0;N<d;N++){let C=N*l[0];for(let _=0;_<u;_++){let F=i?x*(_+.5):x*_,D=Math.min(c-1,s?Math.round(F):Math.floor(F));i&&(D=Math.max(0,D));let $=C+D*l[1];for(let S=0;S<p;S++){let M=i?v*(S+.5):v*S,B=Math.min(h-1,s?Math.round(M):Math.floor(M));i&&(B=Math.max(0,B));let U=$+B*l[2];for(let H=0;H<m;H++){let q=f[U+H];g[I++]=q}}}}return n.makeTensorInfo([d,u,p,m],r.dtype,g)}var bZ={kernelName:No,backendName:\"cpu\",kernelFunc:gZ};function yZ(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a;ge([s,r],\"resizeNearestNeighborGrad\");let o=w.computeStrides(r.shape),l=w.computeStrides(s.shape),[u,p,d,c]=r.shape,[,h,m]=s.shape,f=new Float32Array(u*p*d*c),g=n.data.get(s.dataId).values,b=[i&&h>1?p-1:p,i&&m>1?d-1:d],y=[i&&h>1?h-1:h,i&&m>1?m-1:m],x=b[0]/y[0],v=b[1]/y[1],I=1/x,N=1/v,C=Math.ceil(I)*2+2,_=Math.ceil(N)*2+2;for(let F=0;F<u;F++){let D=F*o[0];for(let $=0;$<p;$++){let S=D+$*o[1],M=Math.floor($*I),B=Math.floor(M-C/2);for(let U=0;U<d;U++){let H=S+U*o[2],q=Math.floor(U*N),K=Math.floor(q-_/2);for(let Z=0;Z<c;Z++){let J=0;for(let ee=0;ee<C;ee++){let ae=ee+B;if(ae<0||ae>=h)continue;let te=D+ae*l[1],se=ae*x,ie=Math.min(p-1,i?Math.round(se):Math.floor(se));if($===ie)for(let ve=0;ve<_;ve++){let ue=ve+K;if(ue<0||ue>=m)continue;let ye=te+ue*l[2],ke=ue*v,Se=Math.min(d-1,i?Math.round(ke):Math.floor(ke));U===Se&&(J+=g[ye+Z])}}f[H+Z]=J}}}}return n.makeTensorInfo(r.shape,r.dtype,f)}var xZ={kernelName:Mu,backendName:\"cpu\",kernelFunc:yZ};function vZ(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a;ge(r,\"reverse\");let i=r.shape.length,o=w.parseAxisParam(s,r.shape);if(i===0)return cr({inputs:{x:r},backend:n});let l=new Wt(r.shape,r.dtype),u=n.bufferSync(r);for(let p=0;p<l.size;p++){let d=l.indexToLoc(p),c=d.slice();o.forEach(h=>c[h]=r.shape[h]-1-c[h]),l.set(u.get(...c),...d)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}var wZ={kernelName:Eo,backendName:\"cpu\",kernelFunc:vZ},kZ={kernelName:Zu,backendName:\"cpu\",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:a}=e,{radians:r,fillValue:s,center:i}=t,o=n,l=w.getTypedArrayFromDType(a.dtype,w.sizeFromShape(a.shape)),[u,p,d,c]=a.shape,[h,m]=T.getImageCenter(i,p,d),f=255,g=Math.sin(r),b=Math.cos(r),y=o.data.get(a.dataId).values;for(let x=0;x<u;x++){let v=x*d*p*c;for(let I=0;I<p;I++){let N=I*(d*c);for(let C=0;C<d;C++){let _=C*c;for(let F=0;F<c;F++){let D=[u,I,C,F],$=D[2],S=D[1],M=($-h)*b-(S-m)*g,B=($-h)*g+(S-m)*b;M=Math.round(M+h),B=Math.round(B+m);let U=s;if(typeof s!=\"number\"&&(F===3?U=f:U=s[F]),M>=0&&M<d&&B>=0&&B<p){let q=B*(d*c),K=M*c,Z=v+q+K+F;U=y[Z]}let H=v+N+_+F;l[H]=U}}}}return{dataId:o.write(l,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},IZ=lt(_o,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),SZ={kernelName:_o,backendName:\"cpu\",kernelFunc:IZ};function NZ(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:i}=a,{sliceRank:o,numUpdates:l,sliceSize:u,strides:p,outputSize:d}=T.calculateShapes(s,r,i),c=!0,h=n.bufferSync(r),m=n.bufferSync(s),f=ni(h,m,i,d,u,l,o,p,0,c);return n.makeTensorInfo(i,f.dtype,f.values)}var TZ={kernelName:Pu,backendName:\"cpu\",kernelFunc:NZ};function CZ(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<t?n=r+1:a=r;return a}function EZ(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<=t?n=r+1:a=r;return a}function _Z(e,t,n,a,r,s){let i=w.getArrayFromDType(\"int32\",n*r);for(let o=0;o<n;++o){let l=e.slice(o*a,(o+1)*a),u=o*r;for(let p=0;p<r;++p)i[u+p]=s===\"left\"?CZ(l,t[p+u]):EZ(l,t[p+u])}return i}function AZ(e){let{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:i}=a,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=_Z(o,l,r.shape[0],r.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,\"int32\",u)}var FZ={kernelName:zu,backendName:\"cpu\",kernelFunc:AZ};function $Z(e){let{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t;ge([a,r,s],\"select\");let i=a.shape.length,o=n.data.get(a.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,p=fa(r.dtype,s.dtype),d=w.makeZerosTypedArray(w.sizeFromShape(r.shape),p),c=0,h=i===0||i>1||r.shape.length===1?1:w.sizeFromShape(r.shape.slice(1));for(let m=0;m<o.length;m++)for(let f=0;f<h;f++)o[m]===1?d[c++]=l[m]:d[c++]=u[m];return n.makeTensorInfo(r.shape,p,d)}var DZ={kernelName:Wu,backendName:\"cpu\",kernelFunc:$Z},RZ=T.SELU_SCALEALPHA,MZ=T.SELU_SCALE,OZ=lt(Fo,e=>e>=0?MZ*e:RZ*(Math.exp(e)-1)),PZ={kernelName:Fo,backendName:\"cpu\",kernelFunc:OZ},LZ=lt(Ro,e=>e<0?-1:e>0?1:0),zZ={kernelName:Ro,backendName:\"cpu\",kernelFunc:LZ},WZ=lt($o,e=>Math.sin(e)),BZ={kernelName:$o,backendName:\"cpu\",kernelFunc:WZ},VZ=lt(Do,e=>Math.sinh(e)),UZ={kernelName:Do,backendName:\"cpu\",kernelFunc:VZ},GZ=11920928955078125e-23,eS=Math.log(GZ)+2,HZ=lt(Oo,e=>{let t=e>-eS,n=e<eS,a=Math.exp(e),r;return n?r=a:t?r=e:r=Math.log(1+a),r}),jZ={kernelName:Oo,backendName:\"cpu\",kernelFunc:HZ};function qZ(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:i}=a;ge([r],\"spaceToBatchND\");let o=w.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<r.shape.length;++g)l.push([0,0]);let u=F_.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),p=T.getReshaped(u.shape,s,o,!1),d=T.getPermuted(p.length,s.length,!1),c=T.getReshapedPermuted(u.shape,s,o,!1),h=xt({inputs:{x:u},backend:n,attrs:{shape:p}}),m=Vn({inputs:{x:h},backend:n,attrs:{perm:d}}),f=xt({inputs:{x:m},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),f}var KZ={kernelName:Vu,backendName:\"cpu\",kernelFunc:qZ};function XZ(e){let{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(a.shape.length!==2)throw new Error(`Indices must be a matrix, saw:\n        ${a.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:\n        ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);let o=n.data.get(a.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,p=n.data.get(i.dataId).values[0],[d,c,h,m,f]=o_(o,a.shape,a.dtype,l,r.dtype,u,p);return[n.makeTensorInfo(c,a.dtype,d),n.makeTensorInfo([c[0]],r.dtype,h),n.makeTensorInfo([m.length],\"bool\",new Uint8Array(m.map(g=>Number(g)))),n.makeTensorInfo([f.length],a.dtype,new Int32Array(f))]}var YZ={kernelName:Gc,backendName:\"cpu\",kernelFunc:XZ};function ZZ(e){let{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(a.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape\n        ${a.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape\n        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.data.get(r.dataId).values),o=n.data.get(a.dataId).values,l=Array.from(n.data.get(s.dataId).values),[u,p,d]=l_(o,a.shape,a.dtype,i,l);return[n.makeTensorInfo(p,a.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}var JZ={kernelName:Gu,backendName:\"cpu\",kernelFunc:ZZ};function QZ(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error(\"Data should be at least 1 dimensional but received scalar\");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape\n          ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);if(r.shape[0]!==s.shape[0])throw new Error(\"segmentIds and indices should have same size.\");let i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[u,p]=V1(i,a.shape,a.dtype,o,l,!0);return n.makeTensorInfo(p,a.dtype,u)}var eJ={kernelName:Hc,backendName:\"cpu\",kernelFunc:QZ};function tJ(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error(\"Data should be at least 1 dimensional but received scalar\");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape\n         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);if(r.shape[0]!==s.shape[0])throw new Error(\"segmentIds and indices should have same size.\");let i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[u,p]=V1(i,a.shape,a.dtype,o,l);return n.makeTensorInfo(p,a.dtype,u)}var nJ={kernelName:jc,backendName:\"cpu\",kernelFunc:tJ};function aJ(e){let{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=t,{outputShape:o}=a,{sliceRank:l,numUpdates:u,sliceSize:p,strides:d,outputSize:c}=T.calculateShapes(s,r,o),h=!1,m=n.bufferSync(r),f;switch(s.dtype){case\"bool\":{let g=n.bufferSync(s),b=!!n.data.get(i.dataId).values[0];f=ni(m,g,o,c,p,u,l,d,b,h);break}case\"float32\":{let g=n.bufferSync(s),b=n.data.get(i.dataId).values[0];f=ni(m,g,o,c,p,u,l,d,b,h);break}case\"int32\":{let g=n.bufferSync(s),b=n.data.get(i.dataId).values[0];f=ni(m,g,o,c,p,u,l,d,b,h);break}case\"string\":{let g=n.bufferSync(s),b=w.decodeString(n.data.get(i.dataId).values[0]);f=ni(m,g,o,c,p,u,l,d,b,h);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return n.makeTensorInfo(o,f.dtype,f.values)}var rJ={kernelName:Hu,backendName:\"cpu\",kernelFunc:aJ};function sJ(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=a,o=w.parseAxisParam(i,r.shape)[0],l=T.prepareSplitSize(r,s,o),u=new Array(r.shape.length).fill(0),p=r.shape.slice();return l.map(d=>{let c=[...p];c[o]=d;let h=xi({inputs:{x:r},backend:n,attrs:{begin:u,size:c}});return u[o]+=d,h})}var iJ={kernelName:Uu,backendName:\"cpu\",kernelFunc:sJ},oJ={kernelName:qc,backendName:\"cpu\",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,a=t;ge(n,\"square\");let r=a.data.get(n.dataId).values,s=new Float32Array(r.length);for(let i=0;i<r.length;++i){let o=r[i];s[i]=o*o}return{dataId:a.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},lJ=lt(Is,(e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),uJ={kernelName:Is,backendName:\"cpu\",kernelFunc:lJ};function pJ(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:p,newAxisMask:d,shrinkAxisMask:c}=a;ge(r,\"stridedSlice\");let{finalShapeSparse:h,finalShape:m,isIdentity:f,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:v}=Kt.sliceInfo(r.shape,s,i,o,l,u,p,d,c),I;if(f)I=xt({inputs:{x:r},backend:n,attrs:{shape:m}});else if(g||b){w.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);let N=Kt.computeOutShape(y,x,v),C=xi({inputs:{x:r},backend:n,attrs:{begin:y,size:N}});I=xt({inputs:{x:C},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(C)}else{let N=n.bufferSync(r),C=c_(h,N,v,y);I=n.makeTensorInfo(m,C.dtype,C.values)}return I}var cJ={kernelName:ju,backendName:\"cpu\",kernelFunc:pJ};function dJ(e){let{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=a,{data:p,dataSplits:d}=t,c=n.data.get(p.dataId).values,h=n.data.get(d.dataId).values,[m,f]=U1(c,h,r,s,i,o,l,u);return[n.makeTensorInfo([m.length],\"string\",m),n.makeTensorInfo(d.shape,\"int32\",f)]}var hJ={kernelName:Xc,backendName:\"cpu\",kernelFunc:dJ};function mJ(e){let{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:s,delimiter:i}=t;if(s.dtype!==\"string\")throw new Error(\"Input must be of datatype string\");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values[0],[u,p,d]=G1(o,l,r),c=p.length;return[n.makeTensorInfo([c,2],\"int32\",u),n.makeTensorInfo([c],\"string\",p),n.makeTensorInfo([2],\"int32\",new Int32Array(d))]}var fJ={kernelName:Yc,backendName:\"cpu\",kernelFunc:mJ};function gJ(e){let{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:s}=t;if(s.dtype!==\"string\")throw new Error(\"Input must be of datatype string\");if(r<=0)throw new Error(\"Number of buckets must be at least 1\");let i=n.data.get(s.dataId).values,o=H1(i,r);return n.makeTensorInfo(s.shape,\"int32\",o)}var bJ={kernelName:Zc,backendName:\"cpu\",kernelFunc:gJ},yJ=lt(Vo,e=>Math.tan(e)),xJ={kernelName:Vo,backendName:\"cpu\",kernelFunc:yJ},vJ=lt(Uo,e=>Math.tanh(e)),wJ={kernelName:Uo,backendName:\"cpu\",kernelFunc:vJ};function kJ(e){let{inputs:t,backend:n}=e,{tensor:a,indices:r,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:p}=T.calculateShapes(s,r,a.shape),d=!1,c=n.bufferSync(r),h=n.bufferSync(s),m=n.bufferSync(a),f=ni(c,h,a.shape,p,l,o,i,u,m,d);return n.makeTensorInfo(a.shape,f.dtype,f.values)}var IJ={kernelName:Lu,backendName:\"cpu\",kernelFunc:kJ};function SJ(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;ge(r,\"tile\");let i=h_(n.bufferSync(r),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}var NJ={kernelName:ks,backendName:\"cpu\",kernelFunc:SJ};function TJ(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:i}=a;ge(r,\"topk\");let o=n.data.get(r.dataId).values,[l,u]=f_(o,r.shape,r.dtype,s,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}var CJ={kernelName:qu,backendName:\"cpu\",kernelFunc:TJ};function EJ(e){let{inputs:t,attrs:n,backend:a}=e,{image:r,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[p,d,c,h]=r.shape,[m,f]=u!=null?u:[d,c],g=[p,m,f,h],b=w.computeStrides(r.shape),y=b[0],x=b[1],v=b[2],I=w.computeStrides(g),N=I[0],C=I[1],_=I[2],F=w.getTypedArrayFromDType(r.dtype,w.sizeFromShape(g));F.fill(l);let D=a.data.get(r.dataId).values,$=a.data.get(s.dataId).values;for(let S=0;S<p;++S){let M=s.shape[0]===1?$:$.subarray(S*8,S*8+8);for(let B=0;B<m;++B)for(let U=0;U<f;++U)for(let H=0;H<h;++H){let q,K=M[6]*U+M[7]*B+1;if(K===0)continue;let Z=(M[0]*U+M[1]*B+M[2])/K,J=(M[3]*U+M[4]*B+M[5])/K,ee=tS(Z,c,o),ae=tS(J,d,o);switch(i){case\"nearest\":q=RJ(D,d,c,y,x,v,S,ae,ee,H,l);break;case\"bilinear\":q=MJ(D,d,c,y,x,v,S,ae,ee,H,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let te=S*N+B*C+U*_+H;F[te]=q}return a.makeTensorInfo(g,r.dtype,F)}return{dataId:a.write(F,g,r.dtype),shape:r.shape,dtype:r.dtype}}var _J={kernelName:Ku,backendName:\"cpu\",kernelFunc:EJ};function tS(e,t,n){switch(n){case\"reflect\":return AJ(e,t);case\"wrap\":return FJ(e,t);case\"nearest\":return DJ(e,t);case\"constant\":default:return $J(e,t)}}function AJ(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let a=2*t;n<a&&(n=a*Math.trunc(-n/a)+n),n=n<-t?n+a:-n-1}else if(n>t-1)if(t<=1)n=0;else{let a=2*t;n-=a*Math.trunc(n/a),n>=t&&(n=a-n-1)}return w.clamp(0,n,t-1)}function FJ(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let a=t-1;n+=t*(Math.trunc(-n/a)+1)}else if(n>t-1)if(t<=1)n=0;else{let a=t-1;n-=t*Math.trunc(n/a)}return w.clamp(0,n,t-1)}function $J(e,t){return e}function DJ(e,t){return w.clamp(0,e,t-1)}function ac(e,t,n,a,r,s,i,o,l,u,p){let d=i*a+o*r+l*s+u;return 0<=o&&o<t&&0<=l&&l<n?e[d]:p}function RJ(e,t,n,a,r,s,i,o,l,u,p){let d=Math.round(o),c=Math.round(l);return ac(e,t,n,a,r,s,i,d,c,u,p)}function MJ(e,t,n,a,r,s,i,o,l,u,p){let d=Math.floor(o),c=Math.floor(l),h=d+1,m=c+1,f=(m-l)*ac(e,t,n,a,r,s,i,d,c,u,p)+(l-c)*ac(e,t,n,a,r,s,i,d,m,u,p),g=(m-l)*ac(e,t,n,a,r,s,i,h,c,u,p)+(l-c)*ac(e,t,n,a,r,s,i,h,m,u,p);return(h-o)*f+(o-d)*g}function OJ(e){let{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;ge(s,\"unique\");let i=a.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:u}=q1(i,r,s.shape,s.dtype);return[a.makeTensorInfo(l,s.dtype,o),a.makeTensorInfo([u.length],\"int32\",u)]}var PJ={kernelName:Jc,backendName:\"cpu\",kernelFunc:OJ};function LJ(e){let{inputs:t,backend:n,attrs:a}=e,{value:r}=t,{axis:s}=a;s<0&&(s+=r.shape.length);let i=r.shape.length,o=r.shape[s],l=new Array(i-1),u=0;for(let h=0;h<i;h++)h!==s&&(l[u++]=r.shape[h]);let p=new Array(i).fill(0),d=r.shape.slice();d[s]=1;let c=new Array(o);for(let h=0;h<c.length;h++){p[s]=h;let m=xi({inputs:{x:r},backend:n,attrs:{begin:p,size:d}});c[h]=xt({inputs:{x:m},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(m)}return c}var zJ={kernelName:Xu,backendName:\"cpu\",kernelFunc:LJ};function WJ(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:s}=t,{numSegments:i}=a;ge(r,\"unsortedSegmentSum\");let o=r.shape.length,l=s.shape.length,u=[],p=[],d=o-l,c=s;for(let m=0;m<d;++m){let f=cm({inputs:{input:c},backend:n,attrs:{dim:m+1}});c=f,p.push(f)}for(let m=0;m<i;++m){let f=w.createScalarValue(m,\"int32\"),g=n.makeTensorInfo([],\"int32\",f),b=OE({inputs:{a:g,b:c},backend:n}),y=bs({inputs:{x:b},backend:n,attrs:{dtype:\"float32\"}}),x=zf({inputs:{a:y,b:r},backend:n}),v=Ed({inputs:{x},backend:n,attrs:{axis:0,keepDims:!1}});u.push(v),p.push(g),p.push(b),p.push(y),p.push(x),p.push(v)}let h=A_({inputs:u,backend:n,attrs:{axis:0}});return p.forEach(m=>n.disposeIntermediateTensorInfo(m)),h}var BJ={kernelName:Qc,backendName:\"cpu\",kernelFunc:WJ},VJ=[MK,m8,PK,zK,v8,BK,UK,HK,qK,XK,ZK,QK,tX,rX,iX,uX,cX,hX,fX,DK,bX,xX,wX,k8,IX,y8,S8,NX,f8,CX,_X,AX,$X,RX,OX,LX,WX,VX,GX,jX,KX,YX,JX,eY,tY,aY,sY,oY,lY,uY,pY,dY,fY,TK,bY,N8,NY,T8,TY,E8,$Y,DY,MY,A8,$8,PY,zY,BY,UY,R8,O8,g8,HY,EX,qY,XY,ZY,CK,L8,W8,QY,V8,t7,r7,i7,u7,c7,h7,m7,G8,g7,y7,v7,k7,S7,T7,E7,j8,A7,D7,P7,K8,Y8,W7,U7,j7,J8,K7,Y7,Z7,F_,tZ,_K,tK,aZ,sZ,oZ,uZ,b8,lv,cZ,AK,FK,$K,hZ,fZ,bZ,xZ,wZ,kZ,SZ,pK,TZ,FZ,DZ,PZ,dK,zZ,BZ,UZ,hK,M7,jZ,KZ,YZ,JZ,eJ,nJ,rJ,iJ,gK,oJ,yK,vK,uJ,cJ,hJ,fJ,bJ,SK,hY,xJ,wJ,IJ,NJ,CJ,_J,Q8,PJ,zJ,BJ,X7];for(let e of VJ)ed(e);var $_={};_e($_,{assertNotComplex:()=>lp,bindCanvasToFramebuffer:()=>QJ,bindColorTextureToFramebuffer:()=>Ph,bindTextureToProgramUniformSampler:()=>K_,bindTextureUnit:()=>H_,bindVertexBufferToProgramAttribute:()=>pv,callAndCheck:()=>de,canBeRepresented:()=>R_,createFragmentShader:()=>P_,createFramebuffer:()=>G_,createProgram:()=>L_,createStaticIndexBuffer:()=>B_,createStaticVertexBuffer:()=>W_,createTexture:()=>V_,createVertexShader:()=>O_,getBatchDim:()=>vi,getExtensionOrThrow:()=>rc,getFramebufferErrorMessage:()=>X_,getMaxTexturesInShader:()=>Q_,getNumChannels:()=>ZJ,getProgramUniformLocation:()=>q_,getProgramUniformLocationOrThrow:()=>j_,getRowsCols:()=>wi,getShapeAs3D:()=>ic,getTextureShapeFromLogicalShape:()=>Z_,getWebGLDisjointQueryTimerVersion:()=>eA,getWebGLErrorMessage:()=>M_,getWebGLMaxTextureSize:()=>J_,hasExtension:()=>da,isCapableOfRenderingToFloatTexture:()=>tA,isDownloadFloatTextureEnabled:()=>nA,isReshapeFree:()=>Tc,isWebGLFenceEnabled:()=>aA,isWebGLVersionEnabled:()=>dv,linkProgram:()=>z_,logShaderSourceAndInfoLog:()=>J1,resetMaxTextureSize:()=>e9,resetMaxTexturesInShader:()=>t9,unbindColorTextureFromFramebuffer:()=>cv,unbindTextureUnit:()=>JJ,validateFramebuffer:()=>sc,validateProgram:()=>Oh,validateTextureSize:()=>U_});var ei={},_h={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function D_(e,t){ei[e]=t}function ja(e,t){if(!(e in ei)||t!=null){let a=GJ(e,t);if(a!==null)ei[e]=a;else return console.log(\"Could not get context for WebGL version\",e),null}let n=ei[e];return n==null||n.isContextLost()?(delete ei[e],ja(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),ei[e])}function UJ(e){if(!G().getBool(\"IS_SAFARI\")&&typeof OffscreenCanvas!=\"undefined\"&&e===2)return new OffscreenCanvas(300,150);if(typeof document!=\"undefined\")return document.createElement(\"canvas\");throw new Error(\"Cannot create a canvas in this context\")}function GJ(e,t){if(e!==1&&e!==2)throw new Error(\"Cannot get WebGL rendering context, WebGL is disabled.\");let n=t==null?UJ(e):t;return n.addEventListener(\"webglcontextlost\",a=>{a.preventDefault(),delete ei[e]},!1),G().getBool(\"SOFTWARE_WEBGL_ENABLED\")&&(_h.failIfMajorPerformanceCaveat=!1),e===1?n.getContext(\"webgl\",_h)||n.getContext(\"experimental-webgl\",_h):n.getContext(\"webgl2\",_h)}var Nc;(function(e){e[e.DENSE=0]=\"DENSE\",e[e.SHARED_BATCH=1]=\"SHARED_BATCH\"})(Nc||(Nc={}));var ca;(function(e){e[e.RENDER=0]=\"RENDER\",e[e.UPLOAD=1]=\"UPLOAD\",e[e.PIXELS=2]=\"PIXELS\",e[e.DOWNLOAD=3]=\"DOWNLOAD\"})(ca||(ca={}));var cn;(function(e){e[e.UNPACKED_FLOAT16=0]=\"UNPACKED_FLOAT16\",e[e.UNPACKED_FLOAT32=1]=\"UNPACKED_FLOAT32\",e[e.PACKED_4X1_UNSIGNED_BYTE=2]=\"PACKED_4X1_UNSIGNED_BYTE\",e[e.PACKED_2X2_FLOAT32=3]=\"PACKED_2X2_FLOAT32\",e[e.PACKED_2X2_FLOAT16=4]=\"PACKED_2X2_FLOAT16\"})(cn||(cn={}));function _d(e,t){return[t,e]}function HJ(e,t){return e*t}function Ah(e){let t=w.sizeFromShape(e),n=Math.ceil(t/4);return w.sizeToSquarishShape(n)}function op(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function jJ(e,t){let[n,a]=op(e,t);return n*a*4}function Z1(e,t){let n=e,a,r,s,i,o,l,u,p,d,c;return G().getNumber(\"WEBGL_VERSION\")===2?(a=n.R32F,r=n.R16F,s=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,p=1,d=n.HALF_FLOAT,c=n.FLOAT,l=n.RGBA8):(a=e.RGBA,r=e.RGBA,s=e.RGBA,i=n.RGBA,o=e.RGBA,u=4,p=4,d=t!=null?t.HALF_FLOAT_OES:null,c=e.FLOAT,l=e.RGBA),{internalFormatFloat:a,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:p,textureTypeHalfFloat:d,textureTypeFloat:c}}function de(e,t){let n=t();return G().getBool(\"DEBUG\")&&qJ(e),n}function qJ(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error(\"WebGL Error: \"+M_(e,t))}var KJ=596e-10,XJ=65504;function R_(e){return!!(G().getBool(\"WEBGL_RENDER_FLOAT32_ENABLED\")||e===0||KJ<Math.abs(e)&&Math.abs(e)<XJ)}function M_(e,t){switch(t){case e.NO_ERROR:return\"NO_ERROR\";case e.INVALID_ENUM:return\"INVALID_ENUM\";case e.INVALID_VALUE:return\"INVALID_VALUE\";case e.INVALID_OPERATION:return\"INVALID_OPERATION\";case e.INVALID_FRAMEBUFFER_OPERATION:return\"INVALID_FRAMEBUFFER_OPERATION\";case e.OUT_OF_MEMORY:return\"OUT_OF_MEMORY\";case e.CONTEXT_LOST_WEBGL:return\"CONTEXT_LOST_WEBGL\";default:return`Unknown error code ${t}`}}function rc(e,t){return Or(e,()=>e.getExtension(t),'Extension \"'+t+'\" not supported on this browser.')}function O_(e,t){let n=Or(e,()=>e.createShader(e.VERTEX_SHADER),\"Unable to create vertex WebGLShader.\");if(de(e,()=>e.shaderSource(n,t)),de(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error(\"Failed to compile vertex shader.\");return n}function P_(e,t){let n=Or(e,()=>e.createShader(e.FRAGMENT_SHADER),\"Unable to create fragment WebGLShader.\");if(de(e,()=>e.shaderSource(n,t)),de(e,()=>e.compileShader(n)),G().get(\"ENGINE_COMPILE_ONLY\"))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw J1(t,e.getShaderInfoLog(n)),new Error(\"Failed to compile fragment shader.\");return n}var YJ=/ERROR: [0-9]+:([0-9]+):/g;function J1(e,t){let n=YJ.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let a=+n[1],r=e.split(`\n`),s=r.length.toString().length+2,i=r.map((d,c)=>w.rightPad((c+1).toString(),s)+d),o=0;for(let d=0;d<i.length;d++)o=Math.max(i[d].length,o);let l=i.slice(0,a-1),u=i.slice(a-1,a),p=i.slice(a);console.log(l.join(`\n`)),console.log(t.split(`\n`)[0]),console.log(`%c ${w.rightPad(u[0],o)}`,\"border:1px solid red; background-color:#e3d2d2; color:#a61717\"),console.log(p.join(`\n`))}function L_(e){return Or(e,()=>e.createProgram(),\"Unable to create WebGLProgram.\")}function z_(e,t){if(de(e,()=>e.linkProgram(t)),!G().get(\"ENGINE_COMPILE_ONLY\")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error(\"Failed to link vertex and fragment shaders.\")}function Oh(e,t){if(de(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error(\"Shader program validation failed.\")}function W_(e,t){let n=Or(e,()=>e.createBuffer(),\"Unable to create WebGLBuffer\");return de(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),de(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function B_(e,t){let n=Or(e,()=>e.createBuffer(),\"Unable to create WebGLBuffer\");return de(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),de(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function ZJ(){return G().getNumber(\"WEBGL_VERSION\")===2?1:4}function V_(e){return Or(e,()=>e.createTexture(),\"Unable to create WebGLTexture.\")}function U_(e,t){let n=G().getNumber(\"WEBGL_MAX_TEXTURE_SIZE\");if(e<=0||t<=0){let a=`[${e}x${t}]`;throw new Error(\"Requested texture size \"+a+\" is invalid.\")}if(e>n||t>n){let a=`[${e}x${t}]`,r=`[${n}x${n}]`;throw new Error(\"Requested texture size \"+a+\" greater than WebGL maximum on this browser / GPU \"+r+\".\")}}function G_(e){return Or(e,()=>e.createFramebuffer(),\"Unable to create WebGLFramebuffer.\")}function pv(e,t,n,a,r,s,i){let o=e.getAttribLocation(t,n);return o===-1?!1:(de(e,()=>e.bindBuffer(e.ARRAY_BUFFER,a)),de(e,()=>e.vertexAttribPointer(o,r,e.FLOAT,!1,s,i)),de(e,()=>e.enableVertexAttribArray(o)),!0)}function H_(e,t,n){Y_(e,n),de(e,()=>e.activeTexture(e.TEXTURE0+n)),de(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function JJ(e,t){Y_(e,t),de(e,()=>e.activeTexture(e.TEXTURE0+t)),de(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function j_(e,t,n){return Or(e,()=>e.getUniformLocation(t,n),'uniform \"'+n+'\" not present in program.')}function q_(e,t,n){return e.getUniformLocation(t,n)}function K_(e,t,n,a){de(e,()=>H_(e,t,a)),de(e,()=>e.uniform1i(n,a))}function QJ(e){de(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),de(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),de(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function Ph(e,t,n){de(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),de(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function cv(e,t){de(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),de(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function sc(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error(\"Error binding framebuffer: \"+X_(e,t))}function X_(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return\"FRAMEBUFFER_INCOMPLETE_ATTACHMENT\";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return\"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return\"FRAMEBUFFER_INCOMPLETE_DIMENSIONS\";case e.FRAMEBUFFER_UNSUPPORTED:return\"FRAMEBUFFER_UNSUPPORTED\";default:return`unknown error ${t}`}}function Or(e,t,n){let a=de(e,()=>t());if(a==null)throw new Error(n);return a}function Y_(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=t+e.TEXTURE0;if(a<e.TEXTURE0||a>n){let r=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${r}.`)}}function vi(e,t=2){return w.sizeFromShape(e.slice(0,e.length-t))}function wi(e){if(e.length===0)throw Error(\"Cannot get rows and columns of an empty shape array.\");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function ic(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[vi(e),...wi(e)]),t}function Z_(e,t=!1){let n=G().getNumber(\"WEBGL_MAX_TEXTURE_SIZE\"),a=G().getNumber(\"WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE\");a===1/0&&G().getBool(\"WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE\")&&(a=n/2),t&&(n=n*2,a=a*2,e=e.map((o,l)=>l>=e.length-2?w.nearestLargerEven(e[l]):e[l]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=w.squeezeShape(e).newShape);let r=w.sizeFromShape(e),s=null;e.length<=1&&r<=n?s=[1,r]:e.length===2&&e[0]<=n&&e[1]<=n?s=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);let i=s!=null&&Math.max(...s)>a&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(s==null||i)if(t){let o=vi(e),l=2,u=2;e.length&&([l,u]=wi(e)),r=o*(l/2)*(u/2),s=w.sizeToSquarishShape(r).map(p=>p*2)}else s=w.sizeToSquarishShape(r);return s}function Fh(e){return e%2===0}function Tc(e,t){if(e=e.slice(-2),t=t.slice(-2),w.arraysEqual(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){let n=e[e.length-1],a=t[t.length-1];if(n===a||Fh(n)&&Fh(a)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&Fh(e[0])&&Fh(t[0])}var Lh,zh;function J_(e){if(Lh==null){let t=ja(e);Lh=t.getParameter(t.MAX_TEXTURE_SIZE)}return Lh}function e9(){Lh=null}function t9(){zh=null}function Q_(e){if(zh==null){let t=ja(e);zh=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,zh)}function eA(e){if(e===0)return 0;let t,n=ja(e);return da(n,\"EXT_disjoint_timer_query_webgl2\")&&e===2?t=2:da(n,\"EXT_disjoint_timer_query\")?t=1:t=0,t}function da(e,t){return e.getExtension(t)!=null}function dv(e){try{if(ja(e)!=null)return!0}catch(t){return console.log(\"Error when getting WebGL context: \",t),!1}return!1}function tA(e){if(e===0)return!1;let t=ja(e);if(e===1){if(!da(t,\"OES_texture_float\"))return!1}else if(!da(t,\"EXT_color_buffer_float\"))return!1;return hv(t)}function nA(e){if(e===0)return!1;let t=ja(e);if(e===1){if(!da(t,\"OES_texture_float\")||!da(t,\"WEBGL_color_buffer_float\"))return!1}else{if(da(t,\"EXT_color_buffer_float\"))return hv(t);let n=\"EXT_color_buffer_half_float\";if(da(t,n)){let a=t.getExtension(n);return n9(t,a)}return!1}return hv(t)}function hv(e){let t=Z1(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),r}function n9(e,t){let n=Z1(e,t),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);let s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(r),s}function aA(e){return e!==2?!1:ja(e).fenceSync!=null}function lp(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&w.assert(n.dtype!==\"complex64\",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var be=G();be.registerFlag(\"HAS_WEBGL\",()=>be.getNumber(\"WEBGL_VERSION\")>0);be.registerFlag(\"WEBGL_VERSION\",()=>dv(2)?2:dv(1)?1:0);be.registerFlag(\"WEBGL_CHECK_NUMERICAL_PROBLEMS\",()=>!1);be.registerFlag(\"WEBGL_BUFFER_SUPPORTED\",()=>be.get(\"WEBGL_VERSION\")===2);be.registerFlag(\"WEBGL_CPU_FORWARD\",()=>!0);be.registerFlag(\"WEBGL_FORCE_F16_TEXTURES\",()=>!1);be.registerFlag(\"WEBGL_PACK\",()=>be.getBool(\"HAS_WEBGL\"));be.registerFlag(\"WEBGL_PACK_NORMALIZATION\",()=>be.getBool(\"WEBGL_PACK\"));be.registerFlag(\"WEBGL_PACK_CLIP\",()=>be.getBool(\"WEBGL_PACK\"));be.registerFlag(\"WEBGL_PACK_DEPTHWISECONV\",()=>be.getBool(\"WEBGL_PACK\"));be.registerFlag(\"WEBGL_PACK_BINARY_OPERATIONS\",()=>be.getBool(\"WEBGL_PACK\"));be.registerFlag(\"WEBGL_PACK_UNARY_OPERATIONS\",()=>be.getBool(\"WEBGL_PACK\"));be.registerFlag(\"WEBGL_PACK_ARRAY_OPERATIONS\",()=>be.getBool(\"WEBGL_PACK\"));be.registerFlag(\"WEBGL_PACK_IMAGE_OPERATIONS\",()=>be.getBool(\"WEBGL_PACK\"));be.registerFlag(\"WEBGL_PACK_REDUCE\",()=>be.getBool(\"WEBGL_PACK\"));be.registerFlag(\"WEBGL_LAZILY_UNPACK\",()=>be.getBool(\"WEBGL_PACK\"));be.registerFlag(\"WEBGL_CONV_IM2COL\",()=>be.getBool(\"WEBGL_PACK\"));be.registerFlag(\"WEBGL_PACK_CONV2DTRANSPOSE\",()=>be.getBool(\"WEBGL_PACK\"));be.registerFlag(\"WEBGL_MAX_TEXTURE_SIZE\",()=>J_(be.getNumber(\"WEBGL_VERSION\")));be.registerFlag(\"WEBGL_MAX_TEXTURES_IN_SHADER\",()=>Q_(be.getNumber(\"WEBGL_VERSION\")));be.registerFlag(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\",()=>{let e=be.getNumber(\"WEBGL_VERSION\");return e===0?0:eA(e)});be.registerFlag(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\",()=>be.getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")>0&&!ad.isMobile());be.registerFlag(\"WEBGL_RENDER_FLOAT32_CAPABLE\",()=>tA(be.getNumber(\"WEBGL_VERSION\")));be.registerFlag(\"WEBGL_RENDER_FLOAT32_ENABLED\",()=>be.getBool(\"WEBGL_FORCE_F16_TEXTURES\")?!1:be.getBool(\"WEBGL_RENDER_FLOAT32_CAPABLE\"));be.registerFlag(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\",()=>nA(be.getNumber(\"WEBGL_VERSION\")));be.registerFlag(\"WEBGL_FENCE_API_ENABLED\",()=>aA(be.getNumber(\"WEBGL_VERSION\")));be.registerFlag(\"WEBGL_SIZE_UPLOAD_UNIFORM\",()=>be.getBool(\"WEBGL_RENDER_FLOAT32_ENABLED\")?4:0);be.registerFlag(\"WEBGL_DELETE_TEXTURE_THRESHOLD\",()=>-1,e=>{if(typeof e!=\"number\")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});be.registerFlag(\"WEBGL_FLUSH_THRESHOLD\",()=>ad.isMobile()?1:-1,e=>{if(typeof e!=\"number\")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});be.registerFlag(\"CPU_HANDOFF_SIZE_THRESHOLD\",()=>128);be.registerFlag(\"WEBGL_USE_SHAPES_UNIFORMS\",()=>!1);be.registerFlag(\"TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD\",()=>1e5);be.registerFlag(\"TOPK_K_CPU_HANDOFF_THRESHOLD\",()=>128);be.registerFlag(\"WEBGL_EXP_CONV\",()=>!1);be.registerFlag(\"SOFTWARE_WEBGL_ENABLED\",()=>be.getBool(\"IS_TEST\"));be.registerFlag(\"WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE\",()=>1/0);be.registerFlag(\"WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE\",()=>!1);be.registerFlag(\"WEBGL2_ISNAN_CUSTOM\",()=>!1);be.registerFlag(\"ENGINE_COMPILE_ONLY\",()=>!1);function En(){let e,t,n,a,r,s,i,o,l,u;return G().getNumber(\"WEBGL_VERSION\")===2?(e=\"#version 300 es\",t=\"in\",n=\"out\",a=\"in\",r=\"texture\",s=\"outputColor\",i=\"out vec4 outputColor;\",o=G().getBool(\"WEBGL2_ISNAN_CUSTOM\")?`\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    `:\"\",l=\"\",u=`\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `):(e=\"\",t=\"attribute\",n=\"varying\",a=\"varying\",r=\"texture2D\",s=\"gl_FragColor\",i=\"\",o=`\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    `,l=`\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    `,u=`\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `),{version:e,attribute:t,varyingVs:n,varyingFs:a,texture2D:r,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function Zo(e,t,n=\"index\"){let a=w.computeStrides(t);return a.map((r,s)=>{let i=`int ${e[s]} = ${n} / ${r}`,o=s===a.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${r}`:`index -= ${e[s]} * ${r}`;return`${i}; ${o};`}).join(\"\")}function Wf(e,t,n=\"index\"){let a=w.computeStrides(t);return a.map((r,s)=>{let i=`int ${e[s]} = ${n} / outShapeStrides[${s}]`,o=s===a.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`;return`${i}; ${o};`}).join(\"\")}function a9(e,t){let n=e.length,a=e.map(s=>`${t}[${s}]`),r=new Array(n-1);r[n-2]=a[n-1];for(let s=n-3;s>=0;--s)r[s]=`(${r[s+1]} * ${a[s+1]})`;return r}function r9(e,t,n=\"index\"){let a=e.map((s,i)=>i),r=a9(a,t);return r.map((s,i)=>{let o=`int ${e[i]} = ${n} / ${r[i]}`,l=i===r.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${r[i]}`:`index -= ${e[i]} * ${r[i]}`;return`${o}; ${l};`}).join(\"\")}function Q1(e){let t=w.computeStrides(e).map(n=>n.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}function ek(){return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n`}var rA=`\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n`,{getBroadcastDims:sA}=T;function s9(e,t,n){let a=[];if(e.forEach(c=>{let h=w.sizeFromShape(c.shapeInfo.logicalShape);if(c.shapeInfo.isUniform?a.push(`uniform float ${c.name}${h>1?`[${h}]`:\"\"};`):(a.push(`uniform sampler2D ${c.name};`),a.push(`uniform int offset${c.name};`)),n.enableShapeUniforms){let{uniformShape:m}=tk(n.packedInputs,c.shapeInfo.logicalShape,c.shapeInfo.texShape);switch(m.length){case 1:a.push(`uniform int ${c.name}Shape;`);break;case 2:a.push(`uniform ivec2 ${c.name}Shape;`);break;case 3:a.push(`uniform ivec3 ${c.name}Shape;`);break;case 4:a.push(`uniform ivec4 ${c.name}Shape;`);break;default:break}a.push(`uniform ivec2 ${c.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:a.push(\"uniform int outShape;\");break;case 2:a.push(\"uniform ivec2 outShape;\"),a.push(\"uniform int outShapeStrides;\");break;case 3:a.push(\"uniform ivec3 outShape;\"),a.push(\"uniform ivec2 outShapeStrides;\");break;case 4:a.push(\"uniform ivec4 outShape;\"),a.push(\"uniform ivec3 outShapeStrides;\");break;default:break}a.push(\"uniform ivec2 outTexShape;\")}n.customUniforms&&n.customUniforms.forEach(c=>{a.push(`uniform ${c.type} ${c.name}${c.arrayIndex?`[${c.arrayIndex}]`:\"\"};`)});let r=a.join(`\n`),s=e.map(c=>i9(c,t,n.packedInputs,n.enableShapeUniforms)).join(`\n`),i=t.texShape,o=En(),l=u9(o),u,p,d=d9(o);return t.isPacked?(u=o9(t.logicalShape,i,n.enableShapeUniforms),p=c9(o)):(u=l9(t.logicalShape,i,n.enableShapeUniforms),p=p9(o)),n.packedInputs&&(d+=g9),[d,l,p,r,u,s,n.userCode].join(`\n`)}function up(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return E9(e,t);case 1:return A9(e,t);case 2:return $9(e,t);case 3:return R9(e,t);case 4:return O9(e,t);case 5:return P9(e);case 6:return L9(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function iA(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return C9(e);case 1:return _9(e,t);case 2:return F9(e,t);case 3:return D9(e,t);default:return M9(e,t)}}function i9(e,t,n=!1,a){let r=\"\";n?r+=iA(e,a):r+=up(e,a);let s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(n?r+=z9(e,t):r+=W9(e,t)),r}function o9(e,t,n){switch(e.length){case 0:return oA();case 1:return b9(e,t,n);case 2:return N9(e,t,n);case 3:return x9(e,t,n);default:return w9(e,t,n)}}function l9(e,t,n){switch(e.length){case 0:return oA();case 1:return y9(e,t,n);case 2:return T9(e,t,n);case 3:return v9(e,t,n);case 4:return k9(e,t,n);case 5:return I9(e,t);case 6:return S9(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function u9(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}function p9(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}function c9(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}function d9(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${h9}\n    ${m9}\n    ${f9}\n  `}var h9=`\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`,m9=`\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`,f9=`\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`,g9=`\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n`;function oA(){return`\n    int getOutputCoords() {\n      return 0;\n    }\n  `}function b9(e,t,n){let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return a[0]===1?n?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    `:`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${a[1]}.0);\n      }\n    `:a[1]===1?n?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    `:`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${a[0]}.0);\n      }\n    `:n?`\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${a[0]}, ${a[1]}));\n      return 2 * (resTexRC.x * ${a[1]} + resTexRC.y);\n    }\n  `}function y9(e,t,n){return t[0]===1?n?`\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    `:`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:t[1]===1?n?`\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    `:`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}function x9(e,t,n){if(n)return`\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `;let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),s=r*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${a[0]}, ${a[1]}));\n      int index = resTexRC.x * ${a[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}function v9(e,t,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${Wf([\"r\",\"c\",\"d\"],e)}\n    return ivec3(r, c, d);\n  }\n`;let a=Zo([\"r\",\"c\",\"d\"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${a}\n      return ivec3(r, c, d);\n    }\n  `}function w9(e,t,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  `;let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),s=r*Math.ceil(e[e.length-2]/2),i=s,o=\"\",l=\"b, r, c\";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`\n      int b${u} = index / ${i};\n      index -= b${u} * ${i};\n    `+o,l=`b${u}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${a[0]}, ${a[1]}));\n      int index = resTexRC.x * ${a[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}function k9(e,t,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${Wf([\"r\",\"c\",\"d\",\"d2\"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;let a=Zo([\"r\",\"c\",\"d\",\"d2\"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${a}\n      return ivec4(r, c, d, d2);\n    }\n  `}function I9(e,t){let n=Zo([\"r\",\"c\",\"d\",\"d2\",\"d3\"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}function S9(e,t){let n=Zo([\"r\",\"c\",\"d\",\"d2\",\"d3\",\"d4\"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}function N9(e,t,n){let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(w.arraysEqual(e,t))return n?`\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    `:`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${a[0]}, ${a[1]}));\n      }\n    `;let r=Math.ceil(e[1]/2);return n?`\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${a[0]}, ${a[1]}));\n\n      int index = resTexRC.x * ${a[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}function T9(e,t,n){return w.arraysEqual(e,t)?n?`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    `:`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:e[1]===1?n?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:e[0]===1?n?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}function Jo(e){return`offset${e}`}function C9(e){let t=e.name,n=\"get\"+t.charAt(0).toUpperCase()+t.slice(1),a=En();return`\n    vec4 ${n}() {\n      return ${a.texture2D}(${t}, halfCR);\n    }\n  `}function E9(e,t){let n=e.name,a=\"get\"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${a}() {return ${n};}`;let[r,s]=e.shapeInfo.texShape;if(r===1&&s===1)return`\n      float ${a}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let i=Jo(n);if(t)return`\n    float ${a}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;let[o,l]=e.shapeInfo.texShape;return`\n    float ${a}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}function _9(e,t){let n=e.name,a=\"get\"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,s=En();if(t)return`\n    vec4 ${a}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `;let i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`\n    vec4 ${a}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}function A9(e,t){let n=e.name,a=\"get\"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${a}(int index) {\n        ${pp(e)}\n      }\n    `;let r=e.shapeInfo.texShape,s=r[0],i=r[1];if(i===1&&s===1)return`\n      float ${a}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let o=Jo(n);return i===1?t?`\n      float ${a}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${a}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:s===1?t?`\n      float ${a}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${a}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${a}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${a}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}function F9(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r=\"get\"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=En();if(s!=null&&w.arraysEqual(n,s))return t?`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);\n\n        return ${l.texture2D}(${a}, uv);\n      }\n    `:`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${l.texture2D}(${a}, uv);\n      }\n    `;if(t)return`\n    vec4 ${r}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${a}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${a}, uv);\n    }\n  `;let u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],p=Math.ceil(n[1]/2);return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${p}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${a}, uv);\n    }\n  `}function $9(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r=\"get\"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape;if(s!=null&&w.arraysEqual(n,s)){if(t)return`\n      float ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);\n        return sampleTexture(${a}, uv);\n      }\n    `;let c=s[0],h=s[1];return`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${h}.0, ${c}.0);\n      return sampleTexture(${a}, uv);\n    }\n  `}let{newShape:i,keptDims:o}=w.squeezeShape(n),l=i;if(l.length<n.length){let c=cp(e,l),h=[\"row\",\"col\"];return`\n      ${up(c,t)}\n      float ${r}(int row, int col) {\n        return ${r}(${dp(h,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${pp(e)}\n      }\n    `;let u=s[0],p=s[1],d=Jo(a);return p===1?t?`\n      float ${r}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${a}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${a}TexShape[0]));\n        return sampleTexture(${a}, uv);\n      }\n    `:`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${a}, uv);\n    }\n  `:u===1?t?`\n      float ${r}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${a}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${a}TexShape[1]), 0.5);\n        return sampleTexture(${a}, uv);\n      }\n    `:`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);\n      return sampleTexture(${a}, uv);\n    }\n  `:t?`\n      float ${r}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${a}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index);\n        return sampleTexture(${a}, uv);\n      }\n    `:`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${p}, index);\n    return sampleTexture(${a}, uv);\n  }\n`}function D9(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r=\"get\"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(n[0]===1){let c=n.slice(1),h=[1,2],m=cp(e,c),f=[\"b\",\"row\",\"col\"];return`\n        ${iA(m,t)}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${dp(f,h)});\n        }\n      `}let o=En();if(t)return`\n    vec4 ${r}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${a}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${a}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${a}, uv);\n    }\n  `;let l=i[0],u=i[1],p=Math.ceil(n[2]/2),d=p*Math.ceil(n[1]/2);return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${d}, ${p}, b, row, col);\n      return ${o.texture2D}(${a}, uv);\n    }\n  `}function R9(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r=\"get\"+a.charAt(0).toUpperCase()+a.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=w.squeezeShape(n),u=o;if(u.length<n.length){let f=cp(e,u),g=[\"row\",\"col\",\"depth\"];return`\n        ${up(f,t)}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${dp(g,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${i}, 1)));\n        ${pp(e)}\n      }\n    `;let p=e.shapeInfo.texShape,d=p[0],c=p[1],h=e.shapeInfo.flatOffset;if(c===s&&h==null)return t?`\n      float ${r}(int row, int col, int depth) {\n        int stride1 = ${a}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${a}TexShape[1], ${a}TexShape[0]);\n        return sampleTexture(${a}, uv);\n      }\n    `:`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${c}.0, ${d}.0);\n          return sampleTexture(${a}, uv);\n        }\n      `;if(c===i&&h==null)return t?`\n      float ${r}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${a}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);\n        return sampleTexture(${a}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}.0, ${d}.0);\n      return sampleTexture(${a}, uv);\n    }\n  `;let m=Jo(a);return t?`\n    float ${r}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${a}Shape[1] * ${a}Shape[2];\n      int stride1 = ${a}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${m};\n      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index);\n      return sampleTexture(${a}, uv);\n    }\n    `:`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${i} + depth + ${m};\n        vec2 uv = uvFromFlat(${d}, ${c}, index);\n        return sampleTexture(${a}, uv);\n      }\n  `}function M9(e,t){let n=e.name,a=\"get\"+n.charAt(0).toUpperCase()+n.slice(1),r=En();if(t)return`\n    vec4 ${a}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${n}, uv);\n    }\n  `;let s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],p=l[1],d=Math.ceil(s[i-1]/2),c=d*Math.ceil(s[i-2]/2),h=\"int b, int row, int col\",m=`b * ${c} + (row / 2) * ${d} + (col / 2)`;for(let f=2;f<i-1;f++)h=`int b${f}, `+h,c*=s[i-f-1],m=`b${f} * ${c} + `+m;return`\n    vec4 ${a}(${h}) {\n      int index = ${m};\n      int texR = index / ${p};\n      int texC = index - texR * ${p};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${u});\n      return ${r.texture2D}(${n}, uv);\n    }\n  `}function O9(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r=\"get\"+a.charAt(0).toUpperCase()+a.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:l,keptDims:u}=w.squeezeShape(n);if(l.length<n.length){let y=cp(e,l),x=[\"row\",\"col\",\"depth\",\"depth2\"];return`\n      ${up(y,t)}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${dp(x,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${s}, 1)));\n        ${pp(e)}\n      }\n    `;let p=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,c=d[0],h=d[1],m=`int stride2 = ${a}Shape[3];`,f=`int stride1 = ${a}Shape[2] * stride2;`,g=`int stride0 = ${a}Shape[1] * stride1;`;if(h===o&&p==null)return t?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        ${m}\n        ${f}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${a}TexShape[1], ${a}TexShape[0]);\n        return sampleTexture(${a}, uv);\n      }\n    `:`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${c}.0);\n        return sampleTexture(${a}, uv);\n      }\n    `;if(h===s&&p==null)return t?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${a}Shape[1] * ${a}Shape[2], ${a}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${a}TexShape[1], ${a}TexShape[0]);\n        return sampleTexture(${a}, uv);\n      }\n    `:`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${c}.0);\n        return sampleTexture(${a}, uv);\n      }\n    `;let b=Jo(a);return t?`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${m}\n      ${f}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index + ${b});\n      return sampleTexture(${a}, uv);\n    }\n  `:`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${c}, ${h}, index + ${b});\n      return sampleTexture(${a}, uv);\n    }\n  `}function P9(e){let t=e.shapeInfo.logicalShape,n=e.name,a=\"get\"+n.charAt(0).toUpperCase()+n.slice(1),r=t[4],s=t[3]*r,i=t[2]*s,o=t[1]*i,{newShape:l,keptDims:u}=w.squeezeShape(t);if(l.length<t.length){let f=cp(e,l),g=[\"row\",\"col\",\"depth\",\"depth2\",\"depth3\"];return`\n      ${up(f)}\n      float ${a}(int row, int col, int depth, int depth2, int depth3) {\n        return ${a}(${dp(g,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${s}, ${r})) +\n          depth3;\n        ${pp(e)}\n      }\n    `;let p=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,c=d[0],h=d[1];if(h===o&&p==null)return`\n      float ${a}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${s}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${c}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(h===r&&p==null)return`\n      float ${a}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${c}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;let m=Jo(n);return`\n    float ${a}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${s} +\n          depth2 * ${r} + depth3 + ${m};\n      vec2 uv = uvFromFlat(${c}, ${h}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}function L9(e){let t=e.shapeInfo.logicalShape,n=e.name,a=\"get\"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:s}=w.squeezeShape(t);if(r.length<t.length){let g=cp(e,r),b=[\"row\",\"col\",\"depth\",\"depth2\",\"depth3\",\"depth4\"];return`\n      ${up(g)}\n      float ${a}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${a}(${dp(b,s)});\n      }\n    `}let i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,p=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${p}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${pp(e)}\n      }\n    `;let d=e.shapeInfo.flatOffset,c=e.shapeInfo.texShape,h=c[0],m=c[1];if(m===p&&d==null)return`\n      float ${a}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(m===i&&d==null)return`\n      float ${a}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;let f=Jo(n);return`\n    float ${a}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${p} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${f};\n      vec2 uv = uvFromFlat(${h}, ${m}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}function pp(e){let t=e.name,n=w.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function z9(e,t){let n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r=\"get\"+a+\"AtOutCoords\",s=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=sA(e.shapeInfo.logicalShape,t.logicalShape),l=ht(i),u=i-s,p,d=[\"x\",\"y\",\"z\",\"w\",\"u\",\"v\"];s===0?p=\"\":i<2&&o.length>=1?p=\"coords = 0;\":p=o.map(g=>`coords.${d[g+u]} = 0;`).join(`\n`);let c=\"\";i<2&&s>0?c=\"coords\":c=e.shapeInfo.logicalShape.map((g,b)=>`coords.${d[b+u]}`).join(\", \");let h=\"return outputValue;\",m=w.sizeFromShape(e.shapeInfo.logicalShape)===1,f=w.sizeFromShape(t.logicalShape)===1;if(s===1&&!m&&!f)h=`\n      return vec4(outputValue.xy, outputValue.xy);\n    `;else if(m&&!f)i===1?h=`\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      `:h=`\n        return vec4(outputValue.x);\n      `;else if(o.length){let g=s-2,b=s-1;o.indexOf(g)>-1&&o.indexOf(b)>-1?h=\"return vec4(outputValue.x);\":o.indexOf(g)>-1?h=\"return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);\":o.indexOf(b)>-1&&(h=\"return vec4(outputValue.xx, outputValue.zz);\")}return`\n    vec4 ${r}() {\n      ${l} coords = getOutputCoords();\n      ${p}\n      vec4 outputValue = get${a}(${c});\n      ${h}\n    }\n  `}function W9(e,t){let n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r=\"get\"+a+\"AtOutCoords\",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&e.shapeInfo.flatOffset==null&&w.arraysEqual(i,s))return`\n      float ${r}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;let u=ht(l),p=sA(e.shapeInfo.logicalShape,t.logicalShape),d=l-o,c,h=[\"x\",\"y\",\"z\",\"w\",\"u\",\"v\"];o===0?c=\"\":l<2&&p.length>=1?c=\"coords = 0;\":c=p.map(f=>`coords.${h[f+d]} = 0;`).join(`\n`);let m=\"\";return l<2&&o>0?m=\"coords\":m=e.shapeInfo.logicalShape.map((f,g)=>`coords.${h[g+d]}`).join(\", \"),`\n    float ${r}() {\n      ${u} coords = getOutputCoords();\n      ${c}\n      return get${a}(${m});\n    }\n  `}function ht(e){if(e<=1)return\"int\";if(e===2)return\"ivec2\";if(e===3)return\"ivec3\";if(e===4)return\"ivec4\";if(e===5)return\"ivec5\";if(e===6)return\"ivec6\";throw Error(`GPU for rank ${e} is not yet supported`)}function tk(e,t,n){let{newShape:a,keptDims:r}=w.squeezeShape(t),s=t.length,i=e&&s===3&&t[0]===1,o=i?t.slice(1):a,l=!e&&s>1&&!w.arraysEqual(t,n)&&a.length<s||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:r}}function cp(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function dp(e,t){return t.map(n=>e[n]).join(\", \")}function B9(e,t,n,a){let r=n.map((p,d)=>{let c={logicalShape:p.shape,texShape:p.isUniform?null:p.texData.texShape,isUniform:p.isUniform,isPacked:p.isUniform?!1:p.texData.isPacked,flatOffset:null};return p.texData!=null&&p.texData.slice!=null&&p.texData.slice.flatOffset>0&&(c.flatOffset=p.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:c}}),s=r.map(p=>p.shapeInfo),i={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},o=s9(r,i,t),l=P_(e.gl,o),u=e.createProgram(l);return G().get(\"ENGINE_COMPILE_ONLY\")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i},lA(e,t,u)))}function lA(e,t,n){let a=[],r=[],s,i,o,l=null,u=null;u=e.getUniformLocation(n,\"NAN\",!1),G().getNumber(\"WEBGL_VERSION\")===1&&(l=e.getUniformLocation(n,\"INFINITY\",!1));let p=!1;for(let d of t.variableNames){let c={name:d,uniform:e.getUniformLocation(n,d,p),offset:e.getUniformLocation(n,`offset${d}`,p)};t.enableShapeUniforms&&(c.shape=e.getUniformLocation(n,`${d}Shape`,p),c.texShape=e.getUniformLocation(n,`${d}TexShape`,p)),a.push(c)}if(t.enableShapeUniforms&&(s=e.getUniformLocation(n,\"outShape\",p),o=e.getUniformLocation(n,\"outShapeStrides\",p),i=e.getUniformLocation(n,\"outTexShape\",p)),t.customUniforms)for(let d of t.customUniforms)r.push(e.getUniformLocation(n,d.name,p));return{variablesLocations:a,customUniformLocations:r,infLoc:l,nanLoc:u,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:i}}function nS(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,a)=>{let r=n.logicalShape,s=t[a],i=s.shape;if(!w.arraysEqual(r,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);if(n.isUniform&&s.isUniform)return;let o=n.texShape,l=s.isUniform?null:s.texData.texShape;if(!w.arraysEqual(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function V9(e,t,n,a,r){t.program.enableShapeUniforms||(nS(t.inShapeInfos,n),nS([t.outShapeInfo],[a]));let s=a.texData.texture,i=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),G().getNumber(\"WEBGL_VERSION\")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){let u=n[l],{uniform:p,offset:d,shape:c,texShape:h}=t.variablesLocations[l];if(c){let{uniformShape:m}=tk(t.program.packedInputs,u.shape,u.texData.texShape);switch(m.length){case 1:e.gl.uniform1iv(c,new Int32Array(m));break;case 2:e.gl.uniform2iv(c,new Int32Array(m));break;case 3:e.gl.uniform3iv(c,new Int32Array(m));break;case 4:e.gl.uniform4iv(c,new Int32Array(m));break;default:break}}if(h&&e.gl.uniform2i(h,u.texData.texShape[0],u.texData.texShape[1]),p!=null){if(u.isUniform){if(w.sizeFromShape(u.shape)<2)e.gl.uniform1f(p,u.uniformValues[0]);else{let m=u.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),e.gl.uniform1fv(p,m)}continue}u.texData.slice!=null&&d!=null&&e.gl.uniform1i(d,u.texData.slice.flatOffset),e.setInputMatrixTexture(u.texData.texture.texture,p,l)}}let o=t.outShapeLocation;if(o)switch(a.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(a.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(a.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(a.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(a.shape));break;default:break}if(t.outShapeStridesLocation){let l=w.computeStrides(a.shape);switch(a.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break;default:break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,a.texData.texShape[0],a.texData.texShape[1]),t.program.customUniforms&&r)for(let l=0;l<t.program.customUniforms.length;++l){let u=t.program.customUniforms[l],p=t.customUniformLocations[l],d=r[l];if(u.type===\"float\")e.gl.uniform1fv(p,d);else if(u.type===\"vec2\")e.gl.uniform2fv(p,d);else if(u.type===\"vec3\")e.gl.uniform3fv(p,d);else if(u.type===\"vec4\")e.gl.uniform4fv(p,d);else if(u.type===\"int\")e.gl.uniform1iv(p,d);else if(u.type===\"ivec2\")e.gl.uniform2iv(p,d);else if(u.type===\"ivec3\")e.gl.uniform3iv(p,d);else if(u.type===\"ivec4\")e.gl.uniform4iv(p,d);else throw Error(`uniform type ${u.type} is not supported yet.`)}e.executeProgram()}function U9(e,t,n){let a=\"\";t.concat(n).forEach(i=>{let o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){let l=i.texData.texShape,{useSqueezeShape:u,uniformShape:p,keptDims:d}=tk(e.packedInputs,i.shape,l),c=\"\",h=\"\",m=\"\";if(p.length===1&&e.packedInputs){let I=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];c=`${I[0]>1}_${I[1]>1}`}else if(p.length===2&&!e.packedInputs)h=`${p[0]>1}_${p[1]>1}`;else if(p.length>2&&!e.packedInputs){let I=w.computeStrides(p);m=`${I[0]===l[1]}_${I[I.length-1]===l[1]}`}let f=i.shape.length,g=p.length===2&&w.arraysEqual(i.shape,l),b=w.sizeFromShape(i.shape)===1,y=T.getBroadcastDims(i.shape,n.shape),x=!e.packedInputs&&f===n.shape.length&&w.arraysEqual(l,n.texData.texShape),v=e.packedInputs||p.length>2?\"\":`${l[0]>1}_${l[1]>1}`;a+=`${f}_${x}_${u?d:\"\"}_${p.length}_${b}_${y}_${g}_${c}_${h}_${m}_${v}_${o}`}else{let l=i.isUniform?\"uniform\":i.texData.texShape;a+=`${i.shape}_${l}_${o}`}});let r=e.userCode,s=e.constructor.name;return s+=\"_\"+a+\"_\"+r+`${G().getNumber(\"WEBGL_VERSION\")}`,s}function vn(e){return G().getBool(\"WEBGL_USE_SHAPES_UNIFORMS\")&&e<=4}var G9=class{constructor(e){this.variableNames=[\"A\"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Nc.DENSE,this.customUniforms=[{name:\"texShape\",type:\"ivec2\"}];let t=En();this.outputShape=e,this.enableShapeUniforms=vn(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Wf([\"r\",\"c\",\"d\"],e):Zo([\"r\",\"c\",\"d\"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}},H9=class{constructor(e){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Nc.DENSE,this.customUniforms=[{name:\"texShape\",type:\"ivec2\"}];let t=En();this.outputShape=e,this.enableShapeUniforms=vn(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Wf([\"r\",\"c\",\"d\"],e):Zo([\"r\",\"c\",\"d\"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}},j9=class{constructor(e){this.variableNames=[\"A\"],this.outTexUsage=ca.DOWNLOAD;let t=En();this.outputShape=e,this.userCode=`\n      ${rA}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}},q9=class{constructor(e){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=ca.DOWNLOAD;let t=En();this.outputShape=e,this.userCode=`\n      ${rA}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}},K9={R:0,G:1,B:2,A:3},aS=class{constructor(e,t=!1,n=\"RGBA\"){this.variableNames=[\"A\"],this.customUniforms=[{name:\"texShape\",type:\"ivec2\"}];let a=En();this.outputShape=e,this.enableShapeUniforms=vn(this.outputShape.length);let r=\"result\";t&&(r=\"floor(result * 255. + 0.5)\");let s=\"\";for(let i=0;i<n.length;i++){let o=n[i];s+=`\n          if(offset == ${i}) {\n            result = values[${K9[o]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?ek():Q1(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${a.texture2D}(A, uv);\n          ${s}\n        }\n        ${a.output} = vec4(${r}, 0., 0., 0.);\n      }\n    `}},X9=class{constructor(e,t=!1){this.variableNames=[\"A\"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:\"texShape\",type:\"ivec2\"}];let n=En();this.outputShape=e,this.enableShapeUniforms=vn(this.outputShape.length);let a=\"\",r=\"result\";t&&(r=\"floor(result * 255. + 0.5)\");for(let s=0;s<=1;s++)for(let i=0;i<=1;i++){let o=s*2+i;a+=`\n          localCoords = coords;\n          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?\"outShape[2]\":`${e[2]}`}) {\n          localCoords[2] += ${i};\n          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?\"outShape[1]\":`${e[1]}`}) {\n            localCoords[1] += ${s};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${o}] = values[0];\n            } else if (offset == 1) {\n              result[${o}] = values[1];\n            } else if (offset == 2) {\n              result[${o}] = values[2];\n            } else {\n              result[${o}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?ek():Q1(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${a}\n\n          ${n.output} = ${r};\n        }\n    `}},uA={};_e(uA,{bindVertexProgramAttributeStreams:()=>yA,createBufferFromOutputTexture:()=>wA,createFloat16MatrixTexture:()=>mA,createFloat16PackedMatrixTexture:()=>bA,createFloat32MatrixTexture:()=>hA,createIndexBuffer:()=>dA,createPackedMatrixTexture:()=>gA,createUnsignedBytesMatrixTexture:()=>fA,createVertexBuffer:()=>cA,createVertexShader:()=>pA,downloadByteEncodedFloatMatrixFromOutputTexture:()=>IA,downloadFloat32MatrixFromBuffer:()=>kA,downloadMatrixFromPackedOutputTexture:()=>NA,downloadPackedMatrixFromBuffer:()=>SA,getInternalFormatForFloat16MatrixTexture:()=>ak,getInternalFormatForFloat16PackedMatrixTexture:()=>ik,getInternalFormatForFloat32MatrixTexture:()=>nk,getInternalFormatForPackedMatrixTexture:()=>sk,getInternalFormatForUnsignedBytesMatrixTexture:()=>rk,uploadDenseMatrixToTexture:()=>xA,uploadPixelDataToTexture:()=>vA});function pA(e){let t=En(),n=`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;return O_(e,n)}function cA(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return W_(e,t)}function dA(e){let t=new Uint16Array([0,1,2,2,1,3]);return B_(e,t)}function Ad(e,t,n,a,r,s){U_(t,n);let i=V_(e),o=e.TEXTURE_2D;return de(e,()=>e.bindTexture(o,i)),de(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),de(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),de(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),de(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),G().getNumber(\"WEBGL_VERSION\")===1?de(e,()=>e.texImage2D(o,0,a,t,n,0,r,s,null)):de(e,()=>e.texStorage2D(o,1,a,t,n)),de(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function nk(e){return e.internalFormatFloat}function hA(e,t,n,a){let[r,s]=_d(t,n);return Ad(e,r,s,nk(a),a.textureFormatFloat,e.FLOAT)}function ak(e){return e.internalFormatHalfFloat}function mA(e,t,n,a){let[r,s]=_d(t,n);return Ad(e,r,s,ak(a),a.textureFormatFloat,a.textureTypeHalfFloat)}function rk(e){return e.downloadTextureFormat}function fA(e,t,n,a){let[r,s]=_d(t,n);return Ad(e,r,s,rk(a),e.RGBA,e.UNSIGNED_BYTE)}function sk(e){return e.internalFormatPackedFloat}function gA(e,t,n,a){let[r,s]=op(t,n);return Ad(e,r,s,sk(a),e.RGBA,e.FLOAT)}function ik(e){return e.internalFormatPackedHalfFloat}function bA(e,t,n,a){let[r,s]=op(t,n);return Ad(e,r,s,ik(a),e.RGBA,a.textureTypeHalfFloat)}function yA(e,t,n){return de(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),pv(e,t,\"clipSpacePos\",n,3,20,0)&&pv(e,t,\"uv\",n,2,20,12)}function xA(e,t,n,a,r,s){de(e,()=>e.bindTexture(e.TEXTURE_2D,t));let i,o,l;r instanceof Uint8Array?(i=new Uint8Array(n*a*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*a*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(r),G().getNumber(\"WEBGL_VERSION\")===2?de(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,a,e.RGBA,o,i)):de(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,a,0,e.RGBA,o,i)),de(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function vA(e,t,n){de(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?G().getNumber(\"WEBGL_VERSION\")===2?de(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):de(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):G().getNumber(\"WEBGL_VERSION\")===2?de(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):de(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),de(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function wA(e,t,n,a){let r=e.createBuffer();de(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r));let s=4*4*t*n;return de(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ)),de(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),de(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),r}function kA(e,t,n){let a=e,r=new Float32Array(n);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,r),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),r}function IA(e,t,n,a){let[r,s]=_d(t,n),i=4,o=new Uint8Array(HJ(t*n,i));return de(e,()=>e.readPixels(0,0,r,s,a.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function SA(e,t,n,a,r,s,i,o){let l=e,u=new Float32Array(jJ(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function NA(e,t,n){let a=new Float32Array(t*n*4);return de(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,a)),a}var Wh=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=G().getNumber(\"WEBGL_VERSION\");if(e!=null?(this.gl=e,D_(t,e)):this.gl=ja(t),e=this.gl,G().getNumber(\"WEBGL_VERSION\")===2){let r=e;this.createVertexArray=()=>de(r,()=>r.createVertexArray()),this.bindVertexArray=s=>de(r,()=>r.bindVertexArray(s)),this.deleteVertexArray=s=>de(r,()=>r.deleteVertexArray(s)),this.getVertexArray=()=>de(r,()=>r.getParameter(r.VERTEX_ARRAY_BINDING))}else if(e!=null){let r=e.getExtension(\"OES_vertex_array_object\");if(r==null)throw new Error(\"All WebGL1 implementations are expected to offer OES_vertex_array_object.\");this.createVertexArray=()=>de(e,()=>r.createVertexArrayOES()),this.bindVertexArray=s=>de(e,()=>r.bindVertexArrayOES(s)),this.deleteVertexArray=s=>de(e,()=>r.deleteVertexArrayOES(s)),this.getVertexArray=()=>de(e,()=>e.getParameter(r.VERTEX_ARRAY_BINDING_OES))}let n=\"WEBGL_color_buffer_float\",a=\"EXT_color_buffer_half_float\";if(this.parallelCompilationExtension=this.gl.getExtension(\"KHR_parallel_shader_compile\"),G().getNumber(\"WEBGL_VERSION\")===1){let r=\"OES_texture_float\",s=\"OES_texture_half_float\";if(this.textureFloatExtension=rc(this.gl,r),da(this.gl,s))this.textureHalfFloatExtension=rc(this.gl,s);else if(G().get(\"WEBGL_FORCE_F16_TEXTURES\"))throw new Error(\"GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.\");if(this.colorBufferFloatExtension=this.gl.getExtension(n),da(this.gl,a))this.colorBufferHalfFloatExtension=rc(this.gl,a);else if(G().get(\"WEBGL_FORCE_F16_TEXTURES\"))throw new Error(\"GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.\")}else if(n=\"EXT_color_buffer_float\",da(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(da(this.gl,a))this.colorBufferHalfFloatExtension=this.gl.getExtension(a);else throw new Error(\"GL context does not support color renderable floats\");this.vertexBuffer=cA(this.gl),this.indexBuffer=dA(this.gl),this.framebuffer=G_(this.gl),this.textureConfig=Z1(this.gl,this.textureHalfFloatExtension)}get debug(){return G().getBool(\"DEBUG\")}dispose(){if(this.disposed)return;this.program!=null&&console.warn(\"Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing.\"),this.outputTexture!=null&&console.warn(\"Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.\");let e=this.gl;de(e,()=>e.finish()),de(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),de(e,()=>e.deleteFramebuffer(this.framebuffer)),de(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),de(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),de(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),hA(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),mA(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),fA(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),vA(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,a){this.throwIfDisposed(),xA(this.gl,e,t,n,a,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),bA(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),gA(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(cv(this.gl,this.framebuffer),this.outputTexture=null),de(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>IA(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,a,r,s){return SA(this.gl,e,t,n,a,r,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return kA(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let a=wA(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(G().getBool(\"WEBGL_FENCE_API_ENABLED\")){let a=e,r=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let s=a.clientWaitSync(r,0,0);return s===a.ALREADY_SIGNALED||s===a.CONDITION_SATISFIED},t=r}else G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>NA(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=pA(t));let n=L_(t);de(t,()=>t.attachShader(n,this.vertexShader)),de(t,()=>t.attachShader(n,e)),z_(t,n);let a=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&Oh(t,a),a}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;de(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),yA(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(de(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Oh(this.gl,this.program),de(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?j_(this.gl,e,t):q_(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),de(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),K_(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[a,r]=op(t,n);this.setOutputMatrixTextureDriver(e,a,r)}setOutputMatrixWriteRegion(e,t,n,a){this.setOutputMatrixWriteRegionDriver(n,e,a,t)}setOutputPackedMatrixWriteRegion(e,t,n,a){throw new Error(\"setOutputPackedMatrixWriteRegion not implemented.\")}debugValidate(){this.program!=null&&Oh(this.gl,this.program),sc(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,\"VAO changed between setProgram and executeProgram!\"),this.debugValidate()}de(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),de(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=rc(this.gl,G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")===2?\"EXT_disjoint_timer_query_webgl2\":\"EXT_disjoint_timer_query\")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")===2){let n=this.gl,a=this.getQueryTimerExtensionWebGL2(),r=n.createQuery();return n.beginQuery(a.TIME_ELAPSED_EXT,r),r}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await w.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"))),this.getQueryTime(e,G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,a=this.getQueryTimerExtensionWebGL2(),r=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(a.GPU_DISJOINT_EXT)),r&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),a=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),a&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=Y9(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;\"setTimeoutCustom\"in G().platform&&(n=G().platform.setTimeoutCustom.bind(G().platform)),w.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Ph(this.gl,e,this.framebuffer),this.debug&&sc(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Ph(this.gl,this.outputTexture,this.framebuffer),this.debug&&sc(this.gl)):cv(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let a=this.gl;Ph(a,e,this.framebuffer),this.debug&&sc(a),this.outputTexture=e,de(a,()=>a.viewport(0,0,t,n)),de(a,()=>a.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,a){this.throwIfDisposed(),de(this.gl,()=>this.gl.scissor(e,t,n,a))}throwIfDisposed(){if(this.disposed)throw new Error(\"Attempted to use disposed GPGPUContext.\")}throwIfNoProgram(){if(this.program==null)throw new Error(\"No GPU program is currently set.\")}};function Y9(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:Z9,bincountImpl:TA,bincountReduceImpl:J9,bitwiseAndImpl:Q9,castImpl:eQ,ceilImpl:tQ,concatImpl:nQ,equalImpl:aQ,expImpl:rQ,expm1Impl:sQ,floorImpl:iQ,gatherNdImpl:oQ,gatherV2Impl:lQ,greaterImpl:uQ,greaterEqualImpl:pQ,lessImpl:cQ,lessEqualImpl:dQ,linSpaceImpl:hQ,logImpl:mQ,maxImpl:fQ,maximumImpl:gQ,minimumImpl:bQ,multiplyImpl:yQ,negImpl:xQ,notEqualImpl:vQ,prodImpl:wQ,raggedGatherImpl:kQ,raggedRangeImpl:IQ,raggedTensorToTensorImpl:SQ,rangeImpl:NQ,rsqrtImpl:TQ,scatterImpl:CQ,sigmoidImpl:EQ,simpleAbsImpl:CA,sliceImpl:_Q,sparseFillEmptyRowsImpl:AQ,sparseReshapeImpl:FQ,sparseSegmentReductionImpl:EA,sqrtImpl:$Q,staticRegexReplaceImpl:DQ,stridedSliceImpl:RQ,stringNGramsImpl:MQ,stringSplitImpl:OQ,stringToHashBucketFastImpl:PQ,subImpl:LQ,tileImpl:zQ,topKImpl:WQ,transposeImpl:ok,uniqueImpl:BQ}=M1;function _A(e,t){return[\"x\",\"y\",\"z\",\"w\",\"u\",\"v\"].slice(0,t).map(n=>`${e}.${n}`)}function In(e,t){return t===1?[e]:_A(e,t)}function VQ(e,t){if(e===1)return\"rc\";let n=\"\";for(let a=0;a<e;a++)n+=t[a],a<e-1&&(n+=\",\");return n}var UQ=class{constructor(e){if(this.variableNames=[\"A\"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=vn(this.outputShape.length),this.rank===0)this.userCode=`\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      `;else{let t=In(\"rc\",this.rank),n=ht(this.rank),a=this.getOutOfBoundsCondition(t),r=this.getSetup(t),s=this.getOutput(t);this.userCode=`\n        void main() {\n          ${n} rc = getOutputCoords();\n\n          if(${a}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${s}));\n          }\n        }\n      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let a=0;a<=1;a++){let r=`${n===0?\"r\":\"rp1\"}, ${a===0?\"c\":\"cp1\"}`;for(let s=2;s<this.rank;s++)r=`${e[e.length-1-s]},`+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?\"outShape\":this.outputShape[0]}`;let t=\"\";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+=\"||\");return t}getSetup(e){if(this.rank===1)return\"\";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],a=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${a};\n    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?\"outShape\":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}},AA=class{constructor(e,t){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:\"inputShape\",type:\"ivec3\"}],this.outputShape=e,this.enableShapeUniforms=vn(this.outputShape.length);let n=\"\";for(let a=0;a<4;a++){let r=\"thisRC = rc;\";a%2===1&&(r+=\"thisRC.z += 1;\"),a>1&&(r+=\"thisRC.y += 1;\"),n+=`\n        ${r}\n        ${a>0?\"if(thisRC.y < rows && thisRC.z < cols){\":\"\"}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${a}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${a>0?\"}\":\"\"}\n      `}this.userCode=`\n      ${GQ(t,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?ek():Q1(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?\"outShape[1]\":e[1]};\n        int cols = ${this.enableShapeUniforms?\"outShape[2]\":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}};function GQ(e,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?r9([\"r\",\"c\",\"d\"],\"inputShape\"):Zo([\"r\",\"c\",\"d\"],e)}\n      return ivec3(r, c, d);\n    }\n  `}var HQ=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let a=sS(t,n),r=iS(e,a,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);let s=rS(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();let o=this.freeTextures[r].pop();return this.usedTextures[r].push(o),o}let i;return a===cn.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===cn.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===cn.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===cn.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===cn.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(i),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),i}releaseTexture(e,t,n,a){if(this.freeTextures==null)return;let r=sS(n,a),s=iS(t,r,a);s in this.freeTextures||(this.freeTextures[s]=[]);let i=rS(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,a),o=G().getNumber(\"WEBGL_DELETE_TEXTURE_THRESHOLD\");o!==-1&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[s],u=l&&l.indexOf(e);if(u==null||u<0)throw new Error(\"Cannot release a texture that was never provided by this texture manager\");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log(\"Free/Used\",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function jQ(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function rS(e,t,n,a,r){let s=qQ(t,a),i;if(r){let[l,u]=op(e[0],e[1]);i=l*u}else{let[l,u]=_d(e[0],e[1]);i=l*u}let o=jQ(n,s);return i*o}function qQ(e,t){switch(e){case cn.PACKED_2X2_FLOAT32:return sk(t);case cn.PACKED_2X2_FLOAT16:return ik(t);case cn.UNPACKED_FLOAT32:return nk(t);case cn.UNPACKED_FLOAT16:return ak(t);case cn.PACKED_4X1_UNSIGNED_BYTE:return rk(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function KQ(e){return G().getBool(\"WEBGL_RENDER_FLOAT32_ENABLED\")?e?cn.PACKED_2X2_FLOAT32:cn.UNPACKED_FLOAT32:e?cn.PACKED_2X2_FLOAT16:cn.UNPACKED_FLOAT16}function sS(e,t){if(e===ca.UPLOAD)return cn.PACKED_2X2_FLOAT32;if(e===ca.RENDER||e==null)return KQ(t);if(e===ca.DOWNLOAD||e===ca.PIXELS)return cn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function iS(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var rr=class{constructor(e,t){this.variableNames=[\"A\"],this.outputShape=e,this.enableShapeUniforms=vn(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},Da=\"if (isnan(x)) return x;\",XQ=\"return x;\",oS=\"return abs(x);\",YQ=\"return (x >= 0.0) ? x : (exp(x) - 1.0);\",ZQ=Da+`\n  return (x < 0.0) ? 0.0 : x;\n`,JQ=Da+`\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n`,Yr=\"return x;\",QQ=\"return 1.0 / (1.0 + exp(-1.0 * x));\",eee=\"return x;\",tee=`\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n`,nee=`\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`,aee=`\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`,ree=\"return 1.0 / (1.0 + exp(-1.0 * x));\",ts=class{constructor(e,t){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=vn(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},see=class{constructor(e){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=vn(this.outputShape.length);let t=e.length,n=In(\"rc\",t),a=ht(t),r=VQ(t,n),s=n.slice(-2),i=t<=1?\"rc\":`vec2(${s.join(\",\")})`;this.userCode=`\n      void main() {\n        ${a} rc = getOutputCoords();\n        vec4 packedInput = getA(${r});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}},iee=mr.whereImpl,oee=1e-7,lee=1e-4,yx={};function uee(e){return e in yx||(yx[e]={}),yx[e]}var pee=G().getNumber(\"CPU_HANDOFF_SIZE_THRESHOLD\"),cee=600;function dee(){return G().global.screen==null?1024:G().global.screen.height*G().global.screen.width*window.devicePixelRatio*cee/1024/1024}var lk=class FA extends Fc{nextDataId(){return FA.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!G().getBool(\"HAS_WEBGL\"))throw new Error(\"WebGL is not supported on this device\");let n;if(t!=null){if(t instanceof Wh)n=t;else{let a=ja(G().getNumber(\"WEBGL_VERSION\"),t);n=new Wh(a)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let a=ja(G().getNumber(\"WEBGL_VERSION\"));n=new Wh(a),this.binaryCache=uee(G().getNumber(\"WEBGL_VERSION\")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new HQ(this.gpgpu),this.numMBBeforeWarning=dee(),this.texData=new ym(this,Ta())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,a,r,s,i){let o=this.makeTensorInfo(n,a),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[r,s]},l.texShape=[r,s];let u=ic(n),p=new aS(u,!1,i),d=this.runWebGLProgram(p,[o],a,[[r,s]]);return d.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(o),d.dataId}write(t,n,a){if((G().getBool(\"WEBGL_CHECK_NUMERICAL_PROBLEMS\")||G().getBool(\"DEBUG\"))&&this.checkNumericalProblems(t),a===\"complex64\"&&t!=null)throw new Error(\"Cannot write to a complex64 dtype. Please use tf.complex(real, imag).\");let r={id:this.nextDataId()};return this.texData.set(r,{shape:n,dtype:a,values:t,usage:ca.UPLOAD,refCount:1}),r}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){let n=this.texData.get(t);n.refCount--}}move(t,n,a,r,s){if(G().getBool(\"DEBUG\")&&this.checkNumericalProblems(n),r===\"complex64\")throw new Error(\"Cannot write to a complex64 dtype. Please use tf.complex(real, imag).\");this.texData.set(t,{shape:a,dtype:r,values:n,usage:ca.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let n=this.texData.get(t),{values:a,dtype:r,complexTensorInfos:s,slice:i,shape:o,isPacked:l}=n;if(i!=null){let c;l?c=new ts(o,Yr):c=new rr(o,Yr);let h=this.runWebGLProgram(c,[{dataId:t,shape:o,dtype:r}],r),m=this.readSync(h.dataId);return this.disposeIntermediateTensorInfo(h),m}if(a!=null)return this.convertAndCacheOnCPU(t);if(r===\"string\")return a;let u=this.activeTimers!=null,p;u&&(p=w.now());let d;if(r===\"complex64\"){let c=this.readSync(s.real.dataId),h=this.readSync(s.imag.dataId);d=T.mergeRealAndImagArrays(c,h)}else d=this.getValuesFromTexture(t);return u&&(this.downloadWaitMs+=w.now()-p),this.convertAndCacheOnCPU(t,d)}async read(t){if(this.pendingRead.has(t)){let m=this.pendingRead.get(t);return new Promise(f=>m.push(f))}let n=this.texData.get(t),{values:a,shape:r,slice:s,dtype:i,complexTensorInfos:o,isPacked:l}=n;if(s!=null){let m;l?m=new ts(r,Yr):m=new rr(r,Yr);let f=this.runWebGLProgram(m,[{dataId:t,shape:r,dtype:i}],i),g=this.read(f.dataId);return this.disposeIntermediateTensorInfo(f),g}if(a!=null)return this.convertAndCacheOnCPU(t);if(G().getBool(\"DEBUG\")&&!G().getBool(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\")&&G().getNumber(\"WEBGL_VERSION\")===2)throw new Error(\"tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.\");let u=null,p;if(i!==\"complex64\"&&G().get(\"WEBGL_BUFFER_SUPPORTED\")){p=this.decode(t);let m=this.texData.get(p.dataId);u=this.gpgpu.createBufferFromTexture(m.texture.texture,...Ah(r))}this.pendingRead.set(t,[]),i!==\"complex64\"&&await this.gpgpu.createAndWaitForFence();let d;if(i===\"complex64\"){let m=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),f=m[0],g=m[1];d=T.mergeRealAndImagArrays(f,g)}else if(u==null)d=this.getValuesFromTexture(t);else{let m=w.sizeFromShape(r);d=this.gpgpu.downloadFloat32MatrixFromBuffer(u,m)}if(p!=null&&this.disposeIntermediateTensorInfo(p),u!=null){let m=this.gpgpu.gl;de(m,()=>m.deleteBuffer(u))}let c=this.convertAndCacheOnCPU(t,d),h=this.pendingRead.get(t);return this.pendingRead.delete(t),h.forEach(m=>m(c)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&Ta().removeDataId(t,this),this.pendingDeletes--),c}readToGPU(t,n={}){let a=this.texData.get(t),{values:r,shape:s,slice:i,dtype:o,isPacked:l,texture:u}=a;if(o===\"complex64\")throw new Error(\"Does not support reading texture for complex64 dtype.\");if(i!=null){let h;l?h=new ts(s,Yr):h=new rr(s,Yr);let m=this.runWebGLProgram(h,[{dataId:t,shape:s,dtype:o}],o),f=this.readToGPU(m,n);return this.disposeIntermediateTensorInfo(m),f}if(u==null)throw r!=null?new Error(\"Data is not on GPU but on CPU.\"):new Error(\"There is no data on GPU or CPU.\");let p=this.decode(t,n.customTexShape),d=Ta().makeTensorFromTensorInfo(p),c=this.texData.get(p.dataId);return Object.assign({tensorRef:d},c.texture)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype===\"string\")try{let a=n.map(r=>w.decodeString(r));return Oe(t.shape,t.dtype,a)}catch(a){throw new Error(\"Failed to decode encoded string bytes into utf-8\")}return Oe(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let n=0;n<t.length;n++){let a=t[n];if(!R_(a))throw G().getBool(\"WEBGL_RENDER_FLOAT32_CAPABLE\")?Error(`The value ${a} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${a} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:n,dtype:a,isPacked:r}=this.texData.get(t),s=w.sizeFromShape(n);if(G().getBool(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\")){let c=this.decode(t),h=this.texData.get(c.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(h.texture.texture,...Ah(n)).subarray(0,s);return this.disposeIntermediateTensorInfo(c),m}let i=G().getBool(\"WEBGL_PACK\")&&r===!0,o=i?ic(n):n,l=i?new q9(o):new j9(o),u=this.runWebGLProgram(l,[{shape:o,dtype:a,dataId:t}],\"float32\"),p=this.texData.get(u.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(p.texture.texture,p.texShape[0],p.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(u),d}timerAvailable(){return G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\")>0}time(t){let n=this.activeTimers,a=[],r=!1;this.programTimersStack==null?(this.programTimersStack=a,r=!0):this.activeTimers.push(a),this.activeTimers=a,t();let s=w.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=w.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,r&&(this.programTimersStack=null);let o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\")>0){let l=await Promise.all(s);o.kernelMs=w.sum(l),o.getExtraProfileInfo=()=>l.map((u,p)=>({name:i[p],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(\", \")}else o.kernelMs={error:\"WebGL query timers are not supported in this environment.\"};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\")>0?this.gpgpu.beginQuery():{startMs:w.now(),endMs:null}}endTimer(t){return G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\")>0?(this.gpgpu.endQuery(),t):(t.endMs=w.now(),t)}async getQueryTime(t){if(G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\")>0)return this.gpgpu.waitForQueryAndGetTime(t);let n=t;return n.endMs-n.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:a}=this.texData.get(t);return a!=null&&(this.disposeData(a.real.dataId,n),this.disposeData(a.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:n,dtype:a,texShape:r,usage:s,isPacked:i,slice:o}=this.texData.get(t),l=o&&o.origDataId||t,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(r,a),this.textureManager.releaseTexture(n,r,s,i)));let p=this.texData.get(t);p.texture=null,p.texShape=null,p.isPacked=!1,p.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=pee){return G().getBool(\"WEBGL_CPU_FORWARD\")&&t.every(a=>this.texData.get(a.dataId).texture==null&&w.sizeFromShape(a.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){T.warn(\"tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead\");let n=t.dataSync();return iee(t.shape,n)}packedUnaryOp(t,n,a){let r=new ts(t.shape,n),s=this.compileAndRun(r,[t],a);return Ta().makeTensorFromTensorInfo(s)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!==\"complex64\"){let r=CA(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,r)}if(G().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\"))return this.packedUnaryOp(t,oS,t.dtype);let n=new rr(t.shape,oS),a=this.compileAndRun(n,[t]);return Ta().makeTensorFromTensorInfo(a)}makeTensorInfo(t,n,a){let r;if(n===\"string\"&&a!=null&&a.length>0&&w.isString(a[0])){let s=a.map(i=>w.encodeString(i));r=this.write(s,t,n)}else r=this.write(a,t,n);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:n}}makeOutput(t,n,a){return Ta().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,a),this)}unpackTensor(t){let n=new see(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){let n=new UQ(t.shape);return this.runWebGLProgram(n,[t],t.dtype,null,!0)}packedReshape(t,n){let a=[vi(t.shape),...wi(t.shape)],r={dtype:t.dtype,shape:a,dataId:t.dataId},s=[vi(n),...wi(n)],i=new AA(s,a),o=!0,l=[a],u=this.runWebGLProgram(i,[r],t.dtype,l,o);return{dataId:u.dataId,shape:n,dtype:u.dtype}}decode(t,n){let a=this.texData.get(t),{isPacked:r,shape:s,dtype:i}=a;if(n!=null){let c=w.sizeFromShape(s),h=n[0]*n[1]*4;w.assert(c<=h,()=>\"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.\")}let o=ic(s),l;r?l=new H9(o):l=new G9(o);let u=!0,p=[n!=null?n:Ah(o)],d=this.runWebGLProgram(l,[{shape:o,dtype:i,dataId:t}],i,p,u,n);return{dtype:i,shape:s,dataId:d.dataId}}runWebGLProgram(t,n,a,r,s=!1,i){let o=this.makeTensorInfo(t.outputShape,a),l=this.texData.get(o.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===Nc.DENSE){let b=i!=null?i:Ah(t.outputShape);l.texShape=b.map(y=>y*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),w.sizeFromShape(o.shape)===0)return l.values=w.getTypedArrayFromDType(o.dtype,0),o;let u=[],p=n.map(b=>{if(b.dtype===\"complex64\")throw new Error(\"GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.\");let y=this.texData.get(b.dataId);if(y.texture==null){if(!t.packedInputs&&w.sizeFromShape(b.shape)<=G().getNumber(\"WEBGL_SIZE_UPLOAD_UNIFORM\"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:y.values};t.packedInputs&&(y.isPacked=!0,y.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!y.isPacked!=!!t.packedInputs)b=y.isPacked?this.unpackTensor(b):this.packTensor(b),u.push(b),y=this.texData.get(b.dataId);else if(y.isPacked&&!Tc(y.shape,b.shape)){let x=b,v=b.shape;b.shape=y.shape,b=this.packedReshape(b,v),u.push(b),y=this.texData.get(b.dataId),x.shape=v}return{shape:b.shape,texData:y,isUniform:!1}});this.uploadToGPU(o.dataId);let d={shape:o.shape,texData:l,isUniform:!1},c=U9(t,p,d),h=this.getAndSaveBinary(c,()=>B9(this.gpgpu,t,p,d)),m=this.activeTimers!=null,f;m&&(f=this.startTimer()),G().get(\"ENGINE_COMPILE_ONLY\")||V9(this.gpgpu,h,p,d,r),u.forEach(b=>this.disposeIntermediateTensorInfo(b)),m&&(f=this.endTimer(f),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(f)}));let g=G().getNumber(\"WEBGL_FLUSH_THRESHOLD\");if(g>0){let b=w.now();b-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!G().getBool(\"WEBGL_LAZILY_UNPACK\")&&l.isPacked&&s===!1){let b=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),b}return o}compileAndRun(t,n,a,r,s=!1){return a=a||n[0].dtype,this.runWebGLProgram(t,n,a,r,s)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(G().getBool(\"IS_TEST\")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!=\"undefined\"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=O(()=>{if(!G().get(\"WEBGL_RENDER_FLOAT32_ENABLED\")){let t=G().getBool(\"DEBUG\");G().set(\"DEBUG\",!1);let n=this.abs(xe(1e-8)).dataSync()[0];if(G().set(\"DEBUG\",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?oee:lee}uploadToGPU(t){let n=this.texData.get(t),{shape:a,dtype:r,values:s,texture:i,usage:o,isPacked:l}=n;if(i!=null)return;let u=this.activeTimers!=null,p;u&&(p=w.now());let d=n.texShape;if(d==null&&(d=Z_(a,l),n.texShape=d),s!=null){let c=ic(a),h,m=d[1],f=d[0],g=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(l||!g)&&([m,f]=op(d[0],d[1])),l?h=new X9(c,g):h=new aS(c,g);let b=g?[f,m]:d,y=this.makeTensorInfo(b,r),x=this.texData.get(y.dataId);g?x.usage=ca.PIXELS:x.usage=ca.UPLOAD,x.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y.dataId),m,f,s);let v=[[f,m]],I=this.runWebGLProgram(h,[y],r,v,!0),N=this.texData.get(I.dataId);n.texShape=N.texShape,n.isPacked=N.isPacked,n.usage=N.usage,G().get(\"ENGINE_COMPILE_ONLY\")?this.disposeData(I.dataId):(n.texture=N.texture,n.values=null,this.texData.delete(I.dataId)),this.disposeIntermediateTensorInfo(y),u&&(this.uploadWaitMs+=w.now()-p)}else{let c=this.acquireTexture(d,o,r,l);n.texture=c}}convertAndCacheOnCPU(t,n){let a=this.texData.get(t),{dtype:r}=a;return n!=null&&(a.values=hee(n,r)),a.values}acquireTexture(t,n,a,r){if(this.numBytesInGPU+=this.computeBytes(t,a),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,r)}computeBytes(t,n){return t[0]*t[1]*w.bytesPerElement(n)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,n]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(n));return Promise.all(t)}else{for(let[,n]of Object.entries(this.binaryCache)){let a=new Promise(r=>{try{this.checkCompletion_(n),r(!0)}catch(s){throw s}});t.push(a)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await Zw(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(J1(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error(\"Failed to compile fragment shader.\")):new Error(\"Failed to link vertex and fragment shaders.\");return!0}getUniformLocations(){for(let t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);let{variablesLocations:n,customUniformLocations:a,infLoc:r,nanLoc:s,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:l}=lA(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=n,t.customUniformLocations=a,t.infLoc=r,t.nanLoc=s,t.outShapeLocation=i,t.outShapeStridesLocation=o,t.outTexShapeLocation=l}}createTensorFromGPUData(t,n,a){t.channels=t.channels||\"RGBA\";let{texture:r,height:s,width:i,channels:o}=t,l=Ta().backend;if(!l.gpgpu.gl.isTexture(r))throw new Error(\"The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.\");let u=l.writeTexture(r,n,a,s,i,o);return Ta().makeTensorFromDataId(u,n,a,l)}};lk.nextDataId=0;function hee(e,t){if(t===\"float32\"||t===\"complex64\")return e;if(t===\"int32\"||t===\"bool\"){let n=t===\"int32\"?new Int32Array(e.length):new Uint8Array(e.length);for(let a=0;a<n.length;++a)n[a]=Math.round(e[a]);return n}else throw new Error(`Unknown dtype ${t}`)}var mee=\"4.22.0\";function $A(){G().set(\"WEBGL_FORCE_F16_TEXTURES\",!0)}ad.isBrowser()&&Om(\"webgl\",()=>new lk,2);var fee={forceHalfFloat:$A},uk=`\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n`,ki=class{constructor(e,t,n){this.variableNames=[\"A\",\"B\"],this.outputShape=T.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=vn(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}},Qo=`\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n`,hp=class{constructor(e,t,n,a=!1){this.variableNames=[\"A\",\"B\"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=T.assertAndGetBroadcastShape(t,n);let r=this.outputShape.length;this.enableShapeUniforms=vn(r);let s=\"\";if(a)if(r===0||w.sizeFromShape(this.outputShape)===1)s=`\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        `;else if(s=`\n          ${ht(r)} coords = getOutputCoords();\n        `,r===1)this.enableShapeUniforms?s+=`\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `:s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{let i=In(\"coords\",r);this.enableShapeUniforms?s+=`\n            bool nextRowOutOfBounds =\n              (${i[r-2]} + 1) >= outShape[${r} - 2];\n            bool nextColOutOfBounds =\n              (${i[r-1]} + 1) >= outShape[${r} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:s+=`\n            bool nextRowOutOfBounds =\n              (${i[r-2]} + 1) >= ${this.outputShape[r-2]};\n            bool nextColOutOfBounds =\n              (${i[r-1]} + 1) >= ${this.outputShape[r-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}};function ta(e){let{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}var gee={kernelName:eo,backendName:\"webgl\",kernelFunc:ta};function $s(e){let{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.makeTensorInfo(a.shape,\"complex64\"),i=n.texData.get(s.dataId),o=ta({inputs:{x:a},backend:n}),l=ta({inputs:{x:r},backend:n});return i.complexTensorInfos={real:o,imag:l},s}var bee={kernelName:wm,backendName:\"webgl\",kernelFunc:$s},DA=\"return (a < 0.) ? b * a : a;\",RA=`\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n`;function yee(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:s}=a,i=n.makeTensorInfo([],\"float32\",w.createScalarValue(s,\"float32\")),o=G().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")?new hp(RA,r.shape,i.shape):new ki(DA,r.shape,i.shape),l=n.runWebGLProgram(o,[r,i],\"float32\");return n.disposeIntermediateTensorInfo(i),l}var xee={kernelName:ro,backendName:\"webgl\",kernelFunc:yee},MA=\"return (a < 0.) ? b * a : a;\",OA=`\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n`;function vee(e){let{inputs:t,backend:n}=e,{x:a,alpha:r}=t,s=G().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")?new hp(OA,a.shape,r.shape):new ki(MA,a.shape,r.shape);return n.runWebGLProgram(s,[a,r],\"float32\")}var wee={kernelName:wo,backendName:\"webgl\",kernelFunc:vee},mp=\"if (isnan(x)) return x;\";function Ze({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:a}){return({inputs:r,backend:s})=>{let{x:i}=r,o=s,l=a||i.dtype;if(o.shouldExecuteOnCPU([i])&&n!=null){let d=o.texData.get(i.dataId),c=n(d.values,l);return o.makeTensorInfo(i.shape,l,c)}let u=G().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")&&t!=null,p;return u?p=new ts(i.shape,t):p=new rr(i.shape,e),o.runWebGLProgram(p,[i],l)}}function hn({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:a=!1,cpuKernelImpl:r,dtype:s}){return({inputs:i,backend:o})=>{let{a:l,b:u}=i,p=o;if(a&&l.dtype===\"complex64\"){let m=p.texData.get(l.dataId),f=p.texData.get(u.dataId),[g,b]=[[m.complexTensorInfos.real,f.complexTensorInfos.real],[m.complexTensorInfos.imag,f.complexTensorInfos.imag]].map(x=>{let[v,I]=x,N={dataId:v.dataId,dtype:v.dtype,shape:l.shape},C={dataId:I.dataId,dtype:I.dtype,shape:u.shape},_=new ki(e,l.shape,u.shape);return p.runWebGLProgram(_,[N,C],fa(v.dtype,I.dtype))}),y=$s({inputs:{real:g,imag:b},backend:p});return p.disposeIntermediateTensorInfo(g),p.disposeIntermediateTensorInfo(b),y}let d=s||fa(l.dtype,u.dtype);if((l.dtype===\"string\"||u.dtype===\"string\"||p.shouldExecuteOnCPU([l,u]))&&r!=null){let m=p.texData.get(l.dataId).values,f=p.texData.get(u.dataId).values,g=l.dtype===\"string\"?T.fromUint8ToStringArray(m):m,b=l.dtype===\"string\"?T.fromUint8ToStringArray(f):f,[y,x]=r(l.shape,u.shape,g,b,d),v=p.makeTensorInfo(x,d),I=p.texData.get(v.dataId);return I.values=y,v}let c=G().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")&&t!=null,h;return c?h=new hp(t,l.shape,u.shape,n):h=new ki(e,l.shape,u.shape),p.runWebGLProgram(h,[l,u],d)}}function Cc(e,t=!1){if(e===\"linear\")return t?eee:XQ;if(e===\"relu\")return t?nee:ZQ;if(e===\"elu\")return t?tee:YQ;if(e===\"relu6\")return t?aee:JQ;if(e===\"prelu\")return t?OA:MA;if(e===\"leakyrelu\")return t?RA:DA;if(e===\"sigmoid\")return t?ree:QQ;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var PA=class{constructor(e,t,n,a=!1,r=!1,s=!1,i=null,o=!1,l=!1){this.variableNames=[\"matrixA\",\"matrixB\"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=vn(this.outputShape.length);let u=a?e[1]:e[2],p=Math.ceil(u/2),d=a?\"i * 2, rc.y\":\"rc.y, i * 2\",c=r?\"rc.z, i * 2\":\"i * 2, rc.z\",h=a?[\"a.xxyy\",\"a.zzww\"]:[\"a.xxzz\",\"a.yyww\"],m=r?[\"b.xzxz\",\"b.ywyw\"]:[\"b.xyxy\",\"b.zwzw\"],f=\"\",g=\"\";i&&(o?f=`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:l?f=`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:f=`vec4 activation(vec4 x) {\n          ${i}\n        }`,g=\"result = activation(result);\");let b=s?\"result += getBiasAtOutCoords();\":\"\";s&&this.variableNames.push(\"bias\"),o&&this.variableNames.push(\"preluActivationWeights\"),l&&this.variableNames.push(\"leakyreluAlpha\");let y=\"rc.x\",x=\"rc.x\";e[0]<t[0]?y=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(x=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${f}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${p}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${y};\n        int batchB = ${x};\n        for (int i = 0; i < ${p}; i++) {\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${c});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${h[0]} * ${m[0]});\n          result += (${h[1]} * ${m[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${b}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}},lS={REAL:\"return areal * breal - aimag * bimag;\",IMAG:\"return areal * bimag + aimag * breal;\"},uS=class{constructor(e,t,n){this.variableNames=[\"AReal\",\"AImag\",\"BReal\",\"BImag\"],this.outputShape=T.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}},pS=\"return a * b;\";function pk(e){let{inputs:t,backend:n}=e,{a,b:r}=t,s=T.upcastType(a.dtype,r.dtype);if(a.dtype===\"complex64\"){let o=n.texData.get(a.dataId),l=n.texData.get(r.dataId),u=new uS(lS.REAL,a.shape,r.shape),p=new uS(lS.IMAG,a.shape,r.shape),d=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:a.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],c=n.runWebGLProgram(u,d,\"float32\"),h=n.runWebGLProgram(p,d,\"float32\"),m=$s({inputs:{real:c,imag:h},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),m}if(n.shouldExecuteOnCPU([a,r])){let o=n.texData.get(a.dataId),l=n.texData.get(r.dataId),[u,p]=yQ(a.shape,r.shape,o.values,l.values,s),d=n.makeTensorInfo(p,s),c=n.texData.get(d.dataId);return c.values=u,d}let i;return G().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")?i=new hp(pS,a.shape,r.shape):i=new ki(pS,a.shape,r.shape),n.runWebGLProgram(i,[a,r],s)}var kee={kernelName:bo,backendName:\"webgl\",kernelFunc:pk};function Iee(e,t,n){let a=[vi(e.shape),...wi(e.shape)],r={dtype:e.dtype,shape:a,dataId:e.dataId},s=[vi(t),...wi(t)],i=new AA(s,a),o=!0,l=[a],u=n.runWebGLProgram(i,[r],e.dtype,l,o);return{dataId:u.dataId,shape:t,dtype:u.dtype}}function ce(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:s}=a,i=n,o=w.sizeFromShape(r.shape),l=w.inferFromImplicitShape(s,o),u=w.sizeFromShape(l);w.assert(o===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);let p=i.texData.get(r.dataId);return p.isPacked&&!Tc(r.shape,l)&&!(p.texture!==null&&Tc(p.shape,l))?Iee(r,l,i):(i.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}var See={kernelName:Ru,backendName:\"webgl\",kernelFunc:ce},cS=class{constructor(e,t){this.variableNames=[\"x\"];let{windowSize:n,batchSize:a,inSize:r,outSize:s}=e;this.outputShape=[a,s];let i=Math.floor(n/4)*4,o=n%4,l=\"sumValue += dot(values, ones);\";if(t!=null){let p=1/t;l=`sumValue += dot(values * ${w.isInt(p)?p.toPrecision(2):p}, ones);`}let u=\"\";r%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${o===1}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${o===2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${o===3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}},Nee=class{constructor(e,t){this.variableNames=[\"x\"];let{windowSize:n,batchSize:a,inSize:r,outSize:s}=e;this.outputShape=[a,s];let i=\"0.0\",o=\"\";t===\"prod\"?i=\"1.0\":t===\"min\"?(i=\"1.0 / 1e-20\",o=\"min\"):t===\"max\"&&(i=\"-1.0 / 1e-20\",o=\"max\");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t===\"sum\"?l=\"sumValue\":t===\"prod\"?l=\"prodValue\":t===\"all\"?l=\"allValue\":t===\"any\"&&(l=\"anyValue\");let u=Math.floor(n/4)*4,p=n%4,d=`\n      if (${t===\"sum\"}) {\n        sumValue += dot(values, ones);\n      } else if (${t===\"prod\"}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${t===\"min\"} || ${t===\"max\"}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,c=\"vec4\";t===\"all\"?(i=\"1.0\",d=`\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      `,c=\"bvec4\"):t===\"any\"&&(i=\"0.0\",d=`\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      `,c=\"bvec4\");let h=\"\";r%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${c} values = ${c}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${p===1}) {\n          ${c} values = ${c}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${p===2}) {\n          ${c} values = ${c}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${p===3}) {\n          ${c} values = ${c}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${l});\n      }\n    `}};function Tee(e){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let n=t.length?t[t.length-1].outSize:e[1],a=T.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:a,outSize:Math.ceil(n/a)})}return t}function el(e,t,n,a){let r=Tee(e.shape),s=e;for(let i=0;i<r.length;i++){let{inSize:o,windowSize:l,outSize:u}=r[i],p,d;n===\"mean\"?p=i===0?new cS({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new cS({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):p=new Nee({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),d=s,s=a.runWebGLProgram(p,[s],t),d.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(d)}return s}var Cee=class{constructor(e,t){this.variableNames=[\"A\"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;let a=ht(this.rank),r=Eee(t);this.userCode=`\n    void main() {\n      ${a} resRC = getOutputCoords();\n      setOutput(getA(${r}));\n    }\n    `}};function Eee(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=[\"resRC.x\",\"resRC.y\",\"resRC.z\",\"resRC.w\",\"resRC.u\",\"resRC.v\"],a=new Array(t);for(let r=0;r<e.length;r++)a[e[r]]=n[r];return a.join()}var _ee=class{constructor(e,t){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let a=ht(this.rank),r=_A(\"rc\",this.rank),s=new Array(this.rank);for(let u=0;u<t.length;u++)s[t[u]]=r[u];let i=`vec2(${s.slice(-2).join()})`,o=`++${r[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${a} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${r[this.rank-1]};\n      if(++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}};function Bf(e,t,n){let a=G().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\")?new _ee(e.shape,t):new Cee(e.shape,t);return n.runWebGLProgram(a,[e],e.dtype)}function Aee(e,t,n,a){let r=t,s=e.shape.length,i=w.parseAxisParam(r,e.shape),o=i,l=T.getAxesPermutation(o,s),u=l!=null,p=e;u&&(p=Bf(e,l,a),o=T.getInnerMostAxes(o.length,s)),T.assertAxesAreInnerMostDims(\"sum\",o,s);let[d,c]=T.computeOutAndReduceShapes(p.shape,o),h=d;n&&(h=T.expandShapeToKeepDim(d,i));let m=w.sizeFromShape(c),f=w.sizeFromShape(e.shape)/m,g=ce({inputs:{x:p},attrs:{shape:[f,m]},backend:a}),b=Mm(e.dtype),y=el(g,b,\"sum\",a),x=ce({inputs:{x:y},attrs:{shape:h},backend:a});return a.disposeIntermediateTensorInfo(g),a.disposeIntermediateTensorInfo(y),u&&a.disposeIntermediateTensorInfo(p),x}function Vf(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;return Aee(r,s,i,n)}var Fee={kernelName:Lo,backendName:\"webgl\",kernelFunc:Vf};function Sn(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{perm:s}=a,i=n,o=r.shape.length,l=new Array(o);for(let p=0;p<l.length;p++)l[p]=r.shape[s[p]];let u;if(i.shouldExecuteOnCPU([r])){let p=i.texData.get(r.dataId).values,d=ok(p,r.shape,r.dtype,s,l);u=i.makeTensorInfo(l,r.dtype);let c=i.texData.get(u.dataId);c.values=d}else u=Bf(r,s,i);return u}var $ee={kernelName:Cr,backendName:\"webgl\",kernelFunc:Sn},LA=1e3;function hm({a:e,b:t,transposeA:n,transposeB:a,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){let u=e.shape.length,p=t.shape.length,d=n?e.shape[u-2]:e.shape[u-1],c=a?t.shape[p-1]:t.shape[p-2],h=n?e.shape[u-1]:e.shape[u-2],m=a?t.shape[p-2]:t.shape[p-1],f=e.shape.slice(0,-2),g=t.shape.slice(0,-2),b=w.sizeFromShape(f),y=w.sizeFromShape(g),x=Ju.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([h,m]);w.assert(d===c,()=>`Error in matMul: inner shapes (${d}) and (${c}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${a} must match.`);let v=n?[b,d,h]:[b,h,d],I=a?[y,m,c]:[y,c,m],N=ce({inputs:{x:e},backend:r,attrs:{shape:v}}),C=ce({inputs:{x:t},backend:r,attrs:{shape:I}}),_=[N,C],F=Math.max(b,y),D=n?N.shape[1]:N.shape[2],$=s!=null,S=i!=null,M=l===\"leakyrelu\",B=l!=null?Cc(l,!0):null,U=$||S||M||B!=null,H;if((h===1||m===1)&&D>LA&&U===!1){let K=N,Z=C;n&&(K=Sn({inputs:{x:N},backend:r,attrs:{perm:[0,2,1]}}),_.push(K)),a&&(Z=Sn({inputs:{x:C},backend:r,attrs:{perm:[0,2,1]}}),_.push(Z));let J=m!==1,ee=m===1,ae=K;J&&(ae=ce({inputs:{x:K},backend:r,attrs:{shape:[F,D,1]}}),_.push(ae));let te=m===1?2:1,se=Z;ee&&(se=ce({inputs:{x:Z},backend:r,attrs:{shape:[F,1,D]}}),_.push(se));let ie=pk({inputs:{a:ae,b:se},backend:r});H=Vf({inputs:{x:ie},backend:r,attrs:{axis:te,keepDims:!0}}),_.push(ie)}else{let K=fa(e.dtype,t.dtype),Z=new PA(v,I,[F,h,m],n,a,$,B,S,M),J=[N,C];if(s!=null&&J.push(s),S&&J.push(i),M){let ee=r.makeTensorInfo([],\"float32\",w.createScalarValue(o,\"float32\"));J.push(ee),_.push(ee)}H=r.runWebGLProgram(Z,J,K)}let q=ce({inputs:{x:H},backend:r,attrs:{shape:x}});_.push(H);for(let K of _)r.disposeIntermediateTensorInfo(K);return q}function Dee(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:p,leakyreluAlpha:d}=a;return hm({a:r,b:s,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:p})}var Ree={kernelName:ii,backendName:\"webgl\",kernelFunc:Dee},dS=\"return abs(x);\";function Mee(e){let{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])&&a.dtype!==\"complex64\"){let s=n.texData.get(a.dataId),i=CA(s.values);return n.makeTensorInfo(a.shape,a.dtype,i)}let r;return G().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")?r=new ts(a.shape,dS):r=new rr(a.shape,dS),n.runWebGLProgram(r,[a],a.dtype)}var Oee={kernelName:Yl,backendName:\"webgl\",kernelFunc:Mee},Pee=Da+`\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n`,Lee=Ze({opSnippet:Pee}),zee={kernelName:Ni,backendName:\"webgl\",kernelFunc:Lee},Wee=Da+`\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));`,Bee=Ze({opSnippet:Wee}),Vee={kernelName:Ti,backendName:\"webgl\",kernelFunc:Bee},hS=\"return a + b;\",Uee=hn({opSnippet:hS,packedOpSnippet:hS,supportsComplex:!0,cpuKernelImpl:Z9}),Gee={kernelName:vs,backendName:\"webgl\",kernelFunc:Uee},Hee=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((r,s)=>`T${s}`);let n=[];this.variableNames.forEach(r=>{n.push(`float v${r} = get${r}AtOutCoords();`)});let a=this.variableNames.map(r=>`v${r}`).join(\" + \");this.userCode=`\n      void main() {\n        ${n.join(`\n        `)}\n\n        float result = ${a};\n        setOutput(result);\n      }\n    `}},jee=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((r,s)=>`T${s}`);let n=[];this.variableNames.forEach(r=>{n.push(`vec4 v${r} = get${r}AtOutCoords();`)});let a=this.variableNames.map(r=>`v${r}`).join(\" + \");this.userCode=`\n      void main() {\n        ${n.join(`\n        `)}\n\n        vec4 result = ${a};\n        setOutput(result);\n      }\n    `}};function Bh(e){let{inputs:t,backend:n}=e,a=t;if(a.length===1)return ta({inputs:{x:a[0]},backend:n});if(a.length>G().getNumber(\"WEBGL_MAX_TEXTURES_IN_SHADER\")){let o=Math.floor(a.length/2),l=Bh({inputs:a.slice(0,o),backend:n}),u=Bh({inputs:a.slice(o),backend:n});return Bh({inputs:[l,u],backend:n})}let r=a.map(o=>o.dtype).reduce((o,l)=>fa(o,l)),s=a.map(o=>o.shape),i=G().getBool(\"WEBGL_PACK\")?new jee(a[0].shape,s):new Hee(a[0].shape,s);return n.runWebGLProgram(i,a,r)}var qee={kernelName:Ci,backendName:\"webgl\",kernelFunc:Bh};function Kee(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,l=w.parseAxisParam(s,r.shape),u=l,p=T.getAxesPermutation(u,o),d=r;p!=null&&(d=Sn({inputs:{x:r},backend:n,attrs:{perm:p}}),u=T.getInnerMostAxes(u.length,o)),T.assertAxesAreInnerMostDims(\"all\",u,o);let[c,h]=T.computeOutAndReduceShapes(d.shape,u),m=w.sizeFromShape(h),f=ce({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),g=el(f,f.dtype,\"all\",n),b;if(i){let y=T.expandShapeToKeepDim(c,l);b=ce({inputs:{x:g},backend:n,attrs:{shape:y}})}else b=ce({inputs:{x:g},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),p!=null&&n.disposeIntermediateTensorInfo(d),b}var Xee={kernelName:Zl,backendName:\"webgl\",kernelFunc:Kee};function Yee(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,l=w.parseAxisParam(s,r.shape),u=l,p=T.getAxesPermutation(u,o),d=r;p!=null&&(d=Sn({inputs:{x:r},backend:n,attrs:{perm:p}}),u=T.getInnerMostAxes(u.length,o)),T.assertAxesAreInnerMostDims(\"any\",u,o);let[c,h]=T.computeOutAndReduceShapes(d.shape,u),m=w.sizeFromShape(h),f=ce({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),g=el(f,f.dtype,\"any\",n),b;if(i){let y=T.expandShapeToKeepDim(c,l);b=ce({inputs:{x:g},backend:n,attrs:{shape:y}})}else b=ce({inputs:{x:g},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),p!=null&&n.disposeIntermediateTensorInfo(d),b}var Zee={kernelName:Jl,backendName:\"webgl\",kernelFunc:Yee},Jee=class{constructor(e,t,n){this.variableNames=[\"A\"];let{windowSize:a,batchSize:r,outSize:s}=e;n||this.variableNames.push(\"bestIndicesA\"),this.outputShape=[r,s];let i=t===\"max\"?\">\":\"<\",o=n?\"inOffset + i;\":\"round(getBestIndicesA(batch, inOffset + i));\";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${a};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${a}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}},Qee=class{constructor(e,t,n,a){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!0,w.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let r=e[e.length-1],s=Math.ceil(r/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),a||this.variableNames.push(\"bestIndicesA\");let i=this.outputShape,o=i.length,l=ht(o),u=In(\"coords\",o),p,d;if(s===1){d=o+1;let C=ht(d);p=`\n        ${C} sourceLocR = ${C}(${u.join()}, 0);\n        ++${u[o-1]};\n        ${C} sourceLocG = ${C}(${u.join()}, 0);\n        ++${u[o-2]};\n        ${C} sourceLocA = ${C}(${u.join()}, 0);\n        --${u[o-1]};\n        ${C} sourceLocB = ${C}(${u.join()}, 0);\n        --${u[o-2]};`}else d=o,p=`\n        ${l} sourceLocR = coords;\n        ++${u[o-1]};\n        ${l} sourceLocG = coords;\n        ++${u[o-2]};\n        ${l} sourceLocA = coords;\n        --${u[o-1]};\n        ${l} sourceLocB = coords;\n        --${u[o-2]};`;let c=[\"x\",\"y\",\"z\",\"w\",\"u\",\"v\"].slice(0,d),h=\".\"+c[d-1],m=c.map(C=>\"int \"+C),f=In(\"sourceLocR\",d-1).concat(\"inIdx.r\"),g=In(\"sourceLocG\",d-1).concat(\"inIdx.g\"),b=In(\"sourceLocB\",d-1).concat(\"inIdx.b\"),y=In(\"sourceLocA\",d-1).concat(\"inIdx.a\"),x=n===\"max\"?\"greaterThan\":\"lessThan\",v=a?\"\":`\n          inIdx = round(vec4(getBestIndicesAChannel(${f.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${y.join()})));`,I=`vec4(\n            getAChannel(${f.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,N=a?\"\":`\n      float getBestIndicesAChannel(${m.join()}) {\n        return getChannel(getBestIndicesA(${c.join()}),\n                                          vec2(${c.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${m.join()}) {\n        return getChannel(getA(${c.join()}),\n                               vec2(${c.slice(-2).join()}));\n      }\n      ${N}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[o-1]} < ${i[o-1]-1};\n        bool hasNextRow = ${u[o-2]} < ${i[o-2]-1};\n        ${p}\n        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},\n          sourceLocB${h}, sourceLocA${h}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${I};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${v}\n          vec4 candidate = ${I};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}};function zA(e,t,n,a=null){let r=t.shape[0],s=t.shape[1];a!=null&&(r=a.shape[0],s=a.shape[1]);let i=T.computeOptimalWindowSize(s),o={windowSize:i,inSize:s,batchSize:r,outSize:Math.ceil(s/i)},l=new Jee(o,n,a==null),u=[t];a!=null&&u.push(a);let p=e.runWebGLProgram(l,u,\"int32\");if(p.shape[1]===1)return p;let d=zA(e,t,n,p);return e.disposeIntermediateTensorInfo(p),d}function WA(e,t,n,a=null){let r=a!=null?a.shape:t.shape,s=r[r.length-1],i=T.computeOptimalWindowSize(s),o=new Qee(r,i,n,a==null),l=a==null?[t]:[t,a],u=e.runWebGLProgram(o,l,\"int32\");if(u.shape.length===t.shape.length){let p=WA(e,t,n,u);return e.disposeIntermediateTensorInfo(u),p}return u}function BA(e,t,n,a){let r=[n];if(T.assertAxesAreInnerMostDims(\"arg\"+a.charAt(0).toUpperCase()+a.slice(1),r,t.shape.length),!G().getBool(\"WEBGL_PACK_REDUCE\")||t.shape.length<=2){let s=[],i=e.texData.get(t.dataId),o=i!==null&&i.isPacked,l=t;o&&(l=e.unpackTensor(t),s.push(l));let[u,p]=T.computeOutAndReduceShapes(l.shape,r),d=w.sizeFromShape(p),c=ce({inputs:{x:l},backend:e,attrs:{shape:[-1,d]}});s.push(c);let h=zA(e,c,a);s.push(h);let m=ce({inputs:{x:h},backend:e,attrs:{shape:u}});return s.forEach(f=>e.disposeIntermediateTensorInfo(f)),m}return WA(e,t,a)}function ete(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a,i=w.parseAxisParam(s,r.shape),o=T.getAxesPermutation(i,r.shape.length),l=r,u=[];o!=null&&(l=Sn({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),i=T.getInnerMostAxes(i.length,l.shape.length)),T.assertAxesAreInnerMostDims(\"argMax\",[i[0]],l.shape.length);let p=BA(n,l,i[0],\"max\");return u.forEach(d=>n.disposeIntermediateTensorInfo(d)),p}var tte={kernelName:Ql,backendName:\"webgl\",kernelFunc:ete};function nte(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a,i=w.parseAxisParam(s,r.shape),o=T.getAxesPermutation(i,r.shape.length),l=r,u=[];o!=null&&(l=Sn({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),i=T.getInnerMostAxes(i.length,l.shape.length)),T.assertAxesAreInnerMostDims(\"argMin\",[i[0]],l.shape.length);let p=BA(n,l,i[0],\"min\");return u.forEach(d=>n.disposeIntermediateTensorInfo(d)),p}var ate={kernelName:eu,backendName:\"webgl\",kernelFunc:nte},rte=Da+`\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n`,ste=Ze({opSnippet:rte}),ite={kernelName:Ei,backendName:\"webgl\",kernelFunc:ste},ote=Da+\"return log(x + sqrt(x * x + 1.0));\",lte=Ze({opSnippet:ote}),ute={kernelName:_i,backendName:\"webgl\",kernelFunc:lte},pte=Da+`\n  return atan(x);\n`,cte=Ze({opSnippet:pte}),dte={kernelName:Ai,backendName:\"webgl\",kernelFunc:cte},hte=uk+`\n  return atan(a, b);\n`,mte=`\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  `+Qo+`\n  return result;\n`,fte=hn({opSnippet:hte,packedOpSnippet:mte}),gte={kernelName:$i,backendName:\"webgl\",kernelFunc:fte},bte=Da+`\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;`,yte=Ze({opSnippet:bte}),xte={kernelName:Fi,backendName:\"webgl\",kernelFunc:yte},Ec=class{constructor(e,t,n,a=!1,r=!1){if(this.variableNames=[\"x\"],t===\"avg\"&&n)throw new Error(\"Cannot compute positions for average pool.\");let s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,p=e.effectiveFilterHeight,d=e.effectiveFilterWidth,c=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;let m=t===\"avg\",f=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,b=\"0.0\";if(m||(b=\"-1.0 / 1e-20\"),n){let C=\">=\";this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${c}, ${h});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${p};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${C} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${a?r?f:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;return}let y=\"max\",x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t===\"avg\"&&(x=\"avgValue / max(count, 1.0)\");let v=Math.floor(s/4)*4,I=s%4,N=`\n      if (${m}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${y}(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${p};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${N}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${I===1}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${N}\n          } else if (${I===2}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${N}\n          } else if (${I===3}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${N}\n          }\n        }\n        setOutput(${x});\n      }\n    `}},ck=class{constructor(e,t,n,a=!1,r=!1){if(this.variableNames=[\"x\"],t===\"avg\"&&n)throw new Error(\"Cannot compute positions for average pool.\");let s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,p=e.dilationHeight,d=e.dilationWidth,c=e.effectiveFilterDepth,h=e.effectiveFilterHeight,m=e.effectiveFilterWidth,f=e.padInfo.front,g=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;let y=t===\"avg\",x=\"0.0\";if(y||(x=\"-1.0 / 1e-20\"),n){let F=\">=\";this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${l});\n        const ivec3 pads = ivec3(${f}, ${g}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${c};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${h};\n                wR += ${p}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${m};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${F} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${a?r?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${h} * ${m} +\n                      wR * ${m} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;return}let v=\"max\",I=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t===\"avg\"&&(I=\"avgValue / max(count, 1.0)\");let N=Math.floor(s/4)*4,C=s%4,_=`\n      if (${y}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${v}(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${l});\n      const ivec3 pads = ivec3(${f}, ${g}, ${b});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h};\n            wR += ${p}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${N}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${_}\n            }\n\n            int xC = xCCorner + ${N};\n            if (${C===1}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${_}\n            } else if (${C===2}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${_}\n            } else if (${C===3}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${_}\n            }\n          }\n        }\n        setOutput(${I});\n      }\n    `}};function vte(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;lp(r,\"avgPool\");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=a,u=1;w.assert(T.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let p=T.computePool2DInfo(r.shape,s,i,u,o,l);if(p.filterWidth===1&&p.filterHeight===1&&w.arraysEqual(p.inShape,p.outShape))return ta({inputs:{x:r},backend:n});let d=new Ec(p,\"avg\",!1);return n.runWebGLProgram(d,[r],\"float32\")}var wte={kernelName:Di,backendName:\"webgl\",kernelFunc:vte};function kte(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=a,p=[1,1,1],d=T.computePool3DInfo(r.shape,s,i,p,o,l,u),c=new ck(d,\"avg\",!1);return n.runWebGLProgram(c,[r],\"float32\")}var Ite={kernelName:tu,backendName:\"webgl\",kernelFunc:kte},Ste=class{constructor(e){this.variableNames=[\"dy\"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,p=l-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${p});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},Nte=class{constructor(e){this.variableNames=[\"dy\"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,p=e.effectiveFilterDepth,d=e.effectiveFilterHeight,c=e.effectiveFilterWidth,h=p-1-e.padInfo.front,m=d-1-e.padInfo.top,f=c-1-e.padInfo.left,g=1/(t*n*a);this.userCode=`\n      const ivec3 pads = ivec3(${h}, ${m}, ${f});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${r}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${c};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function Tte(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:p}=a,d=[1,1,1],c=T.computePool3DInfo(i.shape,o,l,d,u,p),h=new Nte(c);return n.runWebGLProgram(h,[r],i.dtype)}var Cte={kernelName:Rc,backendName:\"webgl\",kernelFunc:Tte};function Ete(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s;lp([r,s],\"avgPoolGrad\");let{filterSize:o,strides:l,pad:u}=a,p=T.computePool2DInfo(i.shape,o,l,1,u),d=new Ste(p);return n.runWebGLProgram(d,[r],i.dtype)}var _te={kernelName:Dc,backendName:\"webgl\",kernelFunc:Ete};function Ate(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=a;return hm({a:r,b:s,transposeA:i,transposeB:o,backend:n})}var Fte={kernelName:Ri,backendName:\"webgl\",kernelFunc:Ate},$te=class{constructor(e,t,n,a,r,s){this.outputShape=[],this.variableNames=[\"x\",\"mean\",\"variance\"],T.assertAndGetBroadcastShape(e,t),T.assertAndGetBroadcastShape(e,n);let i=\"0.0\";a!=null&&(T.assertAndGetBroadcastShape(e,a),this.variableNames.push(\"offset\"),i=\"getOffsetAtOutCoords()\");let o=\"1.0\";r!=null&&(T.assertAndGetBroadcastShape(e,r),this.variableNames.push(\"scale\"),o=\"getScaleAtOutCoords()\"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}},Dte=class{constructor(e,t,n,a,r,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=[\"x\",\"mean\",\"variance\"],T.assertAndGetBroadcastShape(e,t),T.assertAndGetBroadcastShape(e,n);let i=\"vec4(0.0)\";a!=null&&(T.assertAndGetBroadcastShape(e,a),this.variableNames.push(\"offset\"),i=\"getOffsetAtOutCoords()\");let o=\"vec4(1.0)\";r!=null&&(T.assertAndGetBroadcastShape(e,r),this.variableNames.push(\"scale\"),o=\"getScaleAtOutCoords()\"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}},Rte=({inputs:e,backend:t,attrs:n})=>{let{x:a,mean:r,variance:s,offset:i,scale:o}=e;w.assert(r.shape.length===s.shape.length,()=>\"Batch normalization gradient requires mean and variance to have equal ranks.\"),w.assert(i==null||r.shape.length===i.shape.length,()=>\"Batch normalization gradient requires mean and offset to have equal ranks.\"),w.assert(o==null||r.shape.length===o.shape.length,()=>\"Batch normalization gradient requires mean and scale to have equal ranks.\");let{varianceEpsilon:l}=n;l==null&&(l=.001);let u=[a,r,s],p=null;i!=null&&(p=i.shape,u.push(i));let d=null;o!=null&&(d=o.shape,u.push(o));let c=G().getBool(\"WEBGL_PACK_NORMALIZATION\")?new Dte(a.shape,r.shape,s.shape,p,d,l):new $te(a.shape,r.shape,s.shape,p,d,l);return t.runWebGLProgram(c,u,u[0].dtype)},Mte={kernelName:Ji,backendName:\"webgl\",kernelFunc:Rte},Ote=class{constructor(e){this.variableNames=[\"source\"],this.outputShape=e,this.rank=e.length;let t=ht(this.rank);this.customUniforms=[{name:\"start\",arrayIndex:this.rank,type:\"int\"}];let n=Pte(this.rank),a,r=e.map((s,i)=>`sourceLoc.${mv[i]} = start[${i}] + coords.${mv[i]};`);a=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${r.join(`\n`)}\n      `,this.userCode=`\n      void main() {\n        ${a}\n        setOutput(getSource(${n}));\n      }\n    `}},mv=[\"x\",\"y\",\"z\",\"w\",\"u\",\"v\"];function Pte(e){if(e===1)return\"sourceLoc\";if(e<=6)return mv.slice(0,e).map(t=>\"sourceLoc.\"+t).join(\",\");throw Error(`Slicing for rank ${e} is not yet supported`)}var Lte=class{constructor(e){this.variableNames=[\"source\"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:\"start\",arrayIndex:this.rank,type:\"int\"}];let t=ht(this.rank),n=In(\"coords\",this.rank),a=In(\"sourceLoc\",this.rank),r=this.rank===1?\"sourceLoc\":`vec2(${a.slice(-2).join()})`,s=`getChannel(getSource(${a.join()}), ${r})`,i=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${a[this.rank-1]};\n        result.y = ${s};\n        --${a[this.rank-1]};\n      }\n    `,o=this.rank===1?\"\":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${a[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${a[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map((u,p)=>`start[${p}]`).join()});`:e.map((u,p)=>`${a[p]} = ${n[p]} + start[${p}];`).join(`\n`);this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}};function zte(e,t,n,a){let r=a.texData.get(e.dataId),s=a.makeTensorInfo(n,e.dtype),i=a.texData.get(s.dataId);Object.assign(i,r),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=Kt.computeFlatOffset(t,w.computeStrides(e.shape));r.slice&&(o+=r.slice.flatOffset),i.slice={flatOffset:o,origDataId:r.slice&&r.slice.origDataId||e.dataId};let l=a.dataRefCount.get(i.slice.origDataId)||1;return a.dataRefCount.set(i.slice.origDataId,l+1),s}function fp(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:i}=a,[o,l]=Kt.parseSliceParams(r,s,i);if(Kt.assertParamsValid(r,o,l),w.sizeFromShape(l)===0)return n.makeTensorInfo(l,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||r.dtype===\"string\"){let d=n.texData.get(r.dataId),c=_Q(d.values,o,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,c)}let{isPacked:u}=n.texData.get(r.dataId),p=Kt.isSliceContinous(r.shape,o,l);if(u||!p){let d=G().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\")?new Lte(l):new Ote(l),c=[o];return n.runWebGLProgram(d,[r],r.dtype,c)}return n.uploadToGPU(r.dataId),zte(r,o,l,n)}var Wte={kernelName:Bu,backendName:\"webgl\",kernelFunc:fp},Bte=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:i}=a;w.assert(r.shape.length<=4,()=>\"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet\");let o=s.reduce((y,x)=>y*x),l=T.getReshaped(r.shape,s,o),u=T.getPermuted(l.length,s.length),p=T.getReshapedPermuted(r.shape,s,o),d=T.getSliceBeginCoords(i,s.length),c=T.getSliceSize(p,i,s.length),h=[],m=ce({inputs:{x:r},backend:n,attrs:{shape:l}}),f=Sn({inputs:{x:m},backend:n,attrs:{perm:u}}),g=ce({inputs:{x:f},backend:n,attrs:{shape:p}}),b=fp({inputs:{x:g},backend:n,attrs:{begin:d,size:c}});return h.push(m),h.push(f),h.push(g),h.forEach(y=>n.disposeIntermediateTensorInfo(y)),b},Vte={kernelName:nu,backendName:\"webgl\",kernelFunc:Bte};function Ute(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i}=a,o=n.readSync(r.dataId),l=n.readSync(s.dataId),u=TA(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}var Gte={kernelName:au,backendName:\"webgl\",kernelFunc:Ute},Hte=`\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n`,jte=`\n  return float(int(a.r) & int(b.r));\n`;function qte(e){let{inputs:t,backend:n}=e,{a,b:r}=t,s=G().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\"),i=G().getNumber(\"WEBGL_VERSION\");if(n.shouldExecuteOnCPU([a,r])||i===1){let l=n.texData.get(a.dataId).values,u=n.texData.get(r.dataId).values,[p,d]=Q9(a.shape,r.shape,l,u,a.dtype),c=n.makeTensorInfo(d,a.dtype),h=n.texData.get(c.dataId);return h.values=p,c}let o;return s?o=new hp(Hte,a.shape,r.shape,!1):o=new ki(jte,a.shape,r.shape),n.runWebGLProgram(o,[a,r],a.dtype)}var Kte={kernelName:ru,backendName:\"webgl\",kernelFunc:qte};function Xte(e){let{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.readSync(a.dataId),i=n.readSync(r.dataId),o=T.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],\"int32\",Int32Array.from(o))}var Yte={kernelName:Mc,backendName:\"webgl\",kernelFunc:Xte},Zte=\"return float(a != b);\",VA=hn({opSnippet:Zte,cpuKernelImpl:vQ,dtype:\"bool\"}),Jte={kernelName:Eu,backendName:\"webgl\",kernelFunc:VA};function Fd(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.texData.get(a.dataId);return ta({inputs:{x:r.complexTensorInfos.real},backend:n})}var Qte={kernelName:Dm,backendName:\"webgl\",kernelFunc:Fd},ene=\"return float(int(x));\";function tne(e,t){let n=new rr(e.shape,ene),a=t.runWebGLProgram(n,[e],\"int32\");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}function fv(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:s}=a;if(s===\"complex64\"){if(r.dtype===\"complex64\")return ta({inputs:{x:r},backend:n});let i=It(r.shape),o=fv({inputs:{x:r},backend:n,attrs:{dtype:\"float32\"}}),l=$s({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(o),l}if(r.dtype===\"complex64\"){let i=Fd({inputs:{input:r},backend:n}),o=fv({inputs:{x:i},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(i),o}if(!w.hasEncodingLoss(r.dtype,s)){let i=ta({inputs:{x:r},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(n.shouldExecuteOnCPU([r])){let i=n.texData.get(r.dataId).values,[o,l,u]=eQ(i,r.shape,r.dtype,s);return n.makeTensorInfo(o,l,u)}if(s===\"int32\")return tne(r,n);if(s===\"bool\"){let i=n.makeTensorInfo([],\"bool\",w.getTypedArrayFromDType(\"bool\",1)),o=VA({inputs:{a:r,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),o}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${s}`)}var nne={kernelName:Mi,backendName:\"webgl\",kernelFunc:fv},mS=\"return ceil(x);\",ane=Ze({opSnippet:mS,packedOpSnippet:mS,cpuKernelImpl:tQ}),rne={kernelName:Oi,backendName:\"webgl\",kernelFunc:ane},sne=class{constructor(e){this.variableNames=[\"A\"],this.customUniforms=[{name:\"minVal\",type:\"float\"},{name:\"maxVal\",type:\"float\"}],this.outputShape=e,this.userCode=`\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    `}},ine=class{constructor(e){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:\"minVal\",type:\"float\"},{name:\"maxVal\",type:\"float\"}],this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    `}};function one(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:s,clipValueMax:i}=a,o;G().getBool(\"WEBGL_PACK_CLIP\")?o=new ine(r.shape):o=new sne(r.shape);let l=[[s],[i]];return n.runWebGLProgram(o,[r],r.dtype,l)}var lne={kernelName:ws,backendName:\"webgl\",kernelFunc:one},une=class{constructor(e){this.variableNames=[\"real\",\"imag\"],this.outputShape=e,this.userCode=`\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    `}};function fS(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function pne(e){let{inputs:t,backend:n}=e,{x:a}=t,r=n.texData.get(a.dataId),s=new une(a.shape),i=[fS(a,r.complexTensorInfos.real),fS(a,r.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}var cne={kernelName:Oc,backendName:\"webgl\",kernelFunc:pne},dne=class{constructor(e){this.outputShape=[],this.outputShape=T.computeOutShape(e,1),this.variableNames=e.map((s,i)=>`T${i}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++){let i=t[s-1];n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${i}));`)}let a=t.length,r=t[t.length-1];n.push(`else setOutput(getT${a}(yR, yC-${r}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join(`\n        `)}\n      }\n    `}},hne=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=T.computeOutShape(e,t);let n=this.outputShape,a=n.length,r=ht(a),s=In(\"coords\",a),i=[\"x\",\"y\",\"z\",\"w\",\"u\",\"v\"].slice(0,a);this.variableNames=e.map((m,f)=>`T${f}`);let o=new Array(e.length-1);o[0]=e[0][t];for(let m=1;m<o.length;m++)o[m]=o[m-1]+e[m][t];let l=i[t],u=i.slice(-2),p=i.join(),d=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${p}), vec2(${u.join()}));\n        }`;for(let m=1;m<o.length;m++){let f=o[m-1];d+=`\n        if (${l} < ${o[m]}  && ${l} >= ${o[m-1]}) {\n          return getChannel(\n            getT${m}(${$h(i,l,f)}),\n            vec2(${$h(u,l,f)}));\n        }`}let c=o.length,h=o[o.length-1];d+=`\n        return getChannel(\n          getT${c}(${$h(i,l,h)}),\n          vec2(${$h(u,l,h)}));`,this.userCode=`\n      float getValue(${i.map(m=>\"int \"+m)}) {\n        ${d}\n      }\n\n      void main() {\n        ${r} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[a-1]} = ${s[a-1]} + 1;\n        if (${s[a-1]} < ${n[a-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[a-2]} = ${s[a-2]} + 1;\n        if (${s[a-2]} < ${n[a-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[a-1]} = ${s[a-1]} - 1;\n        if (${s[a-2]} < ${n[a-2]} &&\n            ${s[a-1]} < ${n[a-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}};function $h(e,t,n){let a=e.indexOf(t);return e.map((r,s)=>s===a?`${r} - ${n}`:r).join()}function Uf(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.texData.get(a.dataId);return ta({inputs:{x:r.complexTensorInfos.imag},backend:n})}var mne={kernelName:_m,backendName:\"webgl\",kernelFunc:Uf};function oc(e,t,n){let a=e[0].dtype;if(a===\"complex64\"){let h=e.map(y=>Fd({inputs:{input:y},backend:n})),m=e.map(y=>Uf({inputs:{input:y},backend:n})),f=oc(h,t,n),g=oc(m,t,n),b=$s({inputs:{real:f,imag:g},backend:n});return h.forEach(y=>n.disposeIntermediateTensorInfo(y)),m.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),b}let r=n.shouldExecuteOnCPU(e);if(a===\"string\"&&(r=!0),r){let h=e.map(v=>{let I=[-1,w.sizeFromShape(v.shape.slice(t))];return ce({inputs:{x:v},backend:n,attrs:{shape:I}})}),m=h.map(v=>({vals:n.readSync(v.dataId),shape:v.shape})),f=T.computeOutShape(h.map(v=>v.shape),1),g=h[0].shape[0]===1,b=nQ(m,f,a,g),y=T.computeOutShape(e.map(v=>v.shape),t),x=n.makeTensorInfo(y,a,b);return h.forEach(v=>n.disposeIntermediateTensorInfo(v)),x}let s=e.filter(h=>w.sizeFromShape(h.shape)>0),i=G().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\")&&s[0].shape.length>1;if(s.length===1){let h=i?new rr(e[0].shape,Yr):new ts(e[0].shape,Yr);return n.runWebGLProgram(h,e,a)}let o=G().getNumber(\"WEBGL_MAX_TEXTURES_IN_SHADER\");if(s.length>o){let h=[];for(let f=0;f<s.length;f+=o){let g=s.slice(f,f+o);h.push(oc(g,t,n))}let m=oc(h,t,n);for(let f of h)n.disposeIntermediateTensorInfo(f);return m}if(i){let h=new hne(s.map(m=>m.shape),t);return n.runWebGLProgram(h,s,a)}let{tensors2D:l,outShape:u}=fne(s,t,n),p=new dne(l.map(h=>h.shape)),d=n.runWebGLProgram(p,l,a);l.forEach(h=>n.disposeIntermediateTensorInfo(h));let c=ce({inputs:{x:d},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(d),c}function fne(e,t,n){let a=T.computeOutShape(e.map(r=>r.shape),t);return{tensors2D:e.map(r=>ce({inputs:{x:r},attrs:{shape:[-1,w.sizeFromShape(r.shape.slice(t))]},backend:n})),outShape:a}}function UA(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=w.parseAxisParam(r,t[0].shape)[0],i=t.map(u=>u.shape);T.assertParamsConsistent(i,s);let o=T.computeOutShape(t.map(u=>u.shape),s);if(w.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(u=>w.sizeFromShape(u.shape)>0);return l.length===1?ta({inputs:{x:l[0]},backend:n}):oc(l,s,n)}var gne={kernelName:su,backendName:\"webgl\",kernelFunc:UA},GA=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=[\"x\",\"W\"],this.outputShape=e.outShape;let s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,p=e.dilationWidth,d=e.filterHeight,c=e.filterWidth,h=Math.floor(e.inChannels/4)*4,m=e.inChannels%4,f=e.dataFormat===\"channelsLast\",g=f?1:2,b=f?2:3,y=f?3:1,x=\"\",v=\"\";n&&(a?x=`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?x=`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:x=`\n          float activation(float x) {\n            ${n}\n          }\n        `,v=\"result = activation(result);\");let I=t?\"result += getBiasAtOutCoords();\":\"\";t&&this.variableNames.push(\"bias\"),a&&this.variableNames.push(\"preluActivationWeights\"),r&&this.variableNames.push(\"leakyreluAlpha\"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${y}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${c}; wC++) {\n            int xC = xCCorner + wC * ${p};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${h}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${f}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${m===1}) {\n\n              if (${f}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${h}) *\n                    getW(wR, wC, ${h}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${h}, xR, xC) *\n                    getW(wR, wC, ${h}, d2);\n              }\n\n            } else if (${m===2}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2)\n              );\n\n              if (${f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${m===3}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2),\n                getW(wR, wC, ${h} + 2, d2)\n              );\n\n              if (${f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1),\n                  getX(batch, xR, xC, ${h} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC),\n                  getX(batch, ${h} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${I}\n        ${v}\n        setOutput(result);\n      }\n    `}},bne=class{constructor(e){this.variableNames=[\"x\",\"W\"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,a=e.padInfo.left,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,p=e.filterDepth,d=e.filterHeight,c=e.filterWidth,h=Math.floor(e.inChannels/4)*4,m=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${r}, ${s}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${a});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${p}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${c}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${h}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${m===1}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${h}) *\n                  getW(wF, wR, wC, ${h}, d2);\n              } else if (${m===2}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${m===3}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1),\n                  getX(batch, xF, xR, xC, ${h} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2),\n                  getW(wF, wR, wC, ${h} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},HA=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=[\"x\",\"W\"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:\"pads\",type:\"ivec2\"},{name:\"strides\",type:\"ivec2\"},{name:\"dilations\",type:\"ivec2\"},{name:\"inDims\",type:\"ivec2\"}],this.outputShape=e.outShape,this.enableShapeUniforms=vn(this.outputShape.length);let s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,p=u,d=`\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;`;for(let f=0;f<u;f++)d+=`\n           vec4 xTexelC${f*2};\n           int xTexelC${f*2}Ready;\n           vec4 xTexelC${f*2+1};\n           int xTexelC${f*2+1}Ready;\n           vec4 xC${f};`;d+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let f=0;f<u;f++)d+=`\n           xTexelC${f*2} = vec4(0.0);\n           xTexelC${f*2}Ready = 0;\n           xTexelC${f*2+1} = vec4(0.0);\n           xTexelC${f*2+1}Ready = 0;\n           xC${f} = vec4(0.0);`;d+=`\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       `;for(let f=0;f<(p+1)/2;f++){let g=f*2;if(d+=`\n           xC = xCCorner + ${g*o};\n           `,i===1){if(g<u&&(s%2===1?(d+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {\n                   xTexelC${g} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${g}.zw = vec2(0.0);\n                   }\n                   xTexelC${g}Ready = 1;\n                 }\n               `,o===1&&g>0?d+=`\n                 xC${g} = vec4(xTexelC${g-2}.zw, xTexelC${g}.xy);\n                 `:d+=`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${g} = vec4(previous.zw, xTexelC${g}.xy);\n                   } else {\n                     xC${g} = vec4(0.0, 0.0, xTexelC${g}.xy);\n                   }\n                   `):d+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {\n                   xTexelC${g} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${g}.zw = vec2(0.0);\n                   }\n                   xTexelC${g}Ready = 1;\n                 }\n\n                 xC${g} = xTexelC${g};\n                 `,g+1<u)){let b=s%2===0?w.nearestLargerEven(o):o;o%2===0&&s%2===1||o%2!==0&&s%2!==1?(d+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${b};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {\n                     xTexelC${g+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${g+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${g+1}Ready = 1;\n                   }\n                   `,o>1?d+=`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${g+1} = vec4(previous.zw, xTexelC${g+1}.xy);\n                     } else {\n                      xC${g+1} = vec4(0.0, 0.0, xTexelC${g+1}.xy);\n                     }\n                     `:d+=`\n                     xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.xy);\n                     `):b===1?d+=`\n                     xC${g+1} = xTexelC${g};\n                     `:d+=`\n                     xCOffset = xC + ${b};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {\n                       xTexelC${g+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${g+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${g+1}Ready = 1;\n                     }\n\n                     xC${g+1} = xTexelC${g+1};\n                     `}}else g<u&&(s%2===1?(d+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {\n                   xTexelC${g} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${g}.zw = vec2(0.0);\n                   }\n                   xTexelC${g}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${g+1}Ready == 0) {\n                   xTexelC${g+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${g+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${g+1}Ready = 1;\n                 }\n\n                 xC${g} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);\n               `,g+1<u&&(d+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${g+1} = vec4(xTexelC${g+1}.xy, final.xy);\n                 `)):(d+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {\n                   xTexelC${g} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${g}.zw = vec2(0.0);\n                   }\n                   xTexelC${g}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {\n                   xTexelC${g+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${g+1}.zw = vec2(0.);\n                   }\n                   xTexelC${g+1}Ready = 1;\n                 }\n\n                 xC${g} = vec4(\n                   xTexelC${g}.xy, xTexelC${g+1}.xy);\n               `,g+1<u&&(d+=`\n                   xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);\n                 `)));g<u&&(d+=`\n             wTexel = getW(r, ${g}, d1, d2);\n             dotProd += xC${g}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${g}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,g+1<u&&(d+=`\n               wTexel = getW(r, ${g+1}, d1, d2);\n               dotProd += xC${g+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${g+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}d+=`\n     }\n   `,d+=`\n     }\n   `,d+=`\n     }\n   `;let c=\"\",h=\"\";n&&(a?c=`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:r?c=`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:c=`vec4 activation(vec4 x) {\n           ${n}\n         }`,h=\"result = activation(result);\");let m=t?\"result += getBiasAtOutCoords();\":\"\";t&&this.variableNames.push(\"bias\"),a&&this.variableNames.push(\"preluActivationWeights\"),r&&this.variableNames.push(\"leakyreluAlpha\"),this.userCode=`\n       ${c}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${d}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${m}\n         ${h}\n         setOutput(result);\n       }\n     `}},yne=class{constructor(e,t){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:\"inputShape\",type:\"ivec4\"},{name:\"pad\",type:\"ivec2\"},{name:\"stride\",type:\"ivec2\"},{name:\"dilation\",type:\"ivec2\"},{name:\"inChannels\",type:\"int\"},{name:\"itemsPerBlockRow\",type:\"int\"},{name:\"outWidth\",type:\"int\"}],this.outputShape=e,this.enableShapeUniforms=vn(this.outputShape.length);let{dataFormat:n}=t,a=En(),r=n===\"channelsLast\",s=r?1:2,i=r?2:3,o=this.enableShapeUniforms?\"if(blockIndex < outShape[2] && pos < outShape[1]) {\":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l=\"\";for(let u=0;u<=1;u++)for(let p=0;p<=1;p++)l+=`\n          blockIndex = rc.z + ${p};\n          pos = rc.y + ${u};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${s}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${r}) {\n                  innerDims = vec2(d1, ch);\n                  result[${u*2+p}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${u*2+p}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${a.output} = result;\n      }\n    `}};function mm(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function jA({x:e,filter:t,convInfo:n,backend:a,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let l=e.shape,u=a.texData.get(e.dataId),p=n.inChannels,d=l[0]*l[1]*l[2],c=n.outChannels,h=n.dataFormat===\"channelsLast\",m=!1,f=!1,g,b=[];if(s!=null){let y=mm(s.shape,h);y!=null&&(s=ce({inputs:{x:s},backend:a,attrs:{shape:y}}),b.push(s))}if(r!=null){let y=mm(r.shape,h);y!=null&&(r=ce({inputs:{x:r},backend:a,attrs:{shape:y}}),b.push(r))}if(!((d===1||c===1)&&p>LA)&&u.isPacked&&h&&u.texture!=null&&l[2]%2!==0&&w.arraysEqual(u.shape.slice(-3),l.slice(-3))){let y=l[0]*l[1]*(l[2]+1),x={dataId:e.dataId,shape:[1,y,n.inChannels],dtype:e.dtype},v=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,w.assert(Tc(u.shape,x.shape),()=>`packed reshape ${u.shape} to ${x.shape} isn't free`);let I=ce({inputs:{x:t},backend:a,attrs:{shape:[1,n.inChannels,n.outChannels]}});b.push(I);let N=hm({a:x,b:I,backend:a,transposeA:m,transposeB:f,bias:r,activation:o,preluActivationWeights:s,leakyreluAlpha:i}),C=a.texData.get(N.dataId);w.assert(C.isPacked,()=>\"batchMatMul result is expected to be packed\"),u.shape=v,C.shape=n.outShape,g=ta({inputs:{x:N},backend:a}),g.shape=n.outShape,b.push(N)}else{let y=n.outHeight*n.outWidth,x=ce({inputs:{x:e},backend:a,attrs:{shape:h?[n.batchSize,y,n.inChannels]:[n.batchSize,n.inChannels,y]}}),v=ce({inputs:{x:t},backend:a,attrs:{shape:[1,n.inChannels,n.outChannels]}}),I=hm({a:h?x:v,b:h?v:x,transposeA:!h,transposeB:f,backend:a,bias:r,activation:o,preluActivationWeights:s,leakyreluAlpha:i});g=ce({inputs:{x:I},backend:a,attrs:{shape:n.outShape}}),b.push(x),b.push(v),b.push(I)}for(let y of b)a.disposeIntermediateTensorInfo(y);return g}function qA({x:e,filter:t,convInfo:n,backend:a,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let{filterWidth:l,filterHeight:u,inChannels:p,outWidth:d,outHeight:c,dataFormat:h}=n,m=h===\"channelsLast\",f=l*u*p,g=c*d,b=[n.batchSize,f,g],y=!0,x=!1,v=[];if(s!=null){let K=mm(s.shape,m);K!=null&&(s=ce({inputs:{x:s},backend:a,attrs:{shape:K}}),v.push(s))}if(r!=null){let K=mm(r.shape,m);K!=null&&(r=ce({inputs:{x:r},backend:a,attrs:{shape:K}}),v.push(r))}let I=ce({inputs:{x:t},backend:a,attrs:{shape:[1,f,w.sizeFromShape(t.shape)/f]}});v.push(I);let N=new yne(b,n),C=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],_=a.runWebGLProgram(N,[e],\"float32\",C),F=ce({inputs:{x:_},backend:a,attrs:{shape:b}});v.push(_),v.push(F);let D=r!=null,$=s!=null,S=o===\"leakyrelu\",M=o?Cc(o,!0):null,B=new PA(m?F.shape:I.shape,m?I.shape:F.shape,m?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],y,x,D,M,$,S),U=m?[F,I]:[I,F];if(r&&U.push(r),$&&U.push(s),S){let K=a.makeTensorInfo([],\"float32\",w.createScalarValue(i,\"float32\"));U.push(K),v.push(K)}let H=a.runWebGLProgram(B,U,\"float32\"),q=ce({inputs:{x:H},backend:a,attrs:{shape:n.outShape}});v.push(H);for(let K of v)a.disposeIntermediateTensorInfo(K);return q}function xne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:p}=a,d=T.convertConv2DDataFormat(l),c=T.computeConv2DInfo(r.shape,s.shape,i,u,o,p,!1,d),h;if(c.filterHeight===1&&c.filterWidth===1&&c.dilationHeight===1&&c.dilationWidth===1&&c.strideHeight===1&&c.strideWidth===1&&(c.padInfo.type===\"SAME\"||c.padInfo.type===\"VALID\"))h=jA({x:r,filter:s,convInfo:c,backend:n});else if(c.strideWidth<=2&&d===\"channelsLast\"&&G().getBool(\"WEBGL_EXP_CONV\")){let f=new HA(c),g=[[c.padInfo.top,c.padInfo.left],[c.strideHeight,c.strideWidth],[c.dilationHeight,c.dilationWidth],[c.inHeight,c.inWidth]];h=n.runWebGLProgram(f,[r,s],\"float32\",g)}else if(G().getBool(\"WEBGL_CONV_IM2COL\"))h=qA({x:r,filter:s,convInfo:c,backend:n});else{let f=new GA(c);h=n.runWebGLProgram(f,[r,s],\"float32\")}let m=ce({inputs:{x:h},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(h),m}var vne={kernelName:Pi,backendName:\"webgl\",kernelFunc:xne},wne=class{constructor(e){this.variableNames=[\"x\",\"dy\"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,s=e.dataFormat===\"channelsLast\";this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${a};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${r};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${s?`float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);`}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},kne=class{constructor(e){this.variableNames=[\"dy\",\"W\"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=e.dataFormat===\"channelsLast\",i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=s?1:2,u=s?2:3,p=s?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${p}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},Ine=class{constructor(e){this.variableNames=[\"x\",\"dy\"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${r};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${s};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${a} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},Sne=class{constructor(e){this.variableNames=[\"dy\",\"W\"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=a-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${r}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${a}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${a} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function Nne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:p}=a,d=T.convertConv2DDataFormat(l),c=T.computeConv2DInfo(r.shape,p,i,1,o,u,!1,d),h=new wne(c);return n.runWebGLProgram(h,[r,s],\"float32\")}var Tne={kernelName:km,backendName:\"webgl\",kernelFunc:Nne},Cne=class{constructor(e){this.variableNames=[\"dy\",\"W\"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:\"strides\",type:\"vec2\"}],this.outputShape=e.inShape,this.enableShapeUniforms=vn(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,a=t-1-e.padInfo.top,r=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${r});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}};function Ene(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:p}=a,d=T.convertConv2DDataFormat(u),c=T.computeConv2DInfo(i,s.shape,o,1,l,p,!1,d);if(G().getBool(\"WEBGL_PACK_CONV2DTRANSPOSE\")&&d===\"channelsLast\"){let h=[[c.strideHeight,c.strideWidth]],m=new Cne(c);return n.runWebGLProgram(m,[r,s],\"float32\",h)}else{let h=new kne(c);return n.runWebGLProgram(h,[r,s],\"float32\")}}var _ne={kernelName:Li,backendName:\"webgl\",kernelFunc:Ene};function Ane(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a,u=T.computeConv3DInfo(r.shape,s.shape,i,l,o),p=new bne(u);return n.runWebGLProgram(p,[r,s],\"float32\")}var Fne={kernelName:zi,backendName:\"webgl\",kernelFunc:Ane};function $ne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:l}=a,u=T.computeConv3DInfo(r.shape,l,i,1,o),p=new Ine(u);return n.runWebGLProgram(p,[r,s],\"float32\")}var Dne={kernelName:iu,backendName:\"webgl\",kernelFunc:$ne};function Rne(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:l}=a,u=T.computeConv3DInfo(l,s.shape,o,1,i),p=new Sne(u);return n.runWebGLProgram(p,[r,s],\"float32\")}var Mne={kernelName:ou,backendName:\"webgl\",kernelFunc:Rne},One=mp+`\n  return cos(x);\n`,Pne=`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${Qo}\n  return result;\n`,Lne=Ze({opSnippet:One,packedOpSnippet:Pne}),zne={kernelName:Wi,backendName:\"webgl\",kernelFunc:Lne},Wne=`\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n`,Bne=Ze({opSnippet:Wne}),Vne={kernelName:Bi,backendName:\"webgl\",kernelFunc:Bne},Une=class{constructor(e,t,n,a,r){this.variableNames=[\"Image\",\"Boxes\",\"BoxInd\"],this.outputShape=[];let[s,i,o,l]=e,[u]=t,[p,d]=n;this.outputShape=[u,p,d,l];let c=a===\"bilinear\"?1:0,[h,m]=[`${i-1}.0`,`${o-1}.0`],[f,g,b]=p>1?[`${(i-1)/(p-1)}`,\"(y2-y1) * height_ratio\",`y1*${h} + float(y)*(height_scale)`]:[\"0.0\",\"0.0\",`0.5 * (y1+y2) * ${h}`],[y,x,v]=d>1?[`${(o-1)/(d-1)}`,\"(x2-x1) * width_ratio\",`x1*${m} + float(x)*(width_scale)`]:[\"0.0\",\"0.0\",`0.5 * (x1+x2) * ${m}`];this.userCode=`\n      const float height_ratio = float(${f});\n      const float width_ratio = float(${y});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${x};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${h} ) {\n          setOutput(float(${r}));\n          return;\n        }\n        float in_x = ${v};\n        if( in_x < 0.0 || in_x > ${m} ) {\n          setOutput(float(${r}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${c} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}},Gne=e=>{let{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=a,p=new Une(r.shape,s.shape,o,l,u);return n.runWebGLProgram(p,[r,s,i],\"float32\")},Hne={kernelName:uu,backendName:\"webgl\",kernelFunc:Gne},_c;(function(e){e.Prod=\"*\",e.Sum=\"+\"})(_c||(_c={}));var gS=class{constructor(e,t,n,a){this.op=e,this.outputShape=t,this.variableNames=[\"x\"],this.customUniforms=[{name:\"index\",type:\"float\"}];let r=this.outputShape.length,s=this.op===_c.Prod?\"1.0\":\"0.0\",i=n?s:`getX(${bS(r,\"coords\",this.op)})`,o=this.outputShape[this.outputShape.length-1],l=\"\",u=\"\";n?(l=a?`end != ${o-1}`:\"end != 0\",u=a?\"end + 1\":\"end - 1\"):(l=a?`end + pow2 < ${o}`:\"end >= pow2\",u=a?\"end + pow2\":\"end - pow2\"),this.userCode=`\n      void main() {\n        ${ht(r)} coords = getOutputCoords();\n        int end = ${yS(r,\"coords\",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${yS(r,\"coords\",this.op)} = idx;\n          val ${this.op}= getX(${bS(r,\"coords\",this.op)});\n        }\n        setOutput(val);\n      }\n    `}};function bS(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function yS(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function KA(e,t,n,a,r,s){let i=t.shape.length,o=T.getAxesPermutation([a],i),l=t;o!=null&&(l=Sn({inputs:{x:t},backend:n,attrs:{perm:o}}));let u=T.getInnerMostAxes(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${a}`);let p=l.shape[u],d=ta({inputs:{x:l},backend:n});for(let c=0;c<=Math.ceil(Math.log2(p))-1;c++){let h=new gS(e,l.shape,!1,s),m=[[c]],f=d;d=n.runWebGLProgram(h,[d],d.dtype,m),n.disposeIntermediateTensorInfo(f)}if(r){let c=new gS(e,l.shape,r,s),h=d;d=n.runWebGLProgram(c,[d],d.dtype),n.disposeIntermediateTensorInfo(h)}if(o!=null){let c=T.getUndoAxesPermutation(o),h=Sn({inputs:{x:d},backend:n,attrs:{perm:c}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),h}return d}function jne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;return KA(_c.Prod,r,n,s,i,o)}var qne={kernelName:lu,backendName:\"webgl\",kernelFunc:jne};function Kne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;return KA(_c.Sum,r,n,s,i,o)}var Xne={kernelName:Vi,backendName:\"webgl\",kernelFunc:Kne};function Yne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i,binaryOutput:o}=a;if(r.shape.length===1){let l=n.readSync(r.dataId),u=n.readSync(s.dataId),p=TA(l,u,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,p)}else if(r.shape.length===2){let l=n.bufferSync(r),u=n.bufferSync(s),p=J9(l,u,i,o);return n.makeTensorInfo(p.shape,s.dtype,p.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}var Zne={kernelName:Pc,backendName:\"webgl\",kernelFunc:Yne},Jne=class{constructor(e,t,n){this.variableNames=[\"x\"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return this.dataFormat===\"NHWC\"?\"coords[1]\":\"coords[2]\"}getWidthCoordString(){return this.dataFormat===\"NHWC\"?\"coords[2]\":\"coords[3]\"}getDepthCoordString(){return this.dataFormat===\"NHWC\"?\"coords[3]\":\"coords[1]\"}getOutputDepthSize(){return this.dataFormat===\"NHWC\"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat===\"NHWC\"?\"getX(b, in_h, in_w, in_d)\":\"getX(b, in_d, in_h, in_w)\"}};function Qne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:i}=a,o=r.shape[0],l=i===\"NHWC\"?r.shape[1]:r.shape[2],u=i===\"NHWC\"?r.shape[2]:r.shape[3],p=i===\"NHWC\"?r.shape[3]:r.shape[1],d=l*s,c=u*s,h=p/(s*s),m=i===\"NHWC\"?[o,d,c,h]:[o,h,d,c],f=new Jne(m,s,i);return n.runWebGLProgram(f,[r],r.dtype)}var eae={kernelName:pu,backendName:\"webgl\",kernelFunc:Qne},XA=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=[\"x\",\"W\"],this.customUniforms=[{name:\"pads\",type:\"ivec2\"},{name:\"strides\",type:\"ivec2\"},{name:\"dilations\",type:\"ivec2\"},{name:\"inDims\",type:\"ivec2\"}],this.outputShape=e.outShape,this.enableShapeUniforms=vn(this.outputShape.length);let s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,l=\"\",u=\"\";n&&(a?l=`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?l=`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:l=`\n          float activation(float x) {\n            ${n}\n          }\n        `,u=\"result = activation(result);\");let p=t?\"result += getBiasAtOutCoords();\":\"\";t&&this.variableNames.push(\"bias\"),a&&this.variableNames.push(\"preluActivationWeights\"),r&&this.variableNames.push(\"leakyreluAlpha\"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${p}\n        ${u}\n        setOutput(result);\n      }\n    `}},YA=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=[\"x\",\"W\"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:\"pads\",type:\"ivec2\"},{name:\"strides\",type:\"ivec2\"},{name:\"dilations\",type:\"ivec2\"},{name:\"inDims\",type:\"ivec2\"}],this.outputShape=e.outShape,this.enableShapeUniforms=vn(this.outputShape.length);let s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,p=e.filterWidth,d=p,c=`\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<p;g++)c+=`\n          vec4 xTexelC${g*2};\n          int xTexelC${g*2}Ready;\n          vec4 xTexelC${g*2+1};\n          int xTexelC${g*2+1}Ready;\n          vec4 xC${g};`;c+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let g=0;g<p;g++)c+=`\n          xTexelC${g*2} = vec4(0.0);\n          xTexelC${g*2}Ready = 0;\n          xTexelC${g*2+1} = vec4(0.0);\n          xTexelC${g*2+1}Ready = 0;\n          xC${g} = vec4(0.0);`;c+=`\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      `;for(let g=0;g<(d+1)/2;g++){let b=g*2;if(c+=`\n          xC = xCCorner + ${b*l};\n          `,o===1){if(b<p&&(i%2===1?(c+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n              `,l===1&&b>0?c+=`\n                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);\n                `:c+=`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);\n                  } else {\n                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);\n                  }\n                  `):c+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                xC${b} = xTexelC${b};\n                `,b+1<p)){let y=i%2===0?w.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(c+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${y};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${b+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${b+1}Ready = 1;\n                  }\n                  `,l>1?c+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);\n                    } else {\n                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);\n                    }\n                    `:c+=`\n                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);\n                    `):y===1?c+=`\n                    xC${b+1} = xTexelC${b};\n                    `:c+=`\n                    xCOffset = xC + ${y};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${b+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${b+1}Ready = 1;\n                    }\n\n                    xC${b+1} = xTexelC${b+1};\n                    `}}else b<p&&(i%2===1?(c+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {\n                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${b+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${b+1}Ready = 1;\n                }\n\n                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);\n              `,b+1<p&&(c+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);\n                `)):(c+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b+1}.zw = vec2(0.);\n                  }\n                  xTexelC${b+1}Ready = 1;\n                }\n\n                xC${b} = vec4(\n                  xTexelC${b}.xy, xTexelC${b+1}.xy);\n              `,b+1<p&&(c+=`\n                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);\n                `)));b<p&&(c+=`\n            wTexel = getW(r, ${b}, d1, q);\n            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);\n          `,b+1<p&&(c+=`\n              wTexel = getW(r, ${b+1}, d1, q);\n              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}c+=`\n    }\n  `,c+=`\n      }\n    `;let h=\"\",m=\"\";n&&(a?h=`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?h=`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:h=`vec4 activation(vec4 x) {\n          ${n}\n        }`,m=\"result = activation(result);\");let f=t?\"result += getBiasAtOutCoords();\":\"\";t&&this.variableNames.push(\"bias\"),a&&this.variableNames.push(\"preluActivationWeights\"),r&&this.variableNames.push(\"leakyreluAlpha\"),this.userCode=`\n      ${h}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${c}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${f}\n        ${m}\n        setOutput(result);\n      }\n    `}};function tae(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=a,p=l;p==null&&(p=[1,1]),w.assert(T.eitherStridesOrDilationsAreOne(i,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`);let d=T.computeConv2DInfo(r.shape,s.shape,i,p,o,u,!0),c;G().getBool(\"WEBGL_PACK_DEPTHWISECONV\")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?c=new YA(d):c=new XA(d);let h=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(c,[r,s],\"float32\",h)}var nae={kernelName:Ui,backendName:\"webgl\",kernelFunc:tae},aae=class{constructor(e){this.variableNames=[\"x\",\"dy\"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${s} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${a};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${r};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},rae=class{constructor(e){this.variableNames=[\"dy\",\"W\"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function sae(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:p}=a,d=T.computeConv2DInfo(r.shape,p,i,o,l,u,!0),c=new aae(d);return n.runWebGLProgram(c,[r,s],\"float32\")}var iae={kernelName:Im,backendName:\"webgl\",kernelFunc:sae};function oae(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:p}=a,d=T.computeConv2DInfo(p,s.shape,i,o,l,u,!0),c=new rae(d);return n.runWebGLProgram(c,[r,s],\"float32\")}var lae={kernelName:Sm,backendName:\"webgl\",kernelFunc:oae},uae=class{constructor(e){this.variableNames=[\"X\"],this.outputShape=[e,e],this.userCode=`\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    `}};function pae(e){let{inputs:t,backend:n}=e,{x:a}=t,r=[...a.shape,...a.shape],s=w.sizeFromShape(a.shape),i=ce({inputs:{x:a},backend:n,attrs:{shape:[s]}}),o=new uae(s),l=n.runWebGLProgram(o,[i],i.dtype),u=ce({inputs:{x:l},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}var cae={kernelName:Lc,backendName:\"webgl\",kernelFunc:pae},dae=class{constructor(e){this.variableNames=[\"x\",\"W\"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:a,strideHeight:r,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:p,left:d}=a;this.userCode=`\n      const ivec2 strides = ivec2(${r}, ${s});\n      const ivec2 pads = ivec2(${p}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}};function hae(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a,u=T.computeDilation2DInfo(r.shape,s.shape,i,o,\"NHWC\",l),p,d=new dae(u);p=n.runWebGLProgram(d,[r,s],\"float32\");let c=ce({inputs:{x:p},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(p),c}var mae={kernelName:Gi,backendName:\"webgl\",kernelFunc:hae};function fae(e){let{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,s=t,{allDims:i,summedDims:o,idDims:l}=T.decodeEinsumEquation(r,s.length);T.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:p}=T.getEinsumComputePath(o,l),d=p.length,c=null,h=i.length,m=[];for(let f=0;f<d;++f){for(let g of p[f]){let{permutationIndices:b,expandDims:y}=T.getEinsumPermutation(h,l[g]),x;T.isIdentityPermutation(b)?x=s[g]:(x=Sn({inputs:{x:s[g]},backend:n,attrs:{perm:b}}),m.push(x));let v=x.shape.slice();for(let I=0;I<y.length;++I)v.splice(y[I],0,1);w.arraysEqual(x.shape,v)||(x=ce({inputs:{x},backend:n,attrs:{shape:v}}),m.push(x)),c===null?c=x:(c=pk({inputs:{a:x,b:c},backend:n}),m.push(c))}f<d-1&&(u[f]>=0&&(c=Vf({inputs:{x:c},backend:n,attrs:{axis:u[f]-(i.length-h),keepDims:!1}}),m.push(c)),h--)}for(let f of m)f!==c&&n.disposeIntermediateTensorInfo(f);return c}var gae={kernelName:Tm,backendName:\"webgl\",kernelFunc:fae},bae=\"return (x >= 0.0) ? x : (exp(x) - 1.0);\",yae=`\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n`,xae=Ze({opSnippet:bae,packedOpSnippet:yae}),vae={kernelName:ji,backendName:\"webgl\",kernelFunc:xae},wae=\"return (b >= 0.0) ? a : a * (b + 1.0);\",kae=`\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n`,Iae=e=>{let{inputs:t,backend:n}=e,{dy:a,y:r}=t,s=G().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")?new hp(kae,a.shape,r.shape):new ki(wae,a.shape,r.shape);return n.runWebGLProgram(s,[a,r],a.dtype)},Sae={kernelName:cu,backendName:\"webgl\",kernelFunc:Iae},Nae=`\n  return vec4(equal(a, b));\n`,Tae=\"return float(a == b);\",Cae=hn({opSnippet:Tae,packedOpSnippet:Nae,dtype:\"bool\",cpuKernelImpl:aQ}),Eae={kernelName:du,backendName:\"webgl\",kernelFunc:Cae},_ae=`\n  // Error function is calculated approximately with elementary function.\n  // See \"Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables\", Abramowitz and Stegun.\n  float p = ${T.ERF_P};\n  float a1 = ${T.ERF_A1};\n  float a2 = ${T.ERF_A2};\n  float a3 = ${T.ERF_A3};\n  float a4 = ${T.ERF_A4};\n  float a5 = ${T.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`,Aae=Ze({opSnippet:_ae}),Fae={kernelName:qi,backendName:\"webgl\",kernelFunc:Aae},$ae=mp+`\n  return exp(x);\n`,Dae=`\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`,ZA=Ze({opSnippet:$ae,packedOpSnippet:Dae,cpuKernelImpl:rQ,dtype:\"float32\"}),Rae={kernelName:Ki,backendName:\"webgl\",kernelFunc:ZA};function gv(e){let{inputs:t,attrs:n,backend:a}=e,{dim:r}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice(),l=r;return r<0&&(w.assert(-(i+1)<=r,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+r+1),o.splice(l,0,1),ce({inputs:{x:s},backend:a,attrs:{shape:o}})}var Mae={kernelName:hu,backendName:\"webgl\",kernelFunc:gv},xS=\"return exp(x) - 1.0;\",Oae=Ze({opSnippet:xS,packedOpSnippet:xS,cpuKernelImpl:sQ}),Pae={kernelName:Xi,backendName:\"webgl\",kernelFunc:Oae},vS=class{constructor(e,t,n){this.variableNames=[\"real\",\"imag\"];let a=t[1];this.outputShape=t;let r=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${a}.0`:\"1.0\",i;if(e===\"real\")i=\"return real * expR - imag * expI;\";else if(e===\"imag\")i=\"return real * expI + imag * expR;\";else throw new Error(`FFT component must be either \"real\" or \"imag\", got ${e}.`);this.userCode=`\n      const float exponentMultiplier = ${r};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${a});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${a}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${s};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}};function JA(e,t,n){let a=n.texData.get(e.dataId),r=w.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=r/s,o=ce({inputs:{x:e},backend:n,attrs:{shape:[i,s]}}),l=o.shape,u=new vS(\"real\",l,t),p=new vS(\"imag\",l,t),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:l},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:l}],c=n.runWebGLProgram(u,d,\"float32\"),h=n.runWebGLProgram(p,d,\"float32\"),m=$s({inputs:{real:c,imag:h},backend:n});n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h);let f=ce({inputs:{x:m},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(m),f}function Lae(e){let{inputs:t,backend:n}=e,{input:a}=t;return JA(a,!1,n)}var zae={kernelName:Cm,backendName:\"webgl\",kernelFunc:Lae},Wae=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:\"value\",type:\"float\"}],this.variableNames=[\"x\"],this.outputShape=e,this.userCode=`\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    `}};function $d(e){let{backend:t,attrs:n}=e,{shape:a,value:r}=n,{dtype:s}=n;if(s=s||w.inferDtype(r),s===\"string\"){let i=w.getArrayFromDType(s,w.sizeFromShape(a));return i.fill(r),t.makeTensorInfo(a,s,i)}else{let i=new Wae(a,r),o=[[r]];return t.runWebGLProgram(i,[],s,o)}}var Bae={kernelName:zc,backendName:\"webgl\",kernelFunc:$d},Vae=class{constructor(e){this.variableNames=[\"Image\"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},Uae={kernelName:mu,backendName:\"webgl\",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,a=t,r=new Vae(n.shape);return a.runWebGLProgram(r,[n],n.dtype)}},wS=\"return floor(x);\",Gae=Ze({opSnippet:wS,packedOpSnippet:wS,cpuKernelImpl:iQ}),Hae={kernelName:Yi,backendName:\"webgl\",kernelFunc:Gae},jae=`\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n`,qae=`\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n`,Kae=hn({opSnippet:jae,packedOpSnippet:qae,dtype:\"int32\"}),Xae={kernelName:Zi,backendName:\"webgl\",kernelFunc:Kae},Yae=class{constructor(e){this.variableNames=[\"A\"];let t=En(),[n,a]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}},Zae=class{constructor(e){this.variableNames=[\"A\"],this.packedInputs=!1,this.packedOutput=!0;let t=En(),[n,a]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${a}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}},Jae={kernelName:Hh,backendName:\"webgl\",kernelFunc:Qae},Il,xx=G().getBool(\"CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU\");function Qae(e){let{inputs:t,backend:n,attrs:a}=e,{pixels:r}=t,{numChannels:s}=a,i=typeof HTMLVideoElement!=\"undefined\"&&r instanceof HTMLVideoElement,o=typeof HTMLImageElement!=\"undefined\"&&r instanceof HTMLImageElement,[l,u]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height],p=[u,l],d=[u,l,s];if(o||i){let f=G().getBool(\"CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU\");(Il==null||f!==xx)&&(xx=f,Il=document.createElement(\"canvas\").getContext(\"2d\",{willReadFrequently:xx})),Il.canvas.width=l,Il.canvas.height=u,Il.drawImage(r,0,0,l,u),r=Il.canvas}let c=n.makeTensorInfo(p,\"int32\");n.texData.get(c.dataId).usage=ca.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(c.dataId),r);let h=G().getBool(\"WEBGL_PACK\")?new Zae(d):new Yae(d),m=n.runWebGLProgram(h,[c],\"int32\");return n.disposeData(c.dataId),m}function ere(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:p,dilations:d,dimRoundingMode:c,activation:h,leakyreluAlpha:m}=a,f=T.convertConv2DDataFormat(p),g=T.computeConv2DInfo(r.shape,s.shape,l,d,u,c,!1,f),b,y=[],x=i!=null,v=o!=null,I=h===\"leakyrelu\",N=()=>{let _=[r,s],F=(D,$)=>{if($===\"NCHW\"&&D.shape.length===1&&D.shape[0]!==1){let S=ce({inputs:{x:D},backend:n,attrs:{shape:[D.shape[0],1,1]}});return y.push(S),S}return D};if(x&&_.push(F(i,p)),v&&_.push(F(o,p)),I){let D=n.makeTensorInfo([],\"float32\",w.createScalarValue(m,\"float32\"));_.push(D),y.push(D)}return _};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type===\"SAME\"||g.padInfo.type===\"VALID\"))b=jA({x:r,filter:s,convInfo:g,backend:n,bias:i,activation:h,preluActivationWeights:o,leakyreluAlpha:m});else if(g.strideWidth<=2&&f===\"channelsLast\"&&G().getBool(\"WEBGL_EXP_CONV\")){let _=h?Cc(h,!0):null,F=new HA(g,x,_,v,I),D=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],$=N();b=n.runWebGLProgram(F,$,\"float32\",D)}else if(G().getBool(\"WEBGL_CONV_IM2COL\"))b=qA({x:r,filter:s,convInfo:g,backend:n,bias:i,activation:h,preluActivationWeights:o,leakyreluAlpha:m});else{let _=h?Cc(h,!1):null,F=new GA(g,x,_,v,I),D=N();b=n.runWebGLProgram(F,D,\"float32\")}let C=ce({inputs:{x:b},backend:n,attrs:{shape:g.outShape}});return y.push(b),y.forEach(_=>n.disposeIntermediateTensorInfo(_)),C}var tre={kernelName:oi,backendName:\"webgl\",kernelFunc:ere};function nre(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:p,dimRoundingMode:d,activation:c,leakyreluAlpha:h}=a,m=[],f=p;f==null&&(f=[1,1]),w.assert(T.eitherStridesOrDilationsAreOne(l,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${f}'`);let g=T.computeConv2DInfo(r.shape,s.shape,l,f,u,d,!0),b=G().getBool(\"WEBGL_PACK_DEPTHWISECONV\")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,y=c?Cc(c,b):null,x=[r,s],v=i!=null,I=o!=null,N=c===\"leakyrelu\";if(v&&x.push(i),I&&x.push(o),N){let D=n.makeTensorInfo([],\"float32\",w.createScalarValue(h,\"float32\"));x.push(D),m.push(D)}let C;b?C=new YA(g,v,y,I,N):C=new XA(g,v,y,I,N);let _=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],F=n.runWebGLProgram(C,x,\"float32\",_);return m.forEach(D=>n.disposeIntermediateTensorInfo(D)),F}var are={kernelName:li,backendName:\"webgl\",kernelFunc:nre},rre=class{constructor(e,t,n,a){this.sliceDim=e,this.strides=t,this.paramsShape=a,this.variableNames=[\"x\",\"indices\"],this.outputShape=n;let r=ht(n.length),s=`\n    int index;`;for(let i=0;i<this.sliceDim;i++)s+=`\n          index = round(getIndices(coords[0], ${i}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};\n          flattenIndex += index * ${this.strides[i]};`;this.userCode=`\n         void main() {\n          ${r} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${s}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}};function sre(e){let{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=r.shape,i=s[s.length-1],o=w.sizeFromShape(a.shape),[l,u,p,d]=T.prepareAndValidate(a,r),c=ce({inputs:{x:r},backend:n,attrs:{shape:[u,i]}}),h=ce({inputs:{x:a},backend:n,attrs:{shape:[w.sizeFromShape(a.shape)/p,p]}});if(n.shouldExecuteOnCPU([a,r])||a.dtype===\"string\"){let b=n.readSync(r.dataId),y=n.bufferSync(a),x=oQ(b,y,a.dtype,u,i,p,d,a.shape,o);return n.makeTensorInfo(l,a.dtype,x.values)}let m=new rre(i,d,[u,p],a.shape),f=n.runWebGLProgram(m,[h,c],h.dtype),g=ce({inputs:{x:f},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),g}var ire={kernelName:gu,backendName:\"webgl\",kernelFunc:sre},ore=class{constructor(e,t){this.variableNames=[\"A\",\"indices\"],this.outputShape=t,this.rank=t.length;let n=ht(this.rank),a=lre(e,2);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${a}));\n      }\n    `}};function lre(e,t){let n=[\"resRC.x\",\"resRC.y\",\"resRC.z\",\"resRC.w\"],a=[];for(let r=0;r<e.length;r++)r===2?a.push(\"index\"):a.push(`${n[r]}`);return a.join()}function QA(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:i,batchDims:o}=a,l=w.parseAxisParam(i,r.shape)[0];if(G().get(\"DEBUG\")){let y=n.readSync(s.dataId),x=r.shape[l];for(let v=0;v<y.length;++v){let I=y[v];w.assert(I<=x-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${x-1}]`)}}let u=T.segment_util.collectGatherOpShapeInfo(r,s,l,o),p=w.sizeFromShape(s.shape),d=[],c=ce({inputs:{x:r},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),h=ce({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,p/u.batchSize]}});d.push(c),d.push(h);let m=[u.batchSize,u.outerSize,p/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([r,s])||r.dtype===\"string\"){let y=n.bufferSync(h),x=n.bufferSync(c),v=lQ(x,y,m);return d.forEach(I=>n.disposeIntermediateTensorInfo(I)),n.makeTensorInfo(u.outputShape,v.dtype,v.values)}let f=new ore(c.shape,m),g=n.runWebGLProgram(f,[c,h],c.dtype);d.push(g);let b=ce({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return d.forEach(y=>n.disposeIntermediateTensorInfo(y)),b}var ure={kernelName:fu,backendName:\"webgl\",kernelFunc:QA},pre=\"return float(a > b);\",cre=`\n  return vec4(greaterThan(a, b));\n`,dre=hn({opSnippet:pre,packedOpSnippet:cre,cpuKernelImpl:uQ,dtype:\"bool\"}),hre={kernelName:bu,backendName:\"webgl\",kernelFunc:dre},mre=\"return float(a >= b);\",fre=`\n  return vec4(greaterThanEqual(a, b));\n`,gre=hn({opSnippet:mre,packedOpSnippet:fre,dtype:\"bool\",cpuKernelImpl:pQ}),bre={kernelName:Qi,backendName:\"webgl\",kernelFunc:gre};function yre(e){let{inputs:t,backend:n}=e,{input:a}=t;return JA(a,!0,n)}var xre={kernelName:Em,backendName:\"webgl\",kernelFunc:yre},vre=\"return float(!isnan(x) && !isinf(x));\",wre=Ze({opSnippet:vre,dtype:\"bool\"}),kre={kernelName:to,backendName:\"webgl\",kernelFunc:wre},Ire=\"return float(isinf(x));\",Sre=Ze({opSnippet:Ire,dtype:\"bool\"}),Nre={kernelName:no,backendName:\"webgl\",kernelFunc:Sre},Tre=\"return float(isnan(x));\",Cre=Ze({opSnippet:Tre,dtype:\"bool\"}),Ere={kernelName:ao,backendName:\"webgl\",kernelFunc:Cre},_re=\"return float(a < b);\",Are=`\n  return vec4(lessThan(a, b));\n`,Fre=hn({opSnippet:_re,packedOpSnippet:Are,cpuKernelImpl:cQ,dtype:\"bool\"}),$re={kernelName:yu,backendName:\"webgl\",kernelFunc:Fre},Dre=\"return float(a <= b);\",Rre=`\n  return vec4(lessThanEqual(a, b));\n`,Mre=hn({opSnippet:Dre,packedOpSnippet:Rre,cpuKernelImpl:dQ,dtype:\"bool\"}),Ore={kernelName:xu,backendName:\"webgl\",kernelFunc:Mre};function Pre(e){let{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,i=hQ(a,r,s);return t.makeTensorInfo([i.length],\"float32\",i)}var Lre={kernelName:vu,backendName:\"webgl\",kernelFunc:Pre},zre=mp+`\n  return x < 0.0 ? 0./0. : log(x);\n`,Wre=`\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n`,Bre=Ze({opSnippet:zre,packedOpSnippet:Wre,cpuKernelImpl:mQ}),Vre={kernelName:so,backendName:\"webgl\",kernelFunc:Bre},Ure=mp+`\n  return log(1.0 + x);\n`,Gre=Ze({opSnippet:Ure}),Hre={kernelName:io,backendName:\"webgl\",kernelFunc:Gre},jre=\"return float(a >= 1.0 && b >= 1.0);\",qre=`\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n`,Kre=hn({opSnippet:jre,packedOpSnippet:qre,dtype:\"bool\"}),Xre={kernelName:wu,backendName:\"webgl\",kernelFunc:Kre},Yre=\"return float(!(x >= 1.0));\",Zre=Ze({opSnippet:Yre}),Jre={kernelName:ku,backendName:\"webgl\",kernelFunc:Zre},Qre=\"return float(a >= 1.0 || b >= 1.0);\",ese=`\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n`,tse=hn({opSnippet:Qre,packedOpSnippet:ese,dtype:\"bool\"}),nse={kernelName:Iu,backendName:\"webgl\",kernelFunc:tse},ase=class{constructor(e,t,n,a,r){this.variableNames=[\"x\"],this.outputShape=[];let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${a}) * sum`;r===.5?o=`inversesqrt(${l})`:r===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}},rse=class{constructor(e,t,n,a,r){this.variableNames=[\"x\"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${a}) * sum`;r===.5?o=`inversesqrt(${l})`:r===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}},sse=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=a,u=G().getBool(\"WEBGL_PACK_NORMALIZATION\")?new rse(r.shape,s,i,o,l):new ase(r.shape,s,i,o,l);return n.runWebGLProgram(u,[r],r.dtype)},ise={kernelName:oo,backendName:\"webgl\",kernelFunc:sse},ose=class{constructor(e,t,n,a,r){this.variableNames=[\"inputImage\",\"outputImage\",\"dy\"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=a,this.beta=r,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${a}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${a})\n                * float(${r})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${r});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}},lse=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:p}=a,d=new ose(r.shape,o,l,u,p);return n.runWebGLProgram(d,[r,s,i],r.dtype)},use={kernelName:Su,backendName:\"webgl\",kernelFunc:lse};function pse(e,t,n,a){let r=w.sizeFromShape(t),s=w.sizeFromShape(e.shape)/r,i=ce({inputs:{x:e},attrs:{shape:[s,r]},backend:a}),o=el(i,e.dtype,\"max\",a),l=ce({inputs:{x:o},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(i),a.disposeIntermediateTensorInfo(o),l}function eF(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:i}=a,o=r.shape.length,l=w.parseAxisParam(s,r.shape),u=l,p=T.getAxesPermutation(u,o),d=p!=null,c=n.shouldExecuteOnCPU([r]),h=r;if(d){if(c){let y=n.texData.get(h.dataId).values,x=new Array(o);for(let N=0;N<x.length;N++)x[N]=r.shape[p[N]];let v=ok(y,r.shape,r.dtype,p,x);h=n.makeTensorInfo(x,r.dtype);let I=n.texData.get(h.dataId);I.values=v}else h=Bf(r,p,n);u=T.getInnerMostAxes(u.length,o)}T.assertAxesAreInnerMostDims(\"max\",u,o);let[m,f]=T.computeOutAndReduceShapes(h.shape,u),g=m;i&&(g=T.expandShapeToKeepDim(m,l));let b;if(c){let y=n.texData.get(h.dataId).values,x=fQ(y,w.sizeFromShape(f),g,r.dtype);b=n.makeTensorInfo(g,r.dtype);let v=n.texData.get(b.dataId);v.values=x}else b=pse(h,f,g,n);return d&&n.disposeIntermediateTensorInfo(h),b}var cse={kernelName:lo,backendName:\"webgl\",kernelFunc:eF},dse=uk+`\n  return max(a, b);\n`,hse=`\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  `+Qo+`\n  return result;\n`,mse=hn({opSnippet:dse,packedOpSnippet:hse,cpuKernelImpl:gQ}),fse={kernelName:uo,backendName:\"webgl\",kernelFunc:mse};function gse(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;lp(r,\"maxPool\");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=a,u=1;w.assert(T.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let p=T.computePool2DInfo(r.shape,s,i,u,o,l);if(p.filterWidth===1&&p.filterHeight===1&&w.arraysEqual(p.inShape,p.outShape))return ta({inputs:{x:r},backend:n});let d=new Ec(p,\"max\",!1);return n.runWebGLProgram(d,[r],r.dtype)}var bse={kernelName:po,backendName:\"webgl\",kernelFunc:gse};function yse(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=a,p=[1,1,1],d=T.computePool3DInfo(r.shape,s,i,p,o,u,l),c=new ck(d,\"max\",!1);return n.runWebGLProgram(c,[r],r.dtype)}var xse={kernelName:Nu,backendName:\"webgl\",kernelFunc:yse},vse=class{constructor(e){this.variableNames=[\"dy\",\"maxPos\"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,a=e.dilationHeight,r=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=r-1-e.padInfo.top,o=s-1-e.padInfo.left,l=r*s-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${r};\n          wR += ${a}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},wse=class{constructor(e){this.variableNames=[\"dy\",\"maxPos\"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,p=o-1-e.padInfo.front,d=l-1-e.padInfo.top,c=u-1-e.padInfo.left,h=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${d}, ${c});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${r}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${s}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${h} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function kse(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:p}=a,d=[1,1,1],c=T.computePool3DInfo(i.shape,o,l,d,u,p),h=new ck(c,\"max\",!0),m=n.runWebGLProgram(h,[i],i.dtype),f=new wse(c),g=n.runWebGLProgram(f,[r,m],i.dtype);return n.disposeIntermediateTensorInfo(m),g}var Ise={kernelName:Bc,backendName:\"webgl\",kernelFunc:kse};function Sse(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s,output:i}=t,o=s;lp([s,i],\"maxPoolGrad\");let{filterSize:l,strides:u,pad:p,dimRoundingMode:d}=a,c=T.computePool2DInfo(o.shape,l,u,1,p,d),h=!0,m=new Ec(c,\"max\",h),f=n.runWebGLProgram(m,[o],o.dtype),g=new vse(c),b=n.runWebGLProgram(g,[r,f],o.dtype);return n.disposeIntermediateTensorInfo(f),b}var Nse={kernelName:Wc,backendName:\"webgl\",kernelFunc:Sse};function Tse(e,t,n,a){let r=new Ec(n,\"max\",!1),s=a.runWebGLProgram(r,[e],\"float32\");r=new Ec(n,\"max\",!0,!0,t);let i=a.runWebGLProgram(r,[e],\"float32\");return[s,i]}var Cse={kernelName:Vc,backendName:\"webgl\",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:a}=e,{filterSize:r,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;w.assert(a.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`);let u=[1,1];w.assert(T.eitherStridesOrDilationsAreOne(s,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);let p=T.computePool2DInfo(a.shape,r,s,u,i),[d,c]=Tse(a,o,p,l);return[d,c]}};function Ese(e,t,n,a){let r=w.sizeFromShape(t),s=w.sizeFromShape(e.shape)/r,i=ce({inputs:{x:e},attrs:{shape:[s,r]},backend:a}),o=el(i,\"float32\",\"mean\",a),l=ce({inputs:{x:o},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(i),a.disposeIntermediateTensorInfo(o),l}var _se={kernelName:co,backendName:\"webgl\",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:a}=e,{keepDims:r,axis:s}=t,i=n,o=a.shape.length,l=w.parseAxisParam(s,a.shape),u=l,p=T.getAxesPermutation(u,o),d=p!=null,c=i.shouldExecuteOnCPU([a]),h=[],m=a;if(d){if(c){let x=i.texData.get(m.dataId).values,v=new Array(o);for(let C=0;C<v.length;C++)v[C]=a.shape[p[C]];let I=ok(x,a.shape,a.dtype,p,v);m=i.makeTensorInfo(v,a.dtype);let N=i.texData.get(m.dataId);N.values=I}else m=Bf(a,p,i);h.push(m),u=T.getInnerMostAxes(u.length,o)}T.assertAxesAreInnerMostDims(\"sum\",u,o);let[f,g]=T.computeOutAndReduceShapes(m.shape,u),b=f;r&&(b=T.expandShapeToKeepDim(f,l));let y=Ese(m,g,b,i);for(let x of h)i.disposeIntermediateTensorInfo(x);return y}};function Ase(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,l=w.parseAxisParam(s,r.shape),u=l,p=T.getAxesPermutation(u,o),d=r;p!=null&&(d=Sn({inputs:{x:r},backend:n,attrs:{perm:p}}),u=T.getInnerMostAxes(u.length,r.shape.length)),T.assertAxesAreInnerMostDims(\"min\",u,o);let[c,h]=T.computeOutAndReduceShapes(d.shape,u),m=w.sizeFromShape(h),f=ce({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),g=el(f,f.dtype,\"min\",n),b;if(i){let y=T.expandShapeToKeepDim(c,l);b=ce({inputs:{x:g},backend:n,attrs:{shape:y}})}else b=ce({inputs:{x:g},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),p!=null&&n.disposeIntermediateTensorInfo(d),b}var Fse={kernelName:ho,backendName:\"webgl\",kernelFunc:Ase},$se=uk+`\n  return min(a, b);\n`,Dse=`\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  `+Qo+`\n  return result;\n`,Rse=hn({opSnippet:$se,packedOpSnippet:Dse,cpuKernelImpl:bQ}),Mse={kernelName:mo,backendName:\"webgl\",kernelFunc:Rse},Ose=class{constructor(e,t,n){this.variableNames=[\"x\"],this.outputShape=t.map((u,p)=>u[0]+e[p]+u[1]);let a=e.length,r=ht(a),s=t.map(u=>u[0]).join(\",\"),i=t.map((u,p)=>u[0]+e[p]).join(\",\"),o=[\"coords[0]\",\"coords[1]\",\"coords[2]\",\"coords[3]\"].slice(0,a),l=n===\"reflect\"?0:1;if(a===1){this.userCode=`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `;return}this.userCode=`\n      ${r} start = ${r}(${s});\n      ${r} end = ${r}(${i});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        for (int i = 0; i < ${a}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${r} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `}},Pse=class{constructor(e,t,n){this.variableNames=[\"x\"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((h,m)=>h[0]+e[m]+h[1]);let a=e.length,r=ht(a),s=t.map(h=>h[0]).join(\",\"),i=t.map((h,m)=>h[0]+e[m]).join(\",\"),o=In(\"rc\",a),l=In(\"source\",a),u=`${o[a-1]} < ${this.outputShape[a-1]}`,p=a===1?\"source\":`vec2(${l.slice(-2).join()})`,d=n===\"reflect\"?0:1,c=\"\";if(a===1){let h=`\n        ${r} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;c=`\n        ${r} rc = outputLoc;\n        ${h}\n        result[0] = getChannel(getX(${l.join()}), ${p});\n        ${o[a-1]} += 1;\n        if(${u}) {\n          ${h}\n          result[1] = getChannel(getX(${l.join()}), ${p});\n        }\n      `}else{let h=`\n        ${r} source = rc;\n        ${r} lt = ${r}(lessThan(source, start));\n        ${r} gte = ${r}(greaterThanEqual(source, end));\n        ${r} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;c=`\n        ${r} rc = outputLoc;\n        ${h}\n        result[0] = getChannel(getX(${l.join()}), ${p});\n        ${o[a-1]} += 1;\n        if(${u}) {\n          ${h}\n          result[1] = getChannel(getX(${l.join()}), ${p});\n        }\n        rc = outputLoc;\n        ${o[a-2]} += 1;\n        if(${o[a-2]} < ${this.outputShape[a-2]}) {\n          ${h}\n          result[2] = getChannel(getX(${l.join()}), ${p});\n          ${o[a-1]} += 1;\n          if(${u}) {\n            ${h}\n            result[3] = getChannel(getX(${l.join()}), ${p});\n          }\n        }\n      `}this.userCode=`\n      const ${r} start = ${r}(${s});\n      const ${r} end = ${r}(${i});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${c}\n        setOutput(result);\n      }\n    `}},Lse=({inputs:e,backend:t,attrs:n})=>{let{x:a}=e,{paddings:r,mode:s}=n,i=G().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\")?new Pse(a.shape,r,s):new Ose(a.shape,r,s);return t.runWebGLProgram(i,[a],a.dtype)},zse={kernelName:fo,backendName:\"webgl\",kernelFunc:Lse},Wse=`if (b == 0.0) return NAN;\n  return mod(a, b);`,Bse=`\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  `+Qo+`\n  return result;\n`,Vse=hn({opSnippet:Wse,packedOpSnippet:Bse}),Use={kernelName:go,backendName:\"webgl\",kernelFunc:Vse},Gse=class{constructor(e,t,n){this.variableNames=[\"probs\"],this.customUniforms=[{name:\"seed\",type:\"float\"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}},Hse=`\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;`,jse=`\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n`,tF=hn({opSnippet:Hse,packedOpSnippet:jse,checkOutOfBounds:!0}),qse={kernelName:Hi,backendName:\"webgl\",kernelFunc:tF},kS=\"return a - b;\",nF=hn({opSnippet:kS,packedOpSnippet:kS,supportsComplex:!0,cpuKernelImpl:LQ}),Kse={kernelName:Bo,backendName:\"webgl\",kernelFunc:nF};function aF(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,i=w.parseAxisParam([s],r.shape),o=eF({inputs:{x:r},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=T.expandShapeToKeepDim(o.shape,i),u=ce({inputs:{x:o},backend:n,attrs:{shape:l}}),p=nF({inputs:{a:r,b:u},backend:n}),d=ZA({inputs:{x:p},backend:n}),c=Vf({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),h=ce({inputs:{x:c},backend:n,attrs:{shape:l}}),m=tF({inputs:{a:d,b:h},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),m}var Xse={kernelName:zo,backendName:\"webgl\",kernelFunc:aF};function Yse(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=a,l=o?r:aF({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),u=l.shape[0],p=l.shape[1],d=new Gse(u,p,s),c=[[i]],h=n.runWebGLProgram(d,[l],\"int32\",c);return o||n.disposeIntermediateTensorInfo(l),h}var Zse={kernelName:Tu,backendName:\"webgl\",kernelFunc:Yse},Jse=Da+`\n  return -x;\n`,Qse=`\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;function eie(e){let{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){let s=n.texData.get(a.dataId),[i,o]=xQ(s.values,a.shape,a.dtype);return n.makeTensorInfo(o,a.dtype,i)}let r;return G().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")?r=new ts(a.shape,Qse):r=new rr(a.shape,Jse),n.runWebGLProgram(r,[a],a.dtype)}var tie={kernelName:Cu,backendName:\"webgl\",kernelFunc:eie},nie=mr.nonMaxSuppressionV3Impl;function aie(e){T.warn(\"tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead\");let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=a,u=n.readSync(r.dataId),p=n.readSync(s.dataId),{selectedIndices:d}=nie(u,p,i,o,l);return n.makeTensorInfo([d.length],\"int32\",new Int32Array(d))}var rie={kernelName:_u,backendName:\"webgl\",kernelFunc:aie},sie=mr.nonMaxSuppressionV4Impl;function iie(e){T.warn(\"tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead\");let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=a,p=n.readSync(r.dataId),d=n.readSync(s.dataId),{selectedIndices:c,validOutputs:h}=sie(p,d,i,o,l,u);return[n.makeTensorInfo([c.length],\"int32\",new Int32Array(c)),n.makeTensorInfo([],\"int32\",new Int32Array([h]))]}var oie={kernelName:Au,backendName:\"webgl\",kernelFunc:iie},lie=mr.nonMaxSuppressionV5Impl;function uie(e){T.warn(\"tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead\");let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=a,p=n.readSync(r.dataId),d=n.readSync(s.dataId),c=i,h=o,m=l,f=u,{selectedIndices:g,selectedScores:b}=lie(p,d,c,h,m,f);return[n.makeTensorInfo([g.length],\"int32\",new Int32Array(g)),n.makeTensorInfo([b.length],\"float32\",new Float32Array(b))]}var pie={kernelName:Fu,backendName:\"webgl\",kernelFunc:uie},cie=class{constructor(e,t,n,a){this.variableNames=[\"indices\"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${a}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}},die=e=>{let{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:l}=a,u=w.sizeFromShape(r.shape),p=new cie(u,i,o,l),d=ce({inputs:{x:r},backend:n,attrs:{shape:[u]}}),c=n.runWebGLProgram(p,[d],s);n.disposeIntermediateTensorInfo(d);let h=[...r.shape,i],m=ce({inputs:{x:c},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(c),m},hie={kernelName:yo,backendName:\"webgl\",kernelFunc:die};function fm(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype===\"complex64\"){let r=Fd({inputs:{input:a},backend:n}),s=fm({inputs:{x:r},backend:n}),i=Uf({inputs:{input:a},backend:n}),o=fm({inputs:{x:i},backend:n}),l=$s({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return $d({attrs:{shape:a.shape,dtype:a.dtype,value:a.dtype===\"string\"?\"\":0},backend:n})}var mie={kernelName:Yu,backendName:\"webgl\",kernelFunc:fm};function rF(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype===\"string\")throw new Error(\"onesLike is not supported under string dtype\");if(a.dtype===\"complex64\"){let r=Fd({inputs:{input:a},backend:n}),s=rF({inputs:{x:r},backend:n}),i=Uf({inputs:{input:a},backend:n}),o=fm({inputs:{x:i},backend:n}),l=$s({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return $d({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:n})}var fie={kernelName:$u,backendName:\"webgl\",kernelFunc:rF};function gie(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(t.length===1)return gv({inputs:{input:t[0]},backend:n,attrs:{dim:r}});let s=t[0].shape,i=t[0].dtype;t.forEach(p=>{w.assertShapesMatch(s,p.shape,\"All tensors passed to stack must have matching shapes\"),w.assert(i===p.dtype,()=>\"All tensors passed to stack must have matching dtypes\")});let o=[],l=t.map(p=>{let d=gv({inputs:{input:p},backend:n,attrs:{dim:r}});return o.push(d),d}),u=UA({inputs:l,backend:n,attrs:{axis:r}});return o.forEach(p=>n.disposeIntermediateTensorInfo(p)),u}var bie={kernelName:Du,backendName:\"webgl\",kernelFunc:gie},yie=class{constructor(e,t,n){this.variableNames=[\"x\"],this.customUniforms=[{name:\"value\",type:\"float\"}],this.outputShape=t.map((l,u)=>l[0]+e[u]+l[1]);let a=e.length,r=ht(a),s=t.map(l=>l[0]).join(\",\"),i=t.map((l,u)=>l[0]+e[u]).join(\",\"),o=[\"coords[0]\",\"coords[1]\",\"coords[2]\",\"coords[3]\"].slice(0,a);if(a===1){this.userCode=`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `;return}this.userCode=`\n      ${r} start = ${r}(${s});\n      ${r} end = ${r}(${i});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${r} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `}},xie=class{constructor(e,t,n){this.variableNames=[\"x\"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:\"value\",type:\"float\"}],this.outputShape=t.map((m,f)=>m[0]+e[f]+m[1]);let a=e.length,r=ht(a),s=t.map(m=>m[0]).join(\",\"),i=t.map((m,f)=>m[0]+e[f]).join(\",\"),o=In(\"rc\",a),l=In(\"source\",a),u=`${o[a-1]} < ${this.outputShape[a-1]}`,p=a===1?\"source\":`vec2(${l.slice(-2).join()})`,d=[`${r} rc = outputLoc;`,`${o[a-1]} += 1;\n       if(${u}) {\n      `,a===1?\"\":`}\n       rc = outputLoc;\n       ${o[a-2]} += 1;\n       if(${o[a-2]} < ${this.outputShape[a-2]}) {`,a===1?\"\":`  ${o[a-1]} += 1;\n         if(${u}) {`],c=a===1?\"rc < start || rc >= end\":\"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))\",h=\"\";for(let m=0,f=a===1?2:4;m<f;m++)h+=`\n        ${d[m]}\n        if (${c}) {\n          result[${m}] = float(value);\n        } else {\n          ${r} source = rc - start;\n          result[${m}] = getChannel(getX(${l.join()}), ${p});\n        }\n      `;h+=a===1?\"} \":\"}}\",this.userCode=`\n      const ${r} start = ${r}(${s});\n      const ${r} end = ${r}(${i});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}},sF=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:i}=a;if(w.sizeFromShape(r.shape)===0){let u=s.map((p,d)=>p[0]+r.shape[d]+p[1]);return $d({backend:n,attrs:{shape:u,value:i,dtype:r.dtype}})}let o=G().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\")?new xie(r.shape,s,i):new yie(r.shape,s,i),l=[[i]];return n.runWebGLProgram(o,[r],r.dtype,l)},vie={kernelName:xo,backendName:\"webgl\",kernelFunc:sF},wie=`\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n`,kie=`\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  `+Qo+`\n  return result;\n`,Iie=hn({opSnippet:wie,packedOpSnippet:kie}),Sie={kernelName:vo,backendName:\"webgl\",kernelFunc:Iie};function Nie(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,l=[],u=w.parseAxisParam(s,r.shape),p=u,d=T.getAxesPermutation(p,o),c=r;d!=null&&(c=Sn({inputs:{x:r},backend:n,attrs:{perm:d}}),p=T.getInnerMostAxes(p.length,o),l.push(c)),T.assertAxesAreInnerMostDims(\"prod\",p,o);let h;if(n.shouldExecuteOnCPU([c])){let m=n.texData.get(c.dataId).values,{outVals:f,outShape:g,outDtype:b}=wQ(c.shape,c.dtype,m,p);h=n.makeTensorInfo(g,b,f)}else{let[m,f]=T.computeOutAndReduceShapes(c.shape,p),g=w.sizeFromShape(f),b=ce({inputs:{x:c},backend:n,attrs:{shape:[-1,g]}}),y=Mm(r.dtype),x=el(b,y,\"prod\",n);h=ce({inputs:{x},backend:n,attrs:{shape:m}}),l.push(b),l.push(x)}if(i){l.push(h);let m=T.expandShapeToKeepDim(h.shape,u);h=ce({inputs:{x:h},backend:n,attrs:{shape:m}})}return l.forEach(m=>n.disposeIntermediateTensorInfo(m)),h}var Tie={kernelName:ko,backendName:\"webgl\",kernelFunc:Nie};function Cie(e){let{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=a,l=r.map(b=>n.readSync(b.dataId)),u=r.map(b=>b.shape),p=n.readSync(s.dataId),d=n.readSync(i.dataId),[c,h,m]=kQ(l,u,p,s.shape,s.dtype,d,i.shape,o),f=c.map(b=>n.makeTensorInfo([b.length],\"int32\",b)),g=n.makeTensorInfo(m,s.dtype,h);return f.concat([g])}var Eie={kernelName:Am,backendName:\"webgl\",kernelFunc:Cie};function _ie(e){let{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:s}=t,i=n.readSync(a.dataId),o=n.readSync(r.dataId),l=n.readSync(s.dataId),[u,p]=IQ(i,a.shape,a.dtype,o,r.shape,l,s.shape),d=n.makeTensorInfo([u.length],\"int32\",u),c=n.makeTensorInfo([p.length],a.dtype,p);return[d,c]}var Aie={kernelName:Fm,backendName:\"webgl\",kernelFunc:_ie};function Fie(e){let{inputs:t,backend:n,attrs:a}=e,{shape:r,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=a,u=n.readSync(r.dataId),p=n.readSync(s.dataId),d=n.readSync(i.dataId),c=o.map(g=>n.readSync(g.dataId)),h=o.map(g=>g.shape),[m,f]=SQ(u,r.shape,p,s.shape,s.dtype,d,i.shape,c,h,l);return n.makeTensorInfo(m,s.dtype,f)}var $ie={kernelName:$m,backendName:\"webgl\",kernelFunc:Fie},iF=e=>{let{backend:t,attrs:n}=e,{start:a,stop:r,step:s,dtype:i}=n,o=NQ(a,r,s,i);return t.makeTensorInfo([o.length],i,o)},Die={kernelName:Uc,backendName:\"webgl\",kernelFunc:iF},Rie=\"return 1.0 / x;\",Mie=Ze({opSnippet:Rie}),Oie={kernelName:Io,backendName:\"webgl\",kernelFunc:Mie},Pie=Da+`\n  return (x < 0.0) ? 0.0 : x;\n`,Lie=`\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`,zie=Ze({opSnippet:Pie,packedOpSnippet:Lie}),Wie={kernelName:So,backendName:\"webgl\",kernelFunc:zie},Bie=Da+`\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n`,Vie=`\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`,Uie=Ze({opSnippet:Bie,packedOpSnippet:Vie}),Gie={kernelName:Co,backendName:\"webgl\",kernelFunc:Uie},Hie=class{constructor(e,t,n,a,r){this.variableNames=[\"A\"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u=[a&&t>1?i-1:i,a&&n>1?o-1:o],p=[a&&t>1?t-1:t,a&&n>1?n-1:n],d;r?d=\"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)\":d=\"vec2(yRC) * effectiveInputOverOutputRatioRC\",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/p[0]},\n          ${u[1]/p[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}},jie=class{constructor(e,t,n,a,r){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u=[a&&t>1?i-1:i,a&&n>1?o-1:o],p=[a&&t>1?t-1:t,a&&n>1?n-1:n],d;r?d=\"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)\":d=\"vec3(yRC) * effectiveInputOverOutputRatioRC\",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/p[0]},\n          ${u[1]/p[1]},\n          ${u[1]/p[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}};function qie(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a,[l,u]=o,p=G().getBool(\"WEBGL_PACK_IMAGE_OPERATIONS\")?new jie(r.shape,l,u,s,i):new Hie(r.shape,l,u,s,i);return n.runWebGLProgram(p,[r],\"float32\")}var Kie={kernelName:To,backendName:\"webgl\",kernelFunc:qie},Xie=class{constructor(e,t,n){this.variableNames=[\"dy\"],this.outputShape=[],this.outputShape=t;let[,a,r]=t,[,s,i]=e,o=[n&&s>1?a-1:a,n&&i>1?r-1:r],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],p=o[1]/l[1],d=1/u,c=1/p,h=Math.ceil(d)*2+2,m=Math.ceil(c)*2+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${p});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${c});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${a-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}};function Yie(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=new Xie(s.shape,r.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var Zie={kernelName:Ou,backendName:\"webgl\",kernelFunc:Yie},Jie=class{constructor(e,t,n,a,r){this.variableNames=[\"A\"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u=[a&&t>1?i-1:i,a&&n>1?o-1:o],p=[a&&t>1?t-1:t,a&&n>1?n-1:n],d=a?\"0.5\":\"0.0\",c;r?c=\"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))\":c=\"vec2(yRC) * effectiveInputOverOutputRatioRC\",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/p[0]},\n          ${u[1]/p[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${c};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}},Qie=class{constructor(e,t,n,a,r){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u=[a&&t>1?i-1:i,a&&n>1?o-1:o],p=[a&&t>1?t-1:t,a&&n>1?n-1:n],d=a?\"0.5\":\"0.0\",c;r?c=\"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))\":c=\"vec3(yRC) * effectiveInputOverOutputRatioRC\",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/p[0]},\n          ${u[1]/p[1]},\n          ${u[1]/p[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${c};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}};function eoe(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a,[l,u]=o,p=G().getBool(\"WEBGL_PACK_IMAGE_OPERATIONS\")?new Qie(r.shape,l,u,s,i):new Jie(r.shape,l,u,s,i);return n.runWebGLProgram(p,[r],r.dtype)}var toe={kernelName:No,backendName:\"webgl\",kernelFunc:eoe},noe=class{constructor(e,t,n){this.variableNames=[\"dy\"],this.outputShape=[],this.outputShape=t;let[,a,r]=t,[,s,i]=e,o=[n&&s>1?a-1:a,n&&i>1?r-1:r],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],p=o[1]/l[1],d=1/u,c=1/p,h=Math.ceil(d)*2+2,m=Math.ceil(c)*2+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${p});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${c});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}};function aoe(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=new noe(s.shape,r.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var roe={kernelName:Mu,backendName:\"webgl\",kernelFunc:aoe},soe=class{constructor(e,t){this.variableNames=[\"x\"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `;return}let a=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,r=e.map((i,o)=>a(o)).join(\",\"),s=ht(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}},ioe=class{constructor(e,t){this.variableNames=[\"x\"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let a=In(\"rc\",n),r=`${a[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${a[n-2]} + 1 < ${this.outputShape[n-2]}`,i=ht(n);n===1?this.userCode=`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${r}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:this.userCode=`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${o(a.slice())};\n          if(${r}){\n            result.g = ${l(a.slice())};\n          }\n          if(${s}) {\n            result.b = ${u(a.slice())};\n            if(${r}) {\n              result.a = ${p(a.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `;function o(h){return d(h)}function l(h){return h[n-1]=\"(\"+h[n-1]+\" + 1)\",d(h)}function u(h){return h[n-2]=\"(\"+h[n-2]+\" + 1)\",d(h)}function p(h){return h[n-1]=\"(\"+h[n-1]+\" + 1)\",h[n-2]=\"(\"+h[n-2]+\" + 1)\",d(h)}function d(h){let m=e.map((b,y)=>c(y,h)),f=m.join(\",\"),g=m.slice(-2).join(\",\");return`getChannel(getX(${f}), vec2(${g}))`}function c(h,m){return t.indexOf(h)!==-1&&e[h]!==1?`${e[h]} - ${m[h]} - 1`:`${m[h]}`}}};function ooe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a,i=r.shape.length,o=w.parseAxisParam(s,r.shape);if(i===0)return ta({inputs:{x:r},backend:n});let l=G().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\")?new ioe(r.shape,o):new soe(r.shape,o);return n.runWebGLProgram(l,[r],r.dtype)}var loe={kernelName:Eo,backendName:\"webgl\",kernelFunc:ooe},uoe=class{constructor(e,t){this.variableNames=[\"Image\"],this.outputShape=[],this.customUniforms=[{name:\"params\",type:\"vec4\"}];let n=e[1],a=e[2];this.outputShape=e;let r=\"\";typeof t==\"number\"?r=`float outputValue = ${t.toFixed(2)};`:r=`\n        vec3 fill = vec3(${t.join(\",\")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${r}\n          if(coordX >= 0 && coordX < ${a} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},poe={kernelName:Zu,backendName:\"webgl\",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:a}=e,{radians:r,fillValue:s,center:i}=t,o=n,l=new uoe(a.shape,s),[u,p]=T.getImageCenter(i,a.shape[1],a.shape[2]),d=[[u,p,Math.sin(r),Math.cos(r)]];return o.runWebGLProgram(l,[a],a.dtype,d)}},coe=`\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n`,doe=Ze({opSnippet:coe}),hoe={kernelName:_o,backendName:\"webgl\",kernelFunc:doe},moe=\"return inversesqrt(x);\",foe=Ze({opSnippet:moe,cpuKernelImpl:TQ}),goe={kernelName:Ao,backendName:\"webgl\",kernelFunc:foe},dk=class{constructor(e,t,n,a,r,s,i=!0,o=!1){this.variableNames=[\"updates\",\"indices\",\"defaultValue\"],this.outputShape=s;let l=ht(r.length),u=ht(s.length),p=\"\";n===1?p=\"i\":n===2&&(p=\"i, j\");let d=`getIndices(${p})`,c=\"\";a===1?c=\"i\":a===2&&(c=\"i, coords[1]\");let h=`getUpdates(${c})`,m=\"\";o&&(m=\"coords[0], coords[1]\");let f=`getDefaultValue(${m})`,g=t>1?\"strides[j]\":\"strides\";this.userCode=`\n        ${l} strides = ${l}(${r});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${d});\n              flattenedIndex += index * ${g};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${h};\n              found = true;\n            }\n          }\n          setOutput(mix(${f}, sum, float(found)));\n        }\n      `}},boe=class{constructor(e,t,n,a,r,s,i=!0,o=!1){this.variableNames=[\"updates\",\"indices\",\"defaultValue\"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;let l=ht(r.length),u=ht(s.length),p=\"\";n===1?p=\"i\":n===2&&(p=\"i, j\");let d=`getIndices(${p})`,c=\"\";a===1?c=\"i\":a===2&&(c=\"i, coords[1]\");let h=`getUpdates(${c})`,m=\"\";o&&(m=\"coords[0], coords[1]\");let f=`getDefaultValue(${m})`,g=t>1?\"strides[j]\":\"strides\",b=t>1?\"strides[j + 1]\":\"strides\";this.userCode=`\n        ${l} strides = ${l}(${r});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${d});\n              flattenedIndex += index.xz * ${g};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${b};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${h};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${f}, sum, found));\n        }\n      `}};function yoe(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:i}=a,{sliceRank:o,numUpdates:l,sliceSize:u,strides:p,outputSize:d}=T.calculateShapes(s,r,i),c=[d/u,u];if(d===0)return n.makeTensorInfo(i,r.dtype);let h=ce({inputs:{x:r},backend:n,attrs:{shape:[l,o]}}),m=ce({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),f=n.makeTensorInfo([],\"float32\",new Float32Array([0])),g;G().getBool(\"WEBGL_PACK\")?g=new boe(l,o,h.shape.length,m.shape.length,p,c):g=new dk(l,o,h.shape.length,m.shape.length,p,c);let b=n.runWebGLProgram(g,[m,h,f],m.dtype),y=ce({inputs:{x:b},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(f),y}var xoe={kernelName:Pu,backendName:\"webgl\",kernelFunc:yoe},voe=class{constructor(e,t,n,a){this.variableNames=[\"sortedSequence\",\"values\"],this.customUniforms=[{name:\"numInputs\",type:\"int\"}],this.outputShape=[e,n];let r=\"while (left < right) {\",s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=G().getNumber(\"WEBGL_VERSION\")===2?r:s,o=a===\"left\"?\"<\":\"<=\";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${i}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${o} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}};function woe(e){let{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:i}=a,o=new voe(r.shape[0],r.shape[1],s.shape[1],i),l=[[r.shape[1]]];return n.runWebGLProgram(o,[r,s],\"int32\",l)}var koe={kernelName:zu,backendName:\"webgl\",kernelFunc:woe},Ioe=class{constructor(e,t,n){this.variableNames=[\"c\",\"a\",\"b\"],this.outputShape=t;let a,r;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)r=\"resRC\",a=\"resRC\";else{let i=[\"resRC.x\",\"resRC.y\",\"resRC.z\",\"resRC.w\"],o=[],l=[];for(let u=0;u<t.length;u++)l.push(`${i[u]}`),u<e&&o.push(`${i[u]}`);a=o.join(),r=l.join()}let s=ht(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${a});\n        if (cVal >= 1.0) {\n          setOutput(getA(${r}));\n        } else {\n          setOutput(getB(${r}));\n        }\n      }\n    `}};function Soe(e){let{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t,i=new Ioe(a.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(i,[a,r,s],fa(r.dtype,s.dtype))}var Noe={kernelName:Wu,backendName:\"webgl\",kernelFunc:Soe},Toe=`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${T.SELU_SCALEALPHA};\n  float scale = ${T.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`,Coe=Ze({opSnippet:Toe}),Eoe={kernelName:Fo,backendName:\"webgl\",kernelFunc:Coe},_oe=mp+`\n  return 1.0 / (1.0 + exp(-1.0 * x));\n`,Aoe=`\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`,Foe=Ze({opSnippet:_oe,packedOpSnippet:Aoe,cpuKernelImpl:EQ}),$oe={kernelName:Mo,backendName:\"webgl\",kernelFunc:Foe},Doe=`\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n`,Roe=Ze({opSnippet:Doe}),Moe={kernelName:Ro,backendName:\"webgl\",kernelFunc:Roe},Ooe=mp+`\n  return sin(x);\n`,Poe=`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${Qo}\n  return result;\n`,Loe=Ze({opSnippet:Ooe,packedOpSnippet:Poe}),zoe={kernelName:$o,backendName:\"webgl\",kernelFunc:Loe},Woe=`\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n`,Boe=Ze({opSnippet:Woe}),Voe={kernelName:Do,backendName:\"webgl\",kernelFunc:Boe},Uoe=`\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n`,Goe=Ze({opSnippet:Uoe}),Hoe={kernelName:Oo,backendName:\"webgl\",kernelFunc:Goe},joe=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:i}=a;w.assert(r.shape.length<=4,()=>\"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet\");let o=s.reduce((b,y)=>b*y),l=[[0,0]];l.push(...i);for(let b=1+s.length;b<r.shape.length;++b)l.push([0,0]);let u=[],p=sF({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),d=T.getReshaped(p.shape,s,o,!1),c=T.getPermuted(d.length,s.length,!1),h=T.getReshapedPermuted(p.shape,s,o,!1),m=ce({inputs:{x:p},backend:n,attrs:{shape:d}}),f=Sn({inputs:{x:m},backend:n,attrs:{perm:c}}),g=ce({inputs:{x:f},backend:n,attrs:{shape:h}});return u.push(p),u.push(m),u.push(f),u.forEach(b=>n.disposeIntermediateTensorInfo(b)),g},qoe={kernelName:Vu,backendName:\"webgl\",kernelFunc:joe};function Koe(e){let{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(a.shape.length!==2)throw new Error(`Indices must be a matrix, saw:\n         ${a.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:\n         ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);let o=n.readSync(a.dataId),l=n.readSync(r.dataId),u=n.readSync(s.dataId),p=n.readSync(i.dataId)[0],[d,c,h,m,f]=AQ(o,a.shape,a.dtype,l,r.dtype,u,p);return[n.makeTensorInfo(c,a.dtype,d),n.makeTensorInfo([c[0]],r.dtype,h),n.makeTensorInfo([m.length],\"bool\",new Uint8Array(m.map(g=>Number(g)))),n.makeTensorInfo([f.length],a.dtype,new Int32Array(f))]}var Xoe={kernelName:Gc,backendName:\"webgl\",kernelFunc:Koe};function Yoe(e){let{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(a.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${a.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.readSync(r.dataId)),o=n.readSync(a.dataId),l=Array.from(n.readSync(s.dataId)),[u,p,d]=FQ(o,a.shape,a.dtype,i,l);return[n.makeTensorInfo(p,a.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}var Zoe={kernelName:Gu,backendName:\"webgl\",kernelFunc:Yoe};function Joe(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error(\"Data should be at least 1 dimensional but received scalar\");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape\n              ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);let i=n.readSync(a.dataId),o=n.readSync(r.dataId),l=n.readSync(s.dataId),[u,p]=EA(i,a.shape,a.dtype,o,l,!0);return n.makeTensorInfo(p,a.dtype,u)}var Qoe={kernelName:Hc,backendName:\"webgl\",kernelFunc:Joe};function ele(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error(\"Data should be at least 1 dimensional but received scalar\");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape\n             ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);let i=n.readSync(a.dataId),o=n.readSync(r.dataId),l=n.readSync(s.dataId),[u,p]=EA(i,a.shape,a.dtype,o,l);return n.makeTensorInfo(p,a.dtype,u)}var tle={kernelName:jc,backendName:\"webgl\",kernelFunc:ele};function nle(e){let{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=t,{outputShape:o}=a,{sliceRank:l,numUpdates:u,sliceSize:p,strides:d,outputSize:c}=T.calculateShapes(s,r,o),h=!1;if(s.dtype===\"string\"){let b=n.bufferSync(r),y=n.bufferSync(s),x=w.decodeString(n.readSync(i.dataId)[0]),v=CQ(b,y,o,c,p,u,l,d,x,h);return n.makeTensorInfo(o,v.dtype,v.values)}let m=new dk(u,l,r.shape.length,s.shape.length,d,[c,1],h),f=n.runWebGLProgram(m,[s,r,i],s.dtype),g=ce({inputs:{x:f},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(f),g}var ale={kernelName:Hu,backendName:\"webgl\",kernelFunc:nle};function rle(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=a,o=w.parseAxisParam(i,r.shape)[0],l=T.prepareSplitSize(r,s,o),u=r.shape.length,p=new Array(u).fill(0),d=r.shape.slice();return l.map(c=>{let h=[...d];h[o]=c;let m=fp({inputs:{x:r},backend:n,attrs:{begin:p,size:h}});return p[o]+=c,m})}var sle={kernelName:Uu,backendName:\"webgl\",kernelFunc:rle},IS=\"return sqrt(x);\",ile=Ze({opSnippet:IS,packedOpSnippet:IS,cpuKernelImpl:$Q}),ole={kernelName:Po,backendName:\"webgl\",kernelFunc:ile},lle=\"return x * x;\",ule=Ze({opSnippet:lle}),ple={kernelName:qc,backendName:\"webgl\",kernelFunc:ule},SS=\"return (a - b) * (a - b);\",cle=hn({opSnippet:SS,packedOpSnippet:SS}),dle={kernelName:Wo,backendName:\"webgl\",kernelFunc:cle};function hle(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;if(r.dtype!==\"string\")throw new Error(\"Input must be of datatype string\");let s=n.readSync(r.dataId),i=T.fromUint8ToStringArray(s),o=DQ(i,\"string\",a);return n.makeTensorInfo(r.shape,\"string\",o)}var mle={kernelName:Kc,backendName:\"webgl\",kernelFunc:hle};function fle({inputs:e,attrs:t,backend:n}){let{x:a}=e,r=Da+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,s=new rr(a.shape,r);return n.runWebGLProgram(s,[a],a.dtype)}var gle={kernelName:Is,backendName:\"webgl\",kernelFunc:fle},ble=class{constructor(e,t,n){this.variableNames=[\"x\"],this.outputShape=n;let a=n.length,r=ht(n.length),s=ht(n.length),i=\"\";if(a===1)i=\"coords * strides + begin\";else{let o=0;i=n.map((l,u)=>(o++,n.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${o-1}] * strides[${u}] + begin[${u}]`)).join(\",\")}this.userCode=`\n      ${r} begin = ${r}(${e});\n      ${r} strides = ${r}(${t});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}};function yle(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:p,newAxisMask:d,shrinkAxisMask:c}=a,{finalShapeSparse:h,finalShape:m,isIdentity:f,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:v}=Kt.sliceInfo(r.shape,s,i,o,l,u,p,d,c),I;if(f)I=ce({inputs:{x:r},backend:n,attrs:{shape:m}});else if(g||b){w.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);let C=Kt.computeOutShape(y,x,v),_=fp({inputs:{x:r},backend:n,attrs:{begin:y,size:C}});I=ce({inputs:{x:_},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(_)}else if(n.shouldExecuteOnCPU([r])){let C=n.readSync(r.dataId),_=Oe(r.shape,r.dtype,C),F=RQ(h,_,v,y);I=n.makeTensorInfo(m,r.dtype,F.values)}else{let C=new ble(y,v,h);I=n.runWebGLProgram(C,[r],r.dtype)}let N=ce({inputs:{x:I},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(I),N}var xle={kernelName:ju,backendName:\"webgl\",kernelFunc:yle};function vle(e){let{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=a,{data:p,dataSplits:d}=t,c=n.readSync(p.dataId),h=n.readSync(d.dataId),[m,f]=MQ(c,h,r,s,i,o,l,u);return[n.makeTensorInfo([m.length],\"string\",m),n.makeTensorInfo(d.shape,\"int32\",f)]}var wle={kernelName:Xc,backendName:\"webgl\",kernelFunc:vle};function kle(e){let{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:s,delimiter:i}=t;if(s.dtype!==\"string\")throw new Error(\"Input must be of datatype string\");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.readSync(s.dataId),l=n.readSync(i.dataId)[0],[u,p,d]=OQ(o,l,r),c=p.length;return[n.makeTensorInfo([c,2],\"int32\",u),n.makeTensorInfo([c],\"string\",p),n.makeTensorInfo([2],\"int32\",new Int32Array(d))]}var Ile={kernelName:Yc,backendName:\"webgl\",kernelFunc:kle};function Sle(e){let{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:s}=t;if(s.dtype!==\"string\")throw new Error(\"Input must be of datatype string\");if(r<=0)throw new Error(\"Number of buckets must be at least 1\");let i=n.readSync(s.dataId),o=PQ(i,r);return n.makeTensorInfo(s.shape,\"int32\",o)}var Nle={kernelName:Zc,backendName:\"webgl\",kernelFunc:Sle},Tle=\"return tan(x);\",Cle=Ze({opSnippet:Tle}),Ele={kernelName:Vo,backendName:\"webgl\",kernelFunc:Cle},_le=`\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n`,Ale=Ze({opSnippet:_le}),Fle={kernelName:Uo,backendName:\"webgl\",kernelFunc:Ale};function $le(e){let{inputs:t,backend:n,attrs:a}=e,{tensor:r,indices:s,updates:i}=t,{}=a,{sliceRank:o,numUpdates:l,sliceSize:u,strides:p,outputSize:d}=T.calculateShapes(i,s,r.shape),c=[d/u,u];if(d===0)return n.makeTensorInfo(r.shape,s.dtype);let h=ce({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),m=ce({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),f=ce({inputs:{x:r},backend:n,attrs:{shape:c}}),g=new dk(l,o,h.shape.length,m.shape.length,p,c,!1,!0),b=n.runWebGLProgram(g,[m,h,f],f.dtype),y=ce({inputs:{x:b},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),y}var Dle={kernelName:Lu,backendName:\"webgl\",kernelFunc:$le},Rle=class{constructor(e,t){this.variableNames=[\"A\"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;let a=ht(this.rank),r=Mle(e);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}};function Mle(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;let n=[\"resRC.x\",\"resRC.y\",\"resRC.z\",\"resRC.w\",\"resRC.u\"],a=[];for(let r=0;r<e.length;r++)a.push(`imod(${n[r]}, ${e[r]})`);return a.join()}function oF(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;if(r.dtype===\"string\"||r.shape.length>5){let o=n.readSync(r.dataId),l=r.dtype===\"string\"?o.map(d=>w.decodeString(d)):o,u=Oe(r.shape,r.dtype,l),p=zQ(u,s);return n.makeTensorInfo(p.shape,p.dtype,p.values)}let i=new Rle(r.shape,s);return n.runWebGLProgram(i,[r],r.dtype)}var Ole={kernelName:ks,backendName:\"webgl\",kernelFunc:oF},Ple=class{constructor(e){this.variableNames=[\"x\",\"indices\"],this.customUniforms=[{name:\"n\",type:\"int\"},{name:\"firstPass\",type:\"int\"},{name:\"negativeInf\",type:\"float\"},{name:\"dir\",type:\"int\"},{name:\"inc\",type:\"int\"}],this.outputShape=e,this.userCode=`\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     `}},Lle=class{constructor(e){this.variableNames=[\"x\",\"indices\"],this.customUniforms=[{name:\"n\",type:\"int\"},{name:\"firstPass\",type:\"int\"},{name:\"k\",type:\"int\"}],this.outputShape=e,this.userCode=`\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     `}};function qs(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function NS(e){let t=1;for(;t<e;)t*=2;return t}function zle(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:i}=a,o=G().getNumber(\"TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD\"),l=G().getNumber(\"TOPK_K_CPU_HANDOFF_THRESHOLD\"),u=r.shape,p=u[u.length-1];if(n.shouldExecuteOnCPU([r])||p<o||s>l){let F=n.readSync(r.dataId),[D,$]=WQ(F,u,r.dtype,s,i);return[n.makeTensorInfo(D.shape,D.dtype,D.values),n.makeTensorInfo($.shape,$.dtype,$.values)]}if(s===0)return u[u.length-1]=0,[n.makeTensorInfo(u,r.dtype,[]),n.makeTensorInfo(u,\"int32\",[])];if(p===1)return[r,$d({attrs:{shape:u,dtype:\"int32\",value:0},backend:n})];let d=n.texData.get(r.dataId),c=d!==null&&d.isPacked,h=c?n.unpackTensor(r):r,m=w.sizeFromShape(u)/p,f=ce({inputs:{x:h},attrs:{shape:[m,p]},backend:n});c&&qs(n,h);let g=NS(s),b=NS(p),y=null,x=()=>y===null?[f,f]:[f,y],v=(F,D,$)=>{let S=x(),M=new Ple($),B=[[p],[y===null?1:0],[Number.NEGATIVE_INFINITY],[F],[D]],U=y;y=n.runWebGLProgram(M,S,\"int32\",B),qs(n,U)};for(let F=1;F<g;F*=2){let D=F*2;for(let $=F;$>=1;$/=2)v(D,$,[m,b])}for(let F=b;F>g;F/=2){let D=x(),$=new Lle([m,F/2]),S=[[p],[y===null?1:0],[g]],M=y;y=n.runWebGLProgram($,D,\"int32\",S),qs(n,M);let B=g/2,U=B*2;for(let H=B;H>=1;H/=2)v(U,H,y.shape)}let I=y;y=fp({inputs:{x:y},backend:n,attrs:{begin:0,size:[m,s]}}),qs(n,I);let N=QA({inputs:{x:f,indices:y},backend:n,attrs:{axis:1,batchDims:1}});qs(n,f);let C=u.slice(0,-1);C.push(s),I=y,y=ce({inputs:{x:y},attrs:{shape:C},backend:n}),qs(n,I);let _=N;return N=ce({inputs:{x:N},attrs:{shape:C},backend:n}),qs(n,_),[N,y]}var Wle={kernelName:qu,backendName:\"webgl\",kernelFunc:zle},Ble=class{constructor(e,t,n,a,r,s){this.variableNames=[\"Image\",\"Transforms\"],this.outputShape=s;let i=n===\"nearest\"?1:2,o;switch(a){case\"constant\":o=1;break;case\"reflect\":o=2;break;case\"wrap\":o=3;break;case\"nearest\":o=4;break;default:o=1;break}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${r});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${r});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}};function Vle(e){let{inputs:t,backend:n,attrs:a}=e,{image:r,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=a,[p,d,c,h]=r.shape,[m,f]=u!=null?u:[d,c],g=[p,m,f,h],b=new Ble(d,c,i,o,l,g);return n.runWebGLProgram(b,[r,s],\"float32\")}var Ule={kernelName:Ku,backendName:\"webgl\",kernelFunc:Vle};function Gle(e){let{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;lp(s,\"unique\"),console.warn(\"WARNING: \",\"UI might be locked temporarily as data is being downloaded\");let i=a.readSync(s.dataId),{outputValues:o,outputShape:l,indices:u}=BQ(i,r,s.shape,s.dtype);return[a.makeTensorInfo(l,s.dtype,o),a.makeTensorInfo([u.length],\"int32\",u)]}var Hle={kernelName:Jc,backendName:\"webgl\",kernelFunc:Gle};function jle(e){let{inputs:t,backend:n,attrs:a}=e,{value:r}=t,{axis:s}=a;s<0&&(s+=r.shape.length);let i=r,o=i.shape.length,l=r.shape[s],u=new Array(o-1),p=0;for(let f=0;f<o;f++)f!==s&&(u[p++]=i.shape[f]);let d=[],c=new Array(o).fill(0),h=i.shape.slice();h[s]=1;let m=new Array(l);for(let f=0;f<m.length;f++){c[s]=f;let g=fp({inputs:{x:i},backend:n,attrs:{begin:c,size:h}}),b=ce({inputs:{x:g},backend:n,attrs:{shape:u}});m[f]=b,d.push(g)}return d.forEach(f=>n.disposeIntermediateTensorInfo(f)),m}var qle={kernelName:Xu,backendName:\"webgl\",kernelFunc:jle},Kle=class{constructor(e,t){this.variableNames=[\"x\",\"segmentIds\"];let n=e.windowSize,a=e.batchSize,r=e.inSize,s=e.numSegments,i=s*Math.ceil(r/n);this.outputShape=[a,i];let o=\"0.0\",l=\"sumValue\",u=Math.floor(n/4)*4,p=n%4,d=`\n        sumValue += dot(values, segFilter);\n    `,c=\"\";r%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `);let h=\"\";r%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${o};\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${p===1}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${d}\n        } else if (${p===2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${d}\n        } else if (${p===3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${d}\n        }\n        setOutput(${l});\n      }\n    `}};function Xle(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:s}=t,{numSegments:i}=a,o=r.shape.length,l=[],u=0,p=T.getAxesPermutation([u],o),d=r;p!=null&&(d=Sn({inputs:{x:r},backend:n,attrs:{perm:p}}),l.push(d),u=T.getInnerMostAxes(1,o)[0]);let c=T.segment_util.computeOutShape(d.shape,u,i),h=w.sizeFromShape([d.shape[u]]),m=ce({inputs:{x:d},backend:n,attrs:{shape:[-1,h]}});l.push(m);let f=Mm(r.dtype),g=(v,I,N,C,_)=>{let F=v.shape[0],D=v.shape[1],$=T.segment_util.segOpComputeOptimalWindowSize(D,_),S={windowSize:$,inSize:D,batchSize:F,numSegments:_},M=new Kle(S,I),B=n.compileAndRun(M,[v,N],C);if(l.push(B),B.shape[1]===_)return B;let U=iF({backend:n,attrs:{start:0,stop:_,step:1,dtype:\"float32\"}}),H=oF({inputs:{x:U},backend:n,attrs:{reps:[D/$]}});return l.push(U),l.push(H),g(B,I,H,C,_)},b=g(m,\"unsortedSegmentSum\",s,f,i),y=ce({inputs:{x:b},backend:n,attrs:{shape:c}}),x=y;if(p!=null){l.push(y);let v=T.getUndoAxesPermutation(p);x=Sn({inputs:{x},backend:n,attrs:{perm:v}})}return l.forEach(v=>n.disposeIntermediateTensorInfo(v)),x}var Yle={kernelName:Qc,backendName:\"webgl\",kernelFunc:Xle},Zle=[Ree,Oee,zee,Vee,Gee,qee,Xee,Zee,tte,ate,ite,ute,dte,gte,xte,wte,Ite,Cte,_te,Fte,Mte,Vte,Gte,Kte,Yte,nne,rne,lne,bee,cne,gne,vne,Tne,_ne,Fne,Dne,Mne,zne,Vne,Hne,qne,Xne,Zne,eae,nae,iae,lae,cae,mae,gae,vae,Sae,Eae,Fae,Rae,Mae,Pae,zae,Bae,Uae,Hae,Xae,Jae,tre,are,ire,ure,hre,bre,gee,xre,mne,kre,Nre,Ere,xee,$re,Ore,Lre,Vre,Hre,Xre,Jre,nse,ise,use,cse,fse,bse,xse,Ise,Nse,Cse,_se,Fse,Mse,zse,Use,Zse,kee,tie,rie,oie,pie,Jte,hie,fie,bie,vie,Sie,wee,Tie,Eie,Aie,$ie,Die,Qte,qse,Oie,Wie,Gie,See,Kie,Zie,toe,roe,loe,poe,hoe,goe,xoe,koe,Noe,Eoe,$oe,Moe,zoe,Voe,Wte,Xse,Hoe,qoe,Xoe,Zoe,Qoe,tle,ale,sle,ole,ple,dle,mle,gle,xle,wle,Ile,Nle,Kse,Fee,Ele,Fle,Dle,Ole,Wle,Ule,$ee,Hle,qle,Yle,mie];for(let e of Zle)ed(e);var Qe;(function(e){e[e.float32=0]=\"float32\",e[e.int32=1]=\"int32\",e[e.bool=2]=\"bool\",e[e.string=3]=\"string\",e[e.complex64=4]=\"complex64\"})(Qe||(Qe={}));var Ac;(function(e){e[e.linear=0]=\"linear\",e[e.relu=1]=\"relu\",e[e.relu6=2]=\"relu6\",e[e.prelu=3]=\"prelu\",e[e.leakyrelu=4]=\"leakyrelu\",e[e.sigmoid=5]=\"sigmoid\",e[e.elu=6]=\"elu\"})(Ac||(Ac={}));var lF;function Jle(e){lF=e.wasm.cwrap(ii,null,[\"number\",\"array\",\"number\",\"number\",\"array\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Qle(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t;if(r.dtype!==\"float32\"||s.dtype!==\"float32\")throw new Error(\"_FusedMatMul for non non-float32 tensors not yet supported.\");let{transposeA:l,transposeB:u,activation:p,leakyreluAlpha:d}=a,c=n.dataIdMap.get(r.dataId).id,h=n.dataIdMap.get(s.dataId).id,m=0;if(i!=null){let _=n.dataIdMap.get(i.dataId);if(_.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${_.shape.length}.`);m=_.id}let f=o==null?0:n.dataIdMap.get(o.dataId).id,g=Ac[p];if(g==null)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);let b=l?r.shape[2]:r.shape[1],y=u?s.shape[1]:s.shape[2],x=Ju.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)),v=n.makeOutput([...x,b,y],r.dtype),I=n.dataIdMap.get(v.dataId).id,N=new Uint8Array(new Int32Array(r.shape).buffer),C=new Uint8Array(new Int32Array(s.shape).buffer);return lF(c,N,r.shape.length,h,C,s.shape.length,l,u,g,m,f,d||0,I),v}var eue={kernelName:ii,backendName:\"wasm\",setupFunc:Jle,kernelFunc:Qle};function Xe(e,t){let n;function a(s){n=s.wasm.cwrap(e,null,[\"number\",\"number\",\"number\"])}function r(s){let{backend:i,inputs:{x:o}}=s,l=i.dataIdMap.get(o.dataId).id,u=i.makeOutput(o.shape,t||o.dtype),p=i.dataIdMap.get(u.dataId).id;return w.sizeFromShape(u.shape)===0||n(l,Qe[o.dtype],p),u}return{kernelName:e,backendName:\"wasm\",setupFunc:a,kernelFunc:r}}var tue=Xe(Yl),nue=Xe(Ni),aue=Xe(Ti);function Ut(e,t,n){let a;function r(i){a=i.wasm.cwrap(e,null,[\"number\",\"array\",\"number\",\"number\",\"array\",\"number\",\"number\",\"number\"])}function s(i){let{backend:o,inputs:l}=i,{a:u,b:p}=l,d=o.dataIdMap.get(u.dataId).id,c=o.dataIdMap.get(p.dataId).id,h=n!=null?n:u.dtype,m=T.assertAndGetBroadcastShape(u.shape,p.shape),f=o.makeOutput(m,h);if(w.sizeFromShape(m)===0)return f;let g=new Uint8Array(new Int32Array(u.shape).buffer),b=new Uint8Array(new Int32Array(p.shape).buffer),y=o.dataIdMap.get(f.dataId).id;return a(d,g,u.shape.length,c,b,p.shape.length,Qe[u.dtype],y),f}return{kernelName:e,backendName:\"wasm\",setupFunc:r,kernelFunc:s}}var rue=!0,sue=Ut(vs,rue),uF;function iue(e){uF=e.wasm.cwrap(Ci,null,[\"array\",\"number\",\"number\",\"number\"])}function oue(e){let{inputs:t,backend:n}=e,a=n.makeOutput(t[0].shape,t[0].dtype);if(w.sizeFromShape(a.shape)===0)return a;let r=t.map(o=>n.dataIdMap.get(o.dataId).id),s=new Uint8Array(new Int32Array(r).buffer),i=n.dataIdMap.get(a.dataId).id;return uF(s,r.length,Qe[a.dtype],i),a}var lue={kernelName:Ci,backendName:\"wasm\",setupFunc:iue,kernelFunc:oue};function Gf(e){let{inputs:{x:t},backend:n}=e;if(t.dtype===\"string\")return bn(n.readSync(t.dataId),t.shape,t.dtype);let a=n.makeOutput(t.shape,t.dtype),r=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(a).set(r),a}var uue={kernelName:eo,backendName:\"wasm\",kernelFunc:Gf},pF;function pue(e){pF=e.wasm.cwrap(Cr,null,[\"number\",\"array\",\"number\",\"number\",\"number\",\"array\",\"number\"])}function ys(e){let{inputs:t,backend:n,attrs:a}=e,[r,s]=due(t.x.shape,a.perm),i=!0;for(let m=0;m<s.length;m++)s[m]!==m&&(i=!1);let o=cue(t.x.shape,a.perm),l={dataId:t.x.dataId,shape:r,dtype:t.x.dtype};if(i){let m=Gf({inputs:t,backend:n});return m.shape=o,m}let u=n.makeOutput(o,l.dtype),p=n.dataIdMap.get(l.dataId).id,d=n.dataIdMap.get(u.dataId).id,c=new Uint8Array(new Int32Array(s).buffer),h=new Uint8Array(new Int32Array(l.shape).buffer);return pF(p,h,l.shape.length,Qe[l.dtype],d,c,s.length),u}function cue(e,t){let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];return n}function due(e,t){let n=[],a=[];for(let r=0;r<e.length;++r)e[r]!==1&&n.push(e[r]),e[t[r]]!==1&&a.push(t[r]);for(let r=0;r<a.length;++r){let s=-1;for(let i=0;i<a.length;++i)a[i]>=r&&(s===-1||a[s]>a[i])&&(s=i);a[s]=r}return[n,a]}var hue={kernelName:Cr,backendName:\"wasm\",kernelFunc:ys,setupFunc:pue};function Ds(e,t,n){let a=e.shape,r=e.shape.length,s=w.parseAxisParam(t,a),i=s,o=T.getAxesPermutation(i,r),l=null,u=!1;if(o!=null){let p=new Array(r);for(let c=0;c<p.length;c++)p[c]=a[o[c]];i=T.getInnerMostAxes(i.length,r),l=ys({inputs:{x:e},attrs:{perm:o},backend:n});let d=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==d&&(u=!0)}return{transposed:l,originalAxes:s,axes:i,inputWasTransposed:u}}var cF;function mue(e){cF=e.wasm.cwrap(Zl,null,[\"number, number, number\"])}function fue(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:p,originalAxes:d,inputWasTransposed:c}=Ds(i,r,t);if(c){let y=t.dataIdMap.get(u.dataId).id;l=u,o=y}let h=l.shape.length;T.assertAxesAreInnerMostDims(\"all\",p,h);let[m,f]=T.computeOutAndReduceShapes(l.shape,p),g=w.sizeFromShape(f),b=t.makeOutput(m,i.dtype);if(w.sizeFromShape(l.shape)!==0){let y=t.dataIdMap.get(b.dataId).id;cF(o,g,y)}if(c&&t.disposeData(u.dataId),s){let y=T.expandShapeToKeepDim(b.shape,d);b.shape=y}return b}var gue={kernelName:Zl,backendName:\"wasm\",setupFunc:mue,kernelFunc:fue},dF;function bue(e){dF=e.wasm.cwrap(Jl,null,[\"number, number, number\"])}function yue(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:p,originalAxes:d,inputWasTransposed:c}=Ds(i,r,t);if(c){let y=t.dataIdMap.get(u.dataId).id;l=u,o=y}let h=l.shape.length;T.assertAxesAreInnerMostDims(\"any\",p,h);let[m,f]=T.computeOutAndReduceShapes(l.shape,p),g=w.sizeFromShape(f),b=t.makeOutput(m,i.dtype);if(w.sizeFromShape(l.shape)!==0){let y=t.dataIdMap.get(b.dataId).id;dF(o,g,y)}if(c&&t.disposeData(u.dataId),s){let y=T.expandShapeToKeepDim(b.shape,d);b.shape=y}return b}var xue={kernelName:Jl,backendName:\"wasm\",setupFunc:bue,kernelFunc:yue};function hF(e){let t;function n(r){t=r.wasm.cwrap(e,null,[\"number\",\"number\",\"number\",\"number\",\"number\"])}function a(r){let{backend:s,inputs:i,attrs:o}=r,{axis:l}=o,{x:u}=i,p=s.dataIdMap.get(u.dataId).id,d=p,c=u,{transposed:h,axes:m,inputWasTransposed:f}=Ds(u,l,s);if(f){let I=s.dataIdMap.get(h.dataId).id;I!==p&&(c=h,d=I)}let g=c.shape.slice(0,-1),b=s.makeOutput(g,\"int32\"),y=s.dataIdMap.get(b.dataId).id,x=w.sizeFromShape(b.shape),v=c.shape[m[0]];return t(d,Qe[c.dtype],x,v,y),f&&s.disposeData(h.dataId),b}return{kernelName:e,backendName:\"wasm\",setupFunc:n,kernelFunc:a}}var vue=hF(Ql),wue=hF(eu),kue=Xe(Ei),Iue=Xe(_i),Sue=Xe(Ai),Nue=Ut($i,!1),Tue=Xe(Fi),mF;function Cue(e){mF=e.wasm.cwrap(Di,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Eue(e){let{inputs:t,attrs:n,backend:a}=e,r=t.x,s=a.dataIdMap.get(r.dataId).id,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,p=T.computePool2DInfo(r.shape,i,o,1,l,u),d=p.filterHeight,c=p.filterWidth,h=p.padInfo.top,m=p.padInfo.right,f=p.padInfo.bottom,g=p.padInfo.left,b=p.strideHeight,y=p.strideWidth,x=p.inChannels;if(p.dataFormat!==\"channelsLast\")throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);if(p.dilationWidth!==1||p.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${p.dilationHeight}, ${p.dilationWidth}].`);let v=a.makeOutput(p.outShape,\"float32\"),I=a.dataIdMap.get(v.dataId).id;return mF(s,r.shape[0],r.shape[1],r.shape[2],d,c,h,m,f,g,b,y,x,I),v}var _ue={kernelName:Di,backendName:\"wasm\",setupFunc:Cue,kernelFunc:Eue},fF;function Aue(e){fF=e.wasm.cwrap(\"AvgPool3D\",null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Fue(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=a,p=T.computePool3DInfo(r.shape,s,i,1,o,l,u),d=n.makeOutput(p.outShape,r.dtype);return fF(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),d}var $ue={kernelName:tu,backendName:\"wasm\",setupFunc:Aue,kernelFunc:Fue},gF;function Due(e){gF=e.wasm.cwrap(\"AvgPool3DGrad\",null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Rue(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=a,p=T.computePool3DInfo(s.shape,i,o,1,l,u),d=n.makeOutput(s.shape,s.dtype);return gF(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left,p.filterDepth,p.filterHeight,p.filterWidth),d}var Mue={kernelName:Rc,backendName:\"wasm\",setupFunc:Due,kernelFunc:Rue},bF;function Oue(e){bF=e.wasm.cwrap(\"AvgPoolGrad\",null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Pue(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l}=a,u=T.computePool2DInfo(s.shape,i,o,1,l),p=n.makeOutput(s.shape,s.dtype);return bF(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(p.dataId).id,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left,u.filterHeight,u.filterWidth),p}var Lue={kernelName:Dc,backendName:\"wasm\",setupFunc:Oue,kernelFunc:Pue};function zn(e){let{inputs:t,attrs:n}=e,{x:a}=t,{shape:r}=n,s=w.sizeFromShape(a.shape),i=w.inferFromImplicitShape(r,s);return w.assert(s===w.sizeFromShape(i),()=>`new shape: ${i}, old shape: ${a.shape}. New shape and old shape must have the same number of elements.`),e.backend.incRef(a.dataId),{dataId:a.dataId,shape:i,dtype:a.dtype}}var zue={kernelName:Ru,backendName:\"wasm\",kernelFunc:zn},yF;function Wue(e){yF=e.wasm.cwrap(Ri,null,[\"number\",\"array\",\"number\",\"number\",\"array\",\"number\",\"number\",\"number\",\"number\"])}function Bue(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=a;if(r.dtype!==\"float32\"||s.dtype!==\"float32\")throw new Error(\"BatchMatMul for non non-float32 tensors not yet supported.\");let l=r.shape.length,u=s.shape.length,p=i?r.shape[l-2]:r.shape[l-1],d=o?s.shape[u-1]:s.shape[u-2],c=i?r.shape[l-1]:r.shape[l-2],h=o?s.shape[u-2]:s.shape[u-1],m=r.shape.slice(0,-2),f=s.shape.slice(0,-2),g=w.sizeFromShape(m),b=w.sizeFromShape(f),y=Ju.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([c,h]);w.assert(p===d,()=>`Error in matMul: inner shapes (${p}) and (${d}) of Tensors with shapes ${r.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let x=i?[g,p,c]:[g,c,p],v=o?[b,h,d]:[b,d,h],I=zn({inputs:{x:r},backend:n,attrs:{shape:x}}),N=zn({inputs:{x:s},backend:n,attrs:{shape:v}}),C=n.dataIdMap.get(I.dataId).id,_=n.dataIdMap.get(N.dataId).id,F=i?I.shape[2]:I.shape[1],D=o?N.shape[1]:N.shape[2],$=Math.max(g,b),S=n.makeOutput([$,F,D],I.dtype),M=n.dataIdMap.get(S.dataId).id,B=new Uint8Array(new Int32Array(I.shape).buffer),U=new Uint8Array(new Int32Array(N.shape).buffer);return yF(C,B,I.shape.length,_,U,N.shape.length,i,o,M),n.disposeData(I.dataId),n.disposeData(N.dataId),S.shape=y,S}var Vue={kernelName:Ri,backendName:\"wasm\",setupFunc:Wue,kernelFunc:Bue};function Ii(e){let{inputs:{x:t},attrs:{begin:n,size:a},backend:r}=e,[s,i]=Kt.parseSliceParams(t,n,a),o=Kt.isSliceContinous(t.shape,s,i),l=r.readSync(t.dataId),u=r.makeOutput(i,t.dtype),p=w.computeStrides(t.shape),d=r.dataIdMap.get(u.dataId);if(o){let m=Kt.computeFlatOffset(s,p);return t.dtype===\"string\"?d.stringBytes=l.slice(m,m+w.sizeFromShape(i)):r.typedArrayFromHeap(u).set(l.subarray(m,m+w.sizeFromShape(i))),u}if(t.dtype===\"string\"){let m=um(l,s,i,t.shape,t.dtype);return d.stringBytes=m,u}let c=r.typedArrayFromHeap(u),h=t.shape.length;if(h===2)Uue(l,p[0],c,s,i);else if(h===3)Gue(l,p[0],p[1],c,s,i);else if(h===4)Hue(l,p[0],p[1],p[2],c,s,i);else{let m=um(l,s,i,t.shape,t.dtype);c.set(m)}return u}function Uue(e,t,n,a,r){let s=0,i=a[0],o=a[1],l=i+r[0];for(let u=i;u<l;u++){let p=u*t+o;n.set(e.subarray(p,p+r[1]),s),s+=r[1]}}function Gue(e,t,n,a,r,s){let i=0,o=r[0],l=r[1],u=r[2],p=o+s[0],d=l+s[1];for(let c=o;c<p;c++)for(let h=l;h<d;h++){let m=c*t+h*n+u;a.set(e.subarray(m,m+s[2]),i),i+=s[2]}}function Hue(e,t,n,a,r,s,i){let o=0,l=s[0],u=s[1],p=s[2],d=l+i[0],c=u+i[1],h=p+i[2],m=s[3];for(let f=l;f<d;f++)for(let g=u;g<c;g++)for(let b=p;b<h;b++){let y=f*t+g*n+b*a+m;r.set(e.subarray(y,y+i[3]),o),o+=i[3]}}var jue={kernelName:Bu,backendName:\"wasm\",kernelFunc:Ii};function que(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:i}=a,o=s.reduce((b,y)=>b*y),l=T.getReshaped(r.shape,s,o),u=T.getPermuted(l.length,s.length),p=T.getReshapedPermuted(r.shape,s,o),d=T.getSliceBeginCoords(i,s.length),c=T.getSliceSize(p,i,s.length),h=zn({inputs:{x:r},backend:n,attrs:{shape:l}}),m=ys({inputs:{x:h},backend:n,attrs:{perm:u}}),f=zn({inputs:{x:m},backend:n,attrs:{shape:p}}),g=Ii({inputs:{x:f},backend:n,attrs:{begin:d,size:c}});return n.disposeData(h.dataId),n.disposeData(m.dataId),n.disposeData(f.dataId),g}var Kue={kernelName:nu,backendName:\"wasm\",kernelFunc:que},xF;function Xue(e){xF=e.wasm.cwrap(au,null,[\"number\",\"number\",\"boolean\",\"number\",\"number\",\"number\"])}function Yue(e){let{backend:t,inputs:n,attrs:a}=e,{x:r,weights:s}=n,{size:i}=a,o=s.shape.reduce((d,c)=>d*c,1)!==0,l=r.shape.length===1?[i]:[r.shape[0],i],u=t.makeOutput(l,s.dtype);function p(d){return t.dataIdMap.get(d.dataId).id}return xF(p(r),i,o,p(s),Qe[s.dtype],p(u)),u}var Zue={kernelName:au,backendName:\"wasm\",setupFunc:Xue,kernelFunc:Yue},Jue=!0,Que=Ut(ru,Jue);function epe(e){let{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.typedArrayFromHeap(a),i=n.typedArrayFromHeap(r),o=T.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeOutput([o.length],\"int32\",void 0,new Int32Array(o))}var tpe={kernelName:Mc,backendName:\"wasm\",kernelFunc:epe};function Rs(e){let{inputs:{x:t},attrs:{dtype:n},backend:a}=e,r=a.makeOutput(t.shape,n),s=a.typedArrayFromHeap(t);return a.typedArrayFromHeap(r).set(s),r}var npe={kernelName:Mi,backendName:\"wasm\",kernelFunc:Rs},ape=Xe(Oi),vF;function rpe(e){vF=e.wasm.cwrap(ws,null,[\"number\",\"number\",\"number\",\"number\"])}function spe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:s,clipValueMax:i}=a,o=n.dataIdMap.get(r.dataId).id,l=n.makeOutput(r.shape,r.dtype),u=n.dataIdMap.get(l.dataId).id;return vF(o,s,i,u),l}var ipe={kernelName:ws,backendName:\"wasm\",setupFunc:rpe,kernelFunc:spe};function wF(e){let{inputs:t,backend:n}=e,a=w.parseAxisParam(e.attrs.axis,t[0].shape)[0],r=t.map(h=>h.shape);T.assertParamsConsistent(r,a);let s=T.computeOutShape(t.map(h=>h.shape),a),i=t.filter(h=>w.sizeFromShape(h.shape)>0);if(i.length===1)return Gf({inputs:{x:i[0]},backend:n});let o=n.makeOutput(s,t[0].dtype);if(w.sizeFromShape(s)===0)return o;if(i[0].dtype===\"string\"){let h=i.map(x=>{let v=[-1,w.sizeFromShape(x.shape.slice(a))];return zn({inputs:{x},backend:n,attrs:{shape:v}})}),m=h.map(x=>({vals:n.readSync(x.dataId),shape:x.shape}));s=T.computeOutShape(h.map(x=>x.shape),1);let f=h[0].shape[0]===1,g=L1(m,s,t[0].dtype,f),b=T.computeOutShape(i.map(x=>x.shape),a);o.shape=b;let y=n.dataIdMap.get(o.dataId);return y.stringBytes=T.fromStringArrayToUint8(g),h.forEach(x=>n.disposeData(x.dataId)),o}let l=w.sizeFromShape(i[0].shape.slice(0,a)),u=0,p=i.map(h=>{let m=w.sizeFromShape(h.shape.slice(a));return u+=m,m}),d=i.map(h=>n.typedArrayFromHeap(h)),c=n.typedArrayFromHeap(o);for(let h=0;h<l;h++){let m=h*u;for(let f=0;f<d.length;f++){let g=p[f],b=h*g,y=d[f].subarray(b,b+g);c.set(y,m),m+=g}}return o}var ope={kernelName:su,backendName:\"wasm\",kernelFunc:wF},kF;function lpe(e){kF=e.wasm.cwrap(Pi,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function upe(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s}=t,i=a.dataIdMap.get(r.dataId).id,o=a.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:p,dimRoundingMode:d,dataFormat:c}=n,h=T.convertConv2DDataFormat(c),m=T.computeConv2DInfo(r.shape,s.shape,l,u,p,d,!1,h),f=m.filterHeight,g=m.filterWidth,b=m.padInfo.top,y=m.padInfo.right,x=m.padInfo.bottom,v=m.padInfo.left,I=m.dilationHeight,N=m.dilationWidth,C=m.strideHeight,_=m.strideWidth,F=m.inChannels,D=m.outChannels,$=m.padInfo.type===\"SAME\"?1:0;if(m.dataFormat!==\"channelsLast\")throw new Error(`wasm backend Conv2D does not support dataFormat:'${m.dataFormat}'. Please use 'channelsLast'.`);let S=a.makeOutput(m.outShape,\"float32\"),M=a.dataIdMap.get(S.dataId).id;return kF(i,r.shape[0],r.shape[1],r.shape[2],o,f,g,b,y,x,v,$,I,N,C,_,F,D,M),S}var ppe={kernelName:Pi,backendName:\"wasm\",setupFunc:lpe,kernelFunc:upe},IF;function cpe(e){IF=e.wasm.cwrap(Li,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function dpe(e){let{backend:t,inputs:n,attrs:a}=e,{dy:r,filter:s}=n,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,inputShape:p}=a,d=1,c=T.convertConv2DDataFormat(l),h=T.computeConv2DInfo(p,s.shape,i,d,o,u,!1,c),{batchSize:m,filterHeight:f,filterWidth:g,inChannels:b,inHeight:y,inWidth:x,outChannels:v,outHeight:I,outWidth:N,strideHeight:C,strideWidth:_}=h,F=f-1-h.padInfo.top,D=g-1-h.padInfo.left,$=h.dataFormat===\"channelsLast\",S=w.computeStrides(h.inShape),M=w.computeStrides(r.shape),[B,U,H]=w.computeStrides(s.shape),q=S[0],K=$?S[1]:S[2],Z=$?S[2]:1,J=$?1:S[1],ee=M[0],ae=$?M[1]:M[2],te=$?M[2]:1,se=$?1:M[1],ie=t.makeOutput(h.inShape,\"float32\"),ve=t.dataIdMap.get(ie.dataId).id,ue=t.dataIdMap.get(r.dataId).id,ye=t.dataIdMap.get(s.dataId).id;return IF(ue,ye,m,f,g,y,x,b,I,N,v,C,_,F,D,B,U,H,q,K,Z,J,ee,ae,te,se,ve),ie}var hpe={kernelName:Li,backendName:\"wasm\",setupFunc:cpe,kernelFunc:dpe},SF;function mpe(e){SF=e.wasm.cwrap(zi,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function fpe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a;if(r.dtype!==\"float32\")throw new Error(`Tensor x must have dtype float32, got ${r.dtype}`);if(s.dtype!==\"float32\")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=T.computeConv3DInfo(r.shape,s.shape,i,l,o),p=n.makeOutput(u.outShape,r.dtype);return SF(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(p.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),p}var gpe={kernelName:zi,backendName:\"wasm\",setupFunc:mpe,kernelFunc:fpe},NF;function bpe(e){NF=e.wasm.cwrap(iu,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function ype(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:l}=a;if(r.dtype!==\"float32\")throw new Error(`Tensor dy must have dtype float32, got ${r.dtype}`);if(s.dtype!==\"float32\")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=T.computeConv3DInfo(r.shape,l,i,1,o),p=n.makeOutput(u.filterShape,s.dtype);return NF(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(p.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),p}var xpe={kernelName:iu,backendName:\"wasm\",setupFunc:bpe,kernelFunc:ype},TF;function vpe(e){TF=e.wasm.cwrap(ou,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function wpe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:l}=a;if(r.dtype!==\"float32\")throw new Error(`Tensor dy must have dtype float32, got ${r.dtype}`);if(s.dtype!==\"float32\")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=T.computeConv3DInfo(l,s.shape,o,1,i),p=n.makeOutput(u.inShape,r.dtype);return TF(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(p.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),p}var kpe={kernelName:ou,backendName:\"wasm\",setupFunc:vpe,kernelFunc:wpe},Ipe=Xe(Wi),Spe=Xe(Bi),bv;(function(e){e[e.bilinear=0]=\"bilinear\",e[e.nearest=1]=\"nearest\"})(bv||(bv={}));var CF;function Npe(e){CF=e.wasm.cwrap(uu,null,[\"number\",\"number\",\"number\",\"number\",\"array\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Tpe(e){let{backend:t,inputs:n,attrs:a}=e,{method:r,extrapolationValue:s,cropSize:i}=a,{image:o,boxes:l,boxInd:u}=n,p=l.shape[0],[d,c]=i,h=[p,d,c,o.shape[3]],m=t.dataIdMap.get(o.dataId),f;o.dtype!==\"float32\"&&(f=Rs({backend:t,inputs:{x:o},attrs:{dtype:\"float32\"}}),m=t.dataIdMap.get(f.dataId));let g=m.id,b=t.dataIdMap.get(l.dataId).id,y=t.dataIdMap.get(u.dataId).id,x=t.makeOutput(h,\"float32\"),v=t.dataIdMap.get(x.dataId).id,I=new Uint8Array(new Int32Array(o.shape).buffer);return CF(g,b,y,p,I,d,c,bv[r],s,v),f!=null&&t.disposeData(f.dataId),x}var Cpe={kernelName:uu,backendName:\"wasm\",setupFunc:Npe,kernelFunc:Tpe},EF;function Epe(e){EF=e.wasm.cwrap(lu,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function _pe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a,l=r.shape.length;w.assert(r.dtype===\"float32\"||r.dtype===\"int32\",()=>`cumprod does not support ${r.dtype} tensors in the WASM backend`);let u=T.getAxesPermutation([s],l),p=r;u!==null&&(p=ys({inputs:{x:r},attrs:{perm:u},backend:n}));let d=T.getInnerMostAxes(1,l)[0];T.assertAxesAreInnerMostDims(\"cumprod\",[d],l);let c=n.makeOutput(p.shape,p.dtype),h=p.shape[d],m=n.dataIdMap.get(p.dataId).id,f=n.dataIdMap.get(c.dataId).id;EF(m,i?1:0,o?1:0,h,f,Qe[r.dtype]);let g=c;if(u!==null){let b=T.getUndoAxesPermutation(u);g=ys({inputs:{x:c},attrs:{perm:b},backend:n}),n.disposeData(p.dataId),n.disposeData(c.dataId)}return g}var Ape={kernelName:lu,backendName:\"wasm\",setupFunc:Epe,kernelFunc:_pe},_F;function Fpe(e){_F=e.wasm.cwrap(Vi,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function $pe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a,l=r.shape.length;w.assert(r.dtype===\"float32\"||r.dtype===\"int32\",()=>`cumsum does not support ${r.dtype} tensors in the WASM backend`);let u=T.getAxesPermutation([s],l),p=r;u!==null&&(p=ys({inputs:{x:r},attrs:{perm:u},backend:n}));let d=T.getInnerMostAxes(1,l)[0];T.assertAxesAreInnerMostDims(\"cumsum\",[d],l);let c=n.makeOutput(p.shape,p.dtype),h=p.shape[d],m=n.dataIdMap.get(p.dataId).id,f=n.dataIdMap.get(c.dataId).id;_F(m,i?1:0,o?1:0,h,f,Qe[r.dtype]);let g=c;if(u!==null){let b=T.getUndoAxesPermutation(u);g=ys({inputs:{x:c},attrs:{perm:b},backend:n}),n.disposeData(p.dataId),n.disposeData(c.dataId)}return g}var Dpe={kernelName:Vi,backendName:\"wasm\",setupFunc:Fpe,kernelFunc:$pe},AF;function Rpe(e){AF=e.wasm.cwrap(\"DenseBincount\",null,[\"number\",\"array\",\"number\",\"number\",\"boolean\",\"number\",\"number\",\"boolean\",\"number\"])}function Mpe(e){let{backend:t,inputs:n,attrs:a}=e,{x:r,weights:s}=n,{size:i,binaryOutput:o}=a,l=s.shape.reduce((c,h)=>c*h,1)!==0,u=r.shape.length===1?[i]:[r.shape[0],i],p=t.makeOutput(u,s.dtype);function d(c){return t.dataIdMap.get(c.dataId).id}return AF(d(r),new Uint8Array(new Int32Array(r.shape).buffer),r.shape.length,i,l,d(s),Qe[s.dtype],o,d(p)),p}var Ope={kernelName:Pc,backendName:\"wasm\",setupFunc:Rpe,kernelFunc:Mpe},FF;function Ppe(e){FF=e.wasm.cwrap(pu,null,[\"number\",\"number\",\"number\",\"array\",\"number\",\"array\",\"array\",\"number\",\"number\"])}function Lpe(e){let{backend:t,inputs:n,attrs:a}=e,{x:r}=n,{blockSize:s,dataFormat:i}=a,o=r.shape[0],l=i===\"NHWC\"?r.shape[1]:r.shape[2],u=i===\"NHWC\"?r.shape[2]:r.shape[3],p=i===\"NHWC\"?r.shape[3]:r.shape[1],d=l*s,c=u*s,h=p/(s*s),m=i===\"NHWC\"?[o,d,c,h]:[o,h,d,c],f=t.makeOutput(m,\"float32\"),g=t.dataIdMap.get(r.dataId).id,b=new Uint8Array(new Int32Array(w.computeStrides(r.shape)).buffer),y=new Uint8Array(new Int32Array(m).buffer),x=new Uint8Array(new Int32Array(w.computeStrides(m)).buffer),v=t.dataIdMap.get(f.dataId).id;return FF(g,s,i===\"NHWC\"?1:0,b,r.shape.length-1,y,x,m.length,v),f}var zpe={kernelName:pu,backendName:\"wasm\",setupFunc:Ppe,kernelFunc:Lpe},$F;function Wpe(e){$F=e.wasm.cwrap(Ui,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Bpe(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s}=t,i=a.dataIdMap.get(r.dataId).id,o=a.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:p,dimRoundingMode:d}=n,c=u==null?[1,1]:u,h=T.computeConv2DInfo(r.shape,s.shape,l,c,p,d,!0),m=h.filterHeight,f=h.filterWidth,g=h.padInfo.top,b=h.padInfo.right,y=h.padInfo.bottom,x=h.padInfo.left,v=h.dilationHeight,I=h.dilationWidth,N=h.strideHeight,C=h.strideWidth,_=h.inChannels,F=h.outChannels,D=h.padInfo.type===\"SAME\"?1:0;if(h.dataFormat!==\"channelsLast\")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);let $=a.makeOutput(h.outShape,\"float32\"),S=a.dataIdMap.get($.dataId).id;return $F(i,r.shape[0],r.shape[1],r.shape[2],o,m,f,g,b,y,x,D,v,I,N,C,_,F,S),$}var Vpe={kernelName:Ui,backendName:\"wasm\",setupFunc:Wpe,kernelFunc:Bpe},DF;function Upe(e){DF=e.wasm.cwrap(\"Diag\",null,[\"number\",\"number\",\"number\",\"number\"])}function Gpe(e){let{inputs:t,backend:n}=e,{x:a}=t,r=w.sizeFromShape(a.shape),s=n.makeOutput([...a.shape,...a.shape],a.dtype);return DF(n.dataIdMap.get(a.dataId).id,Qe[a.dtype],r,n.dataIdMap.get(s.dataId).id),s}var Hpe={kernelName:Lc,backendName:\"wasm\",setupFunc:Upe,kernelFunc:Gpe},RF;function jpe(e){RF=e.wasm.cwrap(Gi,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function qpe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a;if(r.dtype!==s.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${r.dtype} and ${s.dtype}`);let u=T.computeDilation2DInfo(r.shape,s.shape,i,o,\"NHWC\",l),p=n.makeOutput(u.outShape,r.dtype);return RF(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(p.dataId).id,Qe[r.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),p}var Kpe={kernelName:Gi,backendName:\"wasm\",setupFunc:jpe,kernelFunc:qpe},MF;function Xpe(e){MF=e.wasm.cwrap(Rl,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Ype(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=a;if(r.dtype!==s.dtype||r.dtype!==i.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${r.dtype}, ${s.dtype}, and ${i.dtype}`);let p=T.computeDilation2DInfo(r.shape,s.shape,o,l,\"NHWC\",u),d=n.makeOutput(s.shape,s.dtype);return MF(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,Qe[r.dtype],p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.filterHeight,p.filterWidth,p.padInfo.top,p.padInfo.left),d}var Zpe={kernelName:Rl,backendName:\"wasm\",setupFunc:Xpe,kernelFunc:Ype},OF;function Jpe(e){OF=e.wasm.cwrap(Dl,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Qpe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=a;if(r.dtype!==s.dtype||r.dtype!==i.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${r.dtype}, ${s.dtype}, and ${i.dtype}`);let p=T.computeDilation2DInfo(r.shape,s.shape,o,l,\"NHWC\",u),d=n.makeOutput(r.shape,r.dtype);return OF(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,Qe[r.dtype],p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.filterHeight,p.filterWidth,p.padInfo.top,p.padInfo.left),d}var ece={kernelName:Dl,backendName:\"wasm\",setupFunc:Jpe,kernelFunc:Qpe},tce=Xe(ji),PF;function nce(e){PF=e.wasm.cwrap(cu,null,[\"number\",\"number\",\"number\"])}function ace(e){let{inputs:t,backend:n}=e,{dy:a,y:r}=t,s=n.makeOutput(r.shape,\"float32\"),i=o=>n.dataIdMap.get(o.dataId).id;return PF(i(r),i(a),i(s)),s}var rce={kernelName:cu,backendName:\"wasm\",setupFunc:nce,kernelFunc:ace},sce=!1,ice=Ut(du,sce,\"bool\"),oce=Xe(qi),lce=Xe(Ki,\"float32\");function yv(e){let{inputs:t,attrs:n,backend:a}=e,{input:r}=t,{dim:s}=n,i=r.shape.length,o=r.shape.slice(),l=s;return s<0&&(w.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),zn({inputs:{x:r},backend:a,attrs:{shape:o}})}var uce={kernelName:hu,backendName:\"wasm\",kernelFunc:yv},pce=Xe(Xi,\"float32\");function LF(e){let{attrs:{shape:t,value:n},backend:a}=e,{attrs:{dtype:r}}=e;r=r||w.inferDtype(n);let s=a.makeOutput(t,r);return a.typedArrayFromHeap(s).fill(n),s}var cce={kernelName:zc,backendName:\"wasm\",kernelFunc:LF},zF;function dce(e){zF=e.wasm.cwrap(mu,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function hce(e){let{inputs:t,backend:n}=e,{image:a}=t,r=n.makeOutput(a.shape,a.dtype),s=n.dataIdMap.get(a.dataId).id,i=n.dataIdMap.get(r.dataId).id,[o,l,u,p]=a.shape;return zF(s,o,l,u,p,i),r}var mce={kernelName:mu,backendName:\"wasm\",kernelFunc:hce,setupFunc:dce},fce=Xe(Yi),gce=!1,bce=Ut(Zi,gce),WF;function yce(e){WF=e.wasm.cwrap(Ji,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function xce(e){let{backend:t,inputs:n,attrs:a}=e,{varianceEpsilon:r}=a,{x:s,mean:i,variance:o,offset:l,scale:u}=n,p=t.dataIdMap.get(s.dataId).id,d=t.dataIdMap.get(i.dataId).id,c=t.dataIdMap.get(o.dataId).id,h=l!=null?t.dataIdMap.get(l.dataId).id:0,m=u!=null?t.dataIdMap.get(u.dataId).id:0,f=t.makeOutput(s.shape,s.dtype);if(w.sizeFromShape(s.shape)===0)return f;let g=t.dataIdMap.get(f.dataId).id;return WF(p,d,c,h,m,r,g),f}var vce={kernelName:Ji,backendName:\"wasm\",setupFunc:yce,kernelFunc:xce},BF;function wce(e){BF=e.wasm.cwrap(oi,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function kce(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:p,dataFormat:d,dimRoundingMode:c,activation:h,leakyreluAlpha:m}=n,f=T.computeConv2DInfo(r.shape,s.shape,l,p,u,c),g=Ac[h];if(g==null)throw new Error(`${h} activation not yet supported for FusedConv2D in the wasm backend.`);let b=a.dataIdMap.get(r.dataId).id,y=a.dataIdMap.get(s.dataId).id,x=f.outChannels,v=0;if(i!=null){let te=a.dataIdMap.get(i.dataId);if(te.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${te.shape.length}.`);if(te.shape[0]!==x)throw new Error(`FusedConv2D bias shape (${te.shape}) does not match the number of output channels (${x})`);v=te.id}let I=f.filterHeight,N=f.filterWidth,C=f.padInfo.top,_=f.padInfo.right,F=f.padInfo.bottom,D=f.padInfo.left,$=f.dilationHeight,S=f.dilationWidth,M=f.strideHeight,B=f.strideWidth,U=f.inChannels,H=f.padInfo.type===\"SAME\"?1:0,q=f.batchSize,K=f.inHeight,Z=f.inWidth;if(d!==\"NHWC\")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let J=a.makeOutput(f.outShape,\"float32\"),ee=a.dataIdMap.get(J.dataId).id,ae=o==null?0:a.dataIdMap.get(o.dataId).id;return BF(b,q,K,Z,y,I,N,v,C,_,F,D,H,$,S,M,B,U,x,g,ae,m||0,ee),J}var Ice={kernelName:oi,backendName:\"wasm\",setupFunc:wce,kernelFunc:kce},VF;function Sce(e){VF=e.wasm.cwrap(li,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Nce(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:p,dataFormat:d,dimRoundingMode:c,activation:h,leakyreluAlpha:m}=n,f=T.computeConv2DInfo(r.shape,s.shape,l,p,u,c,!0),g=Ac[h];if(g==null)throw new Error(`${h} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let b=a.dataIdMap.get(r.dataId).id,y=a.dataIdMap.get(s.dataId).id,x=f.outChannels,v=0;if(i!=null){let te=a.dataIdMap.get(i.dataId);if(te.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${te.shape.length}.`);if(te.shape[0]!==x)throw new Error(`FusedDepthwiseConv2D bias shape (${te.shape}) does not match the number of output channels (${x})`);v=te.id}let I=f.filterHeight,N=f.filterWidth,C=f.padInfo.top,_=f.padInfo.right,F=f.padInfo.bottom,D=f.padInfo.left,$=f.dilationHeight,S=f.dilationWidth,M=f.strideHeight,B=f.strideWidth,U=f.inChannels,H=f.padInfo.type===\"SAME\"?1:0,q=f.batchSize,K=f.inHeight,Z=f.inWidth;if(d!==\"NHWC\")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let J=a.makeOutput(f.outShape,\"float32\"),ee=a.dataIdMap.get(J.dataId).id,ae=o==null?0:a.dataIdMap.get(o.dataId).id;return VF(b,q,K,Z,y,I,N,v,C,_,F,D,H,$,S,M,B,U,x,g,ae,m||0,ee),J}var Tce={kernelName:li,backendName:\"wasm\",setupFunc:Sce,kernelFunc:Nce},UF;function Cce(e){UF=e.wasm.cwrap(gu,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"array\",\"number\"])}function Ece(e){let{backend:t,inputs:n}=e,{params:a,indices:r}=n,[s,i,o,l]=Yw.prepareAndValidate(a,r),u=t.makeOutput(s,a.dtype);if(i===0)return u;let p=r.shape,d=p[p.length-1],c=t.dataIdMap.get(a.dataId).id,h=t.dataIdMap.get(r.dataId).id,m=new Uint8Array(new Int32Array(l).buffer),f=t.dataIdMap.get(u.dataId).id;return UF(c,Qe[a.dtype],h,i,d,o,m,f),u}var _ce={kernelName:gu,backendName:\"wasm\",setupFunc:Cce,kernelFunc:Ece},GF;function Ace(e){GF=e.wasm.cwrap(\"Gather\",null,[\"number\",\"number\",\"array\",\"number\",\"number\",\"number\",\"array\",\"number\"])}function Fce(e){let{backend:t,inputs:n,attrs:a}=e,{x:r,indices:s}=n,{axis:i,batchDims:o}=a,l=w.parseAxisParam(i,r.shape)[0],u=t.readSync(s.dataId),p=r.shape[l];for(let C=0;C<u.length;++C){let _=u[C];w.assert(_<=p-1&&_>=0,()=>`GatherV2: the index value ${_} is not in [0, ${p-1}]`)}let d=T.segment_util.collectGatherOpShapeInfo(r,s,l,o),c=zn({inputs:{x:r},attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]},backend:t}),h=w.sizeFromShape(s.shape),m=zn({inputs:{x:s},attrs:{shape:[d.batchSize,h/d.batchSize]},backend:t}),f=[d.batchSize,d.outerSize,h/d.batchSize,d.sliceSize],g=t.makeOutput(f,r.dtype);if(w.sizeFromShape(r.shape)===0)return g;let b=c.shape.length-1,y=t.dataIdMap.get(c.dataId).id,x=t.dataIdMap.get(m.dataId).id,v=t.dataIdMap.get(g.dataId).id,I=new Uint8Array(new Int32Array(w.computeStrides(c.shape)).buffer),N=new Uint8Array(new Int32Array(w.computeStrides(f)).buffer);return GF(y,Qe[r.dtype],I,b,x,d.batchSize,N,v),t.disposeData(c.dataId),t.disposeData(m.dataId),g.shape=d.outputShape,g}var $ce={kernelName:fu,backendName:\"wasm\",setupFunc:Ace,kernelFunc:Fce},Dce=!1,Rce=Ut(bu,Dce,\"bool\"),Mce=!1,Oce=Ut(Qi,Mce,\"bool\"),Pce=Xe(to,\"bool\"),Lce=Xe(no,\"bool\"),zce=Xe(ao,\"bool\"),HF;function Wce(e){HF=e.wasm.cwrap(ro,null,[\"number\",\"number\",\"number\",\"number\"])}function Bce(e){let{inputs:{x:t},attrs:{alpha:n},backend:a}=e,r=a.dataIdMap.get(t.dataId).id,s=a.makeOutput(t.shape,\"float32\");if(w.sizeFromShape(t.shape)!==0){let i=a.dataIdMap.get(s.dataId).id;HF(r,Qe[t.dtype],n,i)}return s}var Vce={kernelName:ro,backendName:\"wasm\",setupFunc:Wce,kernelFunc:Bce},Uce=!1,Gce=Ut(yu,Uce,\"bool\"),Hce=!1,jce=Ut(xu,Hce,\"bool\"),jF;function qce(e){jF=e.wasm.cwrap(vu,null,[\"number\",\"number\",\"number\",\"number\"])}function Kce(e){let{attrs:t,backend:n}=e,{start:a,stop:r,num:s}=t,i=Math.floor(s),o=n.makeOutput([i],\"float32\");return jF(n.dataIdMap.get(o.dataId).id,a,r,i),o}var Xce={kernelName:vu,backendName:\"wasm\",setupFunc:qce,kernelFunc:Kce},Yce=Xe(so),Zce=Xe(io),Jce=!1,Qce=Ut(wu,Jce,\"bool\"),ede=Xe(ku),tde=!1,nde=Ut(Iu,tde,\"bool\"),ade=!1,rde=Ut(jS,ade,\"bool\"),qF;function sde(e){qF=e.wasm.cwrap(oo,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function ide(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=a;if(r.dtype!==\"float32\")throw new Error(\"LRN error: x must have dtype float32\");let u=n.makeOutput(r.shape,r.dtype);return qF(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(u.dataId).id,r.shape[3],s,i,o,l),u}var ode={kernelName:oo,backendName:\"wasm\",setupFunc:sde,kernelFunc:ide},KF;function lde(e){KF=e.wasm.cwrap(Su,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function ude(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:p}=a;if(r.dtype!==\"float32\"||s.dtype!==\"float32\"||i.dtype!==\"float32\")throw new Error(\"LRNGrad error: x, y, and dy must have dtype float32\");let d=n.makeOutput(r.shape,r.dtype);return KF(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,i.shape[3],o,l,u,p),d}var pde={kernelName:Su,backendName:\"wasm\",setupFunc:lde,kernelFunc:ude},XF;function cde(e){XF=e.wasm.cwrap(lo,null,[\"number\",\"number\",\"number\",\"number\"])}function dde(e){let{backend:t,inputs:n,attrs:a}=e,{reductionIndices:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:p,originalAxes:d,inputWasTransposed:c}=Ds(i,r,t);if(c){let y=t.dataIdMap.get(u.dataId).id;l=u,o=y}let h=l.shape.length;T.assertAxesAreInnerMostDims(\"max\",p,h);let[m,f]=T.computeOutAndReduceShapes(l.shape,p),g=w.sizeFromShape(f),b=t.makeOutput(m,i.dtype);if(w.sizeFromShape(l.shape)!==0){let y=t.dataIdMap.get(b.dataId).id;XF(o,Qe[i.dtype],g,y)}if(c&&t.disposeData(u.dataId),s){let y=T.expandShapeToKeepDim(b.shape,d);b.shape=y}return b}var hde={kernelName:lo,backendName:\"wasm\",setupFunc:cde,kernelFunc:dde},mde=!1,fde=Ut(uo,mde),YF;function gde(e){YF=e.wasm.cwrap(po,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function bde(e){let{inputs:t,attrs:n,backend:a}=e,r=t.x,s=a.dataIdMap.get(r.dataId).id;w.assert(r.dtype===\"float32\",()=>`Error in MaxPool: only float32 input is supported. Got ${r.dtype}.`);let{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,p=T.computePool2DInfo(r.shape,i,o,1,l,u),d=p.filterHeight,c=p.filterWidth,h=p.padInfo.top,m=p.padInfo.right,f=p.padInfo.bottom,g=p.padInfo.left,b=p.dilationHeight,y=p.dilationWidth,x=p.strideHeight,v=p.strideWidth,I=p.inChannels,N=p.outChannels;if(p.dataFormat!==\"channelsLast\")throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);let C=a.makeOutput(p.outShape,\"float32\"),_=a.dataIdMap.get(C.dataId).id;return YF(s,r.shape[0],r.shape[1],r.shape[2],d,c,h,m,f,g,b,y,x,v,I,N,_),C}var yde={kernelName:po,backendName:\"wasm\",setupFunc:gde,kernelFunc:bde},ZF;function xde(e){ZF=e.wasm.cwrap(\"MaxPool3D\",null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function vde(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=a,p=T.computePool3DInfo(r.shape,s,i,1,o,l,u),d=n.makeOutput(p.outShape,r.dtype);return ZF(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),d}var wde={kernelName:Nu,backendName:\"wasm\",setupFunc:xde,kernelFunc:vde},JF;function kde(e){JF=e.wasm.cwrap(\"MaxPool3DGrad\",null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Ide(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=a,p=T.computePool3DInfo(s.shape,i,o,1,l,u),d=n.makeOutput(s.shape,s.dtype);return JF(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),d}var Sde={kernelName:Bc,backendName:\"wasm\",setupFunc:kde,kernelFunc:Ide},QF;function Nde(e){QF=e.wasm.cwrap(\"MaxPoolGrad\",null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Tde(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=a,p=T.computePool2DInfo(s.shape,i,o,1,l,u),d=n.makeOutput(s.shape,s.dtype);return QF(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.top,p.padInfo.left),d}var Cde={kernelName:Wc,backendName:\"wasm\",setupFunc:Nde,kernelFunc:Tde},e$;function Ede(e){e$=e.wasm.cwrap(\"MaxPoolWithArgmax\",null,[\"number\",\"number\",\"number\",\"number\",\"boolean\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function _de(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=a;w.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let u=[1,1];w.assert(T.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let p=T.computePool2DInfo(r.shape,s,i,[1,1],o),d=n.makeOutput(p.outShape,r.dtype),c=n.makeOutput(p.outShape,\"int32\");return e$(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,n.dataIdMap.get(c.dataId).id,Qe[r.dtype],l,p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.top,p.padInfo.left),[d,c]}var Ade={kernelName:Vc,backendName:\"wasm\",setupFunc:Ede,kernelFunc:_de},t$;function Fde(e){t$=e.wasm.cwrap(co,null,[\"number, number, number\"])}function $de(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:d,originalAxes:c,inputWasTransposed:h}=Ds(i,r,t),m=d;if(h){let v=t.dataIdMap.get(p.dataId).id;v!==o&&(u=p,l=v,m=T.getInnerMostAxes(m.length,u.shape.length))}T.assertAxesAreInnerMostDims(\"mean\",m,u.shape.length);let[f,g]=T.computeOutAndReduceShapes(u.shape,m),b=w.sizeFromShape(g),y=u;u.dtype!==\"float32\"&&(y=Rs({backend:t,inputs:{x:u},attrs:{dtype:\"float32\"}}),l=t.dataIdMap.get(y.dataId).id);let x=t.makeOutput(f,\"float32\");if(w.sizeFromShape(u.shape)!==0){let v=t.dataIdMap.get(x.dataId).id;t$(l,b,v)}if(h&&t.disposeData(p.dataId),s){let v=T.expandShapeToKeepDim(x.shape,c);x.shape=v}return u.dtype!==\"float32\"&&t.disposeData(y.dataId),x}var Dde={kernelName:co,backendName:\"wasm\",setupFunc:Fde,kernelFunc:$de},n$;function Rde(e){n$=e.wasm.cwrap(ho,null,[\"number\",\"number\",\"number\",\"number\"])}function Mde(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:d,originalAxes:c,inputWasTransposed:h}=Ds(i,r,t);if(h){let x=t.dataIdMap.get(p.dataId).id;x!==o&&(u=p,l=x)}let m=u.shape.length;T.assertAxesAreInnerMostDims(\"min\",d,m);let[f,g]=T.computeOutAndReduceShapes(u.shape,d),b=w.sizeFromShape(g),y=t.makeOutput(f,u.dtype);if(w.sizeFromShape(u.shape)!==0){let x=t.dataIdMap.get(y.dataId).id;n$(l,Qe[i.dtype],b,x)}if(h&&t.disposeData(p.dataId),s){let x=T.expandShapeToKeepDim(y.shape,c);y.shape=x}return y}var Ode={kernelName:ho,backendName:\"wasm\",setupFunc:Rde,kernelFunc:Mde},Pde=!1,Lde=Ut(mo,Pde),xv;(function(e){e[e.reflect=0]=\"reflect\",e[e.symmetric=1]=\"symmetric\"})(xv||(xv={}));var a$;function zde(e){a$=e.wasm.cwrap(fo,null,[\"number\",\"array\",\"number\",\"number\",\"array\",\"array\",\"number\",\"number\"])}function Wde(e){let{inputs:{x:t},backend:n,attrs:{paddings:a,mode:r}}=e,s=a.map((m,f)=>m[0]+t.shape[f]+m[1]),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),p=a.map(m=>m[0]),d=a.map(m=>m[1]),c=new Uint8Array(new Int32Array(p).buffer),h=new Uint8Array(new Int32Array(d).buffer);return a$(i,u,t.shape.length,Qe[t.dtype],c,h,xv[r],l),o}var Bde={kernelName:fo,backendName:\"wasm\",kernelFunc:Wde,setupFunc:zde},r$;function Vde(e){r$=e.wasm.cwrap(zo,null,[\"number\",\"number\",\"number\",\"number\"])}function s$(e){let{backend:t,inputs:{logits:n},attrs:{dim:a}}=e,r=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(s.dataId).id,o=n.shape[a],l=w.sizeFromShape(n.shape)/o;return w.sizeFromShape(s.shape)===0||r$(r,i,o,l),s}var Ude={kernelName:zo,backendName:\"wasm\",setupFunc:Vde,kernelFunc:s$},i$;function Gde(e){i$=e.wasm.cwrap(Tu,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Hde(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=a;if(r.dtype!==\"float32\")throw new Error(`Tensor logits must have dtype float32, got ${r.dtype}`);let l=o?r:s$({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),[u,p]=l.shape,d=n.makeOutput([u,s],\"int32\");return i$(n.dataIdMap.get(l.dataId).id,u,p,s,i,n.dataIdMap.get(d.dataId).id),o||n.disposeData(l.dataId),d}var jde={kernelName:Tu,backendName:\"wasm\",setupFunc:Gde,kernelFunc:Hde},qde=Ut(go,!0),Kde=!0,Xde=Ut(bo,Kde),Yde=Xe(Cu);function hk(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),a=n[0],r=n[1],s=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:a,selectedSize:r,pSelectedScores:s,pValidOutputs:i}}var o$;function Zde(e){o$=e.wasm.cwrap(_u,\"number\",[\"number\",\"number\",\"number\",\"number\",\"number\"])}function Jde(e){let{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i}=a,{boxes:o,scores:l}=n,u=t.dataIdMap.get(o.dataId).id,p=t.dataIdMap.get(l.dataId).id,d=o$(u,p,s,r,i),{pSelectedIndices:c,selectedSize:h,pSelectedScores:m,pValidOutputs:f}=hk(t,d);return t.wasm._free(m),t.wasm._free(f),t.makeOutput([h],\"int32\",c)}var Qde={kernelName:_u,backendName:\"wasm\",setupFunc:Zde,kernelFunc:Jde},l$;function ehe(e){l$=e.wasm.cwrap(Au,\"number\",[\"number\",\"number\",\"number\",\"number\",\"number\",\"bool\"])}function the(e){let{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:o}=a,{boxes:l,scores:u}=n,p=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,c=l$(p,d,s,r,i,o),{pSelectedIndices:h,selectedSize:m,pSelectedScores:f,pValidOutputs:g}=hk(t,c);t.wasm._free(f);let b=t.makeOutput([m],\"int32\",h),y=t.makeOutput([],\"int32\",g);return[b,y]}var nhe={kernelName:Au,backendName:\"wasm\",setupFunc:ehe,kernelFunc:the},u$;function ahe(e){u$=e.wasm.cwrap(Fu,\"number\",[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function rhe(e){let{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i,softNmsSigma:o}=a,{boxes:l,scores:u}=n,p=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,c=u$(p,d,s,r,i,o),{pSelectedIndices:h,selectedSize:m,pSelectedScores:f,pValidOutputs:g}=hk(t,c);t.wasm._free(g);let b=t.makeOutput([m],\"int32\",h),y=t.makeOutput([m],\"float32\",f);return[b,y]}var she={kernelName:Fu,backendName:\"wasm\",setupFunc:ahe,kernelFunc:rhe},ihe=!1,ohe=Ut(Eu,ihe,\"bool\"),p$;function lhe(e){p$=e.wasm.cwrap(yo,null,[\"number\",\"number\",\"number\",\"number\",\"number\"])}function uhe(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:l}=a,u=n.makeOutput([...r.shape,i],s),p=n.dataIdMap.get(u.dataId).id,d=n.dataIdMap.get(r.dataId).id;return p$(d,i,o,l,p),u}var phe={kernelName:yo,backendName:\"wasm\",setupFunc:lhe,kernelFunc:uhe};function che(e){let{inputs:{x:t},backend:n}=e,a=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(a).fill(1),a}var dhe={kernelName:$u,backendName:\"wasm\",kernelFunc:che};function hhe(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(t.length===1)return yv({inputs:{input:t[0]},backend:n,attrs:{dim:r}});let s=t[0].shape,i=t[0].dtype;t.forEach(p=>{w.assertShapesMatch(s,p.shape,\"All tensors passed to stack must have matching shapes\"),w.assert(i===p.dtype,()=>\"All tensors passed to stack must have matching dtypes\")});let o=[],l=t.map(p=>{let d=yv({inputs:{input:p},backend:n,attrs:{dim:r}});return o.push(d),d}),u=wF({inputs:l,backend:n,attrs:{axis:r}});return o.forEach(p=>n.disposeData(p.dataId)),u}var mhe={kernelName:Du,backendName:\"wasm\",kernelFunc:hhe},c$;function fhe(e){c$=e.wasm.cwrap(xo,null,[\"number\",\"array\",\"number\",\"number\",\"array\",\"array\",\"number\",\"number\"])}function ghe(e){let{inputs:{x:t},backend:n,attrs:{paddings:a,constantValue:r}}=e,s=a.map((m,f)=>m[0]+t.shape[f]+m[1]);if(w.sizeFromShape(t.shape)===0)return LF({backend:n,attrs:{shape:s,value:r,dtype:t.dtype}});let i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),p=a.map(m=>m[0]),d=a.map(m=>m[1]),c=new Uint8Array(new Int32Array(p).buffer),h=new Uint8Array(new Int32Array(d).buffer);return c$(i,u,t.shape.length,Qe[t.dtype],c,h,r,l),o}var d$={kernelName:xo,backendName:\"wasm\",kernelFunc:ghe,setupFunc:fhe},bhe=!1,yhe=Ut(vo,bhe),h$;function xhe(e){h$=e.wasm.cwrap(wo,null,[\"number\",\"number\",\"number\"])}function vhe(e){let{inputs:t,backend:n}=e,{x:a,alpha:r}=t,s=n.dataIdMap.get(a.dataId).id,i=n.dataIdMap.get(r.dataId).id,o=s,l=a,u=l;l.dtype!==\"float32\"&&(u=Rs({backend:n,inputs:{x:a},attrs:{dtype:\"float32\"}}),o=n.dataIdMap.get(u.dataId).id);let p=n.makeOutput(a.shape,\"float32\"),d=n.dataIdMap.get(p.dataId).id;return h$(o,i,d),l.dtype!==\"float32\"&&n.disposeData(u.dataId),p}var whe={kernelName:wo,backendName:\"wasm\",setupFunc:xhe,kernelFunc:vhe},m$;function khe(e){m$=e.wasm.cwrap(ko,null,[\"number\",\"number\",\"number\",\"number\"])}function Ihe(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:d,originalAxes:c,inputWasTransposed:h}=Ds(i,r,t),m=d;if(h){let x=t.dataIdMap.get(p.dataId).id;x!==o&&(u=p,l=x,m=T.getInnerMostAxes(m.length,u.shape.length))}T.assertAxesAreInnerMostDims(\"prod\",m,u.shape.length);let[f,g]=T.computeOutAndReduceShapes(u.shape,m),b=w.sizeFromShape(g),y=t.makeOutput(f,u.dtype);if(w.sizeFromShape(u.shape)!==0){let x=t.dataIdMap.get(y.dataId).id;m$(l,b,Qe[y.dtype],x)}if(h&&t.disposeData(p.dataId),s){let x=T.expandShapeToKeepDim(y.shape,c);y.shape=x}return y}var She={kernelName:ko,backendName:\"wasm\",setupFunc:khe,kernelFunc:Ihe},Nhe=e=>{let{backend:t,attrs:n}=e,{start:a,stop:r,step:s,dtype:i}=n,o=B1(a,r,s,i),l=t.makeOutput([o.length],i);return t.typedArrayFromHeap(l).set(o),l},The={kernelName:Uc,backendName:\"wasm\",kernelFunc:Nhe},Che=!0,Ehe=Ut(Hi,Che),_he=Xe(Io),Ahe=Xe(So),Fhe=Xe(Co),f$;function $he(e){f$=e.wasm.cwrap(To,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Dhe(e){let{backend:t,inputs:n,attrs:a}=e,{images:r}=n,{alignCorners:s,halfPixelCenters:i,size:o}=a,[l,u]=o,[p,d,c,h]=r.shape,m=[p,l,u,h],f=t.dataIdMap.get(r.dataId),g;f.dtype!==\"float32\"&&(g=Rs({backend:t,inputs:{x:r},attrs:{dtype:\"float32\"}}),f=t.dataIdMap.get(g.dataId));let b=f.id,y=t.makeOutput(m,\"float32\");if(w.sizeFromShape(r.shape)===0)return y;let x=t.dataIdMap.get(y.dataId).id;return f$(b,p,d,c,h,l,u,s?1:0,i?1:0,x),g!=null&&t.disposeData(g.dataId),y}var Rhe={kernelName:To,backendName:\"wasm\",setupFunc:$he,kernelFunc:Dhe},g$;function Mhe(e){g$=e.wasm.cwrap(Ou,null,[\"number\",\"number\",\"number\",\"array\",\"array\",\"boolean\"])}function Ohe(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=n.makeOutput(r.shape,\"float32\"),l=n.dataIdMap.get(r.dataId),u;return l.dtype!==\"float32\"&&(u=Rs({backend:n,inputs:{x:r},attrs:{dtype:\"float32\"}}),l=n.dataIdMap.get(u.dataId)),g$(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(r.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),i),u!=null&&n.disposeData(u.dataId),o}var Phe={kernelName:Ou,backendName:\"wasm\",setupFunc:Mhe,kernelFunc:Ohe},b$;function Lhe(e){b$=e.wasm.cwrap(No,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function zhe(e){let{backend:t,inputs:n,attrs:a}=e,{images:r}=n,{alignCorners:s,halfPixelCenters:i,size:o}=a,[l,u]=o,[p,d,c,h]=r.shape,m=[p,l,u,h],f=t.makeOutput(m,\"float32\");if(w.sizeFromShape(r.shape)===0)return f;let g=t.dataIdMap.get(r.dataId),b;g.dtype!==\"float32\"&&(b=Rs({backend:t,inputs:{x:r},attrs:{dtype:\"float32\"}}),g=t.dataIdMap.get(b.dataId));let y=g.id,x=t.dataIdMap.get(f.dataId).id;return b$(y,p,d,c,h,l,u,s?1:0,i?1:0,x),b!=null&&t.disposeData(b.dataId),f}var Whe={kernelName:No,backendName:\"wasm\",setupFunc:Lhe,kernelFunc:zhe},y$;function Bhe(e){y$=e.wasm.cwrap(Mu,null,[\"number\",\"number\",\"number\",\"array\",\"array\",\"boolean\"])}function Vhe(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=n.makeOutput(r.shape,\"float32\"),l=n.dataIdMap.get(r.dataId),u;return l.dtype!==\"float32\"&&(u=Rs({backend:n,inputs:{x:r},attrs:{dtype:\"float32\"}}),l=n.dataIdMap.get(u.dataId)),y$(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(r.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),i),u!=null&&n.disposeData(u.dataId),o}var Uhe={kernelName:Mu,backendName:\"wasm\",setupFunc:Bhe,kernelFunc:Vhe},x$;function Ghe(e){x$=e.wasm.cwrap(Eo,null,[\"number\",\"array\",\"number\",\"array\",\"number\",\"number\"])}function Hhe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a,i=w.parseAxisParam(s,r.shape);if(r.shape.length===0)return Gf({inputs:{x:r},backend:n});let o=n.makeOutput(r.shape,r.dtype),l=n.dataIdMap.get(r.dataId).id,u=n.dataIdMap.get(o.dataId).id,p=new Uint8Array(new Int32Array(i).buffer),d=new Uint8Array(new Int32Array(r.shape).buffer);x$(l,p,i.length,d,r.shape.length,u);let c=zn({inputs:{x:o},attrs:{shape:r.shape},backend:n});return n.disposeData(o.dataId),c}var jhe={kernelName:Eo,backendName:\"wasm\",kernelFunc:Hhe,setupFunc:Ghe},v$;function qhe(e){v$=e.wasm.cwrap(Zu,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"array\",\"number\",\"number\"])}function Khe(e){let{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{radians:s,fillValue:i,center:o}=a,l=n.makeOutput(r.shape,r.dtype),u=n.dataIdMap.get(r.dataId).id,p=n.dataIdMap.get(l.dataId).id,[d,c,h,m]=r.shape,[f,g]=T.getImageCenter(o,c,h),b=i===0,y=255,x=typeof i==\"number\"?[i,i,i,b?0:y]:[...i,y],v=new Uint8Array(new Int32Array(x).buffer);return v$(u,d,c,h,m,s,f,g,v,x.length,p),l}var Xhe={kernelName:Zu,backendName:\"wasm\",kernelFunc:Khe,setupFunc:qhe},Yhe=Xe(_o),Zhe=Xe(Ao),w$;function Jhe(e){w$=e.wasm.cwrap(Pu,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"array\",\"number\",\"number\"])}function Qhe(e){let{backend:t,inputs:n,attrs:a}=e,{indices:r,updates:s}=n,{shape:i}=a,o=t.makeOutput(i,s.dtype);if(w.sizeFromShape(i)===0)return o;let{sliceRank:l,numUpdates:u,sliceSize:p,strides:d,outputSize:c}=sf.calculateShapes(s,r,i),h=t.dataIdMap.get(r.dataId).id,m=t.dataIdMap.get(s.dataId).id,f=new Uint8Array(new Int32Array(d).buffer),g=t.dataIdMap.get(o.dataId).id;return w$(h,m,Qe[s.dtype],l,u,p,f,c,g),o}var eme={kernelName:Pu,backendName:\"wasm\",setupFunc:Jhe,kernelFunc:Qhe},k$;function tme(e){k$=e.wasm.cwrap(zu,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"bool\",\"number\"])}function nme(e){let{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:i}=a;if(r.dtype!==s.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${r.dtype} and ${s.dtype}`);let o=n.makeOutput(s.shape,\"int32\");function l(u){return n.dataIdMap.get(u.dataId).id}return k$(l(r),l(s),r.shape[0],r.shape[1],s.shape[1],Qe[r.dtype],i===\"left\",l(o)),o}var ame={kernelName:zu,backendName:\"wasm\",setupFunc:tme,kernelFunc:nme},I$;function rme(e){I$=e.wasm.cwrap(\"SelectV2\",null,[\"number\",\"number\",\"number\",\"number\",\"number\"])}function sme(e){let{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t,i=n.dataIdMap.get(a.dataId).id,o=n.dataIdMap.get(r.dataId).id,l=n.dataIdMap.get(s.dataId).id,u=n.makeOutput(r.shape,r.dtype),p=n.dataIdMap.get(u.dataId).id,d=a.shape.length,c=r.shape.length,h=d===0||d>1||c===1?1:w.sizeFromShape(r.shape.slice(1));return I$(i,o,l,h,p),u}var ime={kernelName:Wu,backendName:\"wasm\",kernelFunc:sme,setupFunc:rme},ome=Xe(Fo),S$;function lme(e){S$=e.wasm.cwrap(Mo,null,[\"number\",\"number\"])}function ume(e){let{backend:t,inputs:{x:n}}=e,a=t.dataIdMap.get(n.dataId).id,r=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(r.dataId).id;return w.sizeFromShape(r.shape)===0||S$(a,s),r}var pme={kernelName:\"Sigmoid\",backendName:\"wasm\",setupFunc:lme,kernelFunc:ume},cme=Xe(Ro),dme=Xe($o),hme=Xe(Do),mme=Xe(Oo);function fme(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:i}=a,o=w.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<r.shape.length;++g)l.push([0,0]);let u=d$.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),p=T.getReshaped(u.shape,s,o,!1),d=T.getPermuted(p.length,s.length,!1),c=T.getReshapedPermuted(u.shape,s,o,!1),h=zn({inputs:{x:u},backend:n,attrs:{shape:p}}),m=ys({inputs:{x:h},backend:n,attrs:{perm:d}}),f=zn({inputs:{x:m},backend:n,attrs:{shape:c}});return n.disposeData(u.dataId),n.disposeData(h.dataId),n.disposeData(m.dataId),f}var gme={kernelName:Vu,backendName:\"wasm\",kernelFunc:fme},N$;function bme(e){N$=e.wasm.cwrap(\"SparseFillEmptyRows\",\"number\",[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function yme(e){let{backend:t,inputs:n}=e,{indices:a,values:r,denseShape:s,defaultValue:i}=n,o=a.shape[0],l=a.shape[1],u=t.readSync(s.dataId)[0],p=[o+u,l],d=t.dataIdMap.get(a.dataId).id,c=t.dataIdMap.get(r.dataId).id,h=t.dataIdMap.get(i.dataId).id,m=t.makeOutput(p,a.dtype),f=t.dataIdMap.get(m.dataId).id,g=t.makeOutput(p.slice(0,1),r.dtype),b=t.dataIdMap.get(g.dataId).id,y=t.makeOutput([u],\"bool\"),x=t.dataIdMap.get(y.dataId).id,v=t.makeOutput([o],a.dtype),I=t.dataIdMap.get(v.dataId).id,N=t.makeOutput([4],\"int32\"),C=t.dataIdMap.get(N.dataId).id,_=N$(d,c,Qe[r.dtype],o,u,l,h,f,b,x,I,C),F=t.readSync(N.dataId),D;switch(F[0]){case 1:{D=T.getSparseFillEmptyRowsIndicesDenseShapeMismatch(F[1]);break}case 2:{D=T.getSparseFillEmptyRowsNegativeIndexErrorMessage(F[1],F[2]);break}case 3:D=T.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(F[1],F[2],F[3]);break;default:D=\"\"}if(t.disposeData(N.dataId),D)throw t.disposeData(m.dataId),t.disposeData(g.dataId),t.disposeData(y.dataId),t.disposeData(v.dataId),new Error(D);let $=m,S=g;return _!==p[0]&&($=Ii({inputs:{x:m},attrs:{begin:0,size:[_,l]},backend:t}),S=Ii({inputs:{x:g},attrs:{begin:0,size:_},backend:t}),t.disposeData(m.dataId),t.disposeData(g.dataId)),[$,S,y,v]}var xme={kernelName:Gc,backendName:\"wasm\",setupFunc:bme,kernelFunc:yme},T$;function vme(e){T$=e.wasm.cwrap(Gu,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function wme(e){let{backend:t,inputs:n}=e,{inputIndices:a,inputShape:r,newShape:s}=n;if(a.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape\n        ${a.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape\n        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=t.dataIdMap.get(a.dataId).id,o=t.dataIdMap.get(r.dataId).id,l=t.dataIdMap.get(s.dataId).id,u=a.shape[0],p=w.sizeFromShape(s.shape),d=t.makeOutput([u,p],a.dtype),c=t.dataIdMap.get(d.dataId).id,h=t.makeOutput([p],s.dtype),m=t.dataIdMap.get(h.dataId).id,f=t.makeOutput([3],\"int32\"),g=t.dataIdMap.get(f.dataId).id;T$(i,o,l,u,c,m,g);let b=t.readSync(f.dataId),y;switch(b[0]){case 0:{y=T.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(b[1],b[2]);break}case 1:{y=T.getSparseReshapeNegativeOutputDimErrorMessage(b[1],b[2]);break}case 2:y=T.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let x=Array.from(t.readSync(r.dataId)),v=Array.from(t.readSync(h.dataId));y=T.getSparseReshapeInputOutputMultipleErrorMessage(x,v);break}case 4:{let x=Array.from(t.readSync(r.dataId)),v=Array.from(t.readSync(h.dataId));y=T.getSparseReshapeInputOutputMismatchErrorMessage(x,v);break}default:y=\"\"}if(t.disposeData(f.dataId),y)throw t.disposeData(d.dataId),t.disposeData(h.dataId),new Error(y);return[d,h]}var kme={kernelName:Gu,backendName:\"wasm\",setupFunc:vme,kernelFunc:wme},C$;function E$(e){C$=e.wasm.cwrap(\"SparseSegmentReduction\",null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function _$(e,t){let{backend:n,inputs:a}=e,{data:r,indices:s,segmentIds:i}=a,o=s.shape[0],l=n.readSync(i.dataId,o-1,o)[0],u=o>0?l+1:0;if(u<0)throw new Error(T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let p=r.shape.slice();p[0]=u;let d=n.dataIdMap.get(r.dataId).id,c=n.dataIdMap.get(s.dataId).id,h=n.dataIdMap.get(i.dataId).id,m=n.makeOutput(p,r.dtype),f=n.dataIdMap.get(m.dataId).id,g=n.makeOutput([4],\"int32\"),b=n.dataIdMap.get(g.dataId).id;C$(d,Qe[r.dtype],r.shape[0],c,h,f,b,t,0);let y=n.readSync(g.dataId),x;switch(y[0]){case 0:{x=T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{x=T.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:x=T.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y[1],y[2]);break;case 3:x=T.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(y[1],y[2],y[3]);break;default:x=\"\"}if(n.disposeData(g.dataId),x)throw n.disposeData(m.dataId),new Error(x);return m}function Ime(e){return _$(e,!0)}var Sme={kernelName:Hc,backendName:\"wasm\",setupFunc:E$,kernelFunc:Ime};function Nme(e){return _$(e,!1)}var Tme={kernelName:jc,backendName:\"wasm\",setupFunc:E$,kernelFunc:Nme},A$;function Cme(e){A$=e.wasm.cwrap(Hu,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"array\",\"number\",\"number\"])}function Eme(e){let{backend:t,inputs:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=n,{outputShape:o}=a,l=t.makeOutput(o,i.dtype);if(w.sizeFromShape(o)===0)return l;let{sliceRank:u,numUpdates:p,sliceSize:d,strides:c,outputSize:h}=T.calculateShapes(s,r,o),m=t.dataIdMap.get(r.dataId).id,f=t.dataIdMap.get(s.dataId).id,g=t.dataIdMap.get(i.dataId).id,b=new Uint8Array(new Int32Array(c).buffer),y=t.dataIdMap.get(l.dataId).id;return A$(m,f,s.shape.length,g,Qe[i.dtype],u,p,d,b,h,y),l}var _me={kernelName:Hu,backendName:\"wasm\",setupFunc:Cme,kernelFunc:Eme};function Ame(e){let{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=n,o=w.parseAxisParam(i,r.shape)[0],l=T.prepareSplitSize(r,s,o),u=new Array(r.shape.length).fill(0),p=r.shape.slice();return l.map(d=>{let c=[...p];c[o]=d;let h=Ii({inputs:{x:r},attrs:{begin:u,size:c},backend:a});return u[o]+=d,h})}var Fme={kernelName:Uu,backendName:\"wasm\",kernelFunc:Ame},$me=Xe(Po),Dme=Xe(qc),Rme=!0,Mme=Ut(Wo,Rme),F$;function Ome(e){F$=e.wasm.cwrap(Is,null,[\"number\",\"number\",\"number\",\"number\"])}function Pme(e){let{backend:t,inputs:n,attrs:a}=e,{alpha:r}=a,{x:s}=n,i=t.dataIdMap.get(s.dataId).id,o=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(o.dataId).id;return F$(i,r,Qe[s.dtype],l),o}var Lme={kernelName:Is,backendName:\"wasm\",setupFunc:Ome,kernelFunc:Pme},$$;function zme(e){$$=e.wasm.cwrap(ju,null,[\"number\",\"array\",\"number\",\"array\",\"array\",\"array\",\"array\",\"array\",\"number\",\"number\"])}function Wme(e){let{backend:t,inputs:n,attrs:a}=e,{x:r}=n,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:p,newAxisMask:d,shrinkAxisMask:c}=a,{finalShapeSparse:h,finalShape:m,isIdentity:f,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:v}=Kt.sliceInfo(r.shape,s,i,o,l,u,p,d,c),I;if(f)I=zn({inputs:{x:r},backend:t,attrs:{shape:m}});else if(g||b){w.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);let N=Kt.computeOutShape(y,x,v),C=Ii({inputs:{x:r},backend:t,attrs:{begin:y,size:N}});I=zn({inputs:{x:C},backend:t,attrs:{shape:m}}),t.disposeData(C.dataId)}else{let N=t.makeOutput(h,\"float32\"),C=t.dataIdMap.get(r.dataId).id,_=new Uint8Array(new Int32Array(w.computeStrides(r.shape)).buffer),F=new Uint8Array(new Int32Array(y).buffer),D=new Uint8Array(new Int32Array(x).buffer),$=new Uint8Array(new Int32Array(v).buffer),S=new Uint8Array(new Int32Array(h).buffer),M=new Uint8Array(new Int32Array(w.computeStrides(h)).buffer),B=t.dataIdMap.get(N.dataId).id;$$(C,_,r.shape.length,F,D,$,S,M,h.length,B),I=zn({inputs:{x:N},backend:t,attrs:{shape:m}}),t.disposeData(N.dataId)}return I}var Bme={kernelName:ju,backendName:\"wasm\",setupFunc:zme,kernelFunc:Wme};function Vme(e){let{backend:t,inputs:n,attrs:a}=e,{data:r,dataSplits:s}=n,{separator:i,nGramWidths:o,leftPad:l,rightPad:u,padWidth:p,preserveShortSequences:d}=a,c=t.readSync(r.dataId),h=t.readSync(s.dataId),[m,f]=U1(c,h,i,o,l,u,p,d),g=t.makeOutput([m.length],\"string\"),b=t.dataIdMap.get(g.dataId);b.stringBytes=m;let y=t.makeOutput(s.shape,\"int32\");return t.typedArrayFromHeap(y).set(f),[g,y]}var Ume={kernelName:Xc,backendName:\"wasm\",kernelFunc:Vme};function Gme(e){let{backend:t,inputs:n,attrs:a}=e,{input:r,delimiter:s}=n,{skipEmpty:i}=a,o=t.readSync(r.dataId),l=t.readSync(s.dataId),[u,p,d]=G1(o,l[0],i),c=p.length,h=t.makeOutput([c,2],\"int32\");t.typedArrayFromHeap(h).set(u);let m=t.makeOutput([c],\"string\"),f=t.dataIdMap.get(m.dataId);f.stringBytes=p;let g=t.makeOutput([2],\"int32\");return t.typedArrayFromHeap(g).set(d),[h,m,g]}var Hme={kernelName:Yc,backendName:\"wasm\",kernelFunc:Gme};function jme(e){let{backend:t,inputs:n,attrs:a}=e,{input:r}=n,{numBuckets:s}=a,i=t.readSync(r.dataId),o=H1(i,s),l=t.makeOutput(r.shape,\"int32\");return t.typedArrayFromHeap(l).set(o),l}var qme={kernelName:Zc,backendName:\"wasm\",kernelFunc:jme},Kme=!0,Xme=Ut(Bo,Kme),D$;function Yme(e){D$=e.wasm.cwrap(Lo,null,[\"number\",\"number\",\"number\",\"number\"])}function Zme(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:d,originalAxes:c,inputWasTransposed:h}=Ds(i,r,t),m=d;if(h){let x=t.dataIdMap.get(p.dataId).id;x!==o&&(u=p,l=x,m=T.getInnerMostAxes(m.length,u.shape.length))}T.assertAxesAreInnerMostDims(\"sum\",m,u.shape.length);let[f,g]=T.computeOutAndReduceShapes(u.shape,m),b=w.sizeFromShape(g),y=t.makeOutput(f,u.dtype);if(w.sizeFromShape(u.shape)!==0){let x=t.dataIdMap.get(y.dataId).id;D$(l,b,Qe[y.dtype],x)}if(h&&t.disposeData(p.dataId),s){let x=T.expandShapeToKeepDim(y.shape,c);y.shape=x}return y}var Jme={kernelName:Lo,backendName:\"wasm\",setupFunc:Yme,kernelFunc:Zme},Qme=Xe(Vo),efe=Xe(Uo),R$;function tfe(e){R$=e.wasm.cwrap(Lu,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"array\",\"number\",\"number\",\"number\"])}function nfe(e){let{backend:t,inputs:n,attrs:a}=e,{tensor:r,indices:s,updates:i}=n,{}=a,o=t.makeOutput(r.shape,r.dtype);if(w.sizeFromShape(r.shape)===0)return o;let{sliceRank:l,numUpdates:u,sliceSize:p,strides:d,outputSize:c}=sf.calculateShapes(i,s,r.shape),h=t.dataIdMap.get(s.dataId).id,m=t.dataIdMap.get(i.dataId).id,f=t.dataIdMap.get(r.dataId).id,g=new Uint8Array(new Int32Array(d).buffer),b=t.dataIdMap.get(o.dataId).id;return R$(h,m,Qe[i.dtype],l,u,p,g,c,b,f),o}var afe={kernelName:Lu,backendName:\"wasm\",setupFunc:tfe,kernelFunc:nfe},M$;function rfe(e){M$=e.wasm.cwrap(ks,null,[\"number\",\"array\",\"number\",\"array\",\"number\",\"number\"])}function sfe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,s=n.dataIdMap.get(r.dataId).id,{reps:i}=a,o=new Array(r.shape.length);for(let c=0;c<o.length;c++)o[c]=r.shape[c]*i[c];let l=new Uint8Array(new Int32Array(r.shape).buffer),u=new Uint8Array(new Int32Array(o).buffer),p=n.makeOutput(o,r.dtype),d=n.dataIdMap.get(p.dataId).id;return M$(s,l,r.shape.length,u,o.length,Qe[p.dtype],d),p}var ife={kernelName:ks,backendName:\"wasm\",setupFunc:rfe,kernelFunc:sfe},O$;function ofe(e){O$=e.wasm.cwrap(qu,null,[\"number\",\"array\",\"number\",\"number\",\"number\",\"bool\",\"number\",\"number\"])}var lfe=({inputs:e,backend:t,attrs:n})=>{let{x:a}=e,{k:r,sorted:s}=n,i=t.dataIdMap.get(a.dataId).id,o=new Uint8Array(new Int32Array(a.shape).buffer),l=a.shape.slice();l[l.length-1]=r;let u=t.makeOutput(l,a.dtype),p=t.dataIdMap.get(u.dataId).id,d=t.makeOutput(l,\"int32\"),c=t.dataIdMap.get(d.dataId).id;return O$(i,o,a.shape.length,Qe[a.dtype],r,s,p,c),[u,d]},ufe={kernelName:qu,backendName:\"wasm\",setupFunc:ofe,kernelFunc:lfe},P$;function pfe(e){P$=e.wasm.cwrap(Ku,null,[\"number\",\"number\",\"bool\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"array\",\"number\",\"array\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function cfe(e){let{backend:t,inputs:n,attrs:a}=e,{image:r,transforms:s}=n,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=a,[p,d,c,h]=r.shape,[m,f]=u!=null?u:[d,c],g=[p,m,f,h],b=new Uint8Array(new Int32Array(w.computeStrides(r.shape)).buffer),y=new Uint8Array(new Int32Array(w.computeStrides(g)).buffer),x=t.makeOutput(g,r.dtype),v=t.dataIdMap.get(x.dataId).id,I=t.dataIdMap.get(r.dataId).id,N=t.dataIdMap.get(s.dataId).id,C=i===\"nearest\"?1:2,_;switch(o){case\"constant\":_=1;break;case\"reflect\":_=2;break;case\"wrap\":_=3;break;case\"nearest\":_=4;break;default:_=1;break}return P$(I,N,s.shape[0]>1,p,m,f,h,c,d,b,r.shape.length-1,y,g.length-1,C,_,l,v),x}var dfe={kernelName:Ku,backendName:\"wasm\",setupFunc:pfe,kernelFunc:cfe};function hfe(e){let{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t,{outputValues:i,outputShape:o,indices:l}=q1(a.readSync(s.dataId),r,s.shape,s.dtype);return[a.makeOutput(o,s.dtype,void 0,i),a.makeOutput([l.length],\"int32\",void 0,l)]}var mfe={kernelName:Jc,backendName:\"wasm\",kernelFunc:hfe};function ffe(e){let{inputs:t,backend:n,attrs:a}=e,{value:r}=t,{axis:s}=a;s<0&&(s+=r.shape.length);let i=r.shape[s],o=r.shape.length,l=new Array(o-1),u=0;for(let h=0;h<o;h++)h!==s&&(l[u++]=r.shape[h]);let p=new Array(i),d=new Array(o).fill(0),c=r.shape.slice();c[s]=1;for(let h=0;h<p.length;h++)d[s]=h,p[h]=Ii({inputs:{x:r},attrs:{begin:d,size:c},backend:n});return p.map(({dataId:h,dtype:m})=>({dataId:h,dtype:m,shape:l}))}var gfe={kernelName:Xu,backendName:\"wasm\",kernelFunc:ffe};function bfe(e){let{inputs:{x:t},backend:n}=e,a=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(a).fill(0),a}var yfe={kernelName:Yu,backendName:\"wasm\",kernelFunc:bfe},xfe=[eue,tue,nue,aue,sue,lue,gue,xue,vue,wue,kue,Iue,Sue,Nue,Tue,_ue,Lue,$ue,Mue,Vue,Kue,Zue,Que,tpe,npe,ape,ipe,ope,ppe,hpe,gpe,xpe,kpe,Ipe,Spe,Cpe,Ape,Dpe,Ope,zpe,Vpe,Hpe,Kpe,Zpe,ece,tce,rce,ice,oce,lce,uce,pce,cce,mce,fce,bce,vce,Ice,Tce,_ce,$ce,Rce,Oce,uue,Pce,Lce,zce,Vce,Gce,jce,Xce,Zce,Yce,Qce,ede,nde,rde,ode,pde,hde,fde,yde,wde,Sde,Cde,Ade,Dde,Ode,Lde,Bde,jde,qde,Xde,Yde,Qde,nhe,she,ohe,phe,dhe,mhe,d$,yhe,whe,She,The,Ehe,_he,Ahe,Fhe,zue,Rhe,Phe,Whe,Uhe,jhe,Xhe,Yhe,Zhe,eme,ame,ime,ome,pme,cme,dme,hme,jue,Ude,mme,gme,xme,kme,Sme,Tme,_me,Fme,$me,Dme,Mme,Lme,Bme,Ume,Hme,qme,Xme,Jme,Qme,efe,afe,ife,ufe,dfe,hue,mfe,gfe,yfe];for(let e of xfe)ed(e);var vv=G();vv.registerFlag(\"WASM_HAS_SIMD_SUPPORT\",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch(e){return!1}});vv.registerFlag(\"WASM_HAS_MULTITHREAD_SUPPORT\",async()=>{if(vv.get(\"IS_NODE\"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(e){return!1}});var TS=xs(VR()),vfe=xs(UR()),CS=xs(GR()),ES=TS.default||TS,wfe=CS.default||CS,L$=class extends Fc{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(z$),wv=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new ym(this,Ta())}write(e,t,n){let a={id:this.dataIdNextNumber++};return this.move(a,e,t,n,1),a}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=w.now();return e(),{kernelMs:w.now()-t}}move(e,t,n,a,r){let s=this.dataIdNextNumber++;if(a===\"string\"){let u=t;this.dataIdMap.set(e,{id:s,stringBytes:u,shape:n,dtype:a,memoryOffset:null,refCount:r});return}let i=w.sizeFromShape(n),o=i*w.bytesPerElement(a),l=this.wasm._malloc(o)>>>0;this.dataIdMap.set(e,{id:s,memoryOffset:l,shape:n,dtype:a,refCount:r}),this.wasm.tfjs.registerTensor(s,i,l),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),l)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:a,dtype:r,shape:s,stringBytes:i}=this.dataIdMap.get(e);if(r===\"string\")return(t==null||t===0)&&(n==null||n>=i.length)?i:i.slice(t,n);t=t||0,n=n||w.sizeFromShape(s);let o=w.bytesPerElement(r),l=this.wasm.HEAPU8.slice(a+t*o,a+n*o);return Sfe(l.buffer,r)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),\"PThread\"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,a){let r;if(n==null)r=this.write(a!=null?a:null,e,t);else{let s=this.dataIdNextNumber++;r={id:s},this.dataIdMap.set(r,{id:s,memoryOffset:n,shape:e,dtype:t,refCount:1});let i=w.sizeFromShape(e);this.wasm.tfjs.registerTensor(s,i,n)}return{dataId:r,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let a=this.wasm.HEAPU8.buffer,{memoryOffset:r}=this.dataIdMap.get(n),s=w.sizeFromShape(e);switch(t){case\"float32\":return new Float32Array(a,r,s);case\"int32\":return new Int32Array(a,r,s);case\"bool\":return new Uint8Array(a,r,s);default:throw new Error(`Unknown dtype ${t}`)}}};function kfe(e){return(t,n)=>(w.fetch(e,{credentials:\"same-origin\"}).then(a=>{a.ok||t.env.a(`failed to load wasm binary file at '${e}'`),a.arrayBuffer().then(r=>{WebAssembly.instantiate(r,t).then(s=>{n(s.instance,s.module)})})}),{})}function _S(e,t,n){if(gm!=null)return gm;let a=\"tfjs-backend-wasm.wasm\";return e&&t?a=\"tfjs-backend-wasm-threaded-simd.wasm\":e&&(a=\"tfjs-backend-wasm-simd.wasm\"),cc!=null&&cc[a]!=null?cc[a]:n+a}async function Ife(){let[e,t]=await Promise.all([G().getAsync(\"WASM_HAS_SIMD_SUPPORT\"),G().getAsync(\"WASM_HAS_MULTITHREAD_SUPPORT\")]);return new Promise((n,a)=>{let r={};r.locateFile=(o,l)=>{if(o.endsWith(\".worker.js\")){let u=vfe.wasmWorkerContents.replace(/\\n/g,\"\\\\n\"),p=new Blob([u],{type:\"application/javascript\"});return URL.createObjectURL(p)}return o.endsWith(\".wasm\")?_S(e,t,lc!=null?lc:l):l+o},mk&&(r.instantiateWasm=kfe(_S(e,t,lc!=null?lc:\"\")));let s=!1;r.onAbort=()=>{s||dc||(dc=!0,a({message:\"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers\"}))};let i;t&&e&&gm==null?(r.mainScriptUrlOrBlob=new Blob([\"var WasmBackendModuleThreadedSimd = \"+ES.toString()],{type:\"text/javascript\"}),i=ES(r)):i=wfe(r),i.then(o=>{s=!0,dc=!1;let l=null;o.tfjs={init:o.cwrap(\"init\",null,[]),initWithThreadsCount:o.cwrap(\"init_with_threads_count\",null,[\"number\"]),getThreadsCount:o.cwrap(\"get_threads_count\",\"number\",[]),registerTensor:o.cwrap(\"register_tensor\",null,[\"number\",\"number\",\"number\"]),disposeData:o.cwrap(\"dispose_data\",l,[\"number\"]),dispose:o.cwrap(\"dispose\",l,[])},n({wasm:o})}).catch(a)})}function Sfe(e,t){switch(t){case\"float32\":return new Float32Array(e);case\"int32\":return new Int32Array(e);case\"bool\":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var Nfe=[\"tfjs-backend-wasm.wasm\",\"tfjs-backend-wasm-simd.wasm\",\"tfjs-backend-wasm-threaded-simd.wasm\"],gm=null,lc=null,cc={},dc=!1,mk=!1;function Tfe(e,t=!1){if($v(\"setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release.\"),dc)throw new Error(\"The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`\");gm=e,mk=t}function Cfe(e,t=!1){if(dc)throw new Error(\"The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`\");if(typeof e==\"string\")lc=e;else{cc=e;let n=Nfe.filter(a=>cc[a]==null);if(n.length>0)throw new Error(`There were no entries found for the following binaries: ${n.join(\",\")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}mk=t}var z$=-1,wv=-1;function Efe(e){z$=e}function _fe(){if(wv===-1)throw new Error(\"WASM backend not initialized.\");return wv}var Afe=\"4.22.0\",Ffe=2;Om(\"wasm\",async()=>{let{wasm:e}=await Ife();return new L$(e)},Ffe);var AS=\"4.22.0\",$fe=\"4.22.0\",Dfe=\"4.22.0\",Rfe=\"4.22.0\",Mfe=\"4.22.0\",Ofe={tfjs:AS,\"tfjs-core\":AS,\"tfjs-converter\":$fe,\"tfjs-backend-cpu\":Dfe,\"tfjs-backend-webgl\":Rfe,\"tfjs-backend-wasm\":Mfe};var iD={};ax(iD,{AnchorPosition:()=>Ik,DrawBox:()=>Od,DrawBoxOptions:()=>Xf,DrawFaceLandmarks:()=>og,DrawFaceLandmarksOptions:()=>ig,DrawTextField:()=>sl,DrawTextFieldOptions:()=>Ip,drawContour:()=>Pr,drawDetections:()=>Ufe,drawFaceExpressions:()=>Gfe,drawFaceLandmarks:()=>jfe});function Pr(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach(({x:a,y:r},s)=>{let i=t[s];e.moveTo(i.x,i.y),e.lineTo(a,r)}),n){let a=t[t.length-1],r=t[0];if(!a||!r)return;e.moveTo(a.x,a.y),e.lineTo(r.x,r.y)}e.stroke()}var W$={};ax(W$,{computeReshapedDimensions:()=>bk,getCenterPoint:()=>al,isDimensions:()=>jf,isEven:()=>Hf,isFloat:()=>gk,isTensor:()=>tl,isTensor1D:()=>Pfe,isTensor2D:()=>fk,isTensor3D:()=>Lr,isTensor4D:()=>wa,isValidNumber:()=>Xa,isValidProbablitiy:()=>gp,range:()=>gr,round:()=>nl});var aa=class e{constructor(t,n){if(!Xa(t)||!Xa(n))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:t,height:n})}`);this._width=t,this._height=n}get width(){return this._width}get height(){return this._height}reverse(){return new e(1/this.width,1/this.height)}};function tl(e,t){return e instanceof Ce&&e.shape.length===t}function Pfe(e){return tl(e,1)}function fk(e){return tl(e,2)}function Lr(e){return tl(e,3)}function wa(e){return tl(e,4)}function gk(e){return e%1!==0}function Hf(e){return e%2===0}function nl(e,t=2){let n=10**t;return Math.floor(e*n)/n}function jf(e){return e&&e.width&&e.height}function bk({width:e,height:t},n){let a=n/Math.max(t,e);return new aa(Math.round(e*a),Math.round(t*a))}function al(e){return e.reduce((t,n)=>t.add(n),new He(0,0)).div(new He(e.length,e.length))}function gr(e,t,n){return Array(e).fill(0).map((a,r)=>t+r*n)}function Xa(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||e===0}function gp(e){return Xa(e)&&e>=0&&e<=1}var He=class e{constructor(t,n){this._x=t,this._y=n}get x(){return this._x}get y(){return this._y}add(t){return new e(this.x+t.x,this.y+t.y)}sub(t){return new e(this.x-t.x,this.y-t.y)}mul(t){return new e(this.x*t.x,this.y*t.y)}div(t){return new e(this.x/t.x,this.y/t.y)}abs(){return new e(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new e(Math.floor(this.x),Math.floor(this.y))}};var mn=class e{static isRect(t){return!!t&&[t.x,t.y,t.width,t.height].every(Xa)}static assertIsValidBox(t,n,a=!1){if(!e.isRect(t))throw new Error(`${n} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!a&&(t.width<0||t.height<0))throw new Error(`${n} - width (${t.width}) and height (${t.height}) must be positive numbers`)}constructor(t,n=!0){let a=t||{},r=[a.left,a.top,a.right,a.bottom].every(Xa),s=[a.x,a.y,a.width,a.height].every(Xa);if(!s&&!r)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(a)}`);let[i,o,l,u]=s?[a.x,a.y,a.width,a.height]:[a.left,a.top,a.right-a.left,a.bottom-a.top];e.assertIsValidBox({x:i,y:o,width:l,height:u},\"Box.constructor\",n),this._x=i,this._y=o,this._width=l,this._height=u}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new He(this.left,this.top)}get topRight(){return new He(this.right,this.top)}get bottomLeft(){return new He(this.left,this.bottom)}get bottomRight(){return new He(this.right,this.bottom)}round(){let[t,n,a,r]=[this.x,this.y,this.width,this.height].map(s=>Math.round(s));return new e({x:t,y:n,width:a,height:r})}floor(){let[t,n,a,r]=[this.x,this.y,this.width,this.height].map(s=>Math.floor(s));return new e({x:t,y:n,width:a,height:r})}toSquare(){let{x:t,y:n,width:a,height:r}=this,s=Math.abs(a-r);return a<r&&(t-=s/2,a+=s),r<a&&(n-=s/2,r+=s),new e({x:t,y:n,width:a,height:r})}rescale(t){let n=jf(t)?t.width:t,a=jf(t)?t.height:t;return new e({x:this.x*n,y:this.y*a,width:this.width*n,height:this.height*a})}pad(t,n){let[a,r,s,i]=[this.x-t/2,this.y-n/2,this.width+t,this.height+n];return new e({x:a,y:r,width:s,height:i})}clipAtImageBorders(t,n){let{x:a,y:r,right:s,bottom:i}=this,o=Math.max(a,0),l=Math.max(r,0),u=s-o,p=i-l,d=Math.min(u,t-o),c=Math.min(p,n-l);return new e({x:o,y:l,width:d,height:c}).floor()}shift(t,n){let{width:a,height:r}=this,s=this.x+t,i=this.y+n;return new e({x:s,y:i,width:a,height:r})}padAtBorders(t,n){let a=this.width+1,r=this.height+1,s=1,i=1,o=a,l=r,u=this.left,p=this.top,d=this.right,c=this.bottom;return d>n&&(o=-d+n+a,d=n),c>t&&(l=-c+t+r,c=t),u<1&&(l=2-u,u=1),p<1&&(l=2-p,p=1),{dy:i,edy:l,dx:s,edx:o,y:p,ey:c,x:u,ex:d,w:a,h:r}}calibrate(t){return new e({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}};var bp=class extends mn{constructor(t,n,a,r,s=!1){super({left:t,top:n,right:a,bottom:r},s)}};var yp=class e{constructor(t,n,a,r,s){this._imageDims=new aa(s.width,s.height),this._score=t,this._classScore=n,this._className=a,this._box=new mn(r).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new mn(this._box).rescale(this.imageDims.reverse())}forSize(t,n){return new e(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:n})}};var Ft=class e extends yp{constructor(t,n,a){super(t,t,\"\",n,a)}forSize(t,n){let{score:a,relativeBox:r,imageDims:s}=super.forSize(t,n);return new e(a,r,s)}};function B$(e,t,n=!0){let a=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left)),r=Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top)),s=a*r;return n?s/(e.area+t.area-s):s/Math.min(e.area,t.area)}function V$(e){let t=e.map(o=>o.x),n=e.map(o=>o.y),a=t.reduce((o,l)=>l<o?l:o,1/0),r=n.reduce((o,l)=>l<o?l:o,1/0),s=t.reduce((o,l)=>o<l?l:o,0),i=n.reduce((o,l)=>o<l?l:o,0);return new bp(a,r,s,i)}function U$(e,t,n,a=!0){let r=t.map((i,o)=>({score:i,boxIndex:o})).sort((i,o)=>i.score-o.score).map(i=>i.boxIndex),s=[];for(;r.length>0;){let i=r.pop();s.push(i);let o=r,l=[];for(let u=0;u<o.length;u++){let p=o[u],d=e[i],c=e[p];l.push(B$(d,c,a))}r=r.filter((u,p)=>l[p]<=n)}return s}function br(e,t){return O(()=>{let[n,a,r]=t,s=yn([...e.shape.slice(0,3),1],n,\"float32\"),i=yn([...e.shape.slice(0,3),1],a,\"float32\"),o=yn([...e.shape.slice(0,3),1],r,\"float32\"),l=et([s,i,o],3);return pe(e,l)})}function G$(e,t=!1){return O(()=>{let[n,a]=e.shape.slice(1);if(n===a)return e;let r=Math.abs(n-a),s=Math.round(r*(t?.5:1)),i=n>a?2:1,o=c=>{let h=e.shape.slice();return h[i]=c,yn(h,0,\"float32\")},l=o(s),u=r-l.shape[i],d=[t&&u?o(u):null,e,l].filter(c=>!!c).map(c=>re(c,\"float32\"));return et(d,i)})}function y0e(e){let t=e.slice();for(let n=t.length-1;n>0;n--){let a=Math.floor(Math.random()*(n+1)),r=t[n];t[n]=t[a],t[a]=r}return t}function qf(e){return 1/(1+Math.exp(-e))}function v0e(e){return Math.log(e/(1-e))}var xp=class extends mn{constructor(t,n,a,r,s=!1){super({x:t,y:n,width:a,height:r},s)}};var Lfe=.5,zfe=.43,Wfe=.45,ka=class{constructor(t,n,a=new He(0,0)){let{width:r,height:s}=n;this._imgDims=new aa(r,s),this._shift=a,this._positions=t.map(i=>i.mul(new He(r,s)).add(a))}get shift(){return new He(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(t=>t.sub(this._shift).div(new He(this.imageWidth,this.imageHeight)))}forSize(t,n){return new this.constructor(this.relativePositions,{width:t,height:n})}shiftBy(t,n){return new this.constructor(this.relativePositions,this._imgDims,new He(t,n))}shiftByPoint(t){return this.shiftBy(t.x,t.y)}align(t,n={}){if(t){let s=t instanceof Ft?t.box.floor():new mn(t);return this.shiftBy(s.x,s.y).align(null,n)}let{useDlibAlignment:a,minBoxPadding:r}={useDlibAlignment:!1,minBoxPadding:.2,...n};return a?this.alignDlib():this.alignMinBbox(r)}alignDlib(){let t=this.getRefPointsForAlignment(),[n,a,r]=t,s=d=>r.sub(d).magnitude(),i=(s(n)+s(a))/2,o=Math.floor(i/Wfe),l=al(t),u=Math.floor(Math.max(0,l.x-Lfe*o)),p=Math.floor(Math.max(0,l.y-zfe*o));return new xp(u,p,Math.min(o,this.imageWidth+u),Math.min(o,this.imageHeight+p))}alignMinBbox(t){let n=V$(this.positions);return n.pad(n.width*t,n.height*t)}getRefPointsForAlignment(){throw new Error(\"getRefPointsForAlignment not implemented by base class\")}};var H$=class extends ka{getRefPointsForAlignment(){let t=this.positions;return[t[0],t[1],al([t[3],t[4]])]}};var vp=class extends ka{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(al)}};var Dd=class{constructor(t,n){this._label=t,this._distance=n}get label(){return this._label}get distance(){return this._distance}toString(t=!0){return`${this.label}${t?` (${nl(this.distance)})`:\"\"}`}};var Rd=class extends mn{static assertIsValidLabeledBox(t,n){if(mn.assertIsValidBox(t,n),!Xa(t.label))throw new Error(`${n} - expected property label (${t.label}) to be a number`)}constructor(t,n){super(t),this._label=n}get label(){return this._label}};var rl=class e{constructor(t,n){if(typeof t!=\"string\")throw new Error(\"LabeledFaceDescriptors - constructor expected label to be a string\");if(!Array.isArray(n)||n.some(a=>!(a instanceof Float32Array)))throw new Error(\"LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array\");this._label=t,this._descriptors=n}get label(){return this._label}get descriptors(){return this._descriptors}toJSON(){return{label:this.label,descriptors:this.descriptors.map(t=>Array.from(t))}}static fromJSON(t){let n=t.descriptors.map(a=>new Float32Array(a));return new e(t.label,n)}};var j$=class extends Rd{static assertIsValidPredictedBox(t,n){if(Rd.assertIsValidLabeledBox(t,n),!gp(t.score)||!gp(t.classScore))throw new Error(`${n} - expected properties score (${t.score}) and (${t.classScore}) to be a number between [0, 1]`)}constructor(t,n,a,r){super(t,n),this._score=a,this._classScore=r}get score(){return this._score}get classScore(){return this._classScore}};function zr(e){return e.detection instanceof Ft}function wp(e,t){return{...e,...{detection:t}}}function yk(){let e=window.fetch;if(!e)throw new Error(\"fetch - missing fetch implementation for browser environment\");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement(\"canvas\"),createImageElement:()=>document.createElement(\"img\"),createVideoElement:()=>document.createElement(\"video\"),fetch:e,readFile:()=>{throw new Error(\"readFile - filesystem not available for browser environment\")}}}function Md(){return typeof __webpack_require__.g==\"object\"&&typeof process!=\"undefined\"&&process.versions!=null&&process.versions.node!=null}function Kf(e){let t=\"\";if(!e&&Md())try{e=wR(\"fs\")}catch(a){t=a.toString()}return{readFile:e?a=>new Promise((r,s)=>{e.readFile(a,(i,o)=>i?s(i):r(o))}):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function xk(){let e=__webpack_require__.g.Canvas||__webpack_require__.g.HTMLCanvasElement,t=__webpack_require__.g.Image||__webpack_require__.g.HTMLImageElement,n=__webpack_require__.g.Video||__webpack_require__.g.HTMLVideoElement,a=()=>{if(e)return new e;throw new Error(\"createCanvasElement - missing Canvas implementation for nodejs environment\")},r=()=>{if(t)return new t;throw new Error(\"createImageElement - missing Image implementation for nodejs environment\")},s=()=>{if(n)return new n;throw new Error(\"createVideoElement - missing Video implementation for nodejs environment\")},i=__webpack_require__.g.fetch,o=Kf();return{Canvas:e||class{},CanvasRenderingContext2D:__webpack_require__.g.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:__webpack_require__.g.ImageData||class{},Video:__webpack_require__.g.HTMLVideoElement||class{},createCanvasElement:a,createImageElement:r,createVideoElement:s,fetch:i,...o}}function vk(){return typeof window==\"object\"&&typeof document!=\"undefined\"&&typeof HTMLImageElement!=\"undefined\"&&typeof HTMLCanvasElement!=\"undefined\"&&typeof HTMLVideoElement!=\"undefined\"&&typeof ImageData!=\"undefined\"&&typeof CanvasRenderingContext2D!=\"undefined\"}var ln;function Bfe(){if(!ln)throw new Error(\"getEnv - environment is not defined, check isNodejs() and isBrowser()\");return ln}function wk(e){ln=e}function kk(){return vk()?wk(yk()):Md()?wk(xk()):null}function Vfe(e){if(ln||kk(),!ln)throw new Error(\"monkeyPatch - environment is not defined, check isNodejs() and isBrowser()\");let{Canvas:t=ln.Canvas,Image:n=ln.Image}=e;ln.Canvas=t,ln.Image=n,ln.createCanvasElement=e.createCanvasElement||(()=>new t),ln.createImageElement=e.createImageElement||(()=>new n),ln.ImageData=e.ImageData||ln.ImageData,ln.Video=e.Video||ln.Video,ln.fetch=e.fetch||ln.fetch,ln.readFile=e.readFile||ln.readFile}var at={getEnv:Bfe,setEnv:wk,initialize:kk,createBrowserEnv:yk,createFileSystem:Kf,createNodejsEnv:xk,monkeyPatch:Vfe,isBrowser:vk,isNodejs:Md};kk();function kp(e){return!at.isNodejs()&&typeof e==\"string\"?document.getElementById(e):e}function ra(e){let{Canvas:t,CanvasRenderingContext2D:n}=at.getEnv();if(e instanceof n)return e;let a=kp(e);if(!(a instanceof t))throw new Error(\"resolveContext2d - expected canvas to be of instance of Canvas\");let r=a.getContext(\"2d\",{willReadFrequently:!0});if(!r)throw new Error(\"resolveContext2d - canvas 2d context is null\");return r}var Ik=(r=>(r.TOP_LEFT=\"TOP_LEFT\",r.TOP_RIGHT=\"TOP_RIGHT\",r.BOTTOM_LEFT=\"BOTTOM_LEFT\",r.BOTTOM_RIGHT=\"BOTTOM_RIGHT\",r))(Ik||{}),Ip=class{constructor(t={}){let{anchorPosition:n,backgroundColor:a,fontColor:r,fontSize:s,fontStyle:i,padding:o}=t;this.anchorPosition=n||\"TOP_LEFT\",this.backgroundColor=a||\"rgba(0, 0, 0, 0.5)\",this.fontColor=r||\"rgba(255, 255, 255, 1)\",this.fontSize=s||14,this.fontStyle=i||\"Georgia\",this.padding=o||4}},sl=class e{constructor(t,n,a={}){this.text=typeof t==\"string\"?[t]:t instanceof e?t.text:t,this.anchor=n,this.options=new Ip(a)}measureWidth(t){let{padding:n}=this.options;return this.text.map(a=>t.measureText(a).width).reduce((a,r)=>a<r?r:a,0)+2*n}measureHeight(){let{fontSize:t,padding:n}=this.options;return this.text.length*t+2*n}getUpperLeft(t,n){let{anchorPosition:a}=this.options,r=a===\"BOTTOM_RIGHT\"||a===\"TOP_RIGHT\",s=a===\"BOTTOM_LEFT\"||a===\"BOTTOM_RIGHT\",i=this.measureWidth(t),o=this.measureHeight(),l=r?this.anchor.x-i:this.anchor.x,u=s?this.anchor.y-o:this.anchor.y;if(n){let{width:p,height:d}=n,c=Math.max(Math.min(l,p-i),0),h=Math.max(Math.min(u,d-o),0);return{x:c,y:h}}return{x:l,y:u}}draw(t){let n=kp(t),a=ra(n),{backgroundColor:r,fontColor:s,fontSize:i,fontStyle:o,padding:l}=this.options;a.font=`${i}px ${o}`;let u=this.measureWidth(a),p=this.measureHeight();a.fillStyle=r;let d=this.getUpperLeft(a,n);a.fillRect(d.x,d.y,u,p),a.fillStyle=s,this.text.forEach((c,h)=>{let m=l+d.x,f=l+d.y+(h+1)*i;a.fillText(c,m,f)})}};var Xf=class{constructor(t={}){let{boxColor:n,lineWidth:a,label:r,drawLabelOptions:s}=t;this.boxColor=n||\"rgba(0, 0, 255, 1)\",this.lineWidth=a||2,this.label=r;let i={anchorPosition:\"BOTTOM_LEFT\",backgroundColor:this.boxColor};this.drawLabelOptions=new Ip({...i,...s})}},Od=class{constructor(t,n={}){this.box=new mn(t),this.options=new Xf(n)}draw(t){let n=ra(t),{boxColor:a,lineWidth:r}=this.options,{x:s,y:i,width:o,height:l}=this.box;n.strokeStyle=a,n.lineWidth=r,n.strokeRect(s,i,o,l);let{label:u}=this.options;u&&new sl([u],{x:s-r/2,y:i},this.options.drawLabelOptions).draw(t)}};function Ufe(e,t){(Array.isArray(t)?t:[t]).forEach(a=>{let r=a instanceof Ft?a.score:zr(a)?a.detection.score:void 0,s=a instanceof Ft?a.box:zr(a)?a.detection.box:new mn(a),i=r?`${nl(r)}`:void 0;new Od(s,{label:i}).draw(e)})}function Yf(e){let{Image:t,Video:n}=at.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function q$(e){return new Promise((t,n)=>{if(e instanceof at.getEnv().Canvas||Yf(e)){t(null);return}function a(s){s.currentTarget&&(s.currentTarget.removeEventListener(\"load\",r),s.currentTarget.removeEventListener(\"error\",a),n(s))}function r(s){s.currentTarget&&(s.currentTarget.removeEventListener(\"load\",r),s.currentTarget.removeEventListener(\"error\",a),t(s))}e.addEventListener(\"load\",r),e.addEventListener(\"error\",a)})}function K$(e){return new Promise((t,n)=>{e instanceof Blob||n(new Error(\"bufferToImage - expected buf to be of type: Blob\"));let a=new FileReader;a.onload=()=>{typeof a.result!=\"string\"&&n(new Error(\"bufferToImage - expected reader.result to be a string, in onload\"));let r=at.getEnv().createImageElement();r.onload=()=>t(r),r.onerror=n,r.src=a.result},a.onerror=n,a.readAsDataURL(e)})}function Sp(e){let{Image:t,Video:n}=at.getEnv();return e instanceof t?new aa(e.naturalWidth,e.naturalHeight):e instanceof n?new aa(e.videoWidth,e.videoHeight):new aa(e.width,e.height)}function Np({width:e,height:t}){let{createCanvasElement:n}=at.getEnv(),a=n();return a.width=e,a.height=t,a}function Zf(e,t){let{ImageData:n}=at.getEnv();if(!(e instanceof n)&&!Yf(e))throw new Error(\"createCanvasFromMedia - media has not finished loading yet\");let{width:a,height:r}=t||Sp(e),s=Np({width:a,height:r});return e instanceof n?ra(s).putImageData(e,0,0):ra(s).drawImage(e,0,0,a,r),s}async function X$(e,t){let n=t||at.getEnv().createCanvasElement(),[a,r,s]=e.shape.slice(wa(e)?1:0),i=O(()=>e.as3D(a,r,s).toInt());return await qo.toPixels(i,n),i.dispose(),n}function Sk(e){let{Image:t,Canvas:n,Video:a}=at.getEnv();return e instanceof t||e instanceof n||e instanceof a}function Y$(e,t,n=!1){let{Image:a,Canvas:r}=at.getEnv();if(!(e instanceof a||e instanceof r))throw new Error(\"imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement\");if(t<=0)return Np({width:1,height:1});let s=Sp(e),i=t/Math.max(s.height,s.width),o=i*s.width,l=i*s.height,u=Np({width:t,height:t}),p=e instanceof r?e:Zf(e),d=Math.abs(o-l)/2,c=n&&o<l?d:0,h=n&&l<o?d:0;return p.width>0&&p.height>0&&ra(u).drawImage(p,c,h,o,l),u}var Wr=class{constructor(t,n=!1){this._imageTensors=[];this._canvases=[];this._treatAsBatchInput=!1;this._inputDimensions=[];this._inputSize=0;if(!Array.isArray(t))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${t}`);this._treatAsBatchInput=n,this._batchSize=t.length,t.forEach((a,r)=>{if(Lr(a)){this._imageTensors[r]=a,this._inputDimensions[r]=a.shape;return}if(wa(a)){let i=a.shape[0];if(i!==1)throw new Error(`NetInput - tf.Tensor4D with batchSize ${i} passed, but not supported in input array`);this._imageTensors[r]=a,this._inputDimensions[r]=a.shape.slice(1);return}let s=a instanceof at.getEnv().Canvas?a:Zf(a);this._canvases[r]=s,this._inputDimensions[r]=[s.height,s.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return gr(this.batchSize,0,1).map((t,n)=>this.getReshapedInputDimensions(n))}getInput(t){return this.canvases[t]||this.imageTensors[t]}getInputDimensions(t){return this._inputDimensions[t]}getInputHeight(t){return this._inputDimensions[t][0]}getInputWidth(t){return this._inputDimensions[t][1]}getReshapedInputDimensions(t){if(typeof this.inputSize!=\"number\")throw new Error(\"getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet\");let n=this.getInputWidth(t),a=this.getInputHeight(t);return bk({width:n,height:a},this.inputSize)}toBatchTensor(t,n=!0){return this._inputSize=t,O(()=>{let a=gr(this.batchSize,0,1).map(s=>{let i=this.getInput(s);if(i instanceof Ce){let o=wa(i)?i:Gt(i);return o=G$(o,n),(o.shape[1]!==t||o.shape[2]!==t)&&(o=Zn.resizeBilinear(o,[t,t],!1,!1)),o.as3D(t,t,3)}if(i instanceof at.getEnv().Canvas)return qo.fromPixels(Y$(i,t,n));throw new Error(`toBatchTensor - at batchIdx ${s}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${i}`)});return At(a.map(s=>re(s,\"float32\"))).as4D(this.batchSize,t,t,3)})}};async function vt(e){if(e instanceof Wr)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error(\"toNetInput - empty array passed as input\");let n=r=>Array.isArray(e)?` at input index ${r}:`:\"\",a=t.map(kp);return a.forEach((r,s)=>{if(!Sk(r)&&!Lr(r)&&!wa(r))throw typeof t[s]==\"string\"?new Error(`toNetInput -${n(s)} string passed, but could not resolve HTMLElement for element id ${t[s]}`):new Error(`toNetInput -${n(s)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(wa(r)){let i=r.shape[0];if(i!==1)throw new Error(`toNetInput -${n(s)} tf.Tensor4D with batchSize ${i} passed, but not supported in input array`)}}),await Promise.all(a.map(r=>Sk(r)&&q$(r))),new Wr(a,Array.isArray(e))}async function Pd(e,t){let{Canvas:n}=at.getEnv(),a=e;if(!(e instanceof n)){let i=await vt(e);if(i.batchSize>1)throw new Error(\"extractFaces - batchSize > 1 not supported\");let o=i.getInput(0);a=o instanceof n?o:await X$(o)}let r=ra(a);return t.map(i=>i instanceof Ft?i.forSize(a.width,a.height).box.floor():i).map(i=>i.clipAtImageBorders(a.width,a.height)).map(({x:i,y:o,width:l,height:u})=>{let p=Np({width:l,height:u});return l>0&&u>0&&ra(p).putImageData(r.getImageData(i,o,l,u),0,0),p})}async function Ld(e,t){if(!Lr(e)&&!wa(e))throw new Error(\"extractFaceTensors - expected image tensor to be 3D or 4D\");if(wa(e)&&e.shape[0]>1)throw new Error(\"extractFaceTensors - batchSize > 1 not supported\");return O(()=>{let[n,a,r]=e.shape.slice(wa(e)?1:0);return t.map(o=>o instanceof Ft?o.forSize(a,n).box:o).map(o=>o.clipAtImageBorders(a,n)).filter(o=>o.width>0&&o.height>0).map(({x:o,y:l,width:u,height:p})=>Ho(e.as3D(n,a,r),[l,o,0],[p,u,r]))})}async function Ms(e,t){let{fetch:n}=at.getEnv(),a=await n(e,t);if(!(a.status<400))throw new Error(`failed to fetch: (${a.status}) ${a.statusText}, from url: ${a.url}`);return a}async function sIe(e){let t=await Ms(e),n=await t.blob();if(!n.type.startsWith(\"image/\"))throw new Error(`fetchImage - expected blob type to be of type image/*, instead have: ${n.type}, for url: ${t.url}`);return K$(n)}async function Z$(e){return(await Ms(e)).json()}async function pIe(e){return new Float32Array(await(await Ms(e)).arrayBuffer())}function J$(e){return new Promise((t,n)=>{e instanceof Blob||n(new Error(\"bufferToVideo - expected buf to be of type: Blob\"));let a=at.getEnv().createVideoElement();a.oncanplay=()=>t(a),a.onerror=n,a.playsInline=!0,a.muted=!0,a.src=URL.createObjectURL(e),a.play()})}async function gIe(e){let t=await Ms(e),n=await t.blob();if(!n.type.startsWith(\"video/\"))throw new Error(`fetchVideo - expected blob type to be of type video/*, instead have: ${n.type}, for url: ${t.url}`);return J$(n)}function Jf(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:\"\",manifestUri:n};if(e===\"/\")return{modelBaseUri:\"/\",manifestUri:`/${n}`};let a=e.startsWith(\"http://\")?\"http://\":e.startsWith(\"https://\")?\"https://\":\"\";e=e.replace(a,\"\");let r=e.split(\"/\").filter(o=>o),s=e.endsWith(\".json\")?r[r.length-1]:n,i=a+(e.endsWith(\".json\")?r.slice(0,r.length-1):r).join(\"/\");return i=e.startsWith(\"/\")?`/${i}`:i,{modelBaseUri:i,manifestUri:i===\"/\"?`/${s}`:`${i}/${s}`}}async function Q$(e,t){let{manifestUri:n,modelBaseUri:a}=Jf(e,t),r=await Z$(n);return jt.loadWeights(r,a)}function IIe(e,t,n=!1){let{width:a,height:r}=n?Sp(t):t;return e.width=a,e.height=r,{width:a,height:r}}var fn=class{constructor(t){this._params=void 0;this._paramMappings=[];this._name=t}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(t){let{obj:n,objProp:a}=this.traversePropertyPath(t);return n[a]}reassignParamFromPath(t,n){let{obj:a,objProp:r}=this.traversePropertyPath(t);a[r].dispose(),a[r]=n}getParamList(){return this._paramMappings.map(({paramPath:t})=>({path:t,tensor:this.getParamFromPath(t)}))}getTrainableParams(){return this.getParamList().filter(t=>t.tensor instanceof os)}getFrozenParams(){return this.getParamList().filter(t=>!(t.tensor instanceof os))}variable(){this.getFrozenParams().forEach(({path:t,tensor:n})=>{this.reassignParamFromPath(t,n.variable())})}freeze(){this.getTrainableParams().forEach(({path:t,tensor:n})=>{let a=bn(n.dataSync());n.dispose(),this.reassignParamFromPath(t,a)})}dispose(t=!0){this.getParamList().forEach(n=>{if(t&&n.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${n.path}`);n.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(({tensor:t})=>Array.from(t.dataSync())).reduce((t,n)=>t.concat(n)))}async load(t){if(t instanceof Float32Array){this.extractWeights(t);return}await this.loadFromUri(t)}async loadFromUri(t){if(t&&typeof t!=\"string\")throw new Error(`${this._name}.loadFromUri - expected model uri`);let n=await Q$(t,this.getDefaultModelName());this.loadFromWeightMap(n)}async loadFromDisk(t){if(t&&typeof t!=\"string\")throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:n}=at.getEnv(),{manifestUri:a,modelBaseUri:r}=Jf(t,this.getDefaultModelName()),s=u=>Promise.all(u.map(p=>n(p).then(d=>typeof d==\"string\"?Buffer.from(d):d.buffer))),i=jt.weightsLoaderFactory(s),o=JSON.parse((await n(a)).toString()),l=await i(o,r);this.loadFromWeightMap(l)}loadFromWeightMap(t){let{paramMappings:n,params:a}=this.extractParamsFromWeightMap(t);this._paramMappings=n,this._params=a}extractWeights(t){let{paramMappings:n,params:a}=this.extractParams(t);this._paramMappings=n,this._params=a}traversePropertyPath(t){if(!this.params)throw new Error(\"traversePropertyPath - model has no loaded params\");let n=t.split(\"/\").reduce((s,i)=>{if(!s.nextObj.hasOwnProperty(i))throw new Error(`traversePropertyPath - object does not have property ${i}, for path ${t}`);return{obj:s.nextObj,objProp:i,nextObj:s.nextObj[i]}},{nextObj:this.params}),{obj:a,objProp:r}=n;if(!a||!r||!(a[r]instanceof Ce))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${t}`);return{obj:a,objProp:r}}};function Un(e,t,n){return O(()=>{let a=_s(e,t.depthwise_filter,t.pointwise_filter,n,\"same\");return a=X(a,t.bias),a})}function Qf(e,t,n=!1){return O(()=>{let a=Ke(n?X($t(e,t.conv0.filters,[2,2],\"same\"),t.conv0.bias):Un(e,t.conv0,[2,2])),r=Un(a,t.conv1,[1,1]),s=Ke(X(a,r)),i=Un(s,t.conv2,[1,1]);return Ke(X(a,X(r,i)))})}function zd(e,t,n=!1,a=!0){return O(()=>{let r=Ke(n?X($t(e,t.conv0.filters,a?[2,2]:[1,1],\"same\"),t.conv0.bias):Un(e,t.conv0,a?[2,2]:[1,1])),s=Un(r,t.conv1,[1,1]),i=Ke(X(r,s)),o=Un(i,t.conv2,[1,1]),l=Ke(X(r,X(s,o))),u=Un(l,t.conv3,[1,1]);return Ke(X(r,X(s,X(o,u))))})}function il(e,t,n=\"same\",a=!1){return O(()=>{let r=X($t(e,t.filters,[1,1],n),t.bias);return a?Ke(r):r})}function _n(e,t){Object.keys(e).forEach(n=>{t.some(a=>a.originalPath===n)||e[n].dispose()})}function Tp(e,t){return(n,a,r,s)=>{let i=Fa(e(n*a*r*r),[r,r,n,a]),o=je(e(a));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:i,bias:o}}}function eg(e,t){return(n,a,r)=>{let s=Ea(e(n*a),[n,a]),i=je(e(a));return t.push({paramPath:`${r}/weights`},{paramPath:`${r}/bias`}),{weights:s,bias:i}}}var Wd=class{constructor(t,n,a){this.depthwise_filter=t;this.pointwise_filter=n;this.bias=a}};function Cp(e,t){return(n,a,r)=>{let s=Fa(e(9*n),[3,3,n,1]),i=Fa(e(n*a),[1,1,n,a]),o=je(e(a));return t.push({paramPath:`${r}/depthwise_filter`},{paramPath:`${r}/pointwise_filter`},{paramPath:`${r}/bias`}),new Wd(s,i,o)}}function Ep(e){return t=>{let n=e(`${t}/depthwise_filter`,4),a=e(`${t}/pointwise_filter`,4),r=e(`${t}/bias`,1);return new Wd(n,a,r)}}function sa(e,t){return(n,a,r)=>{let s=e[n];if(!tl(s,a))throw new Error(`expected weightMap[${n}] to be a Tensor${a}D, instead have ${s}`);return t.push({originalPath:n,paramPath:r||n}),s}}function An(e){let t=e;function n(r){let s=t.slice(0,r);return t=t.slice(r),s}function a(){return t}return{extractWeights:n,getRemainingWeights:a}}function tg(e,t){let n=Tp(e,t),a=Cp(e,t);function r(i,o,l,u=!1){let p=u?n(i,o,3,`${l}/conv0`):a(i,o,`${l}/conv0`),d=a(o,o,`${l}/conv1`),c=a(o,o,`${l}/conv2`);return{conv0:p,conv1:d,conv2:c}}function s(i,o,l,u=!1){let{conv0:p,conv1:d,conv2:c}=r(i,o,l,u),h=a(o,o,`${l}/conv3`);return{conv0:p,conv1:d,conv2:c,conv3:h}}return{extractDenseBlock3Params:r,extractDenseBlock4Params:s}}function eD(e){let t=[],{extractWeights:n,getRemainingWeights:a}=An(e),{extractDenseBlock4Params:r}=tg(n,t),s=r(3,32,\"dense0\",!0),i=r(32,64,\"dense1\"),o=r(64,128,\"dense2\"),l=r(128,256,\"dense3\");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o,dense3:l}}}function ng(e){return t=>{let n=e(`${t}/filters`,4),a=e(`${t}/bias`,1);return{filters:n,bias:a}}}function ag(e,t){let n=sa(e,t),a=ng(n),r=Ep(n);function s(o,l=!1){let u=l?a(`${o}/conv0`):r(`${o}/conv0`),p=r(`${o}/conv1`),d=r(`${o}/conv2`);return{conv0:u,conv1:p,conv2:d}}function i(o,l=!1){let u=l?a(`${o}/conv0`):r(`${o}/conv0`),p=r(`${o}/conv1`),d=r(`${o}/conv2`),c=r(`${o}/conv3`);return{conv0:u,conv1:p,conv2:d,conv3:c}}return{extractDenseBlock3Params:s,extractDenseBlock4Params:i}}function tD(e){let t=[],{extractDenseBlock4Params:n}=ag(e,t),a={dense0:n(\"dense0\",!0),dense1:n(\"dense1\"),dense2:n(\"dense2\"),dense3:n(\"dense3\")};return _n(e,t),{params:a,paramMappings:t}}var _p=class extends fn{constructor(){super(\"FaceFeatureExtractor\")}forwardInput(t){let{params:n}=this;if(!n)throw new Error(\"FaceFeatureExtractor - load model before inference\");return O(()=>{let a=re(t.toBatchTensor(112,!0),\"float32\"),s=br(a,[122.782,117.001,104.298]).div(255),i=zd(s,n.dense0,!0);return i=zd(i,n.dense1),i=zd(i,n.dense2),i=zd(i,n.dense3),i=ya(i,[7,7],[2,2],\"valid\"),i})}async forward(t){return this.forwardInput(await vt(t))}getDefaultModelName(){return\"face_feature_extractor_model\"}extractParamsFromWeightMap(t){return tD(t)}extractParams(t){return eD(t)}};function Bd(e,t){return O(()=>X($e(e,t.weights),t.bias))}function nD(e,t,n){let a=[],{extractWeights:r,getRemainingWeights:s}=An(e),o=eg(r,a)(t,n,\"fc\");if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:a,params:{fc:o}}}function aD(e){let t=[],n=sa(e,t);function a(s){let i=n(`${s}/weights`,2),o=n(`${s}/bias`,1);return{weights:i,bias:o}}let r={fc:a(\"fc\")};return _n(e,t),{params:r,paramMappings:t}}function rg(e){let t={},n={};return Object.keys(e).forEach(a=>{let r=a.startsWith(\"fc\")?n:t;r[a]=e[a]}),{featureExtractorMap:t,classifierMap:n}}var Ap=class extends fn{constructor(t,n){super(t),this._faceFeatureExtractor=n}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(t){let{params:n}=this;if(!n)throw new Error(`${this._name} - load model before inference`);return O(()=>{let a=t instanceof Wr?this.faceFeatureExtractor.forwardInput(t):t;return Bd(a.as2D(a.shape[0],-1),n.fc)})}dispose(t=!0){this.faceFeatureExtractor.dispose(t),super.dispose(t)}loadClassifierParams(t){let{params:n,paramMappings:a}=this.extractClassifierParams(t);this._params=n,this._paramMappings=a}extractClassifierParams(t){return nD(t,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(t){let{featureExtractorMap:n,classifierMap:a}=rg(t);return this.faceFeatureExtractor.loadFromWeightMap(n),aD(a)}extractParams(t){let n=this.getClassifierChannelsIn(),a=this.getClassifierChannelsOut(),r=a*n+a,s=t.slice(0,t.length-r),i=t.slice(t.length-r);return this.faceFeatureExtractor.extractWeights(s),this.extractClassifierParams(i)}};var rD=[\"neutral\",\"happy\",\"sad\",\"angry\",\"fearful\",\"disgusted\",\"surprised\"],Os=class{constructor(t){this.neutral=0;this.happy=0;this.sad=0;this.angry=0;this.fearful=0;this.disgusted=0;this.surprised=0;if(t.length!==7)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${t.length}`);rD.forEach((n,a)=>{this[n]=t[a]})}asSortedArray(){return rD.map(t=>({expression:t,probability:this[t]})).sort((t,n)=>n.probability-t.probability)}};var sg=class extends Ap{constructor(t=new _p){super(\"FaceExpressionNet\",t)}forwardInput(t){return O(()=>qa(this.runNet(t)))}async forward(t){return this.forwardInput(await vt(t))}async predictExpressions(t){let n=await vt(t),a=await this.forwardInput(n),r=await Promise.all(dt(a).map(async i=>{let o=i.dataSync();return i.dispose(),o}));a.dispose();let s=r.map(i=>new Os(i));return n.isBatchInput?s:s[0]}getDefaultModelName(){return\"face_expression_model\"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function sD(e){return e.expressions instanceof Os}function Nk(e,t){return{...e,...{expressions:t}}}function Gfe(e,t,n=.1,a){(Array.isArray(t)?t:[t]).forEach(s=>{let i=s instanceof Os?s:sD(s)?s.expressions:void 0;if(!i)throw new Error(\"drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof\");let l=i.asSortedArray().filter(d=>d.probability>n),u=zr(s)?s.detection.box.bottomLeft:a||new He(0,0);new sl(l.map(d=>`${d.expression} (${nl(d.probability)})`),u).draw(e)})}function Fp(e){return zr(e)&&e.landmarks instanceof ka&&e.unshiftedLandmarks instanceof ka&&e.alignedRect instanceof Ft}function Hfe(e){let t=l=>l*180/Math.PI,n=(l,u)=>Math.sqrt((l.x-u.x)**2+(l.y-u.y)**2),a={roll:void 0,pitch:void 0,yaw:void 0},r=(l,u,p)=>{let d=Math.floor(l.x-u.x),c=Math.floor(u.x-p.x);return d-c},s=(l,u)=>{let p=Math.hypot(u.x-l.x,u.y-l.y),d=u.y-l.y,c=Math.asin(d/p),h=t(c),m=Math.floor(90-h),f=u.x-l.x<0?-1:1;return m*f},i=(l,u,p)=>{let d=n(l,p),c=new He((l.x+p.x)/2,(l.y+p.y)/2),h=n(u,c),m=Math.atan(h/d),f=Math.floor(t(m)),g=c.y-u.y<0?-1:1;return f*g};if(!e||!e.positions||e.positions.length!==68)return a;let o=e.positions;return a.roll=s(o[27],o[66]),a.pitch=i(o[14],o[30],o[2]),a.yaw=r(o[14],o[33],o[2]),a}function Vd(e,t){let{box:n}=e.detection,a=t.shiftBy(n.x,n.y),r=a.align(),{imageDims:s}=e.detection,i=new Ft(e.detection.score,r.rescale(s.reverse()),s),o=Hfe(t);return{...e,...{landmarks:a,unshiftedLandmarks:t,alignedRect:i,angle:o}}}var ig=class{constructor(t={}){let{drawLines:n=!0,drawPoints:a=!0,lineWidth:r,lineColor:s,pointSize:i,pointColor:o}=t;this.drawLines=n,this.drawPoints=a,this.lineWidth=r||1,this.pointSize=i||2,this.lineColor=s||\"rgba(0, 255, 255, 1)\",this.pointColor=o||\"rgba(255, 0, 255, 1)\"}},og=class{constructor(t,n={}){this.faceLandmarks=t,this.options=new ig(n)}draw(t){let n=ra(t),{drawLines:a,drawPoints:r,lineWidth:s,lineColor:i,pointSize:o,pointColor:l}=this.options;if(a&&this.faceLandmarks instanceof vp&&(n.strokeStyle=i,n.lineWidth=s,Pr(n,this.faceLandmarks.getJawOutline()),Pr(n,this.faceLandmarks.getLeftEyeBrow()),Pr(n,this.faceLandmarks.getRightEyeBrow()),Pr(n,this.faceLandmarks.getNose()),Pr(n,this.faceLandmarks.getLeftEye(),!0),Pr(n,this.faceLandmarks.getRightEye(),!0),Pr(n,this.faceLandmarks.getMouth(),!0)),r){n.strokeStyle=l,n.fillStyle=l;let u=p=>{n.beginPath(),n.arc(p.x,p.y,o,0,2*Math.PI),n.fill()};this.faceLandmarks.positions.forEach(u)}}};function jfe(e,t){(Array.isArray(t)?t:[t]).forEach(a=>{let r=a instanceof ka?a:Fp(a)?a.landmarks:void 0;if(!r)throw new Error(\"drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof\");new og(r).draw(e)})}var oD=\"1.7.15\";function Xfe(e,t){let n=Tp(e,t),a=Cp(e,t);function r(i,o,l){let u=a(i,o,`${l}/separable_conv0`),p=a(o,o,`${l}/separable_conv1`),d=n(i,o,1,`${l}/expansion_conv`);return{separable_conv0:u,separable_conv1:p,expansion_conv:d}}function s(i,o){let l=a(i,i,`${o}/separable_conv0`),u=a(i,i,`${o}/separable_conv1`),p=a(i,i,`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:u,separable_conv2:p}}return{extractConvParams:n,extractSeparableConvParams:a,extractReductionBlockParams:r,extractMainBlockParams:s}}function lD(e,t){let n=[],{extractWeights:a,getRemainingWeights:r}=An(e),{extractConvParams:s,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:l}=Xfe(a,n),u=s(3,32,3,\"entry_flow/conv_in\"),p=o(32,64,\"entry_flow/reduction_block_0\"),d=o(64,128,\"entry_flow/reduction_block_1\"),c={conv_in:u,reduction_block_0:p,reduction_block_1:d},h={};gr(t,0,1).forEach(b=>{h[`main_block_${b}`]=l(128,`middle_flow/main_block_${b}`)});let m=o(128,256,\"exit_flow/reduction_block\"),f=i(256,512,\"exit_flow/separable_conv\"),g={reduction_block:m,separable_conv:f};if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:n,params:{entry_flow:c,middle_flow:h,exit_flow:g}}}function Yfe(e,t){let n=sa(e,t),a=ng(n),r=Ep(n);function s(o){let l=r(`${o}/separable_conv0`),u=r(`${o}/separable_conv1`),p=a(`${o}/expansion_conv`);return{separable_conv0:l,separable_conv1:u,expansion_conv:p}}function i(o){let l=r(`${o}/separable_conv0`),u=r(`${o}/separable_conv1`),p=r(`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:u,separable_conv2:p}}return{extractConvParams:a,extractSeparableConvParams:r,extractReductionBlockParams:s,extractMainBlockParams:i}}function uD(e,t){let n=[],{extractConvParams:a,extractSeparableConvParams:r,extractReductionBlockParams:s,extractMainBlockParams:i}=Yfe(e,n),o=a(\"entry_flow/conv_in\"),l=s(\"entry_flow/reduction_block_0\"),u=s(\"entry_flow/reduction_block_1\"),p={conv_in:o,reduction_block_0:l,reduction_block_1:u},d={};gr(t,0,1).forEach(f=>{d[`main_block_${f}`]=i(`middle_flow/main_block_${f}`)});let c=s(\"exit_flow/reduction_block\"),h=r(\"exit_flow/separable_conv\"),m={reduction_block:c,separable_conv:h};return _n(e,n),{params:{entry_flow:p,middle_flow:d,exit_flow:m},paramMappings:n}}function pD(e,t,n){return X($t(e,t.filters,n,\"same\"),t.bias)}function Tk(e,t,n=!0){let a=n?Ke(e):e;return a=Un(a,t.separable_conv0,[1,1]),a=Un(Ke(a),t.separable_conv1,[1,1]),a=Dt(a,[3,3],[2,2],\"same\"),a=X(a,pD(e,t.expansion_conv,[2,2])),a}function Zfe(e,t){let n=Un(Ke(e),t.separable_conv0,[1,1]);return n=Un(Ke(n),t.separable_conv1,[1,1]),n=Un(Ke(n),t.separable_conv2,[1,1]),n=X(n,e),n}var lg=class extends fn{constructor(t){super(\"TinyXception\"),this._numMainBlocks=t}forwardInput(t){let{params:n}=this;if(!n)throw new Error(\"TinyXception - load model before inference\");return O(()=>{let a=re(t.toBatchTensor(112,!0),\"float32\"),s=br(a,[122.782,117.001,104.298]).div(255),i=Ke(pD(s,n.entry_flow.conv_in,[2,2]));return i=Tk(i,n.entry_flow.reduction_block_0,!1),i=Tk(i,n.entry_flow.reduction_block_1),gr(this._numMainBlocks,0,1).forEach(o=>{i=Zfe(i,n.middle_flow[`main_block_${o}`])}),i=Tk(i,n.exit_flow.reduction_block),i=Ke(Un(i,n.exit_flow.separable_conv,[1,1])),i})}async forward(t){return this.forwardInput(await vt(t))}getDefaultModelName(){return\"tiny_xception_model\"}extractParamsFromWeightMap(t){return uD(t,this._numMainBlocks)}extractParams(t){return lD(t,this._numMainBlocks)}};function cD(e){let t=[],{extractWeights:n,getRemainingWeights:a}=An(e),r=eg(n,t),s=r(512,1,\"fc/age\"),i=r(512,2,\"fc/gender\");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:t,params:{fc:{age:s,gender:i}}}}function dD(e){let t=[],n=sa(e,t);function a(s){let i=n(`${s}/weights`,2),o=n(`${s}/bias`,1);return{weights:i,bias:o}}let r={fc:{age:a(\"fc/age\"),gender:a(\"fc/gender\")}};return _n(e,t),{params:r,paramMappings:t}}var Ck=(n=>(n.FEMALE=\"female\",n.MALE=\"male\",n))(Ck||{});var ug=class extends fn{constructor(t=new lg(2)){super(\"AgeGenderNet\"),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(t){let{params:n}=this;if(!n)throw new Error(`${this._name} - load model before inference`);return O(()=>{let a=t instanceof Wr?this.faceFeatureExtractor.forwardInput(t):t,r=ya(a,[7,7],[2,2],\"valid\").as2D(a.shape[0],-1),s=Bd(r,n.fc.age).as1D(),i=Bd(r,n.fc.gender);return{age:s,gender:i}})}forwardInput(t){return O(()=>{let{age:n,gender:a}=this.runNet(t);return{age:n,gender:qa(a)}})}async forward(t){return this.forwardInput(await vt(t))}async predictAgeAndGender(t){let n=await vt(t),a=await this.forwardInput(n),r=dt(a.age),s=dt(a.gender),i=r.map((l,u)=>({ageTensor:l,genderTensor:s[u]})),o=await Promise.all(i.map(async({ageTensor:l,genderTensor:u})=>{let p=l.dataSync()[0],d=u.dataSync()[0],c=d>.5,h=c?\"male\":\"female\",m=c?d:1-d;return l.dispose(),u.dispose(),{age:p,gender:h,genderProbability:m}}));return a.age.dispose(),a.gender.dispose(),n.isBatchInput?o:o[0]}getDefaultModelName(){return\"age_gender_model\"}dispose(t=!0){this.faceFeatureExtractor.dispose(t),super.dispose(t)}loadClassifierParams(t){let{params:n,paramMappings:a}=this.extractClassifierParams(t);this._params=n,this._paramMappings=a}extractClassifierParams(t){return cD(t)}extractParamsFromWeightMap(t){let{featureExtractorMap:n,classifierMap:a}=rg(t);return this.faceFeatureExtractor.loadFromWeightMap(n),dD(a)}extractParams(t){let a=t.slice(0,t.length-1539),r=t.slice(t.length-1539);return this.faceFeatureExtractor.extractWeights(a),this.extractClassifierParams(r)}};var $p=class extends Ap{postProcess(t,n,a){let r=a.map(({width:i,height:o})=>{let l=n/Math.max(o,i);return{width:i*l,height:o*l}}),s=r.length;return O(()=>{let i=(d,c)=>At([yn([68],d,\"float32\"),yn([68],c,\"float32\")],1).as2D(1,136).as1D(),o=(d,c)=>{let{width:h,height:m}=r[d];return c(h,m)?Math.abs(h-m)/2:0},l=d=>o(d,(c,h)=>c<h),u=d=>o(d,(c,h)=>h<c);return t.mul(yn([s,136],n,\"float32\")).sub(At(Array.from(Array(s),(d,c)=>i(l(c),u(c))))).div(At(Array.from(Array(s),(d,c)=>i(r[c].width,r[c].height))))})}forwardInput(t){return O(()=>{let n=this.runNet(t);return this.postProcess(n,t.inputSize,t.inputDimensions.map(([a,r])=>({height:a,width:r})))})}async forward(t){return this.forwardInput(await vt(t))}async detectLandmarks(t){let n=await vt(t),a=O(()=>dt(this.forwardInput(n))),r=await Promise.all(a.map(async(s,i)=>{let o=Array.from(s.dataSync()),l=o.filter((p,d)=>Hf(d)),u=o.filter((p,d)=>!Hf(d));return new vp(Array(68).fill(0).map((p,d)=>new He(l[d],u[d])),{height:n.getInputHeight(i),width:n.getInputWidth(i)})}));return a.forEach(s=>s.dispose()),n.isBatchInput?r:r[0]}getClassifierChannelsOut(){return 136}};var Dp=class extends $p{constructor(t=new _p){super(\"FaceLandmark68Net\",t)}getDefaultModelName(){return\"face_landmark_68_model\"}getClassifierChannelsIn(){return 256}};function hD(e){let t=[],{extractDenseBlock3Params:n}=ag(e,t),a={dense0:n(\"dense0\",!0),dense1:n(\"dense1\"),dense2:n(\"dense2\")};return _n(e,t),{params:a,paramMappings:t}}function mD(e){let t=[],{extractWeights:n,getRemainingWeights:a}=An(e),{extractDenseBlock3Params:r}=tg(n,t),s=r(3,32,\"dense0\",!0),i=r(32,64,\"dense1\"),o=r(64,128,\"dense2\");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o}}}var pg=class extends fn{constructor(){super(\"TinyFaceFeatureExtractor\")}forwardInput(t){let{params:n}=this;if(!n)throw new Error(\"TinyFaceFeatureExtractor - load model before inference\");return O(()=>{let a=re(t.toBatchTensor(112,!0),\"float32\"),s=br(a,[122.782,117.001,104.298]).div(255),i=Qf(s,n.dense0,!0);return i=Qf(i,n.dense1),i=Qf(i,n.dense2),i=ya(i,[14,14],[2,2],\"valid\"),i})}async forward(t){return this.forwardInput(await vt(t))}getDefaultModelName(){return\"face_feature_extractor_tiny_model\"}extractParamsFromWeightMap(t){return hD(t)}extractParams(t){return mD(t)}};var cg=class extends $p{constructor(t=new pg){super(\"FaceLandmark68TinyNet\",t)}getDefaultModelName(){return\"face_landmark_68_tiny_model\"}getClassifierChannelsIn(){return 128}};var fD=class extends Dp{};function gD(e,t){return X(z(e,t.weights),t.biases)}function Ek(e,t,n,a,r=\"same\"){let{filters:s,bias:i}=t.conv,o=$t(e,s,n,r);return o=X(o,i),o=gD(o,t.scale),a?Ke(o):o}function bD(e,t){return Ek(e,t,[1,1],!0)}function _k(e,t){return Ek(e,t,[1,1],!1)}function dg(e,t){return Ek(e,t,[2,2],!0,\"valid\")}function Jfe(e,t){function n(o,l,u){let p=e(o),d=p.length/(l*u*u);if(gk(d))throw new Error(`depth has to be an integer: ${d}, weights.length: ${p.length}, numFilters: ${l}, filterSize: ${u}`);return O(()=>De(Fa(p,[l,d,u,u]),[2,3,1,0]))}function a(o,l,u,p){let d=n(o,l,u),c=je(e(l));return t.push({paramPath:`${p}/filters`},{paramPath:`${p}/bias`}),{filters:d,bias:c}}function r(o,l){let u=je(e(o)),p=je(e(o));return t.push({paramPath:`${l}/weights`},{paramPath:`${l}/biases`}),{weights:u,biases:p}}function s(o,l,u,p){let d=a(o,l,u,`${p}/conv`),c=r(l,`${p}/scale`);return{conv:d,scale:c}}function i(o,l,u,p,d=!1){let c=s((d?.5:1)*o,l,u,`${p}/conv1`),h=s(o,l,u,`${p}/conv2`);return{conv1:c,conv2:h}}return{extractConvLayerParams:s,extractResidualLayerParams:i}}function yD(e){let{extractWeights:t,getRemainingWeights:n}=An(e),a=[],{extractConvLayerParams:r,extractResidualLayerParams:s}=Jfe(t,a),i=r(4704,32,7,\"conv32_down\"),o=s(9216,32,3,\"conv32_1\"),l=s(9216,32,3,\"conv32_2\"),u=s(9216,32,3,\"conv32_3\"),p=s(36864,64,3,\"conv64_down\",!0),d=s(36864,64,3,\"conv64_1\"),c=s(36864,64,3,\"conv64_2\"),h=s(36864,64,3,\"conv64_3\"),m=s(147456,128,3,\"conv128_down\",!0),f=s(147456,128,3,\"conv128_1\"),g=s(147456,128,3,\"conv128_2\"),b=s(589824,256,3,\"conv256_down\",!0),y=s(589824,256,3,\"conv256_1\"),x=s(589824,256,3,\"conv256_2\"),v=s(589824,256,3,\"conv256_down_out\"),I=O(()=>De(Ea(t(256*128),[128,256]),[1,0]));if(a.push({paramPath:\"fc\"}),n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:i,conv32_1:o,conv32_2:l,conv32_3:u,conv64_down:p,conv64_1:d,conv64_2:c,conv64_3:h,conv128_down:m,conv128_1:f,conv128_2:g,conv256_down:b,conv256_1:y,conv256_2:x,conv256_down_out:v,fc:I},paramMappings:a}}function Qfe(e,t){let n=sa(e,t);function a(i){let o=n(`${i}/scale/weights`,1),l=n(`${i}/scale/biases`,1);return{weights:o,biases:l}}function r(i){let o=n(`${i}/conv/filters`,4),l=n(`${i}/conv/bias`,1),u=a(i);return{conv:{filters:o,bias:l},scale:u}}function s(i){return{conv1:r(`${i}/conv1`),conv2:r(`${i}/conv2`)}}return{extractConvLayerParams:r,extractResidualLayerParams:s}}function xD(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:a}=Qfe(e,t),r=n(\"conv32_down\"),s=a(\"conv32_1\"),i=a(\"conv32_2\"),o=a(\"conv32_3\"),l=a(\"conv64_down\"),u=a(\"conv64_1\"),p=a(\"conv64_2\"),d=a(\"conv64_3\"),c=a(\"conv128_down\"),h=a(\"conv128_1\"),m=a(\"conv128_2\"),f=a(\"conv256_down\"),g=a(\"conv256_1\"),b=a(\"conv256_2\"),y=a(\"conv256_down_out\"),{fc:x}=e;if(t.push({originalPath:\"fc\",paramPath:\"fc\"}),!fk(x))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${x}`);let v={conv32_down:r,conv32_1:s,conv32_2:i,conv32_3:o,conv64_down:l,conv64_1:u,conv64_2:p,conv64_3:d,conv128_down:c,conv128_1:h,conv128_2:m,conv256_down:f,conv256_1:g,conv256_2:b,conv256_down_out:y,fc:x};return _n(e,t),{params:v,paramMappings:t}}function Ya(e,t){let n=bD(e,t.conv1);return n=_k(n,t.conv2),n=X(n,e),n=Ke(n),n}function Ud(e,t){let n=dg(e,t.conv1);n=_k(n,t.conv2);let a=ya(e,2,2,\"valid\"),r=It(a.shape),s=a.shape[3]!==n.shape[3];if(a.shape[1]!==n.shape[1]||a.shape[2]!==n.shape[2]){let o=[...n.shape];o[1]=1;let l=It(o);n=et([n,l],1);let u=[...n.shape];u[2]=1;let p=It(u);n=et([n,p],2)}return a=s?et([a,r],3):a,n=X(a,n),n=Ke(n),n}var Rp=class extends fn{constructor(){super(\"FaceRecognitionNet\")}forwardInput(t){let{params:n}=this;if(!n)throw new Error(\"FaceRecognitionNet - load model before inference\");return O(()=>{let a=re(t.toBatchTensor(150,!0),\"float32\"),s=br(a,[122.782,117.001,104.298]).div(255),i=dg(s,n.conv32_down);i=Dt(i,3,2,\"valid\"),i=Ya(i,n.conv32_1),i=Ya(i,n.conv32_2),i=Ya(i,n.conv32_3),i=Ud(i,n.conv64_down),i=Ya(i,n.conv64_1),i=Ya(i,n.conv64_2),i=Ya(i,n.conv64_3),i=Ud(i,n.conv128_down),i=Ya(i,n.conv128_1),i=Ya(i,n.conv128_2),i=Ud(i,n.conv256_down),i=Ya(i,n.conv256_1),i=Ya(i,n.conv256_2),i=Ud(i,n.conv256_down_out);let o=i.mean([1,2]);return $e(o,n.fc)})}async forward(t){return this.forwardInput(await vt(t))}async computeFaceDescriptor(t){var s;if((s=t==null?void 0:t.shape)!=null&&s.some(i=>i<=0))return new Float32Array(128);let n=await vt(t),a=O(()=>dt(this.forwardInput(n))),r=await Promise.all(a.map(i=>i.data()));return a.forEach(i=>i.dispose()),n.isBatchInput?r:r[0]}getDefaultModelName(){return\"face_recognition_model\"}extractParamsFromWeightMap(t){return xD(t)}extractParams(t){return yD(t)}};function Y2e(e){let t=new Rp;return t.extractWeights(e),t}function Ak(e,t){return{...e,...{descriptor:t}}}function eCe(e){return typeof e.age==\"number\"}function Fk(e,t){return{...e,...{age:t}}}function rCe(e){return(e.gender===\"male\"||e.gender===\"female\")&&gp(e.genderProbability)}function $k(e,t,n){return{...e,...{gender:t,genderProbability:n}}}function ege(e,t){function n(l,u){let p=Fa(e(9*l),[3,3,l,1]),d=je(e(l)),c=je(e(l)),h=je(e(l)),m=je(e(l));return t.push({paramPath:`${u}/filters`},{paramPath:`${u}/batch_norm_scale`},{paramPath:`${u}/batch_norm_offset`},{paramPath:`${u}/batch_norm_mean`},{paramPath:`${u}/batch_norm_variance`}),{filters:p,batch_norm_scale:d,batch_norm_offset:c,batch_norm_mean:h,batch_norm_variance:m}}function a(l,u,p,d,c){let h=Fa(e(l*u*p*p),[p,p,l,u]),m=je(e(u));return t.push({paramPath:`${d}/filters`},{paramPath:`${d}/${c?\"batch_norm_offset\":\"bias\"}`}),{filters:h,bias:m}}function r(l,u,p,d){let{filters:c,bias:h}=a(l,u,p,d,!0);return{filters:c,batch_norm_offset:h}}function s(l,u,p){let d=n(l,`${p}/depthwise_conv`),c=r(l,u,1,`${p}/pointwise_conv`);return{depthwise_conv:d,pointwise_conv:c}}function i(){let l=r(3,32,3,\"mobilenetv1/conv_0\"),u=s(32,64,\"mobilenetv1/conv_1\"),p=s(64,128,\"mobilenetv1/conv_2\"),d=s(128,128,\"mobilenetv1/conv_3\"),c=s(128,256,\"mobilenetv1/conv_4\"),h=s(256,256,\"mobilenetv1/conv_5\"),m=s(256,512,\"mobilenetv1/conv_6\"),f=s(512,512,\"mobilenetv1/conv_7\"),g=s(512,512,\"mobilenetv1/conv_8\"),b=s(512,512,\"mobilenetv1/conv_9\"),y=s(512,512,\"mobilenetv1/conv_10\"),x=s(512,512,\"mobilenetv1/conv_11\"),v=s(512,1024,\"mobilenetv1/conv_12\"),I=s(1024,1024,\"mobilenetv1/conv_13\");return{conv_0:l,conv_1:u,conv_2:p,conv_3:d,conv_4:c,conv_5:h,conv_6:m,conv_7:f,conv_8:g,conv_9:b,conv_10:y,conv_11:x,conv_12:v,conv_13:I}}function o(){let l=r(1024,256,1,\"prediction_layer/conv_0\"),u=r(256,512,3,\"prediction_layer/conv_1\"),p=r(512,128,1,\"prediction_layer/conv_2\"),d=r(128,256,3,\"prediction_layer/conv_3\"),c=r(256,128,1,\"prediction_layer/conv_4\"),h=r(128,256,3,\"prediction_layer/conv_5\"),m=r(256,64,1,\"prediction_layer/conv_6\"),f=r(64,128,3,\"prediction_layer/conv_7\"),g=a(512,12,1,\"prediction_layer/box_predictor_0/box_encoding_predictor\"),b=a(512,9,1,\"prediction_layer/box_predictor_0/class_predictor\"),y=a(1024,24,1,\"prediction_layer/box_predictor_1/box_encoding_predictor\"),x=a(1024,18,1,\"prediction_layer/box_predictor_1/class_predictor\"),v=a(512,24,1,\"prediction_layer/box_predictor_2/box_encoding_predictor\"),I=a(512,18,1,\"prediction_layer/box_predictor_2/class_predictor\"),N=a(256,24,1,\"prediction_layer/box_predictor_3/box_encoding_predictor\"),C=a(256,18,1,\"prediction_layer/box_predictor_3/class_predictor\"),_=a(256,24,1,\"prediction_layer/box_predictor_4/box_encoding_predictor\"),F=a(256,18,1,\"prediction_layer/box_predictor_4/class_predictor\"),D=a(128,24,1,\"prediction_layer/box_predictor_5/box_encoding_predictor\"),$=a(128,18,1,\"prediction_layer/box_predictor_5/class_predictor\");return{conv_0:l,conv_1:u,conv_2:p,conv_3:d,conv_4:c,conv_5:h,conv_6:m,conv_7:f,box_predictor_0:{box_encoding_predictor:g,class_predictor:b},box_predictor_1:{box_encoding_predictor:y,class_predictor:x},box_predictor_2:{box_encoding_predictor:v,class_predictor:I},box_predictor_3:{box_encoding_predictor:N,class_predictor:C},box_predictor_4:{box_encoding_predictor:_,class_predictor:F},box_predictor_5:{box_encoding_predictor:D,class_predictor:$}}}return{extractMobilenetV1Params:i,extractPredictionLayerParams:o}}function vD(e){let t=[],{extractWeights:n,getRemainingWeights:a}=An(e),{extractMobilenetV1Params:r,extractPredictionLayerParams:s}=ege(n,t),i=r(),o=s(),u={extra_dim:xd(n(5118*4),[1,5118,4])};if(t.push({paramPath:\"output_layer/extra_dim\"}),a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{params:{mobilenetv1:i,prediction_layer:o,output_layer:u},paramMappings:t}}function tge(e,t){let n=sa(e,t);function a(u,p,d){let c=n(`${u}/Conv2d_${p}_pointwise/weights`,4,`${d}/filters`),h=n(`${u}/Conv2d_${p}_pointwise/convolution_bn_offset`,1,`${d}/batch_norm_offset`);return{filters:c,batch_norm_offset:h}}function r(u){let p=`mobilenetv1/conv_${u}`,d=`MobilenetV1/Conv2d_${u}_depthwise`,c=`${p}/depthwise_conv`,h=`${p}/pointwise_conv`,m=n(`${d}/depthwise_weights`,4,`${c}/filters`),f=n(`${d}/BatchNorm/gamma`,1,`${c}/batch_norm_scale`),g=n(`${d}/BatchNorm/beta`,1,`${c}/batch_norm_offset`),b=n(`${d}/BatchNorm/moving_mean`,1,`${c}/batch_norm_mean`),y=n(`${d}/BatchNorm/moving_variance`,1,`${c}/batch_norm_variance`);return{depthwise_conv:{filters:m,batch_norm_scale:f,batch_norm_offset:g,batch_norm_mean:b,batch_norm_variance:y},pointwise_conv:a(\"MobilenetV1\",u,h)}}function s(){return{conv_0:a(\"MobilenetV1\",0,\"mobilenetv1/conv_0\"),conv_1:r(1),conv_2:r(2),conv_3:r(3),conv_4:r(4),conv_5:r(5),conv_6:r(6),conv_7:r(7),conv_8:r(8),conv_9:r(9),conv_10:r(10),conv_11:r(11),conv_12:r(12),conv_13:r(13)}}function i(u,p){let d=n(`${u}/weights`,4,`${p}/filters`),c=n(`${u}/biases`,1,`${p}/bias`);return{filters:d,bias:c}}function o(u){let p=i(`Prediction/BoxPredictor_${u}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${u}/box_encoding_predictor`),d=i(`Prediction/BoxPredictor_${u}/ClassPredictor`,`prediction_layer/box_predictor_${u}/class_predictor`);return{box_encoding_predictor:p,class_predictor:d}}function l(){return{conv_0:a(\"Prediction\",0,\"prediction_layer/conv_0\"),conv_1:a(\"Prediction\",1,\"prediction_layer/conv_1\"),conv_2:a(\"Prediction\",2,\"prediction_layer/conv_2\"),conv_3:a(\"Prediction\",3,\"prediction_layer/conv_3\"),conv_4:a(\"Prediction\",4,\"prediction_layer/conv_4\"),conv_5:a(\"Prediction\",5,\"prediction_layer/conv_5\"),conv_6:a(\"Prediction\",6,\"prediction_layer/conv_6\"),conv_7:a(\"Prediction\",7,\"prediction_layer/conv_7\"),box_predictor_0:o(0),box_predictor_1:o(1),box_predictor_2:o(2),box_predictor_3:o(3),box_predictor_4:o(4),box_predictor_5:o(5)}}return{extractMobilenetV1Params:s,extractPredictionLayerParams:l}}function wD(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:a}=tge(e,t),r=e[\"Output/extra_dim\"];if(t.push({originalPath:\"Output/extra_dim\",paramPath:\"output_layer/extra_dim\"}),!Lr(r))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${r}`);let s={mobilenetv1:n(),prediction_layer:a(),output_layer:{extra_dim:r}};return _n(e,t),{params:s,paramMappings:t}}function Ra(e,t,n){return O(()=>{let a=$t(e,t.filters,n,\"same\");return a=X(a,t.batch_norm_offset),an(a,0,6)})}var nge=.0010000000474974513;function age(e,t,n){return O(()=>{let a=Ts(e,t.filters,n,\"same\");return a=Ns(a,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,nge),an(a,0,6)})}function rge(e){return[2,4,6,12].some(t=>t===e)?[2,2]:[1,1]}function kD(e,t){return O(()=>{let n,a=Ra(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach((s,i)=>{let o=i+1,l=rge(o);a=age(a,s.depthwise_conv,l),a=Ra(a,s.pointwise_conv,[1,1]),o===11&&(n=a)}),n===null)throw new Error(\"mobileNetV1 - output of conv layer 11 is null\");return{out:a,conv11:n}})}function sge(e,t,n){let a=e.arraySync(),r=Math.min(a[t][0],a[t][2]),s=Math.min(a[t][1],a[t][3]),i=Math.max(a[t][0],a[t][2]),o=Math.max(a[t][1],a[t][3]),l=Math.min(a[n][0],a[n][2]),u=Math.min(a[n][1],a[n][3]),p=Math.max(a[n][0],a[n][2]),d=Math.max(a[n][1],a[n][3]),c=(i-r)*(o-s),h=(p-l)*(d-u);if(c<=0||h<=0)return 0;let m=Math.max(r,l),f=Math.max(s,u),g=Math.min(i,p),b=Math.min(o,d),y=Math.max(g-m,0)*Math.max(b-f,0);return y/(c+h-y)}function ID(e,t,n,a,r){let s=e.shape[0],i=Math.min(n,s),o=t.map((p,d)=>({score:p,boxIndex:d})).filter(p=>p.score>r).sort((p,d)=>d.score-p.score),l=p=>p<=a?1:0,u=[];return o.forEach(p=>{if(u.length>=i)return;let d=p.score;for(let c=u.length-1;c>=0;--c){let h=sge(e,p.boxIndex,u[c]);if(h!==0&&(p.score*=l(h),p.score<=r))break}d===p.score&&u.push(p.boxIndex)}),u}function ige(e){let t=dt(De(e,[1,0])),n=[pe(t[2],t[0]),pe(t[3],t[1])],a=[X(t[0],he(n[0],2)),X(t[1],he(n[1],2))];return{sizes:n,centers:a}}function oge(e,t){let{sizes:n,centers:a}=ige(e),r=dt(De(t,[1,0])),s=he(z(dn(he(r[2],5)),n[0]),2),i=X(z(he(r[0],10),n[0]),a[0]),o=he(z(dn(he(r[3],5)),n[1]),2),l=X(z(he(r[1],10),n[1]),a[1]);return De(At([pe(i,s),pe(l,o),X(i,s),X(l,o)]),[1,0])}function SD(e,t,n){return O(()=>{let a=e.shape[0],r=oge(W(On(n.extra_dim,[a,1,1]),[-1,4]),W(e,[-1,4]));r=W(r,[a,r.shape[0]/a,4]);let s=ha(Ve(t,[0,0,1],[-1,-1,-1])),i=Ve(s,[0,0,0],[-1,-1,1]);i=W(i,[a,i.shape[1]]);let o=dt(r),l=dt(i);return{boxes:o,scores:l}})}function ol(e,t){return O(()=>{let n=e.shape[0],a=W(il(e,t.box_encoding_predictor),[n,-1,1,4]),r=W(il(e,t.class_predictor),[n,-1,3]);return{boxPredictionEncoding:a,classPrediction:r}})}function ND(e,t,n){return O(()=>{let a=Ra(e,n.conv_0,[1,1]),r=Ra(a,n.conv_1,[2,2]),s=Ra(r,n.conv_2,[1,1]),i=Ra(s,n.conv_3,[2,2]),o=Ra(i,n.conv_4,[1,1]),l=Ra(o,n.conv_5,[2,2]),u=Ra(l,n.conv_6,[1,1]),p=Ra(u,n.conv_7,[2,2]),d=ol(t,n.box_predictor_0),c=ol(e,n.box_predictor_1),h=ol(r,n.box_predictor_2),m=ol(i,n.box_predictor_3),f=ol(l,n.box_predictor_4),g=ol(p,n.box_predictor_5),b=et([d.boxPredictionEncoding,c.boxPredictionEncoding,h.boxPredictionEncoding,m.boxPredictionEncoding,f.boxPredictionEncoding,g.boxPredictionEncoding],1),y=et([d.classPrediction,c.classPrediction,h.classPrediction,m.classPrediction,f.classPrediction,g.classPrediction],1);return{boxPredictions:b,classPredictions:y}})}var Ma=class{constructor({minConfidence:t,maxResults:n}={}){this._name=\"SsdMobilenetv1Options\";if(this._minConfidence=t||.5,this._maxResults=n||100,typeof this._minConfidence!=\"number\"||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if(typeof this._maxResults!=\"number\")throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}};var ll=class extends fn{constructor(){super(\"SsdMobilenetv1\")}forwardInput(t){let{params:n}=this;if(!n)throw new Error(\"SsdMobilenetv1 - load model before inference\");return O(()=>{let a=re(t.toBatchTensor(512,!1),\"float32\"),r=pe(he(a,127.5),1),s=kD(r,n.mobilenetv1),{boxPredictions:i,classPredictions:o}=ND(s.out,s.conv11,n.prediction_layer);return SD(i,o,n.output_layer)})}async forward(t){return this.forwardInput(await vt(t))}async locateFaces(t,n={}){let{maxResults:a,minConfidence:r}=new Ma(n),s=await vt(t),{boxes:i,scores:o}=this.forwardInput(s),l=i[0],u=o[0];for(let x=1;x<i.length;x++)i[x].dispose(),o[x].dispose();let p=Array.from(u.dataSync()),c=ID(l,p,a,.5,r),h=s.getReshapedInputDimensions(0),m=s.inputSize,f=m/h.width,g=m/h.height,b=l.arraySync(),y=c.map(x=>{let[v,I]=[Math.max(0,b[x][0]),Math.min(1,b[x][2])].map(_=>_*g),[N,C]=[Math.max(0,b[x][1]),Math.min(1,b[x][3])].map(_=>_*f);return new Ft(p[x],new xp(N,v,C-N,I-v),{height:s.getInputHeight(0),width:s.getInputWidth(0)})});return l.dispose(),u.dispose(),y}getDefaultModelName(){return\"ssd_mobilenetv1_model\"}extractParamsFromWeightMap(t){return wD(t)}extractParams(t){return vD(t)}};function lge(e){let t=new ll;return t.extractWeights(e),t}function YCe(e){return lge(e)}var TD=class extends ll{};var CD=.4,ED=[new He(.738768,.874946),new He(2.42204,2.65704),new He(4.30971,7.04493),new He(10.246,4.59428),new He(12.6868,11.8741)],_D=[new He(1.603231,2.094468),new He(6.041143,7.080126),new He(2.882459,3.518061),new He(4.266906,5.178857),new He(9.041765,10.66308)],AD=[117.001,114.697,97.404],FD=\"tiny_yolov2_model\",$D=\"tiny_yolov2_separable_conv_model\";var hg=e=>typeof e==\"number\";function DD(e){if(!e)throw new Error(`invalid config: ${e}`);if(typeof e.withSeparableConvs!=\"boolean\")throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!hg(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every(t=>typeof t==\"string\"))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map(t=>t||{}).every(t=>hg(t.x)&&hg(t.y)))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||e.meanRgb.length!==3||!e.meanRgb.every(hg)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}function Mp(e){return O(()=>{let t=z(e,xe(.10000000149011612));return X(Ke(pe(e,t)),t)})}function Br(e,t){return O(()=>{let n=xa(e,[[0,0],[1,1],[1,1],[0,0]]);return n=$t(n,t.conv.filters,[1,1],\"valid\"),n=pe(n,t.bn.sub),n=z(n,t.bn.truediv),n=X(n,t.conv.bias),Mp(n)})}function Vr(e,t){return O(()=>{let n=xa(e,[[0,0],[1,1],[1,1],[0,0]]);return n=_s(n,t.depthwise_filter,t.pointwise_filter,[1,1],\"valid\"),n=X(n,t.bias),Mp(n)})}function uge(e,t){let n=Tp(e,t);function a(i,o){let l=je(e(i)),u=je(e(i));return t.push({paramPath:`${o}/sub`},{paramPath:`${o}/truediv`}),{sub:l,truediv:u}}function r(i,o,l){let u=n(i,o,3,`${l}/conv`),p=a(o,`${l}/bn`);return{conv:u,bn:p}}let s=Cp(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:r,extractSeparableConvParams:s}}function RD(e,t,n,a){let{extractWeights:r,getRemainingWeights:s}=An(e),i=[],{extractConvParams:o,extractConvWithBatchNormParams:l,extractSeparableConvParams:u}=uge(r,i),p;if(t.withSeparableConvs){let[d,c,h,m,f,g,b,y,x]=a,v=t.isFirstLayerConv2d?o(d,c,3,\"conv0\"):u(d,c,\"conv0\"),I=u(c,h,\"conv1\"),N=u(h,m,\"conv2\"),C=u(m,f,\"conv3\"),_=u(f,g,\"conv4\"),F=u(g,b,\"conv5\"),D=y?u(b,y,\"conv6\"):void 0,$=x?u(y,x,\"conv7\"):void 0,S=o(x||y||b,5*n,1,\"conv8\");p={conv0:v,conv1:I,conv2:N,conv3:C,conv4:_,conv5:F,conv6:D,conv7:$,conv8:S}}else{let[d,c,h,m,f,g,b,y,x]=a,v=l(d,c,\"conv0\"),I=l(c,h,\"conv1\"),N=l(h,m,\"conv2\"),C=l(m,f,\"conv3\"),_=l(f,g,\"conv4\"),F=l(g,b,\"conv5\"),D=l(b,y,\"conv6\"),$=l(y,x,\"conv7\"),S=o(x,5*n,1,\"conv8\");p={conv0:v,conv1:I,conv2:N,conv3:C,conv4:_,conv5:F,conv6:D,conv7:$,conv8:S}}if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{params:p,paramMappings:i}}function pge(e,t){let n=sa(e,t);function a(o){let l=n(`${o}/sub`,1),u=n(`${o}/truediv`,1);return{sub:l,truediv:u}}function r(o){let l=n(`${o}/filters`,4),u=n(`${o}/bias`,1);return{filters:l,bias:u}}function s(o){let l=r(`${o}/conv`),u=a(`${o}/bn`);return{conv:l,bn:u}}let i=Ep(n);return{extractConvParams:r,extractConvWithBatchNormParams:s,extractSeparableConvParams:i}}function MD(e,t){let n=[],{extractConvParams:a,extractConvWithBatchNormParams:r,extractSeparableConvParams:s}=pge(e,n),i;if(t.withSeparableConvs){let o=t.filterSizes&&t.filterSizes.length||9;i={conv0:t.isFirstLayerConv2d?a(\"conv0\"):s(\"conv0\"),conv1:s(\"conv1\"),conv2:s(\"conv2\"),conv3:s(\"conv3\"),conv4:s(\"conv4\"),conv5:s(\"conv5\"),conv6:o>7?s(\"conv6\"):void 0,conv7:o>8?s(\"conv7\"):void 0,conv8:a(\"conv8\")}}else i={conv0:r(\"conv0\"),conv1:r(\"conv1\"),conv2:r(\"conv2\"),conv3:r(\"conv3\"),conv4:r(\"conv4\"),conv5:r(\"conv5\"),conv6:r(\"conv6\"),conv7:r(\"conv7\"),conv8:a(\"conv8\")};return _n(e,n),{params:i,paramMappings:n}}var yr=class{constructor({inputSize:t,scoreThreshold:n}={}){this._name=\"TinyYolov2Options\";if(this._inputSize=t||416,this._scoreThreshold=n||.5,typeof this._inputSize!=\"number\"||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if(typeof this._scoreThreshold!=\"number\"||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}};var mg=class mg extends fn{constructor(t){super(\"TinyYolov2\"),DD(t),this._config=t}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(t,n){let a=Br(t,n.conv0);return a=Dt(a,[2,2],[2,2],\"same\"),a=Br(a,n.conv1),a=Dt(a,[2,2],[2,2],\"same\"),a=Br(a,n.conv2),a=Dt(a,[2,2],[2,2],\"same\"),a=Br(a,n.conv3),a=Dt(a,[2,2],[2,2],\"same\"),a=Br(a,n.conv4),a=Dt(a,[2,2],[2,2],\"same\"),a=Br(a,n.conv5),a=Dt(a,[2,2],[1,1],\"same\"),a=Br(a,n.conv6),a=Br(a,n.conv7),il(a,n.conv8,\"valid\",!1)}runMobilenet(t,n){let a=this.config.isFirstLayerConv2d?Mp(il(t,n.conv0,\"valid\",!1)):Vr(t,n.conv0);return a=Dt(a,[2,2],[2,2],\"same\"),a=Vr(a,n.conv1),a=Dt(a,[2,2],[2,2],\"same\"),a=Vr(a,n.conv2),a=Dt(a,[2,2],[2,2],\"same\"),a=Vr(a,n.conv3),a=Dt(a,[2,2],[2,2],\"same\"),a=Vr(a,n.conv4),a=Dt(a,[2,2],[2,2],\"same\"),a=Vr(a,n.conv5),a=Dt(a,[2,2],[1,1],\"same\"),a=n.conv6?Vr(a,n.conv6):a,a=n.conv7?Vr(a,n.conv7):a,il(a,n.conv8,\"valid\",!1)}forwardInput(t,n){let{params:a}=this;if(!a)throw new Error(\"TinyYolov2 - load model before inference\");return O(()=>{let r=re(t.toBatchTensor(n,!1),\"float32\");return r=this.config.meanRgb?br(r,this.config.meanRgb):r,r=r.div(255),this.config.withSeparableConvs?this.runMobilenet(r,a):this.runTinyYolov2(r,a)})}async forward(t,n){return this.forwardInput(await vt(t),n)}async detect(t,n={}){let{inputSize:a,scoreThreshold:r}=new yr(n),s=await vt(t),i=await this.forwardInput(s,a),o=O(()=>dt(i)[0].expandDims()),l={width:s.getInputWidth(0),height:s.getInputHeight(0)},u=await this.extractBoxes(o,s.getReshapedInputDimensions(0),r);i.dispose(),o.dispose();let p=u.map(g=>g.box),d=u.map(g=>g.score),c=u.map(g=>g.classScore),h=u.map(g=>this.config.classes[g.label]);return U$(p.map(g=>g.rescale(a)),d,this.config.iouThreshold,!0).map(g=>new yp(d[g],c[g],h[g],p[g],l))}getDefaultModelName(){return\"\"}extractParamsFromWeightMap(t){return MD(t,this.config)}extractParams(t){let n=this.config.filterSizes||mg.DEFAULT_FILTER_SIZES,a=n?n.length:void 0;if(a!==7&&a!==8&&a!==9)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${a} filterSizes in config`);return RD(t,this.config,this.boxEncodingSize,n)}async extractBoxes(t,n,a){let{width:r,height:s}=n,i=Math.max(r,s),o=i/r,l=i/s,u=t.shape[1],p=this.config.anchors.length,[d,c,h]=O(()=>{let b=t.reshape([u,u,p,this.boxEncodingSize]),y=b.slice([0,0,0,0],[u,u,p,4]),x=b.slice([0,0,0,4],[u,u,p,1]),v=this.withClassScores?qa(b.slice([0,0,0,5],[u,u,p,this.config.classes.length]),3):xe(0);return[y,x,v]}),m=[],f=await c.array(),g=await d.array();for(let b=0;b<u;b++)for(let y=0;y<u;y++)for(let x=0;x<p;x++){let v=qf(f[b][y][x][0]);if(!a||v>a){let I=(y+qf(g[b][y][x][0]))/u*o,N=(b+qf(g[b][y][x][1]))/u*l,C=Math.exp(g[b][y][x][2])*this.config.anchors[x].x/u*o,_=Math.exp(g[b][y][x][3])*this.config.anchors[x].y/u*l,F=I-C/2,D=N-_/2,$={row:b,col:y,anchor:x},{classScore:S,label:M}=this.withClassScores?await this.extractPredictedClass(h,$):{classScore:1,label:0};m.push({box:new bp(F,D,F+C,D+_),score:v,classScore:v*S,label:M,...$})}}return d.dispose(),c.dispose(),h.dispose(),m}async extractPredictedClass(t,n){let{row:a,col:r,anchor:s}=n,i=await t.array();return Array(this.config.classes.length).fill(0).map((o,l)=>i[a][r][s][l]).map((o,l)=>({classScore:o,label:l})).reduce((o,l)=>o.classScore>l.classScore?o:l)}};mg.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var Op=mg;var Pp=class extends Op{constructor(t=!0){let n={withSeparableConvs:t,iouThreshold:CD,classes:[\"face\"],...t?{anchors:_D,meanRgb:AD}:{anchors:ED,withClassScores:!0}};super(n)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(t,n){return(await this.detect(t,n)).map(r=>new Ft(r.score,r.relativeBox,{width:r.imageWidth,height:r.imageHeight}))}getDefaultModelName(){return this.withSeparableConvs?$D:FD}extractParamsFromWeightMap(t){return super.extractParamsFromWeightMap(t)}};function BEe(e,t=!0){let n=new Pp(t);return n.extractWeights(e),n}var fg=class extends yr{constructor(){super(...arguments);this._name=\"TinyFaceDetectorOptions\"}};var Oa=class{async then(t){return t(await this.run())}async run(){throw new Error(\"ComposableTask - run is not implemented\")}};async function ul(e,t,n,a,r=({alignedRect:s})=>s){let s=e.map(l=>Fp(l)?r(l):l.detection),i=a||(t instanceof Ce?await Ld(t,s):await Pd(t,s)),o=await n(i);return i.forEach(l=>l instanceof Ce&&l.dispose()),o}async function Lp(e,t,n,a,r){return ul([e],t,async s=>n(s[0]),a,r)}var OD=.4,PD=[new He(1.603231,2.094468),new He(6.041143,7.080126),new He(2.882459,3.518061),new He(4.266906,5.178857),new He(9.041765,10.66308)],LD=[117.001,114.697,97.404];var zp=class extends Op{constructor(){let t={withSeparableConvs:!0,iouThreshold:OD,classes:[\"face\"],anchors:PD,meanRgb:LD,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(t)}get anchors(){return this.config.anchors}async locateFaces(t,n){return(await this.detect(t,n)).map(r=>new Ft(r.score,r.relativeBox,{width:r.imageWidth,height:r.imageHeight}))}getDefaultModelName(){return\"tiny_face_detector_model\"}extractParamsFromWeightMap(t){return super.extractParamsFromWeightMap(t)}};var rt={ssdMobilenetv1:new ll,tinyFaceDetector:new zp,tinyYolov2:new Pp,faceLandmark68Net:new Dp,faceLandmark68TinyNet:new cg,faceRecognitionNet:new Rp,faceExpressionNet:new sg,ageGenderNet:new ug},cge=(e,t)=>rt.ssdMobilenetv1.locateFaces(e,t),b_e=(e,t)=>rt.tinyFaceDetector.locateFaces(e,t),y_e=(e,t)=>rt.tinyYolov2.locateFaces(e,t),dge=e=>rt.faceLandmark68Net.detectLandmarks(e),x_e=e=>rt.faceLandmark68TinyNet.detectLandmarks(e),v_e=e=>rt.faceRecognitionNet.computeFaceDescriptor(e),w_e=e=>rt.faceExpressionNet.predictExpressions(e),k_e=e=>rt.ageGenderNet.predictAgeAndGender(e),hge=e=>rt.ssdMobilenetv1.load(e),I_e=e=>rt.tinyFaceDetector.load(e),S_e=e=>rt.tinyYolov2.load(e),N_e=e=>rt.faceLandmark68Net.load(e),T_e=e=>rt.faceLandmark68TinyNet.load(e),C_e=e=>rt.faceRecognitionNet.load(e),E_e=e=>rt.faceExpressionNet.load(e),__e=e=>rt.ageGenderNet.load(e),A_e=hge,F_e=cge,$_e=dge;var gg=class extends Oa{constructor(n,a,r){super();this.parentTask=n;this.input=a;this.extractedFaces=r}},pl=class extends gg{async run(){let t=await this.parentTask,n=await ul(t,this.input,async a=>Promise.all(a.map(r=>rt.faceExpressionNet.predictExpressions(r))),this.extractedFaces);return t.map((a,r)=>Nk(a,n[r]))}withAgeAndGender(){return new dl(this,this.input)}},cl=class extends gg{async run(){let t=await this.parentTask;if(!t)return;let n=await Lp(t,this.input,a=>rt.faceExpressionNet.predictExpressions(a),this.extractedFaces);return Nk(t,n)}withAgeAndGender(){return new hl(this,this.input)}},Ps=class extends pl{withAgeAndGender(){return new zs(this,this.input)}withFaceDescriptors(){return new Bs(this,this.input)}},Ls=class extends cl{withAgeAndGender(){return new Ws(this,this.input)}withFaceDescriptor(){return new Vs(this,this.input)}};var bg=class extends Oa{constructor(n,a,r){super();this.parentTask=n;this.input=a;this.extractedFaces=r}},dl=class extends bg{async run(){let t=await this.parentTask,n=await ul(t,this.input,async a=>Promise.all(a.map(r=>rt.ageGenderNet.predictAgeAndGender(r))),this.extractedFaces);return t.map((a,r)=>{let{age:s,gender:i,genderProbability:o}=n[r];return Fk($k(a,i,o),s)})}withFaceExpressions(){return new pl(this,this.input)}},hl=class extends bg{async run(){let t=await this.parentTask;if(!t)return;let{age:n,gender:a,genderProbability:r}=await Lp(t,this.input,s=>rt.ageGenderNet.predictAgeAndGender(s),this.extractedFaces);return Fk($k(t,a,r),n)}withFaceExpressions(){return new cl(this,this.input)}},zs=class extends dl{withFaceExpressions(){return new Ps(this,this.input)}withFaceDescriptors(){return new Bs(this,this.input)}},Ws=class extends hl{withFaceExpressions(){return new Ls(this,this.input)}withFaceDescriptor(){return new Vs(this,this.input)}};var yg=class extends Oa{constructor(n,a){super();this.parentTask=n;this.input=a}},Bs=class extends yg{async run(){let t=await this.parentTask;return(await ul(t,this.input,a=>Promise.all(a.map(r=>rt.faceRecognitionNet.computeFaceDescriptor(r))),null,a=>a.landmarks.align(null,{useDlibAlignment:!0}))).map((a,r)=>Ak(t[r],a))}withFaceExpressions(){return new Ps(this,this.input)}withAgeAndGender(){return new zs(this,this.input)}},Vs=class extends yg{async run(){let t=await this.parentTask;if(!t)return;let n=await Lp(t,this.input,a=>rt.faceRecognitionNet.computeFaceDescriptor(a),null,a=>a.landmarks.align(null,{useDlibAlignment:!0}));return Ak(t,n)}withFaceExpressions(){return new Ls(this,this.input)}withAgeAndGender(){return new Ws(this,this.input)}};var xg=class extends Oa{constructor(n,a,r){super();this.parentTask=n;this.input=a;this.useTinyLandmarkNet=r}get landmarkNet(){return this.useTinyLandmarkNet?rt.faceLandmark68TinyNet:rt.faceLandmark68Net}},vg=class extends xg{async run(){let t=await this.parentTask,n=t.map(i=>i.detection),a=this.input instanceof Ce?await Ld(this.input,n):await Pd(this.input,n),r=await Promise.all(a.map(i=>this.landmarkNet.detectLandmarks(i)));return a.forEach(i=>i instanceof Ce&&i.dispose()),t.filter((i,o)=>r[o]).map((i,o)=>Vd(i,r[o]))}withFaceExpressions(){return new Ps(this,this.input)}withAgeAndGender(){return new zs(this,this.input)}withFaceDescriptors(){return new Bs(this,this.input)}},wg=class extends xg{async run(){let t=await this.parentTask;if(!t)return;let{detection:n}=t,a=this.input instanceof Ce?await Ld(this.input,[n]):await Pd(this.input,[n]),r=await this.landmarkNet.detectLandmarks(a[0]);return a.forEach(s=>s instanceof Ce&&s.dispose()),Vd(t,r)}withFaceExpressions(){return new Ls(this,this.input)}withAgeAndGender(){return new Ws(this,this.input)}withFaceDescriptor(){return new Vs(this,this.input)}};var kg=class extends Oa{constructor(n,a=new Ma){super();this.input=n;this.options=a}},Gd=class extends kg{async run(){let{input:t,options:n}=this,a;if(n instanceof fg)a=rt.tinyFaceDetector.locateFaces(t,n);else if(n instanceof Ma)a=rt.ssdMobilenetv1.locateFaces(t,n);else if(n instanceof yr)a=rt.tinyYolov2.locateFaces(t,n);else throw new Error(\"detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options\");return a}runAndExtendWithFaceDetections(){return new Promise((t,n)=>{this.run().then(a=>t(a.map(r=>wp({},r)))).catch(a=>n(a))})}withFaceLandmarks(t=!1){return new vg(this.runAndExtendWithFaceDetections(),this.input,t)}withFaceExpressions(){return new pl(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new dl(this.runAndExtendWithFaceDetections(),this.input)}},Ig=class extends kg{async run(){let t=await new Gd(this.input,this.options),n=t[0];return t.forEach(a=>{a.score>n.score&&(n=a)}),n}runAndExtendWithFaceDetection(){return new Promise(async t=>{let n=await this.run();t(n?wp({},n):void 0)})}withFaceLandmarks(t=!1){return new wg(this.runAndExtendWithFaceDetection(),this.input,t)}withFaceExpressions(){return new cl(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new hl(this.runAndExtendWithFaceDetection(),this.input)}};function _Ae(e,t=new Ma){return new Ig(e,t)}function Dk(e,t=new Ma){return new Gd(e,t)}async function mge(e,t){return Dk(e,new Ma(t?{minConfidence:t}:{})).withFaceLandmarks().withFaceDescriptors()}async function MAe(e,t={}){return Dk(e,new yr(t)).withFaceLandmarks().withFaceDescriptors()}var OAe=mge;function zD(e,t){if(e.length!==t.length)throw new Error(\"euclideanDistance: arr1.length !== arr2.length\");let n=Array.from(e),a=Array.from(t);return Math.sqrt(n.map((r,s)=>r-a[s]).reduce((r,s)=>r+s*s,0))}var WD=class e{constructor(t,n=.6){this._distanceThreshold=n;let a=Array.isArray(t)?t:[t];if(!a.length)throw new Error(\"FaceRecognizer.constructor - expected atleast one input\");let r=1,s=()=>`person ${r++}`;this._labeledDescriptors=a.map(i=>{if(i instanceof rl)return i;if(i instanceof Float32Array)return new rl(s(),[i]);if(i.descriptor&&i.descriptor instanceof Float32Array)return new rl(s(),[i.descriptor]);throw new Error(\"FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>\")})}get labeledDescriptors(){return this._labeledDescriptors}get distanceThreshold(){return this._distanceThreshold}computeMeanDistance(t,n){return n.map(a=>zD(a,t)).reduce((a,r)=>a+r,0)/(n.length||1)}matchDescriptor(t){return this.labeledDescriptors.map(({descriptors:n,label:a})=>new Dd(a,this.computeMeanDistance(t,n))).reduce((n,a)=>n.distance<a.distance?n:a)}findBestMatch(t){let n=this.matchDescriptor(t);return n.distance<this._distanceThreshold?n:new Dd(\"unknown\",n.distance)}toJSON(){return{distanceThreshold:this._distanceThreshold,labeledDescriptors:this._labeledDescriptors.map(t=>t.toJSON())}}static fromJSON(t){let n=t.labeledDescriptors.map(a=>rl.fromJSON(a));return new e(n,t.distanceThreshold)}};function eFe(e){let t=new zp;return t.extractWeights(e),t}function fge(e,t){let{width:n,height:a}=new aa(t.width,t.height);if(n<=0||a<=0)throw new Error(`resizeResults - invalid dimensions: ${JSON.stringify({width:n,height:a})}`);if(Array.isArray(e))return e.map(r=>fge(r,{width:n,height:a}));if(Fp(e)){let r=e.detection.forSize(n,a),s=e.unshiftedLandmarks.forSize(r.box.width,r.box.height);return Vd(wp(e,r),s)}return zr(e)?wp(e,e.detection.forSize(n,a)):e instanceof ka||e instanceof Ft?e.forSize(n,a):e}var cFe=oD;\n//# sourceMappingURL=face-api.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvQHZsYWRtYW5kaWMvZmFjZS1hcGkvZGlzdC9mYWNlLWFwaS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixXQUFXLEtBQTJCLENBQUMsbUdBQU8sQ0FBQyxDQUFnRyxjQUFjLEdBQUcsSUFBMkIsUUFBUSxtR0FBTyx1QkFBdUIsMkRBQTJELEVBQUUsZUFBZSx1QkFBdUIsdUJBQXVCLEdBQUcsVUFBVSxPQUFPLDRsUkFBNGxSLEVBQUUsbU1BQW1NLFdBQVcsbUNBQW1DLHVCQUF1Qix1QkFBdUIsRUFBRSxnQkFBZ0IsZ0dBQWdHLG1EQUFtRCxFQUFFLFNBQVMsb0NBQW9DLHlDQUF5QyxzQkFBc0Isc0JBQXNCLFlBQVksV0FBVyxJQUFJLHU2QkFBdTZCLFVBQVUsVUFBVSxrQkFBa0IsNkNBQTZDLHVFQUF1RSxTQUFTLEVBQUUsY0FBYyw2QkFBNkIsV0FBVyxRQUFRLE1BQU0sZ0JBQWdCLFVBQVUsa0tBQWtLLFlBQVksZ0JBQWdCLHlCQUF5QixNQUFNLGdCQUFnQixpQkFBaUIsS0FBSyxrQkFBa0IsbUJBQW1CLDBDQUEwQyxlQUFlLGtCQUFrQixvQkFBb0IsYUFBYSxlQUFlLGtCQUFrQiw0Q0FBNEMsd0VBQXdFLG1GQUFtRixNQUFNLHVEQUF1RCw0Q0FBNEMsNEJBQTRCLFdBQVcsTUFBTSw4REFBOEQsUUFBUSxpQkFBaUIsc0JBQXNCLDhCQUE4QixzQkFBc0IsZUFBZSxnQkFBZ0IsNEdBQTRHLGNBQWMsb0RBQW9ELFNBQVMsY0FBYyxVQUFVLFdBQVcsUUFBUSxjQUFjLFNBQVMsWUFBWSxZQUFZLDBCQUEwQixjQUFjLGtCQUFrQix1QkFBdUIsMEJBQTBCLGNBQWMsa0JBQWtCLG1CQUFtQiwyQ0FBMkMsdUJBQXVCLGlGQUFpRix3QkFBd0IsK0NBQStDLDJCQUEyQixvQ0FBb0MsOENBQThDLDJDQUEyQyxzQ0FBc0MsK0NBQStDLEVBQUUsOERBQThELDhCQUE4QixLQUFLLFlBQVksV0FBVyxXQUFXLDBCQUEwQixpQkFBaUIsa0NBQWtDLHFCQUFxQix5QkFBeUIsZ0JBQWdCLGlDQUFpQyxvQkFBb0IsNEJBQTRCLHFFQUFxRSwrQ0FBK0MsZUFBZSxLQUFLLDZCQUE2QixxQkFBcUIsbUNBQW1DLHdDQUF3QyxrQ0FBa0MseUJBQXlCLG1DQUFtQyxvQkFBb0IsdUJBQXVCLHFCQUFxQix1QkFBdUIsc0JBQXNCLDhIQUE4SCx1Q0FBdUMsa0JBQWtCLDJEQUEyRCxzQkFBc0IsK0NBQStDLHVCQUF1QiwwRUFBMEUsc0JBQXNCLHFEQUFxRCx1QkFBdUIsNEVBQTRFLHNDQUFzQyx5Q0FBeUMsOElBQThJLHNDQUFzQyxxREFBcUQsa0NBQWtDLGVBQWUsb0pBQW9KLHdKQUF3Six3QkFBd0Isd0NBQXdDLHlDQUF5QywwQkFBMEIscUJBQXFCLDZDQUE2Qyx1Q0FBdUMsdUJBQXVCLG1DQUFtQyxtQ0FBbUMsMkZBQTJGLGlEQUFpRCw0RUFBNEUscUpBQXFKLGtRQUFrUSx1Q0FBdUMsNkRBQTZELE1BQU0sZ0ZBQWdGLHVFQUF1RSx1Q0FBdUMsMENBQTBDLFVBQVUsa0JBQWtCLHNEQUFzRCwrQkFBK0IsSUFBSSxLQUFLLGVBQWUsNkJBQTZCLG9CQUFvQixrQkFBa0IsK0ZBQStGLHlDQUF5QywyRkFBMkYsaURBQWlELElBQUksV0FBVyxTQUFTLEVBQUUsb0RBQW9ELGlGQUFpRiwwQkFBMEIsdUNBQXVDLHlDQUF5QyxTQUFTLHFDQUFxQyxxQkFBcUIsdUVBQXVFLHVDQUF1QyxvQ0FBb0MsZ0RBQWdELDZDQUE2QyxtQkFBbUIsdUVBQXVFLGtCQUFrQix1RUFBdUUsbUJBQW1CLHVFQUF1RSx5QkFBeUIsNklBQTZJLDRDQUE0QywrSkFBK0oscURBQXFELCtDQUErQyxnQkFBZ0IsU0FBUyxlQUFlLDRDQUE0QyxvRUFBb0UsZ0ZBQWdGLG1EQUFtRCx5QkFBeUIsbURBQW1ELHVCQUF1QiwyQ0FBMkMsd0JBQXdCLDJCQUEyQiw0RUFBNEUsd0JBQXdCLDJCQUEyQiw0RUFBNEUsNkJBQTZCLCtDQUErQyw2QkFBNkIsOEVBQThFLDZCQUE2QiwrRUFBK0UsY0FBYyxjQUFjLGdCQUFnQixpQkFBaUIsY0FBYyxpQkFBaUIsa0JBQWtCLDZDQUE2Qyw0Q0FBNEMseUlBQXlJLGdCQUFnQiwrQ0FBK0MsZ0JBQWdCLHFDQUFxQywwQkFBMEIsNkJBQTZCLHFCQUFxQixpREFBaUQsNkRBQTZELGFBQWEsRUFBRSxJQUFJLGFBQWEsK0JBQStCLFlBQVksWUFBWSxXQUFXLEtBQUssbUJBQW1CLDJCQUEyQiwrQ0FBK0MscUNBQXFDLFNBQVMsK0NBQStDLFNBQVMsY0FBYyw2REFBNkQsZ0JBQWdCLGlCQUFpQixjQUFjLGdCQUFnQiwwQ0FBMEMsa0JBQWtCLHFEQUFxRCxzQkFBc0IsWUFBWSxjQUFjLG9DQUFvQyxnQkFBZ0IseUNBQXlDLGdCQUFnQix5Q0FBeUMsaUNBQWlDLDJCQUEyQixtRUFBbUUsYUFBYSxTQUFTLDRFQUE0RSxhQUFhLEVBQUUsSUFBSSwrQ0FBK0MsU0FBUyxnQkFBZ0IsNkRBQTZELGdCQUFnQixpQkFBaUIsY0FBYyxnQkFBZ0Isa0JBQWtCLGtCQUFrQixzRkFBc0Ysb0RBQW9ELFlBQVksY0FBYyx1RUFBdUUsZ0JBQWdCLHlEQUF5RCxnQkFBZ0IseUNBQXlDLGlDQUFpQywyQkFBMkIsbUVBQW1FLGFBQWEsU0FBUyw0RUFBNEUsYUFBYSxFQUFFLElBQUksK0NBQStDLFNBQVMsZ0JBQWdCLDZEQUE2RCxnQkFBZ0IsaUJBQWlCLGNBQWMsV0FBVyxrQkFBa0Isc0JBQXNCLHNKQUFzSixnQkFBZ0IsYUFBYSxzQkFBc0Isb0JBQW9CLFdBQVcsbURBQW1ELEtBQUssV0FBVyxXQUFXLFFBQVEsY0FBYyxLQUFLLDRDQUE0QyxJQUFJLGFBQWEsT0FBTyxnQkFBZ0IsaUNBQWlDLGdCQUFnQix1QkFBdUIseUNBQXlDLGlDQUFpQywyQkFBMkIsbUVBQW1FLGFBQWEsU0FBUyw2REFBNkQsYUFBYSxFQUFFLElBQUksK0NBQStDLFNBQVMsbUJBQW1CLDZEQUE2RCxnQkFBZ0IsaUJBQWlCLGNBQWMsV0FBVyxrQkFBa0IsMEJBQTBCLGdJQUFnSSxnQkFBZ0IseUJBQXlCLDJFQUEyRSxJQUFJLGtKQUFrSix1REFBdUQsSUFBSSxnRkFBZ0Ysa0JBQWtCLE9BQU8sZ0JBQWdCLHlDQUF5QyxnQkFBZ0IsdUJBQXVCLHlDQUF5QyxpQ0FBaUMsMkJBQTJCLG1FQUFtRSxhQUFhLFNBQVMsNkRBQTZELGFBQWEsRUFBRSxJQUFJLCtDQUErQyxTQUFTLGlCQUFpQiw2REFBNkQsZ0JBQWdCLGlCQUFpQixjQUFjLGdCQUFnQixrQkFBa0IsNEJBQTRCLHFIQUFxSCxnR0FBZ0csWUFBWSxjQUFjLG9DQUFvQyxnQkFBZ0IseUNBQXlDLGdCQUFnQix5Q0FBeUMsaUNBQWlDLDJCQUEyQixtRUFBbUUsYUFBYSxTQUFTLDRFQUE0RSxhQUFhLEVBQUUsSUFBSSwrQ0FBK0MsU0FBUyxnQkFBZ0IsNkRBQTZELGNBQWMsZ0JBQWdCLGlCQUFpQixzRUFBc0Usa0JBQWtCLFNBQVMsU0FBUyxXQUFXLE9BQU8seUVBQXlFLHlCQUF5QixJQUFJLHlCQUF5QixLQUFLLEtBQUssa0JBQWtCLGVBQWUsMEJBQTBCLGdCQUFnQixvQkFBb0IseUJBQXlCLHNEQUFzRCwwQ0FBMEMsYUFBYSxFQUFFLGlCQUFpQiw2Q0FBNkMsY0FBYyxpREFBaUQsaUJBQWlCLElBQUksVUFBVSxRQUFRLElBQUkseUNBQXlDLGlCQUFpQixnQ0FBZ0MsSUFBSSxvREFBb0QscUJBQXFCLEtBQUssZ0JBQWdCLHlDQUF5QyxnQkFBZ0Isc0JBQXNCLGlDQUFpQyxvQkFBb0IsVUFBVSx1Q0FBdUMsZ0JBQWdCLHFCQUFxQixXQUFXLDJDQUEyQyxZQUFZLGFBQWEsSUFBSSxNQUFNLHdHQUF3RyxTQUFTLGlDQUFpQyxxQ0FBcUMsY0FBYyxzQ0FBc0Msa0RBQWtELFlBQVksSUFBSSxPQUFPLFdBQVcsZ0NBQWdDLHdCQUFVLG1CQUFtQixTQUFTLGdCQUFnQiwyQ0FBMkMsZ0JBQWdCLHFEQUFxRCxnRkFBZ0YsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsZ0JBQWdCLFlBQVksNkZBQTZGLE9BQU8sS0FBOEIsUUFBUSxVQUFVLGNBQWMsUUFBUSxhQUFhLHVDQUF1QyxhQUFhLHVDQUF1QyxhQUFhLHVDQUF1QyxhQUFhLHVDQUF1QyxhQUFhLHVDQUF1QyxhQUFhLHVDQUF1QyxhQUFhLHVDQUF1QyxnQ0FBZ0MsS0FBSyxrQ0FBa0MsUUFBUSxFQUFFLE1BQU0sT0FBTyxPQUFPLGVBQWUsT0FBTyxnQkFBZ0Isa0JBQWtCLE9BQU8sbURBQW1ELE9BQU8saUNBQWlDLEVBQUUsc0JBQXNCLHNDQUFzQyxRQUFRLHVFQUF1RSxPQUFPLG1CQUFtQixPQUFPLDRCQUE0QixPQUFPLDZEQUE2RCxjQUFjLDBDQUEwQyxZQUFZLGNBQWMsbURBQW1ELE1BQU0sa0JBQWtCLHVCQUF1QixTQUFTLDRGQUE0RixlQUFlLDZDQUE2QyxlQUFlLCtEQUErRCx3QkFBd0IsRUFBRSxDQUFDLE9BQU8sbUJBQW1CLE9BQU8sK0JBQStCLE9BQU8sZUFBZSxPQUFPLG9DQUFvQyw4QkFBOEIsRUFBRSxPQUFPLHFDQUFxQyxRQUFRLGFBQWEsY0FBYyxPQUFPLGVBQWUsTUFBTSxPQUFPLFNBQVMsc0JBQXNCLG9DQUFvQyxNQUFNLElBQUksT0FBTyxTQUFTLGlJQUFpSSxxQkFBTSxpQkFBaUIsdVBBQXVQLHlCQUF5QixzREFBc0QsV0FBVyx5QkFBeUIsK0ZBQStGLGVBQWUsMEJBQTBCLGlFQUFpRSw4Q0FBOEMsZUFBZSxPQUFPLEtBQUssNkJBQTZCLHlCQUF5QixxQ0FBcUMscUJBQU0sK0JBQStCLDZEQUE2RDtBQUN4cjVCO0FBQ0EsSUFBSSxpQ0FBaUMsMkdBQTJHLHdFQUF3RSxnQ0FBZ0MsMkJBQTJCLG9FQUFvRSxtQkFBbUIsaUJBQWlCLFNBQVMsc0VBQXNFLG9CQUFvQixPQUFPLHFCQUFxQixpQkFBaUIsTUFBTSxnSEFBZ0gsY0FBYyxLQUFLLEVBQUUsY0FBYyxjQUFjLDRCQUE0QixTQUFTLGlCQUFpQixrQkFBa0IsdUNBQXVDLFNBQVMsaUJBQWlCLG1IQUFtSCxLQUFLLGdCQUFnQixxREFBcUQsVUFBVSxpQkFBaUIsK0JBQStCLHVCQUF1Qiw0QkFBNEIsOEJBQThCLFlBQVksTUFBTSx3QkFBd0IseUJBQXlCLDBCQUEwQixpQ0FBaUMsWUFBWSxnQkFBZ0IsZUFBZSxrQkFBa0Isa0JBQWtCLDRDQUE0QyxtQkFBbUIsa0JBQWtCLHNFQUFzRSxLQUFLLGtCQUFrQixpR0FBaUcseUJBQXlCLG9CQUFvQixzQkFBc0IsK0JBQStCLGlCQUFpQixlQUFlLDZQQUE2UCxrQ0FBa0MsaUNBQWlDLHFDQUFxQyxtQ0FBbUMseUNBQXlDLHlaQUF5WiwyQ0FBMkMsK0JBQStCLGNBQWMsVUFBVSxjQUFjLG1FQUFtRSxnQkFBZ0Isc0JBQXNCLE9BQU8sY0FBYyxpQkFBaUIsY0FBYyxPQUFPLHVFQUF1RSxpQkFBaUIsdUJBQXVCLFFBQVEsZUFBZSxjQUFjLGVBQWUsY0FBYyxlQUFlLGNBQWMseUJBQXlCLGVBQWUsNERBQTRELGVBQWUsbUhBQW1ILFNBQVMsYUFBYSxlQUFlLHlHQUF5RyxzQ0FBc0MsYUFBYSxzQ0FBc0MsU0FBUyxlQUFlLHdCQUF3QixlQUFlLCtCQUErQixPQUFPLDZEQUE2RCxlQUFlLElBQUksdUNBQXVDLGlCQUFpQix1REFBdUQsU0FBUyxPQUFPLGNBQWMsZ0JBQWdCLHNEQUFzRCwwQkFBMEIsbUJBQW1CLDREQUE0RCx1QkFBdUIsbUJBQW1CLGNBQWMsRUFBRSxzQ0FBc0Msa0JBQWtCLHNCQUFzQixJQUFJLEVBQUUseUNBQXlDLGNBQWMsRUFBRSxjQUFjLE9BQU8sa0NBQWtDLGtCQUFrQixrQkFBa0Isb0hBQW9ILCtCQUErQixzQ0FBc0Msd0NBQXdDLDZCQUE2QixFQUFFLEdBQUcsMEJBQTBCLGdCQUFnQix5QkFBeUIsZ0JBQWdCLDhCQUE4QixxQ0FBcUMsb0JBQW9CLFVBQVUsdUJBQXVCLHVEQUF1RCxFQUFFLGNBQWMseUhBQXlILDBCQUEwQixvQkFBb0IsOENBQThDLCtCQUErQixxR0FBcUcsRUFBRSxTQUFTLHlCQUF5Qiw4QkFBOEIsVUFBVSxVQUFVLGtFQUFrRSx3QkFBd0IsZ0JBQWdCLGVBQWUsd0ZBQXdGLGVBQWUscUJBQXFCLG1IQUFtSCxlQUFlLHFCQUFxQixlQUFlLGFBQWEsRUFBRSxlQUFlLHFCQUFxQiwrQkFBK0IsZUFBZSx3QkFBd0IsZUFBZSxtRkFBbUYsUUFBUSw0RUFBNEUseUJBQXlCLGdFQUFnRSw0QkFBNEIsUUFBUSw4QkFBOEIsY0FBYyw0QkFBNEIsU0FBUyxvQkFBb0IsWUFBWSxXQUFXLGVBQWUsc0JBQXNCLGlGQUFpRixpQkFBaUIsbUNBQW1DLE1BQU0sVUFBVSxlQUFlLDBDQUEwQyxPQUFPLFFBQVEsa0VBQWtFLGlCQUFpQixzQ0FBc0MsMkJBQTJCLFlBQVksSUFBSSwyQkFBMkIsdUJBQXVCLE1BQU0sMkJBQTJCLEtBQUssZ0NBQWdDLGlFQUFpRSw0Q0FBNEMsb0JBQW9CLGdDQUFnQyxvQkFBb0IsMklBQTJJLG9DQUFvQywwQkFBMEIsb0NBQW9DLHNDQUFzQyxpQkFBaUIseUJBQXlCLGlIQUFpSCxvQ0FBb0MsaU5BQWlOLE9BQU8sMGtCQUEwa0IsZ0JBQWdCLCtCQUErQiw2REFBNkQsaUNBQWlDLGFBQWEsUUFBUSxFQUFFLDRCQUE0QixjQUFjLGtDQUFrQyxHQUFHLHFEQUFxRCxtREFBbUQsZUFBZSxzRkFBc0YsRUFBRSxpQ0FBaUMsdURBQXVELHlDQUF5Qyx5QkFBeUIsdUlBQXVJLGFBQWEsZUFBZSxLQUFLLFdBQVcsY0FBYyxjQUFjLG9EQUFvRCxlQUFlLHlCQUF5QixlQUFlLHNCQUFzQixJQUFJLE1BQU0sU0FBUyxPQUFPLFVBQVUsZUFBZSxZQUFZLDhEQUE4RCxpQkFBaUIsZ0JBQWdCLGlDQUFpQyxzQkFBc0IsZUFBZSw0QkFBNEIsZUFBZSxpQ0FBaUMsZUFBZSxlQUFlLDZCQUE2QixRQUFRLHVCQUF1Qix5Q0FBeUMsdUJBQXVCLDJJQUEySSxlQUFlLCtDQUErQyxnQkFBZ0IsUUFBUSxzREFBc0QsNERBQTRELGNBQWMsYUFBYSxVQUFVLGNBQWMsVUFBVSxlQUFlLDRFQUE0RSxrQ0FBa0MsdUJBQXVCLCtCQUErQix1QkFBdUIsbURBQW1ELEVBQUUsS0FBSyxzQkFBc0IsY0FBYyxnQkFBZ0Isb0NBQW9DLEVBQUUsU0FBUyxvQkFBb0IsU0FBUyxjQUFjLE9BQU8sZUFBZSxzQkFBc0IseURBQXlELGNBQWMscUpBQXFKLGNBQWMsa0JBQWtCLGNBQWMsa0JBQWtCLGNBQWMsWUFBWSxPQUFPLFVBQVUsTUFBTSxPQUFPLFVBQVUseUJBQXlCLGlEQUFpRCxvQkFBb0IscUNBQXFDLGNBQWMsMERBQTBELGVBQWUsa0JBQWtCLGdCQUFnQixpQkFBaUIsdUNBQXVDLGVBQWUsd0NBQXdDLE1BQU0sTUFBTSxnQkFBZ0Isa0JBQWtCLHFCQUFxQixFQUFFLFVBQVUsb0JBQW9CLFlBQVksc0JBQXNCLEtBQUssMkJBQTJCLGdDQUFnQyx5QkFBeUIsZUFBZSxJQUFJLDJEQUEyRCxXQUFXLGVBQWUsaUJBQWlCLHlCQUF5QixZQUFZLGlCQUFpQixpQ0FBaUMsYUFBYSxNQUFNLE9BQU8sbUJBQW1CLDRCQUE0Qix1REFBdUQsZUFBZSxTQUFTLGNBQWMsY0FBYyxlQUFlLHNCQUFzQiwwQkFBMEIsaUNBQWlDLG9CQUFvQixpQkFBaUIsYUFBYSw2REFBNkQsdUJBQXVCLDhCQUE4QixrQkFBa0IsTUFBTSxNQUFNLGtDQUFrQyxLQUFLLGFBQWEsTUFBTSwwQkFBMEIsT0FBTyx3QkFBd0IsZUFBZSxlQUFlLFNBQVMsaUJBQWlCLGlCQUFpQiwwQkFBMEIsUUFBUSxZQUFZLFNBQVMscUJBQXFCLHdCQUF3Qix1QkFBdUIsVUFBVSxZQUFZLHFCQUFxQixzQkFBc0IsZ0JBQWdCLGlEQUFpRCx3QkFBd0IsbUJBQW1CLGFBQWEsTUFBTSxrQkFBa0IsdURBQXVELHlCQUF5QixnQkFBZ0IsNkJBQTZCLG9CQUFvQix1QkFBdUIsVUFBVSxtRUFBbUUsb0NBQW9DLGdDQUFnQyxVQUFVLG9DQUFvQywya0JBQTJrQiw0Q0FBNEMsOEVBQThFLHVCQUF1QixvREFBb0QsMENBQTBDLDBGQUEwRixvQ0FBb0MsOEVBQThFLGtDQUFrQywwRUFBMEUsK0JBQStCLG9FQUFvRSwwQkFBMEIsMERBQTBELHNCQUFzQixrREFBa0QsdUJBQXVCLG9EQUFvRCx3QkFBd0Isc0RBQXNELHNCQUFzQixrREFBa0QsdUJBQXVCLG9EQUFvRCxzQkFBc0Isa0RBQWtELHNCQUFzQixrREFBa0QseUJBQXlCLHdEQUF3RCx5QkFBeUIsd0RBQXdELHVCQUF1QixvREFBb0Qsd0JBQXdCLHNEQUFzRCx1QkFBdUIsb0RBQW9ELHdCQUF3QixzREFBc0Qsd0JBQXdCLHNEQUFzRCwwQkFBMEIsMERBQTBELDRCQUE0Qiw4REFBOEQsZ0NBQWdDLHNFQUFzRSw4QkFBOEIsa0VBQWtFLDhCQUE4QixrRUFBa0UsMkJBQTJCLDREQUE0RCw2QkFBNkIsZ0VBQWdFLHVCQUF1QixvREFBb0QsOEJBQThCLGtFQUFrRSx5QkFBeUIsd0RBQXdELHNDQUFzQyxrRkFBa0YseUJBQXlCLHdEQUF3RCx5Q0FBeUMsd0ZBQXdGLHdDQUF3QyxzRkFBc0Ysc0JBQXNCLGtEQUFrRCx1QkFBdUIsb0RBQW9ELGdDQUFnQyxzRUFBc0UsMEJBQTBCLDBEQUEwRCx5QkFBeUIsd0RBQXdELGdDQUFnQyxzRUFBc0UsK0JBQStCLG9FQUFvRSx3Q0FBd0Msc0ZBQXNGLHVCQUF1QixvREFBb0QsNkJBQTZCLGdFQUFnRSwyQ0FBMkMsNEZBQTRGLDBDQUEwQywwRkFBMEYsc0JBQXNCLGtEQUFrRCwwQkFBMEIsMERBQTBELHdCQUF3QixzREFBc0Qsc0JBQXNCLGtEQUFrRCxzQkFBc0Isa0RBQWtELHdCQUF3QixzREFBc0QsZ0NBQWdDLHNFQUFzRSx3QkFBd0Isc0RBQXNELDJCQUEyQiw0REFBNEQsaUNBQWlDLHdFQUF3RSw4QkFBOEIsa0VBQWtFLHVDQUF1QyxvRkFBb0YseUJBQXlCLHdEQUF3RCwyQkFBMkIsNERBQTRELDBCQUEwQiwwREFBMEQsK0JBQStCLG9FQUFvRSwyQkFBMkIsNERBQTRELHdCQUF3QixzREFBc0Qsd0JBQXdCLHNEQUFzRCxzQkFBc0Isa0RBQWtELDBCQUEwQiwwREFBMEQsNEJBQTRCLDhEQUE4RCx1QkFBdUIsb0RBQW9ELDRCQUE0Qiw4REFBOEQsMkJBQTJCLDREQUE0RCxzQkFBc0Isa0RBQWtELHdCQUF3QixzREFBc0QsNkJBQTZCLGdFQUFnRSw2QkFBNkIsZ0VBQWdFLDRCQUE0Qiw4REFBOEQsNkJBQTZCLGdFQUFnRSxzQkFBc0Isa0RBQWtELDBCQUEwQiwwREFBMEQsNEJBQTRCLDhEQUE4RCxnQ0FBZ0Msc0VBQXNFLDhCQUE4QixrRUFBa0Usb0NBQW9DLDhFQUE4RSwwQkFBMEIsMERBQTBELHVCQUF1QixvREFBb0Qsc0JBQXNCLGtEQUFrRCwwQkFBMEIsMERBQTBELDRCQUE0Qiw4REFBOEQsc0JBQXNCLGtEQUFrRCw4QkFBOEIsa0VBQWtFLDJCQUEyQiw0REFBNEQsc0JBQXNCLGtEQUFrRCxzQ0FBc0Msa0ZBQWtGLHNDQUFzQyxrRkFBa0Ysc0NBQXNDLGtGQUFrRiwyQkFBMkIsNERBQTRELHlCQUF5Qix3REFBd0Qsd0JBQXdCLHNEQUFzRCxzQkFBc0Isa0RBQWtELHdCQUF3QixzREFBc0QsdUJBQXVCLG9EQUFvRCwwQkFBMEIsMERBQTBELDZCQUE2QixnRUFBZ0UsdUJBQXVCLG9EQUFvRCx1QkFBdUIscURBQXFELGlDQUFpQyx3RUFBd0UscUNBQXFDLGdGQUFnRix3Q0FBd0Msc0ZBQXNGLDRDQUE0Qyw4RkFBOEYsMEJBQTBCLDBEQUEwRCxtQ0FBbUMsNEVBQTRFLHdCQUF3QixzREFBc0Qsd0JBQXdCLHNEQUFzRCw0QkFBNEIsOERBQThELCtCQUErQixvRUFBb0UsMkJBQTJCLDREQUE0RCx1QkFBdUIsb0RBQW9ELDBCQUEwQiwwREFBMEQsdUJBQXVCLG9EQUFvRCxzQkFBc0Isa0RBQWtELHVCQUF1QixvREFBb0QsMEJBQTBCLDBEQUEwRCwyQkFBMkIsNERBQTRELHNDQUFzQyxrRkFBa0YsZ0NBQWdDLHNFQUFzRSx5Q0FBeUMsd0ZBQXdGLGdDQUFnQyxzRUFBc0UsdUJBQXVCLG9EQUFvRCx5QkFBeUIsd0RBQXdELG9DQUFvQyw4RUFBOEUsdUJBQXVCLG9EQUFvRCwrQkFBK0Isb0VBQW9FLHNCQUFzQixrREFBa0Qsc0JBQXNCLGtEQUFrRCxzQkFBc0Isa0RBQWtELHVCQUF1QixvREFBb0Qsc0NBQXNDLGtGQUFrRix1QkFBdUIsb0RBQW9ELHVCQUF1QixvREFBb0QsNEJBQTRCLDhEQUE4RCw0QkFBNEIsOERBQThELCtCQUErQixvRUFBb0UseUJBQXlCLHdEQUF3RCx1QkFBdUIsb0RBQW9ELHVDQUF1QyxvRkFBb0YsK0JBQStCLG9FQUFvRSxtQ0FBbUMsNEVBQTRFLDBDQUEwQywwRkFBMEYsNkNBQTZDLGdHQUFnRyw4REFBOEQsa0lBQWtJLG9EQUFvRCw4R0FBOEcsMkRBQTJELDRIQUE0SCxpREFBaUQsd0dBQXdHLHVEQUF1RCxvSEFBb0gsK0NBQStDLG9HQUFvRywwQ0FBMEMsMEZBQTBGLDhDQUE4QyxrR0FBa0csMkJBQTJCLDZEQUE2RCw4QkFBOEIsbUVBQW1FLDRCQUE0QiwrREFBK0Qsa0NBQWtDLDJFQUEyRSw4QkFBOEIsb0VBQW9FLDhFQUE4RSxPQUFPLGdCQUFnQixxQkFBcUIsZUFBZSxzQkFBc0IsTUFBTSx5QkFBeUIsT0FBTyxvQkFBb0IsYUFBYSxrR0FBa0csNkRBQTZELHNCQUFzQixnQkFBZ0IsUUFBUSxTQUFTLHVFQUF1RSxtQkFBbUIsbUJBQW1CLEtBQUssT0FBTyxRQUFRLGtCQUFrQixPQUFPLG1EQUFtRCx5Q0FBeUMscUJBQXFCLE9BQU8sb0RBQW9ELDBDQUEwQyxFQUFFLEVBQUUsT0FBTyw4REFBOEQsbUNBQW1DLDhEQUE4RCxPQUFPLG1CQUFtQix1QkFBdUIsOENBQThDLE9BQU8sdUNBQXVDLDRDQUE0QyxPQUFPLHdDQUF3QyxHQUFHLGdCQUFnQixJQUFJLDhFQUE4RSx3QkFBVSxzQkFBc0IsU0FBUywwREFBMEQsZ0JBQWdCLDJDQUEyQyxjQUFjLDRIQUE0SCx3QkFBd0IsZ0RBQWdELDRDQUE0Qyx5Q0FBeUMsVUFBVSxHQUFHLHFCQUFxQixzQkFBc0Isb0RBQW9ELGdCQUFnQiwyREFBMkQsdURBQXVELDJCQUEyQiw0QkFBNEIsa0NBQWtDLGVBQWUsb0JBQW9CLEVBQUUsd0JBQXdCLHFDQUFxQywwQkFBMEIseURBQXlELHdCQUF3QjtBQUN6ZzlCLEdBQUcsT0FBTyxvQkFBb0IsdUJBQXVCLHlEQUF5RCxhQUFhLHlEQUF5RCxFQUFFLHVCQUF1Qix1QkFBdUIsbURBQW1ELGlFQUFpRSwwQkFBMEIsMEJBQTBCLHlCQUF5Qiw4QkFBOEIsbUJBQW1CLDRCQUE0QixnQkFBZ0IsYUFBYSxlQUFlLEdBQUcsbUJBQW1CLElBQUksd0JBQXdCLHVDQUF1QyxzQ0FBc0MsMkJBQTJCLGFBQWEsc0RBQXNELEdBQUcsdUNBQXVDLDZDQUE2QyxzQ0FBc0Msc0NBQXNDLGdDQUFnQyxLQUFLLG9EQUFvRCx5QkFBeUIsK0JBQStCLHNDQUFzQyw0QkFBNEIsNkRBQTZELGdDQUFnQyxnREFBZ0Qsa0NBQWtDLG1CQUFtQiw4Q0FBOEMsOENBQThDLEVBQUUsaUNBQWlDLG1CQUFtQixJQUFJLDREQUE0RCxVQUFVLGlCQUFpQix1Q0FBdUMsa0NBQWtDLEtBQUssK0NBQStDLEtBQUssWUFBWSwrQkFBK0IsOEJBQThCLHdDQUF3Qyx5Q0FBeUMsNkNBQTZDLGtCQUFrQixxREFBcUQsS0FBSyxrREFBa0Qsb0JBQW9CLHNEQUFzRCxhQUFhLFVBQVUsMENBQTBDLHdDQUF3QyxXQUFXLEVBQUUsZ0JBQWdCLFlBQVksNkZBQTZGLE9BQU8sS0FBOEIsUUFBUSxVQUFVLGNBQWMsUUFBUSxnQ0FBZ0MsS0FBSyxtQ0FBbUMsU0FBUyxFQUFFLE1BQU0sT0FBTyxPQUFPLGVBQWUsT0FBTyxnQkFBZ0Isa0JBQWtCLE9BQU8sbURBQW1ELE9BQU8saUNBQWlDLEVBQUUsc0JBQXNCLHVDQUF1QyxTQUFTLHVFQUF1RSxPQUFPLG1CQUFtQixPQUFPLDRCQUE0QixPQUFPLDhCQUE4QixjQUFjLDBDQUEwQyxZQUFZLGNBQWMsbURBQW1ELE1BQU0sa0JBQWtCLHVCQUF1QixTQUFTLDRGQUE0RixlQUFlLDZDQUE2QyxlQUFlLCtEQUErRCx3QkFBd0IsRUFBRSxDQUFDLE9BQU8sbUJBQW1CLE9BQU8sK0JBQStCLE9BQU8sZUFBZSxPQUFPLG9DQUFvQyw4QkFBOEIsRUFBRSxPQUFPLHFDQUFxQyxRQUFRLGFBQWEsY0FBYyxPQUFPLGVBQWUsTUFBTSxPQUFPLFNBQVMsc0JBQXNCLG9DQUFvQyw0TkFBNE4sMEJBQTBCLHlEQUF5RCxXQUFXLDBCQUEwQixtR0FBbUcsZ0JBQWdCLDBCQUEwQixpRUFBaUUsOENBQThDLGdCQUFnQixPQUFPLEtBQUssNkJBQTZCLHdCQUF3QixrRkFBa0YsMkdBQTJHLFVBQVUsK0JBQStCLDBCQUEwQixvRUFBb0UsYUFBYSxpQkFBaUIsVUFBVSxxRUFBcUUsb0JBQW9CLFFBQVEsdUJBQXVCLGlCQUFpQixNQUFNLDREQUE0RCxjQUFjLE1BQU0sRUFBRSxlQUFlLGNBQWMsNEJBQTRCLFNBQVMsa0JBQWtCLGtCQUFrQix1Q0FBdUMsU0FBUyxrQkFBa0Isb0hBQW9ILEtBQUssZ0JBQWdCLHFEQUFxRCxVQUFVLGlCQUFpQiw4QkFBOEIsd0JBQXdCLDRCQUE0Qiw4QkFBOEIsWUFBWSxNQUFNLHdCQUF3Qix5QkFBeUIsMEJBQTBCLGlDQUFpQyxZQUFZLGdCQUFnQixnQkFBZ0Isa0JBQWtCLGtCQUFrQiw4Q0FBOEMsbUJBQW1CLGtCQUFrQix5RUFBeUUsS0FBSyxrQkFBa0IscUdBQXFHLDBCQUEwQixxQkFBcUIsc0JBQXNCLCtCQUErQixlQUFlLDZQQUE2UCw2REFBNkQsY0FBYyxTQUFTLGNBQWMsbUVBQW1FLGdCQUFnQixzQkFBc0IsT0FBTyxjQUFjLGFBQWEsY0FBYyx1RUFBdUUsaUJBQWlCLHVCQUF1QixPQUFPLGVBQWUsY0FBYyxlQUFlLGNBQWMsZUFBZSxjQUFjLHlCQUF5QixlQUFlLDREQUE0RCxlQUFlLG1IQUFtSCxVQUFVLGNBQWMsZUFBZSx1R0FBdUcsdUNBQXVDLGVBQWUsc0NBQXNDLFNBQVMsZUFBZSx3QkFBd0IsZUFBZSwrQkFBK0IsT0FBTywrQ0FBK0MsZUFBZSxJQUFJLHFDQUFxQyxpQkFBaUIsdURBQXVELFVBQVUsUUFBUSxjQUFjLGVBQWUsc0RBQXNELDBCQUEwQixtQkFBbUIsNERBQTRELHVCQUF1QixtQkFBbUIsY0FBYyxFQUFFLHVDQUF1QyxrQkFBa0Isc0JBQXNCLEtBQUssRUFBRSx5Q0FBeUMsY0FBYyxFQUFFLGNBQWMsT0FBTyxrQ0FBa0MsbUJBQW1CLGtCQUFrQiwySEFBMkgsdUJBQXVCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLDhCQUE4QixxQ0FBcUMsb0JBQW9CLFVBQVUsdUJBQXVCLHVEQUF1RCxFQUFFLGNBQWMsd0hBQXdILDBCQUEwQixvQkFBb0IsOENBQThDLCtCQUErQixxR0FBcUcsRUFBRSxTQUFTLHlCQUF5QiwrQkFBK0IsVUFBVSxVQUFVLGtFQUFrRSx3QkFBd0IsVUFBVSxlQUFlLHdGQUF3RixlQUFlLEtBQUssV0FBVyxjQUFjLGNBQWMsT0FBTyxjQUFjLGtCQUFrQixjQUFjLFlBQVkscUJBQXFCLHNDQUFzQyxlQUFlLElBQUkseURBQXlELFlBQVksZUFBZSxpQkFBaUIsUUFBUSxZQUFZLGlCQUFpQixpQ0FBaUMsYUFBYSxNQUFNLE9BQU8sb0JBQW9CLDRCQUE0Qix1REFBdUQsZUFBZSxTQUFTLFFBQVEsOEJBQThCLGNBQWMsMkJBQTJCLFNBQVMsb0JBQW9CLFlBQVksWUFBWSxlQUFlLFVBQVUsMkJBQTJCLFVBQVUsb0JBQW9CLGtCQUFrQixhQUFhLCtEQUErRCx3QkFBd0Isa0JBQWtCLE1BQU0sTUFBTSxrQ0FBa0MsTUFBTSxhQUFhLE1BQU0seUJBQXlCLE9BQU8sdUJBQXVCLGVBQWUsZ0JBQWdCLFVBQVUsa0JBQWtCLGlCQUFpQiwyQkFBMkIsUUFBUSxZQUFZLFNBQVMscUJBQXFCLHdCQUF3Qix1QkFBdUIsVUFBVSxZQUFZLHFCQUFxQixzQkFBc0IsZ0JBQWdCLGtEQUFrRCx3QkFBd0IsbUJBQW1CLGFBQWEsTUFBTSxrQkFBa0IsdURBQXVELHlCQUF5QixnQkFBZ0IsNkJBQTZCLG9CQUFvQix3QkFBd0IsVUFBVSxvRUFBb0Usb0NBQW9DLGlDQUFpQyxRQUFRLDBIQUEwSCw0Q0FBNEMsOEVBQThFLHVCQUF1QixvREFBb0QsMENBQTBDLDBGQUEwRixvQ0FBb0MsOEVBQThFLGtDQUFrQywwRUFBMEUsK0JBQStCLG9FQUFvRSwwQkFBMEIsMERBQTBELHNCQUFzQixrREFBa0QsdUJBQXVCLG9EQUFvRCx3QkFBd0Isc0RBQXNELHNCQUFzQixrREFBa0QsdUJBQXVCLG9EQUFvRCxzQkFBc0Isa0RBQWtELHNCQUFzQixrREFBa0QseUJBQXlCLHdEQUF3RCx5QkFBeUIsd0RBQXdELHVCQUF1QixvREFBb0Qsd0JBQXdCLHNEQUFzRCx1QkFBdUIsb0RBQW9ELHdCQUF3QixzREFBc0Qsd0JBQXdCLHNEQUFzRCwwQkFBMEIsMERBQTBELDRCQUE0Qiw4REFBOEQsZ0NBQWdDLHNFQUFzRSw4QkFBOEIsa0VBQWtFLDhCQUE4QixrRUFBa0UsMkJBQTJCLDREQUE0RCw2QkFBNkIsZ0VBQWdFLHVCQUF1QixvREFBb0QsOEJBQThCLGtFQUFrRSx5QkFBeUIsd0RBQXdELHNDQUFzQyxrRkFBa0YseUJBQXlCLHdEQUF3RCx5Q0FBeUMsd0ZBQXdGLHdDQUF3QyxzRkFBc0Ysc0JBQXNCLGtEQUFrRCx1QkFBdUIsb0RBQW9ELGdDQUFnQyxzRUFBc0UsMEJBQTBCLDBEQUEwRCx5QkFBeUIsd0RBQXdELGdDQUFnQyxzRUFBc0UsK0JBQStCLG9FQUFvRSx3Q0FBd0Msc0ZBQXNGLHVCQUF1QixvREFBb0QsNkJBQTZCLGdFQUFnRSwyQ0FBMkMsNEZBQTRGLDBDQUEwQywwRkFBMEYsc0JBQXNCLGtEQUFrRCwwQkFBMEIsMERBQTBELHdCQUF3QixzREFBc0Qsc0JBQXNCLGtEQUFrRCxzQkFBc0Isa0RBQWtELHdCQUF3QixzREFBc0QsZ0NBQWdDLHNFQUFzRSx3QkFBd0Isc0RBQXNELDJCQUEyQiw0REFBNEQsaUNBQWlDLHdFQUF3RSw4QkFBOEIsa0VBQWtFLHVDQUF1QyxvRkFBb0YseUJBQXlCLHdEQUF3RCwyQkFBMkIsNERBQTRELDBCQUEwQiwwREFBMEQsK0JBQStCLG9FQUFvRSwyQkFBMkIsNERBQTRELHdCQUF3QixzREFBc0Qsd0JBQXdCLHNEQUFzRCxzQkFBc0Isa0RBQWtELDBCQUEwQiwwREFBMEQsNEJBQTRCLDhEQUE4RCx1QkFBdUIsb0RBQW9ELDRCQUE0Qiw4REFBOEQsMkJBQTJCLDREQUE0RCxzQkFBc0Isa0RBQWtELHdCQUF3QixzREFBc0QsNkJBQTZCLGdFQUFnRSw2QkFBNkIsZ0VBQWdFLDRCQUE0Qiw4REFBOEQsNkJBQTZCLGdFQUFnRSxzQkFBc0Isa0RBQWtELDBCQUEwQiwwREFBMEQsNEJBQTRCLDhEQUE4RCxnQ0FBZ0Msc0VBQXNFLDhCQUE4QixrRUFBa0Usb0NBQW9DLDhFQUE4RSwwQkFBMEIsMERBQTBELHVCQUF1QixvREFBb0Qsc0JBQXNCLGtEQUFrRCwwQkFBMEIsMERBQTBELDRCQUE0Qiw4REFBOEQsc0JBQXNCLGtEQUFrRCw4QkFBOEIsa0VBQWtFLDJCQUEyQiw0REFBNEQsc0JBQXNCLGtEQUFrRCxzQ0FBc0Msa0ZBQWtGLHNDQUFzQyxrRkFBa0Ysc0NBQXNDLGtGQUFrRiwyQkFBMkIsNERBQTRELHlCQUF5Qix3REFBd0Qsd0JBQXdCLHNEQUFzRCxzQkFBc0Isa0RBQWtELHdCQUF3QixzREFBc0QsdUJBQXVCLG9EQUFvRCwwQkFBMEIsMERBQTBELDZCQUE2QixnRUFBZ0UsdUJBQXVCLG9EQUFvRCx3QkFBd0Isc0RBQXNELGlDQUFpQyx3RUFBd0UscUNBQXFDLGdGQUFnRix3Q0FBd0Msc0ZBQXNGLDRDQUE0Qyw4RkFBOEYsMEJBQTBCLDBEQUEwRCxtQ0FBbUMsNEVBQTRFLHdCQUF3QixzREFBc0Qsd0JBQXdCLHNEQUFzRCw0QkFBNEIsOERBQThELCtCQUErQixvRUFBb0UsMkJBQTJCLDREQUE0RCx1QkFBdUIsb0RBQW9ELDBCQUEwQiwwREFBMEQsdUJBQXVCLG9EQUFvRCxzQkFBc0Isa0RBQWtELHVCQUF1QixvREFBb0QsMEJBQTBCLDBEQUEwRCwyQkFBMkIsNERBQTRELHNDQUFzQyxrRkFBa0YsZ0NBQWdDLHNFQUFzRSx5Q0FBeUMsd0ZBQXdGLGdDQUFnQyxzRUFBc0UsdUJBQXVCLG9EQUFvRCx5QkFBeUIsd0RBQXdELG9DQUFvQyw4RUFBOEUsdUJBQXVCLG9EQUFvRCwrQkFBK0Isb0VBQW9FLHNCQUFzQixrREFBa0Qsc0JBQXNCLGtEQUFrRCxzQkFBc0Isa0RBQWtELHVCQUF1QixvREFBb0Qsc0NBQXNDLGtGQUFrRix1QkFBdUIsb0RBQW9ELHVCQUF1QixvREFBb0QsNEJBQTRCLDhEQUE4RCw0QkFBNEIsOERBQThELCtCQUErQixvRUFBb0UseUJBQXlCLHdEQUF3RCx1QkFBdUIsb0RBQW9ELG1DQUFtQyw0RUFBNEUsMkJBQTJCLDZEQUE2RCw4QkFBOEIsbUVBQW1FLDRCQUE0QiwrREFBK0Qsa0NBQWtDLDJFQUEyRSw4QkFBOEIsb0VBQW9FLFdBQVcsT0FBTyxnQkFBZ0IscUJBQXFCLGVBQWUsbUNBQW1DLGNBQWMsaUdBQWlHLDZEQUE2RCxzQkFBc0IsZ0JBQWdCLFNBQVMsVUFBVSx1RUFBdUUsbUJBQW1CLG1CQUFtQixLQUFLLE9BQU8sUUFBUSxrQkFBa0IsT0FBTyxtREFBbUQseUNBQXlDLHFCQUFxQixPQUFPLG9EQUFvRCwwQ0FBMEMsRUFBRSxFQUFFLE9BQU8sOEJBQThCLDJGQUEyRiw4REFBOEQsT0FBTyxtQkFBbUIsdUJBQXVCLDhDQUE4QyxPQUFPLHVDQUF1Qyw0Q0FBNEMsT0FBTyx3Q0FBd0MsR0FBRyxnQkFBZ0IsSUFBSSw4RUFBOEUsd0JBQVUsc0JBQXNCLFNBQVMsOENBQThDLFdBQVcsaUJBQWlCLDBFQUEwRSxPQUFPLGtGQUFrRixTQUFTLHVDQUF1QyxPQUFPLHdCQUF3QixVQUFVLCtDQUErQyxhQUFhLDBCQUEwQixVQUFVLFlBQVksc0JBQXNCLFVBQVUsb0JBQW9CLGlCQUFpQixTQUFTLFFBQVEsa0JBQWtCLFFBQVEsa0JBQWtCLFlBQVksc0JBQXNCLGVBQWUsdUJBQXVCLGFBQWEsd0JBQXdCLGlCQUFpQix5QkFBeUIsYUFBYSxtQkFBbUIsZ0JBQWdCLGtCQUFrQiwrQkFBK0IscUNBQXFDLFNBQVMsb0JBQW9CLGlCQUFpQiw0QkFBNEIsVUFBVSw0Q0FBNEMsVUFBVSx1QkFBdUIsZUFBZSxvQkFBb0IsRUFBRSwySEFBMkgsZUFBZSxtQkFBbUIsS0FBSyxJQUFJLG1DQUFtQyxpQkFBaUIsZ0hBQWdILFNBQVMsMEJBQTBCLFNBQVMsR0FBRyxtQkFBbUIsS0FBSyxJQUFJLDZDQUE2QyxtQkFBbUIsaUNBQWlDLGVBQWUscUJBQXFCLG1CQUFtQixXQUFXLGlCQUFpQixlQUFlLFFBQVEsWUFBWSxXQUFXLFlBQVksU0FBUyxpQkFBaUIsb0JBQW9CLG1CQUFtQixpQkFBaUIsUUFBUSxZQUFZLFdBQVcsS0FBSyxnQ0FBZ0MsT0FBTyxTQUFTLGdCQUFnQixnREFBZ0Qsc0JBQXNCLDJCQUEyQixHQUFHLE1BQU0sR0FBRyxhQUFhLGVBQWUsK0VBQStFLGVBQWUseUJBQXlCLFdBQVcsWUFBWSxXQUFXLFlBQVksU0FBUyxlQUFlLG9CQUFvQixpQkFBaUIsa0JBQWtCLGtEQUFrRCxZQUFZLFdBQVcsc0RBQXNELFNBQVMsaUJBQWlCLGtCQUFrQixrREFBa0QsWUFBWSxXQUFXLDRCQUE0QixTQUFTLGVBQWUsZUFBZSxlQUFlLHVDQUF1QyxvQkFBb0Isc0JBQXNCLG9CQUFvQixtQkFBbUIsZUFBZSw4QkFBOEIseUJBQXlCLGVBQWUseUJBQXlCLFlBQVksSUFBSSxXQUFXLGVBQWUsaUJBQWlCLDhDQUE4QywwQkFBMEIsMkJBQTJCLGVBQWUsUUFBUSxJQUFJLE9BQU8sSUFBSSxXQUFXLGtCQUFrQixJQUFJLE9BQU8sZ0NBQWdDLElBQUksRUFBRSxpQkFBaUIsYUFBYSxZQUFZLFdBQVcsdUJBQXVCLG1CQUFtQiwrRUFBK0UsR0FBRyxVQUFVLEVBQUUsR0FBRyxJQUFJLDJEQUEyRCxNQUFNLFNBQVMsRUFBRSxHQUFHLFdBQVcsa0NBQWtDLEVBQUUsb0NBQW9DLEVBQUUsR0FBRyxTQUFTLDBEQUEwRCxFQUFFLDhCQUE4QiwrRUFBK0UsR0FBRyxJQUFJLEVBQUUsR0FBRyxnQkFBZ0Isa0JBQWtCLGlCQUFpQixlQUFlLDBIQUEwSCxFQUFFLElBQUksRUFBRSxpQkFBaUIsRUFBRSxxRkFBcUYsRUFBRSx1QkFBdUIsaUJBQWlCLDZGQUE2RixZQUFZLFdBQVcsS0FBSyxZQUFZLDREQUE0RCxHQUFHLGlCQUFpQixLQUFLLGFBQWEsc0VBQXNFLG1DQUFtQyxPQUFPLHVCQUF1QixpQkFBaUIsZUFBZSxpQkFBaUIsV0FBVyxnREFBZ0Qsd0NBQXdDLHVDQUF1QyxvQ0FBb0MsMENBQTBDLEVBQUUsR0FBRyxTQUFTLGlCQUFpQixZQUFZLFdBQVcsS0FBSyxXQUFXLDBEQUEwRCxHQUFHLDBCQUEwQixFQUFFLEtBQUssZUFBZSw2RUFBNkUsaUJBQWlCLDhIQUE4SCxlQUFlLHVDQUF1Qyw0QkFBNEIsdUJBQXVCLGlDQUFpQyxFQUFFLEdBQUcsZUFBZSxvQkFBb0IsUUFBUSxtQ0FBbUMsZUFBZSwrQ0FBK0MsZUFBZSwyQkFBMkIsZUFBZSwwQkFBMEIsZUFBZSxvTkFBb04sZUFBZSw0Q0FBNEMsaUJBQWlCLFlBQVksSUFBSSx3QkFBd0IsU0FBUyxlQUFlLGVBQWUsZ0JBQWdCLHFCQUFxQixjQUFjLGNBQWMsS0FBSyx1QkFBdUIsU0FBUyx3QkFBd0IsZ0JBQWdCLGlCQUFpQixtQkFBbUIsWUFBWSxJQUFJLGdCQUFnQixLQUFLLHVEQUF1RCxZQUFZLElBQUkseUJBQXlCLFNBQVMsc0JBQXNCLDRCQUE0QixtQ0FBbUMsa0JBQWtCLG9DQUFvQyxFQUFFLGtDQUFrQyxTQUFTLEVBQUUsNkJBQTZCLElBQUksbUJBQW1CLGlCQUFpQiw2QkFBNkIsd0VBQXdFLGtFQUFrRSxzRUFBc0UsaUNBQWlDLEVBQUUsR0FBRyxpQkFBaUIsY0FBYyxZQUFZLFdBQVcsV0FBVyxTQUFTLGlCQUFpQixzRUFBc0Usd0NBQXdDLHVDQUF1QyxxQ0FBcUMsRUFBRSxHQUFHLGlCQUFpQiw2QkFBNkIsMkRBQTJELDhDQUE4Qyw2Q0FBNkMscUNBQXFDLEVBQUUsR0FBRyxlQUFlLGNBQWMsMEdBQTBHLEVBQUUsS0FBSyxFQUFFLG1CQUFtQixrQkFBa0IscUJBQXFCLG9CQUFvQixZQUFZLGFBQWEsaUJBQWlCLFNBQVMsbUJBQW1CLGtCQUFrQixtQkFBbUIsbUJBQW1CLFlBQVksYUFBYSx5Q0FBeUMseUJBQXlCLGVBQWUsNENBQTRDLDRCQUE0QixlQUFlLDJCQUEyQixxQkFBcUIsaUJBQWlCLGdEQUFnRCxpQkFBaUIsNEZBQTRGLG1CQUFtQixzREFBc0QsRUFBRSx5Q0FBeUMsb0JBQW9CLHlCQUF5Qix5QkFBeUIseUJBQXlCLHVCQUF1QiwrRkFBK0YsRUFBRSxJQUFJLEVBQUUsbUJBQW1CLGtCQUFrQiw4RkFBOEYsT0FBTyx3Q0FBd0MsMkJBQTJCLGlDQUFpQyxHQUFHLG9FQUFvRSxxQ0FBcUMsYUFBYSxtQkFBbUIsV0FBVyxtQkFBbUIsYUFBYSxtQkFBbUIsV0FBVyxrQkFBa0IsZUFBZSxrQkFBa0IsU0FBUyxpRUFBaUUsR0FBRyxpQ0FBaUMsb0ZBQW9GLGdCQUFnQix1RUFBdUUsRUFBRSxtQ0FBbUMsMkNBQTJDLFlBQVksMkJBQTJCLElBQUksUUFBUSxhQUFhLGlCQUFpQix5QkFBeUIsbUJBQW1CLHFJQUFxSSx1REFBdUQsc0NBQXNDLHNCQUFzQix5QkFBeUIsSUFBSSxlQUFlLFNBQVMsMEZBQTBGLG1CQUFtQixtREFBbUQsaUJBQWlCLHNCQUFzQiw2Q0FBNkMsR0FBRyxXQUFXLGFBQWEsVUFBVSxZQUFZLGVBQWUsS0FBSyxPQUFPLGNBQWMsYUFBYSxNQUFNLHVDQUF1QyxlQUFlLHFCQUFNLGdCQUFnQixxQkFBTSxDQUFDLGVBQWUsT0FBTyx3QkFBd0IsaUNBQWlDLE9BQUMsTUFBTSx1REFBdUQsS0FBSyxVQUFVLGNBQWMsV0FBVywrREFBK0QsaUJBQWlCLFdBQVcsNkJBQTZCLFVBQVUsNEJBQTRCLHVxRkFBdXFGLGtCQUFrQixnRUFBZ0Usa0JBQWtCLCtEQUErRCwwRUFBMEUsaUJBQWlCLGNBQWMsaUJBQWlCLGVBQWUsaUJBQWlCLGVBQWUsd0JBQXdCLE1BQU0sRUFBRSxJQUFJLGVBQWUsVUFBVSxXQUFXLDRCQUE0QixpQkFBaUIsU0FBUyxlQUFlLElBQUksMkJBQTJCLGFBQWEsNkJBQTZCLEVBQUUsaUJBQWlCLEVBQUUsc0NBQXNDLGVBQWUsSUFBSSxhQUFhLEdBQUcsb0VBQW9FLEVBQUUsZ0JBQWdCLGlCQUFpQixjQUFjLDZDQUE2QyxFQUFFLGlCQUFpQixFQUFFLHNCQUFzQixhQUFhLGVBQWUsK0NBQStDLEVBQUUsa0NBQWtDLGFBQWEsaUJBQWlCLGtCQUFrQixzQkFBc0IsSUFBSSxjQUFjLEVBQUUsTUFBTSxFQUFFLGlCQUFpQixTQUFTLEVBQUUsR0FBRyxFQUFFLEVBQUUsU0FBUyxNQUFNLHFyQ0FBcXJDLEVBQUUsZUFBZSxtSEFBbUgsa0NBQWtDLGVBQWUsOEJBQThCLGtGQUFrRixlQUFlLHlCQUF5QixtQkFBbUIscUJBQXFCLHlDQUF5QyxpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLHlDQUF5QywwQ0FBMEMsc0JBQXNCLG9CQUFvQixzQkFBc0Isd0NBQXdDLHlCQUF5QixvQ0FBb0MsUUFBUSxtRUFBbUUscUJBQXFCLHVEQUF1RCwwQkFBMEIsU0FBUyxrR0FBa0csaUJBQWlCLFNBQVMsNEJBQTRCLHVDQUF1QyxRQUFRLG9EQUFvRCw0Q0FBNEMsVUFBVSwwQkFBMEIsc0ZBQXNGLGlGQUFpRiwwQkFBMEIseVBBQXlQLGdGQUFnRiwwQkFBMEIsMkJBQTJCLHNDQUFzQyx3QkFBd0IsMEdBQTBHLHlCQUF5QixzQ0FBc0MsNFFBQTRRLGFBQWEsZ0NBQWdDLDZaQUE2WixpQkFBaUIsb0NBQW9DLGlCQUFpQiwySEFBMkgsaUJBQWlCLDZFQUE2RSw4RUFBOEUsc0VBQXNFLHdDQUF3QyxlQUFlLCtCQUErQixZQUFZLFdBQVcsbUNBQW1DLFNBQVMsMENBQTBDLEVBQUUsR0FBRyxjQUFjLDBCQUEwQixpQkFBaUIsK0JBQStCLHlCQUF5Qiw2Q0FBNkMseUJBQXlCLDZDQUE2QyxlQUFlLDBFQUEwRSx5QkFBeUIsbUhBQW1ILDRDQUE0QyxXQUFXLGlCQUFpQixLQUFLLFNBQVMsb0ZBQW9GLFlBQVksS0FBSyxpQkFBaUIsU0FBUyxhQUFhLGlCQUFpQixnRUFBZ0UscUJBQXFCLGFBQWEsTUFBTSxVQUFVLGtFQUFrRSxLQUFLLElBQUksNEJBQTRCLG1CQUFtQixnQkFBZ0IsRUFBRSwyREFBMkQsV0FBVyxLQUFLLFdBQVcsa0JBQWtCLGdCQUFnQixFQUFFLE9BQU8sMElBQTBJLG9CQUFvQixJQUFJLHFEQUFxRCxHQUFHLGNBQWMscUNBQXFDLG1EQUFtRCxFQUFFLElBQUksbUJBQW1CLDBCQUEwQixZQUFZLFdBQVcsS0FBSyxXQUFXLHVEQUF1RCxHQUFHLG9CQUFvQixFQUFFLE9BQU8sU0FBUyxhQUFhLDhCQUE4QiwrQkFBK0IsRUFBRSw2RUFBNkUsZ0JBQWdCLFdBQVcsWUFBWSxrQ0FBa0MsTUFBTSxFQUFFLElBQUksRUFBRSxJQUFJLFVBQVUsR0FBRyxpQkFBaUIsR0FBRyxJQUFJLEdBQUcsSUFBSSxFQUFFLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksRUFBRSxtR0FBbUcsbUJBQW1CLFFBQVEsTUFBTSxZQUFZLFdBQVcsa0JBQWtCLFlBQVksV0FBVyxLQUFLLHNCQUFzQixnQkFBZ0IsZ0JBQWdCLFlBQVksV0FBVyxnQkFBZ0IsaURBQWlELE1BQU0sWUFBWSxTQUFTLFdBQVcsU0FBUyxxQkFBcUIsS0FBSyxLQUFLLHNCQUFzQixZQUFZLG1CQUFtQiwyQkFBMkIsd0NBQXdDLE9BQU8sU0FBUyxZQUFZLFdBQVcsS0FBSyxXQUFXLHFCQUFxQixTQUFTLHVCQUF1QixrQkFBa0Isa0JBQWtCLHNCQUFzQixJQUFJLDBDQUEwQyxTQUFTLHFCQUFxQixxQkFBcUIsS0FBSyxLQUFLLGdCQUFnQix5QkFBeUIsY0FBYywrQkFBK0IsK0ZBQStGLGFBQWEsSUFBSSxvQkFBb0IsdUJBQXVCLDhEQUE4RCxFQUFFLCtCQUErQixlQUFlLElBQUksb0JBQW9CLG1FQUFtRSxhQUFhLDBCQUEwQixHQUFHLHNDQUFzQyxRQUFRLElBQUksa0JBQWtCLG9FQUFvRSxhQUFhLDJCQUEyQixFQUFFLGVBQWUsUUFBUSxrREFBa0QsUUFBUSxJQUFJLDJCQUEyQixLQUFLLGNBQWMsOEJBQThCLG9CQUFvQixxQkFBcUIsa0VBQWtFLDhCQUE4QixFQUFFLHFCQUFxQixFQUFFLHVCQUF1QixFQUFFO0FBQ3ZtK0M7QUFDQSxHQUFHLHFCQUFxQix3RkFBd0YsbUJBQW1CLE1BQU0sS0FBSyxVQUFVLFlBQVksSUFBSSw4Q0FBOEMsU0FBUyxtQkFBbUIsTUFBTSw2QkFBNkIsOEJBQThCLElBQUksNkJBQTZCLGVBQWUsRUFBRSxxRUFBcUUsZUFBZSw0QkFBNEIsNEJBQTRCLDRDQUE0QyxVQUFVLG9CQUFvQixZQUFZLHFCQUFxQiwrQ0FBK0MsVUFBVSxTQUFTLDBFQUEwRSwrSUFBK0ksMEZBQTBGLDRDQUE0QyxTQUFTLFlBQVksS0FBSyxLQUFLLGdCQUFnQix1Q0FBdUMsY0FBYyxlQUFlLElBQUksS0FBSyxnQkFBZ0IsNkNBQTZDLGlCQUFpQixJQUFJLEtBQUssZ0JBQWdCLDRDQUE0QyxtQkFBbUIseUJBQXlCLFlBQVksYUFBYSxvQkFBb0I7QUFDcjJDLEVBQUUsWUFBWSxJQUFJO0FBQ2xCLEVBQUUsc0RBQXNELGVBQWUsU0FBUyxZQUFZLFdBQVcsMkJBQTJCLFNBQVMsYUFBYSxtQkFBbUIsOERBQThELGVBQWUseUNBQXlDLEVBQUUsbURBQW1ELFVBQVUsS0FBSyxpTUFBaU0sa0RBQWtELFlBQVksd0ZBQXdGLFNBQVMseUJBQXlCLFVBQVUsSUFBSSx5QkFBeUIsaUJBQWlCLFVBQVUsc0JBQXNCLFFBQVEsZ0JBQWdCLDBCQUEwQiwyQ0FBMkMsRUFBRSxtQkFBbUIsV0FBVyxFQUFFLG1CQUFtQixJQUFJLG9CQUFvQixZQUFZLGFBQWEsNEJBQTRCLHNCQUFzQixjQUFjLDBCQUEwQiw2QkFBNkIsb0JBQW9CLFlBQVksYUFBYSw0QkFBNEIsU0FBUyxjQUFjLDBCQUEwQiwyQkFBMkIsbUNBQW1DLFlBQVksYUFBYSwrREFBK0QseUJBQXlCLFdBQVcseUJBQXlCLFdBQVcsMkRBQTJELHlCQUF5QixlQUFlLEtBQUssZUFBZSxLQUFLLGVBQWUsS0FBSyxhQUFhLHFCQUFxQix3TUFBd00sV0FBVyx5QkFBeUIsZUFBZSx3QkFBd0IsMENBQTBDLGFBQWEsd0RBQXdELGNBQWMsd0JBQXdCLGlEQUFpRCxZQUFZLCtEQUErRCxhQUFhLHVCQUF1Qiw2QkFBNkIsMEJBQTBCLGNBQWMsSUFBSSx1QkFBdUIsU0FBUyxrSEFBa0gsU0FBUyxhQUFhLDREQUE0RCxXQUFXLHVCQUF1QixpQ0FBaUMsNkJBQTZCLHVCQUF1QixTQUFTLGlIQUFpSCxTQUFTLGNBQWMsdUJBQXVCLG1DQUFtQyx3REFBd0QsVUFBVSxnSEFBZ0gsaUJBQWlCLCtCQUErQixrQkFBa0IsMERBQTBELFlBQVksd0JBQXdCLFFBQVEsNkNBQTZDLGVBQWUsc0JBQXNCLHFDQUFxQyxRQUFRLDhDQUE4QyxtQkFBbUIsOERBQThELDZDQUE2QyxzRUFBc0UsRUFBRSxhQUFhLDJCQUEyQixJQUFJLHdCQUF3QixxQkFBcUIsK0RBQStELFVBQVUsbUVBQW1FLFFBQVEsd0JBQXdCLFdBQVcsZUFBZSxzRUFBc0UsUUFBUSx3QkFBd0IsV0FBVyxlQUFlLHFFQUFxRSxVQUFVLHdEQUF3RCw2Q0FBNkMsdUVBQXVFLEVBQUUsVUFBVSxPQUFPLGlHQUFpRyxFQUFFLE9BQU8sYUFBYSxzRUFBc0UsWUFBWSxHQUFHLE9BQU8sYUFBYSwyRUFBMkUsWUFBWSxHQUFHLE9BQU8sYUFBYSwwRUFBMEUsWUFBWSxHQUFHLE9BQU8sYUFBYSwrRUFBK0UsWUFBWSxHQUFHLE9BQU8sYUFBYSxxRkFBcUYsWUFBWSxHQUFHLFFBQVEsMENBQTBDLGlCQUFpQiwrQkFBK0IsNkNBQTZDLGtDQUFrQyxHQUFHLE9BQU8sRUFBRSxHQUFHLGdCQUFnQixlQUFlLHFCQUFxQixlQUFlLHFGQUFxRixlQUFlLCtHQUErRyxpQkFBaUIsaUNBQWlDLDBCQUEwQiw0QkFBNEIsaUJBQWlCLG1EQUFtRCxRQUFRLGVBQWUsUUFBUSxxQkFBcUIsaUJBQWlCLDhCQUE4QixlQUFlLFNBQVMseUJBQXlCLG1CQUFtQixrQkFBa0Isb0JBQW9CLFVBQVUsT0FBTyxpQkFBaUIsUUFBUSxnQkFBZ0IsV0FBVyxnQ0FBZ0MsZUFBZSw0Q0FBNEMsZUFBZSwwQkFBMEIsYUFBYSxjQUFjLDJCQUEyQixpUkFBaVIsNkVBQTZFLDBEQUEwRCxVQUFVLDZFQUE2RSxhQUFhLGVBQWUsMkJBQTJCLHdCQUF3QiwrQ0FBK0MsY0FBYywyRUFBMkUsRUFBRSxxQ0FBcUMsK0JBQStCLFlBQVksV0FBVyxLQUFLLFdBQVcsNENBQTRDLHlCQUF5QixRQUFRLDBGQUEwRixjQUFjLDZEQUE2RCxpQkFBaUIsc0hBQXNILCtCQUErQixJQUFJLG1CQUFtQix3Q0FBd0Msc0RBQXNELEVBQUUsc0hBQXNILG1CQUFtQiw0QkFBNEIsZUFBZSx5Q0FBeUMsZUFBZSx1REFBdUQsSUFBSSxZQUFZLDJCQUEyQixpQkFBaUIsaUJBQWlCLHdCQUF3QixzQkFBc0Isc0VBQXNFLHlCQUF5Qix3Q0FBd0MsR0FBRyxrR0FBa0cscUJBQXFCLEtBQUssb0JBQW9CLGtFQUFrRSxFQUFFLDBCQUEwQiw4Q0FBOEMsMEJBQTBCLElBQUksc0JBQXNCLDJCQUEyQiwyQkFBMkIseUhBQXlILHlCQUF5QixpQ0FBaUMscURBQXFELEVBQUUsNEJBQTRCLGtCQUFrQixxREFBcUQsRUFBRSxxQkFBcUIsOEJBQThCLHdEQUF3RCxFQUFFLDJCQUEyQixJQUFJLGtCQUFrQixxREFBcUQsd09BQXdPLEdBQUcsc0NBQXNDLGtDQUFrQyx3QkFBd0IsZ0NBQWdDLHlCQUF5QixTQUFTLHVDQUF1QyxHQUFHLGlDQUFpQywwQkFBMEIsaUJBQWlCLG1EQUFtRCxHQUFHLGdDQUFnQywrVEFBK1Qsb0JBQW9CLGlHQUFpRyx3SEFBd0gsa0NBQWtDLCtCQUErQixZQUFZLFdBQVcsS0FBSyxZQUFZLHNCQUFzQiwyQkFBMkIsZUFBZSxvQkFBb0IsMEZBQTBGLGNBQWMsa0ZBQWtGLG1LQUFtSyxVQUFVLFdBQVcsWUFBWSwrRUFBK0UsSUFBSSxLQUFLLGdKQUFnSiwwSEFBMEgsSUFBSSxNQUFNLGdLQUFnSyxpQkFBaUIsSUFBSSxJQUFJLFVBQVUsYUFBYSxTQUFTLGFBQWEsZUFBZSx5QkFBeUIsaUJBQWlCLDJCQUEyQixTQUFTLHNCQUFzQixJQUFJLEtBQUssSUFBSSxRQUFRLE9BQU8sbUJBQW1CLElBQUksSUFBSSxTQUFTLDRCQUE0QixPQUFPLGdFQUFnRSxJQUFJLGlCQUFpQixnR0FBZ0csRUFBRSxnQ0FBZ0MsaUJBQWlCLElBQUksMkJBQTJCLDhCQUE4QixFQUFFLHlCQUF5QixtQ0FBbUMsNkJBQTZCLG9DQUFvQyxjQUFjLDZCQUE2QixFQUFFLG9GQUFvRixtQ0FBbUMsaUJBQWlCLGlDQUFpQyxHQUFHLDJCQUEyQixFQUFFLElBQUksaUJBQWlCLDJFQUEyRSxvRUFBb0UsTUFBTSxxQ0FBcUMsdUZBQXVGLFVBQVUsSUFBSSw4QkFBOEIsR0FBRyxxQ0FBcUMsNkJBQTZCLGdEQUFnRCxFQUFFLGlCQUFpQixpQkFBaUIsV0FBVyxnQ0FBZ0MsZ0JBQWdCLHNDQUFzQyxFQUFFLDZCQUE2QixpRUFBaUUsZ0VBQWdFLE1BQU0sd0NBQXdDLHFDQUFxQyxVQUFVLEtBQUssSUFBSSxjQUFjLFNBQVMsMkNBQTJDLE9BQU8sZ0NBQWdDLG1DQUFtQyw2QkFBNkIsMkVBQTJFLElBQUksaUJBQWlCLGtDQUFrQyxxRkFBcUYsOEtBQThLLGdHQUFnRyx3U0FBd1MsMEJBQTBCLDhCQUE4QiwwQ0FBMEMsNkJBQTZCLFlBQVksWUFBWSxpREFBaUQsa0pBQWtKLDRCQUE0QixtQkFBbUIsU0FBUyxvQkFBb0IsNEVBQTRFLGlDQUFpQyxRQUFRLDRDQUE0Qyx5REFBeUQsdUNBQXVDLDJDQUEyQyx5Q0FBeUMsU0FBUyw4QkFBOEIsZUFBZSxPQUFPLDBCQUEwQiwwQ0FBMEMsOEJBQThCLElBQUkseUJBQXlCLHVDQUF1QywrQkFBK0IseUJBQXlCLDBFQUEwRSx3Q0FBd0Msc0ZBQXNGLFFBQVEseUJBQXlCLDhFQUE4RSxpQkFBaUIsMEVBQTBFLFFBQVEsK0xBQStMLDREQUE0RCxrQ0FBa0MsWUFBWSxvREFBb0Qsa0JBQWtCLHNJQUFzSSxpQkFBaUIsK0NBQStDLDBDQUEwQyx1SkFBdUoseUJBQXlCLHVCQUF1Qix1RUFBdUUsbUJBQW1CLDZDQUE2Qyx3Q0FBd0MseUJBQXlCLG1CQUFtQixrSEFBa0gsU0FBUyw0QkFBNEIsK1JBQStSLGlCQUFpQix3QkFBd0Isa0RBQWtELHdVQUF3VSxnSEFBZ0gsZ0NBQWdDLFdBQVcsOERBQThELHlCQUF5QixPQUFPLHVFQUF1RSxTQUFTLGlFQUFpRSxZQUFZLGdDQUFnQywwQ0FBMEMsU0FBUywyREFBMkQsUUFBUSxtQkFBbUIsWUFBWSxvRkFBb0YsVUFBVSwyQkFBMkIsY0FBYyxPQUFPLDJEQUEyRCxxRUFBcUUsWUFBWSxzQ0FBc0MsWUFBWSxzQ0FBc0MsS0FBSyxzQ0FBc0MsbUNBQW1DLGtDQUFrQyxpSUFBaUkseUNBQXlDLEVBQUUsc0JBQXNCLHdKQUF3SixRQUFRLElBQUkseUZBQXlGLHdFQUF3RSxvQ0FBb0MsdUxBQXVMLGlDQUFpQyxTQUFTLHlEQUF5RCx3QkFBd0Isd0VBQXdFLGlDQUFpQywrQkFBK0IsaUJBQWlCLEVBQUUsY0FBYyxpRkFBaUYsc0dBQXNHLFdBQVcsa0JBQWtCLE9BQU8sRUFBRSxnU0FBZ1MsK0NBQStDLDJXQUEyVyxTQUFTLHlCQUF5QixXQUFXLEtBQUssMkJBQTJCLHVDQUF1QyxHQUFHLFlBQVksd0RBQXdELFFBQVEsb0RBQW9ELGVBQWUsMkRBQTJELGNBQWMsd0NBQXdDLHlCQUF5QixTQUFTLGtIQUFrSCwwQkFBMEIsc0NBQXNDLFFBQVEsb0ZBQW9GLCtHQUErRywrRUFBK0Usa0JBQWtCLG9CQUFvQixlQUFlLDBCQUEwQixtQ0FBbUMsY0FBYyxXQUFXLHNCQUFzQixnQkFBZ0Isc0JBQXNCLDJEQUEyRCxXQUFXLGlCQUFpQixPQUFPLFNBQVMseUJBQXlCLFVBQVUsT0FBTyxxREFBcUQsRUFBRSxjQUFjLHNEQUFzRCxPQUFPLGVBQWUsS0FBSyxlQUFlLHlCQUF5QixZQUFZLHVEQUF1RCwwRUFBMEUsT0FBTyxRQUFRLCtDQUErQyx3NkRBQXc2RCxTQUFTLGNBQWMsZ0dBQWdHLFdBQVcsbUNBQW1DLCtKQUErSixFQUFFLHVDQUF1QyxxQ0FBcUMsT0FBTyxzQkFBc0IsT0FBTywrQkFBK0IsT0FBTyw2QkFBNkIsb0xBQW9MLCtLQUErSywrQkFBK0IsOEVBQThFLHVEQUF1RCxrQ0FBa0Msd0VBQXdFLDhDQUE4QyxnRUFBZ0UsK0NBQStDLGlCQUFpQixRQUFRLDJDQUEyQyxVQUFVLHlCQUF5QixrQ0FBa0Msc0RBQXNELDhCQUE4QixTQUFTLEtBQUssc0NBQXNDLHlCQUF5Qix5RkFBeUYsbUJBQW1CLHNDQUFzQyxrQ0FBa0MsYUFBYSx5REFBeUQsTUFBTSxXQUFXLE9BQU8sZ0NBQWdDLGFBQWEsOENBQThDLFVBQVUsZ0RBQWdELGFBQWEsZ0JBQWdCLE1BQU0sb0JBQW9CLFVBQVUsV0FBVyxpQkFBaUIsWUFBWSxXQUFXLDJCQUEyQixxQkFBcUIsNEJBQTRCLDZEQUE2RCxrRkFBa0YsRUFBRSxlQUFlLEVBQUUsWUFBWSxHQUFHLGtCQUFrQixHQUFHLFVBQVUsOEJBQThCLCtDQUErQyxZQUFZLDhLQUE4Syx3Q0FBd0MsNkJBQTZCLEVBQUUsZUFBZSxFQUFFLDZDQUE2QyxFQUFFLElBQUksY0FBYyxtQ0FBbUMsdUNBQXVDLDJCQUEyQiwrQkFBK0IsaURBQWlELEdBQUcsWUFBWSxHQUFHLDZDQUE2QywyQkFBMkIsRUFBRSxHQUFHLEVBQUUsU0FBUyxjQUFjLGNBQWMscUJBQXFCLHlJQUF5SSxVQUFVLFFBQVEsa0JBQWtCLHNEQUFzRCxlQUFlLGdCQUFnQixJQUFJLGNBQWMsdUZBQXVGLFNBQVMsMkJBQTJCLHVDQUF1Qyx3QkFBd0IsSUFBSSxpQkFBaUIsb0RBQW9ELDRDQUE0QyxTQUFTLE1BQU0sUUFBUSx3Q0FBd0MsT0FBTyxlQUFlLHlCQUF5QixVQUFVLFlBQVksRUFBRSxxQkFBcUIsbUJBQW1CLDRIQUE0SCxpQkFBaUIseUlBQXlJLEVBQUUsSUFBSSxtREFBbUQsc09BQXNPLFlBQVksTUFBTSxvQkFBb0IsNkNBQTZDLEVBQUUsNEJBQTRCLEdBQUcsaUJBQWlCLEVBQUUsR0FBRyxZQUFZLFdBQVcsS0FBSyxrREFBa0Qsc0VBQXNFLEVBQUUsdUNBQXVDLEVBQUUsT0FBTyx1R0FBdUcsbUJBQW1CLGNBQWMsbUJBQW1CLFFBQVEsZ0VBQWdFLGFBQWEsZUFBZSx5QkFBeUIsZUFBZSxvSUFBb0ksdUNBQXVDLFFBQVEsWUFBWSxXQUFXLEtBQUssV0FBVyx1RkFBdUYscUJBQXFCLGtCQUFrQix1QkFBdUIsTUFBTSxrR0FBa0csNkJBQTZCLG9EQUFvRCw4SEFBOEgsK0JBQStCLGlFQUFpRSxFQUFFLEdBQUcsdURBQXVELFlBQVkscUJBQXFCLEtBQUssb0dBQW9HLHdDQUF3QyxTQUFTLG9CQUFvQiw0REFBNEQsNEhBQTRILGNBQWMsaUNBQWlDLDhFQUE4RSx3QkFBd0IsdUVBQXVFLGlCQUFpQixtQkFBbUIsS0FBSyxLQUFLLEVBQUUsc0NBQXNDLGtCQUFrQixjQUFjLFNBQVMsY0FBYyxtQkFBbUIsY0FBYyxvQkFBb0IsY0FBYyxrSEFBa0gsZUFBZSwySUFBMkksT0FBTyxjQUFjLHFCQUFxQixjQUFjLFNBQVMsY0FBYyxrQkFBa0IsZUFBZSxvQkFBb0IsZ0JBQWdCLG1CQUFtQixlQUFlLDhCQUE4QixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLHVCQUF1QixjQUFjLGlCQUFpQixjQUFjLHFCQUFxQixlQUFlLG1CQUFtQixlQUFlLHdCQUF3QixlQUFlLCtCQUErQixxQkFBcUIsZ0NBQWdDLGNBQWMsaUJBQWlCLGlCQUFpQixxQkFBcUIsU0FBUyx1QkFBdUIsaUVBQWlFLFlBQVksV0FBVyxLQUFLLCtDQUErQyx1SkFBdUosRUFBRSxLQUFLLFFBQVEsR0FBRyxPQUFPLG9DQUFvQyx1QkFBdUIsNEJBQTRCLDBGQUEwRixZQUFZLFdBQVcsS0FBSyxnRUFBZ0Usd0NBQXdDLEtBQUssRUFBRSxVQUFVLHNCQUFzQiwrQkFBK0IsMkJBQTJCLE9BQU8sb0JBQW9CLGlCQUFpQixvQkFBb0IsS0FBSyxnQkFBZ0Isb0NBQW9DLG9DQUFvQyxTQUFTLGlCQUFpQixvQkFBb0IsdUJBQXVCLHFCQUFxQixjQUFjLDRCQUE0QixRQUFRLFlBQVksSUFBSSx3Q0FBd0MsU0FBUyxtQkFBbUIsV0FBVyx1QkFBdUIsb0JBQW9CLHVCQUF1QixxQkFBcUIsY0FBYyw0QkFBNEIsUUFBUSxZQUFZLElBQUksOENBQThDLFNBQVMsbUJBQW1CLFdBQVcsaUJBQWlCLCtDQUErQyx1QkFBdUIscUJBQXFCLDBDQUEwQyx1REFBdUQsUUFBUSxvQkFBb0IsU0FBUyxxREFBcUQsNkJBQTZCLDJDQUEyQyxRQUFRLG9CQUFvQixTQUFTLGtEQUFrRCxFQUFFLElBQUksK0JBQStCLFFBQVEsaUNBQWlDLFFBQVEseUVBQXlFLDJFQUEyRSwyREFBMkQsNkJBQTZCLFlBQVksV0FBVyxLQUFLLFdBQVcsc0JBQXNCLHNDQUFzQyxzREFBc0QsU0FBUywyQkFBMkIscUJBQXFCLDBGQUEwRixTQUFTLHlCQUF5QiwyQkFBMkIsWUFBWSxXQUFXLEtBQUssV0FBVyxrQ0FBa0MscURBQXFELEVBQUUsS0FBSyxFQUFFLEdBQUcsT0FBTyxzQkFBc0Isa0JBQWtCLEtBQUssWUFBWSxJQUFJLEtBQUssMENBQTBDLE1BQU0scUNBQXFDLGdCQUFnQixLQUFLLFlBQVksdUNBQXVDLHdDQUF3Qyx1Q0FBdUMseUJBQXlCLHNCQUFzQixrRUFBa0UsWUFBWSxXQUFXLDhCQUE4QixzREFBc0QsaUNBQWlDLHFEQUFxRCxFQUFFLEtBQUssRUFBRSxHQUFHLE9BQU8saUJBQWlCLHlCQUF5Qix3QkFBd0IsS0FBSyxlQUFlLEVBQUUsSUFBSSxlQUFlLGdCQUFnQixlQUFlLHFCQUFxQixzQ0FBc0MsR0FBRywyQkFBMkIsNENBQTRDLGlEQUFpRCxnQkFBZ0IsdUJBQXVCLFFBQVEsc0NBQXNDLGdCQUFnQiwrREFBK0Qsa0JBQWtCLG1CQUFtQixhQUFhLGNBQWMsZ0NBQWdDLFdBQVcsdUdBQXVHLFNBQVMsZUFBZSxvREFBb0Qsa0JBQWtCLEdBQUcsYUFBYSxjQUFjLHVOQUF1TixtQkFBbUIsR0FBRyxFQUFFLDRCQUE0QixxQkFBcUIsa0RBQWtELFdBQVcsY0FBYyxNQUFNLDhGQUE4RixlQUFlLFVBQVUsTUFBTSx5Q0FBeUMsZUFBZSxhQUFhLE1BQU0sNEJBQTRCLDZCQUE2Qix1QkFBdUIsSUFBSSxpQ0FBaUMsZUFBZSxlQUFlLE9BQU8sTUFBTSxNQUFNLGtCQUFrQiw4REFBOEQseUNBQXlDLFlBQVksV0FBVywrQkFBK0IsZ0JBQWdCLGVBQWUsa0JBQWtCLGVBQWUsVUFBVSxlQUFlLGNBQWMseUJBQXlCLGlCQUFpQixxQkFBcUIsaUJBQWlCLE9BQU8scUhBQXFILDZVQUE2VSxtQkFBbUIsT0FBTyxtR0FBbUcsd0ZBQXdGLCtFQUErRSw4RUFBOEUsK0JBQStCLGlSQUFpUix1QkFBdUIsUUFBUSw2RUFBNkUsZUFBZSxpSEFBaUgsT0FBTywwUUFBMFEsZUFBZSxTQUFTLG9DQUFvQyxTQUFTLGNBQWMsVUFBVSxnQkFBZ0IsS0FBSyxhQUFhLGtCQUFrQixvQ0FBb0MseUJBQXlCLE9BQU8sWUFBWSxPQUFPLGNBQWMsZUFBZSxPQUFPLGdDQUFnQyxTQUFTLGNBQWMsMEJBQTBCLDBEQUEwRCxZQUFZLEtBQUssZUFBZSxhQUFhLEtBQUssK0JBQStCLFNBQVMsY0FBYywwQkFBMEIsWUFBWSxLQUFLLGNBQWMsc0JBQXNCLGNBQWMseUJBQXlCLFdBQVcsdURBQXVELFlBQVksV0FBVyxLQUFLLDJDQUEyQyxPQUFPLDRCQUE0QixnQkFBZ0IsY0FBYyx3Q0FBd0MscUJBQXFCLDJEQUEyRCw2QkFBNkIscUNBQXFDLDZCQUE2QixxQ0FBcUMsMEJBQTBCLGdDQUFnQyw0QkFBNEIsa0NBQWtDLDBCQUEwQixTQUFTLHlGQUF5RixhQUFhLG9CQUFvQixLQUFLLDRMQUE0TCxjQUFjLHlJQUF5SSw4SEFBOEgsd0ZBQXdGLFNBQVMsZUFBZSxlQUFlLHdCQUF3QixvQkFBb0IsMEJBQTBCLG9CQUFvQixFQUFFLGFBQWEsZUFBZSxxSEFBcUgsaUJBQWlCLGNBQWMsc0pBQXNKLDZDQUE2QyxhQUFhLDJDQUEyQyxvQkFBb0IsMkJBQTJCLGlDQUFpQyw2Q0FBNkMsZUFBZSxZQUFZLDJFQUEyRSxpQkFBaUIsK0VBQStFLGVBQWUsbUJBQW1CLDJCQUEyQixnRUFBZ0UsS0FBSyxtQ0FBbUMsa0VBQWtFLElBQUksU0FBUyw4Q0FBOEMsRUFBRSxTQUFTLFlBQVksTUFBTSxpQkFBaUIsZ0NBQWdDLDBCQUEwQixJQUFJLFNBQVMsK0RBQStELEVBQUUsU0FBUyxZQUFZLG1CQUFtQixxQkFBcUIsZ0JBQWdCLG9CQUFvQiwrQkFBK0IsNEVBQTRFLHVEQUF1RCwrQ0FBK0MseUJBQXlCLElBQUksNkJBQTZCLDJIQUEySCwwQkFBMEIsMEJBQTBCLGVBQWUsaUJBQWlCLGVBQWUsbUVBQW1FLGFBQWEsY0FBYyxvQkFBb0IsbUJBQW1CLDJCQUEyQixpQ0FBaUMsNkNBQTZDLDJFQUEyRSxpQkFBaUIsU0FBUywwREFBMEQsS0FBSyxnRUFBZ0UseUJBQXlCLEVBQUUscUJBQXFCLG1DQUFtQyxpQ0FBaUMsNkNBQTZDLGdGQUFnRixpQkFBaUIsK0VBQStFLEVBQUUsb0JBQW9CLHlCQUF5QixnQ0FBZ0Msa0NBQWtDLHdFQUF3RSx1REFBdUQsdURBQXVELDhDQUE4Qyx5QkFBeUIsR0FBRyxzSEFBc0gsZUFBZSxPQUFPLG1KQUFtSixlQUFlLGdFQUFnRSxlQUFlLGtCQUFrQixxREFBcUQsRUFBRSxHQUFHLHNDQUFzQyxlQUFlLG1FQUFtRSxhQUFhLGVBQWUsOEtBQThLLGlJQUFpSSw4Q0FBOEMsY0FBYyx1SkFBdUosc0dBQXNHLElBQUksNktBQTZLLE9BQU8sbVpBQW1aLG1FQUFtRSxzQkFBc0IsU0FBUyx1REFBdUQsZUFBZSx3R0FBd0cscUJBQXFCLHFCQUFxQixtQkFBbUIsb0JBQW9CLGtCQUFrQixNQUFNLGFBQWEsa0RBQWtELDZFQUE2RSxlQUFlLElBQUksNkhBQTZILFFBQVEsbURBQW1ELHVFQUF1RSxlQUFlLGdCQUFnQixrQkFBa0IseURBQXlELDJFQUEyRSxlQUFlLGlCQUFpQixnQkFBZ0IsK0NBQStDLFlBQVksb0JBQW9CLDhZQUE4WSw0Q0FBNEMsbUZBQW1GLGVBQWUsaUJBQWlCLDhCQUE4QixnQ0FBZ0MsMkhBQTJILDBCQUEwQiwwQkFBMEIsZUFBZSxpQkFBaUIsYUFBYSxjQUFjLDZPQUE2TyxtQkFBbUIsUUFBUSxpQkFBaUIsWUFBWSxpQkFBaUIsS0FBSyxxQkFBcUIsbUNBQW1DLFlBQVkscUNBQXFDLFNBQVMscUJBQXFCLFFBQVEsWUFBWSwrRUFBK0UsRUFBRSxJQUFJLDBDQUEwQyxnQkFBZ0Isc0JBQXNCLGNBQWMsaUJBQWlCLHFCQUFxQiwyREFBMkQsNEJBQTRCLDRKQUE0Six1QkFBdUIscUZBQXFGLEVBQUUscUJBQXFCLHFCQUFxQixtQ0FBbUMsb0VBQW9FLEVBQUUsSUFBSSxTQUFTLG9CQUFvQixnREFBZ0QsZUFBZSxtSEFBbUgsMEJBQTBCLEdBQUcsT0FBTywyQ0FBMkMsNEJBQTRCLG9EQUFvRCxFQUFFLElBQUksNEJBQTRCLG1GQUFtRixFQUFFLDhEQUE4RCxTQUFTLGlDQUFpQyxFQUFFLElBQUksbUNBQW1DLHdGQUF3RixFQUFFLDhEQUE4RCxTQUFTLHNDQUFzQyxFQUFFLElBQUksMkVBQTJFLDRDQUE0QyxzQkFBc0IseUVBQXlFLG9CQUFvQiwyQkFBMkIsZ0JBQWdCLDBDQUEwQyxnQkFBZ0IsYUFBYSxXQUFXLFNBQVMscUJBQXFCLFlBQVksbURBQW1ELHVCQUF1QixrQkFBa0IsdUJBQXVCLGtCQUFrQixhQUFhLGNBQWMsNkdBQTZHLFdBQVcsa0JBQWtCLE1BQU0seUJBQXlCLFlBQVksNkZBQTZGLEVBQUUsR0FBRyw2RkFBNkYsWUFBWSxvQ0FBb0Msc0JBQXNCLHFFQUFxRSxnQkFBZ0IsT0FBTywwQ0FBMEMsb0JBQW9CLHVEQUF1RCxNQUFNLDJGQUEyRixzREFBc0Qsb0JBQW9CLHNDQUFzQyx1SUFBdUksTUFBTSxnQkFBZ0IsZUFBZSwwQkFBMEIsa0NBQWtDLElBQUkseUNBQXlDLFVBQVUsSUFBSSx5Q0FBeUMsV0FBVyxRQUFRLHFCQUFxQixhQUFhLGNBQWMsMERBQTBELFdBQVcsOEZBQThGLE1BQU0sTUFBTSxPQUFPLFVBQVUseUJBQXlCLFlBQVksaUdBQWlHLEVBQUUsR0FBRyxrQ0FBa0MsWUFBWSw4REFBOEQsZ0JBQWdCLHFKQUFxSiwyRUFBMkUsNkJBQTZCLDBDQUEwQyxpQkFBaUIsc0JBQXNCLDZEQUE2RCxFQUFFLEdBQUcsK0hBQStILE9BQU8sSUFBSSxJQUFJLFNBQVMsMkJBQTJCLFVBQVUsU0FBUyxFQUFFLGVBQWUsT0FBTyx3Q0FBd0MseUJBQXlCLFVBQVUsVUFBVSxFQUFFLG9CQUFvQiwyQkFBMkIsS0FBSyxRQUFRLHFDQUFxQyxPQUFPLGlCQUFpQixzQ0FBc0MsY0FBYyxPQUFPLFNBQVMseUJBQXlCLFNBQVMsUUFBUSxFQUFFLGlCQUFpQixnREFBZ0QsY0FBYyxPQUFPLFNBQVMseUJBQXlCLFVBQVUsYUFBYSxFQUFFLGlCQUFpQixzQ0FBc0MscUVBQXFFLE9BQU8sUUFBUSxNQUFNLDJCQUEyQixVQUFVLFFBQVEsRUFBRSxpQkFBaUIsc0NBQXNDLGNBQWMsT0FBTyxTQUFTLHlCQUF5QixTQUFTLFFBQVEsRUFBRSxlQUFlLHFCQUFxQiwwQkFBMEIsT0FBTyxLQUFLLHlCQUF5QixLQUFLLE9BQU8sS0FBSywwQkFBMEIsVUFBVSxRQUFRLEVBQUUsZUFBZSxPQUFPLG1CQUFtQix5QkFBeUIsVUFBVSxTQUFTLEVBQUUsZUFBZSxPQUFPLG9CQUFvQix5QkFBeUIsVUFBVSxVQUFVLEVBQUUsZUFBZSw4SkFBOEosU0FBUyxHQUFHLGlDQUFpQyxFQUFFLGtCQUFrQixjQUFjLGlHQUFpRyxnQkFBZ0Isb0dBQW9HLEVBQUUsUUFBUSx5QkFBeUIsVUFBVSxTQUFTLEVBQUUsMkJBQTJCLE9BQU8sd0JBQXdCLElBQUksbUJBQW1CLDJCQUEyQixVQUFVLFFBQVEsRUFBRSwyQkFBMkIsT0FBTyx3QkFBd0IsSUFBSSxtQkFBbUIsMkJBQTJCLFVBQVUsUUFBUSxFQUFFLG1CQUFtQixPQUFPLG9CQUFvQixJQUFJLFFBQVEsMkJBQTJCLFVBQVUsV0FBVyxFQUFFLG1CQUFtQixPQUFPLG9CQUFvQixJQUFJLFFBQVEsMkJBQTJCLFVBQVUsV0FBVyxFQUFFLGVBQWUsT0FBTyxtQkFBbUIseUJBQXlCLFVBQVUsU0FBUyxFQUFFLGVBQWUsT0FBTyxvQkFBb0IseUJBQXlCLFVBQVUsVUFBVSxFQUFFLGVBQWUsT0FBTyxtQkFBbUIseUJBQXlCLFVBQVUsU0FBUyxFQUFFLGlCQUFpQiwwQ0FBMEMsY0FBYyxPQUFPLFNBQVMseUJBQXlCLFVBQVUsVUFBVSxFQUFFLGVBQWUsT0FBTyxvQkFBb0IseUJBQXlCLFVBQVUsVUFBVSxFQUFFLGdDQUFnQyw4QkFBOEIsaUNBQWlDLDBDQUEwQyxpQkFBaUIsd0NBQXdDLDhDQUE4QywyQ0FBMkMsRUFBRSxHQUFHLDRCQUE0QixtQ0FBbUMscUJBQXFCLG9EQUFvRCwwREFBMEQsMkNBQTJDLEVBQUUsR0FBRyw0QkFBNEIsK0NBQStDLDJCQUEyQixrQ0FBa0Msd0NBQXdDLDJDQUEyQyxFQUFFLEdBQUcsMkRBQTJELGlDQUFpQyxtQ0FBbUMsMEVBQTBFLHdSQUF3UiwrQ0FBK0MsZ0NBQWdDLG9DQUFvQywwQ0FBMEMsMkNBQTJDLEVBQUUsR0FBRywyRUFBMkUsNENBQTRDLHVDQUF1Qyw4RUFBOEUsZ1hBQWdYLHVCQUF1Qix1QkFBdUIsOERBQThELFlBQVkseUJBQXlCLDZCQUE2QixnQkFBZ0IsWUFBWSxJQUFJLHdEQUF3RCxTQUFTLHVCQUF1QixjQUFjLHNDQUFzQyxlQUFlLCtEQUErRCxlQUFlLG9DQUFvQyxpQkFBaUIsNEJBQTRCLCtCQUErQixVQUFVLHVCQUF1QixHQUFHLDJEQUEyRCx3QkFBd0IsY0FBYyxvQkFBb0Isa0NBQWtDLHdHQUF3RyxHQUFHLDJDQUEyQyx1QkFBdUIsMkNBQTJDLCtDQUErQyw0QkFBNEIsd0pBQXdKLEdBQUcsaUZBQWlGLDZDQUE2QywrQ0FBK0MsRUFBRSxHQUFHLE9BQU8sa0NBQWtDLG1DQUFtQyxZQUFZLDBDQUEwQyxHQUFHLDBFQUEwRSwwQ0FBMEMscUJBQXFCLG9CQUFvQixtREFBbUQsc0hBQXNILEdBQUcsMERBQTBELCtDQUErQyxFQUFFLEdBQUcsT0FBTyw2Q0FBNkMsaUJBQWlCLDJCQUEyQixVQUFVLGlDQUFpQywrQkFBK0IsaUNBQWlDLGdEQUFnRCxFQUFFLElBQUksZUFBZSxpQkFBaUIsMkJBQTJCLGlCQUFpQixvQkFBb0IsZUFBZSwyQkFBMkIsZUFBZSxtQ0FBbUMsb0NBQW9DLHNDQUFzQyxFQUFFLEdBQUcsbUJBQW1CLFlBQVksOENBQThDLEVBQUUsc0RBQXNELEdBQUcsY0FBYyxFQUFFLElBQUksOENBQThDLEVBQUUsc0RBQXNELEdBQUcsY0FBYyxFQUFFLElBQUkseUNBQXlDLGNBQWMsd0JBQXdCLEVBQUUsc0RBQXNELEdBQUcsY0FBYyxFQUFFLElBQUksRUFBRSxFQUFFLDZCQUE2QixFQUFFLCtCQUErQixFQUFFLElBQUksaUJBQWlCLE9BQU8seUNBQXlDLElBQUksU0FBUywyQkFBMkIsU0FBUyxZQUFZLEVBQUUsdUJBQXVCLHVDQUF1QyxzRkFBc0YsR0FBRyxpQkFBaUIsRUFBRSxJQUFJLGFBQWEsbUlBQW1JLE9BQU8sc0JBQXNCLE9BQU8sSUFBSSxJQUFJLCtDQUErQyx1QkFBdUIsbUVBQW1FLFVBQVUsWUFBWSxFQUFFLGlDQUFpQyw4Q0FBOEMsZ0pBQWdKLE9BQU8sc0dBQXNHLEVBQUUsK0hBQStILEVBQUUsd0JBQXdCLE9BQU8sSUFBSSxJQUFJLDREQUE0RCx1QkFBdUIsOEVBQThFLFVBQVUsY0FBYyxFQUFFLG1CQUFtQix3REFBd0QsbURBQW1ELDJDQUEyQztBQUM3cjNELHVCQUF1QixRQUFRLEtBQUssK0JBQStCLFdBQVcsUUFBUSwyQkFBMkIsVUFBVSxXQUFXLEVBQUUsMkJBQTJCLDRDQUE0QyxjQUFjLE9BQU8sUUFBUSxJQUFJLDJCQUEyQiwyQkFBMkIsVUFBVSxXQUFXLEVBQUUsZUFBZSxPQUFPLGdDQUFnQyx5QkFBeUIsVUFBVSxZQUFZLEVBQUUsbUJBQW1CLDJDQUEyQyxnRUFBZ0UsT0FBTyxJQUFJLElBQUksZ0JBQWdCLDJCQUEyQixVQUFVLFVBQVUsRUFBRSxlQUFlLE9BQU8sNkJBQTZCLHlCQUF5QixVQUFVLFNBQVMsRUFBRSx5QkFBeUIsZ1lBQWdZLFlBQVksVUFBVSxrQkFBa0IsRUFBRSxtQkFBbUIsdURBQXVELDBDQUEwQyxRQUFRLHlDQUF5QyxTQUFTLGdEQUFnRCxVQUFVLDRDQUE0QyxTQUFTLG1EQUFtRCxZQUFZLG9FQUFvRSxlQUFlLE1BQU0sRUFBRSxHQUFHLE9BQU8sSUFBSSxJQUFJLHNCQUFzQiwyQkFBMkIsVUFBVSxtQkFBbUIsRUFBRSxlQUFlLE1BQU0sK0pBQStKLHlCQUF5QixrQkFBa0IscUZBQXFGLHNDQUFzQyxNQUFNLHNXQUFzVyxPQUFPLDJDQUEyQyxJQUFJLGtCQUFrQix1QkFBdUIsb0JBQW9CLFVBQVUsY0FBYyxFQUFFLHlCQUF5QixxRkFBcUYsc0NBQXNDLE1BQU0sc0hBQXNILE9BQU8scUdBQXFHLE9BQU8seUdBQXlHLE9BQU8sK0dBQStHLE9BQU8sZ0hBQWdILE9BQU8sb0JBQW9CLFVBQVUsZ0JBQWdCLEVBQUUseUJBQXlCLHFGQUFxRixzQ0FBc0MsTUFBTSxzSEFBc0gsT0FBTyxxR0FBcUcsT0FBTyx5R0FBeUcsT0FBTywrR0FBK0csT0FBTyxnSEFBZ0gsT0FBTyxvQkFBb0IsVUFBVSxnQkFBZ0IsRUFBRSx5QkFBeUIscUZBQXFGLHNDQUFzQyxNQUFNLHNIQUFzSCxPQUFPLHFHQUFxRyxPQUFPLHlHQUF5RyxPQUFPLCtHQUErRyxPQUFPLGdIQUFnSCxPQUFPLG9CQUFvQixVQUFVLGdCQUFnQixFQUFFLG1CQUFtQixzREFBc0QsaUZBQWlGLFFBQVEsb0RBQW9ELEVBQUUsc0lBQXNJLFFBQVEsbUJBQW1CLFFBQVEsSUFBSSxPQUFPLGNBQWMsSUFBSSxRQUFRLDJCQUEyQixVQUFVLGFBQWEsRUFBRSxpQkFBaUIsb0RBQW9ELDRGQUE0RixRQUFRLE9BQU8sUUFBUSxHQUFHLGdJQUFnSSxTQUFTLGlCQUFpQixRQUFRLEdBQUcsT0FBTyxTQUFTLHlCQUF5QixVQUFVLGVBQWUsRUFBRSxpQkFBaUIsNEVBQTRFLGtHQUFrRyxPQUFPLEdBQUcsbUdBQW1HLE9BQU8sR0FBRyxPQUFPLFdBQVcseUJBQXlCLFVBQVUsa0JBQWtCLEVBQUUsaUJBQWlCLHVDQUF1Qyx3RUFBd0UsVUFBVSxlQUFlLE9BQU8sSUFBSSxvQkFBb0Isc0JBQXNCLEtBQUssa0JBQWtCLGNBQWMsU0FBUyw4QkFBOEIscUJBQXFCLEtBQUssMEJBQTBCLDBEQUEwRCxFQUFFLDRCQUE0QixFQUFFLEtBQUssa0VBQWtFLE9BQU8sSUFBSSxJQUFJLFFBQVEsMkJBQTJCLFVBQVUsZ0JBQWdCLEVBQUUsZUFBZSxPQUFPLDZCQUE2Qix5QkFBeUIsVUFBVSxTQUFTLEVBQUUsbUJBQW1CLGlCQUFpQixPQUFPLHlCQUF5Qix3QkFBd0IsSUFBSSxtQkFBbUIsNkJBQTZCLHFDQUFxQyxFQUFFLHVDQUF1QyxFQUFFLHdDQUF3QyxPQUFPLElBQUksSUFBSSwrQkFBK0IsMkJBQTJCLFVBQVUsZ0JBQWdCLEVBQUUsZUFBZSxlQUFlLFVBQVUsYUFBYSxFQUFFLGlCQUFpQixlQUFlLFVBQVUsYUFBYSxFQUFFLGlCQUFpQixlQUFlLFVBQVUsYUFBYSxFQUFFLGlCQUFpQixlQUFlLFVBQVUsYUFBYSxFQUFFLHdDQUF3Qyw4RUFBOEUsdUlBQXVJLE9BQU8sNkVBQTZFLE9BQU8scUJBQXFCLHVDQUF1Qyx5REFBeUQsRUFBRSxzQ0FBc0MsV0FBVyx5RkFBeUYsR0FBRyxpQkFBaUIsRUFBRSw0SUFBNEksT0FBTyxhQUFhLElBQUksMkRBQTJELHVCQUF1QixtREFBbUQsVUFBVSxXQUFXLEVBQUUsbUNBQW1DLDBEQUEwRCw0SEFBNEgsT0FBTyw2RUFBNkUsT0FBTyx1RkFBdUYsV0FBVyxzQ0FBc0MsV0FBVyxzRkFBc0YsR0FBRyxnQkFBZ0IsRUFBRSxpTUFBaU0sR0FBRyx1Q0FBdUMsNkhBQTZILDhFQUE4RSxVQUFVLFdBQVcsRUFBRSxrQ0FBa0MsOENBQThDLFNBQVMsb0JBQW9CLE9BQU8sZUFBZSxpQkFBaUIsNEtBQTRLLFNBQVMsaUZBQWlGLE9BQU8sb0ZBQW9GLE9BQU8sR0FBRyw4REFBOEQsaUVBQWlFLEVBQUUsc0NBQXNDLFdBQVcsc0VBQXNFLEVBQUUsdUNBQXVDLFdBQVcsNkJBQTZCLE9BQU8sY0FBYyxJQUFJLDREQUE0RCx1QkFBdUIsbURBQW1ELFVBQVUsd0JBQXdCLEVBQUUseUJBQXlCLG1FQUFtRSw4QkFBOEIsVUFBVSxvQkFBb0IsRUFBRSx5Q0FBeUMsMERBQTBELGtKQUFrSixPQUFPLDZFQUE2RSxPQUFPLHNFQUFzRSxXQUFXLHNDQUFzQyxXQUFXLHlGQUF5RixHQUFHLGlCQUFpQixFQUFFLDREQUE0RCxHQUFHLGlMQUFpTCxPQUFPLGFBQWEsSUFBSSx5Q0FBeUMsdUJBQXVCLDhEQUE4RCxVQUFVLFdBQVcsRUFBRSx1QkFBdUIsOENBQThDLFNBQVMsb0JBQW9CLE9BQU8sZUFBZSxpQkFBaUIsb0dBQW9HLHdCQUF3Qix3RkFBd0YsU0FBUyxpRkFBaUYsT0FBTyxvRkFBb0YsT0FBTyxvRUFBb0UsRUFBRSxzQ0FBc0MsV0FBVyxzRUFBc0UsRUFBRSx1Q0FBdUMsV0FBVyxJQUFJLE9BQU8sY0FBYyxJQUFJLDZCQUE2Qix1QkFBdUIsOERBQThELFVBQVUsd0JBQXdCLEVBQUUsdUJBQXVCLG1FQUFtRSxxQkFBcUIsVUFBVSxvQkFBb0IsRUFBRSxlQUFlLE9BQU8sNEJBQTRCLHlCQUF5QixVQUFVLFFBQVEsRUFBRSxlQUFlLE9BQU8sNkJBQTZCLHlCQUF5QixVQUFVLFNBQVMsRUFBRSw2QkFBNkIsT0FBTyxxQkFBcUIsSUFBSSw4QkFBOEIsMkJBQTJCLFVBQVUsWUFBWSxFQUFFLDZCQUE2QixPQUFPLG9CQUFvQixJQUFJLDhCQUE4QiwyQkFBMkIsVUFBVSxXQUFXLEVBQUUsd0JBQXdCLGdFQUFnRSxzRkFBc0YsUUFBUSx5RkFBeUYsT0FBTyxxREFBcUQsRUFBRSxxSUFBcUksUUFBUSxtQkFBbUIsUUFBUSxJQUFJLE9BQU8sY0FBYyxJQUFJLHVCQUF1QiwyQkFBMkIsVUFBVSxrQkFBa0IsRUFBRSwwQkFBMEIsaUpBQWlKLGdFQUFnRSxFQUFFO0FBQ2xzYixNQUFNLEdBQUcsTUFBTSxJQUFJO0FBQ25CLE1BQU0sUUFBUTtBQUNkLE1BQU0sR0FBRyxNQUFNLEdBQUc7QUFDbEIsVUFBVSxRQUFRLG1FQUFtRSxLQUFLLFNBQVMsR0FBRyxvQ0FBb0MsUUFBUSxHQUFHLE9BQU8sSUFBSSxJQUFJLDBCQUEwQiwyQkFBMkIsVUFBVSxpQkFBaUIsRUFBRSx3Q0FBd0MsZ0dBQWdHLGdKQUFnSixPQUFPLHNGQUFzRixPQUFPLElBQUksdUNBQXVDLDRFQUE0RSxFQUFFLGtEQUFrRCxXQUFXLDhCQUE4QixPQUFPLGFBQWEsSUFBSSwyREFBMkQsdUJBQXVCLG1EQUFtRCxVQUFVLG9CQUFvQixFQUFFLGVBQWUsT0FBTyxtQkFBbUIseUJBQXlCLFVBQVUsU0FBUyxFQUFFLHNDQUFzQyx5REFBeUQsNkZBQTZGLE9BQU8saUZBQWlGLE9BQU8scUdBQXFHLEVBQUUsR0FBRyxhQUFhLGlLQUFpSyxZQUFZLEtBQUssV0FBVyxHQUFHLE9BQU8sYUFBYSxJQUFJLDRCQUE0Qix1QkFBdUIsbURBQW1ELFVBQVUsZUFBZSxRQUFRLE9BQU8sa0ZBQWtGLEVBQUUsaUJBQWlCLG9CQUFvQixZQUFZLElBQUksS0FBSyxzQkFBc0IsNENBQTRDLFNBQVMsaUJBQWlCLFNBQVMsWUFBWSxXQUFXLEtBQUssNENBQTRDLG9DQUFvQyxTQUFTLGlCQUFpQixpREFBaUQsWUFBWSxJQUFJLEtBQUssc0JBQXNCLGVBQWUsc0JBQXNCLG1DQUFtQyx5QkFBeUIsZUFBZSw4REFBOEQsR0FBRyxNQUFNLEVBQUUsR0FBRyxlQUFlLGdCQUFnQixTQUFTLGlCQUFpQixrRkFBa0Ysa0NBQWtDLE9BQU8sU0FBUyx5QkFBeUIsVUFBVSxVQUFVLEVBQUUsbUJBQW1CLCtJQUErSSxxQkFBcUIseUJBQXlCLFVBQVUsVUFBVSxFQUFFLGVBQWUsT0FBTyx3QkFBd0IseUJBQXlCLFVBQVUsY0FBYyxFQUFFLGlCQUFpQixzQ0FBc0MsY0FBYyxnQ0FBZ0MsaUJBQWlCLFVBQVUsYUFBYSxFQUFFLGlCQUFpQix3Q0FBd0Msd0hBQXdILFFBQVEsTUFBTSxPQUFPLElBQUksa0VBQWtFLCtFQUErRSxHQUFHLE1BQU0sRUFBRSw0QkFBNEIsMENBQTBDLGVBQWUsZ0NBQWdDLDJEQUEyRCxxQkFBcUIsZ0NBQWdDLDRCQUE0QixxQkFBcUIsS0FBSyxtQ0FBbUMsZ0JBQWdCLFVBQVUsUUFBUSxFQUFFLG9CQUFvQixpQ0FBaUMsRUFBRSxnQkFBZ0IsWUFBWSwyQkFBMkIsVUFBVSxXQUFXLEVBQUUsZUFBZSxPQUFPLDRCQUE0Qix5QkFBeUIsVUFBVSxRQUFRLEVBQUUsaUJBQWlCLGlEQUFpRCxrRUFBa0UsU0FBUyx3Q0FBd0MsRUFBRSxHQUFHLFNBQVMsVUFBVSxnQkFBZ0IsRUFBRSxlQUFlLHFCQUFxQixpSUFBaUksT0FBTyxLQUFLLHlCQUF5QixVQUFVLFFBQVEsRUFBRSxpQkFBaUIsWUFBWSxXQUFXLHdDQUF3QyxTQUFTLG1CQUFtQixxQ0FBcUMsWUFBWSxJQUFJLG9EQUFvRCxTQUFTLGlCQUFpQixvQkFBb0IsWUFBWSxJQUFJLG9DQUFvQyxxQkFBcUIsWUFBWSxpQkFBaUIsa0JBQWtCLGlCQUFpQixtQkFBbUIsaUJBQWlCLEdBQUcsa0RBQWtELEdBQUcsV0FBVyxHQUFHLFNBQVMsaUJBQWlCLHVCQUF1QixTQUFTLFlBQVksSUFBSSxpQ0FBaUMsaUNBQWlDLGVBQWUsK0RBQStELGlCQUFpQixTQUFTLGNBQWMsSUFBSSxjQUFjLFNBQVMsMkJBQTJCLE9BQU8saUJBQWlCLElBQUksK0JBQStCLDJCQUEyQixVQUFVLFFBQVEsRUFBRSwyQkFBMkIsT0FBTyxpQkFBaUIsSUFBSSxtQkFBbUIsMkJBQTJCLFVBQVUsUUFBUSxFQUFFLGlCQUFpQiwyQ0FBMkMsY0FBYyxPQUFPLFNBQVMseUJBQXlCLFVBQVUsUUFBUSxFQUFFLGlCQUFpQiw4SkFBOEosZ0pBQWdKLHFCQUFxQixlQUFlLE9BQU8sNkJBQTZCLHlCQUF5QixVQUFVLFNBQVMsRUFBRSxlQUFlLDZCQUE2Qiw2QkFBNkIsSUFBSSxJQUFJLFVBQVUsV0FBVyxFQUFFLDJCQUEyQixxQkFBcUIsb0NBQW9DLE9BQU8sSUFBSSxJQUFJLG1CQUFtQiwyQkFBMkIsVUFBVSxRQUFRLEVBQUUseUNBQXlDLGtCQUFrQiwwQkFBMEIsTUFBTSxvQkFBb0IsZ0JBQWdCLGNBQWMsd0JBQXdCLDJCQUEyQixpREFBaUQsbUVBQW1FLDRCQUE0Qiw4QkFBOEIsK0JBQStCLG1FQUFtRSxxREFBcUQsRUFBRSxHQUFHLG1DQUFtQywwQ0FBMEMsMENBQTBDLDJDQUEyQyxxREFBcUQscURBQXFELEVBQUUsR0FBRyxnREFBZ0QsRUFBRSxHQUFHLFVBQVUsU0FBUyxFQUFFLDJCQUEyQiw2QkFBNkIsVUFBVSxrQkFBa0IsRUFBRSxlQUFlLE9BQU8sa0JBQWtCLHlCQUF5QixVQUFVLFFBQVEsRUFBRSxtQkFBbUIsZ0RBQWdELHNEQUFzRCxPQUFPLFFBQVEsSUFBSSxPQUFPLDJCQUEyQixVQUFVLGVBQWUsRUFBRSxlQUFlLE9BQU8sb0JBQW9CLHlCQUF5QixVQUFVLFVBQVUsRUFBRSxpQkFBaUIsMENBQTBDLDZEQUE2RCxRQUFRLDRCQUE0QixFQUFFLElBQUksT0FBTyxJQUFJLElBQUksUUFBUSwyQkFBMkIsVUFBVSxTQUFTLEVBQUUsK0JBQStCLGVBQWUsNkJBQTZCLFlBQVksSUFBSSxpQkFBaUIsNEJBQTRCLG9CQUFvQiw4Q0FBOEMseURBQXlELG9FQUFvRSxxRkFBcUYsU0FBUyxLQUFLLFVBQVUsUUFBUSxFQUFFLGVBQWUsT0FBTyw4QkFBOEIseUJBQXlCLFVBQVUsVUFBVSxFQUFFLHlCQUF5Qiw2REFBNkQsY0FBYyxJQUFJLG9CQUFvQiwyQkFBMkIsVUFBVSxXQUFXLEVBQUUsaUJBQWlCLHNGQUFzRixrQ0FBa0MsT0FBTyxTQUFTLHlCQUF5QixVQUFVLFlBQVksRUFBRSxpQkFBaUIsZ0dBQWdHLGtDQUFrQyxPQUFPLFNBQVMseUJBQXlCLFVBQVUsaUJBQWlCLEVBQUUsZUFBZSxPQUFPLDJCQUEyQix5QkFBeUIsVUFBVSxTQUFTLEVBQUUsZUFBZSxPQUFPLHVCQUF1Qix5QkFBeUIsVUFBVSxhQUFhLEVBQUUsZUFBZSxPQUFPLG9CQUFvQix5QkFBeUIsVUFBVSxVQUFVLEVBQUUsZUFBZSxPQUFPLG9CQUFvQix5QkFBeUIsVUFBVSxVQUFVLEVBQUUsb0JBQW9CLE9BQU8sdUJBQXVCLElBQUksU0FBUywyQkFBMkIsVUFBVSxjQUFjLEVBQUUsaUJBQWlCLGdGQUFnRixrQ0FBa0MsT0FBTyxTQUFTLHlCQUF5QixVQUFVLFNBQVMsRUFBRSxpQkFBaUIsMEZBQTBGLGtDQUFrQyxPQUFPLFNBQVMseUJBQXlCLFVBQVUsY0FBYyxFQUFFLG1CQUFtQixvRUFBb0UsT0FBTyxzQkFBc0Isd0JBQXdCLElBQUksZ0NBQWdDLDRDQUE0QztBQUN0a1Usc0JBQXNCLE9BQU8sMkdBQTJHLEVBQUUsSUFBSSxhQUFhLCtEQUErRCxPQUFPLElBQUksSUFBSSxvQ0FBb0MsdUJBQXVCLG1EQUFtRCxVQUFVLCtCQUErQixFQUFFLGVBQWUsT0FBTyw0QkFBNEIseUJBQXlCLFVBQVUsUUFBUSxFQUFFLGVBQWUsT0FBTyxvQkFBb0IseUJBQXlCLFVBQVUsVUFBVSxFQUFFLGVBQWUseUVBQXlFLGdGQUFnRixtQkFBbUIsSUFBSSxnQkFBZ0IsNkJBQTZCLGdJQUFnSSxHQUFHLGVBQWUsMEVBQTBFLDJHQUEyRyxzRkFBc0YsbUJBQW1CLElBQUksZ0JBQWdCLDhCQUE4Qiw0SUFBNEksR0FBRyxlQUFlLGlGQUFpRix3S0FBd0ssSUFBSSxnQkFBZ0IsNkJBQTZCLGNBQWMsb0JBQW9CLGVBQWUsa0ZBQWtGLHlOQUF5TixtQ0FBbUMsaUtBQWlLLGlCQUFpQixpTkFBaU4sY0FBYyxPQUFPLEtBQUssb0VBQW9FLGtEQUFrRCw0SUFBNEksR0FBRywwQkFBMEIsVUFBVSxnQkFBZ0IseUJBQXlCLDJUQUEyVCxRQUFRLFNBQVMsU0FBUyx5QkFBeUIsNkJBQTZCLHlDQUF5QyxpQkFBaUIsZUFBZSx1QkFBdUIsZUFBZTtBQUN4ekcsc0VBQXNFLGVBQWUsT0FBTyxrQkFBa0IseUJBQXlCLFVBQVUsUUFBUSxFQUFFLGVBQWUsT0FBTyx1QkFBdUIseUJBQXlCLFVBQVUsYUFBYSxFQUFFLGVBQWUsNEJBQTRCLGVBQWUsK0NBQStDLE1BQU0sVUFBVSxlQUFlLEVBQUUsaUJBQWlCLHNDQUFzQyxjQUFjLE9BQU8sU0FBUyx5QkFBeUIsVUFBVSxRQUFRLEVBQUUsb0JBQW9CLGlDQUFpQyxpSUFBaUksUUFBUSxlQUFlLEVBQUUsR0FBRyxrQkFBa0Isb0VBQW9FLGVBQWUseUJBQXlCLHNCQUFzQiw4QkFBOEIsS0FBSyxVQUFVLGVBQWUsRUFBRSwyQkFBMkIsZ0hBQWdILE1BQU0sb0JBQW9CLGNBQWMsU0FBUyxVQUFVLGNBQWMsRUFBRSxpQkFBaUIsa0VBQWtFLG9CQUFvQixPQUFPLFNBQVMseUJBQXlCLFVBQVUsZUFBZSxFQUFFLGVBQWUsT0FBTyxnQ0FBZ0MseUJBQXlCLFVBQVUsZUFBZSxFQUFFLGlCQUFpQixnRUFBZ0Usb0JBQW9CLE9BQU8sU0FBUyx5QkFBeUIsVUFBVSxjQUFjLEVBQUUsaUJBQWlCLGtFQUFrRSxtREFBbUQsVUFBVSxlQUFlLGdCQUFnQiwwQkFBMEIsOEpBQThKLG9GQUFvRiw2R0FBNkcsd0VBQXdFLEdBQUcsR0FBRyxzRUFBc0UsSUFBSSw2QkFBNkIsV0FBVyxHQUFHLE9BQU8sMEJBQTBCLElBQUksUUFBUSwyQkFBMkIsVUFBVSxpQkFBaUIsRUFBRSxpQkFBaUIsc0JBQXNCLHVCQUF1QixzQ0FBc0MsdUlBQXVJLE9BQU8sMEZBQTBGLEdBQUcsaUJBQWlCLEVBQUUsc0JBQXNCLE9BQU8sSUFBSSxJQUFJLCtDQUErQyx1QkFBdUIsbURBQW1ELFVBQVUsWUFBWSxFQUFFLHlDQUF5QyxvQ0FBb0MsZ0pBQWdKLE9BQU8sc0dBQXNHLEVBQUUsdUJBQXVCLE9BQU8sSUFBSSxJQUFJLDREQUE0RCx1QkFBdUIsOERBQThELFVBQVUsY0FBYyxFQUFFLDBCQUEwQixPQUFPLCtCQUErQixJQUFJLG1EQUFtRCx1QkFBdUIsT0FBTywwQkFBMEIsVUFBVSxzQkFBc0IsRUFBRSxpQkFBaUIsOENBQThDLHNGQUFzRixPQUFPLFNBQVMseUJBQXlCLFVBQVUsWUFBWSxFQUFFLDJCQUEyQixPQUFPLGtCQUFrQixJQUFJLG1CQUFtQiwyQkFBMkIsVUFBVSxTQUFTLEVBQUUsMkJBQTJCLDBCQUEwQix3Q0FBd0MsZUFBZSxrQkFBa0IsMkJBQTJCLDJCQUEyQiwwQkFBMEIsd0NBQXdDLGVBQWUsa0JBQWtCLDJCQUEyQixpQkFBaUIsZ0JBQWdCLEdBQUcsRUFBRSw2Q0FBNkMsR0FBRyw0Q0FBNEMsdUJBQXVCLDREQUE0RCx3QkFBd0Isd0ZBQXdGLGdMQUFnTCxpQkFBaUIsOENBQThDLHNGQUFzRixPQUFPLFNBQVMseUJBQXlCLFVBQVUsWUFBWSxFQUFFLG1CQUFtQixvR0FBb0csRUFBRSxJQUFJLDJCQUEyQixnR0FBZ0csZ0VBQWdFLE9BQU8sUUFBUSxTQUFTLElBQUksd0JBQXdCLFlBQVksU0FBUyxzTEFBc0wsR0FBRyxxQ0FBcUMsY0FBYyxvQ0FBb0MsUUFBUSxHQUFHLE9BQU8sa0JBQWtCLElBQUksS0FBSywyQkFBMkIsVUFBVSxjQUFjLEVBQUUsaUJBQWlCLHNDQUFzQyxjQUFjLE9BQU8sU0FBUyx5QkFBeUIsVUFBVSxRQUFRLEVBQUUsMkJBQTJCLHFCQUFxQiwwQ0FBMEMscUJBQXFCLGlEQUFpRCxPQUFPLG1CQUFtQixVQUFVLFlBQVksRUFBRSxxQkFBcUIsZ0dBQWdHLFlBQVksV0FBVyxLQUFLLHdCQUF3QixpQ0FBaUMsY0FBYyxZQUFZLFdBQVcsaUNBQWlDLFlBQVksVUFBVSxpQkFBaUIsRUFBRSx3QkFBd0Isb0RBQW9ELHNGQUFzRixFQUFFLElBQUksdUVBQXVFLEVBQUUsR0FBRyxtQkFBbUIsT0FBTywyQkFBMkIsSUFBSSxpQ0FBaUMsdUJBQXVCLDZCQUE2QixVQUFVLGdCQUFnQixFQUFFLGlCQUFpQix3RkFBd0Ysa0NBQWtDLE9BQU8sU0FBUyx5QkFBeUIsVUFBVSxhQUFhLEVBQUUsbUNBQW1DLHdFQUF3RSxFQUFFLEdBQUcsT0FBTyx3Q0FBd0MsSUFBSSxzQ0FBc0MsMkJBQTJCLFVBQVUsV0FBVyxFQUFFLGVBQWUsT0FBTyx1QkFBdUIseUJBQXlCLFVBQVUsYUFBYSxFQUFFLGlCQUFpQiwwREFBMEQsNEZBQTRGLFFBQVEsTUFBTSxPQUFPLElBQUksZ0NBQWdDLGVBQWUsVUFBVSxpQkFBaUIsRUFBRSxxQkFBcUIscUJBQXFCLG9GQUFvRixPQUFPLDJCQUEyQixJQUFJLEtBQUssMkJBQTJCLFVBQVUsUUFBUSxFQUFFLHFCQUFxQiwwRkFBMEYsVUFBVSxVQUFVLEVBQUUscUJBQXFCLCtIQUErSCxVQUFVLFVBQVUsRUFBRSxxQkFBcUIsZ0pBQWdKLFVBQVUsVUFBVSxFQUFFLHFCQUFxQixpS0FBaUssVUFBVSxVQUFVLEVBQUUsbUJBQW1CLGdDQUFnQyx1Q0FBdUMsUUFBUSxnQ0FBZ0MsU0FBUyxrREFBa0QsVUFBVSxnQ0FBZ0MsU0FBUywwSEFBMEgsa0JBQWtCLGdCQUFnQixjQUFjLG1DQUFtQyxhQUFhLEdBQUcsT0FBTyxJQUFJLElBQUkseUJBQXlCLDJCQUEyQixVQUFVLG1CQUFtQixFQUFFLDJCQUEyQixxREFBcUQsa0NBQWtDLGtKQUFrSixHQUFHLGlCQUFpQixFQUFFLElBQUksaUVBQWlFLGtFQUFrRSxnS0FBZ0ssbURBQW1ELG1CQUFtQiwrSkFBK0osWUFBWSxpQkFBaUIsb0dBQW9HLGlDQUFpQyxVQUFVLFNBQVMsRUFBRSxpQkFBaUIsaURBQWlELGFBQWEseUJBQXlCLFVBQVUsVUFBVSxFQUFFLDJCQUEyQixzQkFBc0Isb0NBQW9DLE9BQU8sSUFBSSxJQUFJLG1CQUFtQiwyQkFBMkIsVUFBVSxTQUFTLEVBQUUscUJBQXFCLGlDQUFpQyxFQUFFLGdIQUFnSCxtREFBbUQsSUFBSSxtQkFBbUIsdUJBQXVCLE9BQU8sMEVBQTBFLFVBQVUsaUJBQWlCLEVBQUUsbUJBQW1CLGlIQUFpSCwyQkFBMkIscUJBQXFCLE9BQU8sd0NBQXdDLFVBQVUsZ0JBQWdCLEVBQUUsdUJBQXVCLDJLQUEySyxFQUFFLHNDQUFzQyxzREFBc0QsSUFBSSxxQkFBcUIsMkJBQTJCLFVBQVUseUJBQXlCLEVBQUUsbUJBQW1CLE1BQU0sbUJBQW1CLGdEQUFnRCx3Q0FBd0MsdUNBQXVDLDBDQUEwQyxFQUFFLEdBQUcsWUFBWSxJQUFJLGFBQWEsMkJBQTJCLFVBQVUsU0FBUyxvQkFBb0IsT0FBTywyUUFBMlEsRUFBRSxrQkFBa0IsbUJBQW1CLGtEQUFrRCxjQUFjLDZDQUE2QyxtQkFBbUIsU0FBUyxrREFBa0QsOENBQThDLGtFQUFrRSxFQUFFLGNBQWMsRUFBRSxHQUFHLHVDQUF1QyxvQkFBb0Isc0VBQXNFLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxvQ0FBb0MsZ0ZBQWdGLFVBQVUsZUFBZSxTQUFTO0FBQ2o4WSxZQUFZLEVBQUU7QUFDZCxZQUFZLEVBQUUsSUFBSSxZQUFZLFdBQVcsS0FBSyxrQkFBa0Isb0RBQW9ELEVBQUUsTUFBTSxFQUFFLGFBQWEsRUFBRSxNQUFNLEVBQUU7QUFDckosWUFBWSxFQUFFO0FBQ2QsWUFBWSxFQUFFLElBQUksK0NBQStDLGlCQUFpQiw4RUFBOEUsaUJBQWlCLHdFQUF3RSxxRkFBcUYsbUJBQW1CLDhFQUE4RSxFQUFFLGlCQUFpQixFQUFFLEdBQUcsK0NBQStDLG1CQUFtQiwyRUFBMkUsbUJBQW1CLFlBQVksV0FBVyw0REFBNEQsTUFBTSxPQUFPLEVBQUUsVUFBVSxFQUFFLEdBQUcsaUJBQWlCLGdEQUFnRCwrRUFBK0UsU0FBUyxlQUFlLFNBQVMsR0FBRyxZQUFZLFdBQVcsb0VBQW9FLEdBQUcsUUFBUSxNQUFNLFVBQVUsTUFBTSxVQUFVLGVBQWUsWUFBWSxXQUFXLEtBQUssV0FBVyxrQ0FBa0MsU0FBUyxlQUFlLHNDQUFzQyxpTEFBaUwsa0RBQWtELEVBQUUscUJBQXFCLHNFQUFzRSwrQkFBK0IsRUFBRSxhQUFhLHVCQUF1QixpS0FBaUssdUJBQXVCLGtDQUFrQyxZQUFZLHlCQUF5QixtQkFBbUIsMEJBQTBCLGFBQWEsS0FBSyxHQUFHLEVBQUUsVUFBVSxxREFBcUQsbUJBQW1CLGtDQUFrQyw0R0FBNEcsNEdBQTRHLGdCQUFnQixnRUFBZ0Usb0JBQW9CLHFDQUFxQyxVQUFVLHFCQUFxQix3Q0FBd0MsdUJBQXVCLHFJQUFxSSxZQUFZLGdCQUFnQixNQUFNLEVBQUUseUNBQXlDLFlBQVkscUdBQXFHLDBHQUEwRyxnQkFBZ0IsK0NBQStDLFVBQVUseUJBQXlCLDJQQUEyUCxHQUFHLElBQUksR0FBRyw4QkFBOEIsdUJBQXVCLGdCQUFnQiw2Q0FBNkMsWUFBWSw4REFBOEQsbUNBQW1DLG1IQUFtSCxFQUFFLEdBQUcsZ0NBQWdDLFlBQVksa0JBQWtCLDhCQUE4QixvQkFBb0IsVUFBVSxnQkFBZ0IsRUFBRSwyQkFBMkIsc0VBQXNFLEVBQUUsR0FBRyxtQ0FBbUMsWUFBWSxrQkFBa0IsOEJBQThCLG9CQUFvQixVQUFVLGlCQUFpQixFQUFFLG1CQUFtQixnRUFBZ0UsRUFBRSxHQUFHLHFCQUFxQixVQUFVLHlCQUF5QixFQUFFLHFDQUFxQyxNQUFNLG1DQUFtQyxZQUFZLGtCQUFrQiw4QkFBOEIsb0JBQW9CLFVBQVUsa0JBQWtCLEVBQUUscUJBQXFCLDJCQUEyQixVQUFVLHFCQUFxQixFQUFFLGlDQUFpQyx1REFBdUQsT0FBTywrQkFBK0Isd0JBQXdCLElBQUksZUFBZSxPQUFPLDJCQUEyQix5QkFBeUIsVUFBVSxTQUFTLEVBQUUsZUFBZSxPQUFPLHlCQUF5Qix5QkFBeUIsVUFBVSxlQUFlLEVBQUUsZUFBZSxPQUFPLG1CQUFtQix5QkFBeUIsVUFBVSxTQUFTLEVBQUUsZUFBZSxPQUFPLG9CQUFvQix5QkFBeUIsVUFBVSxVQUFVLEVBQUUsaUJBQWlCLE9BQU8scUJBQXFCLElBQUksUUFBUSwyQkFBMkIsVUFBVSxZQUFZLEVBQUUsZUFBZSx5QkFBeUIsNkVBQTZFLE9BQU8sWUFBWSxVQUFVLGNBQWMsRUFBRSxpQkFBaUIseUJBQXlCLDZFQUE2RSxPQUFPLFlBQVksVUFBVSxjQUFjLEVBQUUsaUJBQWlCLHlCQUF5Qiw2RUFBNkUsT0FBTyxZQUFZLFVBQVUsY0FBYyxFQUFFLGlCQUFpQix5QkFBeUIsNkVBQTZFLE9BQU8sWUFBWSxVQUFVLGNBQWMsRUFBRSxlQUFlLE9BQU8sb0JBQW9CLHlCQUF5QixVQUFVLFVBQVUsRUFBRSxlQUFlLE9BQU8sOEJBQThCLHlCQUF5QixVQUFVLFVBQVUsRUFBRSxlQUFlLE9BQU8sbUJBQW1CLHlCQUF5QixVQUFVLFNBQVMsRUFBRSx3Q0FBd0MsZ0lBQWdJLDBKQUEwSix5QkFBeUIsaUZBQWlGLE9BQU8sZ0dBQWdHLE9BQU8sZ0dBQWdHLE9BQU8sa0hBQWtILFdBQVcsa0hBQWtILFdBQVcsSUFBSSw4QkFBOEIsb0dBQW9HLElBQUksWUFBWSxXQUFXLElBQUksNENBQTRDLG1EQUFtRCxVQUFVLG9CQUFvQixFQUFFLHVCQUF1QixrREFBa0QsMEVBQTBFLFFBQVEsV0FBVyxRQUFRLDJEQUEyRCxRQUFRLDJEQUEyRCxRQUFRLEtBQUssdURBQXVELFlBQVksV0FBVyxxQkFBcUIsZ0RBQWdELGdCQUFnQixXQUFXLHNEQUFzRCxrQ0FBa0MsVUFBVSxlQUFlLE9BQU8sbUJBQW1CLHlCQUF5QixVQUFVLFNBQVMsRUFBRSxlQUFlLE9BQU8sNEJBQTRCLHlCQUF5QixVQUFVLFFBQVEsRUFBRSxlQUFlLE9BQU8sbUJBQW1CLHlCQUF5QixVQUFVLFNBQVMsRUFBRSxtQkFBbUIseUJBQXlCLDJFQUEyRSxRQUFRLHVCQUF1QixVQUFVLFlBQVksRUFBRSxtQkFBbUIseUJBQXlCLDJFQUEyRSxRQUFRLG1CQUFtQixVQUFVLFlBQVksRUFBRSxtQkFBbUIseUJBQXlCLDJFQUEyRSxRQUFRLG1CQUFtQixVQUFVLFlBQVksRUFBRSxtQkFBbUIseUJBQXlCLDJFQUEyRSxRQUFRLG1CQUFtQixVQUFVLFlBQVksRUFBRSxvQkFBb0Isd0NBQXdDLDZIQUE2SCxRQUFRLGNBQWMsRUFBRSxHQUFHLE9BQU8sU0FBUyxJQUFJLE9BQU8sMkJBQTJCLFVBQVUsWUFBWSxFQUFFLGVBQWUseUZBQXlGLFFBQVEsSUFBSSxPQUFPLFNBQVMseUJBQXlCLFVBQVUsUUFBUSxFQUFFLGVBQWUsMEZBQTBGLFFBQVEsSUFBSSxPQUFPLFNBQVMseUJBQXlCLFVBQVUsU0FBUyxFQUFFLGVBQWUsNkNBQTZDLFNBQVMsaUJBQWlCLFFBQVEsS0FBSywyS0FBMkssUUFBUSx1Q0FBdUMscUJBQXFCLCtDQUErQyxTQUFTLFVBQVUsVUFBVSxFQUFFLHFCQUFxQixPQUFPLG1CQUFtQixJQUFJLDBCQUEwQiwyQkFBMkIsVUFBVSxVQUFVLEVBQUUsaUJBQWlCLDZFQUE2RSxRQUFRLEdBQUcsNkNBQTZDLGlCQUFpQiw0Q0FBNEMsc0NBQXNDLHNCQUFzQix3QkFBd0IsNkRBQTZELFNBQVMsK0pBQStKLGdEQUFnRCxVQUFVLFNBQVMsRUFBRSxpQkFBaUIsa0VBQWtFLGtDQUFrQyxPQUFPLFFBQVEsTUFBTSwyQkFBMkIsVUFBVSxzQkFBc0IsRUFBRSxpQkFBaUIsNkNBQTZDLG1DQUFtQyxVQUFVLFlBQVksRUFBRSxtQkFBbUIsa0RBQWtELCtIQUErSCxXQUFXLFFBQVEsMkJBQTJCLFVBQVUsVUFBVSxFQUFFLG1CQUFtQixPQUFPLGtCQUFrQixJQUFJLFNBQVMsMkJBQTJCLFVBQVUsU0FBUyxFQUFFLHlDQUF5QyxPQUFPLDhDQUE4QyxJQUFJLDZGQUE2RiwyQkFBMkIsVUFBVSxpQkFBaUIsRUFBRSxlQUFlLE9BQU8sNEJBQTRCLHlCQUF5QixVQUFVLFFBQVEsRUFBRSxpQkFBaUIsTUFBTSxjQUFjLHNGQUFzRixzQkFBc0IsbUJBQW1CLGdHQUFnRyxjQUFjLGdIQUFnSCx5SEFBeUgsbUJBQW1CLG1CQUFtQixrR0FBa0csY0FBYyxrSEFBa0gsb0hBQW9ILG1CQUFtQixtQkFBbUIsaUdBQWlHLGNBQWMsb0hBQW9ILG9IQUFvSCxtQkFBbUIsbUJBQW1CLGlHQUFpRyxjQUFjLHNIQUFzSCxvSEFBb0gsbUJBQW1CLG1CQUFtQixnR0FBZ0csY0FBYyx3SEFBd0gsb0hBQW9ILDBCQUEwQixVQUFVLE9BQU8sdUVBQXVFLEVBQUUsbUJBQW1CLHdKQUF3SixRQUFRLG1CQUFtQixRQUFRLFdBQVcsRUFBRSxjQUFjLEVBQUUsa0JBQWtCLEVBQUUsR0FBRyxnREFBZ0QsRUFBRSxLQUFLLHFFQUFxRSxhQUFhLEdBQUcsOERBQThELGFBQWEsR0FBRyxZQUFZLElBQUksbUVBQW1FLEVBQUUsS0FBSyxXQUFXLHFCQUFxQixFQUFFLEtBQUssV0FBVyxLQUFLLFlBQVksV0FBVyxpRUFBaUUsSUFBSSxLQUFLLGFBQWEsYUFBYSxJQUFJLEtBQUssT0FBTyxJQUFJLG1CQUFtQiwyR0FBMkcsT0FBTyxJQUFJLDJHQUEyRyxPQUFPLElBQUksK0ZBQStGLFFBQVEsR0FBRywyRkFBMkYsRUFBRSxHQUFHLGlCQUFpQixvRkFBb0YsUUFBUSxHQUFHLG9GQUFvRixRQUFRLEdBQUcsVUFBVSxtQkFBbUIseURBQXlELFlBQVksSUFBSSxZQUFZLGdFQUFnRSxPQUFPLDZEQUE2RCxtQkFBbUIsZ0lBQWdJLHNIQUFzSCxTQUFTLE1BQU0sUUFBUSxJQUFJLE9BQU8sNkJBQTZCLE1BQU0sMkJBQTJCLFVBQVUsd0JBQXdCLEVBQUUsd0JBQXdCLHNCQUFzQixvRkFBb0YsZ0NBQWdDLG9FQUFvRSxFQUFFLEdBQUcsOEVBQThFLEVBQUUsWUFBWSxFQUFFLEdBQUcsT0FBTyxJQUFJLElBQUksYUFBYSwyQkFBMkIsT0FBTyxvQkFBb0IsVUFBVSxTQUFTLEVBQUUsMkJBQTJCLHdFQUF3RSxPQUFPLEdBQUcsbUNBQW1DLFlBQVksa0JBQWtCLDhCQUE4QixvQkFBb0IsVUFBVSxvQkFBb0IsRUFBRSxtQkFBbUIsNENBQTRDLHVEQUF1RCxPQUFPLElBQUksSUFBSSxPQUFPLDJCQUEyQixPQUFPLG9CQUFvQixVQUFVLFdBQVcsRUFBRSxtQkFBbUIscUZBQXFGLGdEQUFnRCxPQUFPLGlCQUFpQixJQUFJLGVBQWUsMkJBQTJCLFVBQVUsdUJBQXVCLEVBQUUsbUJBQW1CLDZDQUE2QyxxREFBcUQsR0FBRyxjQUFjLGVBQWUsSUFBSSxlQUFlLElBQUksT0FBTyxRQUFRLElBQUksUUFBUSwyQkFBMkIsVUFBVSxZQUFZLEVBQUUsaUJBQWlCLHVCQUF1Qix3QkFBd0IsK0JBQStCLGlCQUFpQixTQUFTLFlBQVksV0FBVyxvQkFBb0Isc0RBQXNELFlBQVksV0FBVyxLQUFLLHNDQUFzQyxrQkFBa0Isb0JBQW9CLHFCQUFxQiw0RUFBNEUsNEJBQTRCLFVBQVUseUJBQXlCLGdHQUFnRyxrSUFBa0ksUUFBUSxZQUFZLE1BQU0sWUFBWSx1R0FBdUcsK0ZBQStGLFVBQVUsbUJBQW1CLDJCQUEyQiw2R0FBNkcsUUFBUSw0QkFBNEIsRUFBRSxrQkFBa0Isb0VBQW9FLFVBQVUsVUFBVSxFQUFFLEdBQUcsNkJBQTZCLE9BQU8sSUFBSSxJQUFJLFFBQVEsb0NBQW9DLG9CQUFvQix5QkFBeUIsSUFBSSxzQkFBc0IsSUFBSSx5QkFBeUIsc0JBQXNCLFVBQVUsY0FBYyxFQUFFLDBCQUEwQix5RkFBeUYsK0RBQStELHFDQUFxQyxNQUFNLGdFQUFnRSxrQ0FBa0Msc0JBQXNCLGNBQWMsVUFBVSxrQkFBa0IsRUFBRSxtQkFBbUIsTUFBTSxzRUFBc0UsVUFBVSxPQUFPLG9CQUFvQixJQUFJLFNBQVMsMkJBQTJCLFVBQVUsY0FBYyxFQUFFLHFCQUFxQixtSEFBbUgsUUFBUSxJQUFJLGtHQUFrRyxRQUFRLElBQUksb0RBQW9ELGtGQUFrRixTQUFTLGVBQWUsRUFBRSxJQUFJLGFBQWEsd0ZBQXdGLFFBQVEscUJBQXFCLEVBQUUsSUFBSSwwRkFBMEYsdUJBQXVCLE1BQU0sMkpBQTJKLFlBQVksT0FBTyw4Q0FBOEMsSUFBSSxlQUFlLDJCQUEyQixVQUFVLGtCQUFrQixFQUFFLGlCQUFpQiwyQ0FBMkMsMERBQTBELHlCQUF5QixVQUFVLGFBQWEsRUFBRSxpQkFBaUIsa0NBQWtDLDBCQUEwQiw4QkFBOEIsU0FBUyxZQUFZLGlCQUFpQixpRUFBaUUsU0FBUyxTQUFTLHFCQUFxQix5QkFBeUIsNkdBQTZHLFNBQVMsdUZBQXVGLEVBQUUsNkNBQTZDLDJEQUEyRCxjQUFjLFVBQVUsWUFBWSxFQUFFLGVBQWUsa0VBQWtFLG1CQUFtQixrQ0FBa0MsWUFBWSxJQUFJLEtBQUssMEJBQTBCLHFCQUFxQix1QkFBdUIsMkJBQTJCLDREQUE0RCxzRkFBc0YsT0FBTyw4R0FBOEcsUUFBUSxtQkFBbUIsT0FBTywySUFBMkksZ0NBQWdDLDRGQUE0RixFQUFFLGFBQWEsRUFBRSxHQUFHLDBFQUEwRSxZQUFZLElBQUksS0FBSyxtQ0FBbUMsWUFBWSxXQUFXLFlBQVksbUJBQW1CLEVBQUUsc0NBQXNDLFlBQVksSUFBSSwwQkFBMEIsT0FBTyxPQUFPLGtFQUFrRSxnQkFBZ0IsT0FBTyxtREFBbUQsRUFBRSxrQ0FBa0MsUUFBUSwwREFBMEQsUUFBUSw0SUFBNEksUUFBUSxtRkFBbUYsUUFBUSwwRkFBMEYsRUFBRSxJQUFJLDBFQUEwRSwyREFBMkQsRUFBRSxzQ0FBc0MsS0FBSyw2REFBNkQsRUFBRSx3Q0FBd0MsS0FBSywrQkFBK0IsT0FBTyxTQUFTLElBQUksOERBQThELDJCQUEyQixVQUFVLHlCQUF5QixFQUFFLG1CQUFtQixrQ0FBa0MsZ0NBQWdDLGdFQUFnRSxFQUFFLElBQUksaUJBQWlCLDhCQUE4Qiw0Q0FBNEMscUJBQXFCLHlCQUF5QiwyQkFBMkIsMEJBQTBCLDRCQUE0Qiw4QkFBOEIsa0NBQWtDLDhCQUE4Qiw0Q0FBNEMsRUFBRSxJQUFJLG1DQUFtQyxhQUFhLDRKQUE0SixFQUFFLG1EQUFtRCw2REFBNkQsR0FBRyw2R0FBNkcsd0JBQXdCLHVDQUF1Qyw4RUFBOEUsNklBQTZJLE9BQU8sbUZBQW1GLE9BQU8sMkJBQTJCLHVDQUF1Qyx5REFBeUQsRUFBRSxzQ0FBc0MsV0FBVyx5RkFBeUYsR0FBRyxpQkFBaUIsRUFBRSxJQUFJLG9DQUFvQyx5TkFBeU4sZUFBZSwrR0FBK0csUUFBUSwwREFBMEQsY0FBYyxNQUFNLE1BQU0sWUFBWSxjQUFjLDhKQUE4SixTQUFTLDBHQUEwRyxFQUFFLDBEQUEwRCxjQUFjLEtBQUsseUJBQXlCLGlCQUFpQixTQUFTLDBEQUEwRCxFQUFFLDJEQUEyRCxXQUFXLElBQUksZUFBZSxzQ0FBc0MsY0FBYyx5RUFBeUUsR0FBRyx3Q0FBd0MsMkJBQTJCLG1JQUFtSSxFQUFFLElBQUksd0RBQXdELFlBQVksY0FBYyxVQUFVLFNBQVMsSUFBSSw2Q0FBNkMsSUFBSSwwRkFBMEYsNEJBQTRCLDBCQUEwQixrRUFBa0Usb0JBQW9CLHNCQUFzQiwwQkFBMEIsb0VBQW9FLG9CQUFvQixTQUFTLFVBQVUsZ0JBQWdCLEVBQUUsaUNBQWlDLFFBQVEsMERBQTBELFFBQVEsMERBQTBELE9BQU8sU0FBUyxJQUFJLDZEQUE2RCwyQkFBMkIsVUFBVSx3Q0FBd0MsRUFBRSxpQ0FBaUMsYUFBYSwrREFBK0QsT0FBTyxjQUFjLElBQUksMkRBQTJELHVCQUF1QixtREFBbUQsVUFBVSx1Q0FBdUMsRUFBRSxhQUFhLDRKQUE0SixFQUFFLHFDQUFxQyx3QkFBd0IsdUNBQXVDLGdHQUFnRyxzSkFBc0osT0FBTyw0RkFBNEYsT0FBTywrRkFBK0YsV0FBVyxrREFBa0QsV0FBVywySEFBMkgsR0FBRyxpQkFBaUIsRUFBRSxvQ0FBb0MsdUNBQXVDLDJFQUEyRSxNQUFNLDBEQUEwRCxjQUFjLCtIQUErSCxFQUFFLElBQUksK0VBQStFLFlBQVksY0FBYyxjQUFjLFlBQVksSUFBSSw2Q0FBNkMsSUFBSSwwRkFBMEYsNEJBQTRCLDBCQUEwQixrRUFBa0Usb0JBQW9CLHNCQUFzQiwwQkFBMEIsb0VBQW9FLG9CQUFvQixTQUFTLFVBQVUseUJBQXlCLEVBQUUsYUFBYSxrSEFBa0gsRUFBRSxxQ0FBcUMsa0JBQWtCLHVDQUF1Qyx3REFBd0QsY0FBYyxnT0FBZ08sb0RBQW9ELEVBQUUsU0FBUyxFQUFFLDJCQUEyQixTQUFTLE1BQU0sU0FBUyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxjQUFjLDhIQUE4SCxrRUFBa0UsTUFBTSxpREFBaUQsY0FBYywwQ0FBMEMsdUtBQXVLLGNBQWMsY0FBYyxpQkFBaUIsSUFBSSx3Q0FBd0MsSUFBSSx5REFBeUQsNEJBQTRCLDBCQUEwQixtQkFBbUIseUJBQXlCLHNCQUFzQiwwQkFBMEIscUJBQXFCLHlCQUF5QixTQUFTLFVBQVUsZ0JBQWdCLEVBQUUsZUFBZSxxQkFBcUIsVUFBVSxrQkFBa0IsRUFBRSxlQUFlLG1CQUFtQixVQUFVLGVBQWUsRUFBRSw0QkFBNEIsYUFBYSxLQUFLLFlBQVksd0JBQXdCLFVBQVUsU0FBUyxFQUFFLCtDQUErQyxlQUFlLHVEQUF1RCxVQUFVLFVBQVUsRUFBRSwwQkFBMEIsbUJBQW1CLDRCQUE0QixlQUFlLFVBQVUsU0FBUyxFQUFFLHNDQUFzQyxpSUFBaUksOEVBQThFLE9BQU8seUZBQXlGLEVBQUUsb0JBQW9CLFFBQVEsMEZBQTBGLEVBQUUsa0JBQWtCLFFBQVEsK0ZBQStGLFNBQVMsc0VBQXNFLEVBQUUsc0ZBQXNGLEVBQUUsR0FBRyxPQUFPLHlCQUF5QixJQUFJLDBDQUEwQywyQkFBMkIsVUFBVSxrQkFBa0IsRUFBRSxlQUFlLDZDQUE2Qyw4RUFBOEUsT0FBTyxJQUFJLE9BQU8sU0FBUywwQkFBMEIsRUFBRSxVQUFVLGtCQUFrQixFQUFFLGVBQWUsNERBQTRELHlGQUF5RixPQUFPLCtHQUErRyxFQUFFLElBQUksd0JBQXdCLG9DQUFvQyxVQUFVLG1CQUFtQixFQUFFLGVBQWUsNERBQTRELHlGQUF5RixPQUFPLDBHQUEwRyxFQUFFLElBQUksMERBQTBELGVBQWUsMkJBQTJCLE1BQU0sNkJBQTZCLE1BQU0sK0JBQStCLE1BQU0saUNBQWlDLE1BQU0sbUNBQW1DLE1BQU0sb0RBQW9ELDBCQUEwQixVQUFVLG1CQUFtQixFQUFFLDBCQUEwQixnREFBZ0QsaUZBQWlGLE9BQU8sSUFBSSxPQUFPLFFBQVEsSUFBSSxnQ0FBZ0MsMkJBQTJCLFVBQVUscUJBQXFCLEVBQUUseUJBQXlCLHFFQUFxRSxpQkFBaUIsb0ZBQW9GLEVBQUUsb0VBQW9FLE9BQU8sNkVBQTZFLFdBQVcsNkhBQTZILEVBQUUsWUFBWSxXQUFXLGdFQUFnRSxFQUFFLEtBQUssZ0VBQWdFLG1EQUFtRCwrR0FBK0csc0RBQXNELE9BQU8saURBQWlELHVCQUF1QixpQkFBaUIsSUFBSSxVQUFVLHNCQUFzQixFQUFFLG1CQUFtQiwrQkFBK0IsZ0JBQWdCLG1CQUFtQixxQkFBcUIsaUJBQWlCLHNCQUFzQixtQkFBbUIsNEJBQTRCLEtBQUssSUFBSSxFQUFFLGNBQWMsZ0JBQWdCLHFCQUFxQixnQkFBZ0IsdUJBQXVCLHVCQUF1Qix5QkFBeUIsK0JBQStCLHlCQUF5QiwwQkFBMEIsd0NBQXdDLFNBQVMsWUFBWSxXQUFXLG9CQUFvQiwyQ0FBMkMsRUFBRSxXQUFXLDRCQUE0QixLQUFLLHVCQUF1QixFQUFFLGVBQWUsd0NBQXdDLEdBQUcsYUFBYSxTQUFTLHFCQUFxQixLQUFLLEtBQUssbUJBQW1CLFNBQVMsS0FBSyxNQUFNLDhDQUE4QyxpR0FBaUcscUJBQXFCLDBFQUEwRSxPQUFPLG1CQUFtQix1REFBdUQsbUJBQW1CLGdRQUFnUSx1QkFBdUIsc0dBQXNHLGlCQUFpQixtQkFBbUIsc0JBQXNCLGdCQUFnQixpQkFBaUIsaUVBQWlFLHlEQUF5RCxxR0FBcUcsc0RBQXNELDREQUE0RCxrQkFBa0IsZUFBZSwyREFBMkQsVUFBVSx1REFBdUQsNkZBQTZGLHVFQUF1RSxPQUFPLGlCQUFpQixJQUFJLCtEQUErRCx1QkFBdUIsT0FBTywwQ0FBMEMsVUFBVSwrQkFBK0IsRUFBRSw2REFBNkQsdUdBQXVHLHVFQUF1RSw0REFBNEQsbUNBQW1DLGlCQUFpQiw4Q0FBOEMsb0RBQW9ELFVBQVUsd0RBQXdELHlKQUF5SixpQkFBaUIsSUFBSSxxRUFBcUUsdUJBQXVCLE9BQU8sd0NBQXdDLFVBQVUsNEJBQTRCLEVBQUUsOERBQThELDhNQUE4TSxpQ0FBaUMsaUJBQWlCLDhDQUE4QywwREFBMEQsVUFBVSwyQkFBMkIscUNBQXFDLDZGQUE2RixPQUFPLG9GQUFvRixFQUFFLDhHQUE4RyxhQUFhLCtEQUErRCxXQUFXLFNBQVMsSUFBSSx5Q0FBeUMsdUJBQXVCLG1EQUFtRCxVQUFVLG1CQUFtQixFQUFFLDJCQUEyQiw0Q0FBNEMsb0dBQW9HLE9BQU8sMkZBQTJGLEVBQUUsc05BQXNOLGFBQWEsK0RBQStELFdBQVcsU0FBUyxJQUFJLHlDQUF5Qyx1QkFBdUIsbURBQW1ELFVBQVUsMEJBQTBCLEVBQUUsb0NBQW9DLHNHQUFzRyw2RUFBNkUsT0FBTyxtSEFBbUgsV0FBVyx1SEFBdUgsUUFBUSw2RUFBNkUsRUFBRSxtQkFBbUIseUJBQXlCLCtCQUErQixjQUFjLFNBQVMsZUFBZSx1Q0FBdUMsVUFBVSx3QkFBd0IsNEJBQTRCLGlCQUFpQiwrQ0FBK0MsWUFBWSxXQUFXLEtBQUssc0RBQXNELDRCQUE0QixjQUFjLHNEQUFzRCxrQkFBa0IsaUNBQWlDLGNBQWMsY0FBYyw4QkFBOEIsU0FBUyxVQUFVLGNBQWMsRUFBRSxnREFBZ0QsbUZBQW1GLDBFQUEwRSxPQUFPLDRQQUE0UCxFQUFFLElBQUksT0FBTyxxQkFBcUIsSUFBSSxzREFBc0QsMkJBQTJCLFVBQVUsY0FBYyxFQUFFLG1CQUFtQiwwQkFBMEIsNERBQTRELE9BQU8sSUFBSSwwQ0FBMEMsa0ZBQWtGLEVBQUUsd0NBQXdDLEVBQUUsaURBQWlELEVBQUUsK05BQStOLEVBQUUsd0NBQXdDLEVBQUUsb0RBQW9ELEVBQUUsNklBQTZJLDhHQUE4RyxvREFBb0QsVUFBVSxhQUFhLEVBQUUsZUFBZSxNQUFNLHFCQUFxQixvR0FBb0csb0JBQW9CLFlBQVksV0FBVyw2RkFBNkYsZUFBZSxNQUFNLEVBQUUsSUFBSSxpREFBaUQsa0VBQWtFLFNBQVMsa0NBQWtDLGNBQWMsS0FBSyxhQUFhLFlBQVksV0FBVyx1QkFBdUIsV0FBVyxtQkFBbUIsSUFBSSxLQUFLLDRCQUE0QixVQUFVLCtCQUErQixHQUFHLG1CQUFtQixVQUFVLGdCQUFnQixFQUFFLG9CQUFvQixtRkFBbUYsT0FBTyw4QkFBOEIsMElBQTBJLGNBQWMsaUJBQWlCLG9CQUFvQixFQUFFLDhDQUE4QyxhQUFhLG9CQUFvQixtQkFBbUIsbUVBQW1FLGVBQWUsWUFBWSxtRkFBbUYsWUFBWSxJQUFJLEtBQUssZ0JBQWdCLG9CQUFvQixrSEFBa0gseUVBQXlFLCtEQUErRCwrQkFBK0IsS0FBSywwQkFBMEIsOEJBQThCLDJDQUEyQywrQkFBK0IsS0FBSywwQkFBMEIsOEJBQThCLGNBQWMsY0FBYywrREFBK0QsRUFBRSxVQUFVLE9BQU8sS0FBSyxhQUFhLDhHQUE4RyxZQUFZLEdBQUcsNkNBQTZDLGlEQUFpRCxrREFBa0QsdUJBQXVCLHdCQUF3QiwyQkFBMkIsZ0JBQWdCLHlCQUF5QixzQ0FBc0MsMEJBQTBCLGtDQUFrQyx3Q0FBd0MsdURBQXVELG9CQUFvQixrQ0FBa0MsRUFBRSxHQUFHLFVBQVUsd0JBQXdCLEVBQUUsK0NBQStDLDBGQUEwRixxR0FBcUcsa0JBQWtCLGlCQUFpQixVQUFVLHVCQUF1QixFQUFFLGlEQUFpRCxrRkFBa0YsNkZBQTZGLG9DQUFvQyxpQkFBaUIsVUFBVSxtQkFBbUIsRUFBRSwrQ0FBK0Msd0VBQXdFLG1GQUFtRixZQUFZLG1CQUFtQix1QkFBdUIsaUJBQWlCLFVBQVUsY0FBYyxFQUFFLG1EQUFtRCx3RUFBd0UsbUZBQW1GLDBFQUEwRSxpQkFBaUIsVUFBVSxjQUFjLEVBQUUsc0RBQXNELG9FQUFvRSwrRUFBK0Usa0ZBQWtGLGlCQUFpQixVQUFVLFlBQVksRUFBRSwrQ0FBK0Msc0ZBQXNGLGlHQUFpRyxjQUFjLGlCQUFpQixVQUFVLHFCQUFxQixFQUFFLGlCQUFpQixvR0FBb0csK0RBQStELHlDQUF5QyxvQkFBb0IsbURBQW1ELGlHQUFpRywrR0FBK0csNkJBQTZCLHlCQUF5QixjQUFjLGlCQUFpQixVQUFVLHdCQUF3QixFQUFFLHNCQUFzQixvSkFBb0osUUFBUSxjQUFjLEVBQUUsR0FBRyxvQkFBb0IsMkNBQTJDLFNBQVMsaUJBQWlCLE9BQU8saUNBQWlDLDZCQUE2QixrRkFBa0YsT0FBTyxtREFBbUQsNkZBQTZGLCtHQUErRyxxQ0FBcUMsMEJBQTBCLGNBQWMsaUJBQWlCLFVBQVUsd0JBQXdCLEVBQUUscUJBQXFCLCtMQUErTDtBQUNyZy9DLFVBQVUsUUFBUSxHQUFHLDhFQUE4RSxRQUFRLEdBQUcsbUZBQW1GLFFBQVEsR0FBRyxxRkFBcUYsUUFBUSxHQUFHLE9BQU8sK0NBQStDLHFCQUFxQixPQUFPLGtGQUFrRixVQUFVLHdCQUF3QixFQUFFLG1CQUFtQix3SUFBd0k7QUFDL29CLFVBQVUsUUFBUSxHQUFHLG1GQUFtRixRQUFRLEdBQUcsaUZBQWlGLFFBQVEsR0FBRyxPQUFPLHVDQUF1QyxxQkFBcUIsT0FBTyxxQ0FBcUMsVUFBVSxrQkFBa0IsRUFBRSxtQkFBbUIsbUlBQW1JLHlGQUF5RjtBQUMza0IsWUFBWSxRQUFRLEdBQUc7QUFDdkIsWUFBWSxRQUFRLEdBQUcsT0FBTywrQkFBK0IseUJBQXlCLFVBQVUsc0JBQXNCLEVBQUUsbUJBQW1CLGdJQUFnSSx5RkFBeUY7QUFDcFcsV0FBVyxRQUFRLEdBQUc7QUFDdEIsV0FBVyxRQUFRLEdBQUcsT0FBTywrQkFBK0IseUJBQXlCLFVBQVUscUJBQXFCLEVBQUUsNkJBQTZCLDBDQUEwQyx5RUFBeUUscUVBQXFFLFFBQVEsR0FBRyx1Q0FBdUMsOEVBQThFLE9BQU8sbUZBQW1GLElBQUksb0JBQW9CLHVCQUF1QixPQUFPLCtCQUErQixVQUFVLGlCQUFpQixFQUFFLHNCQUFzQixvRkFBb0YsNkVBQTZFLFFBQVEsR0FBRyxpRkFBaUYsUUFBUSxHQUFHLE9BQU8sWUFBWSxJQUFJLG9CQUFvQix1QkFBdUIsT0FBTyxxQ0FBcUMsVUFBVSxnQkFBZ0IsRUFBRSxpQkFBaUIsd0RBQXdELGNBQWMsZ0VBQWdFLE9BQU8sU0FBUywyQkFBMkIsVUFBVSwyQkFBMkIsRUFBRSx3QkFBd0Isb0RBQW9ELHFDQUFxQyx1QkFBdUIsSUFBSSxJQUFJLFVBQVUsdUJBQXVCLE1BQU0sZ0NBQWdDLEtBQUssZ0RBQWdELEtBQUssMFVBQTBVLEtBQUssaUNBQWlDLEtBQUssc0tBQXNLLEtBQUssaUZBQWlGLEtBQUssK0VBQStFLE9BQU8sT0FBTywwRkFBMEYsRUFBRSxtQ0FBbUMsZUFBZSxrQ0FBa0MsdUJBQXVCLGlCQUFpQixhQUFhLGNBQWMscUJBQXFCLGdCQUFnQiwyREFBMkQsbUJBQW1CLHlEQUF5RCxtQkFBbUIsK1lBQStZLGtCQUFrQixnREFBZ0QsZUFBZSx1Q0FBdUMsd0JBQXdCLG1CQUFtQixJQUFJLGdCQUFnQiw0QkFBNEIsWUFBWSxpQkFBaUIsNkJBQTZCLEdBQUcsdUJBQXVCLDRCQUE0QixvQ0FBb0MsaUJBQWlCLHFFQUFxRSxzQkFBc0IsbUNBQW1DLHNCQUFzQixlQUFlLFVBQVUsNkNBQTZDLHVCQUF1QixxREFBcUQsaURBQWlELG1CQUFtQiwyRUFBMkUsb0JBQW9CLDRFQUE0RSxvQkFBb0IsR0FBRywyQkFBMkIsbUVBQW1FLDZDQUE2Qyw0RUFBNEUsRUFBRSx3QkFBd0IsdUJBQXVCLGlCQUFpQix3QkFBd0Isc0pBQXNKLGtCQUFrQixtRUFBbUUsb0NBQW9DLDJEQUEyRCxnQkFBZ0IsRUFBRSwrQ0FBK0MsaUVBQWlFLGdCQUFnQixFQUFFLDhDQUE4QyxFQUFFLHdDQUF3QyxrQkFBa0IsOEVBQThFLE9BQU8seUlBQXlJLHdCQUF3QixtQ0FBbUMsWUFBWSxFQUFFLDZCQUE2QixVQUFVLDZIQUE2SCxtQkFBbUIsNERBQTRELHNEQUFzRCxzQ0FBc0MsSUFBSSxvQkFBb0Isa0NBQWtDLHNCQUFzQiw0Q0FBNEMsa0RBQWtELG1EQUFtRCxrREFBa0QsR0FBRyxZQUFZLE9BQU8sa0VBQWtFLHVCQUF1Qiw4Q0FBOEMscUJBQXFCLHVCQUF1QixnQkFBZ0Isb0JBQW9CLG9GQUFvRixrQkFBa0IsbUVBQW1FLCtCQUErQiwyREFBMkQsZ0JBQWdCLEVBQUUsb0ZBQW9GLEVBQUUsd0NBQXdDLGtCQUFrQix3Q0FBd0MsT0FBTyxpQkFBaUIsWUFBWSxvRUFBb0UsWUFBWSxFQUFFLDZCQUE2QixVQUFVLDBFQUEwRSxtQkFBbUIsMEVBQTBFLHNDQUFzQyxJQUFJLG9CQUFvQixrQ0FBa0MsU0FBUyxpQ0FBaUMsa0RBQWtELEdBQUcsWUFBWSxPQUFPLHFGQUFxRix1QkFBdUIsd0RBQXdELHFCQUFxQix1QkFBdUIsYUFBYSwwQkFBMEIsMklBQTJJLDhEQUE4RCw4Q0FBOEMsa0JBQWtCLHVEQUF1RCxPQUFPLGdEQUFnRCxrQkFBa0Isb0NBQW9DLHVFQUF1RSxnQkFBZ0IsRUFBRSxzQ0FBc0MsMkVBQTJFLGdCQUFnQixFQUFFLHNDQUFzQyxFQUFFLHdDQUF3QyxrQkFBa0IsK0xBQStMLHdCQUF3Qiw2REFBNkQsWUFBWSxzR0FBc0csNkJBQTZCLFVBQVUsOE5BQThOLG1CQUFtQix1RUFBdUUsc0RBQXNELHNDQUFzQyxJQUFJLG9CQUFvQix5Q0FBeUMsZ0hBQWdILEVBQUUsc0JBQXNCLGtEQUFrRCxrREFBa0Qsd0RBQXdELGtEQUFrRCxHQUFHLFlBQVksT0FBTyx1RkFBdUYsdUJBQXVCLHdEQUF3RCxxQkFBcUIsdUJBQXVCLGVBQWUsOEJBQThCLDJKQUEySiwrREFBK0QsOENBQThDLGtCQUFrQix1REFBdUQsT0FBTyxxRkFBcUYsa0JBQWtCLG9DQUFvQyx1RUFBdUUsZ0JBQWdCLEVBQUUsK0JBQStCLGlGQUFpRixnQkFBZ0IsRUFBRSwrQkFBK0IsRUFBRSx3Q0FBd0Msa0JBQWtCLHVLQUF1Syx3QkFBd0IsOENBQThDLFlBQVksK0ZBQStGLDZCQUE2QixVQUFVLHFPQUFxTyxtQkFBbUIsbUVBQW1FLG9CQUFvQixtRUFBbUUsWUFBWSxPQUFPLHdHQUF3Ryx1QkFBdUIsZ0VBQWdFLHFCQUFxQix1QkFBdUIsWUFBWSxlQUFlLG9EQUFvRCxrQkFBa0IsbUVBQW1FLHdDQUF3QyxrQkFBa0IsK0JBQStCLE9BQU8sdUJBQXVCLFlBQVksRUFBRSw2QkFBNkIsbUJBQW1CLHFFQUFxRSxVQUFVLGlCQUFpQixtQkFBbUIsb0NBQW9DLG9CQUFvQixtSEFBbUgsWUFBWSxPQUFPLGdDQUFnQyx1QkFBdUIsOEJBQThCLHFCQUFxQix1QkFBdUIsaUJBQWlCLHNCQUFzQiwrR0FBK0csa0JBQWtCLG1FQUFtRSwrQkFBK0IscURBQXFELGdCQUFnQixFQUFFLDhDQUE4QyxFQUFFLHlFQUF5RSxnQkFBZ0IseUJBQXlCLDhGQUE4RixFQUFFLDZCQUE2QixVQUFVLHFGQUFxRixlQUFlLGdCQUFnQixtQkFBbUIsdUVBQXVFLHNDQUFzQyxJQUFJLG9CQUFvQixrQ0FBa0MsU0FBUyw4QkFBOEIsa0RBQWtELEdBQUcsWUFBWSxPQUFPLG9GQUFvRix1QkFBdUIsdURBQXVELHFCQUFxQix1QkFBdUIsZ0JBQWdCLG9DQUFvQyw0U0FBNFMsa0JBQWtCLG1FQUFtRSxvQ0FBb0MsdUVBQXVFLGdCQUFnQixFQUFFLHdDQUF3QyxpRUFBaUUsZ0JBQWdCLEVBQUUsNkNBQTZDLG9GQUFvRixnQkFBZ0IsRUFBRSx1Q0FBdUMsRUFBRSx3Q0FBd0Msa0JBQWtCLG9GQUFvRixPQUFPLCtDQUErQyxrQkFBa0IsMEtBQTBLLG9DQUFvQyxjQUFjLFlBQVksS0FBSyx3SEFBd0gsd0JBQXdCLGNBQWMsYUFBYSxFQUFFLDZCQUE2QixVQUFVLHFRQUFxUSxtQkFBbUIsa0VBQWtFLDJHQUEyRyxzQ0FBc0MsSUFBSSxvQkFBb0Isa0NBQWtDLCtDQUErQyxrREFBa0Qsa0RBQWtELG1EQUFtRCxrREFBa0QsdUVBQXVFLGtEQUFrRCxJQUFJLFlBQVksT0FBTyxvSEFBb0gsdUJBQXVCLHNFQUFzRSwyQkFBMkIsY0FBYyxzQkFBc0IsVUFBVSxPQUFPLDhuQkFBOG5CLEVBQUUsNENBQTRDLGVBQWUsNkNBQTZDLGdCQUFnQixlQUFlLHFJQUFxSSx3SkFBd0osY0FBYywySUFBMkksdUVBQXVFLGdDQUFnQyxHQUFHLG9KQUFvSixRQUFRLDJEQUEyRCx1RUFBdUUsd0JBQXdCLGlGQUFpRix5SEFBeUgsb0ZBQW9GLG1HQUFtRyxPQUFPLDZCQUE2Qiw2QkFBNkIsYUFBYSxlQUFlLCtHQUErRyxFQUFFLEdBQUcsZ0RBQWdELGFBQWEsMkJBQTJCLHFCQUFxQixhQUFhLG9EQUFvRCxZQUFZLHdEQUF3RCxtQkFBbUIsSUFBSSxPQUFPLDRCQUE0Qix5REFBeUQsbUJBQW1CLElBQUksT0FBTyxpQ0FBaUMsR0FBRyxnQkFBZ0IsRUFBRSxPQUFPLG1DQUFtQyxLQUFLLHNGQUFzRixtQkFBbUIsb0dBQW9HLEVBQUUsZUFBZSxjQUFjLHVEQUF1RCxtRkFBbUYscUNBQXFDLHFCQUFxQiwyQkFBMkIscUJBQXFCLGFBQWEsc0JBQXNCLEtBQUssNkRBQTZELEVBQUUsNEJBQTRCLEVBQUUsK0JBQStCLHFEQUFxRCxtQ0FBbUMsWUFBWSw0RkFBNEYsRUFBRSxJQUFJLDZFQUE2RSxFQUFFLHFCQUFxQixxQ0FBcUMsRUFBRSwrR0FBK0csU0FBUyw2Q0FBNkMseUJBQXlCLEtBQUssVUFBVSx3SEFBd0gsMEJBQTBCLHVCQUF1QixpQkFBaUIsZUFBZSxpQkFBaUIscUJBQXFCLHdDQUF3Qyx5QkFBeUIsNEJBQTRCLGNBQWMsS0FBSyxjQUFjLG1GQUFtRixnQkFBZ0IscUZBQXFGLEVBQUUsc0ZBQXNGLEVBQUUsdUZBQXVGLEdBQUcsa0JBQWtCLEVBQUUsR0FBRyw2QkFBNkIsdUJBQXVCLGNBQWMsRUFBRSxxRkFBcUYsWUFBWSxxR0FBcUcsNkVBQTZFLGlCQUFpQixNQUFNLDZEQUE2RCwyRUFBMkUsZUFBZSxVQUFVLFdBQVcsRUFBRSxtQ0FBbUMsWUFBWSxxQkFBcUIsSUFBSSxlQUFlLGdCQUFnQixNQUFNLHVFQUF1RSxTQUFTLGFBQWEsT0FBTyxXQUFXLEVBQUUsOEJBQThCLG1CQUFtQixjQUFjLFVBQVUsZUFBZSx5QkFBeUIsd0JBQXdCLGlDQUFpQyxxQkFBcUIsUUFBUSxzQkFBc0IsaUZBQWlGLHlDQUF5QywwQ0FBMEMsR0FBRywwQkFBMEIsMEJBQTBCLDBCQUEwQixFQUFFLGtCQUFrQiw2QkFBNkIsa0VBQWtFLGFBQWE7QUFDN3VyQix3Q0FBd0MsYUFBYSxJQUFJLGtEQUFrRCxjQUFjLHVCQUF1QixtQ0FBbUMsVUFBVSxFQUFFLEVBQUUscUJBQXFCLEtBQUsscUJBQXFCLGlEQUFpRCxpQkFBaUIsaUZBQWlGLHlCQUF5QixPQUFPLEtBQUssaUVBQWlFLGlCQUFpQiw0Q0FBNEMsZ2dCQUFnZ0IsU0FBUyxxSkFBcUosa0NBQWtDLG9CQUFvQixjQUFjLHFKQUFxSixxQkFBcUIsMkJBQTJCLG1CQUFtQixvQkFBb0IsUUFBUSxvREFBb0QsWUFBWSw0REFBNEQsUUFBUSxvQ0FBb0MsNEJBQTRCLGdEQUFnRCxRQUFRLHVCQUF1QixvQ0FBb0MsZUFBZSx3Q0FBd0MsZ0ZBQWdGLFNBQVMsSUFBSSxzQkFBc0IsbURBQW1ELHVDQUF1QyxXQUFXLDBCQUEwQixTQUFTLDBFQUEwRSxNQUFNLElBQUksaUJBQWlCLFNBQVMscURBQXFELFVBQVUsR0FBRyx5Y0FBeWMsMENBQTBDLCtEQUErRCxXQUFXLDJEQUEyRCxTQUFTLGFBQWEsMkRBQTJELGlDQUFpQyxvQ0FBb0MsbUJBQW1CLG9JQUFvSSxxQ0FBcUMsS0FBSyxnQ0FBZ0MsRUFBRSx1QkFBdUIsdUdBQXVHLG1IQUFtSCxrRUFBa0UscUJBQXFCLHlFQUF5RSxjQUFjLG1DQUFtQyxlQUFlLHlGQUF5RixnQkFBZ0IsZUFBZSwwQ0FBMEMsZUFBZSx3RUFBd0UsU0FBUyxpRUFBaUUsYUFBYSwwQkFBMEIsMEJBQTBCLGlCQUFpQixtQkFBbUIsaUJBQWlCLGVBQWUsYUFBYSxlQUFlLHNCQUFzQixPQUFPLDRCQUE0QixVQUFVLGVBQWUsbUJBQW1CLFFBQVEsNEJBQTRCLFVBQVUsZUFBZSxzR0FBc0cscUJBQXFCLGdCQUFnQix3QkFBd0IscUJBQXFCLGdVQUFnVSxnQkFBZ0Isa1BBQWtQLDREQUE0RCxHQUFHLGVBQWUsaUJBQWlCLGVBQWUsaUJBQWlCLFVBQVUsT0FBTyx1QkFBdUIsRUFBRSxtQkFBbUIsNkVBQTZFLHVHQUF1RyxFQUFFLG9FQUFvRSxPQUFPLHlFQUF5RSxPQUFPLHdFQUF3RSxZQUFZLE1BQU0sV0FBVywrSkFBK0osRUFBRSxHQUFHLGtFQUFrRSxxQkFBcUIsVUFBVSxvQkFBb0IsUUFBUSxPQUFPLHFFQUFxRSxFQUFFLGFBQWEsbUJBQW1CLHlGQUF5Rix1RkFBdUYsa0NBQWtDLHFDQUFxQyxtRUFBbUUsaUZBQWlGLGlGQUFpRixnQ0FBZ0MsdUVBQXVFLDZNQUE2TSxpREFBaUQsWUFBWSxtQkFBbUIsR0FBRywrQkFBK0IsT0FBTyxTQUFTLElBQUksZUFBZSwyQkFBMkIsNkRBQTZELHFEQUFxRCxzQkFBc0IsaUJBQWlCLHVMQUF1TCw2SEFBNkgsMERBQTBELHNCQUFzQixFQUFFLDZGQUE2RixNQUFNLDZCQUE2QixLQUFLLFVBQVUsc0JBQXNCLFlBQVksSUFBSSxnQkFBZ0IsSUFBSSxzQkFBc0IsNkJBQTZCLGVBQWUsNkNBQTZDLGNBQWMsK0dBQStHLGVBQWUsMENBQTBDLGVBQWUsd0RBQXdELHlCQUF5QixXQUFXLDhDQUE4QyxNQUFNLElBQUksNkJBQTZCLHdCQUF3QixFQUFFLFNBQVMsT0FBTyx3REFBd0QsU0FBUyxlQUFlLGVBQWUsa0dBQWtHLE9BQU8sSUFBSSw4QkFBOEIsd0ZBQXdGLEVBQUUsR0FBRyw0RkFBNEYsUUFBUSx5Q0FBeUMsZUFBZSxrQ0FBa0MsMkNBQTJDLEdBQUcscUNBQXFDLHVCQUF1Qiw0QkFBNEIsdUJBQXVCLFFBQVEsNEJBQTRCLE1BQU0sa0lBQWtJLFlBQVksTUFBTSxLQUFLLGtCQUFrQixZQUFZLElBQUksS0FBSyxlQUFlLHdCQUF3QiwrR0FBK0csRUFBRSxJQUFJLDJJQUEySSxFQUFFLElBQUksNENBQTRDLFVBQVUsZ0dBQWdHLFlBQVksZ0xBQWdMLGdEQUFnRCxzQkFBc0IsNEJBQTRCLG1CQUFtQix3QkFBd0IsdUJBQXVCLFFBQVEsNEJBQTRCLHdDQUF3QyxPQUFPLFFBQVEsSUFBSSxvQkFBb0Isb0JBQW9CLFVBQVUsZUFBZSxRQUFRLE9BQU8sMEJBQTBCLEVBQUUsaUJBQWlCLHNDQUFzQyxtR0FBbUcsRUFBRSxJQUFJLHFHQUFxRyxFQUFFLElBQUksOEdBQThHLFFBQVEsSUFBSSw0RkFBNEYsT0FBTyxjQUFjLE1BQU0sRUFBRSxHQUFHLHNHQUFzRyxRQUFRLElBQUksa0NBQWtDLFlBQVksYUFBYSxZQUFZLDBCQUEwQixRQUFRLFFBQVEsWUFBWSxJQUFJLHlCQUF5QixnREFBZ0QsZ0JBQWdCLFVBQVUsT0FBTyxrVkFBa1YsRUFBRSxnQkFBZ0IsbUJBQW1CLHFCQUFxQixvQ0FBb0MsRUFBRSxxQkFBcUIsR0FBRyxvQ0FBb0MsRUFBRSx5Q0FBeUMsRUFBRSxvQkFBb0IsR0FBRyxvQ0FBb0MsRUFBRSxLQUFLLFlBQVksSUFBSSxpREFBaUQsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLEtBQUssVUFBVSwrQkFBK0IsRUFBRSxLQUFLLFdBQVcsSUFBSSxlQUFlLGFBQWEsS0FBSyxJQUFJLHlCQUF5QixTQUFTLG1CQUFtQixTQUFTLFlBQVksV0FBVyxxQ0FBcUMsU0FBUyxxQkFBcUIsYUFBYSxtQkFBbUIsV0FBVyxjQUFjLFlBQVksSUFBSSwyQ0FBMkMsU0FBUyxtQkFBbUIsc0JBQXNCLGlCQUFpQixTQUFTLFlBQVksSUFBSSxnQkFBZ0IsU0FBUywrQkFBK0IsNERBQTRELGtCQUFrQixpQkFBaUIsOENBQThDLGlCQUFpQixJQUFJLDZEQUE2RCxPQUFPLHlCQUF5Qix1QkFBdUIsdUJBQXVCLFlBQVksV0FBVyw4QkFBOEIsS0FBSyx1QkFBdUIscUJBQXFCLFNBQVMsdUJBQXVCLHVCQUF1QixZQUFZLFdBQVcsb0RBQW9ELEtBQUssdUJBQXVCLDJDQUEyQyxZQUFZLFdBQVcsS0FBSyxXQUFXLHVDQUF1QyxTQUFTLG1CQUFtQixXQUFXLGlDQUFpQyx5QkFBeUIscUJBQXFCLHFGQUFxRixXQUFXLG1DQUFtQyx5QkFBeUIscUJBQXFCLHFGQUFxRixXQUFXLG9EQUFvRCxtQkFBbUIsZUFBZSxZQUFZLFdBQVcsZUFBZSxJQUFJLE1BQU0sY0FBYyxXQUFXLG9DQUFvQyxTQUFTLGlCQUFpQixpQ0FBaUMsWUFBWSxhQUFhLGlCQUFpQixTQUFTLG1CQUFtQix1QkFBdUIsa0lBQWtJLGtFQUFrRSxFQUFFLE1BQU0sOE9BQThPLEdBQUcsZ0NBQWdDLEVBQUUsNEJBQTRCLCtCQUErQixNQUFNLDhIQUE4SCxZQUFZLDZKQUE2SixZQUFZLFNBQVMsMERBQTBELHdDQUF3QyxPQUFPLCtEQUErRCxRQUFRLDZCQUE2QixZQUFZLFdBQVcsS0FBSywyQ0FBMkMsRUFBRSxxQkFBcUIsdUNBQXVDLFdBQVcsZUFBZSxTQUFTLHFGQUFxRixrRkFBa0Ysc0JBQXNCLDJDQUEyQyw2QkFBNkIsTUFBTSwyQ0FBMkMsMkVBQTJFLFlBQVksZUFBZSxHQUFHLGlCQUFpQiwrRkFBK0YscURBQXFELHlDQUF5QyxnRUFBZ0UsV0FBVyxpSEFBaUgsTUFBTSwrRkFBK0YsZ0JBQWdCLFlBQVksbUNBQW1DLEtBQUssbUNBQW1DLG9DQUFvQyxPQUFPLHFLQUFxSyxpQkFBaUIsNkNBQTZDLFFBQVEsa1BBQWtQLFlBQVksU0FBUyw0QkFBNEIscUVBQXFFLEtBQUssSUFBSSw2TEFBNkwsdUdBQXVHLEtBQUssd0VBQXdFLElBQUksaUJBQWlCLFFBQVEsUUFBUSxlQUFlLElBQUksMlpBQTJaLHlCQUF5QixrQ0FBa0MsZ0JBQWdCLGtDQUFrQyx5QkFBeUIsY0FBYyxpQkFBaUIsMEJBQTBCLHFCQUFxQix1Q0FBdUMseUJBQXlCLHVDQUF1Qyx1QkFBdUIscUNBQXFDLHFCQUFxQiw2Q0FBNkMseUJBQXlCLHVCQUF1QixvQkFBb0IsK0hBQStILGNBQWMsbUNBQW1DLFNBQVMsTUFBTSxpZ0ZBQWlnRixFQUFFLGlCQUFpQixrQkFBa0Isa0JBQWtCLHFDQUFxQyxFQUFFLHFCQUFxQixFQUFFLDhDQUE4QyxFQUFFLElBQUksb0NBQW9DLEVBQUUsZ0NBQWdDLElBQUksSUFBSSxXQUFXLGtCQUFrQixZQUFZLElBQUksK0NBQStDLEVBQUUsc0JBQXNCLEVBQUUsS0FBSyxFQUFFLDBDQUEwQyxFQUFFLG9DQUFvQyxFQUFFLElBQUksRUFBRSxpQkFBaUIsbUJBQW1CLFlBQVksV0FBVyxrQkFBa0IsU0FBUyxPQUFPLGFBQWEsd01BQXdNLFlBQVksR0FBRyxtQkFBbUIsZ0JBQWdCLDZCQUE2QixnQkFBZ0Isb0JBQW9CLFlBQVksaUJBQWlCLG9CQUFvQixxRUFBcUUsR0FBRyxvQ0FBb0MsV0FBVyxxQkFBcUIsU0FBUyxHQUFHLFlBQVksV0FBVyxLQUFLLDJDQUEyQyxpQkFBaUIscURBQXFELEdBQUcsbUNBQW1DLElBQUksTUFBTSxHQUFHLFlBQVksSUFBSSxNQUFNLEVBQUUsR0FBRyxZQUFZLFNBQVMsZUFBZSxPQUFPLG9LQUFvSyxNQUFNLHNDQUFzQyxXQUFXLFNBQVMsZUFBZSxtRUFBbUUsaUJBQWlCLDJCQUEyQiwwQkFBMEIsOENBQThDLEdBQUcscUNBQXFDLEVBQUUsMENBQTBDLEdBQUcsMERBQTBELEVBQUUsSUFBSSxZQUFZLGtCQUFrQixLQUFLLG9CQUFvQixrRUFBa0UsRUFBRSw2Q0FBNkMsR0FBRyx1Q0FBdUMsV0FBVyxNQUFNLEdBQUcsMkNBQTJDLFdBQVcsTUFBTSxFQUFFLElBQUksVUFBVSxlQUFlLDhDQUE4QyxtQkFBbUIsb0VBQW9FLFlBQVksd0JBQXdCLFNBQVMsa0VBQWtFLEtBQUssaUJBQWlCLGVBQWUsWUFBWSxJQUFJLG1DQUFtQyx5QkFBeUIsU0FBUyxzQkFBc0IsU0FBUyxNQUFNLFVBQVUsY0FBYyxJQUFJLGlEQUFpRCxLQUFLLGNBQWMsWUFBWSxJQUFJLDBDQUEwQyxvQ0FBb0MsU0FBUyx3QkFBd0IsU0FBUyxnQ0FBZ0MsWUFBWSxXQUFXLHVFQUF1RSxTQUFTLGlCQUFpQixVQUFVLFlBQVksSUFBSSxvQkFBb0IsU0FBUyxtQkFBbUIsbUJBQW1CLFlBQVksSUFBSSxtQ0FBbUMsU0FBUyx1SUFBdUksaUJBQWlCLHVHQUF1RyxTQUFTLFVBQVUsU0FBUyxJQUFJLG1DQUFtQyxZQUFZLFdBQVcsK0JBQStCLFNBQVMsZUFBZSxrRUFBa0UsWUFBWSxXQUFXLCtCQUErQixPQUFPLGVBQWUsZUFBZSx3RUFBd0UsWUFBWSxXQUFXLHVEQUF1RCxPQUFPLGVBQWUsZUFBZSx5RUFBeUUsWUFBWSxXQUFXLHVEQUF1RCxPQUFPLGVBQWUsaUJBQWlCLHdCQUF3QixPQUFPLGVBQWUscUJBQXFCLG9CQUFvQixpQkFBaUIsb0RBQW9ELFlBQVksaUJBQWlCLEtBQUssNkJBQTZCLGtDQUFrQyxPQUFPLGVBQWUsbUJBQW1CLHlEQUF5RCxPQUFPLGVBQWUscUNBQXFDLGlCQUFpQixzQkFBc0IsbURBQW1ELHdFQUF3RSxvRUFBb0UsR0FBRyxNQUFNLHFCQUFxQixvREFBb0QsR0FBRywyQkFBMkIsNkJBQTZCLHFDQUFxQyxHQUFHLDBCQUEwQixFQUFFLEdBQUcsd0ZBQXdGLFNBQVMsWUFBWSxXQUFXLEtBQUssV0FBVyx3RkFBd0YsR0FBRyx1Q0FBdUMsNkJBQTZCLFlBQVksV0FBVyxLQUFLLFdBQVcscUNBQXFDLDBCQUEwQixZQUFZLElBQUksS0FBSyx5R0FBeUcsS0FBSyxnRUFBZ0UsUUFBUSxZQUFZLGNBQWMsa0NBQWtDLCtCQUErQixZQUFZLElBQUksY0FBYyxPQUFPLGlDQUFpQyxpQkFBaUIsbUJBQW1CLFdBQVcsWUFBWSxXQUFXLGNBQWMsU0FBUyxZQUFZLElBQUkseUJBQXlCLDhCQUE4QixtQ0FBbUMsbUJBQW1CLG1CQUFtQixZQUFZLFdBQVcsS0FBSyxpQkFBaUIsWUFBWSxjQUFjLHNGQUFzRixZQUFZLFVBQVUsR0FBRyxrQkFBa0Isa0JBQWtCLHNCQUFzQixLQUFLLElBQUksaUJBQWlCLGlCQUFpQixzQ0FBc0MsWUFBWSxJQUFJLGVBQWUsU0FBUyxZQUFZLFdBQVcsS0FBSyxxQkFBcUIsMkRBQTJELE9BQU8sZ0JBQWdCLGVBQWUsNkJBQTZCLGlCQUFpQixTQUFTLFlBQVksV0FBVywrREFBK0QsU0FBUyxxQkFBcUIsU0FBUyxnSUFBZ0ksS0FBSyw0Q0FBNEMsc0VBQXNFLG9CQUFvQixXQUFXLGlDQUFpQyxrQkFBa0IsMkdBQTJHLFNBQVMsZUFBZTtBQUM3MDJCLHVCQUF1QixFQUFFLEVBQUUsaUJBQWlCLGlCQUFpQixFQUFFLG1CQUFtQixHQUFHLEtBQUssbUJBQW1CLGlCQUFpQixFQUFFLG1CQUFtQixHQUFHLEtBQUssRUFBRSxFQUFFLGlCQUFpQix1REFBdUQsR0FBRyxNQUFNLEVBQUUsRUFBRSxpQkFBaUIsY0FBYyxHQUFHLDRCQUE0QixFQUFFLEVBQUUsY0FBYyxzSEFBc0gsaUJBQWlCLG9CQUFvQixpREFBaUQ7QUFDaGhCLGlFQUFpRSxFQUFFLGVBQWUsR0FBRyxlQUFlLEVBQUUsRUFBRSxpQkFBaUIsb0JBQW9CLDJDQUEyQyxHQUFHLDRDQUE0QyxFQUFFLGVBQWUsR0FBRyxjQUFjLEVBQUUsRUFBRSxjQUFjLGlDQUFpQyxjQUFjLHVDQUF1QyxpQkFBaUIsb0JBQW9CLEdBQUcsbUJBQW1CLEVBQUUscURBQXFELG1CQUFtQixzQkFBc0IsRUFBRSxPQUFPLEdBQUcsbUJBQW1CLEVBQUUsR0FBRyxVQUFVLE9BQU8sNEZBQTRGLEVBQUUsaUJBQWlCLFdBQVcsc0RBQXNELEdBQUcsNkJBQTZCLFNBQVMsbUJBQW1CLG9CQUFvQixZQUFZLElBQUksaUNBQWlDLFNBQVMscUJBQXFCLHNDQUFzQyw0RUFBNEUsRUFBRSxJQUFJLEVBQUUsYUFBYSxFQUFFLEdBQUcsaURBQWlELEVBQUU7QUFDL2tDLE1BQU0sRUFBRSxLQUFLLHFDQUFxQyxFQUFFLHdDQUF3QyxFQUFFLEtBQUssWUFBWSxJQUFJLDBEQUEwRCxFQUFFLEtBQUssWUFBWSxtQ0FBbUMsRUFBRSxLQUFLLFdBQVcsSUFBSSxrQ0FBa0MsWUFBWSxJQUFJLHFDQUFxQyxZQUFZLElBQUkscUNBQXFDLFlBQVksSUFBSSx1QkFBdUIsY0FBYyxJQUFJLHFDQUFxQyxPQUFPLDZEQUE2RCxlQUFlLElBQUksdUJBQXVCLFNBQVMsNEVBQTRFLEVBQUUsSUFBSSxlQUFlLHVCQUF1QixVQUFVLE9BQU8sOEdBQThHLEVBQUUsS0FBSyxRQUFRLGtEQUFrRCxTQUFTLE9BQU8sb0NBQW9DLEtBQUssa0RBQWtELFNBQVMsT0FBTyxPQUFPLDRDQUE0QyxzQkFBc0IsS0FBSyxrREFBa0QsU0FBUyxPQUFPLE9BQU8sb0NBQW9DLGtCQUFrQixLQUFLLHNEQUFzRCxpQ0FBaUMsT0FBTyxPQUFPLHdCQUF3Qiw0Q0FBNEMsUUFBUSx3QkFBd0IsK0NBQStDLEtBQUssZ0RBQWdELFNBQVMseUJBQXlCLG1CQUFtQixLQUFLLEtBQUssa0RBQWtELFNBQVMsT0FBTyxjQUFjLEtBQUssa0RBQWtELFNBQVMsT0FBTyxjQUFjLEtBQUssa0RBQWtELFNBQVMsT0FBTyxnREFBZ0QsS0FBSyxrREFBa0QsU0FBUyxPQUFPLE9BQU8sdUNBQXVDLGtCQUFrQixLQUFLLHNEQUFzRCxpQ0FBaUMsT0FBTyxPQUFPLG9EQUFvRCw0Q0FBNEMsUUFBUSx3REFBd0QsK0NBQStDLEtBQUssa0RBQWtELFNBQVMsT0FBTyx1Q0FBdUMsS0FBSyxrREFBa0QsU0FBUyxPQUFPLDZDQUE2Qyx5QkFBeUIsNEVBQTRFLDRNQUE0TSxPQUFPLGtGQUFrRixPQUFPLDRCQUE0QixPQUFPLGFBQWEsSUFBSSwrQ0FBK0MsdUJBQXVCLDhEQUE4RCxVQUFVLGtCQUFrQixNQUFNLG9EQUFvRCxVQUFVLCtDQUErQyxHQUFHLE9BQU8seUJBQXlCLHVCQUF1QiwyREFBMkQsd0NBQXdDLE9BQU8sK0JBQStCLE9BQU8sSUFBSSxpQkFBaUIsb0xBQW9MLE9BQU8sZ0ZBQWdGLE9BQU8sSUFBSSxPQUFPLGFBQWEsSUFBSSw2QkFBNkIsdUJBQXVCLG1EQUFtRCxVQUFVLGdCQUFnQixNQUFNLG9EQUFvRCxVQUFVLDZCQUE2QixHQUFHLE9BQU8sc0JBQXNCLEtBQUssd0RBQXdELFlBQVksMEJBQTBCLEdBQUcsY0FBYyx3Q0FBd0MsUUFBUSx3Q0FBd0MsUUFBUSx3Q0FBd0MsRUFBRSwwQ0FBMEMsS0FBSyxpQ0FBaUMsSUFBSSxxQkFBcUIsR0FBRyxPQUFPLGtCQUFrQixLQUFLLGlDQUFpQyxpREFBaUQscUJBQXFCLEtBQUssMEJBQTBCLG9EQUFvRCxFQUFFLDRCQUE0QixFQUFFLEtBQUssU0FBUyxZQUFZLFdBQVcsc0JBQXNCLE9BQU8sbUJBQW1CLEtBQUssNEJBQTRCLGdCQUFnQixFQUFFLEtBQUssNEJBQTRCLFlBQVksRUFBRSxLQUFLLG9EQUFvRCxVQUFVLDhCQUE4QixHQUFHLE9BQU8sd0NBQXdDLEtBQUssc0RBQXNELEtBQUssa0RBQWtELHlCQUF5QixPQUFPLDBDQUEwQyxnQ0FBZ0MsS0FBSyw2REFBNkQsWUFBWSx5Q0FBeUMsR0FBRyxvSUFBb0ksRUFBRSxLQUFLLCtEQUErRCxLQUFLLDhEQUE4RCxZQUFZLCtDQUErQyxHQUFHLE9BQU8sK0RBQStELHVCQUF1QixRQUFRLHFFQUFxRSxRQUFRLHVKQUF1SixRQUFRLG1GQUFtRixRQUFRLDBGQUEwRixFQUFFLHdFQUF3RSxXQUFXLHNDQUFzQyxLQUFLLHNFQUFzRSxXQUFXLHdDQUF3QyxLQUFLLEtBQUssT0FBTyxTQUFTLElBQUksK0JBQStCLDJCQUEyQixVQUFVLHlCQUF5QixNQUFNLDZEQUE2RCxJQUFJLDRCQUE0QixHQUFHLDZIQUE2SCxFQUFFLElBQUksV0FBVyxPQUFPLDJEQUEyRCxLQUFLLGtEQUFrRCxTQUFTLE9BQU8scUNBQXFDLEtBQUssa0RBQWtELFNBQVMsT0FBTyxpQ0FBaUMsS0FBSyxvREFBb0QsVUFBVSw2QkFBNkIsR0FBRyxPQUFPLE9BQU8sb0NBQW9DLGlDQUFpQyxLQUFLLDZEQUE2RCxJQUFJLDhDQUE4QyxxQkFBcUIsK0hBQStILEVBQUUsSUFBSSxXQUFXLDBHQUEwRyxPQUFPLHdHQUF3RyxPQUFPLHFHQUFxRyxXQUFXLGtEQUFrRCxXQUFXLCtHQUErRyxHQUFHLGlCQUFpQixFQUFFLGdDQUFnQyxtRUFBbUUsS0FBSyw2REFBNkQsY0FBYyxrQkFBa0IsSUFBSSxtQkFBbUIsT0FBTywyREFBMkQsS0FBSyxrREFBa0QsWUFBWSxVQUFVLE9BQU8sMEJBQTBCLEtBQUssa0RBQWtELGlEQUFpRCxPQUFPLGVBQWUsS0FBSyxrREFBa0QsU0FBUyxPQUFPLGVBQWUsS0FBSyxzREFBc0QsU0FBUyxPQUFPLHlCQUF5QixLQUFLLGtEQUFrRCxTQUFTLE9BQU8sbUJBQW1CLEtBQUssNEJBQTRCLFlBQVksRUFBRSxLQUFLLHNEQUFzRCxpQ0FBaUMsT0FBTyxPQUFPLDRDQUE0Qyx1Q0FBdUMsUUFBUSwyQ0FBMkMsbUNBQW1DLFlBQVksb0NBQW9DLEtBQUssOEVBQThFLElBQUksa0JBQWtCLDREQUE0RCxlQUFlLFlBQVksbUJBQW1CLHVCQUF1QixVQUFVLGlFQUFpRSxPQUFPLHFHQUFxRyx1QkFBdUIsNENBQTRDLGVBQWUsa0JBQWtCLDRDQUE0QyxZQUFZLHNCQUFzQiw0Q0FBNEMsYUFBYSxRQUFRLCtDQUErQyxLQUFLLDhEQUE4RCxZQUFZLG1CQUFtQixzQ0FBc0MsZ05BQWdOLG9CQUFvQixVQUFVLGdDQUFnQyxPQUFPLHlGQUF5RixZQUFZLDRCQUE0QixpQkFBaUIsU0FBUyxZQUFZLElBQUksY0FBYyxTQUFTLGVBQWUsU0FBUyxZQUFZLFdBQVcsZ0JBQWdCLGNBQWMsb0JBQW9CLFNBQVMsUUFBUSxzREFBc0QsV0FBVyxPQUFPLDBCQUEwQixLQUFLLDRCQUE0QixzQkFBc0IsRUFBRSxLQUFLLDRCQUE0QixZQUFZLEVBQUUsS0FBSyw0QkFBNEIsWUFBWSxFQUFFLEtBQUssNEJBQTRCLFlBQVksRUFBRSxLQUFLLG9EQUFvRCxVQUFVLFFBQVEsYUFBYSxPQUFPLHVCQUF1QixLQUFLLGtEQUFrRCxTQUFTLE9BQU8scUJBQXFCLEtBQUssa0RBQWtELFNBQVMsT0FBTyw4QkFBOEIsS0FBSyxvRUFBb0UsVUFBVSxPQUFPLEdBQUcsT0FBTyxZQUFZLFlBQVksaUNBQWlDLG9DQUFvQyxPQUFPLGFBQWEsSUFBSSxxQ0FBcUMsMkJBQTJCLFVBQVUsdUNBQXVDLE1BQU0sdUVBQXVFLFlBQVksb0NBQW9DLEdBQUcsT0FBTywyQkFBMkIscUJBQXFCLG9GQUFvRixnQ0FBZ0MsUUFBUSx1RUFBdUUsU0FBUyxtQkFBbUIsK0NBQStDLE9BQU8sY0FBYyxLQUFLLHNEQUFzRCxXQUFXLE9BQU8scUVBQXFFLDJCQUEyQixnSEFBZ0gsbVFBQW1RLE9BQU8sa0ZBQWtGLE9BQU8sbUZBQW1GLE9BQU8sNEJBQTRCLE9BQU8sc0JBQXNCLElBQUksK0NBQStDLHVCQUF1Qiw4REFBOEQsVUFBVSxrQkFBa0IsTUFBTSx1RUFBdUUsWUFBWSwrQ0FBK0MsR0FBRyxPQUFPLDJCQUEyQiwyQkFBMkIseUZBQXlGLHdDQUF3QyxPQUFPLCtCQUErQixPQUFPLDZFQUE2RSxPQUFPLGdGQUFnRixPQUFPLDBCQUEwQixPQUFPLHNCQUFzQixJQUFJLGdEQUFnRCwyQkFBMkIsVUFBVSxnQkFBZ0IsTUFBTSx1RUFBdUUsWUFBWSw2QkFBNkIsR0FBRyxPQUFPLHdCQUF3QixLQUFLLG9EQUFvRCxVQUFVLE9BQU8sOENBQThDLE9BQU8sT0FBTyxzQkFBc0IsY0FBYyxPQUFPLEVBQUUsYUFBYSwyQ0FBMkMsS0FBSyx1RUFBdUUsU0FBUyxPQUFPLHlDQUF5QyxPQUFPLGNBQWMsS0FBSyxzREFBc0QsV0FBVyxPQUFPLG9FQUFvRSxLQUFLLG9EQUFvRCxZQUFZLFdBQVcsb0JBQW9CLE9BQU8sd0JBQXdCLEtBQUssc0RBQXNELGlDQUFpQyxPQUFPLE9BQU8sb0JBQW9CLHVDQUF1QyxRQUFRLDJDQUEyQywwQ0FBMEMsS0FBSyxzREFBc0QsaUNBQWlDLE9BQU8sT0FBTywyQ0FBMkMsdUNBQXVDLFFBQVEsMkNBQTJDLDBDQUEwQyxLQUFLLDRCQUE0QixZQUFZLEVBQUUsS0FBSyx3REFBd0QsV0FBVyxPQUFPLG9DQUFvQyxLQUFLLDRCQUE0QixZQUFZLEVBQUUsS0FBSyxrREFBa0QsSUFBSSxPQUFPLEdBQUcsOEJBQThCLEtBQUssb0RBQW9ELFlBQVksV0FBVyxvQkFBb0IsT0FBTyx3QkFBd0IsS0FBSyx5RUFBeUUsMkNBQTJDLE9BQU8sT0FBTyxvRUFBb0UsNENBQTRDLFFBQVEsZ0VBQWdFLCtDQUErQyxLQUFLLDBEQUEwRCxxQkFBcUIsT0FBTyxnQ0FBZ0MsK0NBQStDLGdEQUFnRCxtQkFBbUIsc0JBQXNCLE9BQU8sc0RBQXNELGNBQWMsbUJBQW1CLGtFQUFrRSxxQkFBcUIsMkVBQTJFLFVBQVUsK0JBQStCLGlDQUFpQyxrQ0FBa0MsVUFBVSxTQUFTLFFBQVEsb0RBQW9ELFVBQVUsT0FBTyxRQUFRLHFFQUFxRSxrQkFBa0IsS0FBSyxzREFBc0QsaUNBQWlDLE9BQU8sT0FBTyw0Q0FBNEMsdUNBQXVDLFFBQVEsMkNBQTJDLG1DQUFtQyxZQUFZLG9DQUFvQyxLQUFLLGtEQUFrRCxTQUFTLE9BQU8sd0JBQXdCLEtBQUssa0RBQWtELDRCQUE0QixPQUFPLDZCQUE2QixLQUFLLGtEQUFrRCxTQUFTLE9BQU8saUNBQWlDLEtBQUssa0RBQWtELFNBQVMsT0FBTyxxQkFBcUIsS0FBSyx5REFBeUQsWUFBWSxlQUFlLE9BQU8saUNBQWlDLEtBQUsseURBQXlELFlBQVksZUFBZSxPQUFPLGlDQUFpQyxLQUFLLGlDQUFpQyxJQUFJLE9BQU8sbUJBQW1CLE9BQU8sZ0JBQWdCLEtBQUssNEJBQTRCLFlBQVksRUFBRSxLQUFLLGtEQUFrRCxTQUFTLE9BQU8saUNBQWlDLEtBQUssMERBQTBELFNBQVMsT0FBTywwRkFBMEYsS0FBSyxrREFBa0QsU0FBUyxPQUFPLE9BQU8sNkVBQTZFLG9CQUFvQixLQUFLLGtEQUFrRCxTQUFTLE9BQU8sOEJBQThCLEtBQUssNEJBQTRCLFlBQVksRUFBRSxLQUFLLGtEQUFrRCxTQUFTLE9BQU8saUNBQWlDLEtBQUssa0RBQWtELFNBQVMsT0FBTyxpQ0FBaUMsS0FBSyxvREFBb0QsVUFBVSxlQUFlLGtDQUFrQyxZQUFZLFNBQVMsa0NBQWtDLE9BQU8sZ0JBQWdCLEtBQUssb0RBQW9ELFVBQVUsTUFBTSxpQkFBaUIsT0FBTyxvQ0FBb0MsS0FBSyxrREFBa0QsU0FBUyxPQUFPLG1CQUFtQixLQUFLLGlDQUFpQyxJQUFJLHdCQUF3QixHQUFHLE9BQU8sa0JBQWtCLEtBQUssaUNBQWlDLElBQUksT0FBTyxHQUFHLE9BQU8sZ0JBQWdCLEtBQUssa0RBQWtELFNBQVMsT0FBTyx1Q0FBdUMsS0FBSyxrREFBa0QsU0FBUyxPQUFPLGtDQUFrQyxLQUFLLHNEQUFzRCxtQkFBbUIsT0FBTyxrREFBa0QsS0FBSyw0QkFBNEIsWUFBWSxFQUFFLEtBQUssc0RBQXNELGlDQUFpQyxPQUFPLE9BQU8sd0JBQXdCLDRDQUE0QyxRQUFRLHdCQUF3QixtREFBbUQsS0FBSyxvREFBb0QsNEJBQTRCLE9BQU8sR0FBRywwQkFBMEIsT0FBTyxFQUFFLDBDQUEwQyxPQUFPLFVBQVUsS0FBSyxrREFBa0QsU0FBUyxPQUFPLHdCQUF3QixLQUFLLGtEQUFrRCxTQUFTLE9BQU8sNkJBQTZCLEtBQUssb0RBQW9ELFVBQVUsT0FBTyxHQUFHLE9BQU8sT0FBTyxZQUFZLDBCQUEwQixPQUFPLDZDQUE2QywrQkFBK0IsT0FBTyxnQkFBZ0IsT0FBTyxxRUFBcUUsK0JBQStCLE9BQU8sZ0JBQWdCLE9BQU8sZ0JBQWdCLE9BQU8sNkZBQTZGLCtCQUErQixPQUFPLGdCQUFnQixPQUFPLGdCQUFnQixPQUFPLGdCQUFnQixPQUFPLHFIQUFxSCxnRkFBZ0YsUUFBUSxlQUFlLFlBQVksS0FBSyxpQ0FBaUMsU0FBUyxPQUFPLFdBQVcsT0FBTyxnQkFBZ0IsS0FBSyxpQ0FBaUMsU0FBUyxPQUFPLEdBQUcsT0FBTyxvQkFBb0IsS0FBSywyREFBMkQsU0FBUyxPQUFPLGlCQUFpQixpQkFBaUIsa0VBQWtFLFlBQVksSUFBSSxnQkFBZ0IsMkJBQTJCLFlBQVksaUJBQWlCLFFBQVEsNEJBQTRCLFlBQVksRUFBRSxpVUFBaVUsc0JBQXNCLDZCQUE2Qix3Q0FBd0MsOEJBQThCLHdDQUF3QywrQkFBK0Isd0NBQXdDLDhCQUE4Qix5Q0FBeUMsZ0NBQWdDLDRDQUE0QyxnQ0FBZ0MsNENBQTRDLGlDQUFpQywwQ0FBMEMsaUNBQWlDLDBDQUEwQyxrQ0FBa0MscUdBQXFHLGlDQUFpQywwQ0FBMEMsOEJBQThCLG1EQUFtRCxpQ0FBaUMsNkNBQTZDLG1DQUFtQywrQ0FBK0MscUNBQXFDLGlEQUFpRCx1Q0FBdUMsbURBQW1ELDhCQUE4Qix3Q0FBd0MsK0JBQStCLHdDQUF3Qyw4QkFBOEIsd0NBQXdDLGdDQUFnQywwQ0FBMEMsK0JBQStCLHdDQUF3Qyx3Q0FBd0MsZ0RBQWdELDJDQUEyQyw0Q0FBNEMsNENBQTRDLGtEQUFrRCxzQ0FBc0MsMENBQTBDLCtCQUErQiwwQ0FBMEMsOEJBQThCLHdDQUF3Qyx3Q0FBd0MsNENBQTRDLG1DQUFtQywwRUFBMEUsMkNBQTJDLG9EQUFvRCxrREFBa0Qsa0RBQWtELDJDQUEyQyxvREFBb0QsNkJBQTZCLHdDQUF3Qyw4QkFBOEIsd0NBQXdDLHNDQUFzQyw4Q0FBOEMscUNBQXFDLDhDQUE4Qyx5Q0FBeUMsNENBQTRDLG9EQUFvRCxvREFBb0QsNkNBQTZDLGtEQUFrRCxtQ0FBbUMsMENBQTBDLDhCQUE4QiwwQ0FBMEMsOEJBQThCLDBDQUEwQyw2QkFBNkIsd0NBQXdDLGdDQUFnQywwQ0FBMEMsNkJBQTZCLHdDQUF3QywwQ0FBMEMsNENBQTRDLDZCQUE2Qix3Q0FBd0MscUNBQXFDLDBDQUEwQywrQkFBK0Isd0NBQXdDLDZCQUE2Qix3Q0FBd0MsaUNBQWlDLG1EQUFtRCwrQkFBK0Isd0NBQXdDLG1DQUFtQywwQ0FBMEMscUNBQXFDLDhDQUE4Qyx1Q0FBdUMsMENBQTBDLGtDQUFrQywwQ0FBMEMsOEJBQThCLHdDQUF3QywrQkFBK0Isd0NBQXdDLGtDQUFrQyx3Q0FBd0MsK0JBQStCLHdDQUF3QywrQkFBK0Isd0NBQXdDLG9DQUFvQywwQ0FBMEMsb0NBQW9DLDBDQUEwQywrQkFBK0IsMENBQTBDLDJEQUEyRCxnREFBZ0Qsb0NBQW9DLHdDQUF3QyxxQ0FBcUMsMENBQTBDLHNDQUFzQyw0Q0FBNEMsNkJBQTZCLHdDQUF3QywrQkFBK0Isd0NBQXdDLHFDQUFxQywwQ0FBMEMsb0NBQW9DLHdDQUF3QyxvQ0FBb0MsMENBQTBDLHFDQUFxQywwQ0FBMEMscUNBQXFDLDhDQUE4Qyx3Q0FBd0MsZ0RBQWdELGdDQUFnQyw0Q0FBNEMsa0NBQWtDLDBDQUEwQyxpQ0FBaUMsNENBQTRDLGdDQUFnQyw0Q0FBNEMsa0NBQWtDLDBDQUEwQyxzQ0FBc0MsNENBQTRDLDhCQUE4QiwwQ0FBMEMsOEJBQThCLHlDQUF5Qyw2QkFBNkIsd0NBQXdDLG1DQUFtQyw4Q0FBOEMsbUNBQW1DLDBDQUEwQyx5Q0FBeUMsOENBQThDLGtDQUFrQyx3Q0FBd0MsZ0NBQWdDLDRDQUE0Qyx5Q0FBeUMsb0RBQW9ELDhCQUE4QiwwQ0FBMEMsZ0NBQWdDLDBDQUEwQyxpQ0FBaUMsNENBQTRDLG9DQUFvQyx3Q0FBd0MsOEJBQThCLHdDQUF3QywrQkFBK0Isd0NBQXdDLG9DQUFvQywrQ0FBK0Msa0NBQWtDLHlDQUF5Qyw2Q0FBNkMsOENBQThDLG9EQUFvRCw4Q0FBOEMsa0NBQWtDLDBDQUEwQyw4QkFBOEIsd0NBQXdDLCtCQUErQix3Q0FBd0MsK0JBQStCLHdDQUF3Qyw4QkFBOEIsd0NBQXdDLG9EQUFvRCxvREFBb0QsaUNBQWlDLHdDQUF3Qyw4QkFBOEIsd0NBQXdDLDZCQUE2Qix3Q0FBd0MsOEJBQThCLHdDQUF3QyxrQ0FBa0MsNENBQTRDLGtDQUFrQywwQ0FBMEMsa0NBQWtDLHdDQUF3QywyQ0FBMkMsNENBQTRDLGtDQUFrQyw0Q0FBNEMsOEJBQThCLHdDQUF3QyxnQ0FBZ0Msd0NBQXdDLDRDQUE0QywwQ0FBMEMsa0NBQWtDLDBDQUEwQyxrQ0FBa0MsdUJBQXVCLDJDQUEyQyxnQkFBZ0IsK0JBQStCLDBDQUEwQyxxREFBcUQsd0RBQXdELDhCQUE4QiwwQ0FBMEMsZ0NBQWdDLDRDQUE0Qyw2QkFBNkIsd0NBQXdDLDhCQUE4Qix3Q0FBd0MsK0JBQStCLDBDQUEwQyxnQ0FBZ0MsK0NBQStDLGlDQUFpQyxrREFBa0QsK0JBQStCLGdEQUFnRCxpQ0FBaUMsNENBQTRDLG9DQUFvQywwQ0FBMEMsaUNBQWlDLDBDQUEwQywrQ0FBK0MsNENBQTRDLGtDQUFrQywwQ0FBMEMsa0NBQWtDLDRDQUE0QyxtQ0FBbUMsd0NBQXdDLDhCQUE4QixlQUFlLG1EQUFtRCwyQkFBMkIsZUFBZSxtREFBbUQsMEJBQTBCLGVBQWUsbURBQW1ELDJCQUEyQixlQUFlLG1EQUFtRCwyQkFBMkIsZUFBZSxtREFBbUQsVUFBVSxlQUFlLDBDQUEwQyxPQUFPLE1BQU0sMkZBQTJGLFNBQVMsMENBQTBDLDBDQUEwQyxxQ0FBcUMscUJBQXFCLG9CQUFvQixnQkFBZ0IsdUJBQXVCLGlCQUFpQixtRkFBbUYsRUFBRSxJQUFJLGlDQUFpQyxvQkFBb0IsS0FBSyxxQ0FBcUMscUJBQXFCLG9CQUFvQixpQkFBaUIscUJBQXFCLFNBQVMsWUFBWSxJQUFJLGtCQUFrQixTQUFTLEtBQUssbUJBQW1CLG9CQUFvQixpQkFBaUIsc0JBQXNCLGlCQUFpQixRQUFRLDBCQUEwQixTQUFTLGVBQWUsMkJBQTJCLGVBQWUsOEJBQThCLGVBQWUsaUdBQWlHLGdDQUFnQyxlQUFlLDBGQUEwRixVQUFVLGVBQWUsdUJBQXVCLFNBQVMsNkRBQTZELGVBQWUsMEVBQTBFLEtBQUsscUJBQXFCLGdCQUFnQixXQUFXLG9IQUFvSCxrQkFBa0IsS0FBSyxrQkFBa0IsdUJBQXVCLFVBQVUsaUJBQWlCLHdCQUF3Qiw4Q0FBOEMsRUFBRSxJQUFJLEVBQUU7QUFDaHBrQyxTQUFTLEdBQUc7QUFDWixnQkFBZ0IsR0FBRyxrR0FBa0csU0FBUyxLQUFLLFFBQVEsb0RBQW9ELEVBQUUsNEJBQTRCLGtCQUFrQjtBQUMvTyxxQ0FBcUMsc0JBQXNCLG9HQUFvRyxFQUFFLElBQUksRUFBRTtBQUN2SyxTQUFTLEdBQUc7QUFDWixnQkFBZ0IsR0FBRyxrR0FBa0csWUFBWSxTQUFTLHdDQUF3QyxzQ0FBc0MsZUFBZSxrQkFBa0Isc0JBQXNCLEtBQUssdUNBQXVDLGFBQWEsd0JBQXdCLDBCQUEwQixNQUFNLEtBQUssc0JBQXNCLEtBQUssdUNBQXVDLHNCQUFzQiwwQkFBMEIsUUFBUSxpQkFBaUIsc0JBQXNCLGlCQUFpQixpQkFBaUIsZUFBZSxvQkFBb0IsU0FBUyw0Q0FBNEMsU0FBUyxlQUFlLGdEQUFnRCxrQkFBa0IsR0FBRywrQ0FBK0MsU0FBUyxtQkFBbUIsMENBQTBDLEdBQUcsaUJBQWlCLEVBQUUsc0JBQXNCLEdBQUcscUJBQXFCLDJCQUEyQiw4RkFBOEYsaUJBQWlCLDZDQUE2QyxHQUFHLG1FQUFtRSxLQUFLLEtBQUssRUFBRSx1REFBdUQsR0FBRyxvQ0FBb0MsTUFBTSxJQUFJLGVBQWUsaUdBQWlHLEVBQUUsTUFBTSxFQUFFLEVBQUUsbUJBQW1CLDRCQUE0QixlQUFlLDBCQUEwQixpQ0FBaUMsZUFBZSxvRUFBb0UsU0FBUyxjQUFjLFlBQVksVUFBVSxrQkFBa0Isc0RBQXNELDJKQUEySixlQUFlLHNCQUFzQixlQUFlLCtCQUErQixlQUFlLHVCQUF1QixlQUFlLG9CQUFvQixpQkFBaUIsaUJBQWlCLFdBQVcsSUFBSSxVQUFVLGtCQUFrQixTQUFTLGtCQUFrQixjQUFjLHVDQUF1QyxlQUFlLDhEQUE4RCxjQUFjLGVBQWUsOERBQThELHVCQUF1QixnQkFBZ0IsOEJBQThCLFNBQVMsRUFBRSxHQUFHLEVBQUUsRUFBRSxxQkFBcUIsY0FBYyxxREFBcUQsZUFBZSxvQkFBb0IsZUFBZSxxQ0FBcUMsbUJBQW1CLHFDQUFxQyxRQUFRLFlBQVksSUFBSSxZQUFZLFNBQVMsZUFBZSxrQ0FBa0MsK0JBQStCLFlBQVksV0FBVyxLQUFLLFdBQVcsV0FBVyxTQUFTLGVBQWUsa0NBQWtDLCtCQUErQixZQUFZLFdBQVcsS0FBSyxXQUFXLFdBQVcsU0FBUyxpQkFBaUIsMkJBQTJCLEVBQUUsYUFBYSxFQUFFLGtCQUFrQixTQUFTLFlBQVksSUFBSSxjQUFjLFNBQVMsT0FBTyxjQUFjLHdDQUF3QyxjQUFjLHFCQUFxQixpQkFBaUIsZUFBZSxvQkFBb0Isc0JBQXNCLG9EQUFvRCxpQkFBaUIsY0FBYywyRkFBMkYsZ0JBQWdCLFVBQVUsY0FBYyxxQkFBcUIsRUFBRSxlQUFlLG9CQUFvQixjQUFjLGVBQWUsaUZBQWlGLE9BQU8sSUFBSSxpQ0FBaUMsY0FBYyxtQkFBbUIsY0FBYyxlQUFlLHdCQUF3Qix5Q0FBeUMsc0RBQXNELG1FQUFtRSxnRkFBZ0YsNkZBQTZGLGtGQUFrRixPQUFPLElBQUksRUFBRSxtQkFBbUIsY0FBYyxlQUFlLHdCQUF3Qix5Q0FBeUMsc0RBQXNELG1FQUFtRSxpRkFBaUYsT0FBTyxJQUFJLEVBQUUscUJBQXFCLGNBQWMsZUFBZSx3QkFBd0IsaUJBQWlCLHdCQUF3Qix3QkFBd0IscUVBQXFFLEVBQUUsR0FBRyxpQkFBaUIsd0JBQXdCLHNEQUFzRCx3QkFBd0IscUVBQXFFLEVBQUUsR0FBRyxpQkFBaUIsd0JBQXdCLG1FQUFtRSxtRUFBbUUsd0JBQXdCLHFFQUFxRSxFQUFFLEdBQUcsaUZBQWlGLE9BQU8sSUFBSSxFQUFFLG9CQUFvQixNQUFNLHNFQUFzRSxpQkFBaUIsZUFBZSx3QkFBd0IsMEJBQTBCLDBCQUEwQiwwQkFBMEIsbUZBQW1GLE9BQU8sSUFBSSxpQkFBaUIscUZBQXFGLFNBQVMsd0RBQXdELE9BQU8sSUFBSSxlQUFlLDJCQUEyQixxQkFBcUIscUJBQXFCLGlHQUFpRyxTQUFTLGdCQUFnQixRQUFRLEdBQUcsY0FBYyxrREFBa0Qsc0hBQXNILFNBQVMsaUJBQWlCLFFBQVEsR0FBRyw0Q0FBNEMsK0VBQStFLEdBQUcsZ0NBQWdDLGNBQWMsbUVBQW1FLGNBQWMsMENBQTBDLG9CQUFvQixrQkFBa0Isb0JBQW9CLCtFQUErRSxNQUFNLG1CQUFtQiwyRUFBMkUsZUFBZSxjQUFjLG1CQUFtQixjQUFjLHFFQUFxRSxTQUFTLHlCQUF5QixFQUFFLEdBQUcsVUFBVSw0RkFBNEYsaUZBQWlGLGVBQWUscUZBQXFGLCtFQUErRSxlQUFlLDhFQUE4RSw2RUFBNkUscUJBQXFCLGtEQUFrRCxPQUFPLEdBQUcsbUJBQW1CLDREQUE0RCxtQkFBbUIsZ0VBQWdFLEVBQUUsNEJBQTRCLGFBQWEsZUFBZSwrQkFBK0IscUJBQXFCLDBCQUEwQixlQUFlLGNBQWMsb0JBQW9CLGlCQUFpQixFQUFFLHNCQUFzQixpQkFBaUIsNkVBQTZFLGVBQWUsbUJBQW1CLGVBQWUsd0JBQXdCLHFDQUFxQyw4QkFBOEIsU0FBUyxZQUFZLFVBQVUscUJBQXFCLFdBQVcsaUJBQWlCLHFCQUFxQixxQkFBcUIsd0JBQXdCLFdBQVcsaUJBQWlCLG9CQUFvQixxQkFBcUIsd0JBQXdCLGVBQWUsOEZBQThGLEVBQUUsR0FBRyxzRUFBc0UsRUFBRSxHQUFHLG1CQUFtQixXQUFXLHdDQUF3QyxZQUFZLE9BQU8sb0JBQW9CLHdCQUF3QixxQkFBcUIsd0JBQXdCLGVBQWUsOEpBQThKLFdBQVcsaURBQWlELFlBQVksT0FBTyx3REFBd0QsNkJBQTZCLHFCQUFxQix3QkFBd0IsZUFBZSxtSkFBbUosV0FBVyxpR0FBaUcsRUFBRSxJQUFJLCtDQUErQyxZQUFZLE9BQU8sb0RBQW9ELDRCQUE0QixxQkFBcUIsd0JBQXdCLGVBQWUsbUpBQW1KLFdBQVcsb0dBQW9HLEVBQUUsSUFBSSwrQ0FBK0MsWUFBWSxPQUFPLG9EQUFvRCwrQkFBK0IscUJBQXFCLHdCQUF3QixlQUFlLHdDQUF3QyxXQUFXLGNBQWMsaUhBQWlILDZCQUE2QixFQUFFLFlBQVksT0FBTyxrQkFBa0Isd0JBQXdCLHFCQUFxQixnQ0FBZ0MsUUFBUSxvQ0FBb0Msd0NBQXdDLHdCQUF3QixjQUFjLGtCQUFrQiw0QkFBNEIseUJBQXlCLHFDQUFxQyxLQUFLLFlBQVksOEJBQThCLFlBQVksd0JBQXdCLGVBQWUseUVBQXlFLFFBQVEsR0FBRyw2TEFBNkwsV0FBVyx1Q0FBdUMsbUlBQW1JLG1CQUFtQiw2REFBNkQscUJBQXFCLHlCQUF5QixFQUFFLElBQUksNkJBQTZCLEtBQUsscUJBQXFCLCtCQUErQixZQUFZLE9BQU8saUZBQWlGLCtCQUErQixxQkFBcUIsd0JBQXdCLGVBQWUsT0FBTyxzRUFBc0UsRUFBRSxlQUFlLHNCQUFzQiw2QkFBNkIscUJBQXFCLHdCQUF3QixlQUFlLE9BQU8scUVBQXFFLEVBQUUsZUFBZSxzQkFBc0IsNEJBQTRCLHFCQUFxQix3QkFBd0IsZUFBZSxPQUFPLG9FQUFvRSxFQUFFLGVBQWUsc0JBQXNCLHdCQUF3QixxQkFBcUIsd0JBQXdCLGVBQWUsT0FBTyxxRUFBcUUsRUFBRSxlQUFlLHNCQUFzQix5QkFBeUIscUJBQXFCLHdCQUF3QixlQUFlLE9BQU8sb0VBQW9FLEVBQUUsZUFBZSxzQkFBc0IsMkJBQTJCLHFCQUFxQix3QkFBd0IsZUFBZSxPQUFPLHFFQUFxRSxFQUFFLGVBQWUsc0JBQXNCLDRCQUE0QixxQkFBcUIsd0JBQXdCLGVBQWUseUhBQXlILFdBQVcsY0FBYyx5REFBeUQsdUZBQXVGLEVBQUUsSUFBSSxJQUFJLDJEQUEyRCw2R0FBNkcseUJBQXlCLEdBQUcsRUFBRSxtQ0FBbUMsb0tBQW9LLDRFQUE0RSxFQUFFLFlBQVksT0FBTyxpQ0FBaUMsMEJBQTBCLHFCQUFxQixRQUFRLG1YQUFtWCxrQkFBa0IsRUFBRSx1RUFBdUUsZUFBZSxhQUFhLGVBQWUsdUJBQXVCLHNCQUFzQixvQ0FBb0MscUNBQXFDLGdDQUFnQyxpQ0FBaUMsbUNBQW1DLHFDQUFxQyxTQUFTLGdDQUFnQyxRQUFRLG9DQUFvQyxlQUFlLDZDQUE2QyxlQUFlLGlEQUFpRCxlQUFlLE1BQU0scUJBQXFCLDZEQUE2RCxNQUFNLFNBQVMsR0FBRyxPQUFPLFNBQVMsU0FBUyxlQUFlLDBDQUEwQyxnQ0FBZ0MsdUNBQXVDLE1BQU0sU0FBUyxHQUFHLGNBQWMsZUFBZSxRQUFRLHFFQUFxRSxTQUFTLDJCQUEyQiw0Q0FBNEMsOE5BQThOLE9BQU8seUNBQXlDLFNBQVMscUtBQXFLLFVBQVUsNENBQTRDLG9CQUFvQix5REFBeUQsV0FBVyx1QkFBdUIsZ0JBQWdCLHVCQUF1QixpQkFBaUIseUNBQXlDLGlCQUFpQix1SUFBdUksZUFBZSwwQkFBMEIsZUFBZSxjQUFjLGlCQUFpQixFQUFFLGFBQWEsZUFBZSxrS0FBa0ssVUFBVSwyQkFBMkIsd01BQXdNLGVBQWUsaUJBQWlCLHFXQUFxVyxpRUFBaUUsd0NBQXdDLFlBQVksU0FBUyxvRUFBb0UsT0FBTyw4SUFBOEksdUNBQXVDLGdCQUFnQixFQUFFLGlUQUFpVCxhQUFhLE9BQU8sMEJBQTBCLGtCQUFrQiw2R0FBNkcsTUFBTSwrQ0FBK0MsNEJBQTRCLFdBQVcsOERBQThELHVCQUF1QixjQUFjLDhEQUE4RCw2SEFBNkgsb0JBQW9CLGtDQUFrQyxvQkFBb0Isd0dBQXdHLEVBQUUsSUFBSSwyREFBMkQsR0FBRyxVQUFVLEVBQUUsMkJBQTJCLDBCQUEwQixpQkFBaUIsNEJBQTRCLGNBQWMsdURBQXVELGVBQWUseURBQXlELFlBQVksb0RBQW9ELFdBQVcsdUhBQXVILHNEQUFzRCxXQUFXLHdDQUF3Qyx1REFBdUQsYUFBYSxzREFBc0QsV0FBVyx3QkFBd0Isb0RBQW9ELFdBQVcseUhBQXlILHlEQUF5RCxhQUFhLG9CQUFvQixrQkFBa0IsK0JBQStCLGNBQWMscUJBQXFCLFlBQVksbUJBQW1CLGFBQWEsY0FBYyxnQkFBZ0IsdUJBQXVCLGlCQUFpQixtRUFBbUUsdUJBQXVCLHdFQUF3RSx3QkFBd0IseUJBQXlCLDBCQUEwQixnS0FBZ0ssMkJBQTJCLDRCQUE0QixjQUFjLDhEQUE4RCxlQUFlLHNCQUFzQixjQUFjLDBHQUEwRyw0QkFBNEIsWUFBWSwwREFBMEQseUJBQXlCLDRDQUE0QyxXQUFXLFVBQVUsVUFBVSwwQkFBMEIsVUFBVSxpQ0FBaUMsRUFBRSxHQUFHLFlBQVksV0FBVyxLQUFLLGtCQUFrQixvQkFBb0IsYUFBYSxpREFBaUQsR0FBRyw2QkFBNkIsVUFBVSxrQkFBa0IsT0FBTyxlQUFlLEVBQUUsR0FBRyxxREFBcUQsR0FBRyw2QkFBNkIsVUFBVSxzQkFBc0IsVUFBVSxlQUFlLEVBQUUsR0FBRyxxREFBcUQsR0FBRyw2QkFBNkIsVUFBVSxzQkFBc0IsVUFBVSxlQUFlLEVBQUUsSUFBSSx5REFBeUQsR0FBRyw2QkFBNkIsV0FBVyxtQkFBbUIsUUFBUSxnQkFBZ0IsUUFBUSxJQUFJLFdBQVcsY0FBYyxxQkFBcUIsc0RBQXNELDBEQUEwRCxHQUFHLDZCQUE2QixVQUFVLGtCQUFrQixHQUFHLCtCQUErQixHQUFHLGdCQUFnQixFQUFFLEtBQUssNkJBQTZCLGlCQUFpQixLQUFLLDhCQUE4QixnREFBZ0QsR0FBRyw2QkFBNkIsVUFBVSxtQkFBbUIsUUFBUSxnQkFBZ0IsUUFBUSxNQUFNLFVBQVUsU0FBUyxvQkFBb0IsMENBQTBDLGVBQWUsaUJBQWlCLGdCQUFnQixvQkFBb0IsV0FBVyxPQUFPLDBCQUEwQiw0QkFBNEIsd0ZBQXdGLHlCQUF5QixnQkFBZ0IsaUNBQWlDLFNBQVMsbUNBQW1DLHVJQUF1SSx1Q0FBdUMscUJBQXFCLGdEQUFnRCxpQkFBaUIsMERBQTBELDRJQUE0SSxTQUFTLEtBQUssbURBQW1ELDRYQUE0WCxVQUFVLEVBQUUsZ0NBQWdDLHNJQUFzSSxrQkFBa0IsZ0RBQWdELHFDQUFxQyxpQkFBaUIsVUFBVSxHQUFHLEtBQUssU0FBUyxxQ0FBcUMsc0NBQXNDLG9EQUFvRCxrQkFBa0IsNENBQTRDLFVBQVUsSUFBSSxxQ0FBcUMsSUFBSSxrQkFBa0IsbUZBQW1GLFdBQVcsOERBQThELFNBQVMsZ0NBQWdDLHFDQUFxQyw2QkFBNkIsaUJBQWlCLHdDQUF3QyxrRUFBa0UsK0JBQStCLFdBQVcsNEhBQTRILGNBQWMsa0VBQWtFLFVBQVUsc0ZBQXNGLHdCQUF3QixTQUFTLGNBQWMsaUJBQWlCLGdEQUFnRCxjQUFjLE9BQU8sbUJBQW1CLCtFQUErRSxVQUFVLGlDQUFpQyxTQUFTLGdDQUFnQyxVQUFVLDZCQUE2QixFQUFFLE1BQU0sdUJBQXVCLGlCQUFpQixZQUFZLFdBQVcsS0FBSyx5QkFBeUIscUVBQXFFLFNBQVMsNENBQTRDLFFBQVEsR0FBRyxjQUFjLE1BQU0sRUFBRSwyQkFBMkIsK0VBQStFLEdBQUcsWUFBWSxVQUFVLEdBQUcsa0hBQWtILHVDQUF1QyxxSkFBcUosZ0NBQWdDLGlDQUFpQyxXQUFXLHNIQUFzSCxzQkFBc0IsU0FBUyxpQkFBaUIsMEJBQTBCLDZDQUE2Qyx3Q0FBd0MsV0FBVyx5REFBeUQsRUFBRSxrQ0FBa0MsV0FBVyx5REFBeUQsWUFBWSxTQUFTLHVCQUF1QixnQ0FBZ0MsNENBQTRDLDBDQUEwQyxXQUFXLFVBQVUsVUFBVSxjQUFjLFVBQVUsMEJBQTBCLFlBQVksV0FBVyx3QkFBd0IsbUNBQW1DLFlBQVksd0NBQXdDLG1CQUFtQiwrRUFBK0UsUUFBUSx3SkFBd0osSUFBSSxZQUFZLFdBQVcsdUZBQXVGLFlBQVksT0FBTyx5Q0FBeUMscUhBQXFILGlCQUFpQixnRUFBZ0Usb0JBQW9CLGdEQUFnRCxVQUFVLHlCQUF5QixVQUFVLHVEQUF1RCxXQUFXLHFDQUFxQyxpRUFBaUUsV0FBVyxvQ0FBb0MseUJBQXlCLFFBQVEsdURBQXVELDhEQUE4RCxlQUFlLFFBQVEsU0FBUywrQkFBK0IsYUFBYSxlQUFlLGdCQUFnQixtQkFBbUIsaUdBQWlHLHdCQUF3QixxREFBcUQsU0FBUyxZQUFZLHlCQUF5QixLQUFLLDRFQUE0RSw0Q0FBNEMsV0FBVyxlQUFlLFNBQVMsMENBQTBDLEtBQUssTUFBTSxTQUFTLGVBQWUsU0FBUyx1Q0FBdUMsS0FBSyxNQUFNLFNBQVMsd0JBQXdCLGVBQWUsVUFBVSw4REFBOEQsd1JBQXdSLHdCQUF3QixZQUFZLG1IQUFtSCxxQ0FBcUMsK0hBQStILHlCQUF5QixxREFBcUQsUUFBUSxFQUFFLHVEQUF1RCxZQUFZLHNDQUFzQyw2S0FBNkssRUFBRSxXQUFXLHlGQUF5RixVQUFVLEdBQUcsVUFBVSxPQUFPLDREQUE0RCxZQUFZLE9BQU8sMkZBQTJGLDBCQUEwQixxQkFBcUIsZUFBZSxxTEFBcUwscUlBQXFJLG1CQUFtQixtREFBbUQsY0FBYyxzQ0FBc0Msc0RBQXNELG1DQUFtQyxpQkFBaUIsNkNBQTZDLElBQUkscUJBQXFCLFNBQVMsc0NBQXNDLFFBQVEsNkNBQTZDLE9BQU8sS0FBSyxRQUFRLE1BQU0sZ0JBQWdCLGVBQWUsbUJBQW1CLGdCQUFnQixnQkFBZ0IsdUhBQXVILEtBQUssa0JBQWtCLHdDQUF3QyxXQUFXLG1IQUFtSCx3Q0FBd0MsT0FBTyxPQUFPLEtBQUssR0FBRyxZQUFZLFdBQVcsd0JBQXdCLFVBQVUsaUNBQWlDLFFBQVEsaUNBQWlDLFlBQVksb0JBQW9CLDZEQUE2RCxPQUFPLEdBQUcsMkJBQTJCLEtBQUssc0JBQXNCLGdFQUFnRSxFQUFFLEdBQUcseUJBQXlCLFdBQVcsb0JBQW9CLDZEQUE2RCxPQUFPLEdBQUcsMEJBQTBCLEtBQUssc0JBQXNCLGdFQUFnRSxFQUFFLEdBQUcsd0JBQXdCLGVBQWUsc0NBQXNDLHFCQUFxQixlQUFlLDREQUE0RCxxQkFBcUIsNkZBQTZGLG9FQUFvRSxvREFBb0QsK0RBQStELFlBQVksY0FBYyx1REFBdUQsSUFBSSwrQkFBK0IsZ0JBQWdCLFlBQVksV0FBVyxLQUFLLFlBQVksc0JBQXNCLDhFQUE4RSwyQkFBMkIsNEJBQTRCLHdCQUF3Qix1QkFBdUIsbUNBQW1DLGdLQUFnSyxXQUFXLGNBQWMsOEJBQThCLDBDQUEwQyxxQ0FBcUMsWUFBWSxXQUFXLEtBQUsseURBQXlELDJCQUEyQixvQkFBb0IsU0FBUyxpQ0FBaUMsaUJBQWlCLDBFQUEwRSxjQUFjLGlCQUFpQixpQkFBaUIsNEJBQTRCLEtBQUssY0FBYyxnQkFBZ0IsSUFBSSx3QkFBd0IsU0FBUyx3REFBd0Qsd0VBQXdFLE9BQU8sZ0NBQWdDLGVBQWUsU0FBUyw4QkFBOEIsU0FBUyxpQkFBaUIsd0JBQXdCLGdDQUFnQyxjQUFjLGNBQWMsV0FBVyxFQUFFLG9CQUFvQixrQkFBa0IsUUFBUSxTQUFTLGlDQUFpQyxxRUFBcUUsS0FBSyxtQkFBbUIsNEdBQTRHLE9BQU8seUJBQXlCLGVBQWUsTUFBTSxnRUFBZ0UsS0FBSyxXQUFXLFlBQVksb0NBQW9DLDZFQUE2RSxJQUFJLE1BQU0sK0JBQStCLFNBQVMsV0FBVyxpRUFBaUUsVUFBVSxPQUFPLCtEQUErRCxFQUFFLGlCQUFpQixrQ0FBa0MscUNBQXFDLFlBQVksVUFBVSxxQkFBcUIsZUFBZSxnS0FBZ0ssU0FBUyxjQUFjLDhDQUE4Qyw0QkFBNEIsRUFBRSxZQUFZLE9BQU8seUNBQXlDLHVCQUF1QixxQkFBcUIsd0JBQXdCLGVBQWUsMEVBQTBFLFNBQVMsNENBQTRDLFlBQVksT0FBTyxrQkFBa0Isd0JBQXdCLHFCQUFxQix3QkFBd0IsU0FBUyxlQUFlLHNCQUFzQixxQkFBcUIsd0JBQXdCLGVBQWUsd1RBQXdULFNBQVMsY0FBYywyRkFBMkYsNEJBQTRCLEVBQUUsWUFBWSxPQUFPLCtFQUErRSwwQkFBMEIscUJBQXFCLFFBQVEsK0VBQStFLGVBQWUsYUFBYSxrQkFBa0IsRUFBRSxzRUFBc0UsZUFBZSx1QkFBdUIsdUJBQXVCLE9BQU8scUNBQXFDLGFBQWEsb0NBQW9DLGVBQWUsaUJBQWlCLGVBQWUsaUJBQWlCLGNBQWMsY0FBYyxlQUFlLGlCQUFpQixVQUFVLE9BQU8sbVJBQW1SLEVBQUUsY0FBYyxjQUFjLGNBQWMsY0FBYyxlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixVQUFVLE9BQU8sczhDQUFzOEMsRUFBRSxxQkFBcUIsa0JBQWtCLG1CQUFtQixnQkFBZ0IsV0FBVyx1QkFBdUIsUUFBUSxzQ0FBc0MsZUFBZSwyQkFBMkIsWUFBWSxXQUFXLG9CQUFvQixPQUFPLGVBQWUsMkJBQTJCLFdBQVcsaUNBQWlDLE9BQU8sYUFBYSxnREFBZ0QsWUFBWSxHQUFHLG9CQUFvQixjQUFjLHlCQUF5QixhQUFhLGNBQWMseUJBQXlCLHVCQUF1Qix5QkFBeUIsdUJBQXVCLHVCQUF1QixxQkFBcUIsY0FBYyxVQUFVLG9CQUFvQixvREFBb0QsVUFBVSx1QkFBdUIsYUFBYSwyQ0FBMkMsWUFBWSwwQ0FBMEMsd0JBQXdCLGNBQWMsRUFBRSxzREFBc0Qsc0JBQXNCLGNBQWMsRUFBRSxvREFBb0Qsd0JBQXdCLGNBQWMsRUFBRSxzREFBc0Qsc0JBQXNCLGNBQWMsRUFBRSxvREFBb0Qsc0JBQXNCLGNBQWMsRUFBRSxvREFBb0Qsb0JBQW9CLGNBQWMsRUFBRSxtREFBbUQscUJBQXFCLGNBQWMsUUFBUSxzQkFBc0IsMkJBQTJCLHNCQUFzQixjQUFjLEVBQUUsNEJBQTRCLGFBQWEsZ0JBQWdCLFdBQVcsMEdBQTBHLEtBQUssTUFBTSxtREFBbUQsc0NBQXNDLHdDQUF3QyxzQkFBc0Isd0lBQXdJLHdDQUF3Qyx5Q0FBeUMsSUFBSSxxQkFBcUIsc0JBQXNCLDhCQUE4QixzQkFBc0IsY0FBYyxxQkFBcUIsc0ZBQXNGLGlCQUFpQixtQkFBbUIsMkJBQTJCLHNCQUFzQixZQUFZLFdBQVcsOEJBQThCLFdBQVcsc0NBQXNDLDJCQUEyQixZQUFZLFdBQVcseUVBQXlFLHFCQUFxQixpQkFBaUIsb1ZBQW9WLDRTQUE0Uyx1QkFBdUIsU0FBUyw0R0FBNEcsd0JBQXdCLG9GQUFvRixzQkFBc0IsU0FBUywySUFBMkksd0JBQXdCLGdFQUFnRSxzQkFBc0IsU0FBUyxxTkFBcU4sc0JBQXNCLDhEQUE4RCxvQkFBb0IsNERBQTRELGlCQUFpQixxQkFBcUIsc0ZBQXNGLGdCQUFnQixlQUFlLHdDQUF3QyxxR0FBcUcsRUFBRSx3R0FBd0csNEJBQTRCLDZEQUE2RCx3REFBd0QsRUFBRSxlQUFlLG1CQUFtQiwwQkFBMEIsU0FBUyw4QkFBOEIsU0FBUyxvQ0FBb0MseUJBQXlCLG1CQUFtQiwrQkFBK0IsaURBQWlELGdDQUFnQyxnQkFBZ0Isb0JBQW9CLHlGQUF5RixHQUFHLDBCQUEwQixrQkFBa0IsT0FBTyxtRUFBbUUsaUJBQWlCLGNBQWMseUNBQXlDLHNEQUFzRCxlQUFlLEVBQUUsaUJBQWlCLGlDQUFpQyxpQkFBaUIsaUNBQWlDLGlCQUFpQixjQUFjLDhEQUE4RCx1QkFBdUIsRUFBRSxpQkFBaUIsY0FBYywwRkFBMEYsMEJBQTBCLEVBQUUsaUJBQWlCLGNBQWMseUJBQXlCLG9CQUFvQixFQUFFLGlCQUFpQixjQUFjLHlCQUF5QixnQkFBZ0IsRUFBRSxpQkFBaUIsY0FBYywwQ0FBMEMsMEJBQTBCLEVBQUUsaUJBQWlCLGNBQWMscURBQXFELGdCQUFnQixFQUFFLHNCQUFzQixjQUFjLGFBQWEsS0FBSyxnQ0FBZ0MsVUFBVSw2RUFBNkUsRUFBRSxzQkFBc0IsY0FBYyw0QkFBNEIsb0JBQW9CLHlDQUF5QyxpQkFBaUIsRUFBRSxpQkFBaUIsNkdBQTZHLHlCQUF5QixNQUFNLHdCQUF3QixHQUFHLGNBQWMsd0JBQXdCLGlDQUFpQyxFQUFFLGlCQUFpQixjQUFjLE1BQU0sOERBQThELEVBQUUsaUJBQWlCLGNBQWMsa0NBQWtDLCtCQUErQixFQUFFLGlCQUFpQixjQUFjLG9CQUFvQiwyQkFBMkIsRUFBRSxpQkFBaUIsY0FBYyxtQ0FBbUMsb0JBQW9CLEVBQUUsUUFBUSw2U0FBNlMsZUFBZSx1QkFBdUIsd0JBQXdCLHNCQUFzQixFQUFFLEVBQUUsMEVBQTBFLEVBQUUsZ0dBQWdHLGNBQWMsaUJBQWlCLGNBQWMsd0NBQXdDLHNCQUFzQixFQUFFLGlCQUFpQixrREFBa0QsaUJBQWlCLG9EQUFvRCxpQkFBaUIsb0RBQW9ELGlCQUFpQixvREFBb0QsaUJBQWlCLGNBQWMsaUNBQWlDLDJDQUEyQyxFQUFFLGlCQUFpQixjQUFjLGlDQUFpQywyQ0FBMkMsRUFBRSxpQkFBaUIsZUFBZSxpQkFBaUIsbUhBQW1ILGlCQUFpQixjQUFjLCtEQUErRCwyQkFBMkIsRUFBRSw4REFBOEQseUtBQXlLLGVBQWUsNENBQTRDLHdDQUF3Qyw4QkFBOEIsRUFBRSxHQUFHLGVBQWUseUNBQXlDLEVBQUUsZ0NBQWdDLE1BQU0sMkNBQTJDLElBQUksTUFBTSx1QkFBdUIsMkNBQTJDLElBQUksTUFBTSw0QkFBNEIsZUFBZSxPQUFPLDJNQUEyTSxrSUFBa0ksaUNBQWlDLEVBQUUsR0FBRyxzQkFBc0IsMEtBQTBLLE1BQU0sd0JBQXdCLGtFQUFrRSxFQUFFLGlDQUFpQyxVQUFVLHVKQUF1SixlQUFlLHFCQUFxQixzRUFBc0UscUJBQXFCLHlEQUF5RCxTQUFTLDBCQUEwQixrQ0FBa0MsU0FBUyxjQUFjLEtBQUssZUFBZSxrREFBa0QsaUNBQWlDLHNFQUFzRSxtSEFBbUgsTUFBTSxPQUFPLCtCQUErQix5REFBeUQsNENBQTRDLGVBQWUsWUFBWSxXQUFXLHdFQUF3RSxxQ0FBcUMsd0NBQXdDLG1CQUFtQixJQUFJLDBCQUEwQixFQUFFLDhCQUE4QixFQUFFLG9CQUFvQixlQUFlLE1BQU0sc0dBQXNHLGVBQWUsbUJBQW1CLHNEQUFzRCxnQkFBZ0IsMERBQTBELEtBQUssTUFBTSxhQUFhLDRCQUE0QixTQUFTLHVEQUF1RCxLQUFLLE1BQU0sVUFBVSxZQUFZLFNBQVMsK0JBQStCLFNBQVMsWUFBWSxXQUFXLDhGQUE4RixLQUFLLG1CQUFtQixRQUFRLElBQUksaUVBQWlFLFNBQVMsYUFBYSxJQUFJLGdDQUFnQyxTQUFTLGFBQWEsc0NBQXNDLEdBQUcsR0FBRyxFQUFFLG1DQUFtQyxVQUFVLHFCQUFxQixRQUFRLElBQUksaUVBQWlFLFNBQVMsYUFBYSxJQUFJLGdDQUFnQyxTQUFTLGFBQWEsU0FBUyxxRkFBcUYseUJBQXlCLEtBQUssc0VBQXNFLFVBQVUsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksNkRBQTZELEdBQUcsR0FBRyxFQUFFLHFDQUFxQyxVQUFVLFlBQVksV0FBVywrQkFBK0IsbUJBQW1CLDZGQUE2RixpQkFBaUIsd0JBQXdCLG1DQUFtQyxvREFBb0QsdUJBQXVCLG9CQUFvQixZQUFZLElBQUksS0FBSyxXQUFXLG9DQUFvQyxTQUFTLEtBQUssU0FBUyw2QkFBNkIsV0FBVyx5Q0FBeUMsS0FBSyxZQUFZLGNBQWMsVUFBVSxpQkFBaUIsdUJBQXVCLG1DQUFtQyxvREFBb0QsdUJBQXVCLG9CQUFvQixZQUFZLElBQUksS0FBSyxXQUFXLG9DQUFvQyxTQUFTLEtBQUssU0FBUyw2QkFBNkIsbUJBQW1CLHNFQUFzRSxVQUFVLHVCQUF1QixxQkFBcUIseUJBQXlCLHNCQUFzQix5Q0FBeUMsd0JBQXdCLGVBQWUsV0FBVyxnRUFBZ0Usd0NBQXdDLGdCQUFnQixzV0FBc1csMkJBQTJCLEdBQUcsaUtBQWlLLDRCQUE0QiwyTkFBMk4sMkJBQTJCLGtEQUFrRCxzR0FBc0csMEJBQTBCLGtEQUFrRCwrS0FBK0ssOEdBQThHLFlBQVksMEJBQTBCLEtBQUssMEJBQTBCLHdIQUF3SCxTQUFTLFVBQVUsR0FBRyx1Q0FBdUMsaUJBQWlCLElBQUksMkdBQTJHLDZEQUE2RCw0R0FBNEcsUUFBUSxLQUFLLEtBQUssS0FBSyxLQUFLLHdCQUF3Qiw2RUFBNkUsd0JBQXdCLGdEQUFnRCxRQUFRLFlBQVksT0FBTyx3QkFBd0IsNEJBQTRCLGlIQUFpSCw2QkFBNkIsWUFBWSxJQUFJLEtBQUsscUZBQXFGLGVBQWUsY0FBYyxnQkFBZ0IsMEJBQTBCLFVBQVUsV0FBVyxtQ0FBbUMsMEJBQTBCLGdCQUFnQixpQ0FBaUMsb0VBQW9FLHdGQUF3RixZQUFZLHlCQUF5QixLQUFLLDBGQUEwRixtQ0FBbUMsU0FBUyxnQkFBZ0IsV0FBVyxrQ0FBa0MsU0FBUyxnQkFBZ0IsV0FBVyxrQ0FBa0MscURBQXFELGVBQWUsZ0JBQWdCLFdBQVcsZUFBZSx3QkFBd0Isc0JBQXNCLEVBQUUsdUZBQXVGLHNFQUFzRSwrQkFBK0Isa0NBQWtDLHNCQUFzQixZQUFZLG9IQUFvSCxHQUFHLFlBQVksT0FBTyxnRUFBZ0UsRUFBRSxHQUFHLHVDQUF1QyxnQkFBZ0Isb0JBQW9CLGlDQUFpQyxnQkFBZ0IsZ0NBQWdDLG1DQUFtQyxFQUFFLFlBQVksR0FBRyx3RkFBd0YsbURBQW1ELG9SQUFvUixpQ0FBaUMsb0JBQW9CLG9EQUFvRCxVQUFVLHlCQUF5QixVQUFVLHlCQUF5QixPQUFPLGtEQUFrRCx5QkFBeUIsa0ZBQWtGLGlHQUFpRywrQ0FBK0MsZ0JBQWdCLHVCQUF1QixpQkFBaUIsd0JBQXdCLDhDQUE4QyxvQkFBb0IsdUJBQXVCLHVRQUF1USw0QkFBNEIsU0FBUyx3REFBd0QsU0FBUywwQkFBMEIsU0FBUywwREFBMEQsb0JBQW9CLFNBQVMsdURBQXVELG1CQUFtQixTQUFTLGNBQWMsOERBQThELG9CQUFvQixRQUFRLGFBQWEsd0JBQXdCLDZEQUE2RCxXQUFXLDRDQUE0QyxFQUFFLEVBQUUsaUJBQWlCLG9EQUFvRCxFQUFFLEdBQUcsV0FBVyxTQUFTLGdCQUFnQixRQUFRLGVBQWUsbUJBQW1CLGtEQUFrRCxrQ0FBa0Msc0VBQXNFLEVBQUUsR0FBRyxZQUFZLE1BQU0sU0FBUyx5QkFBeUIsNkJBQTZCLFVBQVUsS0FBSyxHQUFHLHVCQUF1QixFQUFFLEdBQUcsTUFBTSxnQkFBZ0IsNkJBQTZCLDZJQUE2SSxnQ0FBZ0MsZ0JBQWdCLDRCQUE0QixnRkFBZ0YsR0FBRyw4QkFBOEIsZUFBZSwrQkFBK0IsNkJBQTZCLFVBQVUsY0FBYyxRQUFRLGFBQWEsWUFBWSxxQkFBcUIsK0JBQStCLDRCQUE0QixFQUFFLGlCQUFpQixjQUFjLFFBQVEsTUFBTSx5RUFBeUUsRUFBRSxzQkFBc0IsWUFBWSxpRkFBaUYsRUFBRSxjQUFjLHlCQUF5QixpQkFBaUIsU0FBUyxZQUFZLFdBQVcsS0FBSyxpREFBaUQsT0FBTyxxRUFBcUUsOEJBQThCLDJCQUEyQixnQkFBZ0Isc0JBQXNCLDZEQUE2RCxTQUFTLFlBQVkseUJBQXlCLEtBQUssc0VBQXNFLE9BQU8sR0FBRyxFQUFFLEdBQUcsRUFBRSxTQUFTLFVBQVUsc0VBQXNFLFlBQVksV0FBVyxLQUFLLFNBQVMsT0FBTyxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUUsWUFBWSxjQUFjLFlBQVksMkJBQTJCLEtBQUssc0dBQXNHLE9BQU8sR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFLFVBQVUsWUFBWSxXQUFXLEtBQUssV0FBVyx3QkFBd0IsYUFBYSxzQkFBc0IsK0JBQStCLFNBQVMsWUFBWSxxQkFBcUIsS0FBSyxtQ0FBbUMsY0FBYyxxRUFBcUUsZ0JBQWdCLDJCQUEyQixnQkFBZ0IscUVBQXFFLDBDQUEwQyx3QkFBd0IsUUFBUSxTQUFTLGtEQUFrRCxjQUFjLGdGQUFnRiwyR0FBMkcsK0pBQStKLFlBQVksV0FBVyxLQUFLLHlCQUF5QixpQkFBaUIsbUJBQW1CLDJCQUEyQix5Q0FBeUMsUUFBUSxJQUFJLEtBQUssR0FBRyxpQkFBaUIsb0NBQW9DLGNBQWMsMEJBQTBCLFFBQVEsR0FBRywwQkFBMEIsc0JBQXNCLFlBQVksd0JBQXdCLEtBQUssc0JBQXNCLDJDQUEyQyxTQUFTLGNBQWMsb0NBQW9DLHFFQUFxRSwrQ0FBK0MsZ0RBQWdELDhCQUE4QixFQUFFLEdBQUcsYUFBYSw2RUFBNkUsRUFBRSx1QkFBdUIsb0JBQW9CLFlBQVksc0JBQXNCLGtCQUFrQixjQUFjLFNBQVMscUNBQXFDLHdCQUF3QixLQUFLLHNCQUFzQiwyREFBMkQsU0FBUyxFQUFFLFlBQVksT0FBTyxlQUFlLGlEQUFpRCwwQkFBMEIsNENBQTRDLFlBQVksd0JBQXdCLEtBQUssK0NBQStDLCtCQUErQixrQkFBa0Isd0NBQXdDLFNBQVMsc0JBQXNCLFFBQVEsaURBQWlELFdBQVcsK0dBQStHLDZCQUE2QixTQUFTLFlBQVkseUJBQXlCLEtBQUssMEZBQTBGLHNDQUFzQyxZQUFZLFNBQVMsa0VBQWtFLFdBQVcsU0FBUyxZQUFZLDBCQUEwQixLQUFLLDZFQUE2RSx3Q0FBd0MsV0FBVyxlQUFlLHVDQUF1QyxxQkFBcUIsZ0JBQWdCLFNBQVMsWUFBWSwyQkFBMkIsS0FBSywrRUFBK0Usd0NBQXdDLFdBQVcsZUFBZSx3Q0FBd0MscUJBQXFCLDBCQUEwQiwwQkFBMEIsT0FBTyxRQUFRLE1BQU0sZ0JBQWdCLDRDQUE0QyxnQkFBZ0IsV0FBVyxnQkFBZ0IseUJBQXlCLGtCQUFrQixpQkFBaUIsT0FBTyxPQUFPLFdBQVcsNkJBQTZCLE9BQU8sT0FBTyx3QkFBd0IsMkJBQTJCLDZCQUE2QixjQUFjLDREQUE0RCxFQUFFLG9FQUFvRSw4RkFBOEYsRUFBRSxHQUFHLE9BQU8sRUFBRSx3QkFBd0Isb0JBQW9CLEtBQUssT0FBTyxpQkFBaUIsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsaUJBQWlCLHVCQUF1Qiw4QkFBOEIsZ0JBQWdCLHlCQUF5QixXQUFXLHlDQUF5QyxhQUFhLHFCQUFxQixnQkFBZ0IseUJBQXlCLFdBQVcseUNBQXlDLGFBQWEsY0FBYywwQkFBMEIsRUFBRSxlQUFlLHNOQUFzTixnREFBZ0QsU0FBUyxjQUFjLE9BQU8sd0JBQXdCLDRCQUE0QixFQUFFLElBQUksbUJBQW1CLGVBQWUsaUVBQWlFLDRGQUE0RixxQkFBcUIsNENBQTRDLEdBQUcsaUJBQWlCLFVBQVUsZ0NBQWdDLEdBQUcseUVBQXlFLFNBQVMsNEZBQTRGLFNBQVMscUJBQXFCLGlDQUFpQyxJQUFJLGdEQUFnRCxFQUFFLGdCQUFnQixHQUFHLCtCQUErQixHQUFHLDZCQUE2QixHQUFHLGlCQUFpQixHQUFHLGtCQUFrQixrQkFBa0IsR0FBRyxpQkFBaUIsNkJBQTZCLDJCQUEyQixtRkFBbUYsWUFBWSxhQUFhLG1DQUFtQyx1QkFBdUIsK0JBQStCLDJDQUEyQywrREFBK0QsV0FBVyx1RUFBdUUsOERBQThELE9BQU8seUVBQXlFLCtCQUErQixNQUFNLFNBQVMscUJBQXFCLHNHQUFzRyxHQUFHLDRDQUE0QyxhQUFhLGtCQUFrQixpQkFBaUIsaUJBQWlCLGNBQWMsVUFBVSxpQkFBaUIsWUFBWSxnSUFBZ0ksbUJBQW1CLDRJQUE0SSxFQUFFLEdBQUcsZ0ZBQWdGLDJEQUEyRCxpQkFBaUIsbUNBQW1DLFVBQVUsaUNBQWlDLDZCQUE2QixnRUFBZ0Usa0JBQWtCLG9DQUFvQyxVQUFVLG1DQUFtQyw4QkFBOEIsSUFBSSxZQUFZLFdBQVcsaUVBQWlFLGlCQUFpQixNQUFNLGdCQUFnQixZQUFZLEdBQUcsaUJBQWlCLGdCQUFnQixJQUFJLFlBQVksV0FBVyxrRUFBa0Usa0JBQWtCLE1BQU0sZ0JBQWdCLFlBQVksR0FBRyxpQkFBaUIsZ0JBQWdCLElBQUksT0FBTyxXQUFXLG1CQUFtQiw2QkFBNkIsb0ZBQW9GLFVBQVUsd0JBQXdCLFVBQVUsZUFBZSxHQUFHLE9BQU8sRUFBRSxPQUFPLFNBQVMsZ0JBQWdCLDBGQUEwRixHQUFHLE9BQU8sRUFBRSxLQUFLLGFBQWEsVUFBVSxlQUFlLHVGQUF1RixPQUFPLGlCQUFpQix5QkFBeUIsOEJBQThCLCtZQUErWSxTQUFTLG9MQUFvTCxrQkFBa0IsME5BQTBOLGdCQUFnQixJQUFJLGlDQUFpQyxtUkFBbVIsb0JBQW9CLEdBQUcsS0FBSywyQkFBMkIsY0FBYywyREFBMkQscURBQXFELGtFQUFrRSx5QkFBeUIsNkNBQTZDLG9FQUFvRSxpRUFBaUUsS0FBSyxXQUFXLEVBQUUsU0FBUyx3QkFBd0IsWUFBWSw4QkFBOEIsd0JBQXdCLEVBQUUscUJBQXFCLGNBQWMsb0RBQW9ELGtCQUFrQixvREFBb0QsR0FBRyxTQUFTLCtIQUErSCw0QkFBNEIsa0ZBQWtGLE1BQU0sa0JBQWtCLElBQUksVUFBVSxvQkFBb0IseURBQXlELFNBQVMsd0JBQXdCLHNDQUFzQyxZQUFZLFdBQVcscUNBQXFDLG1DQUFtQyxNQUFNLFlBQVksV0FBVyxLQUFLLGtCQUFrQixhQUFhLHNDQUFzQyxrQ0FBa0MsTUFBTSxNQUFNLG9FQUFvRSw0QkFBNEIsd0JBQXdCLHlFQUF5RSxHQUFHLFlBQVksd0JBQXdCLGFBQWEsa0JBQWtCLFFBQVEsTUFBTSx5QkFBeUIscURBQXFELGlFQUFpRSxRQUFRLGlCQUFpQixpQkFBaUIsV0FBVyx5RkFBeUYsZUFBZSxxQ0FBcUMsZUFBZSxpQ0FBaUMseUJBQXlCLFFBQVEsNENBQTRDLG9FQUFvRSxrSUFBa0ksMEJBQTBCLEdBQUcseUNBQXlDLEtBQUssZ0JBQWdCLEVBQUUscUJBQXFCLFlBQVksWUFBWSxJQUFJLFVBQVUsMkNBQTJDLDJCQUEyQixXQUFXLGtCQUFrQixvQkFBb0IsWUFBWSxXQUFXLEtBQUssa0JBQWtCLHNDQUFzQyxlQUFlLFNBQVMsVUFBVSxnTUFBZ00sV0FBVyxrRkFBa0YsT0FBTyxZQUFZLFdBQVcsS0FBSyxXQUFXLHNCQUFzQixhQUFhLGVBQWUsaUdBQWlHLEVBQUUsR0FBRyxtQkFBbUIseUVBQXlFLGlCQUFpQixzR0FBc0csaUJBQWlCLG9CQUFvQixLQUFLLElBQUkscUNBQXFDLFNBQVMsZUFBZSxTQUFTLHlCQUF5QixZQUFZLFdBQVcsS0FBSyxXQUFXLDhCQUE4QixLQUFLLHVHQUF1RyxXQUFXLFNBQVMsaUJBQWlCLGtCQUFrQixTQUFTLGdDQUFnQyxvREFBb0QsZ0NBQWdDLFdBQVcsYUFBYSxTQUFTLG1EQUFtRCx1Q0FBdUMsZ0NBQWdDLEVBQUUsZ0NBQWdDLFdBQVcsZ0NBQWdDLGNBQWMsMEJBQTBCLEVBQUUsZUFBZSx1QkFBdUIsZUFBZSx3QkFBd0IsZUFBZSxxQkFBcUIsNkJBQTZCLDBCQUEwQixZQUFZLFNBQVMsMEJBQTBCLGVBQWUsdUNBQXVDLEtBQUssT0FBTyxVQUFVLDhDQUE4QyxHQUFHLDRCQUE0QixFQUFFLEdBQUcsU0FBUyxpQ0FBaUMsTUFBTSxVQUFVLFNBQVMsZ0JBQWdCLG1EQUFtRCxFQUFFLGdDQUFnQyxFQUFFLEdBQUcsY0FBYyxlQUFlLG9FQUFvRSxFQUFFLGdIQUFnSCxVQUFVLDhEQUE4RCxFQUFFLEdBQUcsSUFBSSxLQUFLLDJDQUEyQyxHQUFHLFVBQVUsVUFBVSxvRUFBb0UsUUFBUSxHQUFHLE1BQU0sK0JBQStCLFdBQVcsS0FBSyx1QkFBdUIsV0FBVyxtRUFBbUUsRUFBRSxhQUFhLE1BQU0sVUFBVSxhQUFhLHlDQUF5QyxRQUFRLEdBQUcsWUFBWSxjQUFjLEtBQUssc0JBQXNCLDJCQUEyQix1Q0FBdUMsR0FBRyw2REFBNkQsMEJBQTBCLDBCQUEwQiwwQkFBMEIsYUFBYSxHQUFHLHlCQUF5QixZQUFZLDZCQUE2QixnQ0FBZ0MsbUJBQW1CLFFBQVEsTUFBTSxTQUFTLG1CQUFtQiwrQkFBK0IsU0FBUywrQkFBK0Isc0hBQXNILGtDQUFrQyxHQUFHLDhHQUE4RyxrQ0FBa0MsR0FBRyw0SUFBNEksTUFBTSxzQkFBc0IsTUFBTSxvQkFBb0IsbUJBQW1CLGlCQUFpQixZQUFZLFdBQVcsS0FBSyx5QkFBeUIsWUFBWSxnR0FBZ0csU0FBUywwSkFBMEosc0JBQXNCLG9DQUFvQyxZQUFZLFdBQVcsS0FBSyxrQkFBa0IsNERBQTRELFNBQVMsb0NBQW9DLEVBQUUsK0ZBQStGLDZCQUE2QixNQUFNLHFCQUFxQixnRUFBZ0UsRUFBRSxvSEFBb0gsVUFBVSw2QkFBNkIsVUFBVSxjQUFjLElBQUksS0FBSywrQ0FBK0MsVUFBVSxFQUFFLEdBQUcsaUVBQWlFLHdCQUF3QixJQUFJLE1BQU0sdUJBQXVCLFdBQVcsS0FBSyx1QkFBdUIsV0FBVyxtRUFBbUUsRUFBRSxhQUFhLE1BQU0sVUFBVSxhQUFhLHlDQUF5Qyx3QkFBd0IsR0FBRyxZQUFZLGNBQWMsS0FBSyxzQkFBc0IsMkJBQTJCLHFEQUFxRCxFQUFFLGFBQWEsTUFBTSxnQkFBZ0Isc0JBQXNCLDJCQUEyQix3QkFBd0IsTUFBTSxpQkFBaUIsK0RBQStELE1BQU0sa0RBQWtELGlEQUFpRCwySEFBMkgsRUFBRSxHQUFHLHdDQUF3QyxTQUFTLGdCQUFnQixrQ0FBa0Msb0NBQW9DLFVBQVUsMENBQTBDLGVBQWUsNEJBQTRCLDJCQUEyQiwyTUFBMk0sZUFBZSxXQUFXLG9JQUFvSSxLQUFLLDJHQUEyRyxxREFBcUQsU0FBUywrRUFBK0UsY0FBYywwR0FBMEcsRUFBRSx1Q0FBdUMsaUJBQWlCLEdBQUcsdUVBQXVFLEVBQUUsMkhBQTJILEdBQUcsd0NBQXdDLCtCQUErQiw4SUFBOEkscUJBQXFCLGlDQUFpQyxPQUFPLElBQUksdUJBQXVCLEtBQUssaUJBQWlCLHlCQUF5QixVQUFVLEVBQUUsMEZBQTBGLFlBQVksc0JBQXNCLEtBQUsseURBQXlELHdHQUF3RyxTQUFTLHdGQUF3RixZQUFZLHNCQUFzQixLQUFLLDhCQUE4Qiw0QkFBNEIsOEdBQThHLEVBQUUsaURBQWlELG9IQUFvSCxpQkFBaUIsWUFBWSxzQkFBc0IsS0FBSyw4QkFBOEIsV0FBVyxLQUFLLGVBQWUsZ0JBQWdCLCtFQUErRSxtQ0FBbUMsMlVBQTJVLE1BQU0scUdBQXFHLHVCQUF1QixNQUFNLFVBQVUsSUFBSSxZQUFZLE1BQU0sdURBQXVELG1DQUFtQyw4UUFBOFEsaUJBQWlCLEVBQUUsdUNBQXVDLE1BQU0sMkNBQTJDLElBQUksd0JBQXdCLHdCQUF3QixpRUFBaUUsYUFBYSxRQUFRLHVCQUF1QiwyQkFBMkIsNENBQTRDLGlDQUFpQyxNQUFNLFlBQVksb0NBQW9DLEdBQUcsOERBQThELEVBQUUsR0FBRyw4REFBOEQsMEVBQTBFLEdBQUcsc0JBQXNCLFNBQVMsYUFBYSxvR0FBb0csNEVBQTRFLDhDQUE4QywrRUFBK0UsU0FBUyx1REFBdUQsbUJBQW1CLEtBQUssWUFBWSxxQkFBcUIsK0JBQStCLCtCQUErQixnQkFBZ0IscUVBQXFFLE9BQU8sR0FBRyxXQUFXLGNBQWMsZ0JBQWdCLDJCQUEyQixtQ0FBbUMsMEJBQTBCLHFFQUFxRSxZQUFZLFdBQVcsS0FBSyxzQkFBc0IsdUNBQXVDLGVBQWUsUUFBUSxTQUFTLHdCQUF3QixzQkFBc0IsMkRBQTJELGtCQUFrQixHQUFHLFNBQVMseUJBQXlCLGNBQWMsOEJBQThCLG1FQUFtRSx3Q0FBd0MsWUFBWSxXQUFXLFdBQVcseUNBQXlDLGdDQUFnQyxXQUFXLFlBQVksOEJBQThCLEVBQUUsYUFBYSwyQkFBMkIsRUFBRSxnQkFBZ0IsMEJBQTBCLCtCQUErQiw2QkFBNkIsRUFBRSxjQUFjLEVBQUUsWUFBWSw4Q0FBOEMsSUFBSSx1Q0FBdUMsbUNBQW1DLFFBQVEsU0FBUyxrQkFBa0IsOENBQThDLHlDQUF5Qyw2QkFBNkIsa0NBQWtDLHNJQUFzSSxTQUFTLFlBQVksK0JBQStCLEtBQUssK0JBQStCLDZFQUE2RSxvVkFBb1YsRUFBRSxXQUFXLGVBQWUsYUFBYSxZQUFZLDBDQUEwQyw2Q0FBNkMsa0VBQWtFLFdBQVcsWUFBWSw2QkFBNkIsS0FBSyxZQUFZLFdBQVcscUNBQXFDLGNBQWMsc0JBQXNCLGNBQWMsK0NBQStDLDREQUE0RCw0RUFBNEUsNEJBQTRCLFlBQVksV0FBVyxLQUFLLHVEQUF1RCxxQkFBcUIsV0FBVyxrQkFBa0IsWUFBWSxXQUFXLEtBQUssV0FBVyx1QkFBdUIsWUFBWSxXQUFXLG9CQUFvQixTQUFTLEVBQUUseUJBQXlCLDZCQUE2QixZQUFZLFdBQVcsS0FBSyxlQUFlLGNBQWMseUJBQXlCLE9BQU8sRUFBRSxFQUFFLFVBQVUsU0FBUyxvQkFBb0IsV0FBVyxxTkFBcU4sU0FBUyxZQUFZLHFCQUFxQixZQUFZLDhCQUE4QixFQUFFLHFDQUFxQyxZQUFZLElBQUksWUFBWSw0QkFBNEIsS0FBSywyQ0FBMkMsMkJBQTJCLFlBQVksNkJBQTZCLFlBQVksNkJBQTZCLEtBQUssTUFBTSx1REFBdUQsS0FBSyw0REFBNEQsbUJBQW1CLGdCQUFnQixrREFBa0QsU0FBUyxJQUFJLG1EQUFtRCxvREFBb0QsbUJBQW1CLDRCQUE0QixxSEFBcUgsWUFBWSxxQkFBcUIsWUFBWSw4QkFBOEIsRUFBRSxxQ0FBcUMsWUFBWSw0QkFBNEIsS0FBSywrQ0FBK0MsNkJBQTZCLFlBQVksNkJBQTZCLEtBQUssK0VBQStFLFVBQVUsU0FBUyxFQUFFLGtCQUFrQixFQUFFLG1HQUFtRyxtQkFBbUIsc0JBQXNCLElBQUksdUNBQXVDLE1BQU0sNEVBQTRFLHFCQUFxQixXQUFXLHNEQUFzRCxnRkFBZ0YsNk5BQTZOLEVBQUUsa0JBQWtCLGNBQWMseURBQXlELDRCQUE0QiwyRUFBMkUsS0FBSyxzRUFBc0Usc0VBQXNFLHFDQUFxQyw0QkFBNEIsd0NBQXdDLG1FQUFtRSxpSEFBaUgsbUNBQW1DLGlHQUFpRyxRQUFRLG1GQUFtRiwyQ0FBMkMsOERBQThELFNBQVMsb0tBQW9LLHNEQUFzRCxvQ0FBb0MsSUFBSSx5QkFBeUIsdUJBQXVCLDZFQUE2RSxZQUFZLElBQUksS0FBSyx3QkFBd0IsU0FBUyx1RUFBdUUsc0VBQXNFLGdCQUFnQixzQkFBc0IsWUFBWSxXQUFXLEtBQUssU0FBUyxvQ0FBb0Msc0NBQXNDLHFCQUFxQixxQkFBcUIsWUFBWSxXQUFXLEtBQUssa0JBQWtCLGFBQWEsc0JBQXNCLDJCQUEyQixZQUFZLFdBQVcsS0FBSyxrQkFBa0Isc0JBQXNCLHlEQUF5RCxZQUFZLG9EQUFvRCx1RUFBdUUsc0JBQXNCLG9CQUFvQix3QkFBd0IscUdBQXFHLGdCQUFnQixxQkFBcUIsYUFBYSx5Q0FBeUMsbUJBQW1CLGdHQUFnRyxZQUFZLFdBQVcsZ0NBQWdDLG1DQUFtQyxFQUFFLFNBQVMsb0JBQW9CLHFCQUFxQixtQkFBbUIsMEJBQTBCLGdCQUFnQix1QkFBdUIsaUJBQWlCLGtFQUFrRSxVQUFVLHNCQUFzQiw0RUFBNEUsc0JBQXNCLG9FQUFvRSxTQUFTLHFCQUFxQixNQUFNLDhDQUE4QyxrQ0FBa0MsbUhBQW1ILDBCQUEwQixLQUFLLDZCQUE2QixLQUFLLGdCQUFnQixzREFBc0QsMkVBQTJFLFNBQVMsdUJBQXVCLCtGQUErRixzRUFBc0UsU0FBUyx1REFBdUQsVUFBVSxvQkFBb0IsT0FBTyxxRkFBcUYsNkVBQTZFLHNCQUFzQiw0RkFBNEYsc0ZBQXNGLGtHQUFrRyx1Q0FBdUMsd0NBQXdDLHFEQUFxRCxzQkFBc0IsS0FBSyx1Q0FBdUMsTUFBTSxzREFBc0QseUJBQXlCLEtBQUssNkNBQTZDLGNBQWMsNkJBQTZCLEVBQUUsZ0JBQWdCLHVCQUF1Qiw0QkFBNEIsc0VBQXNFLEVBQUUsSUFBSSxrREFBa0QsU0FBUywyQkFBMkIsRUFBRSxJQUFJLE9BQU8sNElBQTRJLHlEQUF5RCx1RkFBdUYsR0FBRyxvQkFBb0Isc0RBQXNELDBDQUEwQyxtQkFBbUIsZUFBZSw2REFBNkQsaUVBQWlFLHNMQUFzTCwwQkFBMEIsMkNBQTJDLHlCQUF5QixrQ0FBa0MscUJBQXFCLHFCQUFxQiwwQkFBMEIsMEJBQTBCLHFCQUFxQix1QkFBdUIseUJBQXlCLGdCQUFnQixNQUFNLHNCQUFzQix5Q0FBeUMsc0JBQXNCLDRCQUE0QixpR0FBaUcsMkRBQTJELHVCQUF1QixTQUFTLHVCQUF1QixpQkFBaUIsc0JBQXNCLDhCQUE4QixtREFBbUQsdURBQXVELFNBQVMsMkJBQTJCLEVBQUUsSUFBSSxPQUFPLHNCQUFzQix5QkFBeUIsaUJBQWlCLDRJQUE0SSx1Q0FBdUMseUNBQXlDLGlIQUFpSCxxSUFBcUkscUpBQXFKLElBQUksa0NBQWtDLGdDQUFnQywrR0FBK0csU0FBUyxpQkFBaUIsZ0NBQWdDLE1BQU0scUJBQXFCLDhCQUE4Qiw2QkFBNkIsc0JBQXNCLEdBQUcsbUNBQW1DLDJCQUEyQixlQUFlLFVBQVUscUJBQXFCLFNBQVMsa0lBQWtJLGNBQWMsdUhBQXVILFFBQVEsb0JBQW9CLHdDQUF3QyxJQUFJLE9BQU8seUNBQXlDLE1BQU0saUtBQWlLLDBKQUEwSiw0QkFBNEIsOEJBQThCLHdJQUF3SSxVQUFVLGdFQUFnRSxFQUFFLFdBQVcsaURBQWlELEtBQUsseUpBQXlKLFFBQVEsWUFBWSx1QkFBdUIsb0NBQW9DLG1MQUFtTCxxR0FBcUcsNkJBQTZCLDZQQUE2UCxFQUFFLEtBQUssK0JBQStCLGlLQUFpSyw4SUFBOEksa0NBQWtDLE1BQU0sbUZBQW1GLHVHQUF1RyxLQUFLLDJCQUEyQixnTEFBZ0wsVUFBVSwyREFBMkQsU0FBUyx5SkFBeUosbUJBQW1CLG1FQUFtRSxnbUJBQWdtQixjQUFjLG9EQUFvRCwyQkFBMkIsOENBQThDLGNBQWMsd0RBQXdELGlCQUFpQixFQUFFLGlGQUFpRixrQ0FBa0MsMkJBQTJCLGlGQUFpRix1Q0FBdUMsY0FBYyxFQUFFLDhEQUE4RCxrQkFBa0IsbUVBQW1FLFdBQVcsNFFBQTRRLGdCQUFnQixvREFBb0QsaUJBQWlCLHVCQUF1QixrQkFBa0IsRUFBRSxpRkFBaUYsNkJBQTZCLHNCQUFzQixpRkFBaUYsa0NBQWtDLHdCQUF3QixvQ0FBb0MsMEJBQTBCLE9BQU8sV0FBVyx1QkFBdUIsZ0hBQWdILElBQUksdUxBQXVMLGVBQWUsNEZBQTRGLEVBQUUsR0FBRyxnQkFBZ0IscUJBQXFCLCtDQUErQyxTQUFTLG9CQUFvQixxSEFBcUgsMEJBQTBCLG1CQUFtQixxSEFBcUgsK0JBQStCLFlBQVksU0FBUywwQkFBMEIsU0FBUyw4REFBOEQsT0FBTywyQkFBMkIsMEJBQTBCLHFCQUFxQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGFBQWEsaUJBQWlCLG9DQUFvQyxxQ0FBcUMsWUFBWSxVQUFVLHFCQUFxQixhQUFhLGlCQUFpQixtQkFBbUIscUJBQXFCLHdCQUF3QixTQUFTLGVBQWUsb0JBQW9CLHFCQUFxQix3QkFBd0IsU0FBUyxlQUFlLG9CQUFvQixxQkFBcUIsd0JBQXdCLFNBQVMsNEJBQTRCLHFCQUFxQixxQkFBcUIsd0JBQXdCLFNBQVMsV0FBVyxzQkFBc0IscUJBQXFCLHdCQUF3QixTQUFTLGVBQWUsdUJBQXVCLHFCQUFxQix3QkFBd0IsU0FBUyxlQUFlLDJCQUEyQixxQkFBcUIsd0JBQXdCLFNBQVMsZUFBZSx3QkFBd0IscUJBQXFCLHdCQUF3QixTQUFTLGVBQWUsd0JBQXdCLHFCQUFxQix3QkFBd0IsU0FBUyxlQUFlLG9CQUFvQixxQkFBcUIsd0JBQXdCLGNBQWMsaUJBQWlCLHVCQUF1QixxQkFBcUIsd0JBQXdCLGNBQWMsaUJBQWlCLDBCQUEwQixxQkFBcUIsd0JBQXdCLFNBQVMsb0JBQW9CLDRDQUE0QyxjQUFjLEtBQUssb0JBQW9CLHFCQUFxQix3QkFBd0IsU0FBUyxpRkFBaUYsd0JBQXdCLHFCQUFxQix3QkFBd0IsU0FBUywrQkFBK0Isb0JBQW9CLHFCQUFxQix3QkFBd0IsYUFBYSxnQ0FBZ0MscUJBQXFCLHFCQUFxQixlQUFlLHdCQUF3QixrQkFBa0IsRUFBRSxzRUFBc0UsZUFBZSxZQUFZLFNBQVMsdUNBQXVDLE9BQU8sdUJBQXVCLFNBQVMsZ0NBQWdDLE9BQU8sb0NBQW9DLGVBQWUsd0lBQXdJLEVBQUUsR0FBRyxzQ0FBc0MscUJBQXFCLGVBQWUsc0lBQXNJLFNBQVMsY0FBYyxjQUFjLG1HQUFtRyxFQUFFLFlBQVksT0FBTyx1QkFBdUIsdUJBQXVCLGNBQWMsZ0JBQWdCLElBQUksb0JBQW9CLHFCQUFxQixlQUFlLHFCQUFxQiwwQkFBMEIsRUFBRSxlQUFlLHFCQUFxQiwwQkFBMEIsRUFBRSxRQUFRLGFBQWEsZUFBZSxhQUFhLGtCQUFrQixFQUFFLHVFQUF1RSxlQUFlLHVCQUF1Qix1QkFBdUIsT0FBTyxxQ0FBcUMsYUFBYSxvQ0FBb0Msd0JBQXdCLGVBQWUsZ0JBQWdCLGdFQUFnRSxVQUFVLFFBQVEsWUFBWSx3REFBd0Qsc0JBQXNCLFNBQVMsWUFBWSxPQUFPLHVCQUF1QixxQkFBcUIsOEJBQThCLG9CQUFvQixxQkFBcUIsd0JBQXdCLGVBQWUsZ0JBQWdCLHdDQUF3QyxzREFBc0QsVUFBVSxZQUFZLHdCQUF3QixzQkFBc0IsU0FBUyxZQUFZLE9BQU8saUJBQWlCLHFCQUFxQiw4QkFBOEIseUJBQXlCLHFCQUFxQix3QkFBd0IsZUFBZSxtQkFBbUIseURBQXlELHVPQUF1TyxpRUFBaUUscUVBQXFFLHVGQUF1RixhQUFhLEdBQUcsU0FBUyxRQUFRLGlCQUFpQiwrREFBK0QsbUhBQW1ILFNBQVMscUNBQXFDLFdBQVcsY0FBYyx3QkFBd0IscUJBQXFCLGlCQUFpQixVQUFVLHVDQUF1QyxZQUFZLE9BQU8sMEpBQTBKLHFCQUFxQiw4QkFBOEIscUJBQXFCLHFCQUFxQix3QkFBd0IsZUFBZSxtQkFBbUIsdUNBQXVDLHVGQUF1RixRQUFRLDJDQUEyQyxvREFBb0QsVUFBVSxZQUFZLGFBQWEsc0JBQXNCLFNBQVMsWUFBWSxPQUFPLGlCQUFpQixxQkFBcUIsOEJBQThCLG1CQUFtQixxQkFBcUIsd0JBQXdCLGVBQWUsZ0JBQWdCLHVDQUF1QyxzREFBc0QsVUFBVSxZQUFZLDJDQUEyQyxzQkFBc0IsU0FBUyxZQUFZLE9BQU8saUJBQWlCLHFCQUFxQiw4QkFBOEIsK0JBQStCLHFCQUFxQix3QkFBd0IsZUFBZSxnQkFBZ0Isc0NBQXNDLDhFQUE4RSxVQUFVLGNBQWMscUJBQXFCLFlBQVksZ0RBQWdELFNBQVMseUlBQXlJLEVBQUUsc0JBQXNCLFNBQVMsWUFBWSxPQUFPLGVBQWUscUJBQXFCLDhCQUE4Qix1QkFBdUIscUJBQXFCLG1CQUFtQixxQ0FBcUMsbUNBQW1DLEdBQUcsMENBQTBDLEdBQUcsc0JBQXNCLFVBQVUsWUFBWSxZQUFZLElBQUksS0FBSyxXQUFXLDZCQUE2QixHQUFHLDBDQUEwQyxHQUFHLHNCQUFzQixtQkFBbUIsaUNBQWlDLEVBQUUsR0FBRyxTQUFTLHlCQUF5QixvQkFBb0Isc0JBQXNCLG9EQUFvRCxxQkFBcUIsdUJBQXVCLGlDQUFpQyx5QkFBeUIsNENBQTRDLEVBQUUsSUFBSSxTQUFTLGlCQUFpQiw0REFBNEQsaUJBQWlCLDhEQUE4RCx1Q0FBdUMsY0FBYyx5SEFBeUgsZ0JBQWdCLFdBQVcsbUdBQW1HLGdCQUFnQixVQUFVLDBHQUEwRyxnQkFBZ0IsVUFBVSxxSkFBcUosa0RBQWtELDhCQUE4QixFQUFFLGdEQUFnRCxjQUFjLDJJQUEySSxPQUFPLElBQUksb0hBQW9ILE9BQU8sSUFBSSxjQUFjLDhHQUE4RyxvQkFBb0IsdUdBQXVHLDZDQUE2QyxFQUFFLDJDQUEyQyxjQUFjLGlJQUFpSSxPQUFPLElBQUksMEdBQTBHLE9BQU8sSUFBSSxjQUFjLDhHQUE4Ryx5SEFBeUgsRUFBRSwyQkFBMkIsaUJBQWlCLGdSQUFnUixVQUFVLDRCQUE0QixteUJBQW15QixrQ0FBa0MsR0FBRyxrQkFBa0IsOEZBQThGLDJJQUEySSxrQ0FBa0MsR0FBRyx1QkFBdUIsZ0hBQWdILDZJQUE2SSxrQ0FBa0MsSUFBSSxxQkFBcUIsZ1BBQWdQLDZCQUE2QixJQUFJLFlBQVksT0FBTyw2VkFBNlYscUJBQXFCLDZCQUE2Qix3QkFBd0IsaUJBQWlCLDJRQUEyUSxTQUFTLFFBQVEscURBQXFELHlGQUF5RixLQUFLLEdBQUcsc0RBQXNELDBRQUEwUSx1QkFBdUIsT0FBTyxnQkFBZ0IsVUFBVSxjQUFjLFFBQVEsbUZBQW1GLHFIQUFxSCxLQUFLLGdIQUFnSCwrR0FBK0csK0dBQStHLDJFQUEyRSxvREFBb0QsU0FBUyxFQUFFLHNCQUFzQixRQUFRLDZFQUE2RSxZQUFZLFdBQVcsS0FBSyx5SUFBeUksVUFBVSxhQUFhLG9IQUFvSCxZQUFZLE9BQU8sMEpBQTBKLHFCQUFxQiw0QkFBNEIscUJBQXFCLG1KQUFtSiwwQkFBMEIsSUFBSSx3QkFBd0IsZUFBZSw0QkFBNEIsWUFBWSx3QkFBd0IsdUJBQXVCLHFCQUFxQiwyS0FBMkssNkJBQTZCLE1BQU0sc0JBQXNCLHFCQUFxQiwyQkFBMkIsZUFBZSw0QkFBNEIsWUFBWSx3QkFBd0IsdUJBQXVCLHFCQUFxQiw0TkFBNE4sNkJBQTZCLE1BQU0sc0JBQXNCLHFCQUFxQix3QkFBd0IsZUFBZSxvQ0FBb0MsT0FBTyxvS0FBb0ssYUFBYSxHQUFHLFNBQVMsK0RBQStELDJDQUEyQyxxREFBcUQsa0dBQWtHLHNEQUFzRCwyUkFBMlIsYUFBYSxPQUFPLGlCQUFpQixVQUFVLGNBQWMsWUFBWSw2SEFBNkgsZUFBZSxHQUFHLHlCQUF5QixzREFBc0QseUtBQXlLLHNEQUFzRCwyREFBMkQsK0tBQStLLEVBQUUsc0JBQXNCLFFBQVEsc0JBQXNCLDhEQUE4RCxrRkFBa0YseUZBQXlGLFlBQVksd0JBQXdCLGlDQUFpQywrQkFBK0IscUJBQXFCLHdCQUF3QixlQUFlLG9DQUFvQyxPQUFPLG9LQUFvSyxhQUFhLEdBQUcsU0FBUywrREFBK0QsMkNBQTJDLHFEQUFxRCxrR0FBa0csc0RBQXNELDJSQUEyUixhQUFhLE9BQU8saUJBQWlCLFVBQVUsY0FBYyxZQUFZLDZIQUE2SCxlQUFlLEdBQUcsMkJBQTJCLDhEQUE4RCxrUEFBa1Asd0RBQXdELDJEQUEyRCxtTEFBbUwsRUFBRSxzQkFBc0IsUUFBUSx3QkFBd0Isc0VBQXNFLHlIQUF5SCx3SEFBd0gsWUFBWSx3QkFBd0IsaUNBQWlDLCtCQUErQixxQkFBcUIsd0JBQXdCLGlCQUFpQiwyUkFBMlIsb1ZBQW9WLHdGQUF3RixVQUFVLGtFQUFrRSwwQkFBMEIsR0FBRyxtY0FBbWMsU0FBUyxzRUFBc0UsVUFBVSxxQkFBcUIsWUFBWSw4QkFBOEIsa0JBQWtCLEdBQUcscURBQXFELHNHQUFzRyxxQkFBcUIsR0FBRyxtRUFBbUUsWUFBWSxZQUFZLGNBQWMsNENBQTRDLFNBQVMsb2RBQW9kLHVCQUF1QixPQUFPLGlCQUFpQixVQUFVLGNBQWMsUUFBUSxNQUFNLGtGQUFrRix3V0FBd1csRUFBRSxZQUFZLHdCQUF3QixtYUFBbWEsNkJBQTZCLHdCQUF3QixlQUFlLGFBQWEsK0JBQStCLHFCQUFxQiwyQkFBMkIsZUFBZSw2Q0FBNkMsT0FBTyxFQUFFLFlBQVksd0JBQXdCLDJDQUEyQyxxQkFBcUIsc0tBQXNLLDZCQUE2QixNQUFNLHNCQUFzQixxQkFBcUIsd0JBQXdCLGVBQWUsNFRBQTRULE9BQU8sRUFBRSxzQkFBc0IscVBBQXFQLFVBQVUsY0FBYyw2Q0FBNkMscUZBQXFGLHNGQUFzRixLQUFLLHFGQUFxRix1RkFBdUYsRUFBRSxZQUFZLE9BQU8sa0RBQWtELHFCQUFxQiw4QkFBOEIsMEJBQTBCLHFCQUFxQix3QkFBd0IsZUFBZSxrREFBa0QsT0FBTywrTkFBK04sc0JBQXNCLHNDQUFzQyw0RUFBNEUsc0JBQXNCLEtBQUssNEVBQTRFLHVCQUF1QixVQUFVLGNBQWMsc0JBQXNCLHNDQUFzQyxrQkFBa0IsMElBQTBJLHVCQUF1QixLQUFLLDRDQUE0QyxvR0FBb0csRUFBRSxZQUFZLE9BQU8sMkVBQTJFLHFCQUFxQiw4QkFBOEIsNEJBQTRCLHFCQUFxQix1Q0FBdUMsY0FBYyx3QkFBd0IsY0FBYyw2RkFBNkYsT0FBTyxLQUFLLG1GQUFtRixPQUFPLEtBQUssaUdBQWlHLEVBQUUsd0JBQXdCLGVBQWUsb1NBQW9TLFNBQVMseUdBQXlHLGtCQUFrQixJQUFJLDRDQUE0QywySEFBMkgsS0FBSyxLQUFLLDRFQUE0RSx5VEFBeVQsVUFBVSxjQUFjLFFBQVEsdUZBQXVGLHNIQUFzSCxFQUFFLHNCQUFzQixRQUFRLHdTQUF3UyxtRUFBbUUsWUFBWSx3QkFBd0IsZ05BQWdOLCtCQUErQixxQkFBcUIscUJBQXFCLHFCQUFxQixpSEFBaUgsNkdBQTZHLGNBQWMsdUNBQXVDLHNCQUFzQixxQ0FBcUMsc0NBQXNDLGNBQWMscUJBQXFCLDBEQUEwRCxFQUFFLEtBQUssNEJBQTRCLG9IQUFvSCxzT0FBc08sc0NBQXNDLG1CQUFtQixZQUFZLElBQUksS0FBSywyQkFBMkIseUJBQXlCLEtBQUssYUFBYSx5RkFBeUYsT0FBTyxzQkFBc0IsRUFBRSx5QkFBeUIsYUFBYSxNQUFNLDhCQUE4QixFQUFFLDJCQUEyQixlQUFlLFNBQVMsTUFBTSxvRkFBb0YsbUNBQW1DLGFBQWEsOElBQThJLCtUQUErVCxPQUFPLG1GQUFtRixZQUFZLHVCQUF1QixzRUFBc0UsNEJBQTRCLHlCQUF5QixhQUFhLGVBQWUsc0JBQXNCLG9CQUFvQiwwQkFBMEIsMEJBQTBCLGFBQWEscUVBQXFFLFNBQVMsZ0NBQWdDLG9CQUFvQixjQUFjLGlCQUFpQixjQUFjLDJCQUEyQixrQ0FBa0MscUJBQXFCLCtCQUErQixvQkFBb0IsY0FBYyxFQUFFLGFBQWEsdUJBQXVCLDJFQUEyRSxZQUFZLElBQUksaUJBQWlCLFNBQVMseUJBQXlCLGNBQWMsZUFBZSxTQUFTLDRGQUE0RixvQkFBb0IsMkNBQTJDLDBCQUEwQixvQkFBb0IsRUFBRSxnQ0FBZ0MsbUJBQW1CLE1BQU0sMEdBQTBHLCtLQUErSyxpQkFBaUIsNEJBQTRCLG9CQUFvQixHQUFHLHFDQUFxQyxlQUFlLEdBQUcsa0NBQWtDLG9CQUFvQixPQUFPLGtHQUFrRyxpQ0FBaUMsZ1dBQWdXLHVKQUF1SixtT0FBbU8sS0FBSyxpRkFBaUYsV0FBVyxVQUFVLHFCQUFxQiw0QkFBNEIsVUFBVSxrQ0FBa0MsRUFBRSxHQUFHLG1FQUFtRSxZQUFZLHNCQUFzQixLQUFLLG1HQUFtRyxrREFBa0QsR0FBRyw2QkFBNkIsVUFBVSxtQkFBbUIsRUFBRSxtQkFBbUIsUUFBUSxHQUFHLG1CQUFtQixnREFBZ0QsRUFBRSxXQUFXLDZEQUE2RCxjQUFjLEVBQUUsa0NBQWtDLDBDQUEwQyxjQUFjLFlBQVksaURBQWlELDJDQUEyQyxjQUFjLEdBQUcsMkJBQTJCLHdGQUF3RixnRUFBZ0UsaUJBQWlCLHVCQUF1QiwwQkFBMEIsNkJBQTZCLFVBQVUsY0FBYyxrRkFBa0YsMEVBQTBFLHNFQUFzRSw2Q0FBNkMsR0FBRywwQkFBMEIsVUFBVSxvQkFBb0IsOEZBQThGLE9BQU8sV0FBVyxjQUFjLHNDQUFzQyx3QkFBd0Isb0ZBQW9GLHFDQUFxQywrQkFBK0Isd0NBQXdDLEVBQUUsbUJBQW1CLGNBQWMsa0JBQWtCLHdLQUF3SyxFQUFFLHVCQUF1QixvREFBb0QsMEJBQTBCLHNFQUFzRSxnQ0FBZ0MsaUdBQWlHLFlBQVksMkJBQTJCLDBJQUEwSSw0REFBNEQsNEJBQTRCLG9EQUFvRCw0Q0FBNEMsOENBQThDLFVBQVUsMEJBQTBCLEVBQUUsdUJBQXVCLDhCQUE4QixPQUFPLEtBQUssbUJBQW1CLHFCQUFxQix5QkFBeUIscUJBQXFCLGVBQWUsbWxDQUFtbEMsU0FBUyx1ZEFBdWQsVUFBVSxjQUFjLDhFQUE4RSxTQUFTLElBQUksV0FBVyxPQUFPLHFDQUFxQyw4RUFBOEUseUVBQXlFLHFIQUFxSCxrRkFBa0YsR0FBRyxxREFBcUQsbUlBQW1JLDZDQUE2QyxpRUFBaUUsRUFBRSxZQUFZLDJCQUEyQix3a0JBQXdrQixxQ0FBcUMsU0FBUyw2QkFBNkIscUJBQXFCLHdCQUF3QixlQUFlLDBCQUEwQixVQUFVLGNBQWMsbU1BQW1NLGtGQUFrRixxQkFBcUIsaUNBQWlDLEVBQUUsRUFBRSx1QkFBdUIsa0JBQWtCLHlCQUF5QixxQkFBcUIsd0JBQXdCLGVBQWUsd1RBQXdULGtrQ0FBa2tDLFNBQVMsUUFBUSxvQkFBb0IseWNBQXljLFVBQVUsY0FBYyx1RkFBdUYsU0FBUyxJQUFJLDRDQUE0QyxxRkFBcUYsaUZBQWlGLHFIQUFxSCwwRkFBMEYsR0FBRyx5REFBeUQsOENBQThDLCtCQUErQix5R0FBeUcsMklBQTJJLGtGQUFrRixtQkFBbUIsZ0NBQWdDLGdDQUFnQyxZQUFZLEVBQUUsWUFBWSwyQkFBMkIsMHFCQUEwcUIscUNBQXFDLFNBQVMsdUJBQXVCLHFCQUFxQix3QkFBd0IsZUFBZSwrS0FBK0ssVUFBVSxjQUFjLG1NQUFtTSxrRkFBa0YscUJBQXFCLGlDQUFpQyxFQUFFLEVBQUUsdUJBQXVCLDREQUE0RCxtQkFBbUIscUJBQXFCLHdCQUF3QixlQUFlLGkxQ0FBaTFDLFNBQVMsTUFBTSxRQUFRLG9CQUFvQix5U0FBeVMsTUFBTSxpQkFBaUIsd0JBQXdCLHdDQUF3Qyx5QkFBeUIsV0FBVywwREFBMEQsc0JBQXNCLDZCQUE2Qiw0QkFBNEIsbUdBQW1HLG9CQUFvQixjQUFjLFVBQVUsY0FBYyxxQ0FBcUMsd0ZBQXdGLFNBQVMsSUFBSSxrQkFBa0IscUZBQXFGLGlGQUFpRixxSEFBcUgsMEZBQTBGLEdBQUcsMkRBQTJELDhDQUE4QywrQkFBK0Isa0pBQWtKLDhCQUE4QixzSkFBc0osb0NBQW9DLGNBQWMsRUFBRSxZQUFZLDJCQUEyQiwrckJBQStyQixxQ0FBcUMsU0FBUyx3QkFBd0IscUJBQXFCLHdCQUF3QixlQUFlLCtLQUErSyxVQUFVLGNBQWMsbU1BQW1NLGtGQUFrRixxQkFBcUIsaUNBQWlDLEVBQUUsRUFBRSx1QkFBdUIsNERBQTRELG9CQUFvQixxQkFBcUIsd0JBQXdCLGVBQWUsNEJBQTRCLGdCQUFnQixTQUFTLGdIQUFnSCxTQUFTLFVBQVUsY0FBYyxJQUFJLHNCQUFzQixrSUFBa0ksWUFBWSxXQUFXLFlBQVksb0JBQW9CLEtBQUssb0JBQW9CLG9GQUFvRixLQUFLLDhDQUE4Qyx1QkFBdUIsRUFBRSxTQUFTLG9CQUFvQixNQUFNLDJCQUEyQixjQUFjLEVBQUUsT0FBTyxnRkFBZ0YsRUFBRSxnQkFBZ0IsWUFBWSwrQkFBK0IsZ0RBQWdELEtBQUsseUJBQXlCLHFDQUFxQyxPQUFPLDBCQUEwQixFQUFFLFNBQVMscUNBQXFDLGNBQWMsUUFBUSxFQUFFLHVCQUF1Qiw0QkFBNEIsU0FBUyxzREFBc0QsU0FBUywwQkFBMEIsU0FBUyx5REFBeUQsb0JBQW9CLFNBQVMsc0RBQXNELG1CQUFtQixTQUFTLGFBQWEsU0FBUyw2Q0FBNkMsYUFBYSxjQUFjLFNBQVMseUJBQXlCLHFDQUFxQyxZQUFZLG1CQUFtQixnQ0FBZ0MsUUFBUSwrQkFBK0IscUJBQXFCLGVBQWUsSUFBSSxvREFBb0Qsb0RBQW9ELGtGQUFrRixxQkFBcUIsU0FBUyxzRkFBc0YsMEdBQTBHLFdBQVcsNkZBQTZGLFNBQVMscUJBQXFCLGVBQWUsK0VBQStFLHdHQUF3RyxpQ0FBaUMsT0FBTyxHQUFHLFVBQVUsY0FBYyw4UUFBOFEsa0ZBQWtGLHFCQUFxQixpQ0FBaUMsRUFBRSxFQUFFLHNCQUFzQix1Q0FBdUMsMEhBQTBILG1CQUFtQixjQUFjLElBQUksWUFBWSx1RkFBdUYsb0RBQW9ELEVBQUUsb0JBQW9CLE9BQU8sa0dBQWtHLHdGQUF3RixtV0FBbVcsa0lBQWtJLDBNQUEwTSxLQUFLLGlGQUFpRixXQUFXLFVBQVUscUJBQXFCLDRCQUE0QixVQUFVLGtDQUFrQyxFQUFFLEdBQUcsOERBQThELFlBQVksc0JBQXNCLEtBQUssZUFBZSxrREFBa0QsR0FBRyw2QkFBNkIsVUFBVSxtQkFBbUIsRUFBRSxtQkFBbUIsUUFBUSxHQUFHLG1CQUFtQixnREFBZ0QsRUFBRSw0QkFBNEIsSUFBSSx1RUFBdUUseUdBQXlHLCtDQUErQyx5QkFBeUIsd0JBQXdCLGVBQWUsSUFBSSx1RUFBdUUsR0FBRyxvQ0FBb0MsS0FBSyxRQUFRLDBZQUEwWSxTQUFTLE1BQU0sUUFBUSxxREFBcUQseUZBQXlGLEtBQUssR0FBRyw0REFBNEQsbUhBQW1ILDREQUE0RCxnS0FBZ0ssTUFBTSx3QkFBd0IsMENBQTBDLHlCQUF5QixXQUFXLDhDQUE4QyxvQkFBb0IsNkJBQTZCLDRCQUE0QixxR0FBcUcsY0FBYyxVQUFVLGNBQWMsMEZBQTBGLFNBQVMsSUFBSSw4Q0FBOEMsOEVBQThFLGlGQUFpRixHQUFHLHVHQUF1RyxrSEFBa0gsMEZBQTBGLEdBQUcseUxBQXlMLG9KQUFvSixpREFBaUQsd0dBQXdHLDBNQUEwTSxjQUFjLEVBQUUsWUFBWSx5QkFBeUIsUUFBUSx3QkFBd0IscUpBQXFKLHFDQUFxQyxPQUFPLG1CQUFtQix3R0FBd0csbUNBQW1DLG1CQUFtQiwwRUFBMEUsOEJBQThCLHFCQUFxQix3QkFBd0IsZUFBZSxnQkFBZ0Isb0NBQW9DLEtBQUssT0FBTyxHQUFHLHVCQUF1QixrQkFBa0IsMEJBQTBCLHFCQUFxQix3QkFBd0IsZUFBZSx3SEFBd0gsaUJBQWlCLGdEQUFnRCxtQkFBbUIsWUFBWSx5QkFBeUIsNkRBQTZELFNBQVMsVUFBVSxjQUFjLHlCQUF5QixZQUFZLDZCQUE2Qiw2REFBNkQsbURBQW1ELFNBQVMsRUFBRSxZQUFZLE9BQU8seURBQXlELHFCQUFxQiw0QkFBNEIsVUFBVSx5QkFBeUIsdUJBQXVCLHFCQUFxQix3QkFBd0IsZUFBZSwwQkFBMEIsT0FBTyxFQUFFLGlCQUFpQixjQUFjLHNCQUFzQixnQ0FBZ0MscUJBQXFCLHdCQUF3QixlQUFlLHFPQUFxTyxXQUFXLHVFQUF1RSwyaEJBQTJoQixVQUFVLEVBQUUsU0FBUyxRQUFRLG9CQUFvQiwwU0FBMFMsZ0JBQWdCLFFBQVEsZ0JBQWdCLHNCQUFzQixRQUFRLGdCQUFnQixrQ0FBa0MsVUFBVSxjQUFjLHlCQUF5QixtREFBbUQsMk1BQTJNLEVBQUUsWUFBWSxPQUFPLG9YQUFvWCxxQkFBcUIsOEJBQThCLHFCQUFxQixxQkFBcUIsd0JBQXdCLGVBQWUsT0FBTywyQkFBMkIsVUFBVSwrQkFBK0Isc0JBQXNCLFFBQVEsZ0hBQWdILFdBQVcsa0hBQWtILHFCQUFxQixVQUFVLGNBQWMseUJBQXlCLFlBQVksZ0RBQWdELFVBQVUsWUFBWSxTQUFTLGNBQWMsb0JBQW9CLGFBQWEsRUFBRSxZQUFZLFNBQVMsc0RBQXNELHdCQUF3Qiw4QkFBOEIsdUJBQXVCLHFCQUFxQix3QkFBd0IsZUFBZSxrRUFBa0UsVUFBVSxjQUFjLHlCQUF5QixZQUFZLGdDQUFnQyxFQUFFLFlBQVksT0FBTywrQkFBK0IscUJBQXFCLDhCQUE4QiwwQkFBMEIscUJBQXFCLHdCQUF3QixlQUFlLHFDQUFxQyxPQUFPLEVBQUUsc0JBQXNCLHlCQUF5QixVQUFVLHFDQUFxQyxZQUFZLE9BQU8sU0FBUyxxQkFBcUIsOEJBQThCLDRCQUE0QixxQkFBcUIsd0JBQXdCLGVBQWUsd0NBQXdDLFlBQVksMEJBQTBCLG9FQUFvRSxhQUFhLG9CQUFvQix5QkFBeUIsMEVBQTBFLFlBQVksV0FBVyxLQUFLLFdBQVcscUNBQXFDLDZEQUE2RCxVQUFVLFlBQVksYUFBYSxpQ0FBaUMsU0FBUyw2QkFBNkIsU0FBUyxzQkFBc0IsU0FBUyxZQUFZLFdBQVcsNkJBQTZCLEtBQUssTUFBTSwwSEFBMEgsVUFBVSxjQUFjLHlCQUF5QixtR0FBbUcsY0FBYyxFQUFFLFlBQVksT0FBTyw2QkFBNkIscUJBQXFCLDhCQUE4Qix1QkFBdUIscUJBQXFCLHdCQUF3QixlQUFlLDRIQUE0SCxnSEFBZ0gsUUFBUSxXQUFXLDRCQUE0QiwrS0FBK0ssdUZBQXVGLHdCQUF3QixHQUFHLHNCQUFzQixRQUFRLGdCQUFnQixpQ0FBaUMsWUFBWSxJQUFJLFVBQVUseUNBQXlDLFlBQVksT0FBTyxlQUFlLHFCQUFxQiw4QkFBOEIsdUJBQXVCLHFCQUFxQix3QkFBd0IsZUFBZSxnQkFBZ0Isb0dBQW9HLHNCQUFzQixTQUFTLFlBQVksMkJBQTJCLDBCQUEwQiw0QkFBNEIsaUJBQWlCLFlBQVksbUNBQW1DLFVBQVUsY0FBYyx5QkFBeUIsNkNBQTZDLDBCQUEwQixJQUFJLHVCQUF1QixxQkFBcUIsd0JBQXdCLGVBQWUsa0lBQWtJLFdBQVcsd0lBQXdJLG1jQUFtYyxTQUFTLHdMQUF3TCxpQ0FBaUMsaUJBQWlCLHVEQUF1RCxzQkFBc0IsOERBQThELDJCQUEyQix5REFBeUQsaUJBQWlCLHVDQUF1QyxFQUFFLElBQUksUUFBUSxZQUFZLFdBQVcsS0FBSyxvQkFBb0IsMkRBQTJELGlCQUFpQix1Q0FBdUMsRUFBRSxHQUFHLHVCQUF1QixpQ0FBaUMsVUFBVSxjQUFjLHlCQUF5QixZQUFZLHFDQUFxQywrQ0FBK0MsaURBQWlELEVBQUUsWUFBWSxPQUFPLGtUQUFrVCxxQkFBcUIsOEJBQThCLHlCQUF5QixxQkFBcUIsd0JBQXdCLGVBQWUsV0FBVywwQkFBMEIsaUJBQWlCLGFBQWEscUNBQXFDLGdDQUFnQyxzRUFBc0UseUJBQXlCLG1DQUFtQyxZQUFZLFdBQVcsS0FBSyxvQ0FBb0MsMkNBQTJDLHdCQUF3Qix3QkFBd0IsS0FBSyxzSEFBc0gsV0FBVyxTQUFTLFNBQVMsMEpBQTBKLFVBQVUsWUFBWSxTQUFTLGtEQUFrRCxnSEFBZ0gsa0JBQWtCLElBQUksb0NBQW9DLFlBQVksV0FBVyxLQUFLLG9DQUFvQyw0Q0FBNEMseUJBQXlCLHVGQUF1RixVQUFVLGNBQWMsNkJBQTZCLDRCQUE0Qix5QkFBeUIsWUFBWSxnQkFBZ0IsYUFBYSxZQUFZLE1BQU0sY0FBYyxVQUFVLDZCQUE2QixLQUFLLFNBQVMsZ0JBQWdCLGFBQWEsWUFBWSxnRkFBZ0Ysc0NBQXNDLGFBQWEsMEJBQTBCLHFCQUFxQixlQUFlLHFDQUFxQyxNQUFNLFlBQVksc0VBQXNFLDZCQUE2QixhQUFhLDhCQUE4QixXQUFXLFVBQVUsa0NBQWtDLEVBQUUsc0JBQXNCLElBQUksTUFBTSxrQ0FBa0MsWUFBWSxXQUFXLEtBQUssb0NBQW9DLDRDQUE0QyxTQUFTLGtEQUFrRCwrREFBK0QsaUJBQWlCLGNBQWMsdUJBQXVCLDhEQUE4RCxnRUFBZ0Usc0lBQXNJLFVBQVUsS0FBSyxTQUFTLElBQUksbUNBQW1DLDhCQUE4QixXQUFXLFlBQVksYUFBYSxpQkFBaUIsU0FBUyxHQUFHLHFCQUFxQixlQUFlLFNBQVMsaUJBQWlCLGNBQWMsbUJBQW1CLFlBQVksV0FBVyxnQkFBZ0IsU0FBUyxJQUFJLG1CQUFtQixxQkFBcUIsd0JBQXdCLGVBQWUsU0FBUyxpQkFBaUIsY0FBYyxtQkFBbUIsWUFBWSxXQUFXLGdCQUFnQixTQUFTLElBQUksd0JBQXdCLHFCQUFxQix3QkFBd0IsZUFBZSxTQUFTLGlCQUFpQixjQUFjLG1CQUFtQixZQUFZLFdBQVcsZ0JBQWdCLHVCQUF1QixJQUFJLHVCQUF1QixxQkFBcUIsd0JBQXdCLGVBQWUsU0FBUyxpQkFBaUIsY0FBYyxXQUFXLFlBQVksV0FBVyxpQkFBaUIsU0FBUyxJQUFJLHVCQUF1QixxQkFBcUIsd0JBQXdCLGVBQWUsU0FBUyxpQkFBaUIsY0FBYyxXQUFXLFlBQVksV0FBVyxpQkFBaUIsU0FBUyxJQUFJLHVCQUF1QixxQkFBcUIsd0JBQXdCLGVBQWUsNENBQTRDLGtHQUFrRyxTQUFTLCtJQUErSSxJQUFJLFNBQVMsMkJBQTJCLEtBQUssTUFBTSxZQUFZLFNBQVMsWUFBWSxXQUFXLEtBQUssbUJBQW1CLHNCQUFzQixTQUFTLHNDQUFzQyxLQUFLLE1BQU0sYUFBYSx5SkFBeUosaUJBQWlCLDhCQUE4QixzQkFBc0IsdUhBQXVILGtFQUFrRSx5QkFBeUIsMkJBQTJCLFVBQVUsTUFBTSxXQUFXLFNBQVMsaUJBQWlCLHVCQUF1Qiw4RUFBOEUsZ0ZBQWdGLHNFQUFzRSxTQUFTLDhCQUE4QixTQUFTLElBQUksY0FBYyxTQUFTLGlCQUFpQixZQUFZLEtBQUssUUFBUSxnQkFBZ0IsU0FBUyxZQUFZLFdBQVcsZ0dBQWdHLHNCQUFzQixtQkFBbUIsRUFBRSxZQUFZLE9BQU8sZUFBZSxxQkFBcUIsOEJBQThCLDJCQUEyQixxQkFBcUIsaUJBQWlCLEtBQUssSUFBSSxNQUFNLFNBQVMsbUJBQW1CLHVIQUF1SCx5RkFBeUYsZUFBZSx5RkFBeUYsZUFBZSwwSkFBMEosc0NBQXNDLHVCQUF1QixRQUFRLGNBQWMsTUFBTSxRQUFRLE1BQU0sU0FBUyxZQUFZLElBQUksY0FBYyx5QkFBeUIsYUFBYSxNQUFNLFNBQVMsWUFBWSxJQUFJLGNBQWMseUJBQXlCLFNBQVMsTUFBTSxvR0FBb0csS0FBSyx3REFBd0QsY0FBYyxRQUFRLE1BQU0sa0JBQWtCLFNBQVMsWUFBWSxNQUFNLGNBQWMsVUFBVSx5Q0FBeUMsRUFBRSx3QkFBd0IsZUFBZSwwSEFBMEgsU0FBUyx1SkFBdUosa0JBQWtCLHVHQUF1Ryw4QkFBOEIsK0RBQStELFNBQVMsTUFBTSxRQUFRLEdBQUcsaUJBQWlCLGdHQUFnRyxVQUFVLFlBQVksb0JBQW9CLG9NQUFvTSxtQkFBbUIsTUFBTSxnR0FBZ0csc0JBQXNCLHVKQUF1SixrQ0FBa0MsdUdBQXVHLDhCQUE4QixnREFBZ0Qsa0JBQWtCLGlDQUFpQyxpQkFBaUIsWUFBWSxZQUFZLE9BQU8sd0NBQXdDLHFCQUFxQiw4QkFBOEIsbUJBQW1CLHFCQUFxQix3QkFBd0IsZUFBZSxzREFBc0Qsc0JBQXNCLFNBQVMsWUFBWSwyQkFBMkIsb0JBQW9CLDRCQUE0QixVQUFVLGNBQWMseUJBQXlCLFlBQVksbUVBQW1FLElBQUksNkJBQTZCLHFCQUFxQix3QkFBd0IsZUFBZSxrREFBa0Qsc0JBQXNCLFNBQVMsWUFBWSwyQkFBMkIsZ0JBQWdCLDRCQUE0QixVQUFVLGNBQWMseUJBQXlCLFlBQVksd0NBQXdDLHlDQUF5Qyw0QkFBNEIseUJBQXlCLElBQUksK0JBQStCLHFCQUFxQix3QkFBd0IsZUFBZSwrRUFBK0Usa0JBQWtCLG9DQUFvQyxzQkFBc0IsU0FBUyxZQUFZLDJCQUEyQixnQkFBZ0IsNEJBQTRCLFVBQVUsY0FBYyw2QkFBNkIsNkJBQTZCLGVBQWUsMkVBQTJFLGtCQUFrQix3RkFBd0YsbUJBQW1CLDJCQUEyQixTQUFTLElBQUksNEJBQTRCLHFCQUFxQiw4QkFBOEIsTUFBTSxnQ0FBZ0MscUNBQXFDLHFDQUFxQyw2RUFBNkUsUUFBUSxNQUFNLFNBQVMsNEJBQTRCLGNBQWMsb0NBQW9DLDRCQUE0QixFQUFFLDRCQUE0QixjQUFjLHlDQUF5Qyx5RUFBeUUsa0VBQWtFLDRCQUE0QixFQUFFLDRCQUE0QixrRkFBa0Ysd0JBQXdCLGVBQWUsY0FBYyxxb0JBQXFvQixTQUFTLFFBQVEsdURBQXVELCtCQUErQixHQUFHLDZGQUE2RixrQkFBa0IsSUFBSSx3QkFBd0Isb0JBQW9CLE9BQU8sR0FBRyxVQUFVLDhiQUE4YixVQUFVLGNBQWMsaUhBQWlILGNBQWMsY0FBYyxVQUFVLGdCQUFnQixTQUFTLG9EQUFvRCxNQUFNLHNKQUFzSixrQ0FBa0MsZ0tBQWdLLGlCQUFpQiwrRUFBK0UsT0FBTyxvQ0FBb0MsaUJBQWlCLEdBQUcsbUZBQW1GLEVBQUUsWUFBWSxPQUFPLHljQUF5YyxxQkFBcUIsOEJBQThCLGtDQUFrQyxxQkFBcUIsd0JBQXdCLGVBQWUsaUJBQWlCLHdFQUF3RSxnR0FBZ0csVUFBVSxHQUFHLGtDQUFrQyx5SEFBeUgsMEJBQTBCLEdBQUcsNkZBQTZGLDBCQUEwQixHQUFHLGdWQUFnVixTQUFTLFFBQVEsZUFBZSxvREFBb0QsWUFBWSxtQkFBbUIsc0NBQXNDLHFFQUFxRSxFQUFFLEdBQUcsdUZBQXVGLFVBQVUsR0FBRyxrQ0FBa0MsMFBBQTBQLFVBQVUsaUNBQWlDLGNBQWMsSUFBSSxrQkFBa0IsOEJBQThCLGlDQUFpQyxzSUFBc0ksWUFBWSxJQUFJLGdGQUFnRixnR0FBZ0csRUFBRSxZQUFZLE9BQU8sZ1BBQWdQLHFCQUFxQiw4QkFBOEIsa0NBQWtDLHFCQUFxQixtQkFBbUIsY0FBYyw0RkFBNEYsT0FBTyxhQUFhLHdNQUF3TSxpR0FBaUcsRUFBRSxrRUFBa0UsTUFBTSx1RkFBdUYsRUFBRSx3QkFBd0IsZUFBZSxpQkFBaUIsMkdBQTJHLDhGQUE4RixLQUFLLHVJQUF1SSxrQkFBa0IsU0FBUyxRQUFRLDZGQUE2RixLQUFLLGlKQUFpSixxQkFBcUIsU0FBUywySUFBMkkscUJBQXFCLFNBQVMsZUFBZSxtQkFBbUIsd0JBQXdCLE9BQU8sR0FBRyxzQkFBc0IsUUFBUSxRQUFRLDZXQUE2VyxVQUFVLHFEQUFxRCxZQUFZLE9BQU8sZ0RBQWdELHFCQUFxQiw4QkFBOEIsNkJBQTZCLHFCQUFxQix5QkFBeUIsY0FBYyx5R0FBeUcsa0NBQWtDLHdGQUF3RixFQUFFLHlCQUF5QixjQUFjLDJHQUEyRyxrQ0FBa0MsMEZBQTBGLEVBQUUsd0JBQXdCLGVBQWUsb0dBQW9HLGtIQUFrSCxzSEFBc0gsMkJBQTJCLEdBQUcsMkVBQTJFLDREQUE0RCw2R0FBNkcscUhBQXFILDBCQUEwQixHQUFHLG1IQUFtSCxPQUFPLEdBQUcsc0JBQXNCLFFBQVEsNkRBQTZELG9CQUFvQixVQUFVLGNBQWMsdUNBQXVDLHVHQUF1RyxpQkFBaUIsRUFBRSxZQUFZLE9BQU8saUVBQWlFLHFCQUFxQiw2QkFBNkIscUJBQXFCLGVBQWUsU0FBUywyQkFBMkIseUNBQXlDLDRCQUE0QixxQkFBcUIsd0JBQXdCLGVBQWUsU0FBUywyQkFBMkIseUNBQXlDLGdDQUFnQyxxQkFBcUIsd0JBQXdCLGVBQWUsdUtBQXVLLGtDQUFrQyw0SkFBNEosaUJBQWlCLElBQUksdUJBQXVCLHdDQUF3QyxtT0FBbU8sT0FBTyxHQUFHLHNCQUFzQixRQUFRLGdHQUFnRyxxTEFBcUwsVUFBVSw2SEFBNkgsWUFBWSxPQUFPLDRGQUE0RixxQkFBcUIsNkJBQTZCLHFCQUFxQixlQUFlLFNBQVMsMkJBQTJCLHlDQUF5Qyw0QkFBNEIscUJBQXFCLHdCQUF3QixlQUFlLFNBQVMsMkJBQTJCLHlDQUF5QyxnQ0FBZ0MscUJBQXFCLHdCQUF3QixlQUFlLG9MQUFvTCxrQ0FBa0MsNEpBQTRKLGlCQUFpQixJQUFJLHVCQUF1QixrREFBa0QsbU9BQW1PLE9BQU8sR0FBRyxzQkFBc0IsUUFBUSw4SUFBOEksK09BQStPLFVBQVUsNkhBQTZILFlBQVksT0FBTyw0RkFBNEYscUJBQXFCLDZCQUE2QixxQkFBcUIsZUFBZSxTQUFTLDJCQUEyQix5Q0FBeUMsNEJBQTRCLHFCQUFxQix3QkFBd0IsZUFBZSxTQUFTLDJCQUEyQix5Q0FBeUMsZ0NBQWdDLHFCQUFxQix3QkFBd0IsZUFBZSxpQ0FBaUMsT0FBTyxHQUFHLHNCQUFzQixrQkFBa0IsVUFBVSxjQUFjLHFCQUFxQixlQUFlLFdBQVcsRUFBRSxVQUFVLGNBQWMsWUFBWSxlQUFlLElBQUksc0NBQXNDLHFCQUFxQix3QkFBd0IsZUFBZSxXQUFXLEVBQUUsVUFBVSxjQUFjLFlBQVksZUFBZSxJQUFJLGtDQUFrQyxxQkFBcUIsd0JBQXdCLGVBQWUsb0hBQW9ILE9BQU8sR0FBRyxzQkFBc0Isb0VBQW9FLFVBQVUsYUFBYSxZQUFZLE9BQU8sMkJBQTJCLHFCQUFxQiw2QkFBNkIscUJBQXFCLFVBQVUsY0FBYyxZQUFZLGdFQUFnRSxJQUFJLHNDQUFzQyxxQkFBcUIsd0JBQXdCLFVBQVUsY0FBYyxZQUFZLGdFQUFnRSxJQUFJLGtDQUFrQyxxQkFBcUIsd0JBQXdCLGVBQWUsNEJBQTRCLFNBQVMsY0FBYyxnQkFBZ0IsZ0RBQWdELGlCQUFpQiwyQ0FBMkMsdUJBQXVCLG1DQUFtQywwQkFBMEIsc0NBQXNDLGNBQWMsMkJBQTJCLGFBQWEseUJBQXlCLGFBQWEsK0JBQStCLGNBQWMseUJBQXlCLFlBQVksT0FBTyxPQUFPLG1FQUFtRSxxQkFBcUIsNEJBQTRCLGdDQUFnQyxtR0FBbUcsMEJBQTBCLEVBQUUsd0JBQXdCLGVBQWUsT0FBTyxTQUFTLG9DQUFvQyxxQkFBcUIsZUFBZSxpQ0FBaUMsU0FBUyxrSEFBa0gsa0JBQWtCLEdBQUcsaUJBQWlCLFFBQVEsRUFBRSxnQ0FBZ0MsMkVBQTJFLHNCQUFzQixRQUFRLDBFQUEwRSxrQ0FBa0MsVUFBVSw4RkFBOEYsK0JBQStCLHFCQUFxQixlQUFlLGtDQUFrQyxvQ0FBb0MsZUFBZSxTQUFTLCtCQUErQix1R0FBdUcsU0FBUywrVkFBK1YscU5BQXFOLGdCQUFnQix1QkFBdUIsaUJBQWlCLHNJQUFzSSxhQUFhLDhFQUE4RSxjQUFjLGlDQUFpQyxxRkFBcUYsc0JBQXNCLDhDQUE4QyxtREFBbUQsVUFBVSwyUEFBMlAsV0FBVyw2REFBNkQsY0FBYyxFQUFFLGtDQUFrQyw4SUFBOEksY0FBYyxZQUFZLGVBQWUsc0pBQXNKLDhCQUE4Qix1QkFBdUIsY0FBYyxHQUFHLGtHQUFrRyxpR0FBaUcsd0JBQXdCLGtLQUFrSyxNQUFNLGdFQUFnRSxpQkFBaUIsdUJBQXVCLDBCQUEwQiw2QkFBNkIsVUFBVSxjQUFjLHlCQUF5Qix3RUFBd0UsS0FBSyxrREFBa0QsNENBQTRDLGVBQWUsZ0RBQWdELGVBQWUsR0FBRyxNQUFNLHdIQUF3SCxNQUFNLHFQQUFxUCxFQUFFLGVBQWUsaUVBQWlFLFNBQVMsK0JBQStCLDJCQUEyQixrQ0FBa0MsNEJBQTRCLGdCQUFnQixpQkFBaUIsMkJBQTJCLE1BQU0scUhBQXFILDRDQUE0QyxzRUFBc0UsY0FBYyx1QkFBdUIsc0ZBQXNGLDBCQUEwQiw0RkFBNEYsZ0NBQWdDLDhMQUE4TCxZQUFZLE9BQU8seUJBQXlCLHFCQUFxQiw0QkFBNEIsdUJBQXVCLGtCQUFrQixnSkFBZ0osUUFBUSw0QkFBNEIsNkJBQTZCLHFCQUFxQix3QkFBd0IsZUFBZSx3RUFBd0UsWUFBWSxPQUFPLG9DQUFvQyxxQkFBcUIsNEJBQTRCLFVBQVUsa0dBQWtHLHlCQUF5QixxQkFBcUIsSUFBSSxtQ0FBbUMsd0JBQXdCLGVBQWUsaURBQWlELDRCQUE0QixjQUFjLDREQUE0RCxnQ0FBZ0MsWUFBWSxhQUFhLGNBQWMsZ0ZBQWdGLDJCQUEyQixFQUFFLGdCQUFnQixjQUFjLGtCQUFrQixlQUFlLEVBQUUsVUFBVSxjQUFjLG9FQUFvRSxtREFBbUQsUUFBUSw0S0FBNEssRUFBRSxZQUFZLE9BQU8sb0NBQW9DLHFCQUFxQiw0QkFBNEIsc0JBQXNCLFFBQVEsOEJBQThCLDRDQUE0QywwQkFBMEIscUJBQXFCLHFCQUFxQixZQUFZLDJEQUEyRCxjQUFjLHVMQUF1TCxHQUFHLGtCQUFrQixHQUFHLG9DQUFvQyxPQUFPLElBQUksOENBQThDLHdGQUF3RixtQkFBbUIscUVBQXFFLHdCQUF3QixlQUFlLHlHQUF5RyxZQUFZLE9BQU8sb0RBQW9ELHFCQUFxQiw0QkFBNEIsc0JBQXNCLGtKQUFrSixVQUFVLGNBQWMsNkNBQTZDLE1BQU0sdUNBQXVDO0FBQzV3bk0sc0NBQXNDLGVBQWUsR0FBRyxxQkFBcUIsNkZBQTZGLDhGQUE4RixlQUFlLEdBQUcsOENBQThDLElBQUksZ0NBQWdDLHFCQUFxQixpRUFBaUUsZUFBZSxrSUFBa0kscURBQXFELGlCQUFpQixxQkFBcUIsbUNBQW1DLDZDQUE2QyxzQkFBc0IsUUFBUSxXQUFXLGlDQUFpQyxZQUFZLE9BQU8sOEdBQThHLHFCQUFxQiw0QkFBNEIsVUFBVSxjQUFjLCtCQUErQix5RkFBeUYsK0ZBQStGLG9DQUFvQyxvQkFBb0IsV0FBVyxTQUFTLGdCQUFnQixJQUFJLHdCQUF3QixxQkFBcUIsYUFBYSxlQUFlLFlBQVksT0FBTywyQ0FBMkMsMEJBQTBCLHdCQUF3QixlQUFlLDZDQUE2QyxZQUFZLE9BQU8sK0JBQStCLHFCQUFxQiw4QkFBOEIsK0JBQStCLGlFQUFpRSxlQUFlLFNBQVMsSUFBSSxvQ0FBb0MsR0FBRyxrSUFBa0ksNEdBQTRHLG9DQUFvQyxZQUFZLGtEQUFrRCxzR0FBc0csWUFBWSxHQUFHO0FBQzN3RSwyQkFBMkIsZ0JBQWdCO0FBQzNDLDJCQUEyQjtBQUMzQixTQUFTLHVDQUF1QyxxREFBcUQsR0FBRyxxQkFBcUIsWUFBWSxPQUFPLG9EQUFvRCxxQkFBcUIsNEJBQTRCLHNCQUFzQixRQUFRLFdBQVcsNEJBQTRCLFVBQVUsY0FBYyxZQUFZLHlDQUF5QyxnQ0FBZ0MsbUdBQW1HLHVDQUF1QyxnQkFBZ0IseUJBQXlCLDJCQUEyQiw2Q0FBNkMsbURBQW1ELDRDQUE0QztBQUNqd0IscUJBQXFCLFNBQVMsaUJBQWlCLElBQUksMkJBQTJCLHFCQUFxQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGFBQWEsZUFBZSxhQUFhLGVBQWUsaUJBQWlCLGVBQWUsYUFBYSxlQUFlLGFBQWEsZUFBZSxpQkFBaUIsZUFBZSxhQUFhLGVBQWUsYUFBYSxlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQiw0QkFBNEIsZUFBZSxpQkFBaUIsZUFBZSxpQkFBaUIsZUFBZSxpQkFBaUIsZUFBZSxpQkFBaUIsZUFBZSxpQkFBaUIsZUFBZSxpQkFBaUIsZUFBZSxpQkFBaUIsZUFBZSxpQkFBaUIsZUFBZSxpQkFBaUIsVUFBVSxPQUFPLGtWQUFrVixFQUFFLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLGlCQUFpQixlQUFlLFVBQVUsT0FBTyxxQkFBcUIsRUFBRSxVQUFVLE9BQU8sZ0NBQWdDLEVBQUUsZUFBZSxpQkFBaUIsZUFBZSxhQUFhLGVBQWUsYUFBYSx3QkFBd0IsY0FBYyxvQ0FBb0MsWUFBWSwrRkFBK0YsZUFBZSxpQkFBaUIsV0FBVyxpQkFBaUIsV0FBVyx3QkFBd0IsZUFBZSx5QkFBeUIsMEdBQTBHLG9RQUFvUSxVQUFVLCtQQUErUCxzQkFBc0IscUhBQXFILHNCQUFzQixZQUFZLDhCQUE4QiwwS0FBMEssb0JBQW9CLHdEQUF3RCxrQkFBa0Isb0JBQW9CLG1CQUFtQixjQUFjLEVBQUUsc0JBQXNCLHlEQUF5RCxjQUFjLDJDQUEyQyxlQUFlLE9BQU8sZUFBZSxpQkFBaUIsUUFBUSxpQkFBaUIsUUFBUSx1REFBdUQsaVFBQWlRLEVBQUUsT0FBTyxhQUFhLDZrREFBNmtELFlBQVksR0FBRyxPQUFPLGFBQWEsTUFBTSxhQUFhLHFEQUFxRCw0REFBNEQsR0FBRyxZQUFZLEdBQUcsVUFBVSxpQkFBaUIsT0FBTyxrRUFBa0UsUUFBUSxlQUFlLGFBQWEsZUFBZSxhQUFhLHNCQUFzQix1QkFBdUIsa0NBQWtDLGdJQUFnSSxzREFBc0QsdUJBQXVCLDBCQUEwQiw4Q0FBOEMsTUFBTSx5REFBeUQsc0JBQXNCLCtDQUErQyx5REFBeUQsc0JBQXNCLGtCQUFrQixxQkFBcUIsaUJBQWlCLFlBQVksb0NBQW9DLG9CQUFvQixnREFBZ0QsdUNBQXVDLG1CQUFtQixtQ0FBbUMsaUJBQWlCLG1CQUFtQix3Q0FBd0MsaUJBQWlCLFlBQVksRUFBRSxHQUFHLEVBQUUsSUFBSSxpQkFBaUIsOEJBQThCLDBDQUEwQyxNQUFNLGtDQUFrQyxvQkFBb0IscUJBQXFCLCtCQUErQixLQUFLLDhEQUE4RCxVQUFVLDBDQUEwQyxtQkFBbUIscUJBQXFCLG1CQUFtQiw4QkFBOEIsZ0NBQWdDLFlBQVksSUFBSSxvQ0FBb0MsU0FBUyxTQUFTLGVBQWUsc0JBQXNCLFVBQVUsT0FBTyxZQUFZLEVBQUUsU0FBUyw4Q0FBOEMsK0JBQStCLEVBQUUsK0JBQStCLFVBQVUscURBQXFELEVBQUUsRUFBRSxnREFBZ0QsK0JBQStCLEVBQUUsK0JBQStCLFVBQVUscURBQXFELEVBQUUsRUFBRSwrQ0FBK0MsNENBQTRDLEVBQUUsRUFBRSxrREFBa0QsK0JBQStCLEVBQUUsK0JBQStCLFVBQVUscURBQXFELEVBQUUscUVBQXFFLEVBQUUsRUFBRSw4Q0FBOEMsK0JBQStCLEVBQUUsK0JBQStCLFVBQVUscURBQXFELEVBQUUsRUFBRSxrREFBa0QsK0JBQStCLEVBQUUsK0JBQStCLFVBQVUscURBQXFELEVBQUUsRUFBRSw4Q0FBOEMsK0JBQStCLEVBQUUsK0JBQStCLFVBQVUscURBQXFELEVBQUUsRUFBRSxtREFBbUQsK0JBQStCLEVBQUUsK0JBQStCLFVBQVUscURBQXFELEVBQUUsRUFBRSxtREFBbUQsK0JBQStCLEVBQUUsK0JBQStCLFVBQVUscURBQXFELEVBQUUsRUFBRSw4Q0FBOEMsK0JBQStCLEVBQUUsK0JBQStCLFVBQVUscURBQXFELEVBQUUsRUFBRSxrREFBa0QsK0JBQStCLEVBQUUsK0JBQStCLFVBQVUscURBQXFELEVBQUUsRUFBRSxrREFBa0QsK0JBQStCLEVBQUUsK0JBQStCLFVBQVUscURBQXFELEVBQUUsRUFBRSw4Q0FBOEMsK0JBQStCLEVBQUUsK0JBQStCLFVBQVUscURBQXFELEVBQUUsRUFBRSw0REFBNEQsK0JBQStCLEVBQUUsK0JBQStCLFVBQVUscURBQXFELEVBQUUsRUFBRSw4Q0FBOEMsK0JBQStCLEVBQUUsK0JBQStCLFVBQVUscURBQXFELEVBQUUsRUFBRSxtREFBbUQsK0JBQStCLEVBQUUsK0JBQStCLFVBQVUscURBQXFELEVBQUUsUUFBUSxPQUFPLFlBQVksRUFBRSxTQUFTLDhDQUE4QywrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLCtDQUErQywrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLCtDQUErQywrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLCtDQUErQywrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLGdEQUFnRCwrQkFBK0IsRUFBRSwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLCtDQUErQywrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLHNEQUFzRCwrQkFBK0IsRUFBRSwwQ0FBMEMsRUFBRSwwQ0FBMEMsVUFBVSxxREFBcUQsRUFBRSxFQUFFLGtEQUFrRCxrQ0FBa0MsRUFBRSxrQ0FBa0MsVUFBVSxxREFBcUQsRUFBRSxFQUFFLHFEQUFxRCwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLDhDQUE4QywrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLCtDQUErQywrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLDhDQUE4QywrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLDhDQUE4QywrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLGdEQUFnRCwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLDhDQUE4QywrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLCtDQUErQywrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSw2REFBNkQsRUFBRSxFQUFFLDhDQUE4QywrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLCtDQUErQywrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSw2REFBNkQsRUFBRSxFQUFFLGdEQUFnRCwrQkFBK0IsRUFBRSxtQ0FBbUMsVUFBVSxxREFBcUQsRUFBRSxFQUFFLCtDQUErQywrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLGdEQUFnRCwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLCtDQUErQywrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLGtEQUFrRCwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLDhDQUE4QywrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLCtDQUErQywrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLCtDQUErQywrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLGdEQUFnRCwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLGlEQUFpRCwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLDhDQUE4QywrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLCtDQUErQywrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLCtDQUErQywrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLGdEQUFnRCwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLGdEQUFnRCwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLGdEQUFnRCwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLHFEQUFxRCwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLG1EQUFtRCwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLGdEQUFnRCwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLGdEQUFnRCwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLGdEQUFnRCwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLDhDQUE4QywrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLG9EQUFvRCwrQkFBK0IsVUFBVSwwREFBMEQsRUFBRSxxREFBcUQsRUFBRSxFQUFFLGdEQUFnRCwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLG1EQUFtRCwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLGdEQUFnRCwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxRQUFRLE9BQU8sWUFBWSxFQUFFLFNBQVMsdURBQXVELHlDQUF5QyxFQUFFLDRDQUE0QyxVQUFVLHdEQUF3RCxFQUFFLEVBQUUsZ0RBQWdELGtDQUFrQyxFQUFFLEVBQUUsOENBQThDLGtDQUFrQyxFQUFFLGtDQUFrQyxFQUFFLEVBQUUsNkNBQTZDLDRDQUE0QyxFQUFFLEVBQUUsNkNBQTZDLG9DQUFvQyxVQUFVLHFEQUFxRCxFQUFFLG1EQUFtRCxFQUFFLG1EQUFtRCxFQUFFLEVBQUUsNENBQTRDLG9DQUFvQyxVQUFVLHFEQUFxRCxFQUFFLEVBQUUscURBQXFELG9DQUFvQyxVQUFVLHFEQUFxRCxFQUFFLEVBQUUscURBQXFELGtDQUFrQyxVQUFVLHlDQUF5QyxFQUFFLHdEQUF3RCxFQUFFLHFEQUFxRCxFQUFFLDREQUE0RCxFQUFFLDRFQUE0RSxFQUFFLHFEQUFxRCxFQUFFLEVBQUUsMERBQTBELDJDQUEyQyxFQUFFLG1DQUFtQyxFQUFFLG9DQUFvQyxFQUFFLG9DQUFvQyxVQUFVLHFEQUFxRCxFQUFFLEVBQUUseURBQXlELDJDQUEyQyxFQUFFLG1DQUFtQyxFQUFFLG9DQUFvQyxVQUFVLHlEQUF5RCxFQUFFLEVBQUUsMkRBQTJELDJDQUEyQyxFQUFFLHVDQUF1QyxFQUFFLG9DQUFvQyxVQUFVLHlDQUF5QyxFQUFFLHdEQUF3RCxFQUFFLEVBQUUsNERBQTRELDJDQUEyQyxFQUFFLHVDQUF1QyxFQUFFLG9DQUFvQyxFQUFFLG9DQUFvQyxVQUFVLHFDQUFxQyxFQUFFLEVBQUUsMkRBQTJELDJDQUEyQyxFQUFFLG9DQUFvQyxVQUFVLHlDQUF5QyxFQUFFLHVGQUF1RixFQUFFLEVBQUUsMERBQTBELDJDQUEyQyxFQUFFLG9DQUFvQyxFQUFFLHVDQUF1QyxFQUFFLG9DQUFvQyxVQUFVLHFDQUFxQyxFQUFFLEVBQUUseURBQXlELDJDQUEyQyxFQUFFLG9DQUFvQyxFQUFFLEVBQUUsMERBQTBELDJDQUEyQyxFQUFFLEVBQUUsbURBQW1ELGtDQUFrQyxFQUFFLHlDQUF5QyxVQUFVLG1EQUFtRCxFQUFFLG1EQUFtRCxFQUFFLEVBQUUsMENBQTBDLGtDQUFrQyxFQUFFLHlDQUF5QyxVQUFVLG1EQUFtRCxFQUFFLG1EQUFtRCxFQUFFLEVBQUUsc0RBQXNELHlDQUF5QyxVQUFVLHNDQUFzQyxFQUFFLHNDQUFzQyxFQUFFLEVBQUUsNkNBQTZDLHlDQUF5QyxVQUFVLHNDQUFzQyxFQUFFLHNDQUFzQyxFQUFFLEVBQUUseURBQXlELG9DQUFvQyxFQUFFLHVDQUF1QyxFQUFFLHlDQUF5QyxVQUFVLHdEQUF3RCxFQUFFLEVBQUUsMkRBQTJELG9DQUFvQyxFQUFFLHVDQUF1QyxFQUFFLHlDQUF5QyxFQUFFLHlDQUF5QyxVQUFVLHdEQUF3RCxFQUFFLEVBQUUsd0RBQXdELDBDQUEwQyxFQUFFLHVDQUF1QyxFQUFFLHlDQUF5QyxVQUFVLHdEQUF3RCxFQUFFLEVBQUUseURBQXlELDBDQUEwQyxFQUFFLG1DQUFtQyxFQUFFLHlDQUF5QyxVQUFVLHdEQUF3RCxFQUFFLEVBQUUseURBQXlELDBDQUEwQyxFQUFFLG1DQUFtQyxFQUFFLG9DQUFvQyxVQUFVLHdEQUF3RCxFQUFFLEVBQUUseURBQXlELHlDQUF5QyxFQUFFLHlDQUF5QyxVQUFVLHdEQUF3RCxFQUFFLEVBQUUsNERBQTRELG9DQUFvQyxFQUFFLHlDQUF5QyxVQUFVLHdEQUF3RCxFQUFFLEVBQUUsdURBQXVELDBDQUEwQyxFQUFFLHlDQUF5QyxVQUFVLHdEQUF3RCxFQUFFLHNEQUFzRCxFQUFFLEVBQUUsdURBQXVELG9DQUFvQyxFQUFFLHlDQUF5QyxFQUFFLHVDQUF1QyxVQUFVLHdEQUF3RCxFQUFFLEVBQUUsd0RBQXdELDBDQUEwQyxVQUFVLHdEQUF3RCxFQUFFLHdE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LGlDQUFpQyx3QkFBd0Isd0JBQXdCLFFBQVEsYUFBYSxnQkFBZ0IscUJBQXFCLFlBQVksSUFBSSxrQkFBa0IsUUFBUSwwREFBMEQsNkRBQTZELHlEQUF5RCw2SUFBNkksU0FBUyxpQ0FBaUMsMkJBQTJCLG1DQUFtQyxzQkFBc0IsRUFBRSx3QkFBd0Isa0VBQWtFLHNCQUFzQixnRUFBZ0UsbUJBQW1CLGlFQUFpRSxxQkFBcUIsWUFBWSxtREFBbUQscUJBQXFCLHVCQUF1QixJQUFJLGdDQUFnQyw2QkFBNkIsdUJBQXVCLFNBQVMsWUFBWSxFQUFFLHdCQUF3QixpRUFBaUUsc0JBQXNCLCtEQUErRCxtQkFBbUIsaUVBQWlFLHlCQUF5QixtQkFBbUIsd0JBQXdCLG1CQUFtQix3QkFBd0Isc0JBQXNCLGdCQUFnQixHQUFHLDZDQUE2Qyx5QkFBeUIsRUFBRSxpRUFBaUUsWUFBWSxpQkFBaUIseUZBQXlGLG9DQUFvQyw4REFBOEQsZUFBZSxvQkFBb0IsMEJBQTBCLDZCQUE2Qix3RkFBd0Ysd0JBQXdCLElBQUksRUFBRSxtQ0FBbUMsNEJBQTRCLG9EQUFvRCx3RkFBd0YsdU5BQXVOLEVBQUUseUJBQXlCLGdDQUFnQyx3QkFBd0IsK0JBQStCLHlCQUF5Qiw0REFBNEQsbUJBQW1CLHFDQUFxQyxzQkFBc0IscUZBQXFGLGlCQUFpQiw4QkFBOEIseUVBQXlFLFNBQVMsT0FBTywwR0FBMEcsbUJBQW1CLGtEQUFrRCxzQ0FBc0MsZ0JBQWdCLGFBQWEsNkJBQTZCLGtCQUFrQixJQUFJLGlCQUFpQiwwQkFBMEIscUVBQXFFLGdCQUFnQixpQkFBaUIsRUFBRSxHQUFHLDJDQUEyQyxpQkFBaUIsR0FBRyxVQUFVLHdGQUF3RixxQkFBcUIsOEZBQThGLFdBQTR1RjtBQUMvbWdHIiwic291cmNlcyI6WyJEOlxcTmV4dEpzUHJvamVjdHNcXHNtYXJ0LXByb21vXFxub2RlX21vZHVsZXNcXEB2bGFkbWFuZGljXFxmYWNlLWFwaVxcZGlzdFxcZmFjZS1hcGkuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIEZhY2UtQVBJXG4gIGhvbWVwYWdlOiA8aHR0cHM6Ly9naXRodWIuY29tL3ZsYWRtYW5kaWMvZmFjZS1hcGk+XG4gIGF1dGhvcjogPGh0dHBzOi8vZ2l0aHViLmNvbS92bGFkbWFuZGljPidcbiovXG5cbnZhciB2Uj1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyIHdSPShlPT50eXBlb2YgcmVxdWlyZSE9XCJ1bmRlZmluZWRcIj9yZXF1aXJlOnR5cGVvZiBQcm94eSE9XCJ1bmRlZmluZWRcIj9uZXcgUHJveHkoZSx7Z2V0Oih0LG4pPT4odHlwZW9mIHJlcXVpcmUhPVwidW5kZWZpbmVkXCI/cmVxdWlyZTp0KVtuXX0pOmUpKGZ1bmN0aW9uKGUpe2lmKHR5cGVvZiByZXF1aXJlIT1cInVuZGVmaW5lZFwiKXJldHVybiByZXF1aXJlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aHJvdyBFcnJvcignRHluYW1pYyByZXF1aXJlIG9mIFwiJytlKydcIiBpcyBub3Qgc3VwcG9ydGVkJyl9KTt2YXIgYXg9KGUsdCk9Pntmb3IodmFyIG4gaW4gdCl2UihlLG4se2dldDp0W25dLGVudW1lcmFibGU6ITB9KX07dmFyIFBlPXt9O2F4KFBlLHtBYnM6KCk9PllsLEFjb3M6KCk9Pk5pLEFjb3NoOigpPT5UaSxBZGFkZWx0YU9wdGltaXplcjooKT0+VncsQWRhZ3JhZE9wdGltaXplcjooKT0+VXcsQWRhbU9wdGltaXplcjooKT0+R3csQWRhbWF4T3B0aW1pemVyOigpPT5IdyxBZGQ6KCk9PnZzLEFkZE46KCk9PkNpLEFsbDooKT0+WmwsQW55OigpPT5KbCxBcmdNYXg6KCk9PlFsLEFyZ01pbjooKT0+ZXUsQXNpbjooKT0+RWksQXNpbmg6KCk9Pl9pLEF0YW46KCk9PkFpLEF0YW4yOigpPT4kaSxBdGFuaDooKT0+RmksQXZnUG9vbDooKT0+RGksQXZnUG9vbDNEOigpPT50dSxBdmdQb29sM0RHcmFkOigpPT5SYyxBdmdQb29sR3JhZDooKT0+RGMsQmFja2VuZFdhc206KCk9PkwkLEJhdGNoTWF0TXVsOigpPT5SaSxCYXRjaFRvU3BhY2VORDooKT0+bnUsQmluY291bnQ6KCk9PmF1LEJpdHdpc2VBbmQ6KCk9PnJ1LEJyb2FkY2FzdEFyZ3M6KCk9Pk1jLEJyb2FkY2FzdFRvOigpPT5IUyxDYWxsYmFjazooKT0+UEMsQ2FsbGJhY2tMaXN0OigpPT5BMixDYXN0OigpPT5NaSxDZWlsOigpPT5PaSxDbGlwQnlWYWx1ZTooKT0+d3MsQ29tcGxleDooKT0+d20sQ29tcGxleEFiczooKT0+T2MsQ29uY2F0OigpPT5zdSxDb252MkQ6KCk9PlBpLENvbnYyREJhY2twcm9wRmlsdGVyOigpPT5rbSxDb252MkRCYWNrcHJvcElucHV0OigpPT5MaSxDb252M0Q6KCk9PnppLENvbnYzREJhY2twcm9wRmlsdGVyVjI6KCk9Pml1LENvbnYzREJhY2twcm9wSW5wdXRWMjooKT0+b3UsQ29zOigpPT5XaSxDb3NoOigpPT5CaSxDcm9wQW5kUmVzaXplOigpPT51dSxDdW1wcm9kOigpPT5sdSxDdW1zdW06KCk9PlZpLEN1c3RvbUNhbGxiYWNrOigpPT4kMixEYXRhU3RvcmFnZTooKT0+eW0sRGVuc2VCaW5jb3VudDooKT0+UGMsRGVwdGhUb1NwYWNlOigpPT5wdSxEZXB0aHdpc2VDb252MmROYXRpdmU6KCk9PlVpLERlcHRod2lzZUNvbnYyZE5hdGl2ZUJhY2twcm9wRmlsdGVyOigpPT5JbSxEZXB0aHdpc2VDb252MmROYXRpdmVCYWNrcHJvcElucHV0OigpPT5TbSxEaWFnOigpPT5MYyxEaWxhdGlvbjJEOigpPT5HaSxEaWxhdGlvbjJEQmFja3Byb3BGaWx0ZXI6KCk9PlJsLERpbGF0aW9uMkRCYWNrcHJvcElucHV0OigpPT5EbCxEcmF3OigpPT5ObSxFTlY6KCk9PlR2LEVhcmx5U3RvcHBpbmc6KCk9PkxDLEVpbnN1bTooKT0+VG0sRWx1OigpPT5qaSxFbHVHcmFkOigpPT5jdSxFbnZpcm9ubWVudDooKT0+VVMsRXF1YWw6KCk9PmR1LEVyZjooKT0+cWksRXhwOigpPT5LaSxFeHBhbmREaW1zOigpPT5odSxFeHBtMTooKT0+WGksRkZUOigpPT5DbSxGaWxsOigpPT56YyxGbGlwTGVmdFJpZ2h0OigpPT5tdSxGbG9vcjooKT0+WWksRmxvb3JEaXY6KCk9PlppLEZyb21QaXhlbHM6KCk9PkhoLEZ1c2VkQmF0Y2hOb3JtOigpPT5KaSxGdXNlZENvbnYyRDooKT0+b2ksRnVzZWREZXB0aHdpc2VDb252MkQ6KCk9PmxpLEdQR1BVQ29udGV4dDooKT0+V2gsR2F0aGVyTmQ6KCk9Pmd1LEdhdGhlclYyOigpPT5mdSxHcmFwaE1vZGVsOigpPT5GMSxHcmVhdGVyOigpPT5idSxHcmVhdGVyRXF1YWw6KCk9PlFpLEhpc3Rvcnk6KCk9PkYyLElGRlQ6KCk9PkVtLElkZW50aXR5OigpPT5lbyxJbWFnOigpPT5fbSxJbnB1dFNwZWM6KCk9Pnp0LElzRmluaXRlOigpPT50byxJc0luZjooKT0+bm8sSXNOYW46KCk9PmFvLEtlcm5lbEJhY2tlbmQ6KCk9PkZjLExSTjooKT0+b28sTFJOR3JhZDooKT0+U3UsTGF5ZXJWYXJpYWJsZTooKT0+azIsTGF5ZXJzTW9kZWw6KCk9PkVyLExlYWt5UmVsdTooKT0+cm8sTGVzczooKT0+eXUsTGVzc0VxdWFsOigpPT54dSxMaW5TcGFjZTooKT0+dnUsTG9nOigpPT5zbyxMb2cxcDooKT0+aW8sTG9nU29mdG1heDooKT0+cVMsTG9naWNhbEFuZDooKT0+d3UsTG9naWNhbE5vdDooKT0+a3UsTG9naWNhbE9yOigpPT5JdSxMb2dpY2FsWG9yOigpPT5qUyxMb3dlckJvdW5kOigpPT5kTSxNYXRoQmFja2VuZENQVTooKT0+UjEsTWF0aEJhY2tlbmRXZWJHTDooKT0+bGssTWF0cml4QmFuZFBhcnQ6KCk9PmhNLE1heDooKT0+bG8sTWF4UG9vbDooKT0+cG8sTWF4UG9vbDNEOigpPT5OdSxNYXhQb29sM0RHcmFkOigpPT5CYyxNYXhQb29sR3JhZDooKT0+V2MsTWF4UG9vbFdpdGhBcmdtYXg6KCk9PlZjLE1heGltdW06KCk9PnVvLE1lYW46KCk9PmNvLE1pbjooKT0+aG8sTWluaW11bTooKT0+bW8sTWlycm9yUGFkOigpPT5mbyxNb2Q6KCk9PmdvLE1vbWVudHVtT3B0aW1pemVyOigpPT5qdyxNdWx0aW5vbWlhbDooKT0+VHUsTXVsdGlwbHk6KCk9PmJvLE5lZzooKT0+Q3UsTm9uTWF4U3VwcHJlc3Npb25WMzooKT0+X3UsTm9uTWF4U3VwcHJlc3Npb25WNDooKT0+QXUsTm9uTWF4U3VwcHJlc3Npb25WNTooKT0+RnUsTm90RXF1YWw6KCk9PkV1LE9QX1NDT1BFX1NVRkZJWDooKT0+RnYsT25lSG90OigpPT55byxPbmVzTGlrZTooKT0+JHUsT3B0aW1pemVyOigpPT5ScixPcHRpbWl6ZXJDb25zdHJ1Y3RvcnM6KCk9PnQyLFBhY2s6KCk9PkR1LFBhZFYyOigpPT54byxQb29sOigpPT5tTSxQb3c6KCk9PnZvLFByZWx1OigpPT53byxQcm9kOigpPT5rbyxSTVNQcm9wT3B0aW1pemVyOigpPT5xdyxSTk46KCk9Pk1yLFJhZ2dlZEdhdGhlcjooKT0+QW0sUmFnZ2VkUmFuZ2U6KCk9PkZtLFJhZ2dlZFRlbnNvclRvVGVuc29yOigpPT4kbSxSYW5nZTooKT0+VWMsUmFuazooKT0+a3gsUmVhbDooKT0+RG0sUmVhbERpdjooKT0+SGksUmVjaXByb2NhbDooKT0+SW8sUmVkdWN0aW9uOigpPT5rbixSZWx1OigpPT5TbyxSZWx1NjooKT0+Q28sUmVzaGFwZTooKT0+UnUsUmVzaXplQmlsaW5lYXI6KCk9PlRvLFJlc2l6ZUJpbGluZWFyR3JhZDooKT0+T3UsUmVzaXplTmVhcmVzdE5laWdoYm9yOigpPT5ObyxSZXNpemVOZWFyZXN0TmVpZ2hib3JHcmFkOigpPT5NdSxSZXZlcnNlOigpPT5FbyxSb3RhdGVXaXRoT2Zmc2V0OigpPT5adSxSb3VuZDooKT0+X28sUnNxcnQ6KCk9PkFvLFNHRE9wdGltaXplcjooKT0+ZmYsU2NhdHRlck5kOigpPT5QdSxTZWFyY2hTb3J0ZWQ6KCk9Pnp1LFNlbGVjdDooKT0+V3UsU2VsdTooKT0+Rm8sU2VxdWVudGlhbDooKT0+RWYsU2lnbW9pZDooKT0+TW8sU2lnbjooKT0+Um8sU2luOigpPT4kbyxTaW5oOigpPT5EbyxTbGljZTooKT0+QnUsU29mdG1heDooKT0+em8sU29mdHBsdXM6KCk9Pk9vLFNwYWNlVG9CYXRjaE5EOigpPT5WdSxTcGFyc2VGaWxsRW1wdHlSb3dzOigpPT5HYyxTcGFyc2VSZXNoYXBlOigpPT5HdSxTcGFyc2VTZWdtZW50TWVhbjooKT0+SGMsU3BhcnNlU2VnbWVudFN1bTooKT0+amMsU3BhcnNlVG9EZW5zZTooKT0+SHUsU3BsaXRWOigpPT5VdSxTcXJ0OigpPT5QbyxTcXVhcmU6KCk9PnFjLFNxdWFyZWREaWZmZXJlbmNlOigpPT5XbyxTdGF0aWNSZWdleFJlcGxhY2U6KCk9PktjLFN0ZXA6KCk9PklzLFN0cmlkZWRTbGljZTooKT0+anUsU3RyaW5nTkdyYW1zOigpPT5YYyxTdHJpbmdTcGxpdDooKT0+WWMsU3RyaW5nVG9IYXNoQnVja2V0RmFzdDooKT0+WmMsU3ViOigpPT5CbyxTdW06KCk9PkxvLFN5bWJvbGljVGVuc29yOigpPT5IYSxUYW46KCk9PlZvLFRhbmg6KCk9PlVvLFRlbnNvcjooKT0+Q2UsVGVuc29yQnVmZmVyOigpPT5XdCxUZW5zb3JTY2F0dGVyVXBkYXRlOigpPT5MdSxUaWxlOigpPT5rcyxUb3BLOigpPT5xdSxUcmFuc2Zvcm06KCk9Pkt1LFRyYW5zcG9zZTooKT0+Q3IsVW5pcXVlOigpPT5KYyxVbnBhY2s6KCk9Plh1LFVuc29ydGVkU2VnbWVudFN1bTooKT0+UWMsVXBwZXJCb3VuZDooKT0+Zk0sVmFyaWFibGU6KCk9Pm9zLFplcm9zTGlrZTooKT0+WXUsX0Z1c2VkTWF0TXVsOigpPT5paSxhYnM6KCk9Pkx0LGFjb3M6KCk9PlB2LGFjb3NoOigpPT5MdixhZGQ6KCk9PlgsYWRkTjooKT0+dk4sYWxsOigpPT5MbSxhbnk6KCk9PnljLGFyZ01heDooKT0+ZGksYXJnTWluOigpPT56dixhc2luOigpPT5Xdixhc2luaDooKT0+QnYsYXRhbjooKT0+VnYsYXRhbjI6KCk9PlV2LGF0YW5oOigpPT5HdixhdmdQb29sOigpPT55YSxhdmdQb29sM2Q6KCk9Pmp2LGJhY2tlbmQ6KCk9PkR2LGJhY2tlbmRfdXRpbDooKT0+VCxiYXNpY0xTVE1DZWxsOigpPT5TTixiYXRjaE5vcm06KCk9Pk5zLGJhdGNoTm9ybTJkOigpPT5xdixiYXRjaE5vcm0zZDooKT0+S3YsYmF0Y2hOb3JtNGQ6KCk9Plh2LGJhdGNoVG9TcGFjZU5EOigpPT5pZCxiaW5jb3VudDooKT0+WXYsYml0d2lzZUFuZDooKT0+Tk4sYm9vbGVhbk1hc2tBc3luYzooKT0+bVQsYnJvYWRjYXN0QXJnczooKT0+VE4sYnJvYWRjYXN0VG86KCk9PmFpLGJyb2FkY2FzdF91dGlsOigpPT5KdSxicm93c2VyOigpPT5xbyxidWZmZXI6KCk9Pk9lLGNhbGxiYWNrczooKT0+ZHEsY2FzdDooKT0+cmUsY2VpbDooKT0+WnYsY2xpcEJ5VmFsdWU6KCk9PmFuLGNsb25lOigpPT5zcixjb21wbGV4OigpPT5fcixjb25jYXQ6KCk9PmV0LGNvbmNhdDFkOigpPT5Kdixjb25jYXQyZDooKT0+UXYsY29uY2F0M2Q6KCk9PmV3LGNvbmNhdDRkOigpPT50dyxjb25zdHJhaW50czooKT0+VDIsY29udjFkOigpPT56bSxjb252MmQ6KCk9PiR0LGNvbnYyZFRyYW5zcG9zZTooKT0+V20sY29udjNkOigpPT5hdyxjb252M2RUcmFuc3Bvc2U6KCk9PnJ3LGNvcHlSZWdpc3RlcmVkS2VybmVsczooKT0+eE0sY29zOigpPT5vZCxjb3NoOigpPT5CbSxjb3NpbmVXaW5kb3c6KCk9PnBmLGN1bXByb2Q6KCk9PndjLGN1bXN1bTooKT0+Vm0sY3VzdG9tR3JhZDooKT0+cHIsZGF0YTooKT0+bEUsZGVuc2VCaW5jb3VudDooKT0+WGgsZGVwcmVjYXRpb25XYXJuOigpPT4kdixkZXB0aFRvU3BhY2U6KCk9PnN3LGRlcHRod2lzZUNvbnYyZDooKT0+VHMsZGVyZWdpc3Rlck9wOigpPT5mcSxkZXZpY2VfdXRpbDooKT0+YWQsZGlhZzooKT0+RU4sZGlsYXRpb24yZDooKT0+aXcsZGlzYWJsZURlcHJlY2F0aW9uV2FybmluZ3M6KCk9PlpNLGRpc3Bvc2U6KCk9PkVlLGRpc3Bvc2VWYXJpYWJsZXM6KCk9PkpNLGRpdjooKT0+aGUsZGl2Tm9OYW46KCk9Pm93LGRvdDooKT0+bHcsZHJvcG91dDooKT0+UHcsZWluc3VtOigpPT5acyxlbHU6KCk9PlF1LGVuYWJsZURlYnVnTW9kZTooKT0+WU0sZW5hYmxlUHJvZE1vZGU6KCk9PlhNLGVuY2xvc2luZ1Bvd2VyT2ZUd286KCk9Pkx3LGVuZ2luZTooKT0+VGEsZW5zdXJlU2hhcGU6KCk9PkFOLGVudjooKT0+RyxlcXVhbDooKT0+Sm4sZXJmOigpPT5VbSxldWNsaWRlYW5Ob3JtOigpPT5jdyxleHA6KCk9PmRuLGV4cGFuZERpbXM6KCk9Pkd0LGV4cG0xOigpPT5kdyxleWU6KCk9PkdtLGZmdDooKT0+YmQsZmlsbDooKT0+eW4sZmluZEJhY2tlbmQ6KCk9PnJPLGZpbmRCYWNrZW5kRmFjdG9yeTooKT0+c08sZmxvb3I6KCk9PnRwLGZsb29yRGl2OigpPT5QbSxmb3JjZUhhbGZGbG9hdDooKT0+JEEsZnVzZWQ6KCk9PlZsLGdhdGhlcjooKT0+bnAsZ2F0aGVyTkQ6KCk9PnlULGdhdGhlcl91dGlsOigpPT5ZdyxnZXRCYWNrZW5kOigpPT5vTixnZXRHcmFkaWVudDooKT0+dngsZ2V0S2VybmVsOigpPT5mYyxnZXRLZXJuZWxzRm9yQmFja2VuZDooKT0+amgsZ2V0VGhyZWFkc0NvdW50OigpPT5fZmUsZ3BncHVfdXRpbDooKT0+dUEsZ3JhZDooKT0+UDMsZ3JhZHM6KCk9PkwzLGdyZWF0ZXI6KCk9PkNuLGdyZWF0ZXJFcXVhbDooKT0+JHIsaWZmdDooKT0+QmwsaW1hZzooKT0+bGQsaW1hZ2U6KCk9PlpuLGluVG9wS0FzeW5jOigpPT54VCxpbml0aWFsaXplcnM6KCk9PkMyLGlucHV0OigpPT5qMixpbzooKT0+anQsaXJmZnQ6KCk9PmFmLGlzRmluaXRlOigpPT5odyxpc0luZjooKT0+bXcsaXNOYU46KCk9PmZ3LGtlZXA6KCk9Pkh0LGtlcm5lbF9pbXBsczooKT0+bXIsbGF5ZXJzOigpPT5FMixsZWFreVJlbHU6KCk9PnVkLGxlc3M6KCk9PlBsLGxlc3NFcXVhbDooKT0+Q3MsbGluYWxnOigpPT5CdyxsaW5zcGFjZTooKT0+TU4sbG9hZEdyYXBoTW9kZWw6KCk9Pnc1LGxvYWRHcmFwaE1vZGVsU3luYzooKT0+azUsbG9hZExheWVyc01vZGVsOigpPT5vaixsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjooKT0+Z3csbG9nOigpPT5Rbixsb2cxcDooKT0+cGQsbG9nU2lnbW9pZDooKT0+YncsbG9nU29mdG1heDooKT0+am0sbG9nU3VtRXhwOigpPT5jZCxsb2dpY2FsQW5kOigpPT5fYSxsb2dpY2FsTm90OigpPT5kZCxsb2dpY2FsT3I6KCk9PnFtLGxvZ2ljYWxYb3I6KCk9Pnl3LGxvc3NlczooKT0+RlQsbG93ZXJCb3VuZDooKT0+UE4sbWF0TXVsOigpPT4kZSxtYXRoOigpPT5WVCxtYXg6KCk9Pm1hLG1heFBvb2w6KCk9PkR0LG1heFBvb2wzZDooKT0+eHcsbWF4UG9vbFdpdGhBcmdtYXg6KCk9PkxOLG1heGltdW06KCk9PmhyLG1lYW46KCk9PkN0LG1lbW9yeTooKT0+S2gsbWVzaGdyaWQ6KCk9PnpOLG1ldHJpY3M6KCk9PlJDLG1pbjooKT0+T2wsbWluaW11bTooKT0+ZHMsbWlycm9yUGFkOigpPT52dyxtb2Q6KCk9Pnd3LG1vZGVsOigpPT5waixtb2RlbHM6KCk9Pk1DLG1vbWVudHM6KCk9PmhkLG1vdmluZ0F2ZXJhZ2U6KCk9PmZULG11bDooKT0+eixtdWx0aVJOTkNlbGw6KCk9PldOLG11bHRpbm9taWFsOigpPT5CTixuZWc6KCk9Pnl0LG5leHRGcmFtZTooKT0+Wncsbm9ybTooKT0+ZXAsbm90RXF1YWw6KCk9PmZpLG9uZUhvdDooKT0+TGwsb25lczooKT0+UG4sb25lc0xpa2U6KCk9PmVhLG9wOigpPT5MLG91dGVyUHJvZHVjdDooKT0+Vk4scGFkOigpPT54YSxwYWQxZDooKT0+VU4scGFkMmQ6KCk9PkdOLHBhZDNkOigpPT5ITixwYWQ0ZDooKT0+ak4scG9vbDooKT0+a3cscG93OigpPT51cixwcmVsdTooKT0+ZmQscHJpbnQ6KCk9Pk92LHByb2Q6KCk9Pkl3LHByb2ZpbGU6KCk9PlFNLHJhZ2dlZEdhdGhlcjooKT0+cU4scmFnZ2VkUmFuZ2U6KCk9PktOLHJhZ2dlZFRlbnNvclRvVGVuc29yOigpPT5YTixyYW5kOigpPT5ZTixyYW5kb21HYW1tYTooKT0+ZVQscmFuZG9tTm9ybWFsOigpPT5YbSxyYW5kb21TdGFuZGFyZE5vcm1hbDooKT0+dFQscmFuZG9tVW5pZm9ybTooKT0+RXMscmFuZG9tVW5pZm9ybUludDooKT0+blQscmFuZ2U6KCk9PmdpLHJlYWR5OigpPT5uTyxyZWFsOigpPT56bCxyZWNpcHJvY2FsOigpPT5FdyxyZWdpc3RlckJhY2tlbmQ6KCk9Pk9tLHJlZ2lzdGVyQ2FsbGJhY2tDb25zdHJ1Y3RvcjooKT0+ZGoscmVnaXN0ZXJHcmFkaWVudDooKT0+S1MscmVnaXN0ZXJLZXJuZWw6KCk9PmVkLHJlZ2lzdGVyT3A6KCk9Pm1xLHJlZ3VsYXJpemVyczooKT0+T0MscmVsdTooKT0+S2UscmVsdTY6KCk9PlltLHJlbW92ZUJhY2tlbmQ6KCk9PmFPLHJlc2hhcGU6KCk9PlcscmV2ZXJzZTooKT0+YmEscmV2ZXJzZTFkOigpPT5hVCxyZXZlcnNlMmQ6KCk9PnJULHJldmVyc2UzZDooKT0+c1QscmV2ZXJzZTRkOigpPT5pVCxyZmZ0OigpPT55ZCxyb3VuZDooKT0+Wm0scnNxcnQ6KCk9PkptLHNjYWxhcjooKT0+eGUsc2NhdHRlck5EOigpPT5nVCxzY2F0dGVyX3V0aWw6KCk9PnNmLHNlYXJjaFNvcnRlZDooKT0+S20sc2VsdTooKT0+UW0sc2VwYXJhYmxlQ29udjJkOigpPT5fcyxzZXF1ZW50aWFsOigpPT5jaixzZXJpYWxpemF0aW9uOigpPT5uZSxzZXRCYWNrZW5kOigpPT50TyxzZXRQbGF0Zm9ybTooKT0+aU8sc2V0VGhyZWFkc0NvdW50OigpPT5FZmUsc2V0V2FzbVBhdGg6KCk9PlRmZSxzZXRXYXNtUGF0aHM6KCk9PkNmZSxzZXRXZWJHTENvbnRleHQ6KCk9PkRfLHNldGRpZmYxZEFzeW5jOigpPT5vVCxzaGFyZWQ6KCk9Pk0xLHNpZ21vaWQ6KCk9PmhhLHNpZ246KCk9Pl93LHNpZ25hbDooKT0+QVQsc2luOigpPT5lZixzaW5oOigpPT50ZixzbGljZTooKT0+VmUsc2xpY2UxZDooKT0+Z2Qsc2xpY2UyZDooKT0+bmYsc2xpY2UzZDooKT0+SG8sc2xpY2U0ZDooKT0+V2wsc2xpY2VfdXRpbDooKT0+S3Qsc29mdG1heDooKT0+cWEsc29mdHBsdXM6KCk9PkdvLHNwYWNlVG9CYXRjaE5EOigpPT5tZCxzcGFyc2U6KCk9PiRULHNwYXJzZVRvRGVuc2U6KCk9PmJULHNwZWN0cmFsOigpPT5fVCxzcGxpdDooKT0+TG4sc3FydDooKT0+cm4sc3F1YXJlOigpPT5wdCxzcXVhcmVkRGlmZmVyZW5jZTooKT0+cmYsc3F1ZWV6ZTooKT0+QXMsc3RhY2s6KCk9PkF0LHN0ZXA6KCk9PmpvLHN0cmlkZWRTbGljZTooKT0+QXcsc3RyaW5nOigpPT5EVCxzdWI6KCk9PnBlLHN1bTooKT0+ZmUsc3VtT3V0VHlwZTooKT0+TW0sdGFuOigpPT5Gdyx0YW5oOigpPT5jcyx0ZW5zb3I6KCk9PmJuLHRlbnNvcjFkOigpPT5qZSx0ZW5zb3IyZDooKT0+RWEsdGVuc29yM2Q6KCk9PnhkLHRlbnNvcjRkOigpPT5GYSx0ZW5zb3I1ZDooKT0+bFQsdGVuc29yNmQ6KCk9PnVULHRlbnNvclNjYXR0ZXJVcGRhdGU6KCk9PmNULHRlbnNvcl91dGlsOigpPT5XYSx0ZXN0X3V0aWw6KCk9PlpOLHRpZHk6KCk9Pk8sdGlsZTooKT0+T24sdGltZTooKT0+ZU8sdG9wazooKT0+RHcsdHJhaW46KCk9PlhzLHRyYW5zcG9zZTooKT0+RGUsdHJ1bmNhdGVkTm9ybWFsOigpPT5sZix1bmlxdWU6KCk9PlJ3LHVucmVnaXN0ZXJHcmFkaWVudDooKT0+eU0sdW5yZWdpc3Rlcktlcm5lbDooKT0+Yk0sdW5zb3J0ZWRTZWdtZW50U3VtOigpPT51Zix1bnN0YWNrOigpPT5kdCx1cGNhc3RUeXBlOigpPT5mYSx1cHBlckJvdW5kOigpPT5kVCx1dGlsOigpPT53LHZhbHVlQW5kR3JhZDooKT0+ejMsdmFsdWVBbmRHcmFkczooKT0+VzMsdmFyaWFibGU6KCk9Pk13LHZhcmlhYmxlR3JhZHM6KCk9Pk9OLHZlcnNpb246KCk9Pk9mZSx2ZXJzaW9uX2NvbnZlcnRlcjooKT0+UzUsdmVyc2lvbl9jb3JlOigpPT5wNCx2ZXJzaW9uX2NwdTooKT0+TkssdmVyc2lvbl9sYXllcnM6KCk9PnYwLHZlcnNpb25fd2FzbTooKT0+QWZlLHZlcnNpb25fd2ViZ2w6KCk9Pm1lZSx3ZWJnbDooKT0+ZmVlLHdlYmdsX3V0aWw6KCk9PiRfLHdoZXJlOigpPT5ubix3aGVyZUFzeW5jOigpPT5Pdyx6ZXJvczooKT0+SXQsemVyb3NMaWtlOigpPT5xZX0pO3ZhciBrUj1PYmplY3QuY3JlYXRlLGt2PU9iamVjdC5kZWZpbmVQcm9wZXJ0eSxJUj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFNSPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLE5SPU9iamVjdC5nZXRQcm90b3R5cGVPZixUUj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFZ0PShlLHQpPT4oKT0+KHR8fGUoKHQ9e2V4cG9ydHM6e319KS5leHBvcnRzLHQpLHQuZXhwb3J0cyksX2U9KGUsdCk9Pntmb3IodmFyIG4gaW4gdClrdihlLG4se2dldDp0W25dLGVudW1lcmFibGU6ITB9KX0sQ1I9KGUsdCxuLGEpPT57aWYodCYmdHlwZW9mIHQ9PVwib2JqZWN0XCJ8fHR5cGVvZiB0PT1cImZ1bmN0aW9uXCIpZm9yKGxldCByIG9mIFNSKHQpKSFUUi5jYWxsKGUscikmJnIhPT1uJiZrdihlLHIse2dldDooKT0+dFtyXSxlbnVtZXJhYmxlOiEoYT1JUih0LHIpKXx8YS5lbnVtZXJhYmxlfSk7cmV0dXJuIGV9LHhzPShlLHQsbik9PihuPWUhPW51bGw/a1IoTlIoZSkpOnt9LENSKHR8fCFlfHwhZS5fX2VzTW9kdWxlP2t2KG4sXCJkZWZhdWx0XCIse3ZhbHVlOmUsZW51bWVyYWJsZTohMH0pOm4sZSkpLEVSPVZ0KChlLHQpPT57dC5leHBvcnRzPWE7dmFyIG49bnVsbDt0cnl7bj1uZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSwxMywyLDk2LDAsMSwxMjcsOTYsNCwxMjcsMTI3LDEyNywxMjcsMSwxMjcsMyw3LDYsMCwxLDEsMSwxLDEsNiw2LDEsMTI3LDEsNjUsMCwxMSw3LDUwLDYsMywxMDksMTE3LDEwOCwwLDEsNSwxMDAsMTA1LDExOCw5NSwxMTUsMCwyLDUsMTAwLDEwNSwxMTgsOTUsMTE3LDAsMyw1LDExNCwxMDEsMTA5LDk1LDExNSwwLDQsNSwxMTQsMTAxLDEwOSw5NSwxMTcsMCw1LDgsMTAzLDEwMSwxMTYsOTUsMTA0LDEwNSwxMDMsMTA0LDAsMCwxMCwxOTEsMSw2LDQsMCwzNSwwLDExLDM2LDEsMSwxMjYsMzIsMCwxNzMsMzIsMSwxNzMsNjYsMzIsMTM0LDEzMiwzMiwyLDE3MywzMiwzLDE3Myw2NiwzMiwxMzQsMTMyLDEyNiwzNCw0LDY2LDMyLDEzNSwxNjcsMzYsMCwzMiw0LDE2NywxMSwzNiwxLDEsMTI2LDMyLDAsMTczLDMyLDEsMTczLDY2LDMyLDEzNCwxMzIsMzIsMiwxNzMsMzIsMywxNzMsNjYsMzIsMTM0LDEzMiwxMjcsMzQsNCw2NiwzMiwxMzUsMTY3LDM2LDAsMzIsNCwxNjcsMTEsMzYsMSwxLDEyNiwzMiwwLDE3MywzMiwxLDE3Myw2NiwzMiwxMzQsMTMyLDMyLDIsMTczLDMyLDMsMTczLDY2LDMyLDEzNCwxMzIsMTI4LDM0LDQsNjYsMzIsMTM1LDE2NywzNiwwLDMyLDQsMTY3LDExLDM2LDEsMSwxMjYsMzIsMCwxNzMsMzIsMSwxNzMsNjYsMzIsMTM0LDEzMiwzMiwyLDE3MywzMiwzLDE3Myw2NiwzMiwxMzQsMTMyLDEyOSwzNCw0LDY2LDMyLDEzNSwxNjcsMzYsMCwzMiw0LDE2NywxMSwzNiwxLDEsMTI2LDMyLDAsMTczLDMyLDEsMTczLDY2LDMyLDEzNCwxMzIsMzIsMiwxNzMsMzIsMywxNzMsNjYsMzIsMTM0LDEzMiwxMzAsMzQsNCw2NiwzMiwxMzUsMTY3LDM2LDAsMzIsNCwxNjcsMTFdKSkse30pLmV4cG9ydHN9Y2F0Y2goUyl7fWZ1bmN0aW9uIGEoUyxNLEIpe3RoaXMubG93PVN8MCx0aGlzLmhpZ2g9TXwwLHRoaXMudW5zaWduZWQ9ISFCfWEucHJvdG90eXBlLl9faXNMb25nX18sT2JqZWN0LmRlZmluZVByb3BlcnR5KGEucHJvdG90eXBlLFwiX19pc0xvbmdfX1wiLHt2YWx1ZTohMH0pO2Z1bmN0aW9uIHIoUyl7cmV0dXJuKFMmJlMuX19pc0xvbmdfXyk9PT0hMH1hLmlzTG9uZz1yO3ZhciBzPXt9LGk9e307ZnVuY3Rpb24gbyhTLE0pe3ZhciBCLFUsSDtyZXR1cm4gTT8oUz4+Pj0wLChIPTA8PVMmJlM8MjU2KSYmKFU9aVtTXSxVKT9VOihCPXUoUywoU3wwKTwwPy0xOjAsITApLEgmJihpW1NdPUIpLEIpKTooU3w9MCwoSD0tMTI4PD1TJiZTPDEyOCkmJihVPXNbU10sVSk/VTooQj11KFMsUzwwPy0xOjAsITEpLEgmJihzW1NdPUIpLEIpKX1hLmZyb21JbnQ9bztmdW5jdGlvbiBsKFMsTSl7aWYoaXNOYU4oUykpcmV0dXJuIE0/djp4O2lmKE0pe2lmKFM8MClyZXR1cm4gdjtpZihTPj1nKXJldHVybiBGfWVsc2V7aWYoUzw9LWIpcmV0dXJuIEQ7aWYoUysxPj1iKXJldHVybiBffXJldHVybiBTPDA/bCgtUyxNKS5uZWcoKTp1KFMlZnwwLFMvZnwwLE0pfWEuZnJvbU51bWJlcj1sO2Z1bmN0aW9uIHUoUyxNLEIpe3JldHVybiBuZXcgYShTLE0sQil9YS5mcm9tQml0cz11O3ZhciBwPU1hdGgucG93O2Z1bmN0aW9uIGQoUyxNLEIpe2lmKFMubGVuZ3RoPT09MCl0aHJvdyBFcnJvcihcImVtcHR5IHN0cmluZ1wiKTtpZihTPT09XCJOYU5cInx8Uz09PVwiSW5maW5pdHlcInx8Uz09PVwiK0luZmluaXR5XCJ8fFM9PT1cIi1JbmZpbml0eVwiKXJldHVybiB4O2lmKHR5cGVvZiBNPT1cIm51bWJlclwiPyhCPU0sTT0hMSk6TT0hIU0sQj1CfHwxMCxCPDJ8fDM2PEIpdGhyb3cgUmFuZ2VFcnJvcihcInJhZGl4XCIpO3ZhciBVO2lmKChVPVMuaW5kZXhPZihcIi1cIikpPjApdGhyb3cgRXJyb3IoXCJpbnRlcmlvciBoeXBoZW5cIik7aWYoVT09PTApcmV0dXJuIGQoUy5zdWJzdHJpbmcoMSksTSxCKS5uZWcoKTtmb3IodmFyIEg9bChwKEIsOCkpLHE9eCxLPTA7SzxTLmxlbmd0aDtLKz04KXt2YXIgWj1NYXRoLm1pbig4LFMubGVuZ3RoLUspLEo9cGFyc2VJbnQoUy5zdWJzdHJpbmcoSyxLK1opLEIpO2lmKFo8OCl7dmFyIGVlPWwocChCLFopKTtxPXEubXVsKGVlKS5hZGQobChKKSl9ZWxzZSBxPXEubXVsKEgpLHE9cS5hZGQobChKKSl9cmV0dXJuIHEudW5zaWduZWQ9TSxxfWEuZnJvbVN0cmluZz1kO2Z1bmN0aW9uIGMoUyxNKXtyZXR1cm4gdHlwZW9mIFM9PVwibnVtYmVyXCI/bChTLE0pOnR5cGVvZiBTPT1cInN0cmluZ1wiP2QoUyxNKTp1KFMubG93LFMuaGlnaCx0eXBlb2YgTT09XCJib29sZWFuXCI/TTpTLnVuc2lnbmVkKX1hLmZyb21WYWx1ZT1jO3ZhciBoPTY1NTM2LG09MTw8MjQsZj1oKmgsZz1mKmYsYj1nLzIseT1vKG0pLHg9bygwKTthLlpFUk89eDt2YXIgdj1vKDAsITApO2EuVVpFUk89djt2YXIgST1vKDEpO2EuT05FPUk7dmFyIE49bygxLCEwKTthLlVPTkU9Tjt2YXIgQz1vKC0xKTthLk5FR19PTkU9Qzt2YXIgXz11KC0xLDIxNDc0ODM2NDcsITEpO2EuTUFYX1ZBTFVFPV87dmFyIEY9dSgtMSwtMSwhMCk7YS5NQVhfVU5TSUdORURfVkFMVUU9Rjt2YXIgRD11KDAsLTIxNDc0ODM2NDgsITEpO2EuTUlOX1ZBTFVFPUQ7dmFyICQ9YS5wcm90b3R5cGU7JC50b0ludD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuc2lnbmVkP3RoaXMubG93Pj4+MDp0aGlzLmxvd30sJC50b051bWJlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuc2lnbmVkPyh0aGlzLmhpZ2g+Pj4wKSpmKyh0aGlzLmxvdz4+PjApOnRoaXMuaGlnaCpmKyh0aGlzLmxvdz4+PjApfSwkLnRvU3RyaW5nPWZ1bmN0aW9uKFMpe2lmKFM9U3x8MTAsUzwyfHwzNjxTKXRocm93IFJhbmdlRXJyb3IoXCJyYWRpeFwiKTtpZih0aGlzLmlzWmVybygpKXJldHVyblwiMFwiO2lmKHRoaXMuaXNOZWdhdGl2ZSgpKWlmKHRoaXMuZXEoRCkpe3ZhciBNPWwoUyksQj10aGlzLmRpdihNKSxVPUIubXVsKE0pLnN1Yih0aGlzKTtyZXR1cm4gQi50b1N0cmluZyhTKStVLnRvSW50KCkudG9TdHJpbmcoUyl9ZWxzZSByZXR1cm5cIi1cIit0aGlzLm5lZygpLnRvU3RyaW5nKFMpO2Zvcih2YXIgSD1sKHAoUyw2KSx0aGlzLnVuc2lnbmVkKSxxPXRoaXMsSz1cIlwiOzspe3ZhciBaPXEuZGl2KEgpLEo9cS5zdWIoWi5tdWwoSCkpLnRvSW50KCk+Pj4wLGVlPUoudG9TdHJpbmcoUyk7aWYocT1aLHEuaXNaZXJvKCkpcmV0dXJuIGVlK0s7Zm9yKDtlZS5sZW5ndGg8NjspZWU9XCIwXCIrZWU7Sz1cIlwiK2VlK0t9fSwkLmdldEhpZ2hCaXRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGlnaH0sJC5nZXRIaWdoQml0c1Vuc2lnbmVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGlnaD4+PjB9LCQuZ2V0TG93Qml0cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxvd30sJC5nZXRMb3dCaXRzVW5zaWduZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sb3c+Pj4wfSwkLmdldE51bUJpdHNBYnM9ZnVuY3Rpb24oKXtpZih0aGlzLmlzTmVnYXRpdmUoKSlyZXR1cm4gdGhpcy5lcShEKT82NDp0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTtmb3IodmFyIFM9dGhpcy5oaWdoIT0wP3RoaXMuaGlnaDp0aGlzLmxvdyxNPTMxO00+MCYmIShTJjE8PE0pO00tLSk7cmV0dXJuIHRoaXMuaGlnaCE9MD9NKzMzOk0rMX0sJC5pc1plcm89ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oaWdoPT09MCYmdGhpcy5sb3c9PT0wfSwkLmVxej0kLmlzWmVybywkLmlzTmVnYXRpdmU9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy51bnNpZ25lZCYmdGhpcy5oaWdoPDB9LCQuaXNQb3NpdGl2ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuc2lnbmVkfHx0aGlzLmhpZ2g+PTB9LCQuaXNPZGQ9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5sb3cmMSk9PT0xfSwkLmlzRXZlbj1mdW5jdGlvbigpe3JldHVybih0aGlzLmxvdyYxKT09PTB9LCQuZXF1YWxzPWZ1bmN0aW9uKFMpe3JldHVybiByKFMpfHwoUz1jKFMpKSx0aGlzLnVuc2lnbmVkIT09Uy51bnNpZ25lZCYmdGhpcy5oaWdoPj4+MzE9PT0xJiZTLmhpZ2g+Pj4zMT09PTE/ITE6dGhpcy5oaWdoPT09Uy5oaWdoJiZ0aGlzLmxvdz09PVMubG93fSwkLmVxPSQuZXF1YWxzLCQubm90RXF1YWxzPWZ1bmN0aW9uKFMpe3JldHVybiF0aGlzLmVxKFMpfSwkLm5lcT0kLm5vdEVxdWFscywkLm5lPSQubm90RXF1YWxzLCQubGVzc1RoYW49ZnVuY3Rpb24oUyl7cmV0dXJuIHRoaXMuY29tcChTKTwwfSwkLmx0PSQubGVzc1RoYW4sJC5sZXNzVGhhbk9yRXF1YWw9ZnVuY3Rpb24oUyl7cmV0dXJuIHRoaXMuY29tcChTKTw9MH0sJC5sdGU9JC5sZXNzVGhhbk9yRXF1YWwsJC5sZT0kLmxlc3NUaGFuT3JFcXVhbCwkLmdyZWF0ZXJUaGFuPWZ1bmN0aW9uKFMpe3JldHVybiB0aGlzLmNvbXAoUyk+MH0sJC5ndD0kLmdyZWF0ZXJUaGFuLCQuZ3JlYXRlclRoYW5PckVxdWFsPWZ1bmN0aW9uKFMpe3JldHVybiB0aGlzLmNvbXAoUyk+PTB9LCQuZ3RlPSQuZ3JlYXRlclRoYW5PckVxdWFsLCQuZ2U9JC5ncmVhdGVyVGhhbk9yRXF1YWwsJC5jb21wYXJlPWZ1bmN0aW9uKFMpe2lmKHIoUyl8fChTPWMoUykpLHRoaXMuZXEoUykpcmV0dXJuIDA7dmFyIE09dGhpcy5pc05lZ2F0aXZlKCksQj1TLmlzTmVnYXRpdmUoKTtyZXR1cm4gTSYmIUI/LTE6IU0mJkI/MTp0aGlzLnVuc2lnbmVkP1MuaGlnaD4+PjA+dGhpcy5oaWdoPj4+MHx8Uy5oaWdoPT09dGhpcy5oaWdoJiZTLmxvdz4+PjA+dGhpcy5sb3c+Pj4wPy0xOjE6dGhpcy5zdWIoUykuaXNOZWdhdGl2ZSgpPy0xOjF9LCQuY29tcD0kLmNvbXBhcmUsJC5uZWdhdGU9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy51bnNpZ25lZCYmdGhpcy5lcShEKT9EOnRoaXMubm90KCkuYWRkKEkpfSwkLm5lZz0kLm5lZ2F0ZSwkLmFkZD1mdW5jdGlvbihTKXtyKFMpfHwoUz1jKFMpKTt2YXIgTT10aGlzLmhpZ2g+Pj4xNixCPXRoaXMuaGlnaCY2NTUzNSxVPXRoaXMubG93Pj4+MTYsSD10aGlzLmxvdyY2NTUzNSxxPVMuaGlnaD4+PjE2LEs9Uy5oaWdoJjY1NTM1LFo9Uy5sb3c+Pj4xNixKPVMubG93JjY1NTM1LGVlPTAsYWU9MCx0ZT0wLHNlPTA7cmV0dXJuIHNlKz1IK0osdGUrPXNlPj4+MTYsc2UmPTY1NTM1LHRlKz1VK1osYWUrPXRlPj4+MTYsdGUmPTY1NTM1LGFlKz1CK0ssZWUrPWFlPj4+MTYsYWUmPTY1NTM1LGVlKz1NK3EsZWUmPTY1NTM1LHUodGU8PDE2fHNlLGVlPDwxNnxhZSx0aGlzLnVuc2lnbmVkKX0sJC5zdWJ0cmFjdD1mdW5jdGlvbihTKXtyZXR1cm4gcihTKXx8KFM9YyhTKSksdGhpcy5hZGQoUy5uZWcoKSl9LCQuc3ViPSQuc3VidHJhY3QsJC5tdWx0aXBseT1mdW5jdGlvbihTKXtpZih0aGlzLmlzWmVybygpKXJldHVybiB4O2lmKHIoUyl8fChTPWMoUykpLG4pe3ZhciBNPW4ubXVsKHRoaXMubG93LHRoaXMuaGlnaCxTLmxvdyxTLmhpZ2gpO3JldHVybiB1KE0sbi5nZXRfaGlnaCgpLHRoaXMudW5zaWduZWQpfWlmKFMuaXNaZXJvKCkpcmV0dXJuIHg7aWYodGhpcy5lcShEKSlyZXR1cm4gUy5pc09kZCgpP0Q6eDtpZihTLmVxKEQpKXJldHVybiB0aGlzLmlzT2RkKCk/RDp4O2lmKHRoaXMuaXNOZWdhdGl2ZSgpKXJldHVybiBTLmlzTmVnYXRpdmUoKT90aGlzLm5lZygpLm11bChTLm5lZygpKTp0aGlzLm5lZygpLm11bChTKS5uZWcoKTtpZihTLmlzTmVnYXRpdmUoKSlyZXR1cm4gdGhpcy5tdWwoUy5uZWcoKSkubmVnKCk7aWYodGhpcy5sdCh5KSYmUy5sdCh5KSlyZXR1cm4gbCh0aGlzLnRvTnVtYmVyKCkqUy50b051bWJlcigpLHRoaXMudW5zaWduZWQpO3ZhciBCPXRoaXMuaGlnaD4+PjE2LFU9dGhpcy5oaWdoJjY1NTM1LEg9dGhpcy5sb3c+Pj4xNixxPXRoaXMubG93JjY1NTM1LEs9Uy5oaWdoPj4+MTYsWj1TLmhpZ2gmNjU1MzUsSj1TLmxvdz4+PjE2LGVlPVMubG93JjY1NTM1LGFlPTAsdGU9MCxzZT0wLGllPTA7cmV0dXJuIGllKz1xKmVlLHNlKz1pZT4+PjE2LGllJj02NTUzNSxzZSs9SCplZSx0ZSs9c2U+Pj4xNixzZSY9NjU1MzUsc2UrPXEqSix0ZSs9c2U+Pj4xNixzZSY9NjU1MzUsdGUrPVUqZWUsYWUrPXRlPj4+MTYsdGUmPTY1NTM1LHRlKz1IKkosYWUrPXRlPj4+MTYsdGUmPTY1NTM1LHRlKz1xKlosYWUrPXRlPj4+MTYsdGUmPTY1NTM1LGFlKz1CKmVlK1UqSitIKlorcSpLLGFlJj02NTUzNSx1KHNlPDwxNnxpZSxhZTw8MTZ8dGUsdGhpcy51bnNpZ25lZCl9LCQubXVsPSQubXVsdGlwbHksJC5kaXZpZGU9ZnVuY3Rpb24oUyl7aWYocihTKXx8KFM9YyhTKSksUy5pc1plcm8oKSl0aHJvdyBFcnJvcihcImRpdmlzaW9uIGJ5IHplcm9cIik7aWYobil7aWYoIXRoaXMudW5zaWduZWQmJnRoaXMuaGlnaD09PS0yMTQ3NDgzNjQ4JiZTLmxvdz09PS0xJiZTLmhpZ2g9PT0tMSlyZXR1cm4gdGhpczt2YXIgTT0odGhpcy51bnNpZ25lZD9uLmRpdl91Om4uZGl2X3MpKHRoaXMubG93LHRoaXMuaGlnaCxTLmxvdyxTLmhpZ2gpO3JldHVybiB1KE0sbi5nZXRfaGlnaCgpLHRoaXMudW5zaWduZWQpfWlmKHRoaXMuaXNaZXJvKCkpcmV0dXJuIHRoaXMudW5zaWduZWQ/djp4O3ZhciBCLFUsSDtpZih0aGlzLnVuc2lnbmVkKXtpZihTLnVuc2lnbmVkfHwoUz1TLnRvVW5zaWduZWQoKSksUy5ndCh0aGlzKSlyZXR1cm4gdjtpZihTLmd0KHRoaXMuc2hydSgxKSkpcmV0dXJuIE47SD12fWVsc2V7aWYodGhpcy5lcShEKSl7aWYoUy5lcShJKXx8Uy5lcShDKSlyZXR1cm4gRDtpZihTLmVxKEQpKXJldHVybiBJO3ZhciBxPXRoaXMuc2hyKDEpO3JldHVybiBCPXEuZGl2KFMpLnNobCgxKSxCLmVxKHgpP1MuaXNOZWdhdGl2ZSgpP0k6QzooVT10aGlzLnN1YihTLm11bChCKSksSD1CLmFkZChVLmRpdihTKSksSCl9ZWxzZSBpZihTLmVxKEQpKXJldHVybiB0aGlzLnVuc2lnbmVkP3Y6eDtpZih0aGlzLmlzTmVnYXRpdmUoKSlyZXR1cm4gUy5pc05lZ2F0aXZlKCk/dGhpcy5uZWcoKS5kaXYoUy5uZWcoKSk6dGhpcy5uZWcoKS5kaXYoUykubmVnKCk7aWYoUy5pc05lZ2F0aXZlKCkpcmV0dXJuIHRoaXMuZGl2KFMubmVnKCkpLm5lZygpO0g9eH1mb3IoVT10aGlzO1UuZ3RlKFMpOyl7Qj1NYXRoLm1heCgxLE1hdGguZmxvb3IoVS50b051bWJlcigpL1MudG9OdW1iZXIoKSkpO2Zvcih2YXIgSz1NYXRoLmNlaWwoTWF0aC5sb2coQikvTWF0aC5MTjIpLFo9Szw9NDg/MTpwKDIsSy00OCksSj1sKEIpLGVlPUoubXVsKFMpO2VlLmlzTmVnYXRpdmUoKXx8ZWUuZ3QoVSk7KUItPVosSj1sKEIsdGhpcy51bnNpZ25lZCksZWU9Si5tdWwoUyk7Si5pc1plcm8oKSYmKEo9SSksSD1ILmFkZChKKSxVPVUuc3ViKGVlKX1yZXR1cm4gSH0sJC5kaXY9JC5kaXZpZGUsJC5tb2R1bG89ZnVuY3Rpb24oUyl7aWYocihTKXx8KFM9YyhTKSksbil7dmFyIE09KHRoaXMudW5zaWduZWQ/bi5yZW1fdTpuLnJlbV9zKSh0aGlzLmxvdyx0aGlzLmhpZ2gsUy5sb3csUy5oaWdoKTtyZXR1cm4gdShNLG4uZ2V0X2hpZ2goKSx0aGlzLnVuc2lnbmVkKX1yZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoUykubXVsKFMpKX0sJC5tb2Q9JC5tb2R1bG8sJC5yZW09JC5tb2R1bG8sJC5ub3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdSh+dGhpcy5sb3csfnRoaXMuaGlnaCx0aGlzLnVuc2lnbmVkKX0sJC5hbmQ9ZnVuY3Rpb24oUyl7cmV0dXJuIHIoUyl8fChTPWMoUykpLHUodGhpcy5sb3cmUy5sb3csdGhpcy5oaWdoJlMuaGlnaCx0aGlzLnVuc2lnbmVkKX0sJC5vcj1mdW5jdGlvbihTKXtyZXR1cm4gcihTKXx8KFM9YyhTKSksdSh0aGlzLmxvd3xTLmxvdyx0aGlzLmhpZ2h8Uy5oaWdoLHRoaXMudW5zaWduZWQpfSwkLnhvcj1mdW5jdGlvbihTKXtyZXR1cm4gcihTKXx8KFM9YyhTKSksdSh0aGlzLmxvd15TLmxvdyx0aGlzLmhpZ2heUy5oaWdoLHRoaXMudW5zaWduZWQpfSwkLnNoaWZ0TGVmdD1mdW5jdGlvbihTKXtyZXR1cm4gcihTKSYmKFM9Uy50b0ludCgpKSwoUyY9NjMpPT09MD90aGlzOlM8MzI/dSh0aGlzLmxvdzw8Uyx0aGlzLmhpZ2g8PFN8dGhpcy5sb3c+Pj4zMi1TLHRoaXMudW5zaWduZWQpOnUoMCx0aGlzLmxvdzw8Uy0zMix0aGlzLnVuc2lnbmVkKX0sJC5zaGw9JC5zaGlmdExlZnQsJC5zaGlmdFJpZ2h0PWZ1bmN0aW9uKFMpe3JldHVybiByKFMpJiYoUz1TLnRvSW50KCkpLChTJj02Myk9PT0wP3RoaXM6UzwzMj91KHRoaXMubG93Pj4+U3x0aGlzLmhpZ2g8PDMyLVMsdGhpcy5oaWdoPj5TLHRoaXMudW5zaWduZWQpOnUodGhpcy5oaWdoPj5TLTMyLHRoaXMuaGlnaD49MD8wOi0xLHRoaXMudW5zaWduZWQpfSwkLnNocj0kLnNoaWZ0UmlnaHQsJC5zaGlmdFJpZ2h0VW5zaWduZWQ9ZnVuY3Rpb24oUyl7aWYocihTKSYmKFM9Uy50b0ludCgpKSxTJj02MyxTPT09MClyZXR1cm4gdGhpczt2YXIgTT10aGlzLmhpZ2g7aWYoUzwzMil7dmFyIEI9dGhpcy5sb3c7cmV0dXJuIHUoQj4+PlN8TTw8MzItUyxNPj4+Uyx0aGlzLnVuc2lnbmVkKX1lbHNlIHJldHVybiBTPT09MzI/dShNLDAsdGhpcy51bnNpZ25lZCk6dShNPj4+Uy0zMiwwLHRoaXMudW5zaWduZWQpfSwkLnNocnU9JC5zaGlmdFJpZ2h0VW5zaWduZWQsJC5zaHJfdT0kLnNoaWZ0UmlnaHRVbnNpZ25lZCwkLnRvU2lnbmVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5zaWduZWQ/dSh0aGlzLmxvdyx0aGlzLmhpZ2gsITEpOnRoaXN9LCQudG9VbnNpZ25lZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuc2lnbmVkP3RoaXM6dSh0aGlzLmxvdyx0aGlzLmhpZ2gsITApfSwkLnRvQnl0ZXM9ZnVuY3Rpb24oUyl7cmV0dXJuIFM/dGhpcy50b0J5dGVzTEUoKTp0aGlzLnRvQnl0ZXNCRSgpfSwkLnRvQnl0ZXNMRT1mdW5jdGlvbigpe3ZhciBTPXRoaXMuaGlnaCxNPXRoaXMubG93O3JldHVybltNJjI1NSxNPj4+OCYyNTUsTT4+PjE2JjI1NSxNPj4+MjQsUyYyNTUsUz4+PjgmMjU1LFM+Pj4xNiYyNTUsUz4+PjI0XX0sJC50b0J5dGVzQkU9ZnVuY3Rpb24oKXt2YXIgUz10aGlzLmhpZ2gsTT10aGlzLmxvdztyZXR1cm5bUz4+PjI0LFM+Pj4xNiYyNTUsUz4+PjgmMjU1LFMmMjU1LE0+Pj4yNCxNPj4+MTYmMjU1LE0+Pj44JjI1NSxNJjI1NV19LGEuZnJvbUJ5dGVzPWZ1bmN0aW9uKFMsTSxCKXtyZXR1cm4gQj9hLmZyb21CeXRlc0xFKFMsTSk6YS5mcm9tQnl0ZXNCRShTLE0pfSxhLmZyb21CeXRlc0xFPWZ1bmN0aW9uKFMsTSl7cmV0dXJuIG5ldyBhKFNbMF18U1sxXTw8OHxTWzJdPDwxNnxTWzNdPDwyNCxTWzRdfFNbNV08PDh8U1s2XTw8MTZ8U1s3XTw8MjQsTSl9LGEuZnJvbUJ5dGVzQkU9ZnVuY3Rpb24oUyxNKXtyZXR1cm4gbmV3IGEoU1s0XTw8MjR8U1s1XTw8MTZ8U1s2XTw8OHxTWzddLFNbMF08PDI0fFNbMV08PDE2fFNbMl08PDh8U1szXSxNKX19KSxfUj1WdCgoKT0+e30pLEFSPVZ0KCgpPT57fSksRlI9VnQoKGUsdCk9PnsoZnVuY3Rpb24obixhLHIpe2Z1bmN0aW9uIHModSl7dmFyIHA9dGhpcyxkPWwoKTtwLm5leHQ9ZnVuY3Rpb24oKXt2YXIgYz0yMDkxNjM5KnAuczArcC5jKjIzMjgzMDY0MzY1Mzg2OTYzZS0yNjtyZXR1cm4gcC5zMD1wLnMxLHAuczE9cC5zMixwLnMyPWMtKHAuYz1jfDApfSxwLmM9MSxwLnMwPWQoXCIgXCIpLHAuczE9ZChcIiBcIikscC5zMj1kKFwiIFwiKSxwLnMwLT1kKHUpLHAuczA8MCYmKHAuczArPTEpLHAuczEtPWQodSkscC5zMTwwJiYocC5zMSs9MSkscC5zMi09ZCh1KSxwLnMyPDAmJihwLnMyKz0xKSxkPW51bGx9ZnVuY3Rpb24gaSh1LHApe3JldHVybiBwLmM9dS5jLHAuczA9dS5zMCxwLnMxPXUuczEscC5zMj11LnMyLHB9ZnVuY3Rpb24gbyh1LHApe3ZhciBkPW5ldyBzKHUpLGM9cCYmcC5zdGF0ZSxoPWQubmV4dDtyZXR1cm4gaC5pbnQzMj1mdW5jdGlvbigpe3JldHVybiBkLm5leHQoKSo0Mjk0OTY3Mjk2fDB9LGguZG91YmxlPWZ1bmN0aW9uKCl7cmV0dXJuIGgoKSsoaCgpKjIwOTcxNTJ8MCkqMTExMDIyMzAyNDYyNTE1NjVlLTMyfSxoLnF1aWNrPWgsYyYmKHR5cGVvZiBjPT1cIm9iamVjdFwiJiZpKGMsZCksaC5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBpKGQse30pfSksaH1mdW5jdGlvbiBsKCl7dmFyIHU9NDAyMjg3MTE5NyxwPWZ1bmN0aW9uKGQpe2Q9U3RyaW5nKGQpO2Zvcih2YXIgYz0wO2M8ZC5sZW5ndGg7YysrKXt1Kz1kLmNoYXJDb2RlQXQoYyk7dmFyIGg9LjAyNTE5NjAzMjgyNDE2OTM4KnU7dT1oPj4+MCxoLT11LGgqPXUsdT1oPj4+MCxoLT11LHUrPWgqNDI5NDk2NzI5Nn1yZXR1cm4odT4+PjApKjIzMjgzMDY0MzY1Mzg2OTYzZS0yNn07cmV0dXJuIHB9YSYmYS5leHBvcnRzP2EuZXhwb3J0cz1vOnImJnIuYW1kP3IoZnVuY3Rpb24oKXtyZXR1cm4gb30pOnRoaXMuYWxlYT1vfSkoZSx0eXBlb2YgdD09XCJvYmplY3RcIiYmdCx0eXBlb2YgZGVmaW5lPT1cImZ1bmN0aW9uXCImJmRlZmluZSl9KSwkUj1WdCgoZSx0KT0+eyhmdW5jdGlvbihuLGEscil7ZnVuY3Rpb24gcyhsKXt2YXIgdT10aGlzLHA9XCJcIjt1Lng9MCx1Lnk9MCx1Lno9MCx1Lnc9MCx1Lm5leHQ9ZnVuY3Rpb24oKXt2YXIgYz11LnhedS54PDwxMTtyZXR1cm4gdS54PXUueSx1Lnk9dS56LHUuej11LncsdS53Xj11Lnc+Pj4xOV5jXmM+Pj44fSxsPT09KGx8MCk/dS54PWw6cCs9bDtmb3IodmFyIGQ9MDtkPHAubGVuZ3RoKzY0O2QrKyl1LnhePXAuY2hhckNvZGVBdChkKXwwLHUubmV4dCgpfWZ1bmN0aW9uIGkobCx1KXtyZXR1cm4gdS54PWwueCx1Lnk9bC55LHUuej1sLnosdS53PWwudyx1fWZ1bmN0aW9uIG8obCx1KXt2YXIgcD1uZXcgcyhsKSxkPXUmJnUuc3RhdGUsYz1mdW5jdGlvbigpe3JldHVybihwLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBjLmRvdWJsZT1mdW5jdGlvbigpe2RvIHZhciBoPXAubmV4dCgpPj4+MTEsbT0ocC5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2LGY9KGgrbSkvKDE8PDIxKTt3aGlsZShmPT09MCk7cmV0dXJuIGZ9LGMuaW50MzI9cC5uZXh0LGMucXVpY2s9YyxkJiYodHlwZW9mIGQ9PVwib2JqZWN0XCImJmkoZCxwKSxjLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIGkocCx7fSl9KSxjfWEmJmEuZXhwb3J0cz9hLmV4cG9ydHM9bzpyJiZyLmFtZD9yKGZ1bmN0aW9uKCl7cmV0dXJuIG99KTp0aGlzLnhvcjEyOD1vfSkoZSx0eXBlb2YgdD09XCJvYmplY3RcIiYmdCx0eXBlb2YgZGVmaW5lPT1cImZ1bmN0aW9uXCImJmRlZmluZSl9KSxEUj1WdCgoZSx0KT0+eyhmdW5jdGlvbihuLGEscil7ZnVuY3Rpb24gcyhsKXt2YXIgdT10aGlzLHA9XCJcIjt1Lm5leHQ9ZnVuY3Rpb24oKXt2YXIgYz11LnhedS54Pj4+MjtyZXR1cm4gdS54PXUueSx1Lnk9dS56LHUuej11LncsdS53PXUudiwodS5kPXUuZCszNjI0Mzd8MCkrKHUudj11LnZedS52PDw0XihjXmM8PDEpKXwwfSx1Lng9MCx1Lnk9MCx1Lno9MCx1Lnc9MCx1LnY9MCxsPT09KGx8MCk/dS54PWw6cCs9bDtmb3IodmFyIGQ9MDtkPHAubGVuZ3RoKzY0O2QrKyl1LnhePXAuY2hhckNvZGVBdChkKXwwLGQ9PXAubGVuZ3RoJiYodS5kPXUueDw8MTBedS54Pj4+NCksdS5uZXh0KCl9ZnVuY3Rpb24gaShsLHUpe3JldHVybiB1Lng9bC54LHUueT1sLnksdS56PWwueix1Lnc9bC53LHUudj1sLnYsdS5kPWwuZCx1fWZ1bmN0aW9uIG8obCx1KXt2YXIgcD1uZXcgcyhsKSxkPXUmJnUuc3RhdGUsYz1mdW5jdGlvbigpe3JldHVybihwLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBjLmRvdWJsZT1mdW5jdGlvbigpe2RvIHZhciBoPXAubmV4dCgpPj4+MTEsbT0ocC5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2LGY9KGgrbSkvKDE8PDIxKTt3aGlsZShmPT09MCk7cmV0dXJuIGZ9LGMuaW50MzI9cC5uZXh0LGMucXVpY2s9YyxkJiYodHlwZW9mIGQ9PVwib2JqZWN0XCImJmkoZCxwKSxjLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIGkocCx7fSl9KSxjfWEmJmEuZXhwb3J0cz9hLmV4cG9ydHM9bzpyJiZyLmFtZD9yKGZ1bmN0aW9uKCl7cmV0dXJuIG99KTp0aGlzLnhvcndvdz1vfSkoZSx0eXBlb2YgdD09XCJvYmplY3RcIiYmdCx0eXBlb2YgZGVmaW5lPT1cImZ1bmN0aW9uXCImJmRlZmluZSl9KSxSUj1WdCgoZSx0KT0+eyhmdW5jdGlvbihuLGEscil7ZnVuY3Rpb24gcyhsKXt2YXIgdT10aGlzO3UubmV4dD1mdW5jdGlvbigpe3ZhciBkPXUueCxjPXUuaSxoLG0sZjtyZXR1cm4gaD1kW2NdLGhePWg+Pj43LG09aF5oPDwyNCxoPWRbYysxJjddLG1ePWheaD4+PjEwLGg9ZFtjKzMmN10sbV49aF5oPj4+MyxoPWRbYys0JjddLG1ePWheaDw8NyxoPWRbYys3JjddLGg9aF5oPDwxMyxtXj1oXmg8PDksZFtjXT1tLHUuaT1jKzEmNyxtfTtmdW5jdGlvbiBwKGQsYyl7dmFyIGgsbSxmPVtdO2lmKGM9PT0oY3wwKSltPWZbMF09YztlbHNlIGZvcihjPVwiXCIrYyxoPTA7aDxjLmxlbmd0aDsrK2gpZltoJjddPWZbaCY3XTw8MTVeYy5jaGFyQ29kZUF0KGgpK2ZbaCsxJjddPDwxMztmb3IoO2YubGVuZ3RoPDg7KWYucHVzaCgwKTtmb3IoaD0wO2g8OCYmZltoXT09PTA7KytoKTtmb3IoaD09OD9tPWZbN109LTE6bT1mW2hdLGQueD1mLGQuaT0wLGg9MjU2O2g+MDstLWgpZC5uZXh0KCl9cCh1LGwpfWZ1bmN0aW9uIGkobCx1KXtyZXR1cm4gdS54PWwueC5zbGljZSgpLHUuaT1sLmksdX1mdW5jdGlvbiBvKGwsdSl7bD09bnVsbCYmKGw9K25ldyBEYXRlKTt2YXIgcD1uZXcgcyhsKSxkPXUmJnUuc3RhdGUsYz1mdW5jdGlvbigpe3JldHVybihwLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBjLmRvdWJsZT1mdW5jdGlvbigpe2RvIHZhciBoPXAubmV4dCgpPj4+MTEsbT0ocC5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2LGY9KGgrbSkvKDE8PDIxKTt3aGlsZShmPT09MCk7cmV0dXJuIGZ9LGMuaW50MzI9cC5uZXh0LGMucXVpY2s9YyxkJiYoZC54JiZpKGQscCksYy5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBpKHAse30pfSksY31hJiZhLmV4cG9ydHM/YS5leHBvcnRzPW86ciYmci5hbWQ/cihmdW5jdGlvbigpe3JldHVybiBvfSk6dGhpcy54b3JzaGlmdDc9b30pKGUsdHlwZW9mIHQ9PVwib2JqZWN0XCImJnQsdHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZkZWZpbmUpfSksTVI9VnQoKGUsdCk9PnsoZnVuY3Rpb24obixhLHIpe2Z1bmN0aW9uIHMobCl7dmFyIHU9dGhpczt1Lm5leHQ9ZnVuY3Rpb24oKXt2YXIgZD11LncsYz11LlgsaD11LmksbSxmO3JldHVybiB1Lnc9ZD1kKzE2NDA1MzE1Mjd8MCxmPWNbaCszNCYxMjddLG09Y1toPWgrMSYxMjddLGZePWY8PDEzLG1ePW08PDE3LGZePWY+Pj4xNSxtXj1tPj4+MTIsZj1jW2hdPWZebSx1Lmk9aCxmKyhkXmQ+Pj4xNil8MH07ZnVuY3Rpb24gcChkLGMpe3ZhciBoLG0sZixnLGIseT1bXSx4PTEyODtmb3IoYz09PShjfDApPyhtPWMsYz1udWxsKTooYz1jK1wiXFwwXCIsbT0wLHg9TWF0aC5tYXgoeCxjLmxlbmd0aCkpLGY9MCxnPS0zMjtnPHg7KytnKWMmJihtXj1jLmNoYXJDb2RlQXQoKGcrMzIpJWMubGVuZ3RoKSksZz09PTAmJihiPW0pLG1ePW08PDEwLG1ePW0+Pj4xNSxtXj1tPDw0LG1ePW0+Pj4xMyxnPj0wJiYoYj1iKzE2NDA1MzE1Mjd8MCxoPXlbZyYxMjddXj1tK2IsZj1oPT0wP2YrMTowKTtmb3IoZj49MTI4JiYoeVsoYyYmYy5sZW5ndGh8fDApJjEyN109LTEpLGY9MTI3LGc9NCoxMjg7Zz4wOy0tZyltPXlbZiszNCYxMjddLGg9eVtmPWYrMSYxMjddLG1ePW08PDEzLGhePWg8PDE3LG1ePW0+Pj4xNSxoXj1oPj4+MTIseVtmXT1tXmg7ZC53PWIsZC5YPXksZC5pPWZ9cCh1LGwpfWZ1bmN0aW9uIGkobCx1KXtyZXR1cm4gdS5pPWwuaSx1Lnc9bC53LHUuWD1sLlguc2xpY2UoKSx1fWZ1bmN0aW9uIG8obCx1KXtsPT1udWxsJiYobD0rbmV3IERhdGUpO3ZhciBwPW5ldyBzKGwpLGQ9dSYmdS5zdGF0ZSxjPWZ1bmN0aW9uKCl7cmV0dXJuKHAubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIGMuZG91YmxlPWZ1bmN0aW9uKCl7ZG8gdmFyIGg9cC5uZXh0KCk+Pj4xMSxtPShwLm5leHQoKT4+PjApLzQyOTQ5NjcyOTYsZj0oaCttKS8oMTw8MjEpO3doaWxlKGY9PT0wKTtyZXR1cm4gZn0sYy5pbnQzMj1wLm5leHQsYy5xdWljaz1jLGQmJihkLlgmJmkoZCxwKSxjLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIGkocCx7fSl9KSxjfWEmJmEuZXhwb3J0cz9hLmV4cG9ydHM9bzpyJiZyLmFtZD9yKGZ1bmN0aW9uKCl7cmV0dXJuIG99KTp0aGlzLnhvcjQwOTY9b30pKGUsdHlwZW9mIHQ9PVwib2JqZWN0XCImJnQsdHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZkZWZpbmUpfSksT1I9VnQoKGUsdCk9PnsoZnVuY3Rpb24obixhLHIpe2Z1bmN0aW9uIHMobCl7dmFyIHU9dGhpcyxwPVwiXCI7dS5uZXh0PWZ1bmN0aW9uKCl7dmFyIGM9dS5iLGg9dS5jLG09dS5kLGY9dS5hO3JldHVybiBjPWM8PDI1XmM+Pj43XmgsaD1oLW18MCxtPW08PDI0Xm0+Pj44XmYsZj1mLWN8MCx1LmI9Yz1jPDwyMF5jPj4+MTJeaCx1LmM9aD1oLW18MCx1LmQ9bTw8MTZeaD4+PjE2XmYsdS5hPWYtY3wwfSx1LmE9MCx1LmI9MCx1LmM9LTE2NDA1MzE1MjcsdS5kPTEzNjcxMzA1NTEsbD09PU1hdGguZmxvb3IobCk/KHUuYT1sLzQyOTQ5NjcyOTZ8MCx1LmI9bHwwKTpwKz1sO2Zvcih2YXIgZD0wO2Q8cC5sZW5ndGgrMjA7ZCsrKXUuYl49cC5jaGFyQ29kZUF0KGQpfDAsdS5uZXh0KCl9ZnVuY3Rpb24gaShsLHUpe3JldHVybiB1LmE9bC5hLHUuYj1sLmIsdS5jPWwuYyx1LmQ9bC5kLHV9ZnVuY3Rpb24gbyhsLHUpe3ZhciBwPW5ldyBzKGwpLGQ9dSYmdS5zdGF0ZSxjPWZ1bmN0aW9uKCl7cmV0dXJuKHAubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIGMuZG91YmxlPWZ1bmN0aW9uKCl7ZG8gdmFyIGg9cC5uZXh0KCk+Pj4xMSxtPShwLm5leHQoKT4+PjApLzQyOTQ5NjcyOTYsZj0oaCttKS8oMTw8MjEpO3doaWxlKGY9PT0wKTtyZXR1cm4gZn0sYy5pbnQzMj1wLm5leHQsYy5xdWljaz1jLGQmJih0eXBlb2YgZD09XCJvYmplY3RcIiYmaShkLHApLGMuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gaShwLHt9KX0pLGN9YSYmYS5leHBvcnRzP2EuZXhwb3J0cz1vOnImJnIuYW1kP3IoZnVuY3Rpb24oKXtyZXR1cm4gb30pOnRoaXMudHljaGVpPW99KShlLHR5cGVvZiB0PT1cIm9iamVjdFwiJiZ0LHR5cGVvZiBkZWZpbmU9PVwiZnVuY3Rpb25cIiYmZGVmaW5lKX0pLFBSPVZ0KCgpPT57fSksTFI9VnQoKGUsdCk9PnsoZnVuY3Rpb24obixhLHIpe3ZhciBzPTI1NixpPTYsbz01MixsPVwicmFuZG9tXCIsdT1yLnBvdyhzLGkpLHA9ci5wb3coMixvKSxkPXAqMixjPXMtMSxoO2Z1bmN0aW9uIG0oSSxOLEMpe3ZhciBfPVtdO049Tj09ITA/e2VudHJvcHk6ITB9Ok58fHt9O3ZhciBGPXkoYihOLmVudHJvcHk/W0ksdihhKV06ST09bnVsbD94KCk6SSwzKSxfKSxEPW5ldyBmKF8pLCQ9ZnVuY3Rpb24oKXtmb3IodmFyIFM9RC5nKGkpLE09dSxCPTA7UzxwOylTPShTK0IpKnMsTSo9cyxCPUQuZygxKTtmb3IoO1M+PWQ7KVMvPTIsTS89MixCPj4+PTE7cmV0dXJuKFMrQikvTX07cmV0dXJuICQuaW50MzI9ZnVuY3Rpb24oKXtyZXR1cm4gRC5nKDQpfDB9LCQucXVpY2s9ZnVuY3Rpb24oKXtyZXR1cm4gRC5nKDQpLzQyOTQ5NjcyOTZ9LCQuZG91YmxlPSQseSh2KEQuUyksYSksKE4ucGFzc3x8Q3x8ZnVuY3Rpb24oUyxNLEIsVSl7cmV0dXJuIFUmJihVLlMmJmcoVSxEKSxTLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIGcoRCx7fSl9KSxCPyhyW2xdPVMsTSk6U30pKCQsRixcImdsb2JhbFwiaW4gTj9OLmdsb2JhbDp0aGlzPT1yLE4uc3RhdGUpfWZ1bmN0aW9uIGYoSSl7dmFyIE4sQz1JLmxlbmd0aCxfPXRoaXMsRj0wLEQ9Xy5pPV8uaj0wLCQ9Xy5TPVtdO2ZvcihDfHwoST1bQysrXSk7RjxzOykkW0ZdPUYrKztmb3IoRj0wO0Y8cztGKyspJFtGXT0kW0Q9YyZEK0lbRiVDXSsoTj0kW0ZdKV0sJFtEXT1OOyhfLmc9ZnVuY3Rpb24oUyl7Zm9yKHZhciBNLEI9MCxVPV8uaSxIPV8uaixxPV8uUztTLS07KU09cVtVPWMmVSsxXSxCPUIqcytxW2MmKHFbVV09cVtIPWMmSCtNXSkrKHFbSF09TSldO3JldHVybiBfLmk9VSxfLmo9SCxCfSkocyl9ZnVuY3Rpb24gZyhJLE4pe3JldHVybiBOLmk9SS5pLE4uaj1JLmosTi5TPUkuUy5zbGljZSgpLE59ZnVuY3Rpb24gYihJLE4pe3ZhciBDPVtdLF89dHlwZW9mIEksRjtpZihOJiZfPT1cIm9iamVjdFwiKWZvcihGIGluIEkpdHJ5e0MucHVzaChiKElbRl0sTi0xKSl9Y2F0Y2goRCl7fXJldHVybiBDLmxlbmd0aD9DOl89PVwic3RyaW5nXCI/STpJK1wiXFwwXCJ9ZnVuY3Rpb24geShJLE4pe2Zvcih2YXIgQz1JK1wiXCIsXyxGPTA7RjxDLmxlbmd0aDspTltjJkZdPWMmKF9ePU5bYyZGXSoxOSkrQy5jaGFyQ29kZUF0KEYrKyk7cmV0dXJuIHYoTil9ZnVuY3Rpb24geCgpe3RyeXt2YXIgSTtyZXR1cm4gaCYmKEk9aC5yYW5kb21CeXRlcyk/ST1JKHMpOihJPW5ldyBVaW50OEFycmF5KHMpLChuLmNyeXB0b3x8bi5tc0NyeXB0bykuZ2V0UmFuZG9tVmFsdWVzKEkpKSx2KEkpfWNhdGNoKF8pe3ZhciBOPW4ubmF2aWdhdG9yLEM9TiYmTi5wbHVnaW5zO3JldHVyblsrbmV3IERhdGUsbixDLG4uc2NyZWVuLHYoYSldfX1mdW5jdGlvbiB2KEkpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KDAsSSl9aWYoeShyLnJhbmRvbSgpLGEpLHR5cGVvZiB0PT1cIm9iamVjdFwiJiZ0LmV4cG9ydHMpe3QuZXhwb3J0cz1tO3RyeXtoPVBSKCl9Y2F0Y2goSSl7fX1lbHNlIHR5cGVvZiBkZWZpbmU9PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZD9kZWZpbmUoZnVuY3Rpb24oKXtyZXR1cm4gbX0pOnJbXCJzZWVkXCIrbF09bX0pKHR5cGVvZiBzZWxmIT1cInVuZGVmaW5lZFwiP3NlbGY6ZSxbXSxNYXRoKX0pLGJtPVZ0KChlLHQpPT57dmFyIG49RlIoKSxhPSRSKCkscj1EUigpLHM9UlIoKSxpPU1SKCksbz1PUigpLGw9TFIoKTtsLmFsZWE9bixsLnhvcjEyOD1hLGwueG9yd293PXIsbC54b3JzaGlmdDc9cyxsLnhvcjQwOTY9aSxsLnR5Y2hlaT1vLHQuZXhwb3J0cz1sfSksRlM9VnQoKCk9Pnt9KSxJdj1WdCgoKT0+e30pLCRTPVZ0KCgpPT57fSkselI9VnQoKCk9Pnt9KSxXUj1WdCgoKT0+e30pLEJSPVZ0KCgpPT57fSksVlI9VnQoKGUsdCk9Pnt2YXIgbj0oKCk9Pnt2YXIgYT10eXBlb2YgZG9jdW1lbnQhPVwidW5kZWZpbmVkXCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwO3JldHVybiB0eXBlb2YgX19maWxlbmFtZSE9XCJ1bmRlZmluZWRcIiYmKGE9YXx8X19maWxlbmFtZSksZnVuY3Rpb24ocil7cj1yfHx7fTtmdW5jdGlvbiBzKCl7cmV0dXJuIHVlLmJ1ZmZlciE9UmUmJnV0KHVlLmJ1ZmZlciksZ3R9ZnVuY3Rpb24gaSgpe3JldHVybiB1ZS5idWZmZXIhPVJlJiZ1dCh1ZS5idWZmZXIpLEdufWZ1bmN0aW9uIG8oKXtyZXR1cm4gdWUuYnVmZmVyIT1SZSYmdXQodWUuYnVmZmVyKSxPdH1mdW5jdGlvbiBsKCl7cmV0dXJuIHVlLmJ1ZmZlciE9UmUmJnV0KHVlLmJ1ZmZlciksdW59ZnVuY3Rpb24gdSgpe3JldHVybiB1ZS5idWZmZXIhPVJlJiZ1dCh1ZS5idWZmZXIpLEZufWZ1bmN0aW9uIHAoKXtyZXR1cm4gdWUuYnVmZmVyIT1SZSYmdXQodWUuYnVmZmVyKSxvYX1mdW5jdGlvbiBkKCl7cmV0dXJuIHVlLmJ1ZmZlciE9UmUmJnV0KHVlLmJ1ZmZlciksJG59dmFyIGM9dHlwZW9mIHIhPVwidW5kZWZpbmVkXCI/cjp7fSxoLG07Yy5yZWFkeT1uZXcgUHJvbWlzZShmdW5jdGlvbihSLGope2g9UixtPWp9KTt2YXIgZjt0eXBlb2YgcHJvY2VzcyE9XCJ1bmRlZmluZWRcIiYmcHJvY2Vzcy5saXN0ZW5lcnMmJihmPXt1bmNhdWdodEV4Y2VwdGlvbjpwcm9jZXNzLmxpc3RlbmVycyhcInVuY2F1Z2h0RXhjZXB0aW9uXCIpLHVuaGFuZGxlZFJlamVjdGlvbjpwcm9jZXNzLmxpc3RlbmVycyhcInVuaGFuZGxlZFJlamVjdGlvblwiKX0pO3ZhciBnPU9iamVjdC5hc3NpZ24oe30sYyksYj1bXSx5PVwiLi90aGlzLnByb2dyYW1cIix4PShSLGopPT57dGhyb3cgan0sdj10eXBlb2Ygd2luZG93PT1cIm9iamVjdFwiLEk9dHlwZW9mIGltcG9ydFNjcmlwdHM9PVwiZnVuY3Rpb25cIixOPXR5cGVvZiBwcm9jZXNzPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZT09XCJzdHJpbmdcIixDPWMuRU5WSVJPTk1FTlRfSVNfUFRIUkVBRHx8ITEsXz1cIlwiO2Z1bmN0aW9uIEYoUil7cmV0dXJuIGMubG9jYXRlRmlsZT9jLmxvY2F0ZUZpbGUoUixfKTpfK1J9dmFyIEQsJCxTLE07ZnVuY3Rpb24gQihSKXtSIGluc3RhbmNlb2YgR3N8fEooXCJleGl0aW5nIGR1ZSB0byBleGNlcHRpb246IFwiK1IpfWlmKE4pe3ZhciBVPUl2KCksSD0kUygpO0k/Xz1ILmRpcm5hbWUoXykrXCIvXCI6Xz1fX2Rpcm5hbWUrXCIvXCIsRD0oaixsZSk9PihqPWdsKGopP25ldyBVUkwoaik6SC5ub3JtYWxpemUoaiksVS5yZWFkRmlsZVN5bmMoaixsZT92b2lkIDA6XCJ1dGY4XCIpKSxTPWo9Pnt2YXIgbGU9RChqLCEwKTtyZXR1cm4gbGUuYnVmZmVyfHwobGU9bmV3IFVpbnQ4QXJyYXkobGUpKSxsZX0sJD0oaixsZSxOZSk9PntqPWdsKGopP25ldyBVUkwoaik6SC5ub3JtYWxpemUoaiksVS5yZWFkRmlsZShqLGZ1bmN0aW9uKE1lLEZlKXtNZT9OZShNZSk6bGUoRmUuYnVmZmVyKX0pfSxwcm9jZXNzLmFyZ3YubGVuZ3RoPjEmJih5PXByb2Nlc3MuYXJndlsxXS5yZXBsYWNlKC9cXFxcL2csXCIvXCIpKSxiPXByb2Nlc3MuYXJndi5zbGljZSgyKSxwcm9jZXNzLm9uKFwidW5jYXVnaHRFeGNlcHRpb25cIixmdW5jdGlvbihqKXtpZighKGogaW5zdGFuY2VvZiBHcykpdGhyb3cgan0pLHByb2Nlc3Mub24oXCJ1bmhhbmRsZWRSZWplY3Rpb25cIixmdW5jdGlvbihqKXt0aHJvdyBqfSkseD0oaixsZSk9PntpZihJYSgpKXRocm93IHByb2Nlc3MuZXhpdENvZGU9aixsZTtCKGxlKSxwcm9jZXNzLmV4aXQoail9LGMuaW5zcGVjdD1mdW5jdGlvbigpe3JldHVyblwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIn07bGV0IFI7dHJ5e1I9elIoKX1jYXRjaChqKXt0aHJvdyBjb25zb2xlLmVycm9yKCdUaGUgXCJ3b3JrZXJfdGhyZWFkc1wiIG1vZHVsZSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgbm9kZS5qcyBidWlsZCAtIHBlcmhhcHMgYSBuZXdlciB2ZXJzaW9uIGlzIG5lZWRlZD8nKSxqfWdsb2JhbC5Xb3JrZXI9Ui5Xb3JrZXJ9ZWxzZSh2fHxJKSYmKEk/Xz1zZWxmLmxvY2F0aW9uLmhyZWY6dHlwZW9mIGRvY3VtZW50IT1cInVuZGVmaW5lZFwiJiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYoXz1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksdHlwZW9mIGEhPVwidW5kZWZpbmVkXCImJmEmJihfPWEpLF8uaW5kZXhPZihcImJsb2I6XCIpIT09MD9fPV8uc3Vic3RyKDAsXy5yZXBsYWNlKC9bPyNdLiovLFwiXCIpLmxhc3RJbmRleE9mKFwiL1wiKSsxKTpfPVwiXCIsTnx8KEQ9Uj0+e3ZhciBqPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gai5vcGVuKFwiR0VUXCIsUiwhMSksai5zZW5kKG51bGwpLGoucmVzcG9uc2VUZXh0fSxJJiYoUz1SPT57dmFyIGo9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBqLm9wZW4oXCJHRVRcIixSLCExKSxqLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsai5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KGoucmVzcG9uc2UpfSksJD0oUixqLGxlKT0+e3ZhciBOZT1uZXcgWE1MSHR0cFJlcXVlc3Q7TmUub3BlbihcIkdFVFwiLFIsITApLE5lLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsTmUub25sb2FkPSgpPT57aWYoTmUuc3RhdHVzPT0yMDB8fE5lLnN0YXR1cz09MCYmTmUucmVzcG9uc2Upe2ooTmUucmVzcG9uc2UpO3JldHVybn1sZSgpfSxOZS5vbmVycm9yPWxlLE5lLnNlbmQobnVsbCl9KSxNPVI9PmRvY3VtZW50LnRpdGxlPVIpO04mJnR5cGVvZiBwZXJmb3JtYW5jZT09XCJ1bmRlZmluZWRcIiYmKGdsb2JhbC5wZXJmb3JtYW5jZT1XUigpLnBlcmZvcm1hbmNlKTt2YXIgcT1jb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLEs9Y29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7TiYmKHE9Uj0+VS53cml0ZVN5bmMoMSxSK2BcbmApLEs9Uj0+VS53cml0ZVN5bmMoMixSK2BcbmApKTt2YXIgWj1jLnByaW50fHxxLEo9Yy5wcmludEVycnx8SztPYmplY3QuYXNzaWduKGMsZyksZz1udWxsLGMuYXJndW1lbnRzJiYoYj1jLmFyZ3VtZW50cyksYy50aGlzUHJvZ3JhbSYmKHk9Yy50aGlzUHJvZ3JhbSksYy5xdWl0JiYoeD1jLnF1aXQpO3ZhciBlZT00LGFlPUF0b21pY3MubG9hZCx0ZT1BdG9taWNzLnN0b3JlLHNlPUF0b21pY3MuY29tcGFyZUV4Y2hhbmdlLGllO2Mud2FzbUJpbmFyeSYmKGllPWMud2FzbUJpbmFyeSk7dmFyIHZlPWMubm9FeGl0UnVudGltZXx8ITA7dHlwZW9mIFdlYkFzc2VtYmx5IT1cIm9iamVjdFwiJiZVcyhcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyIHVlLHllLGtlPSExLFNlO2Z1bmN0aW9uIExlKFIsail7Unx8VXMoail9dmFyIFVlPXR5cGVvZiBUZXh0RGVjb2RlciE9XCJ1bmRlZmluZWRcIj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMDtmdW5jdGlvbiBtdChSLGosbGUpe2o+Pj49MDtmb3IodmFyIE5lPWorbGUsTWU9ajtSW01lXSYmIShNZT49TmUpOykrK01lO2lmKE1lLWo+MTYmJlIuYnVmZmVyJiZVZSlyZXR1cm4gVWUuZGVjb2RlKFIuYnVmZmVyIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXI/Ui5zbGljZShqLE1lKTpSLnN1YmFycmF5KGosTWUpKTtmb3IodmFyIEZlPVwiXCI7ajxNZTspe3ZhciBtZT1SW2orK107aWYoIShtZSYxMjgpKXtGZSs9U3RyaW5nLmZyb21DaGFyQ29kZShtZSk7Y29udGludWV9dmFyIHdlPVJbaisrXSY2MztpZigobWUmMjI0KT09MTkyKXtGZSs9U3RyaW5nLmZyb21DaGFyQ29kZSgobWUmMzEpPDw2fHdlKTtjb250aW51ZX12YXIgVHQ9UltqKytdJjYzO2lmKChtZSYyNDApPT0yMjQ/bWU9KG1lJjE1KTw8MTJ8d2U8PDZ8VHQ6bWU9KG1lJjcpPDwxOHx3ZTw8MTJ8VHQ8PDZ8UltqKytdJjYzLG1lPDY1NTM2KUZlKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG1lKTtlbHNle3ZhciB1YT1tZS02NTUzNjtGZSs9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5Nnx1YT4+MTAsNTYzMjB8dWEmMTAyMyl9fXJldHVybiBGZX1mdW5jdGlvbiBzdChSLGope3JldHVybiBSPj4+PTAsUj9tdChpKCksUixqKTpcIlwifWZ1bmN0aW9uIHR0KFIsaixsZSxOZSl7aWYobGU+Pj49MCwhKE5lPjApKXJldHVybiAwO2Zvcih2YXIgTWU9bGUsRmU9bGUrTmUtMSxtZT0wO21lPFIubGVuZ3RoOysrbWUpe3ZhciB3ZT1SLmNoYXJDb2RlQXQobWUpO2lmKHdlPj01NTI5NiYmd2U8PTU3MzQzKXt2YXIgVHQ9Ui5jaGFyQ29kZUF0KCsrbWUpO3dlPTY1NTM2Kygod2UmMTAyMyk8PDEwKXxUdCYxMDIzfWlmKHdlPD0xMjcpe2lmKGxlPj1GZSlicmVhaztqW2xlKys+Pj4wXT13ZX1lbHNlIGlmKHdlPD0yMDQ3KXtpZihsZSsxPj1GZSlicmVhaztqW2xlKys+Pj4wXT0xOTJ8d2U+PjYsaltsZSsrPj4+MF09MTI4fHdlJjYzfWVsc2UgaWYod2U8PTY1NTM1KXtpZihsZSsyPj1GZSlicmVhaztqW2xlKys+Pj4wXT0yMjR8d2U+PjEyLGpbbGUrKz4+PjBdPTEyOHx3ZT4+NiY2MyxqW2xlKys+Pj4wXT0xMjh8d2UmNjN9ZWxzZXtpZihsZSszPj1GZSlicmVhaztqW2xlKys+Pj4wXT0yNDB8d2U+PjE4LGpbbGUrKz4+PjBdPTEyOHx3ZT4+MTImNjMsaltsZSsrPj4+MF09MTI4fHdlPj42JjYzLGpbbGUrKz4+PjBdPTEyOHx3ZSY2M319cmV0dXJuIGpbbGU+Pj4wXT0wLGxlLU1lfWZ1bmN0aW9uIG50KFIsaixsZSl7cmV0dXJuIHR0KFIsaSgpLGosbGUpfXZhciBSZSxndCxHbixPdCxpYSx1bixGbixvYSwkbjtDJiYoUmU9Yy5idWZmZXIpO2Z1bmN0aW9uIHV0KFIpe1JlPVIsYy5IRUFQOD1ndD1uZXcgSW50OEFycmF5KFIpLGMuSEVBUDE2PU90PW5ldyBJbnQxNkFycmF5KFIpLGMuSEVBUDMyPXVuPW5ldyBJbnQzMkFycmF5KFIpLGMuSEVBUFU4PUduPW5ldyBVaW50OEFycmF5KFIpLGMuSEVBUFUxNj1pYT1uZXcgVWludDE2QXJyYXkoUiksYy5IRUFQVTMyPUZuPW5ldyBVaW50MzJBcnJheShSKSxjLkhFQVBGMzI9b2E9bmV3IEZsb2F0MzJBcnJheShSKSxjLkhFQVBGNjQ9JG49bmV3IEZsb2F0NjRBcnJheShSKX12YXIgRG49Yy5JTklUSUFMX01FTU9SWXx8MTY3NzcyMTY7aWYoQyl1ZT1jLndhc21NZW1vcnksUmU9Yy5idWZmZXI7ZWxzZSBpZihjLndhc21NZW1vcnkpdWU9Yy53YXNtTWVtb3J5O2Vsc2UgaWYodWU9bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDpEbi82NTUzNixtYXhpbXVtOjY1NTM2LHNoYXJlZDohMH0pLCEodWUuYnVmZmVyIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpKXRocm93IEooXCJyZXF1ZXN0ZWQgYSBzaGFyZWQgV2ViQXNzZW1ibHkuTWVtb3J5IGJ1dCB0aGUgcmV0dXJuZWQgYnVmZmVyIGlzIG5vdCBhIFNoYXJlZEFycmF5QnVmZmVyLCBpbmRpY2F0aW5nIHRoYXQgd2hpbGUgdGhlIGJyb3dzZXIgaGFzIFNoYXJlZEFycmF5QnVmZmVyIGl0IGRvZXMgbm90IGhhdmUgV2ViQXNzZW1ibHkgdGhyZWFkcyBzdXBwb3J0IC0geW91IG1heSBuZWVkIHRvIHNldCBhIGZsYWdcIiksTiYmSihcIihvbiBub2RlIHlvdSBtYXkgbmVlZDogLS1leHBlcmltZW50YWwtd2FzbS10aHJlYWRzIC0tZXhwZXJpbWVudGFsLXdhc20tYnVsay1tZW1vcnkgYW5kL29yIHJlY2VudCB2ZXJzaW9uKVwiKSxFcnJvcihcImJhZCBtZW1vcnlcIik7dWUmJihSZT11ZS5idWZmZXIpLERuPVJlLmJ5dGVMZW5ndGgsdXQoUmUpO3ZhciBIbix4cj1bXSxtbD1bXSxaYT1bXSxXcD0hMTtmdW5jdGlvbiBJYSgpe3JldHVybiB2ZX1mdW5jdGlvbiBVcigpe2lmKGMucHJlUnVuKWZvcih0eXBlb2YgYy5wcmVSdW49PVwiZnVuY3Rpb25cIiYmKGMucHJlUnVuPVtjLnByZVJ1bl0pO2MucHJlUnVuLmxlbmd0aDspU2coYy5wcmVSdW4uc2hpZnQoKSk7VnAoeHIpfWZ1bmN0aW9uIEp0KCl7V3A9ITAsIUMmJlZwKG1sKX1mdW5jdGlvbiBIZCgpe2lmKCFDKXtpZihjLnBvc3RSdW4pZm9yKHR5cGVvZiBjLnBvc3RSdW49PVwiZnVuY3Rpb25cIiYmKGMucG9zdFJ1bj1bYy5wb3N0UnVuXSk7Yy5wb3N0UnVuLmxlbmd0aDspUmsoYy5wb3N0UnVuLnNoaWZ0KCkpO1ZwKFphKX19ZnVuY3Rpb24gU2coUil7eHIudW5zaGlmdChSKX1mdW5jdGlvbiBOZyhSKXttbC51bnNoaWZ0KFIpfWZ1bmN0aW9uIFJrKFIpe1phLnVuc2hpZnQoUil9dmFyIEdyPTAsZmw9bnVsbCx2cj1udWxsO2Z1bmN0aW9uIFRnKFIpe0dyKyssYy5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZjLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoR3IpfWZ1bmN0aW9uIGpkKFIpe2lmKEdyLS0sYy5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZjLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoR3IpLEdyPT0wJiYoZmwhPT1udWxsJiYoY2xlYXJJbnRlcnZhbChmbCksZmw9bnVsbCksdnIpKXt2YXIgaj12cjt2cj1udWxsLGooKX19ZnVuY3Rpb24gVXMoUil7Yy5vbkFib3J0JiZjLm9uQWJvcnQoUiksUj1cIkFib3J0ZWQoXCIrUitcIilcIixKKFIpLGtlPSEwLFNlPTEsUis9XCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCI7dmFyIGo9bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcihSKTt0aHJvdyBtKGopLGp9dmFyIENnPVwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiO2Z1bmN0aW9uIHFkKFIpe3JldHVybiBSLnN0YXJ0c1dpdGgoQ2cpfWZ1bmN0aW9uIGdsKFIpe3JldHVybiBSLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpfXZhciBnbjtnbj1cInRmanMtYmFja2VuZC13YXNtLXRocmVhZGVkLXNpbWQud2FzbVwiLHFkKGduKXx8KGduPUYoZ24pKTtmdW5jdGlvbiBLZChSKXt0cnl7aWYoUj09Z24mJmllKXJldHVybiBuZXcgVWludDhBcnJheShpZSk7aWYoUylyZXR1cm4gUyhSKTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn1jYXRjaChqKXtVcyhqKX19ZnVuY3Rpb24gRWcoKXtpZighaWUmJih2fHxJKSl7aWYodHlwZW9mIGZldGNoPT1cImZ1bmN0aW9uXCImJiFnbChnbikpcmV0dXJuIGZldGNoKGduLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKGZ1bmN0aW9uKFIpe2lmKCFSLm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIitnbitcIidcIjtyZXR1cm4gUi5hcnJheUJ1ZmZlcigpfSkuY2F0Y2goZnVuY3Rpb24oKXtyZXR1cm4gS2QoZ24pfSk7aWYoJClyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oUixqKXskKGduLGZ1bmN0aW9uKGxlKXtSKG5ldyBVaW50OEFycmF5KGxlKSl9LGopfSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gS2QoZ24pfSl9ZnVuY3Rpb24gX2coKXt2YXIgUj17ZW52Om9oLHdhc2lfc25hcHNob3RfcHJldmlldzE6b2h9O2Z1bmN0aW9uIGoobWUsd2Upe3ZhciBUdD1tZS5leHBvcnRzO2lmKGMuYXNtPVR0LExnKGMuYXNtLl9lbXNjcmlwdGVuX3Rsc19pbml0KSxIbj1jLmFzbS5fX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlLE5nKGMuYXNtLl9fd2FzbV9jYWxsX2N0b3JzKSx5ZT13ZSwhQyl7dmFyIHVhPUFlLnVudXNlZFdvcmtlcnMubGVuZ3RoO0FlLnVudXNlZFdvcmtlcnMuZm9yRWFjaChmdW5jdGlvbihrcil7QWUubG9hZFdhc21Nb2R1bGVUb1dvcmtlcihrcixmdW5jdGlvbigpey0tdWF8fGpkKFwid2FzbS1pbnN0YW50aWF0ZVwiKX0pfSl9fUN8fFRnKFwid2FzbS1pbnN0YW50aWF0ZVwiKTtmdW5jdGlvbiBsZShtZSl7aihtZS5pbnN0YW5jZSxtZS5tb2R1bGUpfWZ1bmN0aW9uIE5lKG1lKXtyZXR1cm4gRWcoKS50aGVuKGZ1bmN0aW9uKHdlKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUod2UsUil9KS50aGVuKGZ1bmN0aW9uKHdlKXtyZXR1cm4gd2V9KS50aGVuKG1lLGZ1bmN0aW9uKHdlKXtKKFwiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogXCIrd2UpLFVzKHdlKX0pfWZ1bmN0aW9uIE1lKCl7cmV0dXJuIWllJiZ0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmc9PVwiZnVuY3Rpb25cIiYmIXFkKGduKSYmIWdsKGduKSYmIU4mJnR5cGVvZiBmZXRjaD09XCJmdW5jdGlvblwiP2ZldGNoKGduLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKGZ1bmN0aW9uKG1lKXt2YXIgd2U9V2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcobWUsUik7cmV0dXJuIHdlLnRoZW4obGUsZnVuY3Rpb24oVHQpe3JldHVybiBKKFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK1R0KSxKKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIiksTmUobGUpfSl9KTpOZShsZSl9aWYoYy5pbnN0YW50aWF0ZVdhc20pdHJ5e3ZhciBGZT1jLmluc3RhbnRpYXRlV2FzbShSLGopO3JldHVybiBGZX1jYXRjaChtZSl7SihcIk1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6IFwiK21lKSxtKG1lKX1yZXR1cm4gTWUoKS5jYXRjaChtKSx7fX12YXIgTWssT2ssWGQ9e307ZnVuY3Rpb24gR3MoUil7dGhpcy5uYW1lPVwiRXhpdFN0YXR1c1wiLHRoaXMubWVzc2FnZT1cIlByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoXCIrUitcIilcIix0aGlzLnN0YXR1cz1SfWZ1bmN0aW9uIEFnKFIpe3ZhciBqPUFlLnB0aHJlYWRzW1JdO2RlbGV0ZSBBZS5wdGhyZWFkc1tSXSxqLnRlcm1pbmF0ZSgpLGV4KFIpLEFlLnJ1bm5pbmdXb3JrZXJzLnNwbGljZShBZS5ydW5uaW5nV29ya2Vycy5pbmRleE9mKGopLDEpLGoucHRocmVhZF9wdHI9MH1mdW5jdGlvbiBGZyhSKXt2YXIgaj1BZS5wdGhyZWFkc1tSXTtqLnBvc3RNZXNzYWdlKHtjbWQ6XCJjYW5jZWxcIn0pfWZ1bmN0aW9uIEJwKFIpe3ZhciBqPUFlLnB0aHJlYWRzW1JdO0xlKGopLEFlLnJldHVybldvcmtlclRvUG9vbChqKX1mdW5jdGlvbiAkZyhSKXt2YXIgaj1BZS5nZXROZXdXb3JrZXIoKTtpZighailyZXR1cm4gNjtBZS5ydW5uaW5nV29ya2Vycy5wdXNoKGopLEFlLnB0aHJlYWRzW1IucHRocmVhZF9wdHJdPWosai5wdGhyZWFkX3B0cj1SLnB0aHJlYWRfcHRyO3ZhciBsZT17Y21kOlwicnVuXCIsc3RhcnRfcm91dGluZTpSLnN0YXJ0Um91dGluZSxhcmc6Ui5hcmcscHRocmVhZF9wdHI6Ui5wdGhyZWFkX3B0cn07cmV0dXJuIGoucnVuUHRocmVhZD0oKT0+e04mJmoucmVmKCksai5wb3N0TWVzc2FnZShsZSxSLnRyYW5zZmVyTGlzdCksZGVsZXRlIGoucnVuUHRocmVhZH0sai5sb2FkZWQmJmoucnVuUHRocmVhZCgpLDB9dmFyIFlkPXt2YXJhcmdzOnZvaWQgMCxnZXQ6ZnVuY3Rpb24oKXtZZC52YXJhcmdzKz00O3ZhciBSPWwoKVtZZC52YXJhcmdzLTQ+Pj4yXTtyZXR1cm4gUn0sZ2V0U3RyOmZ1bmN0aW9uKFIpe3ZhciBqPXN0KFIpO3JldHVybiBqfX07ZnVuY3Rpb24gWmQoUil7aWYoQylyZXR1cm4gSHIoMSwxLFIpO1NlPVIsSWEoKXx8KEFlLnRlcm1pbmF0ZUFsbFRocmVhZHMoKSxjLm9uRXhpdCYmYy5vbkV4aXQoUiksa2U9ITApLHgoUixuZXcgR3MoUikpfWZ1bmN0aW9uIERnKFIsail7aWYoU2U9UiwhaiYmQyl0aHJvdyBRZChSKSxcInVud2luZFwiO1pkKFIpfXZhciBKZD1EZztmdW5jdGlvbiBSZyhSKXtpZihSIGluc3RhbmNlb2YgR3N8fFI9PVwidW53aW5kXCIpcmV0dXJuIFNlO3goMSxSKX12YXIgQWU9e3VudXNlZFdvcmtlcnM6W10scnVubmluZ1dvcmtlcnM6W10sdGxzSW5pdEZ1bmN0aW9uczpbXSxwdGhyZWFkczp7fSxpbml0OmZ1bmN0aW9uKCl7Qz9BZS5pbml0V29ya2VyKCk6QWUuaW5pdE1haW5UaHJlYWQoKX0saW5pdE1haW5UaHJlYWQ6ZnVuY3Rpb24oKXtmb3IodmFyIFI9ODtSLS07KUFlLmFsbG9jYXRlVW51c2VkV29ya2VyKCl9LGluaXRXb3JrZXI6ZnVuY3Rpb24oKXt2ZT0hMX0sc2V0RXhpdFN0YXR1czpmdW5jdGlvbihSKXtTZT1SfSx0ZXJtaW5hdGVBbGxUaHJlYWRzOmZ1bmN0aW9uKCl7Zm9yKHZhciBSIG9mIE9iamVjdC52YWx1ZXMoQWUucHRocmVhZHMpKUFlLnJldHVybldvcmtlclRvUG9vbChSKTtmb3IodmFyIFIgb2YgQWUudW51c2VkV29ya2VycylSLnRlcm1pbmF0ZSgpO0FlLnVudXNlZFdvcmtlcnM9W119LHJldHVybldvcmtlclRvUG9vbDpmdW5jdGlvbihSKXt2YXIgaj1SLnB0aHJlYWRfcHRyO2RlbGV0ZSBBZS5wdGhyZWFkc1tqXSxBZS51bnVzZWRXb3JrZXJzLnB1c2goUiksQWUucnVubmluZ1dvcmtlcnMuc3BsaWNlKEFlLnJ1bm5pbmdXb3JrZXJzLmluZGV4T2YoUiksMSksUi5wdGhyZWFkX3B0cj0wLE4mJlIudW5yZWYoKSxleChqKX0scmVjZWl2ZU9iamVjdFRyYW5zZmVyOmZ1bmN0aW9uKFIpe30sdGhyZWFkSW5pdFRMUzpmdW5jdGlvbigpe0FlLnRsc0luaXRGdW5jdGlvbnMuZm9yRWFjaChSPT5SKCkpfSxsb2FkV2FzbU1vZHVsZVRvV29ya2VyOmZ1bmN0aW9uKFIsail7Ui5vbm1lc3NhZ2U9RmU9Pnt2YXIgbWU9RmUuZGF0YSx3ZT1tZS5jbWQ7aWYoUi5wdGhyZWFkX3B0ciYmKEFlLmN1cnJlbnRQcm94aWVkT3BlcmF0aW9uQ2FsbGVyVGhyZWFkPVIucHRocmVhZF9wdHIpLG1lLnRhcmdldFRocmVhZCYmbWUudGFyZ2V0VGhyZWFkIT1oaCgpKXt2YXIgVHQ9QWUucHRocmVhZHNbbWUudGFyZ2V0VGhyZWFkXTtUdD9UdC5wb3N0TWVzc2FnZShtZSxtZS50cmFuc2Zlckxpc3QpOkooJ0ludGVybmFsIGVycm9yISBXb3JrZXIgc2VudCBhIG1lc3NhZ2UgXCInK3dlKydcIiB0byB0YXJnZXQgcHRocmVhZCAnK21lLnRhcmdldFRocmVhZCtcIiwgYnV0IHRoYXQgdGhyZWFkIG5vIGxvbmdlciBleGlzdHMhXCIpLEFlLmN1cnJlbnRQcm94aWVkT3BlcmF0aW9uQ2FsbGVyVGhyZWFkPXZvaWQgMDtyZXR1cm59d2U9PT1cInByb2Nlc3NQcm94eWluZ1F1ZXVlXCI/VXAobWUucXVldWUpOndlPT09XCJzcGF3blRocmVhZFwiPyRnKG1lKTp3ZT09PVwiY2xlYW51cFRocmVhZFwiP0JwKG1lLnRocmVhZCk6d2U9PT1cImtpbGxUaHJlYWRcIj9BZyhtZS50aHJlYWQpOndlPT09XCJjYW5jZWxUaHJlYWRcIj9GZyhtZS50aHJlYWQpOndlPT09XCJsb2FkZWRcIj8oUi5sb2FkZWQ9ITAsTiYmUi51bnJlZigpLGomJmooUiksUi5ydW5QdGhyZWFkJiZSLnJ1blB0aHJlYWQoKSk6d2U9PT1cInByaW50XCI/WihcIlRocmVhZCBcIittZS50aHJlYWRJZCtcIjogXCIrbWUudGV4dCk6d2U9PT1cInByaW50RXJyXCI/SihcIlRocmVhZCBcIittZS50aHJlYWRJZCtcIjogXCIrbWUudGV4dCk6d2U9PT1cImFsZXJ0XCI/YWxlcnQoXCJUaHJlYWQgXCIrbWUudGhyZWFkSWQrXCI6IFwiK21lLnRleHQpOm1lLnRhcmdldD09PVwic2V0aW1tZWRpYXRlXCI/Ui5wb3N0TWVzc2FnZShtZSk6d2U9PT1cImNhbGxIYW5kbGVyXCI/Y1ttZS5oYW5kbGVyXSguLi5tZS5hcmdzKTp3ZSYmSihcIndvcmtlciBzZW50IGFuIHVua25vd24gY29tbWFuZCBcIit3ZSksQWUuY3VycmVudFByb3hpZWRPcGVyYXRpb25DYWxsZXJUaHJlYWQ9dm9pZCAwfSxSLm9uZXJyb3I9RmU9Pnt2YXIgbWU9XCJ3b3JrZXIgc2VudCBhbiBlcnJvciFcIjt0aHJvdyBKKG1lK1wiIFwiK0ZlLmZpbGVuYW1lK1wiOlwiK0ZlLmxpbmVubytcIjogXCIrRmUubWVzc2FnZSksRmV9LE4mJihSLm9uKFwibWVzc2FnZVwiLGZ1bmN0aW9uKEZlKXtSLm9ubWVzc2FnZSh7ZGF0YTpGZX0pfSksUi5vbihcImVycm9yXCIsZnVuY3Rpb24oRmUpe1Iub25lcnJvcihGZSl9KSxSLm9uKFwiZGV0YWNoZWRFeGl0XCIsZnVuY3Rpb24oKXt9KSk7dmFyIGxlPVtdLE5lPVtcIm9uRXhpdFwiLFwib25BYm9ydFwiLFwicHJpbnRcIixcInByaW50RXJyXCJdO2Zvcih2YXIgTWUgb2YgTmUpYy5oYXNPd25Qcm9wZXJ0eShNZSkmJmxlLnB1c2goTWUpO1IucG9zdE1lc3NhZ2Uoe2NtZDpcImxvYWRcIixoYW5kbGVyczpsZSx1cmxPckJsb2I6Yy5tYWluU2NyaXB0VXJsT3JCbG9ifHxhLHdhc21NZW1vcnk6dWUsd2FzbU1vZHVsZTp5ZX0pfSxhbGxvY2F0ZVVudXNlZFdvcmtlcjpmdW5jdGlvbigpe3ZhciBSLGo9RihcInRmanMtYmFja2VuZC13YXNtLXRocmVhZGVkLXNpbWQud29ya2VyLmpzXCIpO1I9bmV3IFdvcmtlcihqKSxBZS51bnVzZWRXb3JrZXJzLnB1c2goUil9LGdldE5ld1dvcmtlcjpmdW5jdGlvbigpe3JldHVybiBBZS51bnVzZWRXb3JrZXJzLmxlbmd0aD09MCYmKEFlLmFsbG9jYXRlVW51c2VkV29ya2VyKCksQWUubG9hZFdhc21Nb2R1bGVUb1dvcmtlcihBZS51bnVzZWRXb3JrZXJzWzBdKSksQWUudW51c2VkV29ya2Vycy5wb3AoKX19O2MuUFRocmVhZD1BZTtmdW5jdGlvbiBWcChSKXtmb3IoO1IubGVuZ3RoPjA7KVIuc2hpZnQoKShjKX1mdW5jdGlvbiBNZygpe3ZhciBSPWhoKCksaj1sKClbUis1Mj4+PjJdLGxlPWwoKVtSKzU2Pj4+Ml0sTmU9ai1sZTtWayhqLE5lKSxtaChqKX1jLmVzdGFibGlzaFN0YWNrU3BhY2U9TWc7ZnVuY3Rpb24gUWQoUil7aWYoQylyZXR1cm4gSHIoMiwwLFIpO3RyeXtKZChSKX1jYXRjaChqKXtSZyhqKX19dmFyIGJsPVtdO2Z1bmN0aW9uIE9nKFIpe3ZhciBqPWJsW1JdO3JldHVybiBqfHwoUj49YmwubGVuZ3RoJiYoYmwubGVuZ3RoPVIrMSksYmxbUl09aj1Ibi5nZXQoUikpLGp9ZnVuY3Rpb24gUGcoUixqKXt2YXIgbGU9T2coUikoaik7SWEoKT9BZS5zZXRFeGl0U3RhdHVzKGxlKTpCayhsZSl9Yy5pbnZva2VFbnRyeVBvaW50PVBnO2Z1bmN0aW9uIExnKFIpe0FlLnRsc0luaXRGdW5jdGlvbnMucHVzaChSKX1mdW5jdGlvbiB6ZyhSKXtMayhSLCFJLDEsIXYpLEFlLnRocmVhZEluaXRUTFMoKX1mdW5jdGlvbiBXZyhSKXtDP3Bvc3RNZXNzYWdlKHtjbWQ6XCJjbGVhbnVwVGhyZWFkXCIsdGhyZWFkOlJ9KTpCcChSKX1mdW5jdGlvbiBlaChSLGosbGUsTmUpe3JldHVybiBDP0hyKDMsMSxSLGosbGUsTmUpOnRoKFIsaixsZSxOZSl9ZnVuY3Rpb24gdGgoUixqLGxlLE5lKXtpZih0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXI9PVwidW5kZWZpbmVkXCIpcmV0dXJuIEooXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgU2hhcmVkQXJyYXlCdWZmZXIsIHB0aHJlYWRzIGFyZSBub3QgYXZhaWxhYmxlIVwiKSw2O3ZhciBNZT1bXSxGZT0wO2lmKEMmJihNZS5sZW5ndGg9PT0wfHxGZSkpcmV0dXJuIGVoKFIsaixsZSxOZSk7aWYoRmUpcmV0dXJuIEZlO3ZhciBtZT17c3RhcnRSb3V0aW5lOmxlLHB0aHJlYWRfcHRyOlIsYXJnOk5lLHRyYW5zZmVyTGlzdDpNZX07cmV0dXJuIEM/KG1lLmNtZD1cInNwYXduVGhyZWFkXCIscG9zdE1lc3NhZ2UobWUsTWUpLDApOiRnKG1lKX1mdW5jdGlvbiBCZygpe3JldHVybiA2NTUzNn12YXIgVmc9ITA7ZnVuY3Rpb24gVWcoKXtyZXR1cm4gVmd9ZnVuY3Rpb24gVXAoUil7QXRvbWljcy5zdG9yZShsKCksUj4+MiwxKSxoaCgpJiZXayhSKSxBdG9taWNzLmNvbXBhcmVFeGNoYW5nZShsKCksUj4+MiwxLDApfWMuZXhlY3V0ZU5vdGlmaWVkUHJveHlpbmdRdWV1ZT1VcDtmdW5jdGlvbiBHZyhSLGosbGUsTmUpe2lmKFI9PWopc2V0VGltZW91dCgoKT0+VXAoTmUpKTtlbHNlIGlmKEMpcG9zdE1lc3NhZ2Uoe3RhcmdldFRocmVhZDpSLGNtZDpcInByb2Nlc3NQcm94eWluZ1F1ZXVlXCIscXVldWU6TmV9KTtlbHNle3ZhciBNZT1BZS5wdGhyZWFkc1tSXTtpZighTWUpcmV0dXJuO01lLnBvc3RNZXNzYWdlKHtjbWQ6XCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiLHF1ZXVlOk5lfSl9cmV0dXJuIDF9ZnVuY3Rpb24gSGcoUixqLGxlKXtyZXR1cm4tMX1mdW5jdGlvbiBqZygpe1VzKFwiXCIpfWZ1bmN0aW9uIEhzKFIpe0hzLnNob3dufHwoSHMuc2hvd249e30pLEhzLnNob3duW1JdfHwoSHMuc2hvd25bUl09MSxOJiYoUj1cIndhcm5pbmc6IFwiK1IpLEooUikpfWZ1bmN0aW9uIHFnKCl7Tnx8SXx8SHMoXCJCbG9ja2luZyBvbiB0aGUgbWFpbiB0aHJlYWQgaXMgdmVyeSBkYW5nZXJvdXMsIHNlZSBodHRwczovL2Vtc2NyaXB0ZW4ub3JnL2RvY3MvcG9ydGluZy9wdGhyZWFkcy5odG1sI2Jsb2NraW5nLW9uLXRoZS1tYWluLWJyb3dzZXItdGhyZWFkXCIpfWZ1bmN0aW9uIEtnKCl7cmV0dXJuIERhdGUubm93KCl9ZnVuY3Rpb24gbmgoKXtyZXR1cm4gNDI5NDkwMTc2MH1mdW5jdGlvbiBYZygpe3JldHVybiBuaCgpfXZhciBHcDtOP0dwPSgpPT57dmFyIFI9cHJvY2Vzcy5ocnRpbWUoKTtyZXR1cm4gUlswXSoxZTMrUlsxXS8xZTZ9OkdwPSgpPT5wZXJmb3JtYW5jZS50aW1lT3JpZ2luK3BlcmZvcm1hbmNlLm5vdygpO2Z1bmN0aW9uIFlnKFIsaixsZSl7aSgpLmNvcHlXaXRoaW4oUj4+PjAsaj4+PjAsaitsZT4+PjApfWZ1bmN0aW9uIFpnKCl7cmV0dXJuIE4/QlIoKS5jcHVzKCkubGVuZ3RoOm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5fWZ1bmN0aW9uIEpnKFIpe3ZhciBqPXR4KCksbGU9UigpO3JldHVybiBtaChqKSxsZX1mdW5jdGlvbiBIcihSLGope3ZhciBsZT1hcmd1bWVudHMubGVuZ3RoLTIsTmU9YXJndW1lbnRzO3JldHVybiBKZygoKT0+e2Zvcih2YXIgTWU9bGUsRmU9ZmgoTWUqOCksbWU9RmU+PjMsd2U9MDt3ZTxsZTt3ZSsrKXt2YXIgVHQ9TmVbMit3ZV07ZCgpW21lK3dlPj4+MF09VHR9cmV0dXJuIHprKFIsTWUsRmUsail9KX12YXIgSHA9W107ZnVuY3Rpb24gUWcoUixqLGxlKXtIcC5sZW5ndGg9ajtmb3IodmFyIE5lPWxlPj4zLE1lPTA7TWU8ajtNZSsrKUhwW01lXT1kKClbTmUrTWU+Pj4wXTt2YXIgRmU9UjwwLG1lPUZlP1hkWy1SLTFdOmxiW1JdO3JldHVybiBtZS5hcHBseShudWxsLEhwKX1mdW5jdGlvbiBlYihSKXt0cnl7cmV0dXJuIHVlLmdyb3coUi1SZS5ieXRlTGVuZ3RoKzY1NTM1Pj4+MTYpLHV0KHVlLmJ1ZmZlciksMX1jYXRjaChqKXt9fWZ1bmN0aW9uIHRiKFIpe3ZhciBqPWkoKS5sZW5ndGg7aWYoUj1SPj4+MCxSPD1qKXJldHVybiExO3ZhciBsZT1uaCgpO2lmKFI+bGUpcmV0dXJuITE7bGV0IE5lPShUdCx1YSk9PlR0Kyh1YS1UdCV1YSkldWE7Zm9yKHZhciBNZT0xO01lPD00O01lKj0yKXt2YXIgRmU9aiooMSsuMi9NZSk7RmU9TWF0aC5taW4oRmUsUisxMDA2NjMyOTYpO3ZhciBtZT1NYXRoLm1pbihsZSxOZShNYXRoLm1heChSLEZlKSw2NTUzNikpLHdlPWViKG1lKTtpZih3ZSlyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiBuYigpe3Rocm93XCJ1bndpbmRcIn1mdW5jdGlvbiBhaChSKXtyZXR1cm4gQz9Icig0LDEsUik6NTJ9ZnVuY3Rpb24gcmgoUixqLGxlLE5lLE1lKXtyZXR1cm4gQz9Icig1LDEsUixqLGxlLE5lLE1lKTo3MH12YXIgYWI9W251bGwsW10sW11dO2Z1bmN0aW9uIHJiKFIsail7dmFyIGxlPWFiW1JdO2o9PT0wfHxqPT09MTA/KChSPT09MT9aOkopKG10KGxlLDApKSxsZS5sZW5ndGg9MCk6bGUucHVzaChqKX1mdW5jdGlvbiBzaChSLGosbGUsTmUpe2lmKEMpcmV0dXJuIEhyKDYsMSxSLGosbGUsTmUpO2Zvcih2YXIgTWU9MCxGZT0wO0ZlPGxlO0ZlKyspe3ZhciBtZT11KClbaj4+PjJdLHdlPXUoKVtqKzQ+Pj4yXTtqKz04O2Zvcih2YXIgVHQ9MDtUdDx3ZTtUdCsrKXJiKFIsaSgpW21lK1R0Pj4+MF0pO01lKz13ZX1yZXR1cm4gdSgpW05lPj4+Ml09TWUsMH1mdW5jdGlvbiBpaChSKXt2YXIgaj1jW1wiX1wiK1JdO3JldHVybiBqfWZ1bmN0aW9uIHNiKFIsail7cygpLnNldChSLGo+Pj4wKX1mdW5jdGlvbiBpYihSLGosbGUsTmUsTWUpe3ZhciBGZT17c3RyaW5nOnBhPT57dmFyIHdsPTA7aWYocGEhPW51bGwmJnBhIT09MCl7dmFyIEhrPShwYS5sZW5ndGg8PDIpKzE7d2w9ZmgoSGspLG50KHBhLHdsLEhrKX1yZXR1cm4gd2x9LGFycmF5OnBhPT57dmFyIHdsPWZoKHBhLmxlbmd0aCk7cmV0dXJuIHNiKHBhLHdsKSx3bH19O2Z1bmN0aW9uIG1lKHBhKXtyZXR1cm4gaj09PVwic3RyaW5nXCI/c3QocGEpOmo9PT1cImJvb2xlYW5cIj8hIXBhOnBhfXZhciB3ZT1paChSKSxUdD1bXSx1YT0wO2lmKE5lKWZvcih2YXIga3I9MDtrcjxOZS5sZW5ndGg7a3IrKyl7dmFyIEdrPUZlW2xlW2tyXV07R2s/KHVhPT09MCYmKHVhPXR4KCkpLFR0W2tyXT1HayhOZVtrcl0pKTpUdFtrcl09TmVba3JdfXZhciBueD13ZS5hcHBseShudWxsLFR0KTtmdW5jdGlvbiB4UihwYSl7cmV0dXJuIHVhIT09MCYmbWgodWEpLG1lKHBhKX1yZXR1cm4gbng9eFIobngpLG54fWZ1bmN0aW9uIG9iKFIsaixsZSxOZSl7bGU9bGV8fFtdO3ZhciBNZT1sZS5ldmVyeShtZT0+bWU9PT1cIm51bWJlclwifHxtZT09PVwiYm9vbGVhblwiKSxGZT1qIT09XCJzdHJpbmdcIjtyZXR1cm4gRmUmJk1lJiYhTmU/aWgoUik6ZnVuY3Rpb24oKXtyZXR1cm4gaWIoUixqLGxlLGFyZ3VtZW50cyxOZSl9fUFlLmluaXQoKTt2YXIgbGI9W251bGwsWmQsUWQsZWgsYWgscmgsc2hdLG9oPXtfX2Vtc2NyaXB0ZW5faW5pdF9tYWluX3RocmVhZF9qczp6ZyxfX2Vtc2NyaXB0ZW5fdGhyZWFkX2NsZWFudXA6V2csX19wdGhyZWFkX2NyZWF0ZV9qczp0aCxfZW1zY3JpcHRlbl9kZWZhdWx0X3B0aHJlYWRfc3RhY2tfc2l6ZTpCZyxfZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pYzpVZyxfZW1zY3JpcHRlbl9ub3RpZnlfdGFza19xdWV1ZTpHZyxfZW1zY3JpcHRlbl9zZXRfb2Zmc2NyZWVuY2FudmFzX3NpemU6SGcsYWJvcnQ6amcsZW1zY3JpcHRlbl9jaGVja19ibG9ja2luZ19hbGxvd2VkOnFnLGVtc2NyaXB0ZW5fZGF0ZV9ub3c6S2csZW1zY3JpcHRlbl9nZXRfaGVhcF9tYXg6WGcsZW1zY3JpcHRlbl9nZXRfbm93OkdwLGVtc2NyaXB0ZW5fbWVtY3B5X2JpZzpZZyxlbXNjcmlwdGVuX251bV9sb2dpY2FsX2NvcmVzOlpnLGVtc2NyaXB0ZW5fcmVjZWl2ZV9vbl9tYWluX3RocmVhZF9qczpRZyxlbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwOnRiLGVtc2NyaXB0ZW5fdW53aW5kX3RvX2pzX2V2ZW50X2xvb3A6bmIsZXhpdDpKZCxmZF9jbG9zZTphaCxmZF9zZWVrOnJoLGZkX3dyaXRlOnNoLG1lbW9yeTp1ZXx8Yy53YXNtTWVtb3J5fSxQaz1fZygpLHViPWMuX19fd2FzbV9jYWxsX2N0b3JzPWZ1bmN0aW9uKCl7cmV0dXJuKHViPWMuX19fd2FzbV9jYWxsX2N0b3JzPWMuYXNtLl9fd2FzbV9jYWxsX2N0b3JzKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHBiPWMuX2luaXQ9ZnVuY3Rpb24oKXtyZXR1cm4ocGI9Yy5faW5pdD1jLmFzbS5pbml0KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGNiPWMuX2luaXRfd2l0aF90aHJlYWRzX2NvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKGNiPWMuX2luaXRfd2l0aF90aHJlYWRzX2NvdW50PWMuYXNtLmluaXRfd2l0aF90aHJlYWRzX2NvdW50KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGRiPWMuX2dldF90aHJlYWRzX2NvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKGRiPWMuX2dldF90aHJlYWRzX2NvdW50PWMuYXNtLmdldF90aHJlYWRzX2NvdW50KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGhiPWMuX3JlZ2lzdGVyX3RlbnNvcj1mdW5jdGlvbigpe3JldHVybihoYj1jLl9yZWdpc3Rlcl90ZW5zb3I9Yy5hc20ucmVnaXN0ZXJfdGVuc29yKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG1iPWMuX2Rpc3Bvc2VfZGF0YT1mdW5jdGlvbigpe3JldHVybihtYj1jLl9kaXNwb3NlX2RhdGE9Yy5hc20uZGlzcG9zZV9kYXRhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGZiPWMuX2Rpc3Bvc2U9ZnVuY3Rpb24oKXtyZXR1cm4oZmI9Yy5fZGlzcG9zZT1jLmFzbS5kaXNwb3NlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGdiPWMuX0Ficz1mdW5jdGlvbigpe3JldHVybihnYj1jLl9BYnM9Yy5hc20uQWJzKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGJiPWMuX0Fjb3M9ZnVuY3Rpb24oKXtyZXR1cm4oYmI9Yy5fQWNvcz1jLmFzbS5BY29zKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHliPWMuX0Fjb3NoPWZ1bmN0aW9uKCl7cmV0dXJuKHliPWMuX0Fjb3NoPWMuYXNtLkFjb3NoKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHhiPWMuX0FkZD1mdW5jdGlvbigpe3JldHVybih4Yj1jLl9BZGQ9Yy5hc20uQWRkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHZiPWMuX0FkZE49ZnVuY3Rpb24oKXtyZXR1cm4odmI9Yy5fQWRkTj1jLmFzbS5BZGROKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHdiPWMuX0FsbD1mdW5jdGlvbigpe3JldHVybih3Yj1jLl9BbGw9Yy5hc20uQWxsKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGtiPWMuX0FueT1mdW5jdGlvbigpe3JldHVybihrYj1jLl9Bbnk9Yy5hc20uQW55KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEliPWMuX0FyZ01heD1mdW5jdGlvbigpe3JldHVybihJYj1jLl9BcmdNYXg9Yy5hc20uQXJnTWF4KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFNiPWMuX0FyZ01pbj1mdW5jdGlvbigpe3JldHVybihTYj1jLl9BcmdNaW49Yy5hc20uQXJnTWluKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE5iPWMuX0FzaW49ZnVuY3Rpb24oKXtyZXR1cm4oTmI9Yy5fQXNpbj1jLmFzbS5Bc2luKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFRiPWMuX0FzaW5oPWZ1bmN0aW9uKCl7cmV0dXJuKFRiPWMuX0FzaW5oPWMuYXNtLkFzaW5oKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LENiPWMuX0F0YW49ZnVuY3Rpb24oKXtyZXR1cm4oQ2I9Yy5fQXRhbj1jLmFzbS5BdGFuKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEViPWMuX0F0YW4yPWZ1bmN0aW9uKCl7cmV0dXJuKEViPWMuX0F0YW4yPWMuYXNtLkF0YW4yKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LF9iPWMuX0F0YW5oPWZ1bmN0aW9uKCl7cmV0dXJuKF9iPWMuX0F0YW5oPWMuYXNtLkF0YW5oKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEFiPWMuX0F2Z1Bvb2w9ZnVuY3Rpb24oKXtyZXR1cm4oQWI9Yy5fQXZnUG9vbD1jLmFzbS5BdmdQb29sKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEZiPWMuX0F2Z1Bvb2wzRD1mdW5jdGlvbigpe3JldHVybihGYj1jLl9BdmdQb29sM0Q9Yy5hc20uQXZnUG9vbDNEKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LCRiPWMuX0F2Z1Bvb2wzREdyYWQ9ZnVuY3Rpb24oKXtyZXR1cm4oJGI9Yy5fQXZnUG9vbDNER3JhZD1jLmFzbS5BdmdQb29sM0RHcmFkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LERiPWMuX0F2Z1Bvb2xHcmFkPWZ1bmN0aW9uKCl7cmV0dXJuKERiPWMuX0F2Z1Bvb2xHcmFkPWMuYXNtLkF2Z1Bvb2xHcmFkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFJiPWMuX0JhdGNoTWF0TXVsPWZ1bmN0aW9uKCl7cmV0dXJuKFJiPWMuX0JhdGNoTWF0TXVsPWMuYXNtLkJhdGNoTWF0TXVsKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE1iPWMuX0JpbmNvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKE1iPWMuX0JpbmNvdW50PWMuYXNtLkJpbmNvdW50KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE9iPWMuX0JpdHdpc2VBbmQ9ZnVuY3Rpb24oKXtyZXR1cm4oT2I9Yy5fQml0d2lzZUFuZD1jLmFzbS5CaXR3aXNlQW5kKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFBiPWMuX0NlaWw9ZnVuY3Rpb24oKXtyZXR1cm4oUGI9Yy5fQ2VpbD1jLmFzbS5DZWlsKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LExiPWMuX0NsaXBCeVZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuKExiPWMuX0NsaXBCeVZhbHVlPWMuYXNtLkNsaXBCeVZhbHVlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHpiPWMuX0NvbnYyRD1mdW5jdGlvbigpe3JldHVybih6Yj1jLl9Db252MkQ9Yy5hc20uQ29udjJEKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFdiPWMuX0NvbnYyREJhY2twcm9wSW5wdXQ9ZnVuY3Rpb24oKXtyZXR1cm4oV2I9Yy5fQ29udjJEQmFja3Byb3BJbnB1dD1jLmFzbS5Db252MkRCYWNrcHJvcElucHV0KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEJiPWMuX0NvbnYzRD1mdW5jdGlvbigpe3JldHVybihCYj1jLl9Db252M0Q9Yy5hc20uQ29udjNEKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFZiPWMuX0NvbnYzREJhY2twcm9wRmlsdGVyVjI9ZnVuY3Rpb24oKXtyZXR1cm4oVmI9Yy5fQ29udjNEQmFja3Byb3BGaWx0ZXJWMj1jLmFzbS5Db252M0RCYWNrcHJvcEZpbHRlclYyKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFViPWMuX0NvbnYzREJhY2twcm9wSW5wdXRWMj1mdW5jdGlvbigpe3JldHVybihVYj1jLl9Db252M0RCYWNrcHJvcElucHV0VjI9Yy5hc20uQ29udjNEQmFja3Byb3BJbnB1dFYyKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEdiPWMuX0Nvcz1mdW5jdGlvbigpe3JldHVybihHYj1jLl9Db3M9Yy5hc20uQ29zKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEhiPWMuX0Nvc2g9ZnVuY3Rpb24oKXtyZXR1cm4oSGI9Yy5fQ29zaD1jLmFzbS5Db3NoKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGpiPWMuX0Nyb3BBbmRSZXNpemU9ZnVuY3Rpb24oKXtyZXR1cm4oamI9Yy5fQ3JvcEFuZFJlc2l6ZT1jLmFzbS5Dcm9wQW5kUmVzaXplKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHFiPWMuX0N1bXByb2Q9ZnVuY3Rpb24oKXtyZXR1cm4ocWI9Yy5fQ3VtcHJvZD1jLmFzbS5DdW1wcm9kKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEtiPWMuX0N1bXN1bT1mdW5jdGlvbigpe3JldHVybihLYj1jLl9DdW1zdW09Yy5hc20uQ3Vtc3VtKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFhiPWMuX0RlbnNlQmluY291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4oWGI9Yy5fRGVuc2VCaW5jb3VudD1jLmFzbS5EZW5zZUJpbmNvdW50KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFliPWMuX0RlcHRoVG9TcGFjZT1mdW5jdGlvbigpe3JldHVybihZYj1jLl9EZXB0aFRvU3BhY2U9Yy5hc20uRGVwdGhUb1NwYWNlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFpiPWMuX0RlcHRod2lzZUNvbnYyZE5hdGl2ZT1mdW5jdGlvbigpe3JldHVybihaYj1jLl9EZXB0aHdpc2VDb252MmROYXRpdmU9Yy5hc20uRGVwdGh3aXNlQ29udjJkTmF0aXZlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEpiPWMuX0RpYWc9ZnVuY3Rpb24oKXtyZXR1cm4oSmI9Yy5fRGlhZz1jLmFzbS5EaWFnKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFFiPWMuX0RpbGF0aW9uMkQ9ZnVuY3Rpb24oKXtyZXR1cm4oUWI9Yy5fRGlsYXRpb24yRD1jLmFzbS5EaWxhdGlvbjJEKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGV5PWMuX0RpbGF0aW9uMkRCYWNrcHJvcEZpbHRlcj1mdW5jdGlvbigpe3JldHVybihleT1jLl9EaWxhdGlvbjJEQmFja3Byb3BGaWx0ZXI9Yy5hc20uRGlsYXRpb24yREJhY2twcm9wRmlsdGVyKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHR5PWMuX0RpbGF0aW9uMkRCYWNrcHJvcElucHV0PWZ1bmN0aW9uKCl7cmV0dXJuKHR5PWMuX0RpbGF0aW9uMkRCYWNrcHJvcElucHV0PWMuYXNtLkRpbGF0aW9uMkRCYWNrcHJvcElucHV0KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG55PWMuX0VsdT1mdW5jdGlvbigpe3JldHVybihueT1jLl9FbHU9Yy5hc20uRWx1KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGF5PWMuX0VsdUdyYWQ9ZnVuY3Rpb24oKXtyZXR1cm4oYXk9Yy5fRWx1R3JhZD1jLmFzbS5FbHVHcmFkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHJ5PWMuX0VxdWFsPWZ1bmN0aW9uKCl7cmV0dXJuKHJ5PWMuX0VxdWFsPWMuYXNtLkVxdWFsKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHN5PWMuX0VyZj1mdW5jdGlvbigpe3JldHVybihzeT1jLl9FcmY9Yy5hc20uRXJmKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGl5PWMuX0V4cD1mdW5jdGlvbigpe3JldHVybihpeT1jLl9FeHA9Yy5hc20uRXhwKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG95PWMuX0V4cG0xPWZ1bmN0aW9uKCl7cmV0dXJuKG95PWMuX0V4cG0xPWMuYXNtLkV4cG0xKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGx5PWMuX0ZsaXBMZWZ0UmlnaHQ9ZnVuY3Rpb24oKXtyZXR1cm4obHk9Yy5fRmxpcExlZnRSaWdodD1jLmFzbS5GbGlwTGVmdFJpZ2h0KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHV5PWMuX0Zsb29yPWZ1bmN0aW9uKCl7cmV0dXJuKHV5PWMuX0Zsb29yPWMuYXNtLkZsb29yKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHB5PWMuX0Zsb29yRGl2PWZ1bmN0aW9uKCl7cmV0dXJuKHB5PWMuX0Zsb29yRGl2PWMuYXNtLkZsb29yRGl2KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGN5PWMuX0Z1c2VkQmF0Y2hOb3JtPWZ1bmN0aW9uKCl7cmV0dXJuKGN5PWMuX0Z1c2VkQmF0Y2hOb3JtPWMuYXNtLkZ1c2VkQmF0Y2hOb3JtKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGR5PWMuX0Z1c2VkQ29udjJEPWZ1bmN0aW9uKCl7cmV0dXJuKGR5PWMuX0Z1c2VkQ29udjJEPWMuYXNtLkZ1c2VkQ29udjJEKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGh5PWMuX0Z1c2VkRGVwdGh3aXNlQ29udjJEPWZ1bmN0aW9uKCl7cmV0dXJuKGh5PWMuX0Z1c2VkRGVwdGh3aXNlQ29udjJEPWMuYXNtLkZ1c2VkRGVwdGh3aXNlQ29udjJEKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG15PWMuX0dhdGhlcj1mdW5jdGlvbigpe3JldHVybihteT1jLl9HYXRoZXI9Yy5hc20uR2F0aGVyKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGZ5PWMuX0dhdGhlck5kPWZ1bmN0aW9uKCl7cmV0dXJuKGZ5PWMuX0dhdGhlck5kPWMuYXNtLkdhdGhlck5kKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGd5PWMuX0dyZWF0ZXI9ZnVuY3Rpb24oKXtyZXR1cm4oZ3k9Yy5fR3JlYXRlcj1jLmFzbS5HcmVhdGVyKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGJ5PWMuX0dyZWF0ZXJFcXVhbD1mdW5jdGlvbigpe3JldHVybihieT1jLl9HcmVhdGVyRXF1YWw9Yy5hc20uR3JlYXRlckVxdWFsKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHl5PWMuX0lzRmluaXRlPWZ1bmN0aW9uKCl7cmV0dXJuKHl5PWMuX0lzRmluaXRlPWMuYXNtLklzRmluaXRlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHh5PWMuX0lzSW5mPWZ1bmN0aW9uKCl7cmV0dXJuKHh5PWMuX0lzSW5mPWMuYXNtLklzSW5mKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHZ5PWMuX0lzTmFuPWZ1bmN0aW9uKCl7cmV0dXJuKHZ5PWMuX0lzTmFuPWMuYXNtLklzTmFuKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHd5PWMuX0xSTj1mdW5jdGlvbigpe3JldHVybih3eT1jLl9MUk49Yy5hc20uTFJOKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGt5PWMuX0xSTkdyYWQ9ZnVuY3Rpb24oKXtyZXR1cm4oa3k9Yy5fTFJOR3JhZD1jLmFzbS5MUk5HcmFkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEl5PWMuX0xlYWt5UmVsdT1mdW5jdGlvbigpe3JldHVybihJeT1jLl9MZWFreVJlbHU9Yy5hc20uTGVha3lSZWx1KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFN5PWMuX0xlc3M9ZnVuY3Rpb24oKXtyZXR1cm4oU3k9Yy5fTGVzcz1jLmFzbS5MZXNzKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE55PWMuX0xlc3NFcXVhbD1mdW5jdGlvbigpe3JldHVybihOeT1jLl9MZXNzRXF1YWw9Yy5hc20uTGVzc0VxdWFsKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFR5PWMuX0xpblNwYWNlPWZ1bmN0aW9uKCl7cmV0dXJuKFR5PWMuX0xpblNwYWNlPWMuYXNtLkxpblNwYWNlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEN5PWMuX0xvZz1mdW5jdGlvbigpe3JldHVybihDeT1jLl9Mb2c9Yy5hc20uTG9nKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEV5PWMuX0xvZzFwPWZ1bmN0aW9uKCl7cmV0dXJuKEV5PWMuX0xvZzFwPWMuYXNtLkxvZzFwKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LF95PWMuX0xvZ2ljYWxBbmQ9ZnVuY3Rpb24oKXtyZXR1cm4oX3k9Yy5fTG9naWNhbEFuZD1jLmFzbS5Mb2dpY2FsQW5kKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEF5PWMuX0xvZ2ljYWxOb3Q9ZnVuY3Rpb24oKXtyZXR1cm4oQXk9Yy5fTG9naWNhbE5vdD1jLmFzbS5Mb2dpY2FsTm90KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEZ5PWMuX0xvZ2ljYWxPcj1mdW5jdGlvbigpe3JldHVybihGeT1jLl9Mb2dpY2FsT3I9Yy5hc20uTG9naWNhbE9yKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LCR5PWMuX0xvZ2ljYWxYb3I9ZnVuY3Rpb24oKXtyZXR1cm4oJHk9Yy5fTG9naWNhbFhvcj1jLmFzbS5Mb2dpY2FsWG9yKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LER5PWMuX01heD1mdW5jdGlvbigpe3JldHVybihEeT1jLl9NYXg9Yy5hc20uTWF4KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFJ5PWMuX01heFBvb2w9ZnVuY3Rpb24oKXtyZXR1cm4oUnk9Yy5fTWF4UG9vbD1jLmFzbS5NYXhQb29sKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE15PWMuX01heFBvb2wzRD1mdW5jdGlvbigpe3JldHVybihNeT1jLl9NYXhQb29sM0Q9Yy5hc20uTWF4UG9vbDNEKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE95PWMuX01heFBvb2wzREdyYWQ9ZnVuY3Rpb24oKXtyZXR1cm4oT3k9Yy5fTWF4UG9vbDNER3JhZD1jLmFzbS5NYXhQb29sM0RHcmFkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFB5PWMuX01heFBvb2xHcmFkPWZ1bmN0aW9uKCl7cmV0dXJuKFB5PWMuX01heFBvb2xHcmFkPWMuYXNtLk1heFBvb2xHcmFkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEx5PWMuX01heFBvb2xXaXRoQXJnbWF4PWZ1bmN0aW9uKCl7cmV0dXJuKEx5PWMuX01heFBvb2xXaXRoQXJnbWF4PWMuYXNtLk1heFBvb2xXaXRoQXJnbWF4KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHp5PWMuX01heGltdW09ZnVuY3Rpb24oKXtyZXR1cm4oenk9Yy5fTWF4aW11bT1jLmFzbS5NYXhpbXVtKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFd5PWMuX01lYW49ZnVuY3Rpb24oKXtyZXR1cm4oV3k9Yy5fTWVhbj1jLmFzbS5NZWFuKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEJ5PWMuX01pbj1mdW5jdGlvbigpe3JldHVybihCeT1jLl9NaW49Yy5hc20uTWluKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFZ5PWMuX01pbmltdW09ZnVuY3Rpb24oKXtyZXR1cm4oVnk9Yy5fTWluaW11bT1jLmFzbS5NaW5pbXVtKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFV5PWMuX01pcnJvclBhZD1mdW5jdGlvbigpe3JldHVybihVeT1jLl9NaXJyb3JQYWQ9Yy5hc20uTWlycm9yUGFkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEd5PWMuX01vZD1mdW5jdGlvbigpe3JldHVybihHeT1jLl9Nb2Q9Yy5hc20uTW9kKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEh5PWMuX011bHRpbm9taWFsPWZ1bmN0aW9uKCl7cmV0dXJuKEh5PWMuX011bHRpbm9taWFsPWMuYXNtLk11bHRpbm9taWFsKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGp5PWMuX011bHRpcGx5PWZ1bmN0aW9uKCl7cmV0dXJuKGp5PWMuX011bHRpcGx5PWMuYXNtLk11bHRpcGx5KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHF5PWMuX05lZz1mdW5jdGlvbigpe3JldHVybihxeT1jLl9OZWc9Yy5hc20uTmVnKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEt5PWMuX05vbk1heFN1cHByZXNzaW9uVjM9ZnVuY3Rpb24oKXtyZXR1cm4oS3k9Yy5fTm9uTWF4U3VwcHJlc3Npb25WMz1jLmFzbS5Ob25NYXhTdXBwcmVzc2lvblYzKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFh5PWMuX05vbk1heFN1cHByZXNzaW9uVjQ9ZnVuY3Rpb24oKXtyZXR1cm4oWHk9Yy5fTm9uTWF4U3VwcHJlc3Npb25WND1jLmFzbS5Ob25NYXhTdXBwcmVzc2lvblY0KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGxoPWMuX05vbk1heFN1cHByZXNzaW9uVjU9ZnVuY3Rpb24oKXtyZXR1cm4obGg9Yy5fTm9uTWF4U3VwcHJlc3Npb25WNT1jLmFzbS5Ob25NYXhTdXBwcmVzc2lvblY1KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHVoPWMuX05vdEVxdWFsPWZ1bmN0aW9uKCl7cmV0dXJuKHVoPWMuX05vdEVxdWFsPWMuYXNtLk5vdEVxdWFsKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGpwPWMuX09uZUhvdD1mdW5jdGlvbigpe3JldHVybihqcD1jLl9PbmVIb3Q9Yy5hc20uT25lSG90KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFl5PWMuX1BhZFYyPWZ1bmN0aW9uKCl7cmV0dXJuKFl5PWMuX1BhZFYyPWMuYXNtLlBhZFYyKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFp5PWMuX1Bvdz1mdW5jdGlvbigpe3JldHVybihaeT1jLl9Qb3c9Yy5hc20uUG93KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHlsPWMuX1ByZWx1PWZ1bmN0aW9uKCl7cmV0dXJuKHlsPWMuX1ByZWx1PWMuYXNtLlByZWx1KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHBoPWMuX1Byb2Q9ZnVuY3Rpb24oKXtyZXR1cm4ocGg9Yy5fUHJvZD1jLmFzbS5Qcm9kKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHhsPWMuX1JlYWxEaXY9ZnVuY3Rpb24oKXtyZXR1cm4oeGw9Yy5fUmVhbERpdj1jLmFzbS5SZWFsRGl2KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHZsPWMuX1JlY2lwcm9jYWw9ZnVuY3Rpb24oKXtyZXR1cm4odmw9Yy5fUmVjaXByb2NhbD1jLmFzbS5SZWNpcHJvY2FsKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEp5PWMuX1JlbHU9ZnVuY3Rpb24oKXtyZXR1cm4oSnk9Yy5fUmVsdT1jLmFzbS5SZWx1KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFk9Yy5fUmVsdTY9ZnVuY3Rpb24oKXtyZXR1cm4oWT1jLl9SZWx1Nj1jLmFzbS5SZWx1NikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxvZT1jLl9SZXNpemVCaWxpbmVhcj1mdW5jdGlvbigpe3JldHVybihvZT1jLl9SZXNpemVCaWxpbmVhcj1jLmFzbS5SZXNpemVCaWxpbmVhcikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxJZT1jLl9SZXNpemVCaWxpbmVhckdyYWQ9ZnVuY3Rpb24oKXtyZXR1cm4oSWU9Yy5fUmVzaXplQmlsaW5lYXJHcmFkPWMuYXNtLlJlc2l6ZUJpbGluZWFyR3JhZCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxZZT1jLl9SZXNpemVOZWFyZXN0TmVpZ2hib3I9ZnVuY3Rpb24oKXtyZXR1cm4oWWU9Yy5fUmVzaXplTmVhcmVzdE5laWdoYm9yPWMuYXNtLlJlc2l6ZU5lYXJlc3ROZWlnaGJvcikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx3dD1jLl9SZXNpemVOZWFyZXN0TmVpZ2hib3JHcmFkPWZ1bmN0aW9uKCl7cmV0dXJuKHd0PWMuX1Jlc2l6ZU5lYXJlc3ROZWlnaGJvckdyYWQ9Yy5hc20uUmVzaXplTmVhcmVzdE5laWdoYm9yR3JhZCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxrdD1jLl9SZXZlcnNlPWZ1bmN0aW9uKCl7cmV0dXJuKGt0PWMuX1JldmVyc2U9Yy5hc20uUmV2ZXJzZSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxHZT1jLl9Sb3RhdGVXaXRoT2Zmc2V0PWZ1bmN0aW9uKCl7cmV0dXJuKEdlPWMuX1JvdGF0ZVdpdGhPZmZzZXQ9Yy5hc20uUm90YXRlV2l0aE9mZnNldCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxCZT1jLl9Sb3VuZD1mdW5jdGlvbigpe3JldHVybihCZT1jLl9Sb3VuZD1jLmFzbS5Sb3VuZCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxQdD1jLl9Sc3FydD1mdW5jdGlvbigpe3JldHVybihQdD1jLl9Sc3FydD1jLmFzbS5Sc3FydCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxsYT1jLl9TY2F0dGVyTmQ9ZnVuY3Rpb24oKXtyZXR1cm4obGE9Yy5fU2NhdHRlck5kPWMuYXNtLlNjYXR0ZXJOZCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx3cj1jLl9TZWFyY2hTb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4od3I9Yy5fU2VhcmNoU29ydGVkPWMuYXNtLlNlYXJjaFNvcnRlZCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxjaD1jLl9TZWxlY3RWMj1mdW5jdGlvbigpe3JldHVybihjaD1jLl9TZWxlY3RWMj1jLmFzbS5TZWxlY3RWMikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxxcD1jLl9TZWx1PWZ1bmN0aW9uKCl7cmV0dXJuKHFwPWMuX1NlbHU9Yy5hc20uU2VsdSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxReT1jLl9TaWdtb2lkPWZ1bmN0aW9uKCl7cmV0dXJuKFF5PWMuX1NpZ21vaWQ9Yy5hc20uU2lnbW9pZCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxSbj1jLl9TaWduPWZ1bmN0aW9uKCl7cmV0dXJuKFJuPWMuX1NpZ249Yy5hc20uU2lnbikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxqcj1jLl9TaW49ZnVuY3Rpb24oKXtyZXR1cm4oanI9Yy5fU2luPWMuYXNtLlNpbikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxkaD1jLl9TaW5oPWZ1bmN0aW9uKCl7cmV0dXJuKGRoPWMuX1Npbmg9Yy5hc20uU2luaCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxCRD1jLl9Tb2Z0bWF4PWZ1bmN0aW9uKCl7cmV0dXJuKEJEPWMuX1NvZnRtYXg9Yy5hc20uU29mdG1heCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxWRD1jLl9Tb2Z0cGx1cz1mdW5jdGlvbigpe3JldHVybihWRD1jLl9Tb2Z0cGx1cz1jLmFzbS5Tb2Z0cGx1cykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxVRD1jLl9TcGFyc2VGaWxsRW1wdHlSb3dzPWZ1bmN0aW9uKCl7cmV0dXJuKFVEPWMuX1NwYXJzZUZpbGxFbXB0eVJvd3M9Yy5hc20uU3BhcnNlRmlsbEVtcHR5Um93cykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxHRD1jLl9TcGFyc2VSZXNoYXBlPWZ1bmN0aW9uKCl7cmV0dXJuKEdEPWMuX1NwYXJzZVJlc2hhcGU9Yy5hc20uU3BhcnNlUmVzaGFwZSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxIRD1jLl9TcGFyc2VTZWdtZW50UmVkdWN0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuKEhEPWMuX1NwYXJzZVNlZ21lbnRSZWR1Y3Rpb249Yy5hc20uU3BhcnNlU2VnbWVudFJlZHVjdGlvbikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxqRD1jLl9TcGFyc2VUb0RlbnNlPWZ1bmN0aW9uKCl7cmV0dXJuKGpEPWMuX1NwYXJzZVRvRGVuc2U9Yy5hc20uU3BhcnNlVG9EZW5zZSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxxRD1jLl9TcXJ0PWZ1bmN0aW9uKCl7cmV0dXJuKHFEPWMuX1NxcnQ9Yy5hc20uU3FydCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxLRD1jLl9TcXVhcmU9ZnVuY3Rpb24oKXtyZXR1cm4oS0Q9Yy5fU3F1YXJlPWMuYXNtLlNxdWFyZSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxYRD1jLl9TcXVhcmVkRGlmZmVyZW5jZT1mdW5jdGlvbigpe3JldHVybihYRD1jLl9TcXVhcmVkRGlmZmVyZW5jZT1jLmFzbS5TcXVhcmVkRGlmZmVyZW5jZSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxZRD1jLl9TdGVwPWZ1bmN0aW9uKCl7cmV0dXJuKFlEPWMuX1N0ZXA9Yy5hc20uU3RlcCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxaRD1jLl9TdHJpZGVkU2xpY2U9ZnVuY3Rpb24oKXtyZXR1cm4oWkQ9Yy5fU3RyaWRlZFNsaWNlPWMuYXNtLlN0cmlkZWRTbGljZSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxKRD1jLl9TdWI9ZnVuY3Rpb24oKXtyZXR1cm4oSkQ9Yy5fU3ViPWMuYXNtLlN1YikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxRRD1jLl9TdW09ZnVuY3Rpb24oKXtyZXR1cm4oUUQ9Yy5fU3VtPWMuYXNtLlN1bSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlUj1jLl9UYW49ZnVuY3Rpb24oKXtyZXR1cm4oZVI9Yy5fVGFuPWMuYXNtLlRhbikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0Uj1jLl9UYW5oPWZ1bmN0aW9uKCl7cmV0dXJuKHRSPWMuX1Rhbmg9Yy5hc20uVGFuaCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxuUj1jLl9UZW5zb3JTY2F0dGVyVXBkYXRlPWZ1bmN0aW9uKCl7cmV0dXJuKG5SPWMuX1RlbnNvclNjYXR0ZXJVcGRhdGU9Yy5hc20uVGVuc29yU2NhdHRlclVwZGF0ZSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxhUj1jLl9UaWxlPWZ1bmN0aW9uKCl7cmV0dXJuKGFSPWMuX1RpbGU9Yy5hc20uVGlsZSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxyUj1jLl9Ub3BLPWZ1bmN0aW9uKCl7cmV0dXJuKHJSPWMuX1RvcEs9Yy5hc20uVG9wSykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzUj1jLl9UcmFuc2Zvcm09ZnVuY3Rpb24oKXtyZXR1cm4oc1I9Yy5fVHJhbnNmb3JtPWMuYXNtLlRyYW5zZm9ybSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxpUj1jLl9UcmFuc3Bvc2U9ZnVuY3Rpb24oKXtyZXR1cm4oaVI9Yy5fVHJhbnNwb3NlPWMuYXNtLlRyYW5zcG9zZSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxvUj1jLl9fRnVzZWRNYXRNdWw9ZnVuY3Rpb24oKXtyZXR1cm4ob1I9Yy5fX0Z1c2VkTWF0TXVsPWMuYXNtLl9GdXNlZE1hdE11bCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxsUj1jLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4obFI9Yy5fbWFsbG9jPWMuYXNtLm1hbGxvYykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1Uj1jLl9mcmVlPWZ1bmN0aW9uKCl7cmV0dXJuKHVSPWMuX2ZyZWU9Yy5hc20uZnJlZSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxwUj1jLl9fZW1zY3JpcHRlbl90bHNfaW5pdD1mdW5jdGlvbigpe3JldHVybihwUj1jLl9fZW1zY3JpcHRlbl90bHNfaW5pdD1jLmFzbS5fZW1zY3JpcHRlbl90bHNfaW5pdCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxoaD1jLl9wdGhyZWFkX3NlbGY9ZnVuY3Rpb24oKXtyZXR1cm4oaGg9Yy5fcHRocmVhZF9zZWxmPWMuYXNtLnB0aHJlYWRfc2VsZikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxjUj1jLl9fX2Vycm5vX2xvY2F0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuKGNSPWMuX19fZXJybm9fbG9jYXRpb249Yy5hc20uX19lcnJub19sb2NhdGlvbikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxMaz1jLl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdD1mdW5jdGlvbigpe3JldHVybihMaz1jLl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdD1jLmFzbS5fZW1zY3JpcHRlbl90aHJlYWRfaW5pdCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxkUj1jLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZD1mdW5jdGlvbigpe3JldHVybihkUj1jLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZD1jLmFzbS5fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxoUj1jLl9lbXNjcmlwdGVuX21haW5fdGhyZWFkX3Byb2Nlc3NfcXVldWVkX2NhbGxzPWZ1bmN0aW9uKCl7cmV0dXJuKGhSPWMuX2Vtc2NyaXB0ZW5fbWFpbl90aHJlYWRfcHJvY2Vzc19xdWV1ZWRfY2FsbHM9Yy5hc20uZW1zY3JpcHRlbl9tYWluX3RocmVhZF9wcm9jZXNzX3F1ZXVlZF9jYWxscykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxtUj1jLl9lbXNjcmlwdGVuX21haW5fYnJvd3Nlcl90aHJlYWRfaWQ9ZnVuY3Rpb24oKXtyZXR1cm4obVI9Yy5fZW1zY3JpcHRlbl9tYWluX2Jyb3dzZXJfdGhyZWFkX2lkPWMuYXNtLmVtc2NyaXB0ZW5fbWFpbl9icm93c2VyX3RocmVhZF9pZCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx6az1jLl9lbXNjcmlwdGVuX3J1bl9pbl9tYWluX3J1bnRpbWVfdGhyZWFkX2pzPWZ1bmN0aW9uKCl7cmV0dXJuKHprPWMuX2Vtc2NyaXB0ZW5fcnVuX2luX21haW5fcnVudGltZV90aHJlYWRfanM9Yy5hc20uZW1zY3JpcHRlbl9ydW5faW5fbWFpbl9ydW50aW1lX3RocmVhZF9qcykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxmUj1jLl9lbXNjcmlwdGVuX2Rpc3BhdGNoX3RvX3RocmVhZF89ZnVuY3Rpb24oKXtyZXR1cm4oZlI9Yy5fZW1zY3JpcHRlbl9kaXNwYXRjaF90b190aHJlYWRfPWMuYXNtLmVtc2NyaXB0ZW5fZGlzcGF0Y2hfdG9fdGhyZWFkXykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxXaz1jLl9fZW1zY3JpcHRlbl9wcm94eV9leGVjdXRlX3Rhc2tfcXVldWU9ZnVuY3Rpb24oKXtyZXR1cm4oV2s9Yy5fX2Vtc2NyaXB0ZW5fcHJveHlfZXhlY3V0ZV90YXNrX3F1ZXVlPWMuYXNtLl9lbXNjcmlwdGVuX3Byb3h5X2V4ZWN1dGVfdGFza19xdWV1ZSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxleD1jLl9fZW1zY3JpcHRlbl90aHJlYWRfZnJlZV9kYXRhPWZ1bmN0aW9uKCl7cmV0dXJuKGV4PWMuX19lbXNjcmlwdGVuX3RocmVhZF9mcmVlX2RhdGE9Yy5hc20uX2Vtc2NyaXB0ZW5fdGhyZWFkX2ZyZWVfZGF0YSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxCaz1jLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdD1mdW5jdGlvbigpe3JldHVybihCaz1jLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdD1jLmFzbS5fZW1zY3JpcHRlbl90aHJlYWRfZXhpdCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxWaz1jLl9lbXNjcmlwdGVuX3N0YWNrX3NldF9saW1pdHM9ZnVuY3Rpb24oKXtyZXR1cm4oVms9Yy5fZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzPWMuYXNtLmVtc2NyaXB0ZW5fc3RhY2tfc2V0X2xpbWl0cykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx0eD1jLnN0YWNrU2F2ZT1mdW5jdGlvbigpe3JldHVybih0eD1jLnN0YWNrU2F2ZT1jLmFzbS5zdGFja1NhdmUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sbWg9Yy5zdGFja1Jlc3RvcmU9ZnVuY3Rpb24oKXtyZXR1cm4obWg9Yy5zdGFja1Jlc3RvcmU9Yy5hc20uc3RhY2tSZXN0b3JlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGZoPWMuc3RhY2tBbGxvYz1mdW5jdGlvbigpe3JldHVybihmaD1jLnN0YWNrQWxsb2M9Yy5hc20uc3RhY2tBbGxvYykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxnUj1jLmR5bkNhbGxfaWlqamlpaWk9ZnVuY3Rpb24oKXtyZXR1cm4oZ1I9Yy5keW5DYWxsX2lpamppaWlpPWMuYXNtLmR5bkNhbGxfaWlqamlpaWkpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sYlI9Yy5keW5DYWxsX2ppamk9ZnVuY3Rpb24oKXtyZXR1cm4oYlI9Yy5keW5DYWxsX2ppamk9Yy5hc20uZHluQ2FsbF9qaWppKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2Mua2VlcFJ1bnRpbWVBbGl2ZT1JYSxjLndhc21NZW1vcnk9dWUsYy5jd3JhcD1vYixjLkV4aXRTdGF0dXM9R3MsYy5QVGhyZWFkPUFlO3ZhciBnaDt2cj1mdW5jdGlvbiBSKCl7Z2h8fFVrKCksZ2h8fCh2cj1SKX07ZnVuY3Rpb24gVWsoUil7aWYoUj1SfHxiLEdyPjApcmV0dXJuO2lmKEMpe2goYyksSnQoKSxzdGFydFdvcmtlcihjKTtyZXR1cm59aWYoVXIoKSxHcj4wKXJldHVybjtmdW5jdGlvbiBqKCl7Z2h8fChnaD0hMCxjLmNhbGxlZFJ1bj0hMCwha2UmJihKdCgpLGgoYyksYy5vblJ1bnRpbWVJbml0aWFsaXplZCYmYy5vblJ1bnRpbWVJbml0aWFsaXplZCgpLEhkKCkpKX1jLnNldFN0YXR1cz8oYy5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yy5zZXRTdGF0dXMoXCJcIil9LDEpLGooKX0sMSkpOmooKX1pZihjLnByZUluaXQpZm9yKHR5cGVvZiBjLnByZUluaXQ9PVwiZnVuY3Rpb25cIiYmKGMucHJlSW5pdD1bYy5wcmVJbml0XSk7Yy5wcmVJbml0Lmxlbmd0aD4wOyljLnByZUluaXQucG9wKCkoKTtVaygpO3ZhciBiaDtmJiYoYmg9e3VuY2F1Z2h0RXhjZXB0aW9uOnByb2Nlc3MubGlzdGVuZXJzKFwidW5jYXVnaHRFeGNlcHRpb25cIikuZmlsdGVyKGZ1bmN0aW9uKFIpe3JldHVybiFmLnVuY2F1Z2h0RXhjZXB0aW9uLmluZGV4T2YoUik+LTF9KSx1bmhhbmRsZWRSZWplY3Rpb246cHJvY2Vzcy5saXN0ZW5lcnMoXCJ1bmhhbmRsZWRSZWplY3Rpb25cIikuZmlsdGVyKGZ1bmN0aW9uKFIpe3JldHVybiFmLnVuaGFuZGxlZFJlamVjdGlvbi5pbmRleE9mKFIpPi0xfSl9KTt2YXIgeWg7aWYodHlwZW9mIFdhc21CYWNrZW5kTW9kdWxlIT1cInVuZGVmaW5lZFwiKXloPVdhc21CYWNrZW5kTW9kdWxlO2Vsc2UgaWYodHlwZW9mIHIhPVwidW5kZWZpbmVkXCIpeWg9cjtlbHNlIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHdhc20gbW9kdWxlIGluIHBvc3QuanNcIik7aWYoYmgpe3ZhciB5Uj15aC5fZGlzcG9zZTt5aC5fZGlzcG9zZT1mdW5jdGlvbigpe3lSKCksYmgudW5jYXVnaHRFeGNlcHRpb24uZm9yRWFjaChmdW5jdGlvbihSKXtwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKFwidW5jYXVnaHRFeGNlcHRpb25cIixSKX0pLGJoLnVuaGFuZGxlZFJlamVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uKFIpe3Byb2Nlc3MucmVtb3ZlTGlzdGVuZXIoXCJ1bmhhbmRsZWRSZWplY3Rpb25cIixSKX0pfX1yZXR1cm4gci5yZWFkeX19KSgpO3R5cGVvZiBlPT1cIm9iamVjdFwiJiZ0eXBlb2YgdD09XCJvYmplY3RcIj90LmV4cG9ydHM9bjp0eXBlb2YgZGVmaW5lPT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLGZ1bmN0aW9uKCl7cmV0dXJuIG59KTp0eXBlb2YgZT09XCJvYmplY3RcIiYmKGUuV2FzbUJhY2tlbmRNb2R1bGVUaHJlYWRlZFNpbWQ9bil9KSxVUj1WdCgoZSx0KT0+e3QuZXhwb3J0cy53YXNtV29ya2VyQ29udGVudHM9YFwidXNlIHN0cmljdFwiO3ZhciBNb2R1bGU9e307dmFyIEVOVklST05NRU5UX0lTX05PREU9dHlwZW9mIHByb2Nlc3M9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlPT1cInN0cmluZ1wiO2lmKEVOVklST05NRU5UX0lTX05PREUpe3ZhciBub2RlV29ya2VyVGhyZWFkcz1yZXF1aXJlKFwid29ya2VyX3RocmVhZHNcIik7dmFyIHBhcmVudFBvcnQ9bm9kZVdvcmtlclRocmVhZHMucGFyZW50UG9ydDtwYXJlbnRQb3J0Lm9uKFwibWVzc2FnZVwiLGRhdGE9Pm9ubWVzc2FnZSh7ZGF0YTpkYXRhfSkpO3ZhciBmcz1yZXF1aXJlKFwiZnNcIik7T2JqZWN0LmFzc2lnbihnbG9iYWwse3NlbGY6Z2xvYmFsLHJlcXVpcmU6cmVxdWlyZSxNb2R1bGU6TW9kdWxlLGxvY2F0aW9uOntocmVmOl9fZmlsZW5hbWV9LFdvcmtlcjpub2RlV29ya2VyVGhyZWFkcy5Xb3JrZXIsaW1wb3J0U2NyaXB0czpmdW5jdGlvbihmKXsoMCxldmFsKShmcy5yZWFkRmlsZVN5bmMoZixcInV0ZjhcIikrXCIvLyMgc291cmNlVVJMPVwiK2YpfSxwb3N0TWVzc2FnZTpmdW5jdGlvbihtc2cpe3BhcmVudFBvcnQucG9zdE1lc3NhZ2UobXNnKX0scGVyZm9ybWFuY2U6Z2xvYmFsLnBlcmZvcm1hbmNlfHx7bm93OmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9fX0pfXZhciBpbml0aWFsaXplZEpTPWZhbHNlO3ZhciBwZW5kaW5nTm90aWZpZWRQcm94eWluZ1F1ZXVlcz1bXTtmdW5jdGlvbiB0aHJlYWRQcmludEVycigpe3ZhciB0ZXh0PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbihcIiBcIik7aWYoRU5WSVJPTk1FTlRfSVNfTk9ERSl7ZnMud3JpdGVTeW5jKDIsdGV4dCtcIlxuXCIpO3JldHVybn1jb25zb2xlLmVycm9yKHRleHQpfWZ1bmN0aW9uIHRocmVhZEFsZXJ0KCl7dmFyIHRleHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTtwb3N0TWVzc2FnZSh7Y21kOlwiYWxlcnRcIix0ZXh0OnRleHQsdGhyZWFkSWQ6TW9kdWxlW1wiX3B0aHJlYWRfc2VsZlwiXSgpfSl9dmFyIGVycj10aHJlYWRQcmludEVycjtzZWxmLmFsZXJ0PXRocmVhZEFsZXJ0O01vZHVsZVtcImluc3RhbnRpYXRlV2FzbVwiXT0oaW5mbyxyZWNlaXZlSW5zdGFuY2UpPT57dmFyIGluc3RhbmNlPW5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShNb2R1bGVbXCJ3YXNtTW9kdWxlXCJdLGluZm8pO3JlY2VpdmVJbnN0YW5jZShpbnN0YW5jZSk7TW9kdWxlW1wid2FzbU1vZHVsZVwiXT1udWxsO3JldHVybiBpbnN0YW5jZS5leHBvcnRzfTtzZWxmLm9udW5oYW5kbGVkcmVqZWN0aW9uPWU9Pnt0aHJvdyBlLnJlYXNvbj8/ZX07c2VsZi5zdGFydFdvcmtlcj1pbnN0YW5jZT0+e01vZHVsZT1pbnN0YW5jZTtwb3N0TWVzc2FnZSh7XCJjbWRcIjpcImxvYWRlZFwifSl9O3NlbGYub25tZXNzYWdlPWU9Pnt0cnl7aWYoZS5kYXRhLmNtZD09PVwibG9hZFwiKXtNb2R1bGVbXCJ3YXNtTW9kdWxlXCJdPWUuZGF0YS53YXNtTW9kdWxlO2Zvcihjb25zdCBoYW5kbGVyIG9mIGUuZGF0YS5oYW5kbGVycyl7TW9kdWxlW2hhbmRsZXJdPWZ1bmN0aW9uKCl7cG9zdE1lc3NhZ2Uoe2NtZDpcImNhbGxIYW5kbGVyXCIsaGFuZGxlcjpoYW5kbGVyLGFyZ3M6Wy4uLmFyZ3VtZW50c119KX19TW9kdWxlW1wid2FzbU1lbW9yeVwiXT1lLmRhdGEud2FzbU1lbW9yeTtNb2R1bGVbXCJidWZmZXJcIl09TW9kdWxlW1wid2FzbU1lbW9yeVwiXS5idWZmZXI7TW9kdWxlW1wiRU5WSVJPTk1FTlRfSVNfUFRIUkVBRFwiXT10cnVlO2lmKHR5cGVvZiBlLmRhdGEudXJsT3JCbG9iPT1cInN0cmluZ1wiKXtpbXBvcnRTY3JpcHRzKGUuZGF0YS51cmxPckJsb2IpfWVsc2V7dmFyIG9iamVjdFVybD1VUkwuY3JlYXRlT2JqZWN0VVJMKGUuZGF0YS51cmxPckJsb2IpO2ltcG9ydFNjcmlwdHMob2JqZWN0VXJsKTtVUkwucmV2b2tlT2JqZWN0VVJMKG9iamVjdFVybCl9V2FzbUJhY2tlbmRNb2R1bGVUaHJlYWRlZFNpbWQoTW9kdWxlKX1lbHNlIGlmKGUuZGF0YS5jbWQ9PT1cInJ1blwiKXtNb2R1bGVbXCJfX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXRcIl0oZS5kYXRhLnB0aHJlYWRfcHRyLDAsMCwxKTtNb2R1bGVbXCJlc3RhYmxpc2hTdGFja1NwYWNlXCJdKCk7TW9kdWxlW1wiUFRocmVhZFwiXS5yZWNlaXZlT2JqZWN0VHJhbnNmZXIoZS5kYXRhKTtNb2R1bGVbXCJQVGhyZWFkXCJdLnRocmVhZEluaXRUTFMoKTtpZighaW5pdGlhbGl6ZWRKUyl7cGVuZGluZ05vdGlmaWVkUHJveHlpbmdRdWV1ZXMuZm9yRWFjaChxdWV1ZT0+e01vZHVsZVtcImV4ZWN1dGVOb3RpZmllZFByb3h5aW5nUXVldWVcIl0ocXVldWUpfSk7cGVuZGluZ05vdGlmaWVkUHJveHlpbmdRdWV1ZXM9W107aW5pdGlhbGl6ZWRKUz10cnVlfXRyeXtNb2R1bGVbXCJpbnZva2VFbnRyeVBvaW50XCJdKGUuZGF0YS5zdGFydF9yb3V0aW5lLGUuZGF0YS5hcmcpfWNhdGNoKGV4KXtpZihleCE9XCJ1bndpbmRcIil7aWYoZXggaW5zdGFuY2VvZiBNb2R1bGVbXCJFeGl0U3RhdHVzXCJdKXtpZihNb2R1bGVbXCJrZWVwUnVudGltZUFsaXZlXCJdKCkpe31lbHNle01vZHVsZVtcIl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdFwiXShleC5zdGF0dXMpfX1lbHNle3Rocm93IGV4fX19fWVsc2UgaWYoZS5kYXRhLmNtZD09PVwiY2FuY2VsXCIpe2lmKE1vZHVsZVtcIl9wdGhyZWFkX3NlbGZcIl0oKSl7TW9kdWxlW1wiX19lbXNjcmlwdGVuX3RocmVhZF9leGl0XCJdKC0xKX19ZWxzZSBpZihlLmRhdGEudGFyZ2V0PT09XCJzZXRpbW1lZGlhdGVcIil7fWVsc2UgaWYoZS5kYXRhLmNtZD09PVwicHJvY2Vzc1Byb3h5aW5nUXVldWVcIil7aWYoaW5pdGlhbGl6ZWRKUyl7TW9kdWxlW1wiZXhlY3V0ZU5vdGlmaWVkUHJveHlpbmdRdWV1ZVwiXShlLmRhdGEucXVldWUpfWVsc2V7cGVuZGluZ05vdGlmaWVkUHJveHlpbmdRdWV1ZXMucHVzaChlLmRhdGEucXVldWUpfX1lbHNlIGlmKGUuZGF0YS5jbWQpe2VycihcIndvcmtlci5qcyByZWNlaXZlZCB1bmtub3duIGNvbW1hbmQgXCIrZS5kYXRhLmNtZCk7ZXJyKGUuZGF0YSl9fWNhdGNoKGV4KXtpZihNb2R1bGVbXCJfX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWRcIl0pe01vZHVsZVtcIl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZFwiXSgpfXRocm93IGV4fX07YH0pLEdSPVZ0KChlLHQpPT57dmFyIG49KCgpPT57dmFyIGE9dHlwZW9mIGRvY3VtZW50IT1cInVuZGVmaW5lZFwiJiZkb2N1bWVudC5jdXJyZW50U2NyaXB0P2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjOnZvaWQgMDtyZXR1cm4gdHlwZW9mIF9fZmlsZW5hbWUhPVwidW5kZWZpbmVkXCImJihhPWF8fF9fZmlsZW5hbWUpLGZ1bmN0aW9uKHIpe3I9cnx8e307dmFyIHM9dHlwZW9mIHIhPVwidW5kZWZpbmVkXCI/cjp7fSxpLG87cy5yZWFkeT1uZXcgUHJvbWlzZShmdW5jdGlvbihZLG9lKXtpPVksbz1vZX0pO3ZhciBsO3R5cGVvZiBwcm9jZXNzIT1cInVuZGVmaW5lZFwiJiZwcm9jZXNzLmxpc3RlbmVycyYmKGw9e3VuY2F1Z2h0RXhjZXB0aW9uOnByb2Nlc3MubGlzdGVuZXJzKFwidW5jYXVnaHRFeGNlcHRpb25cIiksdW5oYW5kbGVkUmVqZWN0aW9uOnByb2Nlc3MubGlzdGVuZXJzKFwidW5oYW5kbGVkUmVqZWN0aW9uXCIpfSk7dmFyIHU9T2JqZWN0LmFzc2lnbih7fSxzKSxwPVtdLGQ9XCIuL3RoaXMucHJvZ3JhbVwiLGM9KFksb2UpPT57dGhyb3cgb2V9LGg9dHlwZW9mIHdpbmRvdz09XCJvYmplY3RcIixtPXR5cGVvZiBpbXBvcnRTY3JpcHRzPT1cImZ1bmN0aW9uXCIsZj10eXBlb2YgcHJvY2Vzcz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnM9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU9PVwic3RyaW5nXCIsZz1cIlwiO2Z1bmN0aW9uIGIoWSl7cmV0dXJuIHMubG9jYXRlRmlsZT9zLmxvY2F0ZUZpbGUoWSxnKTpnK1l9dmFyIHkseCx2LEk7ZnVuY3Rpb24gTihZKXtZIGluc3RhbmNlb2YgZmx8fEQoXCJleGl0aW5nIGR1ZSB0byBleGNlcHRpb246IFwiK1kpfWlmKGYpe3ZhciBDPUl2KCksXz0kUygpO20/Zz1fLmRpcm5hbWUoZykrXCIvXCI6Zz1fX2Rpcm5hbWUrXCIvXCIseT0oWSxvZSk9PihZPVVyKFkpP25ldyBVUkwoWSk6Xy5ub3JtYWxpemUoWSksQy5yZWFkRmlsZVN5bmMoWSxvZT92b2lkIDA6XCJ1dGY4XCIpKSx2PVk9Pnt2YXIgb2U9eShZLCEwKTtyZXR1cm4gb2UuYnVmZmVyfHwob2U9bmV3IFVpbnQ4QXJyYXkob2UpKSxvZX0seD0oWSxvZSxJZSk9PntZPVVyKFkpP25ldyBVUkwoWSk6Xy5ub3JtYWxpemUoWSksQy5yZWFkRmlsZShZLGZ1bmN0aW9uKFllLHd0KXtZZT9JZShZZSk6b2Uod3QuYnVmZmVyKX0pfSxwcm9jZXNzLmFyZ3YubGVuZ3RoPjEmJihkPXByb2Nlc3MuYXJndlsxXS5yZXBsYWNlKC9cXFxcL2csXCIvXCIpKSxwPXByb2Nlc3MuYXJndi5zbGljZSgyKSxwcm9jZXNzLm9uKFwidW5jYXVnaHRFeGNlcHRpb25cIixmdW5jdGlvbihZKXtpZighKFkgaW5zdGFuY2VvZiBmbCkpdGhyb3cgWX0pLHByb2Nlc3Mub24oXCJ1bmhhbmRsZWRSZWplY3Rpb25cIixmdW5jdGlvbihZKXt0aHJvdyBZfSksYz0oWSxvZSk9PntpZihHbigpKXRocm93IHByb2Nlc3MuZXhpdENvZGU9WSxvZTtOKG9lKSxwcm9jZXNzLmV4aXQoWSl9LHMuaW5zcGVjdD1mdW5jdGlvbigpe3JldHVyblwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIn19ZWxzZShofHxtKSYmKG0/Zz1zZWxmLmxvY2F0aW9uLmhyZWY6dHlwZW9mIGRvY3VtZW50IT1cInVuZGVmaW5lZFwiJiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYoZz1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksYSYmKGc9YSksZy5pbmRleE9mKFwiYmxvYjpcIikhPT0wP2c9Zy5zdWJzdHIoMCxnLnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpOmc9XCJcIix5PVk9Pnt2YXIgb2U9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBvZS5vcGVuKFwiR0VUXCIsWSwhMSksb2Uuc2VuZChudWxsKSxvZS5yZXNwb25zZVRleHR9LG0mJih2PVk9Pnt2YXIgb2U9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBvZS5vcGVuKFwiR0VUXCIsWSwhMSksb2UucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixvZS5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KG9lLnJlc3BvbnNlKX0pLHg9KFksb2UsSWUpPT57dmFyIFllPW5ldyBYTUxIdHRwUmVxdWVzdDtZZS5vcGVuKFwiR0VUXCIsWSwhMCksWWUucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixZZS5vbmxvYWQ9KCk9PntpZihZZS5zdGF0dXM9PTIwMHx8WWUuc3RhdHVzPT0wJiZZZS5yZXNwb25zZSl7b2UoWWUucmVzcG9uc2UpO3JldHVybn1JZSgpfSxZZS5vbmVycm9yPUllLFllLnNlbmQobnVsbCl9LEk9WT0+ZG9jdW1lbnQudGl0bGU9WSk7dmFyIEY9cy5wcmludHx8Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxEPXMucHJpbnRFcnJ8fGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO09iamVjdC5hc3NpZ24ocyx1KSx1PW51bGwscy5hcmd1bWVudHMmJihwPXMuYXJndW1lbnRzKSxzLnRoaXNQcm9ncmFtJiYoZD1zLnRoaXNQcm9ncmFtKSxzLnF1aXQmJihjPXMucXVpdCk7dmFyICQ9NCxTO3Mud2FzbUJpbmFyeSYmKFM9cy53YXNtQmluYXJ5KTt2YXIgTT1zLm5vRXhpdFJ1bnRpbWV8fCEwO3R5cGVvZiBXZWJBc3NlbWJseSE9XCJvYmplY3RcIiYmWmEoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpO3ZhciBCLFU9ITEsSDtmdW5jdGlvbiBxKFksb2Upe1l8fFphKG9lKX12YXIgSz10eXBlb2YgVGV4dERlY29kZXIhPVwidW5kZWZpbmVkXCI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDA7ZnVuY3Rpb24gWihZLG9lLEllKXtvZT4+Pj0wO2Zvcih2YXIgWWU9b2UrSWUsd3Q9b2U7WVt3dF0mJiEod3Q+PVllKTspKyt3dDtpZih3dC1vZT4xNiYmWS5idWZmZXImJkspcmV0dXJuIEsuZGVjb2RlKFkuc3ViYXJyYXkob2Usd3QpKTtmb3IodmFyIGt0PVwiXCI7b2U8d3Q7KXt2YXIgR2U9WVtvZSsrXTtpZighKEdlJjEyOCkpe2t0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKEdlKTtjb250aW51ZX12YXIgQmU9WVtvZSsrXSY2MztpZigoR2UmMjI0KT09MTkyKXtrdCs9U3RyaW5nLmZyb21DaGFyQ29kZSgoR2UmMzEpPDw2fEJlKTtjb250aW51ZX12YXIgUHQ9WVtvZSsrXSY2MztpZigoR2UmMjQwKT09MjI0P0dlPShHZSYxNSk8PDEyfEJlPDw2fFB0OkdlPShHZSY3KTw8MTh8QmU8PDEyfFB0PDw2fFlbb2UrK10mNjMsR2U8NjU1MzYpa3QrPVN0cmluZy5mcm9tQ2hhckNvZGUoR2UpO2Vsc2V7dmFyIGxhPUdlLTY1NTM2O2t0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGxhPj4xMCw1NjMyMHxsYSYxMDIzKX19cmV0dXJuIGt0fWZ1bmN0aW9uIEooWSxvZSl7cmV0dXJuIFk+Pj49MCxZP1ooaWUsWSxvZSk6XCJcIn1mdW5jdGlvbiBlZShZLG9lLEllLFllKXtpZihJZT4+Pj0wLCEoWWU+MCkpcmV0dXJuIDA7Zm9yKHZhciB3dD1JZSxrdD1JZStZZS0xLEdlPTA7R2U8WS5sZW5ndGg7KytHZSl7dmFyIEJlPVkuY2hhckNvZGVBdChHZSk7aWYoQmU+PTU1Mjk2JiZCZTw9NTczNDMpe3ZhciBQdD1ZLmNoYXJDb2RlQXQoKytHZSk7QmU9NjU1MzYrKChCZSYxMDIzKTw8MTApfFB0JjEwMjN9aWYoQmU8PTEyNyl7aWYoSWU+PWt0KWJyZWFrO29lW0llKys+Pj4wXT1CZX1lbHNlIGlmKEJlPD0yMDQ3KXtpZihJZSsxPj1rdClicmVhaztvZVtJZSsrPj4+MF09MTkyfEJlPj42LG9lW0llKys+Pj4wXT0xMjh8QmUmNjN9ZWxzZSBpZihCZTw9NjU1MzUpe2lmKEllKzI+PWt0KWJyZWFrO29lW0llKys+Pj4wXT0yMjR8QmU+PjEyLG9lW0llKys+Pj4wXT0xMjh8QmU+PjYmNjMsb2VbSWUrKz4+PjBdPTEyOHxCZSY2M31lbHNle2lmKEllKzM+PWt0KWJyZWFrO29lW0llKys+Pj4wXT0yNDB8QmU+PjE4LG9lW0llKys+Pj4wXT0xMjh8QmU+PjEyJjYzLG9lW0llKys+Pj4wXT0xMjh8QmU+PjYmNjMsb2VbSWUrKz4+PjBdPTEyOHxCZSY2M319cmV0dXJuIG9lW0llPj4+MF09MCxJZS13dH1mdW5jdGlvbiBhZShZLG9lLEllKXtyZXR1cm4gZWUoWSxpZSxvZSxJZSl9dmFyIHRlLHNlLGllLHZlLHVlLHllLGtlLFNlLExlO2Z1bmN0aW9uIFVlKFkpe3RlPVkscy5IRUFQOD1zZT1uZXcgSW50OEFycmF5KFkpLHMuSEVBUDE2PXZlPW5ldyBJbnQxNkFycmF5KFkpLHMuSEVBUDMyPXllPW5ldyBJbnQzMkFycmF5KFkpLHMuSEVBUFU4PWllPW5ldyBVaW50OEFycmF5KFkpLHMuSEVBUFUxNj11ZT1uZXcgVWludDE2QXJyYXkoWSkscy5IRUFQVTMyPWtlPW5ldyBVaW50MzJBcnJheShZKSxzLkhFQVBGMzI9U2U9bmV3IEZsb2F0MzJBcnJheShZKSxzLkhFQVBGNjQ9TGU9bmV3IEZsb2F0NjRBcnJheShZKX12YXIgbXQ9cy5JTklUSUFMX01FTU9SWXx8MTY3NzcyMTYsc3QsdHQ9W10sbnQ9W10sUmU9W10sZ3Q9ITE7ZnVuY3Rpb24gR24oKXtyZXR1cm4gTX1mdW5jdGlvbiBPdCgpe2lmKHMucHJlUnVuKWZvcih0eXBlb2Ygcy5wcmVSdW49PVwiZnVuY3Rpb25cIiYmKHMucHJlUnVuPVtzLnByZVJ1bl0pO3MucHJlUnVuLmxlbmd0aDspRm4ocy5wcmVSdW4uc2hpZnQoKSk7dnIodHQpfWZ1bmN0aW9uIGlhKCl7Z3Q9ITAsdnIobnQpfWZ1bmN0aW9uIHVuKCl7aWYocy5wb3N0UnVuKWZvcih0eXBlb2Ygcy5wb3N0UnVuPT1cImZ1bmN0aW9uXCImJihzLnBvc3RSdW49W3MucG9zdFJ1bl0pO3MucG9zdFJ1bi5sZW5ndGg7KSRuKHMucG9zdFJ1bi5zaGlmdCgpKTt2cihSZSl9ZnVuY3Rpb24gRm4oWSl7dHQudW5zaGlmdChZKX1mdW5jdGlvbiBvYShZKXtudC51bnNoaWZ0KFkpfWZ1bmN0aW9uICRuKFkpe1JlLnVuc2hpZnQoWSl9dmFyIHV0PTAsRG49bnVsbCxIbj1udWxsO2Z1bmN0aW9uIHhyKFkpe3V0Kysscy5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZzLm1vbml0b3JSdW5EZXBlbmRlbmNpZXModXQpfWZ1bmN0aW9uIG1sKFkpe2lmKHV0LS0scy5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZzLm1vbml0b3JSdW5EZXBlbmRlbmNpZXModXQpLHV0PT0wJiYoRG4hPT1udWxsJiYoY2xlYXJJbnRlcnZhbChEbiksRG49bnVsbCksSG4pKXt2YXIgb2U9SG47SG49bnVsbCxvZSgpfX1mdW5jdGlvbiBaYShZKXtzLm9uQWJvcnQmJnMub25BYm9ydChZKSxZPVwiQWJvcnRlZChcIitZK1wiKVwiLEQoWSksVT0hMCxIPTEsWSs9XCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCI7dmFyIG9lPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoWSk7dGhyb3cgbyhvZSksb2V9dmFyIFdwPVwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiO2Z1bmN0aW9uIElhKFkpe3JldHVybiBZLnN0YXJ0c1dpdGgoV3ApfWZ1bmN0aW9uIFVyKFkpe3JldHVybiBZLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpfXZhciBKdDtKdD1cInRmanMtYmFja2VuZC13YXNtLndhc21cIixJYShKdCl8fChKdD1iKEp0KSk7ZnVuY3Rpb24gSGQoWSl7dHJ5e2lmKFk9PUp0JiZTKXJldHVybiBuZXcgVWludDhBcnJheShTKTtpZih2KXJldHVybiB2KFkpO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWNhdGNoKG9lKXtaYShvZSl9fWZ1bmN0aW9uIFNnKCl7aWYoIVMmJihofHxtKSl7aWYodHlwZW9mIGZldGNoPT1cImZ1bmN0aW9uXCImJiFVcihKdCkpcmV0dXJuIGZldGNoKEp0LHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKGZ1bmN0aW9uKFkpe2lmKCFZLm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIitKdCtcIidcIjtyZXR1cm4gWS5hcnJheUJ1ZmZlcigpfSkuY2F0Y2goZnVuY3Rpb24oKXtyZXR1cm4gSGQoSnQpfSk7aWYoeClyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oWSxvZSl7eChKdCxmdW5jdGlvbihJZSl7WShuZXcgVWludDhBcnJheShJZSkpfSxvZSl9KX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpe3JldHVybiBIZChKdCl9KX1mdW5jdGlvbiBOZygpe3ZhciBZPXtlbnY6QnAsd2FzaV9zbmFwc2hvdF9wcmV2aWV3MTpCcH07ZnVuY3Rpb24gb2UoR2UsQmUpe3ZhciBQdD1HZS5leHBvcnRzO3MuYXNtPVB0LEI9cy5hc20ubWVtb3J5LFVlKEIuYnVmZmVyKSxzdD1zLmFzbS5fX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlLG9hKHMuYXNtLl9fd2FzbV9jYWxsX2N0b3JzKSxtbChcIndhc20taW5zdGFudGlhdGVcIil9eHIoXCJ3YXNtLWluc3RhbnRpYXRlXCIpO2Z1bmN0aW9uIEllKEdlKXtvZShHZS5pbnN0YW5jZSl9ZnVuY3Rpb24gWWUoR2Upe3JldHVybiBTZygpLnRoZW4oZnVuY3Rpb24oQmUpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShCZSxZKX0pLnRoZW4oZnVuY3Rpb24oQmUpe3JldHVybiBCZX0pLnRoZW4oR2UsZnVuY3Rpb24oQmUpe0QoXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIitCZSksWmEoQmUpfSl9ZnVuY3Rpb24gd3QoKXtyZXR1cm4hUyYmdHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nPT1cImZ1bmN0aW9uXCImJiFJYShKdCkmJiFVcihKdCkmJiFmJiZ0eXBlb2YgZmV0Y2g9PVwiZnVuY3Rpb25cIj9mZXRjaChKdCx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbihmdW5jdGlvbihHZSl7dmFyIEJlPVdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKEdlLFkpO3JldHVybiBCZS50aGVuKEllLGZ1bmN0aW9uKFB0KXtyZXR1cm4gRChcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIitQdCksRChcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpLFllKEllKX0pfSk6WWUoSWUpfWlmKHMuaW5zdGFudGlhdGVXYXNtKXRyeXt2YXIga3Q9cy5pbnN0YW50aWF0ZVdhc20oWSxvZSk7cmV0dXJuIGt0fWNhdGNoKEdlKXtEKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrR2UpLG8oR2UpfXJldHVybiB3dCgpLmNhdGNoKG8pLHt9fXZhciBSayxHcjtmdW5jdGlvbiBmbChZKXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPVwiUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdChcIitZK1wiKVwiLHRoaXMuc3RhdHVzPVl9ZnVuY3Rpb24gdnIoWSl7Zm9yKDtZLmxlbmd0aD4wOylZLnNoaWZ0KCkocyl9ZnVuY3Rpb24gVGcoKXtaYShcIlwiKX1mdW5jdGlvbiBqZCgpe3JldHVybiA0Mjk0OTAxNzYwfWZ1bmN0aW9uIFVzKCl7cmV0dXJuIGpkKCl9ZnVuY3Rpb24gQ2coWSxvZSxJZSl7aWUuY29weVdpdGhpbihZPj4+MCxvZT4+PjAsb2UrSWU+Pj4wKX1mdW5jdGlvbiBxZChZKXt0cnl7cmV0dXJuIEIuZ3JvdyhZLXRlLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNiksVWUoQi5idWZmZXIpLDF9Y2F0Y2gob2Upe319ZnVuY3Rpb24gZ2woWSl7dmFyIG9lPWllLmxlbmd0aDtZPVk+Pj4wO3ZhciBJZT1qZCgpO2lmKFk+SWUpcmV0dXJuITE7bGV0IFllPShQdCxsYSk9PlB0KyhsYS1QdCVsYSklbGE7Zm9yKHZhciB3dD0xO3d0PD00O3d0Kj0yKXt2YXIga3Q9b2UqKDErLjIvd3QpO2t0PU1hdGgubWluKGt0LFkrMTAwNjYzMjk2KTt2YXIgR2U9TWF0aC5taW4oSWUsWWUoTWF0aC5tYXgoWSxrdCksNjU1MzYpKSxCZT1xZChHZSk7aWYoQmUpcmV0dXJuITB9cmV0dXJuITF9dmFyIGduPXt2YXJhcmdzOnZvaWQgMCxnZXQ6ZnVuY3Rpb24oKXtnbi52YXJhcmdzKz00O3ZhciBZPXllW2duLnZhcmFyZ3MtND4+PjJdO3JldHVybiBZfSxnZXRTdHI6ZnVuY3Rpb24oWSl7dmFyIG9lPUooWSk7cmV0dXJuIG9lfX07ZnVuY3Rpb24gS2QoWSl7cmV0dXJuIDUyfWZ1bmN0aW9uIEVnKFksb2UsSWUsWWUsd3Qpe3JldHVybiA3MH12YXIgX2c9W251bGwsW10sW11dO2Z1bmN0aW9uIE1rKFksb2Upe3ZhciBJZT1fZ1tZXTtvZT09PTB8fG9lPT09MTA/KChZPT09MT9GOkQpKFooSWUsMCkpLEllLmxlbmd0aD0wKTpJZS5wdXNoKG9lKX1mdW5jdGlvbiBPayhZLG9lLEllLFllKXtmb3IodmFyIHd0PTAsa3Q9MDtrdDxJZTtrdCsrKXt2YXIgR2U9a2Vbb2U+Pj4yXSxCZT1rZVtvZSs0Pj4+Ml07b2UrPTg7Zm9yKHZhciBQdD0wO1B0PEJlO1B0KyspTWsoWSxpZVtHZStQdD4+PjBdKTt3dCs9QmV9cmV0dXJuIGtlW1llPj4+Ml09d3QsMH1mdW5jdGlvbiBYZChZKXt2YXIgb2U9c1tcIl9cIitZXTtyZXR1cm4gb2V9ZnVuY3Rpb24gR3MoWSxvZSl7c2Uuc2V0KFksb2U+Pj4wKX1mdW5jdGlvbiBBZyhZLG9lLEllLFllLHd0KXt2YXIga3Q9e3N0cmluZzpSbj0+e3ZhciBqcj0wO2lmKFJuIT1udWxsJiZSbiE9PTApe3ZhciBkaD0oUm4ubGVuZ3RoPDwyKSsxO2pyPWpwKGRoKSxhZShSbixqcixkaCl9cmV0dXJuIGpyfSxhcnJheTpSbj0+e3ZhciBqcj1qcChSbi5sZW5ndGgpO3JldHVybiBHcyhSbixqciksanJ9fTtmdW5jdGlvbiBHZShSbil7cmV0dXJuIG9lPT09XCJzdHJpbmdcIj9KKFJuKTpvZT09PVwiYm9vbGVhblwiPyEhUm46Um59dmFyIEJlPVhkKFkpLFB0PVtdLGxhPTA7aWYoWWUpZm9yKHZhciB3cj0wO3dyPFllLmxlbmd0aDt3cisrKXt2YXIgY2g9a3RbSWVbd3JdXTtjaD8obGE9PT0wJiYobGE9bGgoKSksUHRbd3JdPWNoKFllW3dyXSkpOlB0W3dyXT1ZZVt3cl19dmFyIHFwPUJlLmFwcGx5KG51bGwsUHQpO2Z1bmN0aW9uIFF5KFJuKXtyZXR1cm4gbGEhPT0wJiZ1aChsYSksR2UoUm4pfXJldHVybiBxcD1ReShxcCkscXB9ZnVuY3Rpb24gRmcoWSxvZSxJZSxZZSl7SWU9SWV8fFtdO3ZhciB3dD1JZS5ldmVyeShHZT0+R2U9PT1cIm51bWJlclwifHxHZT09PVwiYm9vbGVhblwiKSxrdD1vZSE9PVwic3RyaW5nXCI7cmV0dXJuIGt0JiZ3dCYmIVllP1hkKFkpOmZ1bmN0aW9uKCl7cmV0dXJuIEFnKFksb2UsSWUsYXJndW1lbnRzLFllKX19dmFyIEJwPXthYm9ydDpUZyxlbXNjcmlwdGVuX2dldF9oZWFwX21heDpVcyxlbXNjcmlwdGVuX21lbWNweV9iaWc6Q2csZW1zY3JpcHRlbl9yZXNpemVfaGVhcDpnbCxmZF9jbG9zZTpLZCxmZF9zZWVrOkVnLGZkX3dyaXRlOk9rfSwkZz1OZygpLFlkPXMuX19fd2FzbV9jYWxsX2N0b3JzPWZ1bmN0aW9uKCl7cmV0dXJuKFlkPXMuX19fd2FzbV9jYWxsX2N0b3JzPXMuYXNtLl9fd2FzbV9jYWxsX2N0b3JzKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFpkPXMuX2luaXQ9ZnVuY3Rpb24oKXtyZXR1cm4oWmQ9cy5faW5pdD1zLmFzbS5pbml0KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LERnPXMuX2luaXRfd2l0aF90aHJlYWRzX2NvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKERnPXMuX2luaXRfd2l0aF90aHJlYWRzX2NvdW50PXMuYXNtLmluaXRfd2l0aF90aHJlYWRzX2NvdW50KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEpkPXMuX2dldF90aHJlYWRzX2NvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKEpkPXMuX2dldF90aHJlYWRzX2NvdW50PXMuYXNtLmdldF90aHJlYWRzX2NvdW50KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFJnPXMuX3JlZ2lzdGVyX3RlbnNvcj1mdW5jdGlvbigpe3JldHVybihSZz1zLl9yZWdpc3Rlcl90ZW5zb3I9cy5hc20ucmVnaXN0ZXJfdGVuc29yKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEFlPXMuX2Rpc3Bvc2VfZGF0YT1mdW5jdGlvbigpe3JldHVybihBZT1zLl9kaXNwb3NlX2RhdGE9cy5hc20uZGlzcG9zZV9kYXRhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFZwPXMuX2Rpc3Bvc2U9ZnVuY3Rpb24oKXtyZXR1cm4oVnA9cy5fZGlzcG9zZT1zLmFzbS5kaXNwb3NlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE1nPXMuX0Ficz1mdW5jdGlvbigpe3JldHVybihNZz1zLl9BYnM9cy5hc20uQWJzKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFFkPXMuX0Fjb3M9ZnVuY3Rpb24oKXtyZXR1cm4oUWQ9cy5fQWNvcz1zLmFzbS5BY29zKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGJsPXMuX0Fjb3NoPWZ1bmN0aW9uKCl7cmV0dXJuKGJsPXMuX0Fjb3NoPXMuYXNtLkFjb3NoKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE9nPXMuX0FkZD1mdW5jdGlvbigpe3JldHVybihPZz1zLl9BZGQ9cy5hc20uQWRkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFBnPXMuX0FkZE49ZnVuY3Rpb24oKXtyZXR1cm4oUGc9cy5fQWRkTj1zLmFzbS5BZGROKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LExnPXMuX0FsbD1mdW5jdGlvbigpe3JldHVybihMZz1zLl9BbGw9cy5hc20uQWxsKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHpnPXMuX0FueT1mdW5jdGlvbigpe3JldHVybih6Zz1zLl9Bbnk9cy5hc20uQW55KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFdnPXMuX0FyZ01heD1mdW5jdGlvbigpe3JldHVybihXZz1zLl9BcmdNYXg9cy5hc20uQXJnTWF4KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGVoPXMuX0FyZ01pbj1mdW5jdGlvbigpe3JldHVybihlaD1zLl9BcmdNaW49cy5hc20uQXJnTWluKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHRoPXMuX0FzaW49ZnVuY3Rpb24oKXtyZXR1cm4odGg9cy5fQXNpbj1zLmFzbS5Bc2luKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEJnPXMuX0FzaW5oPWZ1bmN0aW9uKCl7cmV0dXJuKEJnPXMuX0FzaW5oPXMuYXNtLkFzaW5oKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFZnPXMuX0F0YW49ZnVuY3Rpb24oKXtyZXR1cm4oVmc9cy5fQXRhbj1zLmFzbS5BdGFuKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFVnPXMuX0F0YW4yPWZ1bmN0aW9uKCl7cmV0dXJuKFVnPXMuX0F0YW4yPXMuYXNtLkF0YW4yKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFVwPXMuX0F0YW5oPWZ1bmN0aW9uKCl7cmV0dXJuKFVwPXMuX0F0YW5oPXMuYXNtLkF0YW5oKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEdnPXMuX0F2Z1Bvb2w9ZnVuY3Rpb24oKXtyZXR1cm4oR2c9cy5fQXZnUG9vbD1zLmFzbS5BdmdQb29sKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEhnPXMuX0F2Z1Bvb2wzRD1mdW5jdGlvbigpe3JldHVybihIZz1zLl9BdmdQb29sM0Q9cy5hc20uQXZnUG9vbDNEKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGpnPXMuX0F2Z1Bvb2wzREdyYWQ9ZnVuY3Rpb24oKXtyZXR1cm4oamc9cy5fQXZnUG9vbDNER3JhZD1zLmFzbS5BdmdQb29sM0RHcmFkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEhzPXMuX0F2Z1Bvb2xHcmFkPWZ1bmN0aW9uKCl7cmV0dXJuKEhzPXMuX0F2Z1Bvb2xHcmFkPXMuYXNtLkF2Z1Bvb2xHcmFkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHFnPXMuX0JhdGNoTWF0TXVsPWZ1bmN0aW9uKCl7cmV0dXJuKHFnPXMuX0JhdGNoTWF0TXVsPXMuYXNtLkJhdGNoTWF0TXVsKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEtnPXMuX0JpbmNvdW50PWZ1bmN0aW9uKCl7cmV0dXJuKEtnPXMuX0JpbmNvdW50PXMuYXNtLkJpbmNvdW50KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG5oPXMuX0JpdHdpc2VBbmQ9ZnVuY3Rpb24oKXtyZXR1cm4obmg9cy5fQml0d2lzZUFuZD1zLmFzbS5CaXR3aXNlQW5kKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFhnPXMuX0NlaWw9ZnVuY3Rpb24oKXtyZXR1cm4oWGc9cy5fQ2VpbD1zLmFzbS5DZWlsKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEdwPXMuX0NsaXBCeVZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuKEdwPXMuX0NsaXBCeVZhbHVlPXMuYXNtLkNsaXBCeVZhbHVlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFlnPXMuX0NvbnYyRD1mdW5jdGlvbigpe3JldHVybihZZz1zLl9Db252MkQ9cy5hc20uQ29udjJEKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFpnPXMuX0NvbnYyREJhY2twcm9wSW5wdXQ9ZnVuY3Rpb24oKXtyZXR1cm4oWmc9cy5fQ29udjJEQmFja3Byb3BJbnB1dD1zLmFzbS5Db252MkRCYWNrcHJvcElucHV0KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEpnPXMuX0NvbnYzRD1mdW5jdGlvbigpe3JldHVybihKZz1zLl9Db252M0Q9cy5hc20uQ29udjNEKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEhyPXMuX0NvbnYzREJhY2twcm9wRmlsdGVyVjI9ZnVuY3Rpb24oKXtyZXR1cm4oSHI9cy5fQ29udjNEQmFja3Byb3BGaWx0ZXJWMj1zLmFzbS5Db252M0RCYWNrcHJvcEZpbHRlclYyKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEhwPXMuX0NvbnYzREJhY2twcm9wSW5wdXRWMj1mdW5jdGlvbigpe3JldHVybihIcD1zLl9Db252M0RCYWNrcHJvcElucHV0VjI9cy5hc20uQ29udjNEQmFja3Byb3BJbnB1dFYyKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFFnPXMuX0Nvcz1mdW5jdGlvbigpe3JldHVybihRZz1zLl9Db3M9cy5hc20uQ29zKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGViPXMuX0Nvc2g9ZnVuY3Rpb24oKXtyZXR1cm4oZWI9cy5fQ29zaD1zLmFzbS5Db3NoKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHRiPXMuX0Nyb3BBbmRSZXNpemU9ZnVuY3Rpb24oKXtyZXR1cm4odGI9cy5fQ3JvcEFuZFJlc2l6ZT1zLmFzbS5Dcm9wQW5kUmVzaXplKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG5iPXMuX0N1bXByb2Q9ZnVuY3Rpb24oKXtyZXR1cm4obmI9cy5fQ3VtcHJvZD1zLmFzbS5DdW1wcm9kKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGFoPXMuX0N1bXN1bT1mdW5jdGlvbigpe3JldHVybihhaD1zLl9DdW1zdW09cy5hc20uQ3Vtc3VtKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHJoPXMuX0RlbnNlQmluY291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4ocmg9cy5fRGVuc2VCaW5jb3VudD1zLmFzbS5EZW5zZUJpbmNvdW50KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGFiPXMuX0RlcHRoVG9TcGFjZT1mdW5jdGlvbigpe3JldHVybihhYj1zLl9EZXB0aFRvU3BhY2U9cy5hc20uRGVwdGhUb1NwYWNlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHJiPXMuX0RlcHRod2lzZUNvbnYyZE5hdGl2ZT1mdW5jdGlvbigpe3JldHVybihyYj1zLl9EZXB0aHdpc2VDb252MmROYXRpdmU9cy5hc20uRGVwdGh3aXNlQ29udjJkTmF0aXZlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHNoPXMuX0RpYWc9ZnVuY3Rpb24oKXtyZXR1cm4oc2g9cy5fRGlhZz1zLmFzbS5EaWFnKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGloPXMuX0RpbGF0aW9uMkQ9ZnVuY3Rpb24oKXtyZXR1cm4oaWg9cy5fRGlsYXRpb24yRD1zLmFzbS5EaWxhdGlvbjJEKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHNiPXMuX0RpbGF0aW9uMkRCYWNrcHJvcEZpbHRlcj1mdW5jdGlvbigpe3JldHVybihzYj1zLl9EaWxhdGlvbjJEQmFja3Byb3BGaWx0ZXI9cy5hc20uRGlsYXRpb24yREJhY2twcm9wRmlsdGVyKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGliPXMuX0RpbGF0aW9uMkRCYWNrcHJvcElucHV0PWZ1bmN0aW9uKCl7cmV0dXJuKGliPXMuX0RpbGF0aW9uMkRCYWNrcHJvcElucHV0PXMuYXNtLkRpbGF0aW9uMkRCYWNrcHJvcElucHV0KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG9iPXMuX0VsdT1mdW5jdGlvbigpe3JldHVybihvYj1zLl9FbHU9cy5hc20uRWx1KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGxiPXMuX0VsdUdyYWQ9ZnVuY3Rpb24oKXtyZXR1cm4obGI9cy5fRWx1R3JhZD1zLmFzbS5FbHVHcmFkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG9oPXMuX0VxdWFsPWZ1bmN0aW9uKCl7cmV0dXJuKG9oPXMuX0VxdWFsPXMuYXNtLkVxdWFsKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFBrPXMuX0VyZj1mdW5jdGlvbigpe3JldHVybihQaz1zLl9FcmY9cy5hc20uRXJmKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHViPXMuX0V4cD1mdW5jdGlvbigpe3JldHVybih1Yj1zLl9FeHA9cy5hc20uRXhwKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHBiPXMuX0V4cG0xPWZ1bmN0aW9uKCl7cmV0dXJuKHBiPXMuX0V4cG0xPXMuYXNtLkV4cG0xKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGNiPXMuX0ZsaXBMZWZ0UmlnaHQ9ZnVuY3Rpb24oKXtyZXR1cm4oY2I9cy5fRmxpcExlZnRSaWdodD1zLmFzbS5GbGlwTGVmdFJpZ2h0KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGRiPXMuX0Zsb29yPWZ1bmN0aW9uKCl7cmV0dXJuKGRiPXMuX0Zsb29yPXMuYXNtLkZsb29yKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGhiPXMuX0Zsb29yRGl2PWZ1bmN0aW9uKCl7cmV0dXJuKGhiPXMuX0Zsb29yRGl2PXMuYXNtLkZsb29yRGl2KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG1iPXMuX0Z1c2VkQmF0Y2hOb3JtPWZ1bmN0aW9uKCl7cmV0dXJuKG1iPXMuX0Z1c2VkQmF0Y2hOb3JtPXMuYXNtLkZ1c2VkQmF0Y2hOb3JtKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGZiPXMuX0Z1c2VkQ29udjJEPWZ1bmN0aW9uKCl7cmV0dXJuKGZiPXMuX0Z1c2VkQ29udjJEPXMuYXNtLkZ1c2VkQ29udjJEKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGdiPXMuX0Z1c2VkRGVwdGh3aXNlQ29udjJEPWZ1bmN0aW9uKCl7cmV0dXJuKGdiPXMuX0Z1c2VkRGVwdGh3aXNlQ29udjJEPXMuYXNtLkZ1c2VkRGVwdGh3aXNlQ29udjJEKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGJiPXMuX0dhdGhlcj1mdW5jdGlvbigpe3JldHVybihiYj1zLl9HYXRoZXI9cy5hc20uR2F0aGVyKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHliPXMuX0dhdGhlck5kPWZ1bmN0aW9uKCl7cmV0dXJuKHliPXMuX0dhdGhlck5kPXMuYXNtLkdhdGhlck5kKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHhiPXMuX0dyZWF0ZXI9ZnVuY3Rpb24oKXtyZXR1cm4oeGI9cy5fR3JlYXRlcj1zLmFzbS5HcmVhdGVyKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHZiPXMuX0dyZWF0ZXJFcXVhbD1mdW5jdGlvbigpe3JldHVybih2Yj1zLl9HcmVhdGVyRXF1YWw9cy5hc20uR3JlYXRlckVxdWFsKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHdiPXMuX0lzRmluaXRlPWZ1bmN0aW9uKCl7cmV0dXJuKHdiPXMuX0lzRmluaXRlPXMuYXNtLklzRmluaXRlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGtiPXMuX0lzSW5mPWZ1bmN0aW9uKCl7cmV0dXJuKGtiPXMuX0lzSW5mPXMuYXNtLklzSW5mKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEliPXMuX0lzTmFuPWZ1bmN0aW9uKCl7cmV0dXJuKEliPXMuX0lzTmFuPXMuYXNtLklzTmFuKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFNiPXMuX0xSTj1mdW5jdGlvbigpe3JldHVybihTYj1zLl9MUk49cy5hc20uTFJOKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE5iPXMuX0xSTkdyYWQ9ZnVuY3Rpb24oKXtyZXR1cm4oTmI9cy5fTFJOR3JhZD1zLmFzbS5MUk5HcmFkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFRiPXMuX0xlYWt5UmVsdT1mdW5jdGlvbigpe3JldHVybihUYj1zLl9MZWFreVJlbHU9cy5hc20uTGVha3lSZWx1KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LENiPXMuX0xlc3M9ZnVuY3Rpb24oKXtyZXR1cm4oQ2I9cy5fTGVzcz1zLmFzbS5MZXNzKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEViPXMuX0xlc3NFcXVhbD1mdW5jdGlvbigpe3JldHVybihFYj1zLl9MZXNzRXF1YWw9cy5hc20uTGVzc0VxdWFsKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LF9iPXMuX0xpblNwYWNlPWZ1bmN0aW9uKCl7cmV0dXJuKF9iPXMuX0xpblNwYWNlPXMuYXNtLkxpblNwYWNlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEFiPXMuX0xvZz1mdW5jdGlvbigpe3JldHVybihBYj1zLl9Mb2c9cy5hc20uTG9nKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEZiPXMuX0xvZzFwPWZ1bmN0aW9uKCl7cmV0dXJuKEZiPXMuX0xvZzFwPXMuYXNtLkxvZzFwKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LCRiPXMuX0xvZ2ljYWxBbmQ9ZnVuY3Rpb24oKXtyZXR1cm4oJGI9cy5fTG9naWNhbEFuZD1zLmFzbS5Mb2dpY2FsQW5kKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LERiPXMuX0xvZ2ljYWxOb3Q9ZnVuY3Rpb24oKXtyZXR1cm4oRGI9cy5fTG9naWNhbE5vdD1zLmFzbS5Mb2dpY2FsTm90KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFJiPXMuX0xvZ2ljYWxPcj1mdW5jdGlvbigpe3JldHVybihSYj1zLl9Mb2dpY2FsT3I9cy5hc20uTG9naWNhbE9yKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE1iPXMuX0xvZ2ljYWxYb3I9ZnVuY3Rpb24oKXtyZXR1cm4oTWI9cy5fTG9naWNhbFhvcj1zLmFzbS5Mb2dpY2FsWG9yKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE9iPXMuX01heD1mdW5jdGlvbigpe3JldHVybihPYj1zLl9NYXg9cy5hc20uTWF4KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFBiPXMuX01heFBvb2w9ZnVuY3Rpb24oKXtyZXR1cm4oUGI9cy5fTWF4UG9vbD1zLmFzbS5NYXhQb29sKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LExiPXMuX01heFBvb2wzRD1mdW5jdGlvbigpe3JldHVybihMYj1zLl9NYXhQb29sM0Q9cy5hc20uTWF4UG9vbDNEKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHpiPXMuX01heFBvb2wzREdyYWQ9ZnVuY3Rpb24oKXtyZXR1cm4oemI9cy5fTWF4UG9vbDNER3JhZD1zLmFzbS5NYXhQb29sM0RHcmFkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFdiPXMuX01heFBvb2xHcmFkPWZ1bmN0aW9uKCl7cmV0dXJuKFdiPXMuX01heFBvb2xHcmFkPXMuYXNtLk1heFBvb2xHcmFkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEJiPXMuX01heFBvb2xXaXRoQXJnbWF4PWZ1bmN0aW9uKCl7cmV0dXJuKEJiPXMuX01heFBvb2xXaXRoQXJnbWF4PXMuYXNtLk1heFBvb2xXaXRoQXJnbWF4KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFZiPXMuX01heGltdW09ZnVuY3Rpb24oKXtyZXR1cm4oVmI9cy5fTWF4aW11bT1zLmFzbS5NYXhpbXVtKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFViPXMuX01lYW49ZnVuY3Rpb24oKXtyZXR1cm4oVWI9cy5fTWVhbj1zLmFzbS5NZWFuKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEdiPXMuX01pbj1mdW5jdGlvbigpe3JldHVybihHYj1zLl9NaW49cy5hc20uTWluKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEhiPXMuX01pbmltdW09ZnVuY3Rpb24oKXtyZXR1cm4oSGI9cy5fTWluaW11bT1zLmFzbS5NaW5pbXVtKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGpiPXMuX01pcnJvclBhZD1mdW5jdGlvbigpe3JldHVybihqYj1zLl9NaXJyb3JQYWQ9cy5hc20uTWlycm9yUGFkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHFiPXMuX01vZD1mdW5jdGlvbigpe3JldHVybihxYj1zLl9Nb2Q9cy5hc20uTW9kKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEtiPXMuX011bHRpbm9taWFsPWZ1bmN0aW9uKCl7cmV0dXJuKEtiPXMuX011bHRpbm9taWFsPXMuYXNtLk11bHRpbm9taWFsKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFhiPXMuX011bHRpcGx5PWZ1bmN0aW9uKCl7cmV0dXJuKFhiPXMuX011bHRpcGx5PXMuYXNtLk11bHRpcGx5KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFliPXMuX05lZz1mdW5jdGlvbigpe3JldHVybihZYj1zLl9OZWc9cy5hc20uTmVnKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFpiPXMuX05vbk1heFN1cHByZXNzaW9uVjM9ZnVuY3Rpb24oKXtyZXR1cm4oWmI9cy5fTm9uTWF4U3VwcHJlc3Npb25WMz1zLmFzbS5Ob25NYXhTdXBwcmVzc2lvblYzKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEpiPXMuX05vbk1heFN1cHByZXNzaW9uVjQ9ZnVuY3Rpb24oKXtyZXR1cm4oSmI9cy5fTm9uTWF4U3VwcHJlc3Npb25WND1zLmFzbS5Ob25NYXhTdXBwcmVzc2lvblY0KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFFiPXMuX05vbk1heFN1cHByZXNzaW9uVjU9ZnVuY3Rpb24oKXtyZXR1cm4oUWI9cy5fTm9uTWF4U3VwcHJlc3Npb25WNT1zLmFzbS5Ob25NYXhTdXBwcmVzc2lvblY1KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGV5PXMuX05vdEVxdWFsPWZ1bmN0aW9uKCl7cmV0dXJuKGV5PXMuX05vdEVxdWFsPXMuYXNtLk5vdEVxdWFsKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHR5PXMuX09uZUhvdD1mdW5jdGlvbigpe3JldHVybih0eT1zLl9PbmVIb3Q9cy5hc20uT25lSG90KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG55PXMuX1BhZFYyPWZ1bmN0aW9uKCl7cmV0dXJuKG55PXMuX1BhZFYyPXMuYXNtLlBhZFYyKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGF5PXMuX1Bvdz1mdW5jdGlvbigpe3JldHVybihheT1zLl9Qb3c9cy5hc20uUG93KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHJ5PXMuX1ByZWx1PWZ1bmN0aW9uKCl7cmV0dXJuKHJ5PXMuX1ByZWx1PXMuYXNtLlByZWx1KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHN5PXMuX1Byb2Q9ZnVuY3Rpb24oKXtyZXR1cm4oc3k9cy5fUHJvZD1zLmFzbS5Qcm9kKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGl5PXMuX1JlYWxEaXY9ZnVuY3Rpb24oKXtyZXR1cm4oaXk9cy5fUmVhbERpdj1zLmFzbS5SZWFsRGl2KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG95PXMuX1JlY2lwcm9jYWw9ZnVuY3Rpb24oKXtyZXR1cm4ob3k9cy5fUmVjaXByb2NhbD1zLmFzbS5SZWNpcHJvY2FsKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGx5PXMuX1JlbHU9ZnVuY3Rpb24oKXtyZXR1cm4obHk9cy5fUmVsdT1zLmFzbS5SZWx1KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHV5PXMuX1JlbHU2PWZ1bmN0aW9uKCl7cmV0dXJuKHV5PXMuX1JlbHU2PXMuYXNtLlJlbHU2KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHB5PXMuX1Jlc2l6ZUJpbGluZWFyPWZ1bmN0aW9uKCl7cmV0dXJuKHB5PXMuX1Jlc2l6ZUJpbGluZWFyPXMuYXNtLlJlc2l6ZUJpbGluZWFyKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGN5PXMuX1Jlc2l6ZUJpbGluZWFyR3JhZD1mdW5jdGlvbigpe3JldHVybihjeT1zLl9SZXNpemVCaWxpbmVhckdyYWQ9cy5hc20uUmVzaXplQmlsaW5lYXJHcmFkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGR5PXMuX1Jlc2l6ZU5lYXJlc3ROZWlnaGJvcj1mdW5jdGlvbigpe3JldHVybihkeT1zLl9SZXNpemVOZWFyZXN0TmVpZ2hib3I9cy5hc20uUmVzaXplTmVhcmVzdE5laWdoYm9yKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGh5PXMuX1Jlc2l6ZU5lYXJlc3ROZWlnaGJvckdyYWQ9ZnVuY3Rpb24oKXtyZXR1cm4oaHk9cy5fUmVzaXplTmVhcmVzdE5laWdoYm9yR3JhZD1zLmFzbS5SZXNpemVOZWFyZXN0TmVpZ2hib3JHcmFkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG15PXMuX1JldmVyc2U9ZnVuY3Rpb24oKXtyZXR1cm4obXk9cy5fUmV2ZXJzZT1zLmFzbS5SZXZlcnNlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGZ5PXMuX1JvdGF0ZVdpdGhPZmZzZXQ9ZnVuY3Rpb24oKXtyZXR1cm4oZnk9cy5fUm90YXRlV2l0aE9mZnNldD1zLmFzbS5Sb3RhdGVXaXRoT2Zmc2V0KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGd5PXMuX1JvdW5kPWZ1bmN0aW9uKCl7cmV0dXJuKGd5PXMuX1JvdW5kPXMuYXNtLlJvdW5kKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGJ5PXMuX1JzcXJ0PWZ1bmN0aW9uKCl7cmV0dXJuKGJ5PXMuX1JzcXJ0PXMuYXNtLlJzcXJ0KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHl5PXMuX1NjYXR0ZXJOZD1mdW5jdGlvbigpe3JldHVybih5eT1zLl9TY2F0dGVyTmQ9cy5hc20uU2NhdHRlck5kKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHh5PXMuX1NlYXJjaFNvcnRlZD1mdW5jdGlvbigpe3JldHVybih4eT1zLl9TZWFyY2hTb3J0ZWQ9cy5hc20uU2VhcmNoU29ydGVkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHZ5PXMuX1NlbGVjdFYyPWZ1bmN0aW9uKCl7cmV0dXJuKHZ5PXMuX1NlbGVjdFYyPXMuYXNtLlNlbGVjdFYyKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHd5PXMuX1NlbHU9ZnVuY3Rpb24oKXtyZXR1cm4od3k9cy5fU2VsdT1zLmFzbS5TZWx1KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGt5PXMuX1NpZ21vaWQ9ZnVuY3Rpb24oKXtyZXR1cm4oa3k9cy5fU2lnbW9pZD1zLmFzbS5TaWdtb2lkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEl5PXMuX1NpZ249ZnVuY3Rpb24oKXtyZXR1cm4oSXk9cy5fU2lnbj1zLmFzbS5TaWduKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFN5PXMuX1Npbj1mdW5jdGlvbigpe3JldHVybihTeT1zLl9TaW49cy5hc20uU2luKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE55PXMuX1Npbmg9ZnVuY3Rpb24oKXtyZXR1cm4oTnk9cy5fU2luaD1zLmFzbS5TaW5oKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFR5PXMuX1NvZnRtYXg9ZnVuY3Rpb24oKXtyZXR1cm4oVHk9cy5fU29mdG1heD1zLmFzbS5Tb2Z0bWF4KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEN5PXMuX1NvZnRwbHVzPWZ1bmN0aW9uKCl7cmV0dXJuKEN5PXMuX1NvZnRwbHVzPXMuYXNtLlNvZnRwbHVzKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEV5PXMuX1NwYXJzZUZpbGxFbXB0eVJvd3M9ZnVuY3Rpb24oKXtyZXR1cm4oRXk9cy5fU3BhcnNlRmlsbEVtcHR5Um93cz1zLmFzbS5TcGFyc2VGaWxsRW1wdHlSb3dzKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LF95PXMuX1NwYXJzZVJlc2hhcGU9ZnVuY3Rpb24oKXtyZXR1cm4oX3k9cy5fU3BhcnNlUmVzaGFwZT1zLmFzbS5TcGFyc2VSZXNoYXBlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEF5PXMuX1NwYXJzZVNlZ21lbnRSZWR1Y3Rpb249ZnVuY3Rpb24oKXtyZXR1cm4oQXk9cy5fU3BhcnNlU2VnbWVudFJlZHVjdGlvbj1zLmFzbS5TcGFyc2VTZWdtZW50UmVkdWN0aW9uKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEZ5PXMuX1NwYXJzZVRvRGVuc2U9ZnVuY3Rpb24oKXtyZXR1cm4oRnk9cy5fU3BhcnNlVG9EZW5zZT1zLmFzbS5TcGFyc2VUb0RlbnNlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LCR5PXMuX1NxcnQ9ZnVuY3Rpb24oKXtyZXR1cm4oJHk9cy5fU3FydD1zLmFzbS5TcXJ0KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LER5PXMuX1NxdWFyZT1mdW5jdGlvbigpe3JldHVybihEeT1zLl9TcXVhcmU9cy5hc20uU3F1YXJlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFJ5PXMuX1NxdWFyZWREaWZmZXJlbmNlPWZ1bmN0aW9uKCl7cmV0dXJuKFJ5PXMuX1NxdWFyZWREaWZmZXJlbmNlPXMuYXNtLlNxdWFyZWREaWZmZXJlbmNlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE15PXMuX1N0ZXA9ZnVuY3Rpb24oKXtyZXR1cm4oTXk9cy5fU3RlcD1zLmFzbS5TdGVwKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LE95PXMuX1N0cmlkZWRTbGljZT1mdW5jdGlvbigpe3JldHVybihPeT1zLl9TdHJpZGVkU2xpY2U9cy5hc20uU3RyaWRlZFNsaWNlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFB5PXMuX1N1Yj1mdW5jdGlvbigpe3JldHVybihQeT1zLl9TdWI9cy5hc20uU3ViKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEx5PXMuX1N1bT1mdW5jdGlvbigpe3JldHVybihMeT1zLl9TdW09cy5hc20uU3VtKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHp5PXMuX1Rhbj1mdW5jdGlvbigpe3JldHVybih6eT1zLl9UYW49cy5hc20uVGFuKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFd5PXMuX1Rhbmg9ZnVuY3Rpb24oKXtyZXR1cm4oV3k9cy5fVGFuaD1zLmFzbS5UYW5oKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEJ5PXMuX1RlbnNvclNjYXR0ZXJVcGRhdGU9ZnVuY3Rpb24oKXtyZXR1cm4oQnk9cy5fVGVuc29yU2NhdHRlclVwZGF0ZT1zLmFzbS5UZW5zb3JTY2F0dGVyVXBkYXRlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFZ5PXMuX1RpbGU9ZnVuY3Rpb24oKXtyZXR1cm4oVnk9cy5fVGlsZT1zLmFzbS5UaWxlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFV5PXMuX1RvcEs9ZnVuY3Rpb24oKXtyZXR1cm4oVXk9cy5fVG9wSz1zLmFzbS5Ub3BLKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEd5PXMuX1RyYW5zZm9ybT1mdW5jdGlvbigpe3JldHVybihHeT1zLl9UcmFuc2Zvcm09cy5hc20uVHJhbnNmb3JtKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEh5PXMuX1RyYW5zcG9zZT1mdW5jdGlvbigpe3JldHVybihIeT1zLl9UcmFuc3Bvc2U9cy5hc20uVHJhbnNwb3NlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGp5PXMuX19GdXNlZE1hdE11bD1mdW5jdGlvbigpe3JldHVybihqeT1zLl9fRnVzZWRNYXRNdWw9cy5hc20uX0Z1c2VkTWF0TXVsKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHF5PXMuX21hbGxvYz1mdW5jdGlvbigpe3JldHVybihxeT1zLl9tYWxsb2M9cy5hc20ubWFsbG9jKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEt5PXMuX2ZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4oS3k9cy5fZnJlZT1zLmFzbS5mcmVlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFh5PXMuX19fZXJybm9fbG9jYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4oWHk9cy5fX19lcnJub19sb2NhdGlvbj1zLmFzbS5fX2Vycm5vX2xvY2F0aW9uKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGxoPXMuc3RhY2tTYXZlPWZ1bmN0aW9uKCl7cmV0dXJuKGxoPXMuc3RhY2tTYXZlPXMuYXNtLnN0YWNrU2F2ZSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSx1aD1zLnN0YWNrUmVzdG9yZT1mdW5jdGlvbigpe3JldHVybih1aD1zLnN0YWNrUmVzdG9yZT1zLmFzbS5zdGFja1Jlc3RvcmUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sanA9cy5zdGFja0FsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKGpwPXMuc3RhY2tBbGxvYz1zLmFzbS5zdGFja0FsbG9jKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFl5PXMuZHluQ2FsbF9paWpqaWlpaT1mdW5jdGlvbigpe3JldHVybihZeT1zLmR5bkNhbGxfaWlqamlpaWk9cy5hc20uZHluQ2FsbF9paWpqaWlpaSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxaeT1zLmR5bkNhbGxfamlqaT1mdW5jdGlvbigpe3JldHVybihaeT1zLmR5bkNhbGxfamlqaT1zLmFzbS5keW5DYWxsX2ppamkpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07cy5jd3JhcD1GZzt2YXIgeWw7SG49ZnVuY3Rpb24gWSgpe3lsfHxwaCgpLHlsfHwoSG49WSl9O2Z1bmN0aW9uIHBoKFkpe2lmKFk9WXx8cCx1dD4wfHwoT3QoKSx1dD4wKSlyZXR1cm47ZnVuY3Rpb24gb2UoKXt5bHx8KHlsPSEwLHMuY2FsbGVkUnVuPSEwLCFVJiYoaWEoKSxpKHMpLHMub25SdW50aW1lSW5pdGlhbGl6ZWQmJnMub25SdW50aW1lSW5pdGlhbGl6ZWQoKSx1bigpKSl9cy5zZXRTdGF0dXM/KHMuc2V0U3RhdHVzKFwiUnVubmluZy4uLlwiKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe3Muc2V0U3RhdHVzKFwiXCIpfSwxKSxvZSgpfSwxKSk6b2UoKX1pZihzLnByZUluaXQpZm9yKHR5cGVvZiBzLnByZUluaXQ9PVwiZnVuY3Rpb25cIiYmKHMucHJlSW5pdD1bcy5wcmVJbml0XSk7cy5wcmVJbml0Lmxlbmd0aD4wOylzLnByZUluaXQucG9wKCkoKTtwaCgpO3ZhciB4bDtsJiYoeGw9e3VuY2F1Z2h0RXhjZXB0aW9uOnByb2Nlc3MubGlzdGVuZXJzKFwidW5jYXVnaHRFeGNlcHRpb25cIikuZmlsdGVyKGZ1bmN0aW9uKFkpe3JldHVybiFsLnVuY2F1Z2h0RXhjZXB0aW9uLmluZGV4T2YoWSk+LTF9KSx1bmhhbmRsZWRSZWplY3Rpb246cHJvY2Vzcy5saXN0ZW5lcnMoXCJ1bmhhbmRsZWRSZWplY3Rpb25cIikuZmlsdGVyKGZ1bmN0aW9uKFkpe3JldHVybiFsLnVuaGFuZGxlZFJlamVjdGlvbi5pbmRleE9mKFkpPi0xfSl9KTt2YXIgdmw7aWYodHlwZW9mIHIhPVwidW5kZWZpbmVkXCIpdmw9cjtlbHNlIGlmKHR5cGVvZiBXYXNtQmFja2VuZE1vZHVsZVRocmVhZGVkU2ltZCE9XCJ1bmRlZmluZWRcIil2bD1XYXNtQmFja2VuZE1vZHVsZVRocmVhZGVkU2ltZDtlbHNlIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHdhc20gbW9kdWxlIGluIHBvc3QuanNcIik7aWYoeGwpe3ZhciBKeT12bC5fZGlzcG9zZTt2bC5fZGlzcG9zZT1mdW5jdGlvbigpe0p5KCkseGwudW5jYXVnaHRFeGNlcHRpb24uZm9yRWFjaChmdW5jdGlvbihZKXtwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKFwidW5jYXVnaHRFeGNlcHRpb25cIixZKX0pLHhsLnVuaGFuZGxlZFJlamVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uKFkpe3Byb2Nlc3MucmVtb3ZlTGlzdGVuZXIoXCJ1bmhhbmRsZWRSZWplY3Rpb25cIixZKX0pfX1yZXR1cm4gci5yZWFkeX19KSgpO3R5cGVvZiBlPT1cIm9iamVjdFwiJiZ0eXBlb2YgdD09XCJvYmplY3RcIj90LmV4cG9ydHM9bjp0eXBlb2YgZGVmaW5lPT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLGZ1bmN0aW9uKCl7cmV0dXJuIG59KTp0eXBlb2YgZT09XCJvYmplY3RcIiYmKGUuV2FzbUJhY2tlbmRNb2R1bGU9bil9KSx5bT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQpe3RoaXMuYmFja2VuZD1lLHRoaXMuZGF0YU1vdmVyPXQsdGhpcy5kYXRhPW5ldyBXZWFrTWFwLHRoaXMuZGF0YUlkc0NvdW50PTB9Z2V0KGUpe3JldHVybiB0aGlzLmRhdGEuaGFzKGUpfHx0aGlzLmRhdGFNb3Zlci5tb3ZlRGF0YSh0aGlzLmJhY2tlbmQsZSksdGhpcy5kYXRhLmdldChlKX1zZXQoZSx0KXt0aGlzLmRhdGFJZHNDb3VudCsrLHRoaXMuZGF0YS5zZXQoZSx0KX1oYXMoZSl7cmV0dXJuIHRoaXMuZGF0YS5oYXMoZSl9ZGVsZXRlKGUpe3JldHVybiB0aGlzLmRhdGFJZHNDb3VudC0tLHRoaXMuZGF0YS5kZWxldGUoZSl9bnVtRGF0YUlkcygpe3JldHVybiB0aGlzLmRhdGFJZHNDb3VudH19LEZjPWNsYXNze3JlZkNvdW50KGUpe3JldHVybiBqbihcInJlZkNvdW50XCIpfWluY1JlZihlKXtyZXR1cm4gam4oXCJpbmNSZWZcIil9dGltZXJBdmFpbGFibGUoKXtyZXR1cm4hMH10aW1lKGUpe3JldHVybiBqbihcInRpbWVcIil9cmVhZChlKXtyZXR1cm4gam4oXCJyZWFkXCIpfXJlYWRTeW5jKGUpe3JldHVybiBqbihcInJlYWRTeW5jXCIpfXJlYWRUb0dQVShlLHQpe3JldHVybiBqbihcInJlYWRUb0dQVVwiKX1udW1EYXRhSWRzKCl7cmV0dXJuIGpuKFwibnVtRGF0YUlkc1wiKX1kaXNwb3NlRGF0YShlLHQpe3JldHVybiBqbihcImRpc3Bvc2VEYXRhXCIpfXdyaXRlKGUsdCxuKXtyZXR1cm4gam4oXCJ3cml0ZVwiKX1tb3ZlKGUsdCxuLGEscil7cmV0dXJuIGpuKFwibW92ZVwiKX1jcmVhdGVUZW5zb3JGcm9tR1BVRGF0YShlLHQsbil7cmV0dXJuIGpuKFwiY3JlYXRlVGVuc29yRnJvbUdQVURhdGFcIil9bWVtb3J5KCl7cmV0dXJuIGpuKFwibWVtb3J5XCIpfWZsb2F0UHJlY2lzaW9uKCl7cmV0dXJuIGpuKFwiZmxvYXRQcmVjaXNpb25cIil9ZXBzaWxvbigpe3JldHVybiB0aGlzLmZsb2F0UHJlY2lzaW9uKCk9PT0zMj8xZS03OjFlLTR9ZGlzcG9zZSgpe3JldHVybiBqbihcImRpc3Bvc2VcIil9fTtmdW5jdGlvbiBqbihlKXt0aHJvdyBuZXcgRXJyb3IoYCcke2V9JyBub3QgeWV0IGltcGxlbWVudGVkIG9yIG5vdCBmb3VuZCBpbiB0aGUgcmVnaXN0cnkuIFRoaXMga2VybmVsIG1heSBub3QgYmUgc3VwcG9ydGVkIGJ5IHRoZSB0ZmpzIGJhY2tlbmQgeW91IGhhdmUgY2hvc2VuYCl9ZnVuY3Rpb24gRFMoZSl7bGV0IHQ9ZS5sZW5ndGgsbj0wO2Zvcig7dD4wOyluPU1hdGgucmFuZG9tKCkqdHwwLHQtLSxWaChlLHQsbil9ZnVuY3Rpb24gSFIoZSx0KXtpZihlLmxlbmd0aCE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgQXJyYXkgc2l6ZXMgbXVzdCBtYXRjaCB0byBiZSBzaHVmZmxlZCB0b2dldGhlciBGaXJzdCBhcnJheSBsZW5ndGggd2FzICR7ZS5sZW5ndGh9U2Vjb25kIGFycmF5IGxlbmd0aCB3YXMgJHt0Lmxlbmd0aH1gKTtsZXQgbj1lLmxlbmd0aCxhPTA7Zm9yKDtuPjA7KWE9TWF0aC5yYW5kb20oKSpufDAsbi0tLFZoKGUsbixhKSxWaCh0LG4sYSl9ZnVuY3Rpb24gaGMoZSx0LG4pe3JldHVybiBNYXRoLm1heChlLE1hdGgubWluKHQsbikpfWZ1bmN0aW9uIGpSKGUpe3JldHVybiBlJTI9PT0wP2U6ZSsxfWZ1bmN0aW9uIFZoKGUsdCxuKXtsZXQgYT1lW3RdO2VbdF09ZVtuXSxlW25dPWF9ZnVuY3Rpb24gcVIoZSl7bGV0IHQ9MDtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyl0Kz1lW25dO3JldHVybiB0fWZ1bmN0aW9uIEtSKGUsdCl7bGV0IG49TWF0aC5yYW5kb20oKTtyZXR1cm4gdCpuKygxLW4pKmV9ZnVuY3Rpb24gWFIoZSx0KXtsZXQgbj0wO2ZvcihsZXQgYT0wO2E8ZS5sZW5ndGg7YSsrKXtsZXQgcj1OdW1iZXIoZVthXSktTnVtYmVyKHRbYV0pO24rPXIqcn1yZXR1cm4gbn1mdW5jdGlvbiBBKGUsdCl7aWYoIWUpdGhyb3cgbmV3IEVycm9yKHR5cGVvZiB0PT1cInN0cmluZ1wiP3Q6dCgpKX1mdW5jdGlvbiBObihlLHQsbj1cIlwiKXtBKEFyKGUsdCksKCk9Pm4rYCBTaGFwZXMgJHtlfSBhbmQgJHt0fSBtdXN0IG1hdGNoYCl9ZnVuY3Rpb24gU2koZSl7QShlIT1udWxsLCgpPT5cIlRoZSBpbnB1dCB0byB0aGUgdGVuc29yIGNvbnN0cnVjdG9yIG11c3QgYmUgYSBub24tbnVsbCB2YWx1ZS5cIil9ZnVuY3Rpb24gb3QoZSl7aWYoZS5sZW5ndGg9PT0wKXJldHVybiAxO2xldCB0PWVbMF07Zm9yKGxldCBuPTE7bjxlLmxlbmd0aDtuKyspdCo9ZVtuXTtyZXR1cm4gdH1mdW5jdGlvbiBZUihlKXtyZXR1cm4gZS5sZW5ndGg9PT0wfWZ1bmN0aW9uIFJTKGUsdCl7aWYoZT09PXQpcmV0dXJuITA7aWYoZT09bnVsbHx8dD09bnVsbHx8ZS5sZW5ndGghPT10Lmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKylpZihlW25dIT09bnVsbCYmdFtuXSE9PW51bGwmJmVbbl0hPT10W25dKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIEFyKGUsdCl7aWYoZT09PXQpcmV0dXJuITA7aWYoZT09bnVsbHx8dD09bnVsbHx8ZS5sZW5ndGghPT10Lmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKylpZihlW25dIT09dFtuXSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiAkbChlKXtyZXR1cm4gZSUxPT09MH1mdW5jdGlvbiBaUihlKXtpZihNYXRoLnRhbmghPW51bGwpcmV0dXJuIE1hdGgudGFuaChlKTtpZihlPT09MS8wKXJldHVybiAxO2lmKGU9PT0tMS8wKXJldHVybi0xO3tsZXQgdD1NYXRoLmV4cCgyKmUpO3JldHVybih0LTEpLyh0KzEpfX1mdW5jdGlvbiBKUihlKXtsZXQgdD1NYXRoLmNlaWwoTWF0aC5zcXJ0KGUpKTtyZXR1cm5bdCxNYXRoLmNlaWwoZS90KV19ZnVuY3Rpb24gUVIoZSl7bGV0IHQ9bmV3IFVpbnQzMkFycmF5KGUpO2ZvcihsZXQgbj0wO248ZTsrK24pdFtuXT1uO3JldHVybiBEUyh0KSx0fWZ1bmN0aW9uIHVjKGUsdCl7cmV0dXJuIHQ8PWUubGVuZ3RoP2U6ZStcIiBcIi5yZXBlYXQodC1lLmxlbmd0aCl9ZnVuY3Rpb24gZU0oZSx0PXI9PjAsbixhKXtyZXR1cm4gbmV3IFByb21pc2UoKHIscyk9PntsZXQgaT0wLG89KCk9PntpZihlKCkpe3IoKTtyZXR1cm59aSsrO2xldCBsPXQoaSk7aWYobiE9bnVsbCYmaT49bil7cygpO3JldHVybn1hIT1udWxsP2EobyxsKTpzZXRUaW1lb3V0KG8sbCl9O28oKX0pfWZ1bmN0aW9uIHRNKGUsdCl7bGV0IG49MSxhPS0xO2ZvcihsZXQgcz0wO3M8ZS5sZW5ndGg7KytzKWlmKGVbc10+PTApbio9ZVtzXTtlbHNlIGlmKGVbc109PT0tMSl7aWYoYSE9PS0xKXRocm93IEVycm9yKGBTaGFwZXMgY2FuIG9ubHkgaGF2ZSAxIGltcGxpY2l0IHNpemUuIEZvdW5kIC0xIGF0IGRpbSAke2F9IGFuZCBkaW0gJHtzfWApO2E9c31lbHNlIGlmKGVbc108MCl0aHJvdyBFcnJvcihgU2hhcGVzIGNhbiBub3QgYmUgPCAwLiBGb3VuZCAke2Vbc119IGF0IGRpbSAke3N9YCk7aWYoYT09PS0xKXtpZih0PjAmJnQhPT1uKXRocm93IEVycm9yKGBTaXplKCR7dH0pIG11c3QgbWF0Y2ggdGhlIHByb2R1Y3Qgb2Ygc2hhcGUgJHtlfWApO3JldHVybiBlfWlmKG49PT0wKXRocm93IEVycm9yKGBDYW5ub3QgaW5mZXIgdGhlIG1pc3Npbmcgc2l6ZSBpbiBbJHtlfV0gd2hlbiB0aGVyZSBhcmUgMCBlbGVtZW50c2ApO2lmKHQlbiE9PTApdGhyb3cgRXJyb3IoYFRoZSBpbXBsaWNpdCBzaGFwZSBjYW4ndCBiZSBhIGZyYWN0aW9uYWwgbnVtYmVyLiBHb3QgJHt0fSAvICR7bn1gKTtsZXQgcj1lLnNsaWNlKCk7cmV0dXJuIHJbYV09dC9uLHJ9ZnVuY3Rpb24gQWEoZSx0KXtsZXQgbj10Lmxlbmd0aDtyZXR1cm4gZT1lPT1udWxsP3QubWFwKChhLHIpPT5yKTpbXS5jb25jYXQoZSksQShlLmV2ZXJ5KGE9PmE+PS1uJiZhPG4pLCgpPT5gQWxsIHZhbHVlcyBpbiBheGlzIHBhcmFtIG11c3QgYmUgaW4gcmFuZ2UgWy0ke259LCAke259KSBidXQgZ290IGF4aXMgJHtlfWApLEEoZS5ldmVyeShhPT4kbChhKSksKCk9PmBBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbnRlZ2VycyBidXQgZ290IGF4aXMgJHtlfWApLGUubWFwKGE9PmE8MD9uK2E6YSl9ZnVuY3Rpb24gTVMoZSx0KXtsZXQgbj1bXSxhPVtdLHI9dCE9bnVsbCYmQXJyYXkuaXNBcnJheSh0KSYmdC5sZW5ndGg9PT0wLHM9dD09bnVsbHx8cj9udWxsOkFhKHQsZSkuc29ydCgpLGk9MDtmb3IobGV0IG89MDtvPGUubGVuZ3RoOysrbyl7aWYocyE9bnVsbCl7aWYoc1tpXT09PW8mJmVbb10hPT0xKXRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc3F1ZWV6ZSBheGlzICR7b30gc2luY2UgaXRzIGRpbSAnJHtlW29dfScgaXMgbm90IDFgKTsoc1tpXT09bnVsbHx8c1tpXT5vKSYmZVtvXT09PTEmJihuLnB1c2goZVtvXSksYS5wdXNoKG8pKSxzW2ldPD1vJiZpKyt9ZVtvXSE9PTEmJihuLnB1c2goZVtvXSksYS5wdXNoKG8pKX1yZXR1cm57bmV3U2hhcGU6bixrZXB0RGltczphfX1mdW5jdGlvbiBPUyhlLHQpe3JldHVybiBTdihlLHQpfWZ1bmN0aW9uIFN2KGUsdCl7bGV0IG49bnVsbDtpZihlPT1udWxsfHxlPT09XCJmbG9hdDMyXCIpbj1uZXcgRmxvYXQzMkFycmF5KHQpO2Vsc2UgaWYoZT09PVwiaW50MzJcIiluPW5ldyBJbnQzMkFycmF5KHQpO2Vsc2UgaWYoZT09PVwiYm9vbFwiKW49bmV3IFVpbnQ4QXJyYXkodCk7ZWxzZSBpZihlPT09XCJzdHJpbmdcIiluPW5ldyBBcnJheSh0KTtlbHNlIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhIHR5cGUgJHtlfWApO3JldHVybiBufWZ1bmN0aW9uIFBTKGUsdCl7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspe2xldCBhPWVbbl07aWYoaXNOYU4oYSl8fCFpc0Zpbml0ZShhKSl0aHJvdyBFcnJvcihgQSB0ZW5zb3Igb2YgdHlwZSAke3R9IGJlaW5nIHVwbG9hZGVkIGNvbnRhaW5zICR7YX0uYCl9fWZ1bmN0aW9uIExTKGUpe3JldHVybiBlPT09XCJib29sXCJ8fGU9PT1cImNvbXBsZXg2NFwifHxlPT09XCJmbG9hdDMyXCJ8fGU9PT1cImludDMyXCJ8fGU9PT1cInN0cmluZ1wifWZ1bmN0aW9uIG5NKGUsdCl7cmV0dXJuISh0PT09XCJjb21wbGV4NjRcInx8dD09PVwiZmxvYXQzMlwiJiZlIT09XCJjb21wbGV4NjRcInx8dD09PVwiaW50MzJcIiYmZSE9PVwiZmxvYXQzMlwiJiZlIT09XCJjb21wbGV4NjRcInx8dD09PVwiYm9vbFwiJiZlPT09XCJib29sXCIpfWZ1bmN0aW9uIFVoKGUpe2lmKGU9PT1cImZsb2F0MzJcInx8ZT09PVwiaW50MzJcIilyZXR1cm4gNDtpZihlPT09XCJjb21wbGV4NjRcIilyZXR1cm4gODtpZihlPT09XCJib29sXCIpcmV0dXJuIDE7dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGR0eXBlICR7ZX1gKX1mdW5jdGlvbiB6UyhlKXtpZihlPT1udWxsKXJldHVybiAwO2xldCB0PTA7cmV0dXJuIGUuZm9yRWFjaChuPT50Kz1uLmxlbmd0aCksdH1mdW5jdGlvbiBKcihlKXtyZXR1cm4gdHlwZW9mIGU9PVwic3RyaW5nXCJ8fGUgaW5zdGFuY2VvZiBTdHJpbmd9ZnVuY3Rpb24gV1MoZSl7cmV0dXJuIHR5cGVvZiBlPT1cImJvb2xlYW5cIn1mdW5jdGlvbiBCUyhlKXtyZXR1cm4gdHlwZW9mIGU9PVwibnVtYmVyXCJ9ZnVuY3Rpb24gJGMoZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/JGMoZVswXSk6ZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheT9cImZsb2F0MzJcIjplIGluc3RhbmNlb2YgSW50MzJBcnJheXx8ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fGUgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheT9cImludDMyXCI6QlMoZSk/XCJmbG9hdDMyXCI6SnIoZSk/XCJzdHJpbmdcIjpXUyhlKT9cImJvb2xcIjpcImZsb2F0MzJcIn1mdW5jdGlvbiBzcyhlKXtyZXR1cm4hIShlJiZlLmNvbnN0cnVjdG9yJiZlLmNhbGwmJmUuYXBwbHkpfWZ1bmN0aW9uIEdoKGUsdCl7Zm9yKGxldCBuPXQ7bjxlOysrbilpZihlJW49PT0wKXJldHVybiBuO3JldHVybiBlfWZ1bmN0aW9uIFhsKGUpe2xldCB0PWUubGVuZ3RoO2lmKHQ8MilyZXR1cm5bXTtsZXQgbj1uZXcgQXJyYXkodC0xKTtuW3QtMl09ZVt0LTFdO2ZvcihsZXQgYT10LTM7YT49MDstLWEpblthXT1uW2ErMV0qZVthKzFdO3JldHVybiBufWZ1bmN0aW9uIFZTKGUsdCxuLGE9ITEpe2xldCByPW5ldyBBcnJheTtpZih0Lmxlbmd0aD09PTEpe2xldCBzPXRbMF0qKGE/MjoxKTtmb3IobGV0IGk9MDtpPHM7aSsrKXJbaV09bltlK2ldfWVsc2V7bGV0IHM9dFswXSxpPXQuc2xpY2UoMSksbz1pLnJlZHVjZSgobCx1KT0+bCp1KSooYT8yOjEpO2ZvcihsZXQgbD0wO2w8cztsKyspcltsXT1WUyhlK2wqbyxpLG4sYSl9cmV0dXJuIHJ9ZnVuY3Rpb24gRWwoZSx0LG49ITEpe2lmKGUubGVuZ3RoPT09MClyZXR1cm4gdFswXTtsZXQgYT1lLnJlZHVjZSgocixzKT0+cipzKSoobj8yOjEpO2lmKGE9PT0wKXJldHVybltdO2lmKGEhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYFske2V9XSBkb2VzIG5vdCBtYXRjaCB0aGUgaW5wdXQgc2l6ZSAke3QubGVuZ3RofSR7bj9cIiBmb3IgYSBjb21wbGV4IHRlbnNvclwiOlwiXCJ9LmApO3JldHVybiBWUygwLGUsdCxuKX1mdW5jdGlvbiBhTShlLHQpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGU7aWYodD09PVwiZmxvYXQzMlwiKXJldHVybiBlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5P2U6bmV3IEZsb2F0MzJBcnJheShlKTtpZih0PT09XCJpbnQzMlwiKXJldHVybiBlIGluc3RhbmNlb2YgSW50MzJBcnJheT9lOm5ldyBJbnQzMkFycmF5KGUpO2lmKHQ9PT1cImJvb2xcInx8dD09PVwic3RyaW5nXCIpcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShuZXcgSW50MzJBcnJheShlKSk7dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGR0eXBlICR7dH1gKX1mdW5jdGlvbiBOdihlLHQpe2xldCBuPXhtKGUsdCk7Zm9yKGxldCBhPTA7YTxuLmxlbmd0aDthKyspblthXT0xO3JldHVybiBufWZ1bmN0aW9uIHhtKGUsdCl7aWYodD09bnVsbHx8dD09PVwiZmxvYXQzMlwifHx0PT09XCJjb21wbGV4NjRcIilyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShlKTtpZih0PT09XCJpbnQzMlwiKXJldHVybiBuZXcgSW50MzJBcnJheShlKTtpZih0PT09XCJib29sXCIpcmV0dXJuIG5ldyBVaW50OEFycmF5KGUpO3Rocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhIHR5cGUgJHt0fWApfWZ1bmN0aW9uIHJNKGUsdCl7bGV0IG49ZS5yZWR1Y2UoKGEscik9PmEqciwxKTtpZih0PT1udWxsfHx0PT09XCJmbG9hdDMyXCIpcmV0dXJuIEVsKGUsbmV3IEZsb2F0MzJBcnJheShuKSk7aWYodD09PVwiaW50MzJcIilyZXR1cm4gRWwoZSxuZXcgSW50MzJBcnJheShuKSk7aWYodD09PVwiYm9vbFwiKXJldHVybiBFbChlLG5ldyBVaW50OEFycmF5KG4pKTt0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YSB0eXBlICR7dH1gKX1mdW5jdGlvbiBuYShlKXtlLmZvckVhY2godD0+e0EoTnVtYmVyLmlzSW50ZWdlcih0KSYmdD49MCwoKT0+YFRlbnNvciBtdXN0IGhhdmUgYSBzaGFwZSBjb21wcmlzZWQgb2YgcG9zaXRpdmUgaW50ZWdlcnMgYnV0IGdvdCBzaGFwZSBbJHtlfV0uYCl9KX1mdW5jdGlvbiBzTShlLHQsbil7aWYodD09PTApcmV0dXJuIDA7aWYodD09PTEpcmV0dXJuIGVbMF07bGV0IGE9ZVtlLmxlbmd0aC0xXTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoLTE7KytyKWErPW5bcl0qZVtyXTtyZXR1cm4gYX1mdW5jdGlvbiBpTShlLHQsbil7aWYodD09PTApcmV0dXJuW107aWYodD09PTEpcmV0dXJuW2VdO2xldCBhPW5ldyBBcnJheSh0KTtmb3IobGV0IHI9MDtyPGEubGVuZ3RoLTE7KytyKWFbcl09TWF0aC5mbG9vcihlL25bcl0pLGUtPWFbcl0qbltyXTtyZXR1cm4gYVthLmxlbmd0aC0xXT1lLGF9ZnVuY3Rpb24gdm0oZSl7cmV0dXJuIGUmJmUudGhlbiYmdHlwZW9mIGUudGhlbj09XCJmdW5jdGlvblwifXZhciBqaz1cInRmanNmbGFnc1wiLFVTPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuZ2xvYmFsPWUsdGhpcy5mbGFncz17fSx0aGlzLmZsYWdSZWdpc3RyeT17fSx0aGlzLnVybEZsYWdzPXt9LHRoaXMuZ2V0UXVlcnlQYXJhbXM9b00sdGhpcy5wb3B1bGF0ZVVSTEZsYWdzKCl9c2V0UGxhdGZvcm0oZSx0KXt0aGlzLnBsYXRmb3JtIT1udWxsJiYoRygpLmdldEJvb2woXCJJU19URVNUXCIpfHxHKCkuZ2V0Qm9vbChcIlBST0RcIil8fGNvbnNvbGUud2FybihgUGxhdGZvcm0gJHt0aGlzLnBsYXRmb3JtTmFtZX0gaGFzIGFscmVhZHkgYmVlbiBzZXQuIE92ZXJ3cml0aW5nIHRoZSBwbGF0Zm9ybSB3aXRoICR7ZX0uYCkpLHRoaXMucGxhdGZvcm1OYW1lPWUsdGhpcy5wbGF0Zm9ybT10fXJlZ2lzdGVyRmxhZyhlLHQsbil7aWYodGhpcy5mbGFnUmVnaXN0cnlbZV09e2V2YWx1YXRpb25Gbjp0LHNldEhvb2s6bn0sdGhpcy51cmxGbGFnc1tlXSE9bnVsbCl7bGV0IGE9dGhpcy51cmxGbGFnc1tlXTtHKCkuZ2V0Qm9vbChcIklTX1RFU1RcIil8fEcoKS5nZXRCb29sKFwiUFJPRFwiKXx8Y29uc29sZS53YXJuKGBTZXR0aW5nIGZlYXR1cmUgb3ZlcnJpZGUgZnJvbSBVUkwgJHtlfTogJHthfS5gKSx0aGlzLnNldChlLGEpfX1hc3luYyBnZXRBc3luYyhlKXtyZXR1cm4gZSBpbiB0aGlzLmZsYWdzP3RoaXMuZmxhZ3NbZV06KHRoaXMuZmxhZ3NbZV09YXdhaXQgdGhpcy5ldmFsdWF0ZUZsYWcoZSksdGhpcy5mbGFnc1tlXSl9Z2V0KGUpe2lmKGUgaW4gdGhpcy5mbGFncylyZXR1cm4gdGhpcy5mbGFnc1tlXTtsZXQgdD10aGlzLmV2YWx1YXRlRmxhZyhlKTtpZih2bSh0KSl0aHJvdyBuZXcgRXJyb3IoYEZsYWcgJHtlfSBjYW5ub3QgYmUgc3luY2hyb25vdXNseSBldmFsdWF0ZWQuIFBsZWFzZSB1c2UgZ2V0QXN5bmMoKSBpbnN0ZWFkLmApO3JldHVybiB0aGlzLmZsYWdzW2VdPXQsdGhpcy5mbGFnc1tlXX1nZXROdW1iZXIoZSl7cmV0dXJuIHRoaXMuZ2V0KGUpfWdldEJvb2woZSl7cmV0dXJuIHRoaXMuZ2V0KGUpfWdldFN0cmluZyhlKXtyZXR1cm4gdGhpcy5nZXQoZSl9Z2V0RmxhZ3MoKXtyZXR1cm4gdGhpcy5mbGFnc31nZXQgZmVhdHVyZXMoKXtyZXR1cm4gdGhpcy5mbGFnc31zZXQoZSx0KXtpZih0aGlzLmZsYWdSZWdpc3RyeVtlXT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzZXQgZmxhZyAke2V9IGFzIGl0IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkLmApO3RoaXMuZmxhZ3NbZV09dCx0aGlzLmZsYWdSZWdpc3RyeVtlXS5zZXRIb29rIT1udWxsJiZ0aGlzLmZsYWdSZWdpc3RyeVtlXS5zZXRIb29rKHQpfWV2YWx1YXRlRmxhZyhlKXtpZih0aGlzLmZsYWdSZWdpc3RyeVtlXT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBldmFsdWF0ZSBmbGFnICcke2V9Jzogbm8gZXZhbHVhdGlvbiBmdW5jdGlvbiBmb3VuZC5gKTtyZXR1cm4gdGhpcy5mbGFnUmVnaXN0cnlbZV0uZXZhbHVhdGlvbkZuKCl9c2V0RmxhZ3MoZSl7dGhpcy5mbGFncz1PYmplY3QuYXNzaWduKHt9LGUpfXJlc2V0KCl7dGhpcy5mbGFncz17fSx0aGlzLnVybEZsYWdzPXt9LHRoaXMucG9wdWxhdGVVUkxGbGFncygpfXBvcHVsYXRlVVJMRmxhZ3MoKXtpZih0eXBlb2YgdGhpcy5nbG9iYWw9PVwidW5kZWZpbmVkXCJ8fHR5cGVvZiB0aGlzLmdsb2JhbC5sb2NhdGlvbj09XCJ1bmRlZmluZWRcInx8dHlwZW9mIHRoaXMuZ2xvYmFsLmxvY2F0aW9uLnNlYXJjaD09XCJ1bmRlZmluZWRcIilyZXR1cm47bGV0IGU9dGhpcy5nZXRRdWVyeVBhcmFtcyh0aGlzLmdsb2JhbC5sb2NhdGlvbi5zZWFyY2gpO2prIGluIGUmJmVbamtdLnNwbGl0KFwiLFwiKS5mb3JFYWNoKHQ9PntsZXRbbixhXT10LnNwbGl0KFwiOlwiKTt0aGlzLnVybEZsYWdzW25dPXVNKG4sYSl9KX19O2Z1bmN0aW9uIG9NKGUpe2xldCB0PXt9O3JldHVybiBlLnJlcGxhY2UoL1s/Jl0oW149PyZdKykoPzo9KFteJl0qKSk/L2csKG4sLi4uYSk9PihsTSh0LGFbMF0sYVsxXSksYS5qb2luKFwiPVwiKSkpLHR9ZnVuY3Rpb24gbE0oZSx0LG4pe2VbZGVjb2RlVVJJQ29tcG9uZW50KHQpXT1kZWNvZGVVUklDb21wb25lbnQobnx8XCJcIil9ZnVuY3Rpb24gdU0oZSx0KXtsZXQgbj10LnRvTG93ZXJDYXNlKCk7cmV0dXJuIG49PT1cInRydWVcInx8bj09PVwiZmFsc2VcIj9uPT09XCJ0cnVlXCI6YCR7K259YD09PW4/K246dH1mdW5jdGlvbiBHKCl7cmV0dXJuIFR2fXZhciBUdj1udWxsO2Z1bmN0aW9uIHBNKGUpe1R2PWV9dmFyIHJ4O2Z1bmN0aW9uIEdTKCl7aWYocng9PW51bGwpe2xldCBlO2lmKHR5cGVvZiB3aW5kb3chPVwidW5kZWZpbmVkXCIpZT13aW5kb3c7ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT1cInVuZGVmaW5lZFwiKWU9Z2xvYmFsO2Vsc2UgaWYodHlwZW9mIHByb2Nlc3MhPVwidW5kZWZpbmVkXCIpZT1wcm9jZXNzO2Vsc2UgaWYodHlwZW9mIHNlbGYhPVwidW5kZWZpbmVkXCIpZT1zZWxmO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYSBnbG9iYWwgb2JqZWN0XCIpO3J4PWV9cmV0dXJuIHJ4fWZ1bmN0aW9uIGNNKCl7bGV0IGU9R1MoKTtyZXR1cm4gZS5fdGZHbG9iYWxzPT1udWxsJiYoZS5fdGZHbG9iYWxzPW5ldyBNYXApLGUuX3RmR2xvYmFsc31mdW5jdGlvbiBDdihlLHQpe2xldCBuPWNNKCk7aWYobi5oYXMoZSkpcmV0dXJuIG4uZ2V0KGUpO3tsZXQgYT10KCk7cmV0dXJuIG4uc2V0KGUsYSksbi5nZXQoZSl9fXZhciBZbD1cIkFic1wiLE5pPVwiQWNvc1wiLFRpPVwiQWNvc2hcIix2cz1cIkFkZFwiLENpPVwiQWRkTlwiLFpsPVwiQWxsXCIsSmw9XCJBbnlcIixRbD1cIkFyZ01heFwiLGV1PVwiQXJnTWluXCIsRWk9XCJBc2luXCIsX2k9XCJBc2luaFwiLEFpPVwiQXRhblwiLEZpPVwiQXRhbmhcIiwkaT1cIkF0YW4yXCIsRGk9XCJBdmdQb29sXCIsRGM9XCJBdmdQb29sR3JhZFwiLHR1PVwiQXZnUG9vbDNEXCIsUmM9XCJBdmdQb29sM0RHcmFkXCIsUmk9XCJCYXRjaE1hdE11bFwiLG51PVwiQmF0Y2hUb1NwYWNlTkRcIixhdT1cIkJpbmNvdW50XCIscnU9XCJCaXR3aXNlQW5kXCIsSFM9XCJCcm9hZGNhc3RUb1wiLE1jPVwiQnJvYWRjYXN0QXJnc1wiLE1pPVwiQ2FzdFwiLE9pPVwiQ2VpbFwiLHdzPVwiQ2xpcEJ5VmFsdWVcIix3bT1cIkNvbXBsZXhcIixPYz1cIkNvbXBsZXhBYnNcIixzdT1cIkNvbmNhdFwiLFBpPVwiQ29udjJEXCIsa209XCJDb252MkRCYWNrcHJvcEZpbHRlclwiLExpPVwiQ29udjJEQmFja3Byb3BJbnB1dFwiLHppPVwiQ29udjNEXCIsaXU9XCJDb252M0RCYWNrcHJvcEZpbHRlclYyXCIsb3U9XCJDb252M0RCYWNrcHJvcElucHV0VjJcIixXaT1cIkNvc1wiLEJpPVwiQ29zaFwiLGx1PVwiQ3VtcHJvZFwiLFZpPVwiQ3Vtc3VtXCIsdXU9XCJDcm9wQW5kUmVzaXplXCIsUGM9XCJEZW5zZUJpbmNvdW50XCIscHU9XCJEZXB0aFRvU3BhY2VcIixVaT1cIkRlcHRod2lzZUNvbnYyZE5hdGl2ZVwiLEltPVwiRGVwdGh3aXNlQ29udjJkTmF0aXZlQmFja3Byb3BGaWx0ZXJcIixTbT1cIkRlcHRod2lzZUNvbnYyZE5hdGl2ZUJhY2twcm9wSW5wdXRcIixMYz1cIkRpYWdcIixHaT1cIkRpbGF0aW9uMkRcIixEbD1cIkRpbGF0aW9uMkRCYWNrcHJvcElucHV0XCIsUmw9XCJEaWxhdGlvbjJEQmFja3Byb3BGaWx0ZXJcIixObT1cIkRyYXdcIixIaT1cIlJlYWxEaXZcIixUbT1cIkVpbnN1bVwiLGppPVwiRWx1XCIsY3U9XCJFbHVHcmFkXCIscWk9XCJFcmZcIixkdT1cIkVxdWFsXCIsS2k9XCJFeHBcIixodT1cIkV4cGFuZERpbXNcIixYaT1cIkV4cG0xXCIsQ209XCJGRlRcIix6Yz1cIkZpbGxcIixtdT1cIkZsaXBMZWZ0UmlnaHRcIixZaT1cIkZsb29yXCIsWmk9XCJGbG9vckRpdlwiLEppPVwiRnVzZWRCYXRjaE5vcm1cIixmdT1cIkdhdGhlclYyXCIsZ3U9XCJHYXRoZXJOZFwiLGJ1PVwiR3JlYXRlclwiLFFpPVwiR3JlYXRlckVxdWFsXCIsZW89XCJJZGVudGl0eVwiLEVtPVwiSUZGVFwiLF9tPVwiSW1hZ1wiLHRvPVwiSXNGaW5pdGVcIixubz1cIklzSW5mXCIsYW89XCJJc05hblwiLHJvPVwiTGVha3lSZWx1XCIseXU9XCJMZXNzXCIseHU9XCJMZXNzRXF1YWxcIix2dT1cIkxpblNwYWNlXCIsc289XCJMb2dcIixpbz1cIkxvZzFwXCIsd3U9XCJMb2dpY2FsQW5kXCIsa3U9XCJMb2dpY2FsTm90XCIsSXU9XCJMb2dpY2FsT3JcIixqUz1cIkxvZ2ljYWxYb3JcIixxUz1cIkxvZ1NvZnRtYXhcIixkTT1cIkxvd2VyQm91bmRcIixvbz1cIkxSTlwiLFN1PVwiTFJOR3JhZFwiLGhNPVwiTWF0cml4QmFuZFBhcnRcIixsbz1cIk1heFwiLHVvPVwiTWF4aW11bVwiLHBvPVwiTWF4UG9vbFwiLFdjPVwiTWF4UG9vbEdyYWRcIixOdT1cIk1heFBvb2wzRFwiLEJjPVwiTWF4UG9vbDNER3JhZFwiLFZjPVwiTWF4UG9vbFdpdGhBcmdtYXhcIixjbz1cIk1lYW5cIixobz1cIk1pblwiLG1vPVwiTWluaW11bVwiLGZvPVwiTWlycm9yUGFkXCIsZ289XCJNb2RcIixUdT1cIk11bHRpbm9taWFsXCIsYm89XCJNdWx0aXBseVwiLEN1PVwiTmVnXCIsRXU9XCJOb3RFcXVhbFwiLF91PVwiTm9uTWF4U3VwcHJlc3Npb25WM1wiLEF1PVwiTm9uTWF4U3VwcHJlc3Npb25WNFwiLEZ1PVwiTm9uTWF4U3VwcHJlc3Npb25WNVwiLCR1PVwiT25lc0xpa2VcIix5bz1cIk9uZUhvdFwiLER1PVwiUGFja1wiLHhvPVwiUGFkVjJcIixtTT1cIlBvb2xcIix2bz1cIlBvd1wiLHdvPVwiUHJlbHVcIixrbz1cIlByb2RcIixBbT1cIlJhZ2dlZEdhdGhlclwiLEZtPVwiUmFnZ2VkUmFuZ2VcIiwkbT1cIlJhZ2dlZFRlbnNvclRvVGVuc29yXCIsVWM9XCJSYW5nZVwiLERtPVwiUmVhbFwiLElvPVwiUmVjaXByb2NhbFwiLFNvPVwiUmVsdVwiLFJ1PVwiUmVzaGFwZVwiLE5vPVwiUmVzaXplTmVhcmVzdE5laWdoYm9yXCIsTXU9XCJSZXNpemVOZWFyZXN0TmVpZ2hib3JHcmFkXCIsVG89XCJSZXNpemVCaWxpbmVhclwiLE91PVwiUmVzaXplQmlsaW5lYXJHcmFkXCIsQ289XCJSZWx1NlwiLEVvPVwiUmV2ZXJzZVwiLF9vPVwiUm91bmRcIixBbz1cIlJzcXJ0XCIsUHU9XCJTY2F0dGVyTmRcIixMdT1cIlRlbnNvclNjYXR0ZXJVcGRhdGVcIix6dT1cIlNlYXJjaFNvcnRlZFwiLFd1PVwiU2VsZWN0XCIsRm89XCJTZWx1XCIsQnU9XCJTbGljZVwiLCRvPVwiU2luXCIsRG89XCJTaW5oXCIsUm89XCJTaWduXCIsTW89XCJTaWdtb2lkXCIsT289XCJTb2Z0cGx1c1wiLFBvPVwiU3FydFwiLExvPVwiU3VtXCIsVnU9XCJTcGFjZVRvQmF0Y2hORFwiLFV1PVwiU3BsaXRWXCIsem89XCJTb2Z0bWF4XCIsR2M9XCJTcGFyc2VGaWxsRW1wdHlSb3dzXCIsR3U9XCJTcGFyc2VSZXNoYXBlXCIsSGM9XCJTcGFyc2VTZWdtZW50TWVhblwiLGpjPVwiU3BhcnNlU2VnbWVudFN1bVwiLEh1PVwiU3BhcnNlVG9EZW5zZVwiLFdvPVwiU3F1YXJlZERpZmZlcmVuY2VcIixxYz1cIlNxdWFyZVwiLEtjPVwiU3RhdGljUmVnZXhSZXBsYWNlXCIsanU9XCJTdHJpZGVkU2xpY2VcIixYYz1cIlN0cmluZ05HcmFtc1wiLFljPVwiU3RyaW5nU3BsaXRcIixaYz1cIlN0cmluZ1RvSGFzaEJ1Y2tldEZhc3RcIixCbz1cIlN1YlwiLFZvPVwiVGFuXCIsVW89XCJUYW5oXCIsa3M9XCJUaWxlXCIscXU9XCJUb3BLXCIsS3U9XCJUcmFuc2Zvcm1cIixDcj1cIlRyYW5zcG9zZVwiLEpjPVwiVW5pcXVlXCIsWHU9XCJVbnBhY2tcIixRYz1cIlVuc29ydGVkU2VnbWVudFN1bVwiLGZNPVwiVXBwZXJCb3VuZFwiLFl1PVwiWmVyb3NMaWtlXCIsSXM9XCJTdGVwXCIsSGg9XCJGcm9tUGl4ZWxzXCIsWnU9XCJSb3RhdGVXaXRoT2Zmc2V0XCIsaWk9XCJfRnVzZWRNYXRNdWxcIixvaT1cIkZ1c2VkQ29udjJEXCIsbGk9XCJGdXNlZERlcHRod2lzZUNvbnYyRFwiO2Z1bmN0aW9uIFpyKC4uLmUpe0coKS5nZXRCb29sKFwiSVNfVEVTVFwiKXx8RygpLmdldEJvb2woXCJQUk9EXCIpfHxjb25zb2xlLndhcm4oLi4uZSl9ZnVuY3Rpb24gZ00oLi4uZSl7RygpLmdldEJvb2woXCJJU19URVNUXCIpfHxHKCkuZ2V0Qm9vbChcIlBST0RcIil8fGNvbnNvbGUubG9nKC4uLmUpfXZhciBNbD1DdihcImtlcm5lbFJlZ2lzdHJ5XCIsKCk9Pm5ldyBNYXApLG1jPUN2KFwiZ3JhZFJlZ2lzdHJ5XCIsKCk9Pm5ldyBNYXApO2Z1bmN0aW9uIGZjKGUsdCl7bGV0IG49RXYoZSx0KTtyZXR1cm4gTWwuZ2V0KG4pfWZ1bmN0aW9uIHZ4KGUpe3JldHVybiBtYy5nZXQoZSl9ZnVuY3Rpb24gamgoZSl7bGV0IHQ9TWwuZW50cmllcygpLG49W107Zm9yKDs7KXtsZXR7ZG9uZTphLHZhbHVlOnJ9PXQubmV4dCgpO2lmKGEpYnJlYWs7bGV0W3MsaV09cixbb109cy5zcGxpdChcIl9cIik7bz09PWUmJm4ucHVzaChpKX1yZXR1cm4gbn1mdW5jdGlvbiBlZChlKXtsZXR7a2VybmVsTmFtZTp0LGJhY2tlbmROYW1lOm59PWUsYT1Fdih0LG4pO01sLmhhcyhhKSYmWnIoYFRoZSBrZXJuZWwgJyR7dH0nIGZvciBiYWNrZW5kICcke259JyBpcyBhbHJlYWR5IHJlZ2lzdGVyZWRgKSxNbC5zZXQoYSxlKX1mdW5jdGlvbiBLUyhlKXtsZXR7a2VybmVsTmFtZTp0fT1lO21jLmhhcyh0KSYmRygpLmdldEJvb2woXCJERUJVR1wiKSYmWnIoYE92ZXJyaWRpbmcgdGhlIGdyYWRpZW50IGZvciAnJHt0fSdgKSxtYy5zZXQodCxlKX1mdW5jdGlvbiBiTShlLHQpe2xldCBuPUV2KGUsdCk7aWYoIU1sLmhhcyhuKSl0aHJvdyBuZXcgRXJyb3IoYFRoZSBrZXJuZWwgJyR7ZX0nIGZvciBiYWNrZW5kICcke3R9JyBpcyBub3QgcmVnaXN0ZXJlZGApO01sLmRlbGV0ZShuKX1mdW5jdGlvbiB5TShlKXtpZighbWMuaGFzKGUpKXRocm93IG5ldyBFcnJvcihgVGhlIGdyYWRpZW50ICcke2V9JyBmb3IgYmFja2VuZCBpcyBub3QgcmVnaXN0ZXJlZGApO21jLmRlbGV0ZShlKX1mdW5jdGlvbiB4TShlLHQpe2poKGUpLmZvckVhY2gobj0+e2xldCBhPU9iamVjdC5hc3NpZ24oe30sbix7YmFja2VuZE5hbWU6dH0pO2VkKGEpfSl9ZnVuY3Rpb24gRXYoZSx0KXtyZXR1cm5gJHt0fV8ke2V9YH12YXIgdz17fTtfZSh3LHthcnJheXNFcXVhbDooKT0+QXIsYXJyYXlzRXF1YWxXaXRoTnVsbDooKT0+UlMsYXNzZXJ0OigpPT5BLGFzc2VydE5vbk5lZ2F0aXZlSW50ZWdlckRpbWVuc2lvbnM6KCk9Pm5hLGFzc2VydE5vbk51bGw6KCk9PlNpLGFzc2VydFNoYXBlc01hdGNoOigpPT5ObixieXRlc0Zyb21TdHJpbmdBcnJheTooKT0+elMsYnl0ZXNQZXJFbGVtZW50OigpPT5VaCxjaGVja0NvbnZlcnNpb25Gb3JFcnJvcnM6KCk9PlBTLGNsYW1wOigpPT5oYyxjb21wdXRlU3RyaWRlczooKT0+WGwsY29udmVydEJhY2tlbmRWYWx1ZXNBbmRBcnJheUJ1ZmZlcjooKT0+YU0sY3JlYXRlU2NhbGFyVmFsdWU6KCk9Pk5NLGNyZWF0ZVNodWZmbGVkSW5kaWNlczooKT0+UVIsZGVjb2RlU3RyaW5nOigpPT5xaCxkaXN0U3F1YXJlZDooKT0+WFIsZW5jb2RlU3RyaW5nOigpPT5uZCxmZXRjaDooKT0+Q00sZmluZ2VyUHJpbnQ2NDooKT0+U00sZmxhdHRlbjooKT0+aXMsZ2V0QXJyYXlGcm9tRFR5cGU6KCk9PlN2LGdldFR5cGVkQXJyYXlGcm9tRFR5cGU6KCk9Pk9TLGhhc0VuY29kaW5nTG9zczooKT0+bk0saGV4VG9Mb25nOigpPT50ZCxpbmRleFRvTG9jOigpPT5pTSxpbmZlckR0eXBlOigpPT4kYyxpbmZlckZyb21JbXBsaWNpdFNoYXBlOigpPT50TSxpc0Jvb2xlYW46KCk9PldTLGlzRnVuY3Rpb246KCk9PnNzLGlzSW50OigpPT4kbCxpc051bWJlcjooKT0+QlMsaXNQcm9taXNlOigpPT52bSxpc1NjYWxhclNoYXBlOigpPT5ZUixpc1N0cmluZzooKT0+SnIsaXNUeXBlZEFycmF5OigpPT5lbixpc1ZhbGlkRHR5cGU6KCk9PkxTLGxvY1RvSW5kZXg6KCk9PnNNLG1ha2VPbmVzVHlwZWRBcnJheTooKT0+TnYsbWFrZVplcm9zTmVzdGVkVHlwZWRBcnJheTooKT0+ck0sbWFrZVplcm9zVHlwZWRBcnJheTooKT0+eG0sbmVhcmVzdERpdmlzb3I6KCk9PkdoLG5lYXJlc3RMYXJnZXJFdmVuOigpPT5qUixub3c6KCk9PmdjLHBhcnNlQXhpc1BhcmFtOigpPT5BYSxyYW5kVW5pZm9ybTooKT0+S1IscmVwZWF0ZWRUcnk6KCk9PmVNLHJpZ2h0UGFkOigpPT51YyxzaHVmZmxlOigpPT5EUyxzaHVmZmxlQ29tYm86KCk9PkhSLHNpemVGcm9tU2hhcGU6KCk9Pm90LHNpemVUb1NxdWFyaXNoU2hhcGU6KCk9PkpSLHNxdWVlemVTaGFwZTooKT0+TVMsc3VtOigpPT5xUixzd2FwOigpPT5WaCx0YW5oOigpPT5aUix0b05lc3RlZEFycmF5OigpPT5FbCx0b1R5cGVkQXJyYXk6KCk9PlJtfSk7ZnVuY3Rpb24gWFMoZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXl8fGUgaW5zdGFuY2VvZiBJbnQzMkFycmF5fHxlIGluc3RhbmNlb2YgVWludDhBcnJheXx8ZSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5fXZhciBxaz14cyhFUigpKSxZcz1xay5kZWZhdWx0fHxxaztmdW5jdGlvbiB0ZChlKXtyZXR1cm4gWXMuZnJvbVN0cmluZyhlLCEwLDE2KX12YXIgWVM9dGQoXCJjM2E1Yzg1Yzk3Y2IzMTI3XCIpLEtzPXRkKFwiYjQ5MmI2NmZiZTk4ZjI3M1wiKSx3bj10ZChcIjlhZTE2YTNiMmY5MDQwNGZcIik7ZnVuY3Rpb24gd3goZSl7cmV0dXJuIGUueG9yKGUuc2hydSg0NykpfWZ1bmN0aW9uIFpTKGUsdCxuKXtsZXQgYT1lLnNsaWNlKHQsdCtuKTtyZXR1cm4gWXMuZnJvbUJ5dGVzKEFycmF5LmZyb20oYSksITAsITApfWZ1bmN0aW9uIGJ0KGUsdCl7cmV0dXJuIFpTKGUsdCw4KX1mdW5jdGlvbiBLayhlLHQpe3JldHVybiBaUyhlLHQsNCl9ZnVuY3Rpb24gUXQoZSx0KXtyZXR1cm4gdD09PTA/ZTplLnNocnUodCkub3IoZS5zaGwoNjQtdCkpfWZ1bmN0aW9uIG5zKGUsdCxuPXRkKFwiOWRkZmVhMDhlYjM4MmQ2OVwiKSl7bGV0IGE9ZS54b3IodCkubXVsKG4pO2E9YS54b3IoYS5zaHJ1KDQ3KSk7bGV0IHI9dC54b3IoYSkubXVsKG4pO3JldHVybiByPXIueG9yKHIuc2hydSg0NykpLHI9ci5tdWwobikscn1mdW5jdGlvbiB2TShlLHQsbixhLHIscyl7cj1yLmFkZChlKSxzPVF0KHMuYWRkKHIpLmFkZChhKSwyMSk7bGV0IGk9cjtyZXR1cm4gcj1yLmFkZCh0KSxyPXIuYWRkKG4pLHM9cy5hZGQoUXQociw0NCkpLFtyLmFkZChhKSxzLmFkZChpKV19ZnVuY3Rpb24geGgoZSx0LG4sYSl7cmV0dXJuIHZNKGJ0KGUsdCksYnQoZSx0KzgpLGJ0KGUsdCsxNiksYnQoZSx0KzI0KSxuLGEpfWZ1bmN0aW9uIHdNKGUsdD1lLmxlbmd0aCl7aWYodD49OCl7bGV0IG49d24uYWRkKHQqMiksYT1idChlLDApLmFkZCh3bikscj1idChlLHQtOCkscz1RdChyLDM3KS5tdWwobikuYWRkKGEpLGk9UXQoYSwyNSkuYWRkKHIpLm11bChuKTtyZXR1cm4gbnMocyxpLG4pfWlmKHQ+PTQpe2xldCBuPXduLmFkZCh0KjIpLGE9S2soZSwwKTtyZXR1cm4gbnMoYS5zaGwoMykuYWRkKHQpLEtrKGUsdC00KSxuKX1pZih0PjApe2xldCBuPWVbMF0sYT1lW3Q+PjFdLHI9ZVt0LTFdLHM9bisoYTw8OCksaT10KyhyPDwyKTtyZXR1cm4gd3god24ubXVsKHMpLnhvcihZUy5tdWwoaSkpKS5tdWwod24pfXJldHVybiB3bn1mdW5jdGlvbiBrTShlLHQ9ZS5sZW5ndGgpe2xldCBuPXduLmFkZCh0KjIpLGE9YnQoZSwwKS5tdWwoS3MpLHI9YnQoZSw4KSxzPWJ0KGUsdC04KS5tdWwobiksaT1idChlLHQtMTYpLm11bCh3bik7cmV0dXJuIG5zKFF0KGEuYWRkKHIpLDQzKS5hZGQoUXQocywzMCkpLmFkZChpKSxhLmFkZChRdChyLmFkZCh3biksMTgpKS5hZGQocyksbil9ZnVuY3Rpb24gSU0oZSx0PWUubGVuZ3RoKXtsZXQgbj13bi5hZGQodCoyKSxhPWJ0KGUsMCkubXVsKHduKSxyPWJ0KGUsOCkscz1idChlLHQtOCkubXVsKG4pLGk9YnQoZSx0LTE2KS5tdWwod24pLG89UXQoYS5hZGQociksNDMpLmFkZChRdChzLDMwKSkuYWRkKGkpLGw9bnMobyxhLmFkZChRdChyLmFkZCh3biksMTgpKS5hZGQocyksbiksdT1idChlLDE2KS5tdWwobikscD1idChlLDI0KSxkPW8uYWRkKGJ0KGUsdC0zMikpLm11bChuKSxjPWwuYWRkKGJ0KGUsdC0yNCkpLm11bChuKTtyZXR1cm4gbnMoUXQodS5hZGQocCksNDMpLmFkZChRdChkLDMwKSkuYWRkKGMpLHUuYWRkKFF0KHAuYWRkKGEpLDE4KSkuYWRkKGQpLG4pfWZ1bmN0aW9uIFNNKGUsdD1lLmxlbmd0aCl7bGV0IG49WXMuZnJvbU51bWJlcig4MSwhMCk7aWYodDw9MzIpcmV0dXJuIHQ8PTE2P3dNKGUsdCk6a00oZSx0KTtpZih0PD02NClyZXR1cm4gSU0oZSx0KTtsZXQgYT1uLHI9bi5tdWwoS3MpLmFkZCgxMTMpLHM9d3goci5tdWwod24pLmFkZCgxMTMpKS5tdWwod24pLGk9W1lzLlVaRVJPLFlzLlVaRVJPXSxvPVtZcy5VWkVSTyxZcy5VWkVST107YT1hLm11bCh3bikuYWRkKGJ0KGUsMCkpO2xldCBsPTAsdT0odC0xPj42KSo2NCxwPXUrKHQtMSY2MyktNjM7ZG8gYT1RdChhLmFkZChyKS5hZGQoaVswXSkuYWRkKGJ0KGUsbCs4KSksMzcpLm11bChLcykscj1RdChyLmFkZChpWzFdKS5hZGQoYnQoZSxsKzQ4KSksNDIpLm11bChLcyksYT1hLnhvcihvWzFdKSxyPXIuYWRkKGlbMF0pLmFkZChidChlLGwrNDApKSxzPVF0KHMuYWRkKG9bMF0pLDMzKS5tdWwoS3MpLGk9eGgoZSxsLGlbMV0ubXVsKEtzKSxhLmFkZChvWzBdKSksbz14aChlLGwrMzIscy5hZGQob1sxXSksci5hZGQoYnQoZSxsKzE2KSkpLFtzLGFdPVthLHNdLGwrPTY0O3doaWxlKGwhPT11KTtsZXQgZD1Lcy5hZGQocy5hbmQoMjU1KS5zaGwoMSkpO3JldHVybiBsPXAsb1swXT1vWzBdLmFkZCh0LTEmNjMpLGlbMF09aVswXS5hZGQob1swXSksb1swXT1vWzBdLmFkZChpWzBdKSxhPVF0KGEuYWRkKHIpLmFkZChpWzBdKS5hZGQoYnQoZSxsKzgpKSwzNykubXVsKGQpLHI9UXQoci5hZGQoaVsxXSkuYWRkKGJ0KGUsbCs0OCkpLDQyKS5tdWwoZCksYT1hLnhvcihvWzFdLm11bCg5KSkscj1yLmFkZChpWzBdLm11bCg5KS5hZGQoYnQoZSxsKzQwKSkpLHM9UXQocy5hZGQob1swXSksMzMpLm11bChkKSxpPXhoKGUsbCxpWzFdLm11bChkKSxhLmFkZChvWzBdKSksbz14aChlLGwrMzIscy5hZGQob1sxXSksci5hZGQoYnQoZSxsKzE2KSkpLFtzLGFdPVthLHNdLG5zKG5zKGlbMF0sb1swXSxkKS5hZGQod3gocikubXVsKFlTKSkuYWRkKHMpLG5zKGlbMV0sb1sxXSxkKS5hZGQoYSksZCl9ZnVuY3Rpb24gTk0oZSx0KXtyZXR1cm4gdD09PVwic3RyaW5nXCI/bmQoZSk6Um0oW2VdLHQpfWZ1bmN0aW9uIFRNKGUsdCl7cmV0dXJuIGUgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkmJnQ9PT1cImZsb2F0MzJcInx8ZSBpbnN0YW5jZW9mIEludDMyQXJyYXkmJnQ9PT1cImludDMyXCJ8fGUgaW5zdGFuY2VvZiBVaW50OEFycmF5JiZ0PT09XCJib29sXCJ9ZnVuY3Rpb24gUm0oZSx0KXtpZih0PT09XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udmVydCBhIHN0cmluZ1tdIHRvIGEgVHlwZWRBcnJheVwiKTtpZihBcnJheS5pc0FycmF5KGUpJiYoZT1pcyhlKSksRygpLmdldEJvb2woXCJERUJVR1wiKSYmUFMoZSx0KSxUTShlLHQpKXJldHVybiBlO2lmKHQ9PW51bGx8fHQ9PT1cImZsb2F0MzJcInx8dD09PVwiY29tcGxleDY0XCIpcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoZSk7aWYodD09PVwiaW50MzJcIilyZXR1cm4gbmV3IEludDMyQXJyYXkoZSk7aWYodD09PVwiYm9vbFwiKXtsZXQgbj1uZXcgVWludDhBcnJheShlLmxlbmd0aCk7Zm9yKGxldCBhPTA7YTxuLmxlbmd0aDsrK2EpTWF0aC5yb3VuZChlW2FdKSE9PTAmJihuW2FdPTEpO3JldHVybiBufWVsc2UgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGEgdHlwZSAke3R9YCl9ZnVuY3Rpb24gZ2MoKXtyZXR1cm4gRygpLnBsYXRmb3JtLm5vdygpfWZ1bmN0aW9uIENNKGUsdCl7cmV0dXJuIEcoKS5wbGF0Zm9ybS5mZXRjaChlLHQpfWZ1bmN0aW9uIG5kKGUsdD1cInV0Zi04XCIpe3JldHVybiB0PXR8fFwidXRmLThcIixHKCkucGxhdGZvcm0uZW5jb2RlKGUsdCl9ZnVuY3Rpb24gcWgoZSx0PVwidXRmLThcIil7cmV0dXJuIHQ9dHx8XCJ1dGYtOFwiLEcoKS5wbGF0Zm9ybS5kZWNvZGUoZSx0KX1mdW5jdGlvbiBlbihlKXtyZXR1cm4gRygpLnBsYXRmb3JtLmlzVHlwZWRBcnJheSE9bnVsbD9HKCkucGxhdGZvcm0uaXNUeXBlZEFycmF5KGUpOlhTKGUpfWZ1bmN0aW9uIGlzKGUsdD1bXSxuPSExKXtpZih0PT1udWxsJiYodD1bXSksdHlwZW9mIGU9PVwiYm9vbGVhblwifHx0eXBlb2YgZT09XCJudW1iZXJcInx8dHlwZW9mIGU9PVwic3RyaW5nXCJ8fHZtKGUpfHxlPT1udWxsfHxlbihlKSYmbil0LnB1c2goZSk7ZWxzZSBpZihBcnJheS5pc0FycmF5KGUpfHxlbihlKSlmb3IobGV0IGE9MDthPGUubGVuZ3RoOysrYSlpcyhlW2FdLHQsbik7ZWxzZXtsZXQgYT0tMTtmb3IobGV0IHIgb2YgT2JqZWN0LmtleXMoZSkpL14oWzEtOV0rWzAtOV0qfDApJC8udGVzdChyKSYmKGE9TWF0aC5tYXgoYSxOdW1iZXIocikpKTtmb3IobGV0IHI9MDtyPD1hO3IrKylpcyhlW3JdLHQsbil9cmV0dXJuIHR9dmFyIEVNPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5iYWNrZW5kVGltZXI9ZSx0aGlzLmxvZ2dlcj10LHQ9PW51bGwmJih0aGlzLmxvZ2dlcj1uZXcgQU0pfXByb2ZpbGVLZXJuZWwoZSx0LG4pe2xldCBhLHI9KCk9PnthPW4oKX0scyxpPWdjKCk7aWYodGhpcy5iYWNrZW5kVGltZXIudGltZXJBdmFpbGFibGUoKSlzPXRoaXMuYmFja2VuZFRpbWVyLnRpbWUocik7ZWxzZXtyKCk7Zm9yKGxldCBvIG9mIGEpby5kYXRhU3luYygpO3M9UHJvbWlzZS5yZXNvbHZlKHtrZXJuZWxNczpnYygpLWl9KX1pZihHKCkuZ2V0Qm9vbChcIkNIRUNLX0NPTVBVVEFUSU9OX0ZPUl9FUlJPUlNcIikpZm9yKGxldCBvPTA7bzxhLmxlbmd0aDtvKyspe2xldCBsPWFbb107bC5kYXRhKCkudGhlbih1PT57X00odSxsLmR0eXBlLGUpfSl9cmV0dXJue2tlcm5lbE5hbWU6ZSxvdXRwdXRzOmEsaW5wdXRzOnQsdGltZU1zOnMudGhlbihvPT5vLmtlcm5lbE1zKSxleHRyYUluZm86cy50aGVuKG89Pm8uZ2V0RXh0cmFQcm9maWxlSW5mbyE9bnVsbD9vLmdldEV4dHJhUHJvZmlsZUluZm8oKTpcIlwiKX19bG9nS2VybmVsUHJvZmlsZShlKXtsZXR7a2VybmVsTmFtZTp0LG91dHB1dHM6bix0aW1lTXM6YSxpbnB1dHM6cixleHRyYUluZm86c309ZTtuLmZvckVhY2goaT0+e1Byb21pc2UuYWxsKFtpLmRhdGEoKSxhLHNdKS50aGVuKG89Pnt0aGlzLmxvZ2dlci5sb2dLZXJuZWxQcm9maWxlKHQsaSxvWzBdLG9bMV0scixvWzJdKX0pfSl9fTtmdW5jdGlvbiBfTShlLHQsbil7aWYodCE9PVwiZmxvYXQzMlwiKXJldHVybiExO2ZvcihsZXQgYT0wO2E8ZS5sZW5ndGg7YSsrKXtsZXQgcj1lW2FdO2lmKGlzTmFOKHIpfHwhaXNGaW5pdGUocikpcmV0dXJuIGNvbnNvbGUud2FybihgRm91bmQgJHtyfSBpbiB0aGUgcmVzdWx0IG9mICcke259J2ApLCEwfXJldHVybiExfXZhciBBTT1jbGFzc3tsb2dLZXJuZWxQcm9maWxlKGUsdCxuLGEscixzKXtsZXQgaT10eXBlb2YgYT09XCJudW1iZXJcIj91YyhgJHthfW1zYCw5KTphLmVycm9yLG89dWMoZSwyNSksbD10LnJhbmssdT10LnNpemUscD11Yyh0LnNoYXBlLnRvU3RyaW5nKCksMTQpLGQ9XCJcIjtmb3IobGV0IGMgaW4gcil7bGV0IGg9cltjXTtpZihoIT1udWxsKXtsZXQgbT1oLnNoYXBlfHx0LnNoYXBlLGY9bS5sZW5ndGg7ZCs9YCR7Y306ICR7Zn1EICR7Zj4wP206XCJcIn0gYH19Y29uc29sZS5sb2coYCVjJHtvfVx0JWMke2l9XHQlYyR7bH1EICR7cH1cdCVjJHt1fVx0JWMke2R9XHQlYyR7c31gLFwiZm9udC13ZWlnaHQ6Ym9sZFwiLFwiY29sb3I6cmVkXCIsXCJjb2xvcjpibHVlXCIsXCJjb2xvcjogb3JhbmdlXCIsXCJjb2xvcjogZ3JlZW5cIixcImNvbG9yOiBzdGVlbGJsdWVcIil9fTtmdW5jdGlvbiBGTShlLHQsbil7bGV0IGE9e30scj17fTtmb3IobGV0IGw9MDtsPHQubGVuZ3RoO2wrKylhW3RbbF0uaWRdPSEwO2ZvcihsZXQgbD0wO2w8ZS5sZW5ndGg7bCsrKXtsZXQgdT1lW2xdLHA9dS5pbnB1dHM7Zm9yKGxldCBkIGluIHApe2xldCBjPXBbZF0saD0hMTtmb3IobGV0IG09MDttPHQubGVuZ3RoO20rKylpZihhW2MuaWRdKXt1Lm91dHB1dHMuZm9yRWFjaChmPT5hW2YuaWRdPSEwKSxoPSEwLHJbdS5pZF09ITA7YnJlYWt9aWYoaClicmVha319bGV0IHM9e307c1tuLmlkXT0hMDtsZXQgaT17fTtmb3IobGV0IGw9ZS5sZW5ndGgtMTtsPj0wO2wtLSl7bGV0IHU9ZVtsXSxwPXUuaW5wdXRzO2ZvcihsZXQgZD0wO2Q8dS5vdXRwdXRzLmxlbmd0aDtkKyspaWYoc1t1Lm91dHB1dHNbZF0uaWRdKXtmb3IobGV0IGMgaW4gcClzW3BbY10uaWRdPSEwLGlbdS5pZF09ITA7YnJlYWt9fWxldCBvPVtdO2ZvcihsZXQgbD0wO2w8ZS5sZW5ndGg7bCsrKXtsZXQgdT1lW2xdO2lmKHJbdS5pZF0mJmlbdS5pZF0pe2xldCBwPXt9O2ZvcihsZXQgYyBpbiB1LmlucHV0cyl7bGV0IGg9dS5pbnB1dHNbY107YVtoLmlkXSYmKHBbY109aCl9bGV0IGQ9T2JqZWN0LmFzc2lnbih7fSx1KTtkLmlucHV0cz1wLGQub3V0cHV0cz11Lm91dHB1dHMsby5wdXNoKGQpfX1yZXR1cm4gb31mdW5jdGlvbiAkTShlLHQsbixhKXtmb3IobGV0IHI9dC5sZW5ndGgtMTtyPj0wO3ItLSl7bGV0IHM9dFtyXSxpPVtdO2lmKHMub3V0cHV0cy5mb3JFYWNoKGw9PntsZXQgdT1lW2wuaWRdO3UhPW51bGw/aS5wdXNoKHUpOmkucHVzaChudWxsKX0pLHMuZ3JhZGllbnQ9PW51bGwpdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29tcHV0ZSBncmFkaWVudDogZ3JhZGllbnQgZnVuY3Rpb24gbm90IGZvdW5kIGZvciAke3Mua2VybmVsTmFtZX0uYCk7bGV0IG89cy5ncmFkaWVudChpKTtmb3IobGV0IGwgaW4gcy5pbnB1dHMpe2lmKCEobCBpbiBvKSl0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBiYWNrcHJvcCB0aHJvdWdoIGlucHV0ICR7bH0uIEF2YWlsYWJsZSBncmFkaWVudHMgZm91bmQ6ICR7T2JqZWN0LmtleXMobyl9LmApO2xldCB1PW4oKCk9Pm9bbF0oKSk7aWYodS5kdHlwZSE9PVwiZmxvYXQzMlwiKXRocm93IG5ldyBFcnJvcihgRXJyb3IgaW4gZ3JhZGllbnQgZm9yIG9wICR7cy5rZXJuZWxOYW1lfS4gVGhlIGdyYWRpZW50IG9mIGlucHV0ICR7bH0gbXVzdCBoYXZlICdmbG9hdDMyJyBkdHlwZSwgYnV0IGhhcyAnJHt1LmR0eXBlfSdgKTtsZXQgcD1zLmlucHV0c1tsXTtpZighQXIodS5zaGFwZSxwLnNoYXBlKSl0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGluIGdyYWRpZW50IGZvciBvcCAke3Mua2VybmVsTmFtZX0uIFRoZSBncmFkaWVudCBvZiBpbnB1dCAnJHtsfScgaGFzIHNoYXBlICcke3Uuc2hhcGV9Jywgd2hpY2ggZG9lcyBub3QgbWF0Y2ggdGhlIHNoYXBlIG9mIHRoZSBpbnB1dCAnJHtwLnNoYXBlfSdgKTtpZihlW3AuaWRdPT1udWxsKWVbcC5pZF09dTtlbHNle2xldCBkPWVbcC5pZF07ZVtwLmlkXT1hKGQsdSksZC5kaXNwb3NlKCl9fX19dmFyIFhrPTIwLEtwPTMsc3g9NztmdW5jdGlvbiBETShlLHQsbixhKXtsZXQgcj1YbCh0KSxzPVJNKGUsdCxuLHIpLGk9dC5sZW5ndGgsbz1EaChlLHQsbixyLHMpLGw9W1wiVGVuc29yXCJdO3JldHVybiBhJiYobC5wdXNoKGAgIGR0eXBlOiAke259YCksbC5wdXNoKGAgIHJhbms6ICR7aX1gKSxsLnB1c2goYCAgc2hhcGU6IFske3R9XWApLGwucHVzaChcIiAgdmFsdWVzOlwiKSksbC5wdXNoKG8ubWFwKHU9PlwiICAgIFwiK3UpLmpvaW4oYFxuYCkpLGwuam9pbihgXG5gKX1mdW5jdGlvbiBSTShlLHQsbixhKXtsZXQgcj1vdCh0KSxzPWFbYS5sZW5ndGgtMV0saT1uZXcgQXJyYXkocykuZmlsbCgwKSxvPXQubGVuZ3RoLGw9bj09PVwiY29tcGxleDY0XCI/ZWMoZSk6ZTtpZihvPjEpZm9yKGxldCB1PTA7dTxyL3M7dSsrKXtsZXQgcD11KnM7Zm9yKGxldCBkPTA7ZDxzO2QrKylpW2RdPU1hdGgubWF4KGlbZF0sUXAobFtwK2RdLDAsbikubGVuZ3RoKX1yZXR1cm4gaX1mdW5jdGlvbiBRcChlLHQsbil7bGV0IGE7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/YT1gJHtwYXJzZUZsb2F0KGVbMF0udG9GaXhlZChzeCkpfSArICR7cGFyc2VGbG9hdChlWzFdLnRvRml4ZWQoc3gpKX1qYDpKcihlKT9hPWAnJHtlfSdgOm49PT1cImJvb2xcIj9hPUpTKGUpOmE9cGFyc2VGbG9hdChlLnRvRml4ZWQoc3gpKS50b1N0cmluZygpLHVjKGEsdCl9ZnVuY3Rpb24gSlMoZSl7cmV0dXJuIGU9PT0wP1wiZmFsc2VcIjpcInRydWVcIn1mdW5jdGlvbiBEaChlLHQsbixhLHIscz0hMCl7bGV0IGk9bj09PVwiY29tcGxleDY0XCI/MjoxLG89dFswXSxsPXQubGVuZ3RoO2lmKGw9PT0wKXtpZihuPT09XCJjb21wbGV4NjRcIil7bGV0IGY9ZWMoZSk7cmV0dXJuW1FwKGZbMF0sMCxuKV19cmV0dXJuIG49PT1cImJvb2xcIj9bSlMoZVswXSldOltlWzBdLnRvU3RyaW5nKCldfWlmKGw9PT0xKXtpZihvPlhrKXtsZXQgZj1LcCppLGc9QXJyYXkuZnJvbShlLnNsaWNlKDAsZikpLGI9QXJyYXkuZnJvbShlLnNsaWNlKChvLUtwKSppLG8qaSkpO3JldHVybiBuPT09XCJjb21wbGV4NjRcIiYmKGc9ZWMoZyksYj1lYyhiKSksW1wiW1wiK2cubWFwKCh5LHgpPT5RcCh5LHJbeF0sbikpLmpvaW4oXCIsIFwiKStcIiwgLi4uLCBcIitiLm1hcCgoeSx4KT0+UXAoeSxyW28tS3AreF0sbikpLmpvaW4oXCIsIFwiKStcIl1cIl19cmV0dXJuW1wiW1wiKyhuPT09XCJjb21wbGV4NjRcIj9lYyhlKTpBcnJheS5mcm9tKGUpKS5tYXAoKGYsZyk9PlFwKGYscltnXSxuKSkuam9pbihcIiwgXCIpK1wiXVwiXX1sZXQgdT10LnNsaWNlKDEpLHA9YS5zbGljZSgxKSxkPWFbMF0qaSxjPVtdO2lmKG8+WGspe2ZvcihsZXQgZj0wO2Y8S3A7ZisrKXtsZXQgZz1mKmQsYj1nK2Q7Yy5wdXNoKC4uLkRoKGUuc2xpY2UoZyxiKSx1LG4scCxyLCExKSl9Yy5wdXNoKFwiLi4uXCIpO2ZvcihsZXQgZj1vLUtwO2Y8bztmKyspe2xldCBnPWYqZCxiPWcrZDtjLnB1c2goLi4uRGgoZS5zbGljZShnLGIpLHUsbixwLHIsZj09PW8tMSkpfX1lbHNlIGZvcihsZXQgZj0wO2Y8bztmKyspe2xldCBnPWYqZCxiPWcrZDtjLnB1c2goLi4uRGgoZS5zbGljZShnLGIpLHUsbixwLHIsZj09PW8tMSkpfWxldCBoPWw9PT0yP1wiLFwiOlwiXCI7Y1swXT1cIltcIisobz4wP2NbMF0raDpcIlwiKTtmb3IobGV0IGY9MTtmPGMubGVuZ3RoLTE7ZisrKWNbZl09XCIgXCIrY1tmXStoO2xldCBtPWAsXG5gO2ZvcihsZXQgZj0yO2Y8bDtmKyspbSs9YFxuYDtyZXR1cm4gY1tjLmxlbmd0aC0xXT1cIiBcIitjW2MubGVuZ3RoLTFdK1wiXVwiKyhzP1wiXCI6bSksY31mdW5jdGlvbiBlYyhlKXtsZXQgdD1bXTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rPTIpdC5wdXNoKFtlW25dLGVbbisxXV0pO3JldHVybiB0fXZhciBXdD1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbil7aWYodGhpcy5kdHlwZT10LHRoaXMuc2hhcGU9ZS5zbGljZSgpLHRoaXMuc2l6ZT1vdChlKSxuIT1udWxsKXtsZXQgYT1uLmxlbmd0aDtBKGE9PT10aGlzLnNpemUsKCk9PmBMZW5ndGggb2YgdmFsdWVzICcke2F9JyBkb2VzIG5vdCBtYXRjaCB0aGUgc2l6ZSBpbmZlcnJlZCBieSB0aGUgc2hhcGUgJyR7dGhpcy5zaXplfScuYCl9aWYodD09PVwiY29tcGxleDY0XCIpdGhyb3cgbmV3IEVycm9yKFwiY29tcGxleDY0IGR0eXBlIFRlbnNvckJ1ZmZlcnMgYXJlIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSBjcmVhdGUgYSBUZW5zb3JCdWZmZXIgZm9yIHRoZSByZWFsIGFuZCBpbWFnaW5hcnkgcGFydHMgc2VwYXJhdGVseSBhbmQgY2FsbCB0Zi5jb21wbGV4KHJlYWwsIGltYWcpLlwiKTt0aGlzLnZhbHVlcz1ufHxTdih0LHRoaXMuc2l6ZSksdGhpcy5zdHJpZGVzPVhsKGUpfXNldChlLC4uLnQpe3QubGVuZ3RoPT09MCYmKHQ9WzBdKSxBKHQubGVuZ3RoPT09dGhpcy5yYW5rLCgpPT5gVGhlIG51bWJlciBvZiBwcm92aWRlZCBjb29yZGluYXRlcyAoJHt0Lmxlbmd0aH0pIG11c3QgbWF0Y2ggdGhlIHJhbmsgKCR7dGhpcy5yYW5rfSlgKTtsZXQgbj10aGlzLmxvY1RvSW5kZXgodCk7dGhpcy52YWx1ZXNbbl09ZX1nZXQoLi4uZSl7ZS5sZW5ndGg9PT0wJiYoZT1bMF0pO2xldCB0PTA7Zm9yKGxldCBhIG9mIGUpe2lmKGE8MHx8YT49dGhpcy5zaGFwZVt0XSl7bGV0IHI9YFJlcXVlc3RlZCBvdXQgb2YgcmFuZ2UgZWxlbWVudCBhdCAke2V9LiAgIEJ1ZmZlciBzaGFwZT0ke3RoaXMuc2hhcGV9YDt0aHJvdyBuZXcgRXJyb3Iocil9dCsrfWxldCBuPWVbZS5sZW5ndGgtMV07Zm9yKGxldCBhPTA7YTxlLmxlbmd0aC0xOysrYSluKz10aGlzLnN0cmlkZXNbYV0qZVthXTtyZXR1cm4gdGhpcy52YWx1ZXNbbl19bG9jVG9JbmRleChlKXtpZih0aGlzLnJhbms9PT0wKXJldHVybiAwO2lmKHRoaXMucmFuaz09PTEpcmV0dXJuIGVbMF07bGV0IHQ9ZVtlLmxlbmd0aC0xXTtmb3IobGV0IG49MDtuPGUubGVuZ3RoLTE7KytuKXQrPXRoaXMuc3RyaWRlc1tuXSplW25dO3JldHVybiB0fWluZGV4VG9Mb2MoZSl7aWYodGhpcy5yYW5rPT09MClyZXR1cm5bXTtpZih0aGlzLnJhbms9PT0xKXJldHVybltlXTtsZXQgdD1uZXcgQXJyYXkodGhpcy5zaGFwZS5sZW5ndGgpO2ZvcihsZXQgbj0wO248dC5sZW5ndGgtMTsrK24pdFtuXT1NYXRoLmZsb29yKGUvdGhpcy5zdHJpZGVzW25dKSxlLT10W25dKnRoaXMuc3RyaWRlc1tuXTtyZXR1cm4gdFt0Lmxlbmd0aC0xXT1lLHR9Z2V0IHJhbmsoKXtyZXR1cm4gdGhpcy5zaGFwZS5sZW5ndGh9dG9UZW5zb3IoKXtyZXR1cm4gemEoKS5tYWtlVGVuc29yKHRoaXMudmFsdWVzLHRoaXMuc2hhcGUsdGhpcy5kdHlwZSl9fSx6YT1udWxsLFNsPW51bGwsTU09bnVsbDtmdW5jdGlvbiBPTShlKXt6YT1lfWZ1bmN0aW9uIFBNKGUpe1NsPWV9ZnVuY3Rpb24gTE0oZSl7TU09ZX12YXIgQ2U9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4sYSl7dGhpcy5rZXB0PSExLHRoaXMuaXNEaXNwb3NlZEludGVybmFsPSExLHRoaXMuc2hhcGU9ZS5zbGljZSgpLHRoaXMuZHR5cGU9dHx8XCJmbG9hdDMyXCIsdGhpcy5zaXplPW90KGUpLHRoaXMuc3RyaWRlcz1YbChlKSx0aGlzLmRhdGFJZD1uLHRoaXMuaWQ9YSx0aGlzLnJhbmtUeXBlPXRoaXMucmFuazw1P3RoaXMucmFuay50b1N0cmluZygpOlwiaGlnaGVyXCJ9Z2V0IHJhbmsoKXtyZXR1cm4gdGhpcy5zaGFwZS5sZW5ndGh9YXN5bmMgYnVmZmVyKCl7bGV0IGU9YXdhaXQgdGhpcy5kYXRhKCk7cmV0dXJuIFNsLmJ1ZmZlcih0aGlzLnNoYXBlLHRoaXMuZHR5cGUsZSl9YnVmZmVyU3luYygpe3JldHVybiBTbC5idWZmZXIodGhpcy5zaGFwZSx0aGlzLmR0eXBlLHRoaXMuZGF0YVN5bmMoKSl9YXN5bmMgYXJyYXkoKXtsZXQgZT1hd2FpdCB0aGlzLmRhdGEoKTtyZXR1cm4gRWwodGhpcy5zaGFwZSxlLHRoaXMuZHR5cGU9PT1cImNvbXBsZXg2NFwiKX1hcnJheVN5bmMoKXtyZXR1cm4gRWwodGhpcy5zaGFwZSx0aGlzLmRhdGFTeW5jKCksdGhpcy5kdHlwZT09PVwiY29tcGxleDY0XCIpfWFzeW5jIGRhdGEoKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpO2xldCBlPXphKCkucmVhZCh0aGlzLmRhdGFJZCk7aWYodGhpcy5kdHlwZT09PVwic3RyaW5nXCIpe2xldCB0PWF3YWl0IGU7dHJ5e3JldHVybiB0Lm1hcChuPT5xaChuKSl9Y2F0Y2gobil7dGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlY29kZSB0aGUgc3RyaW5nIGJ5dGVzIGludG8gdXRmLTguIFRvIGdldCB0aGUgb3JpZ2luYWwgYnl0ZXMsIGNhbGwgdGVuc29yLmJ5dGVzKCkuXCIpfX1yZXR1cm4gZX1kYXRhVG9HUFUoZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksemEoKS5yZWFkVG9HUFUodGhpcy5kYXRhSWQsZSl9ZGF0YVN5bmMoKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpO2xldCBlPXphKCkucmVhZFN5bmModGhpcy5kYXRhSWQpO2lmKHRoaXMuZHR5cGU9PT1cInN0cmluZ1wiKXRyeXtyZXR1cm4gZS5tYXAodD0+cWgodCkpfWNhdGNoKHQpe3Rocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZWNvZGUgdGhlIHN0cmluZyBieXRlcyBpbnRvIHV0Zi04LiBUbyBnZXQgdGhlIG9yaWdpbmFsIGJ5dGVzLCBjYWxsIHRlbnNvci5ieXRlcygpLlwiKX1yZXR1cm4gZX1hc3luYyBieXRlcygpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCk7bGV0IGU9YXdhaXQgemEoKS5yZWFkKHRoaXMuZGF0YUlkKTtyZXR1cm4gdGhpcy5kdHlwZT09PVwic3RyaW5nXCI/ZTpuZXcgVWludDhBcnJheShlLmJ1ZmZlcil9ZGlzcG9zZSgpe3RoaXMuaXNEaXNwb3NlZHx8KHRoaXMua2VyYXNNYXNrJiZ0aGlzLmtlcmFzTWFzay5kaXNwb3NlKCksemEoKS5kaXNwb3NlVGVuc29yKHRoaXMpLHRoaXMuaXNEaXNwb3NlZEludGVybmFsPSEwKX1nZXQgaXNEaXNwb3NlZCgpe3JldHVybiB0aGlzLmlzRGlzcG9zZWRJbnRlcm5hbH10aHJvd0lmRGlzcG9zZWQoKXtpZih0aGlzLmlzRGlzcG9zZWQpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIGlzIGRpc3Bvc2VkLlwiKX1wcmludChlPSExKXtyZXR1cm4gU2wucHJpbnQodGhpcyxlKX1jbG9uZSgpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFNsLmNsb25lKHRoaXMpfXRvU3RyaW5nKGU9ITEpe2xldCB0PXRoaXMuZGF0YVN5bmMoKTtyZXR1cm4gRE0odCx0aGlzLnNoYXBlLHRoaXMuZHR5cGUsZSl9Y2FzdChlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxTbC5jYXN0KHRoaXMsZSl9dmFyaWFibGUoZT0hMCx0LG4pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHphKCkubWFrZVZhcmlhYmxlKHRoaXMsZSx0LG4pfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KENlLFN5bWJvbC5oYXNJbnN0YW5jZSx7dmFsdWU6ZT0+ISFlJiZlLmRhdGEhPW51bGwmJmUuZGF0YVN5bmMhPW51bGwmJmUudGhyb3dJZkRpc3Bvc2VkIT1udWxsfSk7ZnVuY3Rpb24gUSgpe3JldHVybiBDdihcIlRlbnNvclwiLCgpPT5DZSl9USgpO3ZhciBvcz1jbGFzcyBleHRlbmRzIENle2NvbnN0cnVjdG9yKGUsdCxuLGEpe3N1cGVyKGUuc2hhcGUsZS5kdHlwZSxlLmRhdGFJZCxhKSx0aGlzLnRyYWluYWJsZT10LHRoaXMubmFtZT1ufWFzc2lnbihlKXtpZihlLmR0eXBlIT09dGhpcy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoYGR0eXBlIG9mIHRoZSBuZXcgdmFsdWUgKCR7ZS5kdHlwZX0pIGFuZCBwcmV2aW91cyB2YWx1ZSAoJHt0aGlzLmR0eXBlfSkgbXVzdCBtYXRjaGApO2lmKCFBcihlLnNoYXBlLHRoaXMuc2hhcGUpKXRocm93IG5ldyBFcnJvcihgc2hhcGUgb2YgdGhlIG5ldyB2YWx1ZSAoJHtlLnNoYXBlfSkgYW5kIHByZXZpb3VzIHZhbHVlICgke3RoaXMuc2hhcGV9KSBtdXN0IG1hdGNoYCk7emEoKS5kaXNwb3NlVGVuc29yKHRoaXMpLHRoaXMuZGF0YUlkPWUuZGF0YUlkLHphKCkuaW5jUmVmKHRoaXMsbnVsbCl9ZGlzcG9zZSgpe3phKCkuZGlzcG9zZVZhcmlhYmxlKHRoaXMpLHRoaXMuaXNEaXNwb3NlZEludGVybmFsPSEwfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KG9zLFN5bWJvbC5oYXNJbnN0YW5jZSx7dmFsdWU6ZT0+ZSBpbnN0YW5jZW9mIENlJiZlLmFzc2lnbiE9bnVsbCYmZS5hc3NpZ24gaW5zdGFuY2VvZiBGdW5jdGlvbn0pO3ZhciBXYT17fTtfZShXYSx7YXNzZXJ0VHlwZXNNYXRjaDooKT0+dE4sZ2V0VGVuc29yc0luQ29udGFpbmVyOigpPT5fdixpc1RlbnNvckluTGlzdDooKT0+V00sbWFrZVR5cGVzTWF0Y2g6KCk9Pl90fSk7dmFyIGt4OyhmdW5jdGlvbihlKXtlLlIwPVwiUjBcIixlLlIxPVwiUjFcIixlLlIyPVwiUjJcIixlLlIzPVwiUjNcIixlLlI0PVwiUjRcIixlLlI1PVwiUjVcIixlLlI2PVwiUjZcIn0pKGt4fHwoa3g9e30pKTt2YXIgSXg7KGZ1bmN0aW9uKGUpe2UuZmxvYXQzMj1cImZsb2F0MzJcIixlLmludDMyPVwiaW50MzJcIixlLmJvb2w9XCJpbnQzMlwiLGUuY29tcGxleDY0PVwiY29tcGxleDY0XCJ9KShJeHx8KEl4PXt9KSk7dmFyIFN4OyhmdW5jdGlvbihlKXtlLmZsb2F0MzI9XCJmbG9hdDMyXCIsZS5pbnQzMj1cImludDMyXCIsZS5ib29sPVwiYm9vbFwiLGUuY29tcGxleDY0PVwiY29tcGxleDY0XCJ9KShTeHx8KFN4PXt9KSk7dmFyIE54OyhmdW5jdGlvbihlKXtlLmZsb2F0MzI9XCJmbG9hdDMyXCIsZS5pbnQzMj1cImZsb2F0MzJcIixlLmJvb2w9XCJmbG9hdDMyXCIsZS5jb21wbGV4NjQ9XCJjb21wbGV4NjRcIn0pKE54fHwoTng9e30pKTt2YXIgVHg7KGZ1bmN0aW9uKGUpe2UuZmxvYXQzMj1cImNvbXBsZXg2NFwiLGUuaW50MzI9XCJjb21wbGV4NjRcIixlLmJvb2w9XCJjb21wbGV4NjRcIixlLmNvbXBsZXg2ND1cImNvbXBsZXg2NFwifSkoVHh8fChUeD17fSkpO3ZhciB6TT17ZmxvYXQzMjpOeCxpbnQzMjpJeCxib29sOlN4LGNvbXBsZXg2NDpUeH07ZnVuY3Rpb24gZmEoZSx0KXtpZihlPT09XCJzdHJpbmdcInx8dD09PVwic3RyaW5nXCIpe2lmKGU9PT1cInN0cmluZ1wiJiZ0PT09XCJzdHJpbmdcIilyZXR1cm5cInN0cmluZ1wiO3Rocm93IG5ldyBFcnJvcihgQ2FuIG5vdCB1cGNhc3QgJHtlfSB3aXRoICR7dH1gKX1yZXR1cm4gek1bZV1bdF19ZnVuY3Rpb24gTW0oZSl7cmV0dXJuIGZhKGUsXCJpbnQzMlwiKX1mdW5jdGlvbiBRUyhlKXtyZXR1cm4gZSE9bnVsbCYmdHlwZW9mIGU9PVwib2JqZWN0XCImJlwidGV4dHVyZVwiaW4gZSYmZS50ZXh0dXJlIGluc3RhbmNlb2YgV2ViR0xUZXh0dXJlfWZ1bmN0aW9uIGVOKGUpe3JldHVybiB0eXBlb2YgR1BVQnVmZmVyIT1cInVuZGVmaW5lZFwiJiZlIT1udWxsJiZ0eXBlb2YgZT09XCJvYmplY3RcIiYmXCJidWZmZXJcImluIGUmJmUuYnVmZmVyIGluc3RhbmNlb2YgR1BVQnVmZmVyfWZ1bmN0aW9uIF90KGUsdCl7aWYoZS5kdHlwZT09PXQuZHR5cGUpcmV0dXJuW2UsdF07bGV0IG49ZmEoZS5kdHlwZSx0LmR0eXBlKTtyZXR1cm5bZS5jYXN0KG4pLHQuY2FzdChuKV19ZnVuY3Rpb24gdE4oZSx0KXtBKGUuZHR5cGU9PT10LmR0eXBlLCgpPT5gVGhlIGR0eXBlcyBvZiB0aGUgZmlyc3QoJHtlLmR0eXBlfSkgYW5kIHNlY29uZCgke3QuZHR5cGV9KSBpbnB1dCBtdXN0IG1hdGNoYCl9ZnVuY3Rpb24gV00oZSx0KXtyZXR1cm4gdC5zb21lKG49Pm4uaWQ9PT1lLmlkKX1mdW5jdGlvbiBfdihlKXtsZXQgdD1bXTtyZXR1cm4gbk4oZSx0LG5ldyBTZXQpLHR9ZnVuY3Rpb24gbk4oZSx0LG4pe2lmKGU9PW51bGwpcmV0dXJuO2lmKGUgaW5zdGFuY2VvZiBDZSl7dC5wdXNoKGUpO3JldHVybn1pZighQk0oZSkpcmV0dXJuO2xldCBhPWU7Zm9yKGxldCByIGluIGEpe2xldCBzPWFbcl07bi5oYXMocyl8fChuLmFkZChzKSxuTihzLHQsbikpfX1mdW5jdGlvbiBCTShlKXtyZXR1cm4gQXJyYXkuaXNBcnJheShlKXx8dHlwZW9mIGU9PVwib2JqZWN0XCJ9ZnVuY3Rpb24gaXgoZSl7cmV0dXJuIGUua2VybmVsTmFtZSE9bnVsbH12YXIgWWs9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXM9e30sdGhpcy5uZXh0VGFwZU5vZGVJZD0wLHRoaXMubnVtQnl0ZXM9MCx0aGlzLm51bVRlbnNvcnM9MCx0aGlzLm51bVN0cmluZ1RlbnNvcnM9MCx0aGlzLm51bURhdGFCdWZmZXJzPTAsdGhpcy5ncmFkaWVudERlcHRoPTAsdGhpcy5rZXJuZWxEZXB0aD0wLHRoaXMuc2NvcGVTdGFjaz1bXSx0aGlzLm51bURhdGFNb3Zlc1N0YWNrPVtdLHRoaXMubmV4dFNjb3BlSWQ9MCx0aGlzLnRlbnNvckluZm89bmV3IFdlYWtNYXAsdGhpcy5wcm9maWxpbmc9ITEsdGhpcy5hY3RpdmVQcm9maWxlPXtuZXdCeXRlczowLG5ld1RlbnNvcnM6MCxwZWFrQnl0ZXM6MCxrZXJuZWxzOltdLHJlc3VsdDpudWxsLGdldCBrZXJuZWxOYW1lcygpe3JldHVybiBBcnJheS5mcm9tKG5ldyBTZXQodGhpcy5rZXJuZWxzLm1hcChlPT5lLm5hbWUpKSl9fX1kaXNwb3NlKCl7Zm9yKGxldCBlIGluIHRoaXMucmVnaXN0ZXJlZFZhcmlhYmxlcyl0aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXNbZV0uZGlzcG9zZSgpfX0sQXY9Y2xhc3MgQ3h7Y29uc3RydWN0b3IodCl7dGhpcy5FTlY9dCx0aGlzLnJlZ2lzdHJ5PXt9LHRoaXMucmVnaXN0cnlGYWN0b3J5PXt9LHRoaXMucGVuZGluZ0JhY2tlbmRJbml0SWQ9MCx0aGlzLnN0YXRlPW5ldyBZa31hc3luYyByZWFkeSgpe2lmKHRoaXMucGVuZGluZ0JhY2tlbmRJbml0IT1udWxsKXJldHVybiB0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdC50aGVuKCgpPT57fSk7aWYodGhpcy5iYWNrZW5kSW5zdGFuY2UhPW51bGwpcmV0dXJuO2xldCB0PXRoaXMuZ2V0U29ydGVkQmFja2VuZHMoKTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyl7bGV0IGE9dFtuXTtpZihhd2FpdCB0aGlzLmluaXRpYWxpemVCYWNrZW5kKGEpLnN1Y2Nlc3Mpe2F3YWl0IHRoaXMuc2V0QmFja2VuZChhKTtyZXR1cm59fXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBpbml0aWFsaXplIGFueSBiYWNrZW5kcywgYWxsIGJhY2tlbmQgaW5pdGlhbGl6YXRpb25zIGZhaWxlZC5cIil9Z2V0IGJhY2tlbmQoKXtpZih0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdCE9bnVsbCl0aHJvdyBuZXcgRXJyb3IoYEJhY2tlbmQgJyR7dGhpcy5iYWNrZW5kTmFtZX0nIGhhcyBub3QgeWV0IGJlZW4gaW5pdGlhbGl6ZWQuIE1ha2Ugc3VyZSB0byBhd2FpdCB0Zi5yZWFkeSgpIG9yIGF3YWl0IHRmLnNldEJhY2tlbmQoKSBiZWZvcmUgY2FsbGluZyBvdGhlciBtZXRob2RzYCk7aWYodGhpcy5iYWNrZW5kSW5zdGFuY2U9PW51bGwpe2xldHtuYW1lOnQsYXN5bmNJbml0Om59PXRoaXMuaW5pdGlhbGl6ZUJhY2tlbmRzQW5kUmV0dXJuQmVzdCgpO2lmKG4pdGhyb3cgbmV3IEVycm9yKGBUaGUgaGlnaGVzdCBwcmlvcml0eSBiYWNrZW5kICcke3R9JyBoYXMgbm90IHlldCBiZWVuIGluaXRpYWxpemVkLiBNYWtlIHN1cmUgdG8gYXdhaXQgdGYucmVhZHkoKSBvciBhd2FpdCB0Zi5zZXRCYWNrZW5kKCkgYmVmb3JlIGNhbGxpbmcgb3RoZXIgbWV0aG9kc2ApO3RoaXMuc2V0QmFja2VuZCh0KX1yZXR1cm4gdGhpcy5iYWNrZW5kSW5zdGFuY2V9YmFja2VuZE5hbWVzKCl7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucmVnaXN0cnlGYWN0b3J5KX1maW5kQmFja2VuZCh0KXtpZighKHQgaW4gdGhpcy5yZWdpc3RyeSkpaWYodCBpbiB0aGlzLnJlZ2lzdHJ5RmFjdG9yeSl7bGV0e2FzeW5jSW5pdDpufT10aGlzLmluaXRpYWxpemVCYWNrZW5kKHQpO2lmKG4pcmV0dXJuIG51bGx9ZWxzZSByZXR1cm4gbnVsbDtyZXR1cm4gdGhpcy5yZWdpc3RyeVt0XX1maW5kQmFja2VuZEZhY3RvcnkodCl7cmV0dXJuIHQgaW4gdGhpcy5yZWdpc3RyeUZhY3Rvcnk/dGhpcy5yZWdpc3RyeUZhY3RvcnlbdF0uZmFjdG9yeTpudWxsfXJlZ2lzdGVyQmFja2VuZCh0LG4sYT0xKXtyZXR1cm4gdCBpbiB0aGlzLnJlZ2lzdHJ5RmFjdG9yeT8oWnIoYCR7dH0gYmFja2VuZCB3YXMgYWxyZWFkeSByZWdpc3RlcmVkLiBSZXVzaW5nIGV4aXN0aW5nIGJhY2tlbmQgZmFjdG9yeS5gKSwhMSk6KHRoaXMucmVnaXN0cnlGYWN0b3J5W3RdPXtmYWN0b3J5Om4scHJpb3JpdHk6YX0sITApfWFzeW5jIHNldEJhY2tlbmQodCl7aWYodGhpcy5yZWdpc3RyeUZhY3RvcnlbdF09PW51bGwpdGhyb3cgbmV3IEVycm9yKGBCYWNrZW5kIG5hbWUgJyR7dH0nIG5vdCBmb3VuZCBpbiByZWdpc3RyeWApO2lmKHRoaXMuYmFja2VuZE5hbWU9dCx0aGlzLnJlZ2lzdHJ5W3RdPT1udWxsKXt0aGlzLmJhY2tlbmRJbnN0YW5jZT1udWxsO2xldHtzdWNjZXNzOm4sYXN5bmNJbml0OmF9PXRoaXMuaW5pdGlhbGl6ZUJhY2tlbmQodCk7aWYoIShhP2F3YWl0IG46bikpcmV0dXJuITF9cmV0dXJuIHRoaXMuYmFja2VuZEluc3RhbmNlPXRoaXMucmVnaXN0cnlbdF0sdGhpcy5zZXR1cFJlZ2lzdGVyZWRLZXJuZWxzKCksdGhpcy5wcm9maWxlcj1uZXcgRU0odGhpcy5iYWNrZW5kSW5zdGFuY2UpLCEwfXNldHVwUmVnaXN0ZXJlZEtlcm5lbHMoKXtqaCh0aGlzLmJhY2tlbmROYW1lKS5mb3JFYWNoKHQ9Pnt0LnNldHVwRnVuYyE9bnVsbCYmdC5zZXR1cEZ1bmModGhpcy5iYWNrZW5kSW5zdGFuY2UpfSl9ZGlzcG9zZVJlZ2lzdGVyZWRLZXJuZWxzKHQpe2poKHQpLmZvckVhY2gobj0+e24uZGlzcG9zZUZ1bmMhPW51bGwmJm4uZGlzcG9zZUZ1bmModGhpcy5yZWdpc3RyeVt0XSl9KX1pbml0aWFsaXplQmFja2VuZCh0KXtsZXQgbj10aGlzLnJlZ2lzdHJ5RmFjdG9yeVt0XTtpZihuPT1udWxsKXRocm93IG5ldyBFcnJvcihgQ2Fubm90IGluaXRpYWxpemUgYmFja2VuZCAke3R9LCBubyByZWdpc3RyYXRpb24gZm91bmQuYCk7dHJ5e2xldCBhPW4uZmFjdG9yeSgpO2lmKGEmJiEoYSBpbnN0YW5jZW9mIEZjKSYmdHlwZW9mIGEudGhlbj09XCJmdW5jdGlvblwiKXtsZXQgcj0rK3RoaXMucGVuZGluZ0JhY2tlbmRJbml0SWQscz1hLnRoZW4oaT0+cjx0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdElkPyExOih0aGlzLnJlZ2lzdHJ5W3RdPWksdGhpcy5wZW5kaW5nQmFja2VuZEluaXQ9bnVsbCwhMCkpLmNhdGNoKGk9PihyPHRoaXMucGVuZGluZ0JhY2tlbmRJbml0SWR8fCh0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdD1udWxsLFpyKGBJbml0aWFsaXphdGlvbiBvZiBiYWNrZW5kICR7dH0gZmFpbGVkYCksWnIoaS5zdGFja3x8aS5tZXNzYWdlKSksITEpKTtyZXR1cm4gdGhpcy5wZW5kaW5nQmFja2VuZEluaXQ9cyx7c3VjY2VzczpzLGFzeW5jSW5pdDohMH19ZWxzZSByZXR1cm4gdGhpcy5yZWdpc3RyeVt0XT1hLHtzdWNjZXNzOiEwLGFzeW5jSW5pdDohMX19Y2F0Y2goYSl7cmV0dXJuIFpyKGBJbml0aWFsaXphdGlvbiBvZiBiYWNrZW5kICR7dH0gZmFpbGVkYCksWnIoYS5zdGFja3x8YS5tZXNzYWdlKSx7c3VjY2VzczohMSxhc3luY0luaXQ6ITF9fX1yZW1vdmVCYWNrZW5kKHQpe2lmKCEodCBpbiB0aGlzLnJlZ2lzdHJ5RmFjdG9yeSkpdGhyb3cgbmV3IEVycm9yKGAke3R9IGJhY2tlbmQgbm90IGZvdW5kIGluIHJlZ2lzdHJ5YCk7dGhpcy5iYWNrZW5kTmFtZT09PXQmJnRoaXMucGVuZGluZ0JhY2tlbmRJbml0IT1udWxsJiZ0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdElkKyssdCBpbiB0aGlzLnJlZ2lzdHJ5JiYodGhpcy5kaXNwb3NlUmVnaXN0ZXJlZEtlcm5lbHModCksdGhpcy5yZWdpc3RyeVt0XS5kaXNwb3NlKCksZGVsZXRlIHRoaXMucmVnaXN0cnlbdF0pLGRlbGV0ZSB0aGlzLnJlZ2lzdHJ5RmFjdG9yeVt0XSx0aGlzLmJhY2tlbmROYW1lPT09dCYmKHRoaXMucGVuZGluZ0JhY2tlbmRJbml0PW51bGwsdGhpcy5iYWNrZW5kTmFtZT1udWxsLHRoaXMuYmFja2VuZEluc3RhbmNlPW51bGwpfWdldFNvcnRlZEJhY2tlbmRzKCl7aWYoT2JqZWN0LmtleXModGhpcy5yZWdpc3RyeUZhY3RvcnkpLmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKFwiTm8gYmFja2VuZCBmb3VuZCBpbiByZWdpc3RyeS5cIik7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucmVnaXN0cnlGYWN0b3J5KS5zb3J0KCh0LG4pPT50aGlzLnJlZ2lzdHJ5RmFjdG9yeVtuXS5wcmlvcml0eS10aGlzLnJlZ2lzdHJ5RmFjdG9yeVt0XS5wcmlvcml0eSl9aW5pdGlhbGl6ZUJhY2tlbmRzQW5kUmV0dXJuQmVzdCgpe2xldCB0PXRoaXMuZ2V0U29ydGVkQmFja2VuZHMoKTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyl7bGV0IGE9dFtuXSx7c3VjY2VzczpyLGFzeW5jSW5pdDpzfT10aGlzLmluaXRpYWxpemVCYWNrZW5kKGEpO2lmKHN8fHIpcmV0dXJue25hbWU6YSxhc3luY0luaXQ6c319dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGluaXRpYWxpemUgYW55IGJhY2tlbmRzLCBhbGwgYmFja2VuZCBpbml0aWFsaXphdGlvbnMgZmFpbGVkLlwiKX1tb3ZlRGF0YSh0LG4pe2xldCBhPXRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQobikscj1hLmJhY2tlbmQscz10aGlzLnJlYWRTeW5jKG4pLGk9ci5yZWZDb3VudChuKTtyLmRpc3Bvc2VEYXRhKG4sITApLGEuYmFja2VuZD10LHQubW92ZShuLHMsYS5zaGFwZSxhLmR0eXBlLGkpLHRoaXMuc2hvdWxkQ2hlY2tGb3JNZW1MZWFrcygpJiZ0aGlzLnN0YXRlLm51bURhdGFNb3Zlc1N0YWNrW3RoaXMuc3RhdGUubnVtRGF0YU1vdmVzU3RhY2subGVuZ3RoLTFdKyt9dGlkeSh0LG4pe2xldCBhPW51bGw7aWYobj09bnVsbCl7aWYodHlwZW9mIHQhPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBhIGZ1bmN0aW9uIHRvIHRpZHkoKVwiKTtuPXR9ZWxzZXtpZih0eXBlb2YgdCE9XCJzdHJpbmdcIiYmISh0IGluc3RhbmNlb2YgU3RyaW5nKSl0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIGNhbGxpbmcgd2l0aCB0d28gYXJndW1lbnRzLCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGlkeSgpIG11c3QgYmUgYSBzdHJpbmdcIik7aWYodHlwZW9mIG4hPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIGNhbGxpbmcgd2l0aCB0d28gYXJndW1lbnRzLCB0aGUgMm5kIGFyZ3VtZW50IHRvIHRpZHkoKSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7YT10fWxldCByO3JldHVybiB0aGlzLnNjb3BlZFJ1bigoKT0+dGhpcy5zdGFydFNjb3BlKGEpLCgpPT50aGlzLmVuZFNjb3BlKHIpLCgpPT4ocj1uKCksciBpbnN0YW5jZW9mIFByb21pc2UmJmNvbnNvbGUuZXJyb3IoXCJDYW5ub3QgcmV0dXJuIGEgUHJvbWlzZSBpbnNpZGUgb2YgdGlkeS5cIikscikpfXNjb3BlZFJ1bih0LG4sYSl7dCgpO3RyeXtsZXQgcj1hKCk7cmV0dXJuIG4oKSxyfWNhdGNoKHIpe3Rocm93IG4oKSxyfX1uZXh0VGVuc29ySWQoKXtyZXR1cm4gQ3gubmV4dFRlbnNvcklkKyt9bmV4dFZhcmlhYmxlSWQoKXtyZXR1cm4gQ3gubmV4dFZhcmlhYmxlSWQrK31jbG9uZSh0KXtsZXQgbj1QLnJ1bktlcm5lbChlbyx7eDp0fSksYT17eDp0fSxyPWk9Pih7eDooKT0+e2xldCBvPVwiZmxvYXQzMlwiLGw9e3g6aX0sdT17ZHR5cGU6b307cmV0dXJuIFAucnVuS2VybmVsKE1pLGwsdSl9fSkscz1bXTtyZXR1cm4gdGhpcy5hZGRUYXBlTm9kZSh0aGlzLnN0YXRlLmFjdGl2ZVNjb3BlLm5hbWUsYSxbbl0scixzLHt9KSxufXJ1bktlcm5lbCh0LG4sYSl7aWYodGhpcy5iYWNrZW5kTmFtZT09bnVsbCYmdGhpcy5iYWNrZW5kLGZjKHQsdGhpcy5iYWNrZW5kTmFtZSk9PW51bGwpdGhyb3cgbmV3IEVycm9yKGBLZXJuZWwgJyR7dH0nIG5vdCByZWdpc3RlcmVkIGZvciBiYWNrZW5kICcke3RoaXMuYmFja2VuZE5hbWV9J2ApO3JldHVybiB0aGlzLnJ1bktlcm5lbEZ1bmMoe2tlcm5lbE5hbWU6dCxpbnB1dHM6bixhdHRyczphfSl9c2hvdWxkQ2hlY2tGb3JNZW1MZWFrcygpe3JldHVybiB0aGlzLkVOVi5nZXRCb29sKFwiSVNfVEVTVFwiKX1jaGVja0tlcm5lbEZvck1lbUxlYWsodCxuLGEpe2xldCByPXRoaXMuYmFja2VuZC5udW1EYXRhSWRzKCkscz0wO2EuZm9yRWFjaChsPT57cys9bC5kdHlwZT09PVwiY29tcGxleDY0XCI/MzoxfSk7bGV0IGk9dGhpcy5zdGF0ZS5udW1EYXRhTW92ZXNTdGFja1t0aGlzLnN0YXRlLm51bURhdGFNb3Zlc1N0YWNrLmxlbmd0aC0xXSxvPXItbi1zLWk7aWYobz4wKXRocm93IG5ldyBFcnJvcihgQmFja2VuZCAnJHt0aGlzLmJhY2tlbmROYW1lfScgaGFzIGFuIGludGVybmFsIG1lbW9yeSBsZWFrICgke299IGRhdGEgaWRzKSBhZnRlciBydW5uaW5nICcke3R9J2ApfXJ1bktlcm5lbEZ1bmModCl7bGV0IG4sYT1bXSxyPXRoaXMuaXNUYXBlT24oKSxzPXRoaXMuc3RhdGUubnVtQnl0ZXMsaT10aGlzLnN0YXRlLm51bVRlbnNvcnM7dGhpcy5zaG91bGRDaGVja0Zvck1lbUxlYWtzKCkmJnRoaXMuc3RhdGUubnVtRGF0YU1vdmVzU3RhY2sucHVzaCgwKTtsZXQgbzt0aGlzLmJhY2tlbmROYW1lPT1udWxsJiZ0aGlzLmJhY2tlbmQ7bGV0IGwsdT1peCh0KT90Lmtlcm5lbE5hbWU6dGhpcy5zdGF0ZS5hY3RpdmVTY29wZSE9bnVsbD90aGlzLnN0YXRlLmFjdGl2ZVNjb3BlLm5hbWU6XCJcIjtpZihpeCh0KSl7bGV0e2tlcm5lbE5hbWU6bSxpbnB1dHM6ZixhdHRyczpnfT10O3RoaXMuYmFja2VuZE5hbWU9PW51bGwmJnRoaXMuYmFja2VuZDtsZXQgYj1mYyhtLHRoaXMuYmFja2VuZE5hbWUpO0EoYiE9bnVsbCwoKT0+YENhbm5vdCBmaW5kIHJlZ2lzdGVyZWQga2VybmVsICcke219JyBmb3IgYmFja2VuZCAnJHt0aGlzLmJhY2tlbmROYW1lfSdgKSxvPSgpPT57bGV0IHk9dGhpcy5iYWNrZW5kLm51bURhdGFJZHMoKTtsPWIua2VybmVsRnVuYyh7aW5wdXRzOmYsYXR0cnM6ZyxiYWNrZW5kOnRoaXMuYmFja2VuZH0pO2xldCB4PUFycmF5LmlzQXJyYXkobCk/bDpbbF07dGhpcy5zaG91bGRDaGVja0Zvck1lbUxlYWtzKCkmJnRoaXMuY2hlY2tLZXJuZWxGb3JNZW1MZWFrKG0seSx4KTtsZXQgdj14Lm1hcChJPT5JLnJhbmshPW51bGw/STp0aGlzLm1ha2VUZW5zb3JGcm9tVGVuc29ySW5mbyhJKSk7aWYocil7bGV0IEk9dGhpcy5nZXRUZW5zb3JzRm9yR3JhZGllbnQobSxmLHYpO2E9dGhpcy5zYXZlVGVuc29yc0ZvckJhY2t3YXJkTW9kZShJKX1yZXR1cm4gdn19ZWxzZXtsZXR7Zm9yd2FyZEZ1bmM6bX09dCxmPWc9PntyJiYoYT1nLm1hcChiPT50aGlzLmtlZXAodGhpcy5jbG9uZShiKSkpKX07bz0oKT0+e2xldCBnPXRoaXMuYmFja2VuZC5udW1EYXRhSWRzKCk7bD10aGlzLnRpZHkoKCk9Pm0odGhpcy5iYWNrZW5kLGYpKTtsZXQgYj1BcnJheS5pc0FycmF5KGwpP2w6W2xdO3JldHVybiB0aGlzLnNob3VsZENoZWNrRm9yTWVtTGVha3MoKSYmdGhpcy5jaGVja0tlcm5lbEZvck1lbUxlYWsodSxnLGIpLGJ9fWxldHtpbnB1dHM6cCxhdHRyczpkfT10LGM9aXgodCk/bnVsbDp0LmJhY2t3YXJkc0Z1bmMsaDtyZXR1cm4gdGhpcy5zY29wZWRSdW4oKCk9PnRoaXMuc3RhdGUua2VybmVsRGVwdGgrKywoKT0+dGhpcy5zdGF0ZS5rZXJuZWxEZXB0aC0tLCgpPT57IXRoaXMuRU5WLmdldEJvb2woXCJERUJVR1wiKSYmIXRoaXMuc3RhdGUucHJvZmlsaW5nP249bygpOihoPXRoaXMucHJvZmlsZXIucHJvZmlsZUtlcm5lbCh1LHAsKCk9Pm8oKSksdGhpcy5FTlYuZ2V0Qm9vbChcIkRFQlVHXCIpJiZ0aGlzLnByb2ZpbGVyLmxvZ0tlcm5lbFByb2ZpbGUoaCksbj1oLm91dHB1dHMpfSksciYmdGhpcy5hZGRUYXBlTm9kZSh1LHAsbixjLGEsZCksdGhpcy5zdGF0ZS5wcm9maWxpbmcmJnRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZS5rZXJuZWxzLnB1c2goe25hbWU6dSxieXRlc0FkZGVkOnRoaXMuc3RhdGUubnVtQnl0ZXMtcyx0b3RhbEJ5dGVzU25hcHNob3Q6dGhpcy5zdGF0ZS5udW1CeXRlcyx0ZW5zb3JzQWRkZWQ6dGhpcy5zdGF0ZS5udW1UZW5zb3JzLWksdG90YWxUZW5zb3JzU25hcHNob3Q6dGhpcy5zdGF0ZS5udW1UZW5zb3JzLGlucHV0U2hhcGVzOk9iamVjdC5rZXlzKHApLm1hcChtPT5wW21dIT1udWxsP3BbbV0uc2hhcGU6bnVsbCksb3V0cHV0U2hhcGVzOm4ubWFwKG09Pm0uc2hhcGUpLGtlcm5lbFRpbWVNczpoLnRpbWVNcyxleHRyYUluZm86aC5leHRyYUluZm99KSxBcnJheS5pc0FycmF5KGwpP246blswXX1zYXZlVGVuc29yc0ZvckJhY2t3YXJkTW9kZSh0KXtyZXR1cm4gdC5tYXAobj0+dGhpcy5rZWVwKHRoaXMuY2xvbmUobikpKX1nZXRUZW5zb3JzRm9yR3JhZGllbnQodCxuLGEpe2xldCByPXZ4KHQpO2lmKHIhPW51bGwpe2xldCBzPXIuaW5wdXRzVG9TYXZlfHxbXSxpPXIub3V0cHV0c1RvU2F2ZXx8W10sbztyLnNhdmVBbGxJbnB1dHM/KEEoQXJyYXkuaXNBcnJheShuKSwoKT0+XCJzYXZlQWxsSW5wdXRzIGlzIHRydWUsIGV4cGVjdGVkIGlucHV0cyB0byBiZSBhbiBhcnJheS5cIiksbz1PYmplY3Qua2V5cyhuKS5tYXAodT0+blt1XSkpOm89cy5tYXAodT0+blt1XSk7bGV0IGw9YS5maWx0ZXIoKHUscCk9PmlbcF0pO3JldHVybiBvLmNvbmNhdChsKX1yZXR1cm5bXX1tYWtlVGVuc29yKHQsbixhLHIpe2lmKHQ9PW51bGwpdGhyb3cgbmV3IEVycm9yKFwiVmFsdWVzIHBhc3NlZCB0byBlbmdpbmUubWFrZVRlbnNvcigpIGFyZSBudWxsXCIpO2E9YXx8XCJmbG9hdDMyXCIscj1yfHx0aGlzLmJhY2tlbmQ7bGV0IHM9dDthPT09XCJzdHJpbmdcIiYmSnIodFswXSkmJihzPXQubWFwKGw9Pm5kKGwpKSk7bGV0IGk9ci53cml0ZShzLG4sYSksbz1uZXcgQ2UobixhLGksdGhpcy5uZXh0VGVuc29ySWQoKSk7aWYodGhpcy50cmFja1RlbnNvcihvLHIpLGE9PT1cInN0cmluZ1wiKXtsZXQgbD10aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KGkpLHU9elMocyk7dGhpcy5zdGF0ZS5udW1CeXRlcys9dS1sLmJ5dGVzLGwuYnl0ZXM9dX1yZXR1cm4gb31tYWtlVGVuc29yRnJvbURhdGFJZCh0LG4sYSxyKXthPWF8fFwiZmxvYXQzMlwiO2xldCBzPXtkYXRhSWQ6dCxzaGFwZTpuLGR0eXBlOmF9O3JldHVybiB0aGlzLm1ha2VUZW5zb3JGcm9tVGVuc29ySW5mbyhzLHIpfW1ha2VUZW5zb3JGcm9tVGVuc29ySW5mbyh0LG4pe2xldHtkYXRhSWQ6YSxzaGFwZTpyLGR0eXBlOnN9PXQsaT1uZXcgQ2UocixzLGEsdGhpcy5uZXh0VGVuc29ySWQoKSk7cmV0dXJuIHRoaXMudHJhY2tUZW5zb3IoaSxuKSxpfW1ha2VWYXJpYWJsZSh0LG49ITAsYSxyKXthPWF8fHRoaXMubmV4dFZhcmlhYmxlSWQoKS50b1N0cmluZygpLHIhPW51bGwmJnIhPT10LmR0eXBlJiYodD10LmNhc3QocikpO2xldCBzPW5ldyBvcyh0LG4sYSx0aGlzLm5leHRUZW5zb3JJZCgpKTtpZih0aGlzLnN0YXRlLnJlZ2lzdGVyZWRWYXJpYWJsZXNbcy5uYW1lXSE9bnVsbCl0aHJvdyBuZXcgRXJyb3IoYFZhcmlhYmxlIHdpdGggbmFtZSAke3MubmFtZX0gd2FzIGFscmVhZHkgcmVnaXN0ZXJlZGApO3JldHVybiB0aGlzLnN0YXRlLnJlZ2lzdGVyZWRWYXJpYWJsZXNbcy5uYW1lXT1zLHRoaXMuaW5jUmVmKHMsdGhpcy5iYWNrZW5kKSxzfXRyYWNrVGVuc29yKHQsbil7dGhpcy5zdGF0ZS5udW1UZW5zb3JzKyssdC5kdHlwZT09PVwic3RyaW5nXCImJnRoaXMuc3RhdGUubnVtU3RyaW5nVGVuc29ycysrO2xldCBhPTA7dC5kdHlwZSE9PVwiY29tcGxleDY0XCImJnQuZHR5cGUhPT1cInN0cmluZ1wiJiYoYT10LnNpemUqVWgodC5kdHlwZSkpLHRoaXMuc3RhdGUubnVtQnl0ZXMrPWEsdGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmhhcyh0LmRhdGFJZCl8fCh0aGlzLnN0YXRlLm51bURhdGFCdWZmZXJzKyssdGhpcy5zdGF0ZS50ZW5zb3JJbmZvLnNldCh0LmRhdGFJZCx7YmFja2VuZDpufHx0aGlzLmJhY2tlbmQsZHR5cGU6dC5kdHlwZSxzaGFwZTp0LnNoYXBlLGJ5dGVzOmF9KSksdCBpbnN0YW5jZW9mIG9zfHx0aGlzLnRyYWNrKHQpfWluY1JlZih0LG4pe3RoaXMudHJhY2tUZW5zb3IodCxuKSx0aGlzLmJhY2tlbmQuaW5jUmVmKHQuZGF0YUlkKX1yZW1vdmVEYXRhSWQodCxuKXt0aGlzLnN0YXRlLnRlbnNvckluZm8uaGFzKHQpJiZ0aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KHQpLmJhY2tlbmQ9PT1uJiYodGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmRlbGV0ZSh0KSx0aGlzLnN0YXRlLm51bURhdGFCdWZmZXJzLS0pfWRpc3Bvc2VUZW5zb3IodCl7aWYoIXRoaXMuc3RhdGUudGVuc29ySW5mby5oYXModC5kYXRhSWQpKXJldHVybjtsZXQgbj10aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KHQuZGF0YUlkKTtpZih0aGlzLnN0YXRlLm51bVRlbnNvcnMtLSx0LmR0eXBlPT09XCJzdHJpbmdcIiYmKHRoaXMuc3RhdGUubnVtU3RyaW5nVGVuc29ycy0tLHRoaXMuc3RhdGUubnVtQnl0ZXMtPW4uYnl0ZXMpLHQuZHR5cGUhPT1cImNvbXBsZXg2NFwiJiZ0LmR0eXBlIT09XCJzdHJpbmdcIil7bGV0IGE9dC5zaXplKlVoKHQuZHR5cGUpO3RoaXMuc3RhdGUubnVtQnl0ZXMtPWF9bi5iYWNrZW5kLmRpc3Bvc2VEYXRhKHQuZGF0YUlkKSYmdGhpcy5yZW1vdmVEYXRhSWQodC5kYXRhSWQsbi5iYWNrZW5kKX1kaXNwb3NlVmFyaWFibGVzKCl7Zm9yKGxldCB0IGluIHRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlcyl7bGV0IG49dGhpcy5zdGF0ZS5yZWdpc3RlcmVkVmFyaWFibGVzW3RdO3RoaXMuZGlzcG9zZVZhcmlhYmxlKG4pfX1kaXNwb3NlVmFyaWFibGUodCl7dGhpcy5kaXNwb3NlVGVuc29yKHQpLHRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlc1t0Lm5hbWVdIT1udWxsJiZkZWxldGUgdGhpcy5zdGF0ZS5yZWdpc3RlcmVkVmFyaWFibGVzW3QubmFtZV19bWVtb3J5KCl7bGV0IHQ9dGhpcy5iYWNrZW5kLm1lbW9yeSgpO3JldHVybiB0Lm51bVRlbnNvcnM9dGhpcy5zdGF0ZS5udW1UZW5zb3JzLHQubnVtRGF0YUJ1ZmZlcnM9dGhpcy5zdGF0ZS5udW1EYXRhQnVmZmVycyx0Lm51bUJ5dGVzPXRoaXMuc3RhdGUubnVtQnl0ZXMsdGhpcy5zdGF0ZS5udW1TdHJpbmdUZW5zb3JzPjAmJih0LnVucmVsaWFibGU9ITAsdC5yZWFzb25zPT1udWxsJiYodC5yZWFzb25zPVtdKSx0LnJlYXNvbnMucHVzaChcIk1lbW9yeSB1c2FnZSBieSBzdHJpbmcgdGVuc29ycyBpcyBhcHByb3hpbWF0ZSAoMiBieXRlcyBwZXIgY2hhcmFjdGVyKVwiKSksdH1hc3luYyBwcm9maWxlKHQpe3RoaXMuc3RhdGUucHJvZmlsaW5nPSEwO2xldCBuPXRoaXMuc3RhdGUubnVtQnl0ZXMsYT10aGlzLnN0YXRlLm51bVRlbnNvcnM7dGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLmtlcm5lbHM9W10sdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLnJlc3VsdD1hd2FpdCB0KCksdGhpcy5zdGF0ZS5wcm9maWxpbmc9ITEsdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLnBlYWtCeXRlcz1NYXRoLm1heCguLi50aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUua2VybmVscy5tYXAocj0+ci50b3RhbEJ5dGVzU25hcHNob3QpKSx0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUubmV3Qnl0ZXM9dGhpcy5zdGF0ZS5udW1CeXRlcy1uLHRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZS5uZXdUZW5zb3JzPXRoaXMuc3RhdGUubnVtVGVuc29ycy1hO2ZvcihsZXQgciBvZiB0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUua2VybmVscylyLmtlcm5lbFRpbWVNcz1hd2FpdCByLmtlcm5lbFRpbWVNcyxyLmV4dHJhSW5mbz1hd2FpdCByLmV4dHJhSW5mbztyZXR1cm4gdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlfWlzVGFwZU9uKCl7cmV0dXJuIHRoaXMuc3RhdGUuZ3JhZGllbnREZXB0aD4wJiZ0aGlzLnN0YXRlLmtlcm5lbERlcHRoPT09MH1hZGRUYXBlTm9kZSh0LG4sYSxyLHMsaSl7bGV0IG89e2lkOnRoaXMuc3RhdGUubmV4dFRhcGVOb2RlSWQrKyxrZXJuZWxOYW1lOnQsaW5wdXRzOm4sb3V0cHV0czphLHNhdmVkOnN9LGw9dngodCk7bCE9bnVsbCYmKHI9bC5ncmFkRnVuYyksciE9bnVsbCYmKG8uZ3JhZGllbnQ9dT0+KHU9dS5tYXAoKHAsZCk9PntpZihwPT1udWxsKXtsZXQgYz1hW2RdLGg9eG0oYy5zaXplLGMuZHR5cGUpO3JldHVybiB0aGlzLm1ha2VUZW5zb3IoaCxjLnNoYXBlLGMuZHR5cGUpfXJldHVybiBwfSkscih1Lmxlbmd0aD4xP3U6dVswXSxzLGkpKSksdGhpcy5zdGF0ZS5hY3RpdmVUYXBlLnB1c2gobyl9a2VlcCh0KXtyZXR1cm4gdC5rZXB0PSEwLHR9c3RhcnRUYXBlKCl7dGhpcy5zdGF0ZS5ncmFkaWVudERlcHRoPT09MCYmKHRoaXMuc3RhdGUuYWN0aXZlVGFwZT1bXSksdGhpcy5zdGF0ZS5ncmFkaWVudERlcHRoKyt9ZW5kVGFwZSgpe3RoaXMuc3RhdGUuZ3JhZGllbnREZXB0aC0tfXN0YXJ0U2NvcGUodCl7bGV0IG49e3RyYWNrOltdLG5hbWU6XCJ1bm5hbWVkIHNjb3BlXCIsaWQ6dGhpcy5zdGF0ZS5uZXh0U2NvcGVJZCsrfTt0JiYobi5uYW1lPXQpLHRoaXMuc3RhdGUuc2NvcGVTdGFjay5wdXNoKG4pLHRoaXMuc3RhdGUuYWN0aXZlU2NvcGU9bn1lbmRTY29wZSh0KXtsZXQgbj1fdih0KSxhPW5ldyBTZXQobi5tYXAocz0+cy5pZCkpO2ZvcihsZXQgcz0wO3M8dGhpcy5zdGF0ZS5hY3RpdmVTY29wZS50cmFjay5sZW5ndGg7cysrKXtsZXQgaT10aGlzLnN0YXRlLmFjdGl2ZVNjb3BlLnRyYWNrW3NdOyFpLmtlcHQmJiFhLmhhcyhpLmlkKSYmaS5kaXNwb3NlKCl9bGV0IHI9dGhpcy5zdGF0ZS5zY29wZVN0YWNrLnBvcCgpO3RoaXMuc3RhdGUuYWN0aXZlU2NvcGU9dGhpcy5zdGF0ZS5zY29wZVN0YWNrLmxlbmd0aD09PTA/bnVsbDp0aGlzLnN0YXRlLnNjb3BlU3RhY2tbdGhpcy5zdGF0ZS5zY29wZVN0YWNrLmxlbmd0aC0xXSxuLmZvckVhY2gocz0+eyFzLmtlcHQmJnMuc2NvcGVJZD09PXIuaWQmJnRoaXMudHJhY2socyl9KX1ncmFkaWVudHModCxuLGEscj0hMSl7aWYoQShuLmxlbmd0aD4wLCgpPT5cImdyYWRpZW50cygpIHJlY2VpdmVkIGFuIGVtcHR5IGxpc3Qgb2YgeHMuXCIpLGEhPW51bGwmJmEuZHR5cGUhPT1cImZsb2F0MzJcIil0aHJvdyBuZXcgRXJyb3IoYGR5IG11c3QgaGF2ZSAnZmxvYXQzMicgZHR5cGUsIGJ1dCBoYXMgJyR7YS5kdHlwZX0nYCk7bGV0IHM9dGhpcy5zY29wZWRSdW4oKCk9PnRoaXMuc3RhcnRUYXBlKCksKCk9PnRoaXMuZW5kVGFwZSgpLCgpPT50aGlzLnRpZHkoXCJmb3J3YXJkXCIsdCkpO0EocyBpbnN0YW5jZW9mIENlLCgpPT5cIlRoZSByZXN1bHQgeSByZXR1cm5lZCBieSBmKCkgbXVzdCBiZSBhIHRlbnNvci5cIik7bGV0IGk9Rk0odGhpcy5zdGF0ZS5hY3RpdmVUYXBlLG4scyk7aWYoIXImJmkubGVuZ3RoPT09MCYmbi5sZW5ndGg+MCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSBncmFkaWVudCBvZiB5PWYoeCkgd2l0aCByZXNwZWN0IHRvIHguIE1ha2Ugc3VyZSB0aGF0IHRoZSBmIHlvdSBwYXNzZWQgZW5jbG9zZXMgYWxsIG9wZXJhdGlvbnMgdGhhdCBsZWFkIGZyb20geCB0byB5LlwiKTtyZXR1cm4gdGhpcy50aWR5KFwiYmFja3dhcmRcIiwoKT0+e2xldCBvPXt9O29bcy5pZF09YT09bnVsbD9WTShzLnNoYXBlKTphLCRNKG8saSx1PT50aGlzLnRpZHkodSksVU0pO2xldCBsPW4ubWFwKHU9Pm9bdS5pZF0pO3JldHVybiB0aGlzLnN0YXRlLmdyYWRpZW50RGVwdGg9PT0wJiYodGhpcy5zdGF0ZS5hY3RpdmVUYXBlLmZvckVhY2godT0+e2ZvcihsZXQgcCBvZiB1LnNhdmVkKXAuZGlzcG9zZSgpfSksdGhpcy5zdGF0ZS5hY3RpdmVUYXBlPW51bGwpLHt2YWx1ZTpzLGdyYWRzOmx9fSl9Y3VzdG9tR3JhZCh0KXtyZXR1cm4gQShzcyh0KSwoKT0+XCJUaGUgZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpLCguLi5uKT0+e0Eobi5ldmVyeShvPT5vIGluc3RhbmNlb2YgQ2UpLCgpPT5cIlRoZSBhcmdzIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpKHgxLCB4MiwuLi4pIG11c3QgYWxsIGJlIHRlbnNvcnNcIik7bGV0IGEscj17fTtuLmZvckVhY2goKG8sbCk9PntyW2xdPW99KTtsZXQgcz0obyxsKT0+KGE9dCguLi5uLGwpLEEoYS52YWx1ZSBpbnN0YW5jZW9mIENlLCgpPT5cIlRoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aGVyZSBgb2JqLnZhbHVlYCBpcyBhIHRlbnNvclwiKSxBKHNzKGEuZ3JhZEZ1bmMpLCgpPT5cIlRoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aGVyZSBgb2JqLmdyYWRGdW5jYCBpcyBhIGZ1bmN0aW9uLlwiKSxhLnZhbHVlKSxpPShvLGwpPT57bGV0IHU9YS5ncmFkRnVuYyhvLGwpLHA9QXJyYXkuaXNBcnJheSh1KT91Olt1XTtBKHAubGVuZ3RoPT09bi5sZW5ndGgsKCk9PlwiVGhlIGZ1bmN0aW9uIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdoZXJlIGBvYmouZ3JhZEZ1bmNgIGlzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBzYW1lIG51bWJlciBvZiB0ZW5zb3JzIGFzIGlucHV0cyBwYXNzZWQgdG8gZiguLi4pLlwiKSxBKHAuZXZlcnkoYz0+YyBpbnN0YW5jZW9mIENlKSwoKT0+XCJUaGUgZnVuY3Rpb24gZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IHJldHVybiBhbiBvYmplY3Qgd2hlcmUgYG9iai5ncmFkRnVuY2AgaXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBsaXN0IG9mIG9ubHkgdGVuc29ycy5cIik7bGV0IGQ9e307cmV0dXJuIHAuZm9yRWFjaCgoYyxoKT0+e2RbaF09KCk9PmN9KSxkfTtyZXR1cm4gdGhpcy5ydW5LZXJuZWxGdW5jKHtmb3J3YXJkRnVuYzpzLGJhY2t3YXJkc0Z1bmM6aSxpbnB1dHM6cn0pfX1yZWFkU3luYyh0KXtyZXR1cm4gdGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldCh0KS5iYWNrZW5kLnJlYWRTeW5jKHQpfXJlYWQodCl7cmV0dXJuIHRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQodCkuYmFja2VuZC5yZWFkKHQpfXJlYWRUb0dQVSh0LG4pe3JldHVybiB0aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KHQpLmJhY2tlbmQucmVhZFRvR1BVKHQsbil9YXN5bmMgdGltZSh0KXtsZXQgbj1nYygpLGE9YXdhaXQgdGhpcy5iYWNrZW5kLnRpbWUodCk7cmV0dXJuIGEud2FsbE1zPWdjKCktbixhfXRyYWNrKHQpe3JldHVybiB0aGlzLnN0YXRlLmFjdGl2ZVNjb3BlIT1udWxsJiYodC5zY29wZUlkPXRoaXMuc3RhdGUuYWN0aXZlU2NvcGUuaWQsdGhpcy5zdGF0ZS5hY3RpdmVTY29wZS50cmFjay5wdXNoKHQpKSx0fWdldCByZWdpc3RlcmVkVmFyaWFibGVzKCl7cmV0dXJuIHRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlc31yZXNldCgpe3RoaXMucGVuZGluZ0JhY2tlbmRJbml0SWQrKyx0aGlzLnN0YXRlLmRpc3Bvc2UoKSx0aGlzLkVOVi5yZXNldCgpLHRoaXMuc3RhdGU9bmV3IFlrO2ZvcihsZXQgdCBpbiB0aGlzLnJlZ2lzdHJ5KXRoaXMuZGlzcG9zZVJlZ2lzdGVyZWRLZXJuZWxzKHQpLHRoaXMucmVnaXN0cnlbdF0uZGlzcG9zZSgpLGRlbGV0ZSB0aGlzLnJlZ2lzdHJ5W3RdO3RoaXMuYmFja2VuZE5hbWU9bnVsbCx0aGlzLmJhY2tlbmRJbnN0YW5jZT1udWxsLHRoaXMucGVuZGluZ0JhY2tlbmRJbml0PW51bGx9fTtBdi5uZXh0VGVuc29ySWQ9MDtBdi5uZXh0VmFyaWFibGVJZD0wO2Z1bmN0aW9uIFZNKGUpe2xldCB0PU52KG90KGUpLFwiZmxvYXQzMlwiKTtyZXR1cm4gUC5tYWtlVGVuc29yKHQsZSxcImZsb2F0MzJcIil9ZnVuY3Rpb24gYU4oKXtsZXQgZT1HUygpO2lmKGUuX3RmZW5naW5lPT1udWxsKXtsZXQgdD1uZXcgVVMoZSk7ZS5fdGZlbmdpbmU9bmV3IEF2KHQpfXJldHVybiBwTShlLl90ZmVuZ2luZS5FTlYpLE9NKCgpPT5lLl90ZmVuZ2luZSksZS5fdGZlbmdpbmV9dmFyIFA9YU4oKTtmdW5jdGlvbiBVTShlLHQpe2xldCBuPXthOmUsYjp0fTtyZXR1cm4gUC5ydW5LZXJuZWwodnMsbil9dmFyIGFkPXt9O19lKGFkLHtpc0Jyb3dzZXI6KCk9PnJOLGlzTW9iaWxlOigpPT5qTSxtb2NrSXNNb2JpbGU6KCk9PkhNfSk7ZnVuY3Rpb24gR00oKXtyZXR1cm4gdHlwZW9mIG5hdmlnYXRvciE9XCJ1bmRlZmluZWRcIiYmbmF2aWdhdG9yIT1udWxsfXZhciBFeDtmdW5jdGlvbiBITShlKXtFeD1lfWZ1bmN0aW9uIGpNKGUpe2lmKEV4IT09dm9pZCAwKXJldHVybiBFeDtpZihlfHxHTSgpKXtpZihlfHwoZT1uYXZpZ2F0b3IpLGUucHJvZHVjdD09PVwiUmVhY3ROYXRpdmVcIilyZXR1cm4hMDtsZXQgdD1lLnVzZXJBZ2VudHx8ZS52ZW5kb3J8fCh0eXBlb2Ygd2luZG93IT1cInVuZGVmaW5lZFwiP3dpbmRvdy5vcGVyYTpcIlwiKTtpZighdCl7bGV0IG49ZTtyZXR1cm4gbi51c2VyQWdlbnREYXRhJiZuLnVzZXJBZ2VudERhdGEubW9iaWxlfXJldHVybi8oYW5kcm9pZHxiYlxcZCt8bWVlZ28pLittb2JpbGV8YXZhbnRnb3xiYWRhXFwvfGJsYWNrYmVycnl8YmxhemVyfGNvbXBhbHxlbGFpbmV8ZmVubmVjfGhpcHRvcHxpZW1vYmlsZXxpcChob25lfG9kKXxpcmlzfGtpbmRsZXxsZ2UgfG1hZW1vfG1pZHB8bW1wfG1vYmlsZS4rZmlyZWZveHxuZXRmcm9udHxvcGVyYSBtKG9ifGluKWl8cGFsbSggb3MpP3xwaG9uZXxwKGl4aXxyZSlcXC98cGx1Y2tlcnxwb2NrZXR8cHNwfHNlcmllcyg0fDYpMHxzeW1iaWFufHRyZW98dXBcXC4oYnJvd3NlcnxsaW5rKXx2b2RhZm9uZXx3YXB8d2luZG93cyBjZXx4ZGF8eGlpbm8vaS50ZXN0KHQpfHwvMTIwN3w2MzEwfDY1OTB8M2dzb3w0dGhwfDUwWzEtNl1pfDc3MHN8ODAyc3xhIHdhfGFiYWN8YWMoZXJ8b298c1xcLSl8YWkoa298cm4pfGFsKGF2fGNhfGNvKXxhbW9pfGFuKGV4fG55fHl3KXxhcHR1fGFyKGNofGdvKXxhcyh0ZXx1cyl8YXR0d3xhdShkaXxcXC1tfHIgfHMgKXxhdmFufGJlKGNrfGxsfG5xKXxiaShsYnxyZCl8YmwoYWN8YXopfGJyKGV8dil3fGJ1bWJ8YndcXC0obnx1KXxjNTVcXC98Y2FwaXxjY3dhfGNkbVxcLXxjZWxsfGNodG18Y2xkY3xjbWRcXC18Y28obXB8bmQpfGNyYXd8ZGEoaXR8bGx8bmcpfGRidGV8ZGNcXC1zfGRldml8ZGljYXxkbW9ifGRvKGN8cClvfGRzKDEyfFxcLWQpfGVsKDQ5fGFpKXxlbShsMnx1bCl8ZXIoaWN8azApfGVzbDh8ZXooWzQtN10wfG9zfHdhfHplKXxmZXRjfGZseShcXC18Xyl8ZzEgdXxnNTYwfGdlbmV8Z2ZcXC01fGdcXC1tb3xnbyhcXC53fG9kKXxncihhZHx1bil8aGFpZXxoY2l0fGhkXFwtKG18cHx0KXxoZWlcXC18aGkocHR8dGEpfGhwKCBpfGlwKXxoc1xcLWN8aHQoYyhcXC18IHxffGF8Z3xwfHN8dCl8dHApfGh1KGF3fHRjKXxpXFwtKDIwfGdvfG1hKXxpMjMwfGlhYyggfFxcLXxcXC8pfGlicm98aWRlYXxpZzAxfGlrb218aW0xa3xpbm5vfGlwYXF8aXJpc3xqYSh0fHYpYXxqYnJvfGplbXV8amlnc3xrZGRpfGtlaml8a2d0KCB8XFwvKXxrbG9ufGtwdCB8a3djXFwtfGt5byhjfGspfGxlKG5vfHhpKXxsZyggZ3xcXC8oa3xsfHUpfDUwfDU0fFxcLVthLXddKXxsaWJ3fGx5bnh8bTFcXC13fG0zZ2F8bTUwXFwvfG1hKHRlfHVpfHhvKXxtYygwMXwyMXxjYSl8bVxcLWNyfG1lKHJjfHJpKXxtaShvOHxvYXx0cyl8bW1lZnxtbygwMXwwMnxiaXxkZXxkb3x0KFxcLXwgfG98dil8enopfG10KDUwfHAxfHYgKXxtd2JwfG15d2F8bjEwWzAtMl18bjIwWzItM118bjMwKDB8Mil8bjUwKDB8Mnw1KXxuNygwKDB8MSl8MTApfG5lKChjfG0pXFwtfG9ufHRmfHdmfHdnfHd0KXxub2soNnxpKXxuenBofG8yaW18b3AodGl8d3YpfG9yYW58b3dnMXxwODAwfHBhbihhfGR8dCl8cGR4Z3xwZygxM3xcXC0oWzEtOF18YykpfHBoaWx8cGlyZXxwbChheXx1Yyl8cG5cXC0yfHBvKGNrfHJ0fHNlKXxwcm94fHBzaW98cHRcXC1nfHFhXFwtYXxxYygwN3wxMnwyMXwzMnw2MHxcXC1bMi03XXxpXFwtKXxxdGVrfHIzODB8cjYwMHxyYWtzfHJpbTl8cm8odmV8em8pfHM1NVxcL3xzYShnZXxtYXxtbXxtc3xueXx2YSl8c2MoMDF8aFxcLXxvb3xwXFwtKXxzZGtcXC98c2UoYyhcXC18MHwxKXw0N3xtY3xuZHxyaSl8c2doXFwtfHNoYXJ8c2llKFxcLXxtKXxza1xcLTB8c2woNDV8aWQpfHNtKGFsfGFyfGIzfGl0fHQ1KXxzbyhmdHxueSl8c3AoMDF8aFxcLXx2XFwtfHYgKXxzeSgwMXxtYil8dDIoMTh8NTApfHQ2KDAwfDEwfDE4KXx0YShndHxsayl8dGNsXFwtfHRkZ1xcLXx0ZWwoaXxtKXx0aW1cXC18dFxcLW1vfHRvKHBsfHNoKXx0cyg3MHxtXFwtfG0zfG01KXx0eFxcLTl8dXAoXFwuYnxnMXxzaSl8dXRzdHx2NDAwfHY3NTB8dmVyaXx2aShyZ3x0ZSl8dmsoNDB8NVswLTNdfFxcLXYpfHZtNDB8dm9kYXx2dWxjfHZ4KDUyfDUzfDYwfDYxfDcwfDgwfDgxfDgzfDg1fDk4KXx3M2MoXFwtfCApfHdlYmN8d2hpdHx3aShnIHxuY3xudyl8d21sYnx3b251fHg3MDB8eWFzXFwtfHlvdXJ8emV0b3x6dGVcXC0vaS50ZXN0KHQuc3Vic3RyKDAsNCkpfXJldHVybiExfWZ1bmN0aW9uIHJOKCl7cmV0dXJuIHR5cGVvZiB3aW5kb3chPVwidW5kZWZpbmVkXCImJndpbmRvdy5kb2N1bWVudCE9bnVsbHx8dHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlIT1cInVuZGVmaW5lZFwifXZhciBXbj1HKCk7V24ucmVnaXN0ZXJGbGFnKFwiREVCVUdcIiwoKT0+ITEsZT0+e2UmJmNvbnNvbGUud2FybihcIkRlYnVnZ2luZyBtb2RlIGlzIE9OLiBUaGUgb3V0cHV0IG9mIGV2ZXJ5IG1hdGggY2FsbCB3aWxsIGJlIGRvd25sb2FkZWQgdG8gQ1BVIGFuZCBjaGVja2VkIGZvciBOYU5zLiBUaGlzIHNpZ25pZmljYW50bHkgaW1wYWN0cyBwZXJmb3JtYW5jZS5cIil9KTtXbi5yZWdpc3RlckZsYWcoXCJJU19CUk9XU0VSXCIsKCk9PnJOKCkpO1duLnJlZ2lzdGVyRmxhZyhcIklTX05PREVcIiwoKT0+dHlwZW9mIHByb2Nlc3MhPVwidW5kZWZpbmVkXCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zIT1cInVuZGVmaW5lZFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlIT1cInVuZGVmaW5lZFwiKTtXbi5yZWdpc3RlckZsYWcoXCJJU19DSFJPTUVcIiwoKT0+dHlwZW9mIG5hdmlnYXRvciE9XCJ1bmRlZmluZWRcIiYmbmF2aWdhdG9yIT1udWxsJiZuYXZpZ2F0b3IudXNlckFnZW50IT1udWxsJiYvQ2hyb21lLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpJiYvR29vZ2xlIEluYy8udGVzdChuYXZpZ2F0b3IudmVuZG9yKSk7V24ucmVnaXN0ZXJGbGFnKFwiSVNfU0FGQVJJXCIsKCk9PnR5cGVvZiBuYXZpZ2F0b3IhPVwidW5kZWZpbmVkXCImJm5hdmlnYXRvciE9bnVsbCYmbmF2aWdhdG9yLnVzZXJBZ2VudCE9bnVsbCYmL1NhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSYmL0FwcGxlLy50ZXN0KG5hdmlnYXRvci52ZW5kb3IpKTtXbi5yZWdpc3RlckZsYWcoXCJQUk9EXCIsKCk9PiExKTtXbi5yZWdpc3RlckZsYWcoXCJURU5TT1JMSUtFX0NIRUNLX1NIQVBFX0NPTlNJU1RFTkNZXCIsKCk9PlduLmdldEJvb2woXCJERUJVR1wiKSk7V24ucmVnaXN0ZXJGbGFnKFwiREVQUkVDQVRJT05fV0FSTklOR1NfRU5BQkxFRFwiLCgpPT4hMCk7V24ucmVnaXN0ZXJGbGFnKFwiSVNfVEVTVFwiLCgpPT4hMSk7V24ucmVnaXN0ZXJGbGFnKFwiQ0hFQ0tfQ09NUFVUQVRJT05fRk9SX0VSUk9SU1wiLCgpPT5Xbi5nZXRCb29sKFwiREVCVUdcIikpO1duLnJlZ2lzdGVyRmxhZyhcIldSQVBfVE9fSU1BR0VCSVRNQVBcIiwoKT0+ITEpO1duLnJlZ2lzdGVyRmxhZyhcIkNBTlZBUzJEX1dJTExfUkVBRF9GUkVRVUVOVExZX0ZPUl9HUFVcIiwoKT0+ITEpO1duLnJlZ2lzdGVyRmxhZyhcIlVTRV9TRVRUSU1FT1VUQ1VTVE9NXCIsKCk9PiExKTtmdW5jdGlvbiBscihlLHQpe2xldCBuPWU7aWYoZW4oZSkpcmV0dXJuIHQ9PT1cInN0cmluZ1wiP1tdOltlLmxlbmd0aF07aWYoUVMoZSkpe2xldCByPWUuY2hhbm5lbHN8fFwiUkdCQVwiO3JldHVybltlLmhlaWdodCxlLndpZHRoKnIubGVuZ3RoXX1lbHNlIGlmKGVOKGUpKXJldHVybltlLmJ1ZmZlci5zaXplLyh0PT1udWxsPzQ6VWgodCkpXTtpZighQXJyYXkuaXNBcnJheShlKSlyZXR1cm5bXTtsZXQgYT1bXTtmb3IoO0FycmF5LmlzQXJyYXkobil8fGVuKG4pJiZ0IT09XCJzdHJpbmdcIjspYS5wdXNoKG4ubGVuZ3RoKSxuPW5bMF07cmV0dXJuIEFycmF5LmlzQXJyYXkoZSkmJkcoKS5nZXRCb29sKFwiVEVOU09STElLRV9DSEVDS19TSEFQRV9DT05TSVNURU5DWVwiKSYmc04oZSxhLFtdKSxhfWZ1bmN0aW9uIHNOKGUsdCxuKXtpZihuPW58fFtdLCFBcnJheS5pc0FycmF5KGUpJiYhZW4oZSkpe0EodC5sZW5ndGg9PT0wLCgpPT5gRWxlbWVudCBhcnJbJHtuLmpvaW4oXCJdW1wiKX1dIGlzIGEgcHJpbWl0aXZlLCBidXQgc2hvdWxkIGJlIGFuIGFycmF5L1R5cGVkQXJyYXkgb2YgJHt0WzBdfSBlbGVtZW50c2ApO3JldHVybn1BKHQubGVuZ3RoPjAsKCk9PmBFbGVtZW50IGFyclske24uam9pbihcIl1bXCIpfV0gc2hvdWxkIGJlIGEgcHJpbWl0aXZlLCBidXQgaXMgYW4gYXJyYXkgb2YgJHtlLmxlbmd0aH0gZWxlbWVudHNgKSxBKGUubGVuZ3RoPT09dFswXSwoKT0+YEVsZW1lbnQgYXJyWyR7bi5qb2luKFwiXVtcIil9XSBzaG91bGQgaGF2ZSAke3RbMF19IGVsZW1lbnRzLCBidXQgaGFzICR7ZS5sZW5ndGh9IGVsZW1lbnRzYCk7bGV0IGE9dC5zbGljZSgxKTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoOysrcilzTihlW3JdLGEsbi5jb25jYXQocikpfWZ1bmN0aW9uIFprKGUsdCxuLGEpe2lmKGUhPT1cInN0cmluZ19vcl9udW1lcmljXCIpe2lmKGU9PW51bGwpdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgZHR5cGUgY2Fubm90IGJlIG51bGwuXCIpO2lmKGUhPT1cIm51bWVyaWNcIiYmZSE9PXR8fGU9PT1cIm51bWVyaWNcIiYmdD09PVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKGBBcmd1bWVudCAnJHtufScgcGFzc2VkIHRvICcke2F9JyBtdXN0IGJlICR7ZX0gdGVuc29yLCBidXQgZ290ICR7dH0gdGVuc29yYCl9fWZ1bmN0aW9uIEUoZSx0LG4sYT1cIm51bWVyaWNcIil7aWYoZSBpbnN0YW5jZW9mIFEoKSlyZXR1cm4gWmsoYSxlLmR0eXBlLHQsbiksZTtsZXQgcj0kYyhlKTtpZihyIT09XCJzdHJpbmdcIiYmW1wiYm9vbFwiLFwiaW50MzJcIixcImZsb2F0MzJcIl0uaW5kZXhPZihhKT49MCYmKHI9YSksWmsoYSxyLHQsbiksZT09bnVsbHx8IWVuKGUpJiYhQXJyYXkuaXNBcnJheShlKSYmdHlwZW9mIGUhPVwibnVtYmVyXCImJnR5cGVvZiBlIT1cImJvb2xlYW5cIiYmdHlwZW9mIGUhPVwic3RyaW5nXCIpe2xldCBvPWU9PW51bGw/XCJudWxsXCI6ZS5jb25zdHJ1Y3Rvci5uYW1lO3Rocm93IG5ldyBFcnJvcihgQXJndW1lbnQgJyR7dH0nIHBhc3NlZCB0byAnJHtufScgbXVzdCBiZSBhIFRlbnNvciBvciBUZW5zb3JMaWtlLCBidXQgZ290ICcke299J2ApfWxldCBzPWxyKGUscik7IWVuKGUpJiYhQXJyYXkuaXNBcnJheShlKSYmKGU9W2VdKTtsZXQgaT1yIT09XCJzdHJpbmdcIj9SbShlLHIpOmlzKGUsW10sITApO3JldHVybiBQLm1ha2VUZW5zb3IoaSxzLHIpfWZ1bmN0aW9uIGJjKGUsdCxuLGE9XCJudW1lcmljXCIpe2lmKCFBcnJheS5pc0FycmF5KGUpKXRocm93IG5ldyBFcnJvcihgQXJndW1lbnQgJHt0fSBwYXNzZWQgdG8gJHtufSBtdXN0IGJlIGEgXFxgVGVuc29yW11cXGAgb3IgXFxgVGVuc29yTGlrZVtdXFxgYCk7cmV0dXJuIGUubWFwKChyLHMpPT5FKHIsYCR7dH1bJHtzfV1gLG4sYSkpfXZhciBGdj1cIl9fb3BcIjtmdW5jdGlvbiBMKGUpe2xldCB0PU9iamVjdC5rZXlzKGUpO2lmKHQubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoYFBsZWFzZSBwcm92aWRlIGFuIG9iamVjdCB3aXRoIGEgc2luZ2xlIGtleSAob3BlcmF0aW9uIG5hbWUpIG1hcHBpbmcgdG8gYSBmdW5jdGlvbi4gR290IGFuIG9iamVjdCB3aXRoICR7dC5sZW5ndGh9IGtleXMuYCk7bGV0IG49dFswXSxhPWVbbl07bi5lbmRzV2l0aChcIl9cIikmJihuPW4uc3Vic3RyaW5nKDAsbi5sZW5ndGgtMSkpLG49bitGdjtsZXQgcj0oLi4ucyk9PntQLnN0YXJ0U2NvcGUobik7dHJ5e2xldCBpPWEoLi4ucyk7cmV0dXJuIHZtKGkpJiZjb25zb2xlLmVycm9yKFwiQ2Fubm90IHJldHVybiBhIFByb21pc2UgaW5zaWRlIG9mIHRpZHkuXCIpLFAuZW5kU2NvcGUoaSksaX1jYXRjaChpKXt0aHJvdyBQLmVuZFNjb3BlKG51bGwpLGl9fTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJuYW1lXCIse3ZhbHVlOm4sY29uZmlndXJhYmxlOiEwfSkscn1mdW5jdGlvbiBxTShlLHQpe2xldCBuPUUoZSxcInJlYWxcIixcImNvbXBsZXhcIiksYT1FKHQsXCJpbWFnXCIsXCJjb21wbGV4XCIpO05uKG4uc2hhcGUsYS5zaGFwZSxgcmVhbCBhbmQgaW1hZyBzaGFwZXMsICR7bi5zaGFwZX0gYW5kICR7YS5zaGFwZX0sIG11c3QgbWF0Y2ggaW4gY2FsbCB0byB0Zi5jb21wbGV4KCkuYCk7bGV0IHI9e3JlYWw6bixpbWFnOmF9O3JldHVybiBQLnJ1bktlcm5lbCh3bSxyKX12YXIgX3I9TCh7Y29tcGxleF86cU19KTtmdW5jdGlvbiBTcyhlLHQsbixhKXtpZihhPT1udWxsKWE9JGMoZSk7ZWxzZSBpZihhPT09XCJjb21wbGV4NjRcIil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29uc3RydWN0IGEgY29tcGxleDY0IHRlbnNvciBkaXJlY3RseS4gUGxlYXNlIHVzZSB0Zi5jb21wbGV4KHJlYWwsIGltYWcpLlwiKTtpZihlTihlKXx8UVMoZSkpe2lmKGEhPT1cImZsb2F0MzJcIiYmYSE9PVwiaW50MzJcIil0aHJvdyBuZXcgRXJyb3IoYENyZWF0aW5nIHRlbnNvciBmcm9tIEdQVSBkYXRhIG9ubHkgc3VwcG9ydHMgJ2Zsb2F0MzInfCdpbnQzMicgZHR5cGUsIHdoaWxlIHRoZSBkdHlwZSBpcyAke2F9LmApO3JldHVybiBQLmJhY2tlbmQuY3JlYXRlVGVuc29yRnJvbUdQVURhdGEoZSx0fHxuLGEpfWlmKCFlbihlKSYmIUFycmF5LmlzQXJyYXkoZSkmJnR5cGVvZiBlIT1cIm51bWJlclwiJiZ0eXBlb2YgZSE9XCJib29sZWFuXCImJnR5cGVvZiBlIT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihcInZhbHVlcyBwYXNzZWQgdG8gdGVuc29yKHZhbHVlcykgbXVzdCBiZSBhIG51bWJlci9ib29sZWFuL3N0cmluZyBvciBhbiBhcnJheSBvZiBudW1iZXJzL2Jvb2xlYW5zL3N0cmluZ3MsIG9yIGEgVHlwZWRBcnJheVwiKTtpZih0IT1udWxsKXtuYSh0KTtsZXQgcj1vdCh0KSxzPW90KG4pO0Eocj09PXMsKCk9PmBCYXNlZCBvbiB0aGUgcHJvdmlkZWQgc2hhcGUsIFske3R9XSwgdGhlIHRlbnNvciBzaG91bGQgaGF2ZSAke3J9IHZhbHVlcyBidXQgaGFzICR7c31gKTtmb3IobGV0IGk9MDtpPG4ubGVuZ3RoOysraSl7bGV0IG89bltpXSxsPWk9PT1uLmxlbmd0aC0xP28hPT1vdCh0LnNsaWNlKGkpKTohMDtBKG5baV09PT10W2ldfHwhbCwoKT0+YEVycm9yIGNyZWF0aW5nIGEgbmV3IFRlbnNvci4gSW5mZXJyZWQgc2hhcGUgKCR7bn0pIGRvZXMgbm90IG1hdGNoIHRoZSBwcm92aWRlZCBzaGFwZSAoJHt0fSkuIGApfX1yZXR1cm4hZW4oZSkmJiFBcnJheS5pc0FycmF5KGUpJiYoZT1bZV0pLHQ9dHx8bixlPWEhPT1cInN0cmluZ1wiP1JtKGUsYSk6aXMoZSxbXSwhMCksUC5tYWtlVGVuc29yKGUsdCxhKX1mdW5jdGlvbiBibihlLHQsbil7bGV0IGE9bHIoZSxuKTtyZXR1cm4gU3MoZSx0LGEsbil9dmFyIHVpPXtmbG9hdDMyOjQsZmxvYXQxNjoyLGludDMyOjQsdWludDE2OjIsdWludDg6MSxib29sOjEsY29tcGxleDY0Ojh9LEZyPWNsYXNzIGlOe3N0YXRpYyBqb2luKHQpe3JldHVybiBuZXcgaU4odCkuc2xpY2UoKX1jb25zdHJ1Y3Rvcih0KXtpZih0aGlzLnNoYXJkcz1bXSx0aGlzLnByZXZpb3VzU2hhcmRJbmRleD0wLHQ9PW51bGx8fCh0IGluc3RhbmNlb2YgQXJyYXl8fCh0PVt0XSksdD10Lm1hcChhPT5lbihhKT9hLmJ1ZmZlcjphKSx0Lmxlbmd0aD09PTApKXJldHVybjt0aGlzLmJ1ZmZlclVuaWZvcm1TaXplPXRbMF0uYnl0ZUxlbmd0aDtsZXQgbj0wO2ZvcihsZXQgYT0wO2E8dC5sZW5ndGg7YSsrKXtsZXQgcj10W2FdO2EhPT10Lmxlbmd0aC0xJiZyLmJ5dGVMZW5ndGghPT10aGlzLmJ1ZmZlclVuaWZvcm1TaXplJiYodGhpcy5idWZmZXJVbmlmb3JtU2l6ZT12b2lkIDApO2xldCBzPW4rci5ieXRlTGVuZ3RoO3RoaXMuc2hhcmRzLnB1c2goe2J1ZmZlcjpyLHN0YXJ0Om4sZW5kOnN9KSxuPXN9dGhpcy5zaGFyZHMubGVuZ3RoPT09MCYmKHRoaXMuYnl0ZUxlbmd0aD0wKSx0aGlzLmJ5dGVMZW5ndGg9dGhpcy5zaGFyZHNbdGhpcy5zaGFyZHMubGVuZ3RoLTFdLmVuZH1zbGljZSh0PTAsbj10aGlzLmJ5dGVMZW5ndGgpe2lmKHRoaXMuc2hhcmRzLmxlbmd0aD09PTApcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtpZih0PWlzTmFOKE51bWJlcih0KSk/MDp0LG49aXNOYU4oTnVtYmVyKG4pKT8wOm4sdD1NYXRoLm1heCgwLHQpLG49TWF0aC5taW4odGhpcy5ieXRlTGVuZ3RoLG4pLG48PXQpcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtsZXQgYT10aGlzLmZpbmRTaGFyZEZvckJ5dGUodCk7aWYoYT09PS0xKXRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgc3RhcnQgc2hhcmQgZm9yIGJ5dGUgJHt0fWApO2xldCByPW4tdCxzPW5ldyBBcnJheUJ1ZmZlcihyKSxpPW5ldyBVaW50OEFycmF5KHMpLG89MDtmb3IobGV0IGw9YTtsPHRoaXMuc2hhcmRzLmxlbmd0aDtsKyspe2xldCB1PXRoaXMuc2hhcmRzW2xdLHA9dCtvLXUuc3RhcnQsZD1vLGM9TWF0aC5taW4obix1LmVuZCktdS5zdGFydCxoPW5ldyBVaW50OEFycmF5KHUuYnVmZmVyLHAsYy1wKTtpZihpLnNldChoLGQpLG8rPWgubGVuZ3RoLG48dS5lbmQpYnJlYWt9cmV0dXJuIHN9ZmluZFNoYXJkRm9yQnl0ZSh0KXtpZih0aGlzLnNoYXJkcy5sZW5ndGg9PT0wfHx0PDB8fHQ+PXRoaXMuYnl0ZUxlbmd0aClyZXR1cm4tMTtpZih0aGlzLmJ1ZmZlclVuaWZvcm1TaXplIT1udWxsKXJldHVybiB0aGlzLnByZXZpb3VzU2hhcmRJbmRleD1NYXRoLmZsb29yKHQvdGhpcy5idWZmZXJVbmlmb3JtU2l6ZSksdGhpcy5wcmV2aW91c1NoYXJkSW5kZXg7ZnVuY3Rpb24gbihyKXtyZXR1cm4gdDxyLnN0YXJ0Py0xOnQ+PXIuZW5kPzE6MH1pZihuKHRoaXMuc2hhcmRzW3RoaXMucHJldmlvdXNTaGFyZEluZGV4XSk9PT0wKXJldHVybiB0aGlzLnByZXZpb3VzU2hhcmRJbmRleDtsZXQgYT1LTSh0aGlzLnNoYXJkcyxuKTtyZXR1cm4gYT09PS0xPy0xOih0aGlzLnByZXZpb3VzU2hhcmRJbmRleD1hLHRoaXMucHJldmlvdXNTaGFyZEluZGV4KX19O2Z1bmN0aW9uIEtNKGUsdCl7bGV0IG49MCxhPWUubGVuZ3RoO2Zvcig7bjw9YTspe2xldCByPU1hdGguZmxvb3IoKGEtbikvMikrbixzPXQoZVtyXSk7aWYocz09PTApcmV0dXJuIHI7czwwP2E9cjpuPXIrMX1yZXR1cm4tMX1mdW5jdGlvbiBYTSgpe0coKS5zZXQoXCJQUk9EXCIsITApfWZ1bmN0aW9uIFlNKCl7RygpLnNldChcIkRFQlVHXCIsITApfWZ1bmN0aW9uIFpNKCl7RygpLnNldChcIkRFUFJFQ0FUSU9OX1dBUk5JTkdTX0VOQUJMRURcIiwhMSksY29uc29sZS53YXJuKFwiVGVuc29yRmxvdy5qcyBkZXByZWNhdGlvbiB3YXJuaW5ncyBoYXZlIGJlZW4gZGlzYWJsZWQuXCIpfWZ1bmN0aW9uICR2KGUpe0coKS5nZXRCb29sKFwiREVQUkVDQVRJT05fV0FSTklOR1NfRU5BQkxFRFwiKSYmY29uc29sZS53YXJuKGUrXCIgWW91IGNhbiBkaXNhYmxlIGRlcHJlY2F0aW9uIHdhcm5pbmdzIHdpdGggdGYuZGlzYWJsZURlcHJlY2F0aW9uV2FybmluZ3MoKS5cIil9TE0oJHYpO2Z1bmN0aW9uIEpNKCl7UC5kaXNwb3NlVmFyaWFibGVzKCl9ZnVuY3Rpb24gVGEoKXtyZXR1cm4gUH1mdW5jdGlvbiBLaCgpe3JldHVybiBQLm1lbW9yeSgpfWZ1bmN0aW9uIFFNKGUpe3JldHVybiBQLnByb2ZpbGUoZSl9ZnVuY3Rpb24gTyhlLHQpe3JldHVybiBQLnRpZHkoZSx0KX1mdW5jdGlvbiBFZShlKXtfdihlKS5mb3JFYWNoKHQ9PnQuZGlzcG9zZSgpKX1mdW5jdGlvbiBIdChlKXtyZXR1cm4gUC5rZWVwKGUpfWZ1bmN0aW9uIGVPKGUpe3JldHVybiBQLnRpbWUoZSl9ZnVuY3Rpb24gdE8oZSl7cmV0dXJuIFAuc2V0QmFja2VuZChlKX1mdW5jdGlvbiBuTygpe3JldHVybiBQLnJlYWR5KCl9ZnVuY3Rpb24gb04oKXtyZXR1cm4gUC5iYWNrZW5kTmFtZX1mdW5jdGlvbiBhTyhlKXtQLnJlbW92ZUJhY2tlbmQoZSl9ZnVuY3Rpb24gck8oZSl7cmV0dXJuIFAuZmluZEJhY2tlbmQoZSl9ZnVuY3Rpb24gc08oZSl7cmV0dXJuIFAuZmluZEJhY2tlbmRGYWN0b3J5KGUpfWZ1bmN0aW9uIE9tKGUsdCxuPTEpe3JldHVybiBQLnJlZ2lzdGVyQmFja2VuZChlLHQsbil9ZnVuY3Rpb24gRHYoKXtyZXR1cm4gUC5iYWNrZW5kfWZ1bmN0aW9uIGlPKGUsdCl7RygpLnNldFBsYXRmb3JtKGUsdCl9dmFyIGxzPTQ7YXN5bmMgZnVuY3Rpb24gb08oZSx0KXtsZXQgbj1bXSxhPVtdLHI9QXJyYXkuaXNBcnJheShlKT9lLm1hcChpPT5pLm5hbWUpOk9iamVjdC5rZXlzKGUpO2ZvcihsZXQgaT0wO2k8ci5sZW5ndGg7KytpKXtsZXQgbz1yW2ldLGw9QXJyYXkuaXNBcnJheShlKT9lW2ldLnRlbnNvcjplW29dO2lmKGwuZHR5cGUhPT1cImZsb2F0MzJcIiYmbC5kdHlwZSE9PVwiaW50MzJcIiYmbC5kdHlwZSE9PVwiYm9vbFwiJiZsLmR0eXBlIT09XCJzdHJpbmdcIiYmbC5kdHlwZSE9PVwiY29tcGxleDY0XCIpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkdHlwZSBpbiB3ZWlnaHQgJyR7b30nOiAke2wuZHR5cGV9YCk7bGV0IHU9e25hbWU6byxzaGFwZTpsLnNoYXBlLGR0eXBlOmwuZHR5cGV9O2lmKGwuZHR5cGU9PT1cInN0cmluZ1wiKXtsZXQgcD1uZXcgUHJvbWlzZShhc3luYyBkPT57bGV0IGM9YXdhaXQgbC5ieXRlcygpLGg9Yy5yZWR1Y2UoKGcsYik9PmcrYi5sZW5ndGgsMCkrbHMqYy5sZW5ndGgsbT1uZXcgVWludDhBcnJheShoKSxmPTA7Zm9yKGxldCBnPTA7ZzxjLmxlbmd0aDtnKyspe2xldCBiPWNbZ10seT1uZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoW2IubGVuZ3RoXSkuYnVmZmVyKTttLnNldCh5LGYpLGYrPWxzLG0uc2V0KGIsZiksZis9Yi5sZW5ndGh9ZChtKX0pO2EucHVzaChwKX1lbHNlIGEucHVzaChsLmRhdGEoKSk7dCE9bnVsbCYmKHUuZ3JvdXA9dCksbi5wdXNoKHUpfWxldCBzPWF3YWl0IFByb21pc2UuYWxsKGEpO3JldHVybntkYXRhOnBPKHMpLHNwZWNzOm59fWZ1bmN0aW9uIGxOKGUsdCl7bGV0IG49bmV3IEZyKGUpLGE9e30scj0wO2ZvcihsZXQgcyBvZiB0KXtsZXQgaT1sTyhzLChvLGwpPT5uLnNsaWNlKHIrbyxyK2wpKTthW3MubmFtZV09dU4ocyxuLnNsaWNlKHIscitpKSkscis9aX1yZXR1cm4gYX1mdW5jdGlvbiBsTyhlLHQpe2xldCBuPW90KGUuc2hhcGUpLGE7aWYoXCJxdWFudGl6YXRpb25cImluIGUpe2xldCByPWUucXVhbnRpemF0aW9uO2E9dWlbci5kdHlwZV19ZWxzZSBpZihlLmR0eXBlPT09XCJzdHJpbmdcIil7bGV0IHI9MDtmb3IobGV0IHM9MDtzPG47cysrKXIrPWxzK25ldyBVaW50MzJBcnJheSh0KHIscitscykpWzBdO3JldHVybiByfWVsc2UgYT11aVtlLmR0eXBlXTtyZXR1cm4gbiphfWFzeW5jIGZ1bmN0aW9uIHVPKGUsdCl7bGV0IG49b3QoZS5zaGFwZSksYTtpZihcInF1YW50aXphdGlvblwiaW4gZSl7bGV0IHI9ZS5xdWFudGl6YXRpb247YT11aVtyLmR0eXBlXX1lbHNlIGlmKGUuZHR5cGU9PT1cInN0cmluZ1wiKXtsZXQgcj0wO2ZvcihsZXQgcz0wO3M8bjtzKyspcis9bHMrbmV3IFVpbnQzMkFycmF5KGF3YWl0IHQocixyK2xzKSlbMF07cmV0dXJuIHJ9ZWxzZSBhPXVpW2UuZHR5cGVdO3JldHVybiBuKmF9ZnVuY3Rpb24gdU4oZSx0KXtsZXQgbj1lLm5hbWUsYT1lLmR0eXBlLHI9ZS5zaGFwZSxzPW90KHIpLGksbz0wO2lmKFwicXVhbnRpemF0aW9uXCJpbiBlKXtsZXQgbD1lLnF1YW50aXphdGlvbjtpZihsLmR0eXBlPT09XCJ1aW50OFwifHxsLmR0eXBlPT09XCJ1aW50MTZcIil7aWYoIShcIm1pblwiaW4gbCYmXCJzY2FsZVwiaW4gbCkpdGhyb3cgbmV3IEVycm9yKGBXZWlnaHQgJHtlLm5hbWV9IHdpdGggcXVhbnRpemF0aW9uICR7bC5kdHlwZX0gZG9lc24ndCBoYXZlIGNvcnJlc3BvbmRpbmcgbWV0YWRhdGEgbWluIGFuZCBzY2FsZS5gKX1lbHNlIGlmKGwuZHR5cGU9PT1cImZsb2F0MTZcIil7aWYoYSE9PVwiZmxvYXQzMlwiKXRocm93IG5ldyBFcnJvcihgV2VpZ2h0ICR7ZS5uYW1lfSBpcyBxdWFudGl6ZWQgd2l0aCAke2wuZHR5cGV9IHdoaWNoIG9ubHkgc3VwcG9ydHMgd2VpZ2h0cyBvZiB0eXBlIGZsb2F0MzIgbm90ICR7YX0uYCl9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFdlaWdodCAke2UubmFtZX0gaGFzIHVua25vd24gcXVhbnRpemF0aW9uIGR0eXBlICR7bC5kdHlwZX0uIFN1cHBvcnRlZCBxdWFudGl6YXRpb24gZHR5cGVzIGFyZTogJ3VpbnQ4JywgJ3VpbnQxNicsIGFuZCAnZmxvYXQxNicuYCk7bGV0IHU9dWlbbC5kdHlwZV0scD1sLmR0eXBlPT09XCJ1aW50OFwiP25ldyBVaW50OEFycmF5KHQpOm5ldyBVaW50MTZBcnJheSh0KTtpZihhPT09XCJmbG9hdDMyXCIpaWYobC5kdHlwZT09PVwidWludDhcInx8bC5kdHlwZT09PVwidWludDE2XCIpe2k9bmV3IEZsb2F0MzJBcnJheShwLmxlbmd0aCk7Zm9yKGxldCBkPTA7ZDxwLmxlbmd0aDtkKyspe2xldCBjPXBbZF07aVtkXT1jKmwuc2NhbGUrbC5taW59fWVsc2UgaWYobC5kdHlwZT09PVwiZmxvYXQxNlwiKWk9Yk8oKShwKTtlbHNlIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcXVhbnRpemF0aW9uIHR5cGUgJHtsLmR0eXBlfSBmb3Igd2VpZ2h0IHR5cGUgZmxvYXQzMi5gKTtlbHNlIGlmKGE9PT1cImludDMyXCIpe2lmKGwuZHR5cGUhPT1cInVpbnQ4XCImJmwuZHR5cGUhPT1cInVpbnQxNlwiKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcXVhbnRpemF0aW9uIHR5cGUgJHtsLmR0eXBlfSBmb3Igd2VpZ2h0IHR5cGUgaW50MzIuYCk7aT1uZXcgSW50MzJBcnJheShwLmxlbmd0aCk7Zm9yKGxldCBkPTA7ZDxwLmxlbmd0aDtkKyspe2xldCBjPXBbZF07aVtkXT1NYXRoLnJvdW5kKGMqbC5zY2FsZStsLm1pbil9fWVsc2UgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkdHlwZSBpbiB3ZWlnaHQgJyR7bn0nOiAke2F9YCk7bys9cyp1fWVsc2UgaWYoYT09PVwic3RyaW5nXCIpe2xldCBsPW90KGUuc2hhcGUpO2k9W107Zm9yKGxldCB1PTA7dTxsO3UrKyl7bGV0IHA9bmV3IFVpbnQzMkFycmF5KHQuc2xpY2UobyxvK2xzKSlbMF07bys9bHM7bGV0IGQ9bmV3IFVpbnQ4QXJyYXkodC5zbGljZShvLG8rcCkpO2kucHVzaChkKSxvKz1wfX1lbHNle2xldCBsPXVpW2FdO2lmKGE9PT1cImZsb2F0MzJcIilpPW5ldyBGbG9hdDMyQXJyYXkodCk7ZWxzZSBpZihhPT09XCJpbnQzMlwiKWk9bmV3IEludDMyQXJyYXkodCk7ZWxzZSBpZihhPT09XCJib29sXCIpaT1uZXcgVWludDhBcnJheSh0KTtlbHNlIGlmKGE9PT1cImNvbXBsZXg2NFwiKXtpPW5ldyBGbG9hdDMyQXJyYXkodCk7bGV0IHU9bmV3IEZsb2F0MzJBcnJheShpLmxlbmd0aC8yKSxwPW5ldyBGbG9hdDMyQXJyYXkoaS5sZW5ndGgvMik7Zm9yKGxldCBtPTA7bTx1Lmxlbmd0aDttKyspdVttXT1pW20qMl0scFttXT1pW20qMisxXTtsZXQgZD1ibih1LHIsXCJmbG9hdDMyXCIpLGM9Ym4ocCxyLFwiZmxvYXQzMlwiKSxoPV9yKGQsYyk7cmV0dXJuIGQuZGlzcG9zZSgpLGMuZGlzcG9zZSgpLGh9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGR0eXBlIGluIHdlaWdodCAnJHtufSc6ICR7YX1gKTtvKz1zKmx9cmV0dXJuIGJuKGkscixhKX1hc3luYyBmdW5jdGlvbiBKayhlLHQsbil7bGV0IGE9bmV3IFVpbnQ4QXJyYXkodCk7Zm9yKDthLmJ5dGVMZW5ndGg8bjspe2xldHtkb25lOnIsdmFsdWU6c309YXdhaXQgZS5yZWFkKCk7aWYociYmcz09bnVsbCl7bGV0IG89bi1hLmJ5dGVMZW5ndGg7dGhyb3cgbmV3IEVycm9yKGBSZWFkZXIgaXMgZG9uZSBidXQgJHtvfSBieXRlcyBhcmUgc3RpbGwgZXhwZWN0ZWRgKX1sZXQgaT1uZXcgVWludDhBcnJheShhLmxlbmd0aCtzLmJ5dGVMZW5ndGgpO2kuc2V0KGEsMCksaS5zZXQobmV3IFVpbnQ4QXJyYXkocyksYS5sZW5ndGgpLGE9aX1yZXR1cm4gYS5idWZmZXJ9YXN5bmMgZnVuY3Rpb24gcE4oZSx0KXtsZXQgbj17fSxhPWUuZ2V0UmVhZGVyKCkscj1uZXcgQXJyYXlCdWZmZXIoMCk7Zm9yKGxldCBzIG9mIHQpe2xldCBpPWF3YWl0IHVPKHMsYXN5bmModSxwKT0+KHI9YXdhaXQgSmsoYSxyLHApLHIuc2xpY2UodSxwKSkpO3I9YXdhaXQgSmsoYSxyLGkpO2xldCBvPXIuc2xpY2UoMCxpKTtyPXIuc2xpY2UoaSk7bGV0IGw9dU4ocyxvKTtpZihuW3MubmFtZV09bCxvTigpPT09XCJ3ZWJncHVcIil7bGV0IHU9RHYoKTtcInVwbG9hZFRvR1BVXCJpbiB1JiZvdChsLnNoYXBlKT49RygpLmdldChcIldFQkdQVV9DUFVfSEFORE9GRl9TSVpFX1RIUkVTSE9MRFwiKSYmdS51cGxvYWRUb0dQVShsLmRhdGFJZCl9fXJldHVybiBufWZ1bmN0aW9uIHBPKGUpe2lmKGU9PT1udWxsKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpbnB1dCB2YWx1ZTogJHtKU09OLnN0cmluZ2lmeShlKX1gKTtsZXQgdD0wLG49W107ZS5mb3JFYWNoKHM9PntpZih0Kz1zLmJ5dGVMZW5ndGgsbi5wdXNoKHMuYnl0ZUxlbmd0aD09PXMuYnVmZmVyLmJ5dGVMZW5ndGg/czpuZXcgcy5jb25zdHJ1Y3RvcihzKSksIShzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5fHxzIGluc3RhbmNlb2YgSW50MzJBcnJheXx8cyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgVHlwZWRBcnJheSBzdWJ0eXBlOiAke3MuY29uc3RydWN0b3IubmFtZX1gKX0pO2xldCBhPW5ldyBVaW50OEFycmF5KHQpLHI9MDtyZXR1cm4gbi5mb3JFYWNoKHM9PnthLnNldChuZXcgVWludDhBcnJheShzLmJ1ZmZlcikscikscis9cy5ieXRlTGVuZ3RofSksYS5idWZmZXJ9dmFyIFJ2PXR5cGVvZiBCdWZmZXIhPVwidW5kZWZpbmVkXCImJih0eXBlb2YgQmxvYj09XCJ1bmRlZmluZWRcInx8dHlwZW9mIGF0b2I9PVwidW5kZWZpbmVkXCJ8fHR5cGVvZiBidG9hPT1cInVuZGVmaW5lZFwiKTtmdW5jdGlvbiBRayhlKXtyZXR1cm4gUnY/QnVmZmVyLmJ5dGVMZW5ndGgoZSxcInV0ZjhcIik6bmV3IEJsb2IoW2VdKS5zaXplfWZ1bmN0aW9uIGNPKGUpe2lmKFJ2KXJldHVybiBCdWZmZXIuZnJvbShlKS50b1N0cmluZyhcImJhc2U2NFwiKTtsZXQgdD1uZXcgVWludDhBcnJheShlKSxuPVwiXCI7Zm9yKGxldCBhPTAscj10Lmxlbmd0aDthPHI7YSsrKW4rPVN0cmluZy5mcm9tQ2hhckNvZGUodFthXSk7cmV0dXJuIGJ0b2Eobil9ZnVuY3Rpb24gZE8oZSl7aWYoUnYpe2xldCBhPUJ1ZmZlci5mcm9tKGUsXCJiYXNlNjRcIik7cmV0dXJuIGEuYnVmZmVyLnNsaWNlKGEuYnl0ZU9mZnNldCxhLmJ5dGVPZmZzZXQrYS5ieXRlTGVuZ3RoKX1sZXQgdD1hdG9iKGUpLG49bmV3IFVpbnQ4QXJyYXkodC5sZW5ndGgpO2ZvcihsZXQgYT0wO2E8dC5sZW5ndGg7KythKW4uc2V0KFt0LmNoYXJDb2RlQXQoYSldLGEpO3JldHVybiBuLmJ1ZmZlcn1mdW5jdGlvbiBoTyhlKXtyZXR1cm4gRnIuam9pbihlKX1mdW5jdGlvbiBlSShlKXtsZXQgdD1cIi9cIjtmb3IoZT1lLnRyaW0oKTtlLmVuZHNXaXRoKHQpOyllPWUuc2xpY2UoMCxlLmxlbmd0aC0xKTtsZXQgbj1lLnNwbGl0KHQpO3JldHVybiBuW24ubGVuZ3RoLTFdfWZ1bmN0aW9uIGNOKGUsdCl7bGV0IG49e21vZGVsVG9wb2xvZ3k6ZS5tb2RlbFRvcG9sb2d5LGZvcm1hdDplLmZvcm1hdCxnZW5lcmF0ZWRCeTplLmdlbmVyYXRlZEJ5LGNvbnZlcnRlZEJ5OmUuY29udmVydGVkQnksd2VpZ2h0c01hbmlmZXN0OnR9O3JldHVybiBlLnNpZ25hdHVyZSE9bnVsbCYmKG4uc2lnbmF0dXJlPWUuc2lnbmF0dXJlKSxlLnVzZXJEZWZpbmVkTWV0YWRhdGEhPW51bGwmJihuLnVzZXJEZWZpbmVkTWV0YWRhdGE9ZS51c2VyRGVmaW5lZE1ldGFkYXRhKSxlLm1vZGVsSW5pdGlhbGl6ZXIhPW51bGwmJihuLm1vZGVsSW5pdGlhbGl6ZXI9ZS5tb2RlbEluaXRpYWxpemVyKSxlLmluaXRpYWxpemVyU2lnbmF0dXJlIT1udWxsJiYobi5pbml0aWFsaXplclNpZ25hdHVyZT1lLmluaXRpYWxpemVyU2lnbmF0dXJlKSxlLnRyYWluaW5nQ29uZmlnIT1udWxsJiYobi50cmFpbmluZ0NvbmZpZz1lLnRyYWluaW5nQ29uZmlnKSxufWZ1bmN0aW9uIGROKGUsdCxuKXtsZXQgYT17bW9kZWxUb3BvbG9neTplLm1vZGVsVG9wb2xvZ3ksZm9ybWF0OmUuZm9ybWF0LGdlbmVyYXRlZEJ5OmUuZ2VuZXJhdGVkQnksY29udmVydGVkQnk6ZS5jb252ZXJ0ZWRCeX07aWYoZS50cmFpbmluZ0NvbmZpZyE9bnVsbCYmKGEudHJhaW5pbmdDb25maWc9ZS50cmFpbmluZ0NvbmZpZyksZS53ZWlnaHRzTWFuaWZlc3QhPW51bGwpe2lmKCF0KXRocm93IG5ldyBFcnJvcihcIm1vZGVsSlNPTiBoYXMgd2VpZ2h0c01hbmlmZXN0IGJ1dCB3ZWlnaHRTcGVjcyBpcyBudWxsXCIpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcIm1vZGVsSlNPTiBoYXMgd2VpZ2h0c01hbmlmZXN0IGJ1dCB3ZWlnaHREYXRhIGlzIG51bGxcIik7YS53ZWlnaHRTcGVjcz10LGEud2VpZ2h0RGF0YT1ufXJldHVybiBlLnNpZ25hdHVyZSE9bnVsbCYmKGEuc2lnbmF0dXJlPWUuc2lnbmF0dXJlKSxlLnVzZXJEZWZpbmVkTWV0YWRhdGEhPW51bGwmJihhLnVzZXJEZWZpbmVkTWV0YWRhdGE9ZS51c2VyRGVmaW5lZE1ldGFkYXRhKSxlLm1vZGVsSW5pdGlhbGl6ZXIhPW51bGwmJihhLm1vZGVsSW5pdGlhbGl6ZXI9ZS5tb2RlbEluaXRpYWxpemVyKSxlLmluaXRpYWxpemVyU2lnbmF0dXJlIT1udWxsJiYoYS5pbml0aWFsaXplclNpZ25hdHVyZT1lLmluaXRpYWxpemVyU2lnbmF0dXJlKSxhfWFzeW5jIGZ1bmN0aW9uIE12KGUsdCl7bGV0IG4sYTtyZXR1cm4gZS53ZWlnaHRzTWFuaWZlc3QhPW51bGwmJihbbixhXT1hd2FpdCB0KGUud2VpZ2h0c01hbmlmZXN0KSksZE4oZSxuLGEpfWZ1bmN0aW9uIHJkKGUpe2lmKGUubW9kZWxUb3BvbG9neSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIEpTT04gbW9kZWwgdG9wb2xvZ3ksIHJlY2VpdmVkIEFycmF5QnVmZmVyLlwiKTtyZXR1cm57ZGF0ZVNhdmVkOm5ldyBEYXRlLG1vZGVsVG9wb2xvZ3lUeXBlOlwiSlNPTlwiLG1vZGVsVG9wb2xvZ3lCeXRlczplLm1vZGVsVG9wb2xvZ3k9PW51bGw/MDpRayhKU09OLnN0cmluZ2lmeShlLm1vZGVsVG9wb2xvZ3kpKSx3ZWlnaHRTcGVjc0J5dGVzOmUud2VpZ2h0U3BlY3M9PW51bGw/MDpRayhKU09OLnN0cmluZ2lmeShlLndlaWdodFNwZWNzKSksd2VpZ2h0RGF0YUJ5dGVzOmUud2VpZ2h0RGF0YT09bnVsbD8wOm5ldyBGcihlLndlaWdodERhdGEpLmJ5dGVMZW5ndGh9fWZ1bmN0aW9uIF94KGUpe2xldCB0PVtdO2ZvcihsZXQgbiBvZiBlKXQucHVzaCguLi5uLndlaWdodHMpO3JldHVybiB0fWZ1bmN0aW9uIG1PKCl7bGV0IGU9bj0+e2xldCBhPW48PDEzLHI9MDtmb3IoOyEoYSY4Mzg4NjA4KTspci09ODM4ODYwOCxhPDw9MTtyZXR1cm4gYSY9LTgzODg2MDkscis9OTQ3OTEyNzA0LGF8cn0sdD1uZXcgVWludDMyQXJyYXkoMjA0OCk7dFswXT0wO2ZvcihsZXQgbj0xO248MTAyNDtuKyspdFtuXT1lKG4pO2ZvcihsZXQgbj0xMDI0O248MjA0ODtuKyspdFtuXT05Mzk1MjQwOTYrKG4tMTAyNDw8MTMpO3JldHVybiB0fWZ1bmN0aW9uIGZPKCl7bGV0IGU9bmV3IFVpbnQzMkFycmF5KDY0KTtlWzBdPTAsZVszMV09MTE5OTU3MDk0NCxlWzMyXT0yMTQ3NDgzNjQ4LGVbNjNdPTMzNDcwNTQ1OTI7Zm9yKGxldCB0PTE7dDwzMTt0KyspZVt0XT10PDwyMztmb3IobGV0IHQ9MzM7dDw2Mzt0KyspZVt0XT0yMTQ3NDgzNjQ4Kyh0LTMyPDwyMyk7cmV0dXJuIGV9ZnVuY3Rpb24gZ08oKXtsZXQgZT1uZXcgVWludDMyQXJyYXkoNjQpO2ZvcihsZXQgdD0wO3Q8NjQ7dCsrKWVbdF09MTAyNDtyZXR1cm4gZVswXT1lWzMyXT0wLGV9ZnVuY3Rpb24gYk8oKXtsZXQgZT1tTygpLHQ9Zk8oKSxuPWdPKCk7cmV0dXJuIGE9PntsZXQgcj1uZXcgQXJyYXlCdWZmZXIoNCphLmxlbmd0aCkscz1uZXcgVWludDMyQXJyYXkocik7Zm9yKGxldCBpPTA7aTxhLmxlbmd0aDtpKyspe2xldCBvPWFbaV0sbD1lW25bbz4+MTBdKyhvJjEwMjMpXSt0W28+PjEwXTtzW2ldPWx9cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkocil9fXZhciBnYT1jbGFzcyBMYXtjb25zdHJ1Y3Rvcigpe3RoaXMuc2F2ZVJvdXRlcnM9W10sdGhpcy5sb2FkUm91dGVycz1bXX1zdGF0aWMgZ2V0SW5zdGFuY2UoKXtyZXR1cm4gTGEuaW5zdGFuY2U9PW51bGwmJihMYS5pbnN0YW5jZT1uZXcgTGEpLExhLmluc3RhbmNlfXN0YXRpYyByZWdpc3RlclNhdmVSb3V0ZXIodCl7TGEuZ2V0SW5zdGFuY2UoKS5zYXZlUm91dGVycy5wdXNoKHQpfXN0YXRpYyByZWdpc3RlckxvYWRSb3V0ZXIodCl7TGEuZ2V0SW5zdGFuY2UoKS5sb2FkUm91dGVycy5wdXNoKHQpfXN0YXRpYyBnZXRTYXZlSGFuZGxlcnModCl7cmV0dXJuIExhLmdldEhhbmRsZXJzKHQsXCJzYXZlXCIpfXN0YXRpYyBnZXRMb2FkSGFuZGxlcnModCxuKXtyZXR1cm4gTGEuZ2V0SGFuZGxlcnModCxcImxvYWRcIixuKX1zdGF0aWMgZ2V0SGFuZGxlcnModCxuLGEpe2xldCByPVtdO3JldHVybihuPT09XCJsb2FkXCI/TGEuZ2V0SW5zdGFuY2UoKS5sb2FkUm91dGVyczpMYS5nZXRJbnN0YW5jZSgpLnNhdmVSb3V0ZXJzKS5mb3JFYWNoKHM9PntsZXQgaT1zKHQsYSk7aSE9PW51bGwmJnIucHVzaChpKX0pLHJ9fSx5Tz1lPT5nYS5yZWdpc3RlclNhdmVSb3V0ZXIoZSkseE89ZT0+Z2EucmVnaXN0ZXJMb2FkUm91dGVyKGUpLHZPPWU9PmdhLmdldFNhdmVIYW5kbGVycyhlKSx3Tz0oZSx0KT0+Z2EuZ2V0TG9hZEhhbmRsZXJzKGUsdCksQXg9XCJ0ZW5zb3JmbG93anNcIixGeD0xLHRpPVwibW9kZWxzX3N0b3JlXCIsUXI9XCJtb2RlbF9pbmZvX3N0b3JlXCI7ZnVuY3Rpb24gaE4oKXtpZighRygpLmdldEJvb2woXCJJU19CUk9XU0VSXCIpKXRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBvYnRhaW4gSW5kZXhlZERCIGZhY3RvcnkgYmVjYXVzZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudGlzIG5vdCBhIHdlYiBicm93c2VyLlwiKTtsZXQgZT10eXBlb2Ygd2luZG93PT1cInVuZGVmaW5lZFwiP3NlbGY6d2luZG93LHQ9ZS5pbmRleGVkREJ8fGUubW96SW5kZXhlZERCfHxlLndlYmtpdEluZGV4ZWREQnx8ZS5tc0luZGV4ZWREQnx8ZS5zaGltSW5kZXhlZERCO2lmKHQ9PW51bGwpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgYnJvd3NlciBkb2VzIG5vdCBhcHBlYXIgdG8gc3VwcG9ydCBJbmRleGVkREIuXCIpO3JldHVybiB0fWZ1bmN0aW9uICR4KGUpe2xldCB0PWUucmVzdWx0O3QuY3JlYXRlT2JqZWN0U3RvcmUodGkse2tleVBhdGg6XCJtb2RlbFBhdGhcIn0pLHQuY3JlYXRlT2JqZWN0U3RvcmUoUXIse2tleVBhdGg6XCJtb2RlbFBhdGhcIn0pfXZhciBwaT1jbGFzc3tjb25zdHJ1Y3RvcihlKXtpZih0aGlzLmluZGV4ZWREQj1oTigpLGU9PW51bGx8fCFlKXRocm93IG5ldyBFcnJvcihcIkZvciBJbmRleGVkREIsIG1vZGVsUGF0aCBtdXN0IG5vdCBiZSBudWxsLCB1bmRlZmluZWQgb3IgZW1wdHkuXCIpO3RoaXMubW9kZWxQYXRoPWV9YXN5bmMgc2F2ZShlKXtpZihlLm1vZGVsVG9wb2xvZ3kgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyTG9jYWxTdG9yYWdlLnNhdmUoKSBkb2VzIG5vdCBzdXBwb3J0IHNhdmluZyBtb2RlbCB0b3BvbG9neSBpbiBiaW5hcnkgZm9ybWF0cyB5ZXQuXCIpO3JldHVybiB0aGlzLmRhdGFiYXNlQWN0aW9uKHRoaXMubW9kZWxQYXRoLGUpfWFzeW5jIGxvYWQoKXtyZXR1cm4gdGhpcy5kYXRhYmFzZUFjdGlvbih0aGlzLm1vZGVsUGF0aCl9ZGF0YWJhc2VBY3Rpb24oZSx0KXtyZXR1cm4gbmV3IFByb21pc2UoKG4sYSk9PntsZXQgcj10aGlzLmluZGV4ZWREQi5vcGVuKEF4LEZ4KTtyLm9udXBncmFkZW5lZWRlZD0oKT0+JHgociksci5vbnN1Y2Nlc3M9KCk9PntsZXQgcz1yLnJlc3VsdDtpZih0PT1udWxsKXtsZXQgaT1zLnRyYW5zYWN0aW9uKHRpLFwicmVhZG9ubHlcIiksbz1pLm9iamVjdFN0b3JlKHRpKS5nZXQodGhpcy5tb2RlbFBhdGgpO28ub25zdWNjZXNzPSgpPT57aWYoby5yZXN1bHQ9PW51bGwpcmV0dXJuIHMuY2xvc2UoKSxhKG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgbW9kZWwgd2l0aCBwYXRoICcke3RoaXMubW9kZWxQYXRofScgaW4gSW5kZXhlZERCLmApKTtuKG8ucmVzdWx0Lm1vZGVsQXJ0aWZhY3RzKX0sby5vbmVycm9yPWw9PihzLmNsb3NlKCksYShvLmVycm9yKSksaS5vbmNvbXBsZXRlPSgpPT5zLmNsb3NlKCl9ZWxzZXt0LndlaWdodERhdGE9RnIuam9pbih0LndlaWdodERhdGEpO2xldCBpPXJkKHQpLG89cy50cmFuc2FjdGlvbihRcixcInJlYWR3cml0ZVwiKSxsPW8ub2JqZWN0U3RvcmUoUXIpLHU7dHJ5e3U9bC5wdXQoe21vZGVsUGF0aDp0aGlzLm1vZGVsUGF0aCxtb2RlbEFydGlmYWN0c0luZm86aX0pfWNhdGNoKGQpe3JldHVybiBhKGQpfWxldCBwO3Uub25zdWNjZXNzPSgpPT57cD1zLnRyYW5zYWN0aW9uKHRpLFwicmVhZHdyaXRlXCIpO2xldCBkPXAub2JqZWN0U3RvcmUodGkpLGM7dHJ5e2M9ZC5wdXQoe21vZGVsUGF0aDp0aGlzLm1vZGVsUGF0aCxtb2RlbEFydGlmYWN0czp0LG1vZGVsQXJ0aWZhY3RzSW5mbzppfSl9Y2F0Y2goaCl7cmV0dXJuIGEoaCl9Yy5vbnN1Y2Nlc3M9KCk9Pm4oe21vZGVsQXJ0aWZhY3RzSW5mbzppfSksYy5vbmVycm9yPWg9PntsPW8ub2JqZWN0U3RvcmUoUXIpO2xldCBtPWwuZGVsZXRlKHRoaXMubW9kZWxQYXRoKTttLm9uc3VjY2Vzcz0oKT0+KHMuY2xvc2UoKSxhKGMuZXJyb3IpKSxtLm9uZXJyb3I9Zj0+KHMuY2xvc2UoKSxhKGMuZXJyb3IpKX19LHUub25lcnJvcj1kPT4ocy5jbG9zZSgpLGEodS5lcnJvcikpLG8ub25jb21wbGV0ZT0oKT0+e3A9PW51bGw/cy5jbG9zZSgpOnAub25jb21wbGV0ZT0oKT0+cy5jbG9zZSgpfX19LHIub25lcnJvcj1zPT5hKHIuZXJyb3IpfSl9fTtwaS5VUkxfU0NIRU1FPVwiaW5kZXhlZGRiOi8vXCI7dmFyIG1OPWU9PkcoKS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSYmIUFycmF5LmlzQXJyYXkoZSkmJmUuc3RhcnRzV2l0aChwaS5VUkxfU0NIRU1FKT9rTyhlLnNsaWNlKHBpLlVSTF9TQ0hFTUUubGVuZ3RoKSk6bnVsbDtnYS5yZWdpc3RlclNhdmVSb3V0ZXIobU4pO2dhLnJlZ2lzdGVyTG9hZFJvdXRlcihtTik7ZnVuY3Rpb24ga08oZSl7cmV0dXJuIG5ldyBwaShlKX1mdW5jdGlvbiBJTyhlKXtyZXR1cm4gZS5zdGFydHNXaXRoKHBpLlVSTF9TQ0hFTUUpP2Uuc2xpY2UocGkuVVJMX1NDSEVNRS5sZW5ndGgpOmV9dmFyIFNPPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5pbmRleGVkREI9aE4oKX1hc3luYyBsaXN0TW9kZWxzKCl7cmV0dXJuIG5ldyBQcm9taXNlKChlLHQpPT57bGV0IG49dGhpcy5pbmRleGVkREIub3BlbihBeCxGeCk7bi5vbnVwZ3JhZGVuZWVkZWQ9KCk9PiR4KG4pLG4ub25zdWNjZXNzPSgpPT57bGV0IGE9bi5yZXN1bHQscj1hLnRyYW5zYWN0aW9uKFFyLFwicmVhZG9ubHlcIikscz1yLm9iamVjdFN0b3JlKFFyKS5nZXRBbGwoKTtzLm9uc3VjY2Vzcz0oKT0+e2xldCBpPXt9O2ZvcihsZXQgbyBvZiBzLnJlc3VsdClpW28ubW9kZWxQYXRoXT1vLm1vZGVsQXJ0aWZhY3RzSW5mbztlKGkpfSxzLm9uZXJyb3I9aT0+KGEuY2xvc2UoKSx0KHMuZXJyb3IpKSxyLm9uY29tcGxldGU9KCk9PmEuY2xvc2UoKX0sbi5vbmVycm9yPWE9PnQobi5lcnJvcil9KX1hc3luYyByZW1vdmVNb2RlbChlKXtyZXR1cm4gZT1JTyhlKSxuZXcgUHJvbWlzZSgodCxuKT0+e2xldCBhPXRoaXMuaW5kZXhlZERCLm9wZW4oQXgsRngpO2Eub251cGdyYWRlbmVlZGVkPSgpPT4keChhKSxhLm9uc3VjY2Vzcz0oKT0+e2xldCByPWEucmVzdWx0LHM9ci50cmFuc2FjdGlvbihRcixcInJlYWR3cml0ZVwiKSxpPXMub2JqZWN0U3RvcmUoUXIpLG89aS5nZXQoZSksbDtvLm9uc3VjY2Vzcz0oKT0+e2lmKG8ucmVzdWx0PT1udWxsKXJldHVybiByLmNsb3NlKCksbihuZXcgRXJyb3IoYENhbm5vdCBmaW5kIG1vZGVsIHdpdGggcGF0aCAnJHtlfScgaW4gSW5kZXhlZERCLmApKTt7bGV0IHU9aS5kZWxldGUoZSkscD0oKT0+e2w9ci50cmFuc2FjdGlvbih0aSxcInJlYWR3cml0ZVwiKTtsZXQgZD1sLm9iamVjdFN0b3JlKHRpKS5kZWxldGUoZSk7ZC5vbnN1Y2Nlc3M9KCk9PnQoby5yZXN1bHQubW9kZWxBcnRpZmFjdHNJbmZvKSxkLm9uZXJyb3I9Yz0+bihvLmVycm9yKX07dS5vbnN1Y2Nlc3M9cCx1Lm9uZXJyb3I9ZD0+KHAoKSxyLmNsb3NlKCksbihvLmVycm9yKSl9fSxvLm9uZXJyb3I9dT0+KHIuY2xvc2UoKSxuKG8uZXJyb3IpKSxzLm9uY29tcGxldGU9KCk9PntsPT1udWxsP3IuY2xvc2UoKTpsLm9uY29tcGxldGU9KCk9PnIuY2xvc2UoKX19LGEub25lcnJvcj1yPT5uKGEuZXJyb3IpfSl9fSxUcj1cIi9cIixObD1cInRlbnNvcmZsb3dqc19tb2RlbHNcIixmTj1cImluZm9cIixOTz1cIm1vZGVsX3RvcG9sb2d5XCIsVE89XCJ3ZWlnaHRfc3BlY3NcIixDTz1cIndlaWdodF9kYXRhXCIsRU89XCJtb2RlbF9tZXRhZGF0YVwiO2Z1bmN0aW9uIGdOKGUpe3JldHVybntpbmZvOltObCxlLGZOXS5qb2luKFRyKSx0b3BvbG9neTpbTmwsZSxOT10uam9pbihUciksd2VpZ2h0U3BlY3M6W05sLGUsVE9dLmpvaW4oVHIpLHdlaWdodERhdGE6W05sLGUsQ09dLmpvaW4oVHIpLG1vZGVsTWV0YWRhdGE6W05sLGUsRU9dLmpvaW4oVHIpfX1mdW5jdGlvbiBiTihlKXtmb3IobGV0IHQgb2YgT2JqZWN0LnZhbHVlcyhlKSl3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odCl9ZnVuY3Rpb24gX08oZSl7bGV0IHQ9ZS5zcGxpdChUcik7aWYodC5sZW5ndGg8Myl0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQga2V5IGZvcm1hdDogJHtlfWApO3JldHVybiB0LnNsaWNlKDEsdC5sZW5ndGgtMSkuam9pbihUcil9ZnVuY3Rpb24gQU8oZSl7cmV0dXJuIGUuc3RhcnRzV2l0aChjaS5VUkxfU0NIRU1FKT9lLnNsaWNlKGNpLlVSTF9TQ0hFTUUubGVuZ3RoKTplfXZhciBjaT1jbGFzc3tjb25zdHJ1Y3RvcihlKXtpZighRygpLmdldEJvb2woXCJJU19CUk9XU0VSXCIpfHx0eXBlb2Ygd2luZG93PT1cInVuZGVmaW5lZFwifHx0eXBlb2Ygd2luZG93LmxvY2FsU3RvcmFnZT09XCJ1bmRlZmluZWRcIil0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY3VycmVudCBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IGxvY2FsIHN0b3JhZ2UuXCIpO2lmKHRoaXMuTFM9d2luZG93LmxvY2FsU3RvcmFnZSxlPT1udWxsfHwhZSl0aHJvdyBuZXcgRXJyb3IoXCJGb3IgbG9jYWwgc3RvcmFnZSwgbW9kZWxQYXRoIG11c3Qgbm90IGJlIG51bGwsIHVuZGVmaW5lZCBvciBlbXB0eS5cIik7dGhpcy5tb2RlbFBhdGg9ZSx0aGlzLmtleXM9Z04odGhpcy5tb2RlbFBhdGgpfWFzeW5jIHNhdmUoZSl7aWYoZS5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckxvY2FsU3RvcmFnZS5zYXZlKCkgZG9lcyBub3Qgc3VwcG9ydCBzYXZpbmcgbW9kZWwgdG9wb2xvZ3kgaW4gYmluYXJ5IGZvcm1hdHMgeWV0LlwiKTt7bGV0IHQ9SlNPTi5zdHJpbmdpZnkoZS5tb2RlbFRvcG9sb2d5KSxuPUpTT04uc3RyaW5naWZ5KGUud2VpZ2h0U3BlY3MpLGE9cmQoZSkscj1Gci5qb2luKGUud2VpZ2h0RGF0YSk7dHJ5e3RoaXMuTFMuc2V0SXRlbSh0aGlzLmtleXMuaW5mbyxKU09OLnN0cmluZ2lmeShhKSksdGhpcy5MUy5zZXRJdGVtKHRoaXMua2V5cy50b3BvbG9neSx0KSx0aGlzLkxTLnNldEl0ZW0odGhpcy5rZXlzLndlaWdodFNwZWNzLG4pLHRoaXMuTFMuc2V0SXRlbSh0aGlzLmtleXMud2VpZ2h0RGF0YSxjTyhyKSk7bGV0IHM9e2Zvcm1hdDplLmZvcm1hdCxnZW5lcmF0ZWRCeTplLmdlbmVyYXRlZEJ5LGNvbnZlcnRlZEJ5OmUuY29udmVydGVkQnksc2lnbmF0dXJlOmUuc2lnbmF0dXJlIT1udWxsP2Uuc2lnbmF0dXJlOnZvaWQgMCx1c2VyRGVmaW5lZE1ldGFkYXRhOmUudXNlckRlZmluZWRNZXRhZGF0YSE9bnVsbD9lLnVzZXJEZWZpbmVkTWV0YWRhdGE6dm9pZCAwLG1vZGVsSW5pdGlhbGl6ZXI6ZS5tb2RlbEluaXRpYWxpemVyIT1udWxsP2UubW9kZWxJbml0aWFsaXplcjp2b2lkIDAsaW5pdGlhbGl6ZXJTaWduYXR1cmU6ZS5pbml0aWFsaXplclNpZ25hdHVyZSE9bnVsbD9lLmluaXRpYWxpemVyU2lnbmF0dXJlOnZvaWQgMCx0cmFpbmluZ0NvbmZpZzplLnRyYWluaW5nQ29uZmlnIT1udWxsP2UudHJhaW5pbmdDb25maWc6dm9pZCAwfTtyZXR1cm4gdGhpcy5MUy5zZXRJdGVtKHRoaXMua2V5cy5tb2RlbE1ldGFkYXRhLEpTT04uc3RyaW5naWZ5KHMpKSx7bW9kZWxBcnRpZmFjdHNJbmZvOmF9fWNhdGNoKHMpe3Rocm93IGJOKHRoaXMua2V5cyksbmV3IEVycm9yKGBGYWlsZWQgdG8gc2F2ZSBtb2RlbCAnJHt0aGlzLm1vZGVsUGF0aH0nIHRvIGxvY2FsIHN0b3JhZ2U6IHNpemUgcXVvdGEgYmVpbmcgZXhjZWVkZWQgaXMgYSBwb3NzaWJsZSBjYXVzZSBvZiB0aGlzIGZhaWx1cmU6IG1vZGVsVG9wb2xvZ3lCeXRlcz0ke2EubW9kZWxUb3BvbG9neUJ5dGVzfSwgd2VpZ2h0U3BlY3NCeXRlcz0ke2Eud2VpZ2h0U3BlY3NCeXRlc30sIHdlaWdodERhdGFCeXRlcz0ke2Eud2VpZ2h0RGF0YUJ5dGVzfS5gKX19fWFzeW5jIGxvYWQoKXtsZXQgZT1KU09OLnBhcnNlKHRoaXMuTFMuZ2V0SXRlbSh0aGlzLmtleXMuaW5mbykpO2lmKGU9PW51bGwpdGhyb3cgbmV3IEVycm9yKGBJbiBsb2NhbCBzdG9yYWdlLCB0aGVyZSBpcyBubyBtb2RlbCB3aXRoIG5hbWUgJyR7dGhpcy5tb2RlbFBhdGh9J2ApO2lmKGUubW9kZWxUb3BvbG9neVR5cGUhPT1cIkpTT05cIil0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyTG9jYWxTdG9yYWdlIGRvZXMgbm90IHN1cHBvcnQgbG9hZGluZyBub24tSlNPTiBtb2RlbCB0b3BvbG9neSB5ZXQuXCIpO2xldCB0PXt9LG49SlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLnRvcG9sb2d5KSk7aWYobj09bnVsbCl0aHJvdyBuZXcgRXJyb3IoYEluIGxvY2FsIHN0b3JhZ2UsIHRoZSB0b3BvbG9neSBvZiBtb2RlbCAnJHt0aGlzLm1vZGVsUGF0aH0nIGlzIG1pc3NpbmcuYCk7dC5tb2RlbFRvcG9sb2d5PW47bGV0IGE9SlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLndlaWdodFNwZWNzKSk7aWYoYT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoYEluIGxvY2FsIHN0b3JhZ2UsIHRoZSB3ZWlnaHQgc3BlY3Mgb2YgbW9kZWwgJyR7dGhpcy5tb2RlbFBhdGh9JyBhcmUgbWlzc2luZy5gKTt0LndlaWdodFNwZWNzPWE7bGV0IHI9dGhpcy5MUy5nZXRJdGVtKHRoaXMua2V5cy5tb2RlbE1ldGFkYXRhKTtpZihyIT1udWxsKXtsZXQgaT1KU09OLnBhcnNlKHIpO3QuZm9ybWF0PWkuZm9ybWF0LHQuZ2VuZXJhdGVkQnk9aS5nZW5lcmF0ZWRCeSx0LmNvbnZlcnRlZEJ5PWkuY29udmVydGVkQnksaS5zaWduYXR1cmUhPW51bGwmJih0LnNpZ25hdHVyZT1pLnNpZ25hdHVyZSksaS51c2VyRGVmaW5lZE1ldGFkYXRhIT1udWxsJiYodC51c2VyRGVmaW5lZE1ldGFkYXRhPWkudXNlckRlZmluZWRNZXRhZGF0YSksaS5tb2RlbEluaXRpYWxpemVyIT1udWxsJiYodC5tb2RlbEluaXRpYWxpemVyPWkubW9kZWxJbml0aWFsaXplciksaS5pbml0aWFsaXplclNpZ25hdHVyZSE9bnVsbCYmKHQuaW5pdGlhbGl6ZXJTaWduYXR1cmU9aS5pbml0aWFsaXplclNpZ25hdHVyZSksaS50cmFpbmluZ0NvbmZpZyE9bnVsbCYmKHQudHJhaW5pbmdDb25maWc9aS50cmFpbmluZ0NvbmZpZyl9bGV0IHM9dGhpcy5MUy5nZXRJdGVtKHRoaXMua2V5cy53ZWlnaHREYXRhKTtpZihzPT1udWxsKXRocm93IG5ldyBFcnJvcihgSW4gbG9jYWwgc3RvcmFnZSwgdGhlIGJpbmFyeSB3ZWlnaHQgdmFsdWVzIG9mIG1vZGVsICcke3RoaXMubW9kZWxQYXRofScgYXJlIG1pc3NpbmcuYCk7cmV0dXJuIHQud2VpZ2h0RGF0YT1kTyhzKSx0fX07Y2kuVVJMX1NDSEVNRT1cImxvY2Fsc3RvcmFnZTovL1wiO3ZhciB5Tj1lPT5HKCkuZ2V0Qm9vbChcIklTX0JST1dTRVJcIikmJiFBcnJheS5pc0FycmF5KGUpJiZlLnN0YXJ0c1dpdGgoY2kuVVJMX1NDSEVNRSk/Rk8oZS5zbGljZShjaS5VUkxfU0NIRU1FLmxlbmd0aCkpOm51bGw7Z2EucmVnaXN0ZXJTYXZlUm91dGVyKHlOKTtnYS5yZWdpc3RlckxvYWRSb3V0ZXIoeU4pO2Z1bmN0aW9uIEZPKGUpe3JldHVybiBuZXcgY2koZSl9dmFyICRPPWNsYXNze2NvbnN0cnVjdG9yKCl7QShHKCkuZ2V0Qm9vbChcIklTX0JST1dTRVJcIiksKCk9PlwiQ3VycmVudCBlbnZpcm9ubWVudCBpcyBub3QgYSB3ZWIgYnJvd3NlclwiKSxBKHR5cGVvZiB3aW5kb3c9PVwidW5kZWZpbmVkXCJ8fHR5cGVvZiB3aW5kb3cubG9jYWxTdG9yYWdlIT1cInVuZGVmaW5lZFwiLCgpPT5cIkN1cnJlbnQgYnJvd3NlciBkb2VzIG5vdCBhcHBlYXIgdG8gc3VwcG9ydCBsb2NhbFN0b3JhZ2VcIiksdGhpcy5MUz13aW5kb3cubG9jYWxTdG9yYWdlfWFzeW5jIGxpc3RNb2RlbHMoKXtsZXQgZT17fSx0PU5sK1RyLG49VHIrZk47Zm9yKGxldCBhPTA7YTx0aGlzLkxTLmxlbmd0aDsrK2Epe2xldCByPXRoaXMuTFMua2V5KGEpO2lmKHIuc3RhcnRzV2l0aCh0KSYmci5lbmRzV2l0aChuKSl7bGV0IHM9X08ocik7ZVtzXT1KU09OLnBhcnNlKHRoaXMuTFMuZ2V0SXRlbShyKSl9fXJldHVybiBlfWFzeW5jIHJlbW92ZU1vZGVsKGUpe2U9QU8oZSk7bGV0IHQ9Z04oZSk7aWYodGhpcy5MUy5nZXRJdGVtKHQuaW5mbyk9PW51bGwpdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBtb2RlbCBhdCBwYXRoICcke2V9J2ApO2xldCBuPUpTT04ucGFyc2UodGhpcy5MUy5nZXRJdGVtKHQuaW5mbykpO3JldHVybiBiTih0KSxufX0sX2w9XCI6Ly9cIix1cz1jbGFzcyBxcntjb25zdHJ1Y3Rvcigpe3RoaXMubWFuYWdlcnM9e319c3RhdGljIGdldEluc3RhbmNlKCl7cmV0dXJuIHFyLmluc3RhbmNlPT1udWxsJiYocXIuaW5zdGFuY2U9bmV3IHFyKSxxci5pbnN0YW5jZX1zdGF0aWMgcmVnaXN0ZXJNYW5hZ2VyKHQsbil7QSh0IT1udWxsLCgpPT5cInNjaGVtZSBtdXN0IG5vdCBiZSB1bmRlZmluZWQgb3IgbnVsbC5cIiksdC5lbmRzV2l0aChfbCkmJih0PXQuc2xpY2UoMCx0LmluZGV4T2YoX2wpKSksQSh0Lmxlbmd0aD4wLCgpPT5cInNjaGVtZSBtdXN0IG5vdCBiZSBhbiBlbXB0eSBzdHJpbmcuXCIpO2xldCBhPXFyLmdldEluc3RhbmNlKCk7QShhLm1hbmFnZXJzW3RdPT1udWxsLCgpPT5gQSBtb2RlbCBzdG9yZSBtYW5hZ2VyIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3Igc2NoZW1lICcke3R9Jy5gKSxhLm1hbmFnZXJzW3RdPW59c3RhdGljIGdldE1hbmFnZXIodCl7bGV0IG49cXIuZ2V0SW5zdGFuY2UoKS5tYW5hZ2Vyc1t0XTtpZihuPT1udWxsKXRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgbW9kZWwgbWFuYWdlciBmb3Igc2NoZW1lICcke3R9J2ApO3JldHVybiBufXN0YXRpYyBnZXRTY2hlbWVzKCl7cmV0dXJuIE9iamVjdC5rZXlzKHFyLmdldEluc3RhbmNlKCkubWFuYWdlcnMpfX07ZnVuY3Rpb24gUmgoZSl7aWYoZS5pbmRleE9mKF9sKT09PS0xKXRocm93IG5ldyBFcnJvcihgVGhlIHVybCBzdHJpbmcgcHJvdmlkZWQgZG9lcyBub3QgY29udGFpbiBhIHNjaGVtZS4gU3VwcG9ydGVkIHNjaGVtZXMgYXJlOiAke3VzLmdldFNjaGVtZXMoKS5qb2luKFwiLFwiKX1gKTtyZXR1cm57c2NoZW1lOmUuc3BsaXQoX2wpWzBdLHBhdGg6ZS5zcGxpdChfbClbMV19fWFzeW5jIGZ1bmN0aW9uIHhOKGUsdCxuPSExKXtBKGUhPT10LCgpPT5gT2xkIHBhdGggYW5kIG5ldyBwYXRoIGFyZSB0aGUgc2FtZTogJyR7ZX0nYCk7bGV0IGE9Z2EuZ2V0TG9hZEhhbmRsZXJzKGUpO0EoYS5sZW5ndGg+MCwoKT0+YENvcHlpbmcgZmFpbGVkIGJlY2F1c2Ugbm8gbG9hZCBoYW5kbGVyIGlzIGZvdW5kIGZvciBzb3VyY2UgVVJMICR7ZX0uYCksQShhLmxlbmd0aDwyLCgpPT5gQ29weWluZyBmYWlsZWQgYmVjYXVzZSBtb3JlIHRoYW4gb25lICgke2EubGVuZ3RofSkgbG9hZCBoYW5kbGVycyBmb3Igc291cmNlIFVSTCAke2V9LmApO2xldCByPWFbMF0scz1nYS5nZXRTYXZlSGFuZGxlcnModCk7QShzLmxlbmd0aD4wLCgpPT5gQ29weWluZyBmYWlsZWQgYmVjYXVzZSBubyBzYXZlIGhhbmRsZXIgaXMgZm91bmQgZm9yIGRlc3RpbmF0aW9uIFVSTCAke3R9LmApLEEocy5sZW5ndGg8MiwoKT0+YENvcHlpbmcgZmFpbGVkIGJlY2F1c2UgbW9yZSB0aGFuIG9uZSAoJHthLmxlbmd0aH0pIHNhdmUgaGFuZGxlcnMgZm9yIGRlc3RpbmF0aW9uIFVSTCAke3R9LmApO2xldCBpPXNbMF0sbz1SaChlKS5zY2hlbWUsbD1SaChlKS5wYXRoLHU9bz09PVJoKGUpLnNjaGVtZSxwPWF3YWl0IHIubG9hZCgpO24mJnUmJmF3YWl0IHVzLmdldE1hbmFnZXIobykucmVtb3ZlTW9kZWwobCk7bGV0IGQ9YXdhaXQgaS5zYXZlKHApO3JldHVybiBuJiYhdSYmYXdhaXQgdXMuZ2V0TWFuYWdlcihvKS5yZW1vdmVNb2RlbChsKSxkLm1vZGVsQXJ0aWZhY3RzSW5mb31hc3luYyBmdW5jdGlvbiBETygpe2xldCBlPXVzLmdldFNjaGVtZXMoKSx0PXt9O2ZvcihsZXQgbiBvZiBlKXtsZXQgYT1hd2FpdCB1cy5nZXRNYW5hZ2VyKG4pLmxpc3RNb2RlbHMoKTtmb3IobGV0IHIgaW4gYSl7bGV0IHM9bitfbCtyO3Rbc109YVtyXX19cmV0dXJuIHR9YXN5bmMgZnVuY3Rpb24gUk8oZSl7bGV0IHQ9UmgoZSk7cmV0dXJuIHVzLmdldE1hbmFnZXIodC5zY2hlbWUpLnJlbW92ZU1vZGVsKHQucGF0aCl9YXN5bmMgZnVuY3Rpb24gTU8oZSx0KXtyZXR1cm4geE4oZSx0LCExKX1hc3luYyBmdW5jdGlvbiBPTyhlLHQpe3JldHVybiB4TihlLHQsITApfXZhciBQTz1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMubWVzc2FnZU5hbWU9XCJzZXRUaW1lb3V0Q3VzdG9tXCIsdGhpcy5mdW5jdGlvblJlZnM9W10sdGhpcy5oYW5kbGVkTWVzc2FnZUNvdW50PTAsdGhpcy5oYXNFdmVudExpc3RlbmVyPSExfWZldGNoKGUsdCl7cmV0dXJuIGZldGNoKGUsdCl9bm93KCl7cmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpfWVuY29kZShlLHQpe2lmKHQhPT1cInV0Zi04XCImJnQhPT1cInV0ZjhcIil0aHJvdyBuZXcgRXJyb3IoYEJyb3dzZXIncyBlbmNvZGVyIG9ubHkgc3VwcG9ydHMgdXRmLTgsIGJ1dCBnb3QgJHt0fWApO3JldHVybiB0aGlzLnRleHRFbmNvZGVyPT1udWxsJiYodGhpcy50ZXh0RW5jb2Rlcj1uZXcgVGV4dEVuY29kZXIpLHRoaXMudGV4dEVuY29kZXIuZW5jb2RlKGUpfWRlY29kZShlLHQpe3JldHVybiBuZXcgVGV4dERlY29kZXIodCkuZGVjb2RlKGUpfXNldFRpbWVvdXRDdXN0b20oZSx0KXtpZih0eXBlb2Ygd2luZG93PT1cInVuZGVmaW5lZFwifHwhRygpLmdldEJvb2woXCJVU0VfU0VUVElNRU9VVENVU1RPTVwiKSl7c2V0VGltZW91dChlLHQpO3JldHVybn10aGlzLmZ1bmN0aW9uUmVmcy5wdXNoKGUpLHNldFRpbWVvdXQoKCk9Pnt3aW5kb3cucG9zdE1lc3NhZ2Uoe25hbWU6dGhpcy5tZXNzYWdlTmFtZSxpbmRleDp0aGlzLmZ1bmN0aW9uUmVmcy5sZW5ndGgtMX0sXCIqXCIpfSx0KSx0aGlzLmhhc0V2ZW50TGlzdGVuZXJ8fCh0aGlzLmhhc0V2ZW50TGlzdGVuZXI9ITAsd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsbj0+e2lmKG4uc291cmNlPT09d2luZG93JiZuLmRhdGEubmFtZT09PXRoaXMubWVzc2FnZU5hbWUpe24uc3RvcFByb3BhZ2F0aW9uKCk7bGV0IGE9dGhpcy5mdW5jdGlvblJlZnNbbi5kYXRhLmluZGV4XTthKCksdGhpcy5oYW5kbGVkTWVzc2FnZUNvdW50KyssdGhpcy5oYW5kbGVkTWVzc2FnZUNvdW50PT09dGhpcy5mdW5jdGlvblJlZnMubGVuZ3RoJiYodGhpcy5mdW5jdGlvblJlZnM9W10sdGhpcy5oYW5kbGVkTWVzc2FnZUNvdW50PTApfX0sITApKX1pc1R5cGVkQXJyYXkoZSl7cmV0dXJuIFhTKGUpfX07aWYoRygpLmdldChcIklTX0JST1dTRVJcIikpe0coKS5zZXRQbGF0Zm9ybShcImJyb3dzZXJcIixuZXcgUE8pO3RyeXt1cy5yZWdpc3Rlck1hbmFnZXIoY2kuVVJMX1NDSEVNRSxuZXcgJE8pfWNhdGNoKGUpe310cnl7dXMucmVnaXN0ZXJNYW5hZ2VyKHBpLlVSTF9TQ0hFTUUsbmV3IFNPKX1jYXRjaChlKXt9fXZhciBMTz17aW1wb3J0RmV0Y2g6KCk9Pl9SKCl9LG94LHpPPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy51dGlsPUFSKCksdGhpcy50ZXh0RW5jb2Rlcj1uZXcgdGhpcy51dGlsLlRleHRFbmNvZGVyfWZldGNoKGUsdCl7cmV0dXJuIEcoKS5nbG9iYWwuZmV0Y2ghPW51bGw/RygpLmdsb2JhbC5mZXRjaChlLHQpOihveD09bnVsbCYmKG94PUxPLmltcG9ydEZldGNoKCkpLG94KGUsdCkpfW5vdygpe2xldCBlPXByb2Nlc3MuaHJ0aW1lKCk7cmV0dXJuIGVbMF0qMWUzK2VbMV0vMWU2fWVuY29kZShlLHQpe2lmKHQhPT1cInV0Zi04XCImJnQhPT1cInV0ZjhcIil0aHJvdyBuZXcgRXJyb3IoYE5vZGUgYnVpbHQtaW4gZW5jb2RlciBvbmx5IHN1cHBvcnRzIHV0Zi04LCBidXQgZ290ICR7dH1gKTtyZXR1cm4gdGhpcy50ZXh0RW5jb2Rlci5lbmNvZGUoZSl9ZGVjb2RlKGUsdCl7cmV0dXJuIGUubGVuZ3RoPT09MD9cIlwiOm5ldyB0aGlzLnV0aWwuVGV4dERlY29kZXIodCkuZGVjb2RlKGUpfWlzVHlwZWRBcnJheShlKXtyZXR1cm4gdGhpcy51dGlsLnR5cGVzLmlzRmxvYXQzMkFycmF5KGUpfHx0aGlzLnV0aWwudHlwZXMuaXNJbnQzMkFycmF5KGUpfHx0aGlzLnV0aWwudHlwZXMuaXNVaW50OEFycmF5KGUpfHx0aGlzLnV0aWwudHlwZXMuaXNVaW50OENsYW1wZWRBcnJheShlKX19O0coKS5nZXQoXCJJU19OT0RFXCIpJiYhRygpLmdldChcIklTX0JST1dTRVJcIikmJkcoKS5zZXRQbGF0Zm9ybShcIm5vZGVcIixuZXcgek8pO2Z1bmN0aW9uIE9lKGUsdD1cImZsb2F0MzJcIixuKXtyZXR1cm4gdD10fHxcImZsb2F0MzJcIixuYShlKSxuZXcgV3QoZSx0LG4pfWZ1bmN0aW9uIFdPKGUsdCl7bGV0IG49RShlLFwieFwiLFwiY2FzdFwiKTtpZighTFModCkpdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY2FzdCB0byB1bmtub3duIGR0eXBlICR7dH1gKTtpZih0PT09XCJzdHJpbmdcIiYmbi5kdHlwZSE9PVwic3RyaW5nXCJ8fHQhPT1cInN0cmluZ1wiJiZuLmR0eXBlPT09XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IHN0cmluZ3MgY2FuIGJlIGNhc3RlZCB0byBzdHJpbmdzXCIpO2xldCBhPXt4Om59LHI9e2R0eXBlOnR9O3JldHVybiBQLnJ1bktlcm5lbChNaSxhLHIpfXZhciByZT1MKHtjYXN0XzpXT30pO2Z1bmN0aW9uIEJPKGUpe2xldCB0PXt4OkUoZSxcInhcIixcImNsb25lXCIsXCJzdHJpbmdfb3JfbnVtZXJpY1wiKX07cmV0dXJuIFAucnVuS2VybmVsKGVvLHQpfXZhciBzcj1MKHtjbG9uZV86Qk99KTtmdW5jdGlvbiBPdihlLHQ9ITEpe2NvbnNvbGUubG9nKGUudG9TdHJpbmcodCkpfWFOKCk7dmFyIFZPPXtidWZmZXI6T2UsY2FzdDpyZSxjbG9uZTpzcixwcmludDpPdn07UE0oVk8pO2Z1bmN0aW9uIFVPKGUsdCl7bGV0IG49RShlLFwiYVwiLFwiYWRkXCIpLGE9RSh0LFwiYlwiLFwiYWRkXCIpO1tuLGFdPV90KG4sYSk7bGV0IHI9e2E6bixiOmF9O3JldHVybiBQLnJ1bktlcm5lbCh2cyxyKX12YXIgWD1MKHthZGRfOlVPfSk7ZnVuY3Rpb24gR08oZSx0KXtsZXQgbj1FKGUsXCJhXCIsXCJmbG9vckRpdlwiKSxhPUUodCxcImJcIixcImZsb29yRGl2XCIpO1tuLGFdPV90KG4sYSk7bGV0IHI9e2E6bixiOmF9O3JldHVybiBQLnJ1bktlcm5lbChaaSxyKX12YXIgUG09TCh7Zmxvb3JEaXZfOkdPfSk7ZnVuY3Rpb24gSE8oZSx0KXtsZXQgbj1FKGUsXCJhXCIsXCJkaXZcIiksYT1FKHQsXCJiXCIsXCJkaXZcIik7aWYoW24sYV09X3QobixhKSxuLmR0eXBlPT09XCJpbnQzMlwiJiZhLmR0eXBlPT09XCJpbnQzMlwiKXJldHVybiBQbShuLGEpO2xldCByPXthOm4sYjphfSxzPXt9O3JldHVybiBQLnJ1bktlcm5lbChIaSxyLHMpfXZhciBoZT1MKHtkaXZfOkhPfSk7ZnVuY3Rpb24gak8oZSx0KXtsZXQgbj1FKGUsXCJhXCIsXCJtdWxcIiksYT1FKHQsXCJiXCIsXCJtdWxcIik7W24sYV09X3QobixhKTtsZXQgcj17YTpuLGI6YX07cmV0dXJuIFAucnVuS2VybmVsKGJvLHIpfXZhciB6PUwoe211bF86ak99KTtmdW5jdGlvbiBxTyhlKXtsZXQgdD1FKGUsXCJ4XCIsXCJhYnNcIik7aWYodC5kdHlwZT09PVwiY29tcGxleDY0XCIpe2xldCBuPXt4OnR9O3JldHVybiBQLnJ1bktlcm5lbChPYyxuKX1lbHNle2xldCBuPXt4OnR9O3JldHVybiBQLnJ1bktlcm5lbChZbCxuKX19dmFyIEx0PUwoe2Fic186cU99KTtmdW5jdGlvbiBLTyhlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJhY29zXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoTmksdCl9dmFyIFB2PUwoe2Fjb3NfOktPfSk7ZnVuY3Rpb24gWE8oZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwiYWNvc2hcIil9O3JldHVybiBQLnJ1bktlcm5lbChUaSx0KX12YXIgTHY9TCh7YWNvc2hfOlhPfSk7ZnVuY3Rpb24gWU8oZSl7QShBcnJheS5pc0FycmF5KGUpLCgpPT5cIlRoZSBhcmd1bWVudCBwYXNzZWQgdG8gdGYuYWRkTigpIG11c3QgYmUgYSBsaXN0IG9mIHRlbnNvcnNcIiksQShlLmxlbmd0aD49MSwoKT0+YE11c3QgcGFzcyBhdCBsZWFzdCBvbmUgdGVuc29yIHRvIHRmLmFkZE4oKSwgYnV0IGdvdCAke2UubGVuZ3RofWApO2xldCB0PWUubWFwKChyLHMpPT5FKHIsYHRlbnNvcnMke3N9YCxcImFkZE5cIikpLG49dFswXTt0LmZvckVhY2gocj0+e2lmKHIuZHR5cGUhPT1uLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIkFsbCB0ZW5zb3JzIHBhc3NlZCB0byB0Zi5hZGROKCkgbXVzdCBoYXZlIHRoZSBzYW1lIGR0eXBlXCIpfSksdC5mb3JFYWNoKHI9PntpZighQXIoci5zaGFwZSxuLnNoYXBlKSl0aHJvdyBuZXcgRXJyb3IoXCJBbGwgdGVuc29ycyBwYXNzZWQgdG8gdGYuYWRkTigpIG11c3QgaGF2ZSB0aGUgc2FtZSBzaGFwZVwiKX0pO2xldCBhPXQ7cmV0dXJuIFAucnVuS2VybmVsKENpLGEpfXZhciB2Tj1MKHthZGROXzpZT30pO2Z1bmN0aW9uIFpPKGUsdD1udWxsLG49ITEpe2xldCBhPXt4OkUoZSxcInhcIixcImFsbFwiLFwiYm9vbFwiKX0scj17YXhpczp0LGtlZXBEaW1zOm59O3JldHVybiBQLnJ1bktlcm5lbChabCxhLHIpfXZhciBMbT1MKHthbGxfOlpPfSk7ZnVuY3Rpb24gSk8oZSx0PW51bGwsbj0hMSl7bGV0IGE9e3g6RShlLFwieFwiLFwiYW55XCIsXCJib29sXCIpfSxyPXtheGlzOnQsa2VlcERpbXM6bn07cmV0dXJuIFAucnVuS2VybmVsKEpsLGEscil9dmFyIHljPUwoe2FueV86Sk99KTtmdW5jdGlvbiBRTyhlLHQ9MCl7bGV0IG49e3g6RShlLFwieFwiLFwiYXJnTWF4XCIpfSxhPXtheGlzOnR9O3JldHVybiBQLnJ1bktlcm5lbChRbCxuLGEpfXZhciBkaT1MKHthcmdNYXhfOlFPfSk7ZnVuY3Rpb24gZVAoZSx0PTApe2xldCBuPXt4OkUoZSxcInhcIixcImFyZ01pblwiKX0sYT17YXhpczp0fTtyZXR1cm4gUC5ydW5LZXJuZWwoZXUsbixhKX12YXIgenY9TCh7YXJnTWluXzplUH0pO2Z1bmN0aW9uIHRQKGUpe2xldCB0PXt4OkUoZSxcInhcIixcImFzaW5cIil9O3JldHVybiBQLnJ1bktlcm5lbChFaSx0KX12YXIgV3Y9TCh7YXNpbl86dFB9KTtmdW5jdGlvbiBuUChlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJhc2luaFwiKX07cmV0dXJuIFAucnVuS2VybmVsKF9pLHQpfXZhciBCdj1MKHthc2luaF86blB9KTtmdW5jdGlvbiBhUChlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJhdGFuXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoQWksdCl9dmFyIFZ2PUwoe2F0YW5fOmFQfSk7ZnVuY3Rpb24gclAoZSx0KXtsZXQgbj1FKGUsXCJhXCIsXCJhdGFuMlwiKSxhPUUodCxcImJcIixcImF0YW4yXCIpO1tuLGFdPV90KG4sYSk7bGV0IHI9e2E6bixiOmF9O3JldHVybiBQLnJ1bktlcm5lbCgkaSxyKX12YXIgVXY9TCh7YXRhbjJfOnJQfSk7ZnVuY3Rpb24gc1AoZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwiYXRhbmhcIil9O3JldHVybiBQLnJ1bktlcm5lbChGaSx0KX12YXIgR3Y9TCh7YXRhbmhfOnNQfSk7ZnVuY3Rpb24gaVAoZSx0LG4sYSxyPVwiTkhXQ1wiLHMpe2xldCBpPWVbM10sbz1bLi4udCxpXSxsPUlOKHIpO3JldHVybiBzZChlLG8sbixzLGEsbnVsbCxudWxsLGwpfWZ1bmN0aW9uIHdOKGUsdCxuLGEscixzLGk9XCJjaGFubmVsc0xhc3RcIil7bGV0W28sbF09eGModCksdTtpZihpPT09XCJjaGFubmVsc0xhc3RcIil1PVtvLGwsZVszXSxlWzNdXTtlbHNlIGlmKGk9PT1cImNoYW5uZWxzRmlyc3RcIil1PVtvLGwsZVsxXSxlWzFdXTtlbHNlIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhRm9ybWF0ICR7aX1gKTtyZXR1cm4gc2QoZSx1LG4sYSxyLHMsITEsaSl9ZnVuY3Rpb24gb1AoZSx0LG4sYSxyLHMsaT1cIk5ESFdDXCIpe2xldFtvLGwsdV09RHgodCkscCxkO2lmKGk9PT1cIk5ESFdDXCIpZD1cImNoYW5uZWxzTGFzdFwiLHA9W28sbCx1LGVbNF0sZVs0XV07ZWxzZSBpZihpPT09XCJOQ0RIV1wiKWQ9XCJjaGFubmVsc0ZpcnN0XCIscD1bbyxsLHUsZVsxXSxlWzFdXTtlbHNlIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhRm9ybWF0ICR7aX1gKTtyZXR1cm4ga04oZSxwLG4sYSxyLCExLGQscyl9ZnVuY3Rpb24gc2QoZSx0LG4sYSxyLHMsaT0hMSxvPVwiY2hhbm5lbHNMYXN0XCIpe2xldFtsLHUscCxkXT1bLTEsLTEsLTEsLTFdO2lmKG89PT1cImNoYW5uZWxzTGFzdFwiKVtsLHUscCxkXT1lO2Vsc2UgaWYobz09PVwiY2hhbm5lbHNGaXJzdFwiKVtsLGQsdSxwXT1lO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGFGb3JtYXQgJHtvfWApO2xldFtjLGgsLG1dPXQsW2YsZ109eGMobiksW2IseV09eGMoYSkseD1BbChjLGIpLHY9QWwoaCx5KSx7cGFkSW5mbzpJLG91dEhlaWdodDpOLG91dFdpZHRoOkN9PXBQKHIsdSxwLGYsZyx4LHYscyxvKSxfPWk/bSpkOm0sRjtyZXR1cm4gbz09PVwiY2hhbm5lbHNGaXJzdFwiP0Y9W2wsXyxOLENdOm89PT1cImNoYW5uZWxzTGFzdFwiJiYoRj1bbCxOLEMsX10pLHtiYXRjaFNpemU6bCxkYXRhRm9ybWF0Om8saW5IZWlnaHQ6dSxpbldpZHRoOnAsaW5DaGFubmVsczpkLG91dEhlaWdodDpOLG91dFdpZHRoOkMsb3V0Q2hhbm5lbHM6XyxwYWRJbmZvOkksc3RyaWRlSGVpZ2h0OmYsc3RyaWRlV2lkdGg6ZyxmaWx0ZXJIZWlnaHQ6YyxmaWx0ZXJXaWR0aDpoLGVmZmVjdGl2ZUZpbHRlckhlaWdodDp4LGVmZmVjdGl2ZUZpbHRlcldpZHRoOnYsZGlsYXRpb25IZWlnaHQ6YixkaWxhdGlvbldpZHRoOnksaW5TaGFwZTplLG91dFNoYXBlOkYsZmlsdGVyU2hhcGU6dH19ZnVuY3Rpb24ga04oZSx0LG4sYSxyLHM9ITEsaT1cImNoYW5uZWxzTGFzdFwiLG8pe2xldFtsLHUscCxkLGNdPVstMSwtMSwtMSwtMSwtMV07aWYoaT09PVwiY2hhbm5lbHNMYXN0XCIpW2wsdSxwLGQsY109ZTtlbHNlIGlmKGk9PT1cImNoYW5uZWxzRmlyc3RcIilbbCxjLHUscCxkXT1lO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGFGb3JtYXQgJHtpfWApO2xldFtoLG0sZiwsZ109dCxbYix5LHhdPUR4KG4pLFt2LEksTl09RHgoYSksQz1BbChoLHYpLF89QWwobSxJKSxGPUFsKGYsTikse3BhZEluZm86RCxvdXREZXB0aDokLG91dEhlaWdodDpTLG91dFdpZHRoOk19PWNQKHIsdSxwLGQsYix5LHgsQyxfLEYsbyksQj1zP2cqYzpnLFU7cmV0dXJuIGk9PT1cImNoYW5uZWxzRmlyc3RcIj9VPVtsLEIsJCxTLE1dOmk9PT1cImNoYW5uZWxzTGFzdFwiJiYoVT1bbCwkLFMsTSxCXSkse2JhdGNoU2l6ZTpsLGRhdGFGb3JtYXQ6aSxpbkRlcHRoOnUsaW5IZWlnaHQ6cCxpbldpZHRoOmQsaW5DaGFubmVsczpjLG91dERlcHRoOiQsb3V0SGVpZ2h0OlMsb3V0V2lkdGg6TSxvdXRDaGFubmVsczpCLHBhZEluZm86RCxzdHJpZGVEZXB0aDpiLHN0cmlkZUhlaWdodDp5LHN0cmlkZVdpZHRoOngsZmlsdGVyRGVwdGg6aCxmaWx0ZXJIZWlnaHQ6bSxmaWx0ZXJXaWR0aDpmLGVmZmVjdGl2ZUZpbHRlckRlcHRoOkMsZWZmZWN0aXZlRmlsdGVySGVpZ2h0Ol8sZWZmZWN0aXZlRmlsdGVyV2lkdGg6RixkaWxhdGlvbkRlcHRoOnYsZGlsYXRpb25IZWlnaHQ6SSxkaWxhdGlvbldpZHRoOk4saW5TaGFwZTplLG91dFNoYXBlOlUsZmlsdGVyU2hhcGU6dH19ZnVuY3Rpb24gbFAoZSx0LG4sYSxyKXthPT1udWxsJiYoYT1IdihlLHQsbikpO2xldCBzPWVbMF0saT1lWzFdLG89dmMoKHMtdCsyKmEpL24rMSxyKSxsPXZjKChpLXQrMiphKS9uKzEscik7cmV0dXJuW28sbF19ZnVuY3Rpb24gdVAoZSx0LG4sYSxyLHMpe3I9PW51bGwmJihyPUh2KGUsdFswXSxhWzBdKSk7bGV0IGk9WzAsMCwwLG5dO2ZvcihsZXQgbz0wO288MztvKyspZVtvXSsyKnI+PXRbb10mJihpW29dPXZjKChlW29dLXRbb10rMipyKS9hW29dKzEscykpO3JldHVybiBpfWZ1bmN0aW9uIEh2KGUsdCxuLGE9MSl7bGV0IHI9QWwodCxhKTtyZXR1cm4gTWF0aC5mbG9vcigoZVswXSoobi0xKS1uK3IpLzIpfWZ1bmN0aW9uIHhjKGUpe3JldHVybiB0eXBlb2YgZT09XCJudW1iZXJcIj9bZSxlLGVdOmUubGVuZ3RoPT09Mj9bZVswXSxlWzFdLDFdOmV9ZnVuY3Rpb24gRHgoZSl7cmV0dXJuIHR5cGVvZiBlPT1cIm51bWJlclwiP1tlLGUsZV06ZX1mdW5jdGlvbiBBbChlLHQpe3JldHVybiB0PD0xP2U6ZSsoZS0xKSoodC0xKX1mdW5jdGlvbiBwUChlLHQsbixhLHIscyxpLG8sbCl7bGV0IHUscCxkO2lmKHR5cGVvZiBlPT1cIm51bWJlclwiKXt1PXt0b3A6ZSxib3R0b206ZSxsZWZ0OmUscmlnaHQ6ZSx0eXBlOmU9PT0wP1wiVkFMSURcIjpcIk5VTUJFUlwifTtsZXQgYz1sUChbdCxuXSxzLGEsZSxvKTtwPWNbMF0sZD1jWzFdfWVsc2UgaWYoZT09PVwic2FtZVwiKXtwPU1hdGguY2VpbCh0L2EpLGQ9TWF0aC5jZWlsKG4vcik7bGV0IGM9TWF0aC5tYXgoMCwocC0xKSphK3MtdCksaD1NYXRoLm1heCgwLChkLTEpKnIraS1uKSxtPU1hdGguZmxvb3IoYy8yKSxmPWMtbSxnPU1hdGguZmxvb3IoaC8yKSxiPWgtZzt1PXt0b3A6bSxib3R0b206ZixsZWZ0OmcscmlnaHQ6Yix0eXBlOlwiU0FNRVwifX1lbHNlIGlmKGU9PT1cInZhbGlkXCIpdT17dG9wOjAsYm90dG9tOjAsbGVmdDowLHJpZ2h0OjAsdHlwZTpcIlZBTElEXCJ9LHA9TWF0aC5jZWlsKCh0LXMrMSkvYSksZD1NYXRoLmNlaWwoKG4taSsxKS9yKTtlbHNlIGlmKHR5cGVvZiBlPT1cIm9iamVjdFwiKXtsZXQgYz1sPT09XCJjaGFubmVsc0xhc3RcIj9lWzFdWzBdOmVbMl1bMF0saD1sPT09XCJjaGFubmVsc0xhc3RcIj9lWzFdWzFdOmVbMl1bMV0sbT1sPT09XCJjaGFubmVsc0xhc3RcIj9lWzJdWzBdOmVbM11bMF0sZj1sPT09XCJjaGFubmVsc0xhc3RcIj9lWzJdWzFdOmVbM11bMV07dT17dG9wOmMsYm90dG9tOmgsbGVmdDptLHJpZ2h0OmYsdHlwZTpjPT09MCYmaD09PTAmJm09PT0wJiZmPT09MD9cIlZBTElEXCI6XCJFWFBMSUNJVFwifSxwPXZjKCh0LXMrYytoKS9hKzEsbyksZD12Yygobi1pK20rZikvcisxLG8pfWVsc2UgdGhyb3cgRXJyb3IoYFVua25vd24gcGFkZGluZyBwYXJhbWV0ZXI6ICR7ZX1gKTtyZXR1cm57cGFkSW5mbzp1LG91dEhlaWdodDpwLG91dFdpZHRoOmR9fWZ1bmN0aW9uIGNQKGUsdCxuLGEscixzLGksbyxsLHUscCl7bGV0IGQsYyxoLG07aWYoZT09PVwidmFsaWRcIiYmKGU9MCksdHlwZW9mIGU9PVwibnVtYmVyXCIpe2Q9e3RvcDplLGJvdHRvbTplLGxlZnQ6ZSxyaWdodDplLGZyb250OmUsYmFjazplLHR5cGU6ZT09PTA/XCJWQUxJRFwiOlwiTlVNQkVSXCJ9O2xldCBmPXVQKFt0LG4sYSwxXSxbbyxsLHVdLDEsW3IscyxpXSxlLHApO2M9ZlswXSxoPWZbMV0sbT1mWzJdfWVsc2UgaWYoZT09PVwic2FtZVwiKXtjPU1hdGguY2VpbCh0L3IpLGg9TWF0aC5jZWlsKG4vcyksbT1NYXRoLmNlaWwoYS9pKTtsZXQgZj0oYy0xKSpyK28tdCxnPShoLTEpKnMrbC1uLGI9KG0tMSkqaSt1LWEseT1NYXRoLmZsb29yKGYvMikseD1mLXksdj1NYXRoLmZsb29yKGcvMiksST1nLXYsTj1NYXRoLmZsb29yKGIvMiksQz1iLU47ZD17dG9wOnYsYm90dG9tOkksbGVmdDpOLHJpZ2h0OkMsZnJvbnQ6eSxiYWNrOngsdHlwZTpcIlNBTUVcIn19ZWxzZSB0aHJvdyBFcnJvcihgVW5rbm93biBwYWRkaW5nIHBhcmFtZXRlcjogJHtlfWApO3JldHVybntwYWRJbmZvOmQsb3V0RGVwdGg6YyxvdXRIZWlnaHQ6aCxvdXRXaWR0aDptfX1mdW5jdGlvbiB2YyhlLHQpe2lmKCF0KXJldHVybiBNYXRoLnRydW5jKGUpO3N3aXRjaCh0KXtjYXNlXCJyb3VuZFwiOnJldHVybiBNYXRoLnJvdW5kKGUpO2Nhc2VcImNlaWxcIjpyZXR1cm4gTWF0aC5jZWlsKGUpO2Nhc2VcImZsb29yXCI6cmV0dXJuIE1hdGguZmxvb3IoZSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcm91bmRpbmdNb2RlICR7dH1gKX19ZnVuY3Rpb24gcHMoZSl7bGV0W3QsbixhXT14YyhlKTtyZXR1cm4gdD09PTEmJm49PT0xJiZhPT09MX1mdW5jdGlvbiBkcihlLHQpe3JldHVybiBwcyhlKXx8cHModCl9ZnVuY3Rpb24gaGkoZSl7cmV0dXJuIHhjKGUpLmV2ZXJ5KHQ9PnQ+MCl9ZnVuY3Rpb24gSU4oZSl7aWYoZT09PVwiTkhXQ1wiKXJldHVyblwiY2hhbm5lbHNMYXN0XCI7aWYoZT09PVwiTkNIV1wiKXJldHVyblwiY2hhbm5lbHNGaXJzdFwiO3Rocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhRm9ybWF0ICR7ZX1gKX1mdW5jdGlvbiBUbihlLHQsbil7aWYobiE9bnVsbCl7aWYodHlwZW9mIHQ9PVwic3RyaW5nXCIpdGhyb3cgRXJyb3IoYEVycm9yIGluICR7ZX06IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZyBkaW1Sb3VuZGluZ01vZGUgJHtufSBidXQgZ290IHBhZCAke3R9LmApO2lmKHR5cGVvZiB0PT1cIm51bWJlclwiKUEoJGwodCksKCk9PmBFcnJvciBpbiAke2V9OiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcgZGltUm91bmRpbmdNb2RlICR7bn0gYnV0IGdvdCBwYWQgJHt0fS5gKTtlbHNlIGlmKHR5cGVvZiB0PT1cIm9iamVjdFwiKXQuZm9yRWFjaChhPT57YS5mb3JFYWNoKHI9PntBKCRsKHIpLCgpPT5gRXJyb3IgaW4gJHtlfTogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nIGRpbVJvdW5kaW5nTW9kZSAke259IGJ1dCBnb3QgcGFkICR7cn0uYCl9KX0pO2Vsc2UgdGhyb3cgRXJyb3IoYEVycm9yIGluICR7ZX06IFVua25vd24gcGFkZGluZyBwYXJhbWV0ZXI6ICR7dH1gKX19ZnVuY3Rpb24gZFAoZSx0KXtsZXQgbj17eDpFKGUsXCJ4XCIsXCJyZXNoYXBlXCIsXCJzdHJpbmdfb3JfbnVtZXJpY1wiKX0sYT17c2hhcGU6dH07cmV0dXJuIFAucnVuS2VybmVsKFJ1LG4sYSl9dmFyIFc9TCh7cmVzaGFwZV86ZFB9KTtmdW5jdGlvbiBoUChlLHQsbixhLHIpe2xldCBzPUUoZSxcInhcIixcImF2Z1Bvb2xcIixcImZsb2F0MzJcIiksaT0xO0EoZHIobixpKSwoKT0+YEVycm9yIGluIGF2Z1Bvb2w6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzICR7bn0gYW5kIGRpbGF0aW9ucyAnJHtpfSdgKTtsZXQgbz1zLGw9ITE7cy5yYW5rPT09MyYmKGw9ITAsbz1XKHMsWzEscy5zaGFwZVswXSxzLnNoYXBlWzFdLHMuc2hhcGVbMl1dKSksQShvLnJhbms9PT00LCgpPT5gRXJyb3IgaW4gYXZnUG9vbDogeCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgJHtvLnJhbmt9LmApLFRuKFwiYXZnUG9vbFwiLGEscik7bGV0IHU9e3g6b30scD17ZmlsdGVyU2l6ZTp0LHN0cmlkZXM6bixwYWQ6YSxkaW1Sb3VuZGluZ01vZGU6cn0sZD1QLnJ1bktlcm5lbChEaSx1LHApO3JldHVybiBkPXJlKGQscy5kdHlwZSksbD9XKGQsW2Quc2hhcGVbMV0sZC5zaGFwZVsyXSxkLnNoYXBlWzNdXSk6ZH12YXIgeWE9TCh7YXZnUG9vbF86aFB9KTtmdW5jdGlvbiBtUChlLHQsbixhLHIscz1cIk5ESFdDXCIpe2xldCBpPUUoZSxcInhcIixcImF2Z1Bvb2wzZFwiLFwiZmxvYXQzMlwiKSxvPWksbD0hMTtpLnJhbms9PT00JiYobD0hMCxvPVcoaSxbMSxpLnNoYXBlWzBdLGkuc2hhcGVbMV0saS5zaGFwZVsyXSxpLnNoYXBlWzNdXSkpLEEoby5yYW5rPT09NSwoKT0+YEVycm9yIGluIGF2Z1Bvb2wzZDogeCBtdXN0IGJlIHJhbmsgNSBidXQgZ290IHJhbmsgJHtvLnJhbmt9LmApLEEocz09PVwiTkRIV0NcIiwoKT0+YEVycm9yIGluIGF2Z1Bvb2wzZDogT25seSBOREhXQyBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLCBidXQgZ290IGRhdGFGb3JtYXQgb2YgJHtzfWApLEEodHlwZW9mIG49PVwibnVtYmVyXCImJm4+MHx8QXJyYXkuaXNBcnJheShuKSYmblswXT4wJiZuWzFdPjAmJm5bMl0+MCwoKT0+YEVycm9yIGluIGF2Z1Bvb2wzZDogU3RyaWRlIG11c3QgYmUgPiAwLCBidXQgZ290ICcke259J2ApLFRuKFwiYXZnUG9vbDNkXCIsYSxyKTtsZXQgdT17eDpvfSxwPXtmaWx0ZXJTaXplOnQsc3RyaWRlczpuLHBhZDphLGRpbVJvdW5kaW5nTW9kZTpyLGRhdGFGb3JtYXQ6c30sZD1QLnJ1bktlcm5lbCh0dSx1LHApO3JldHVybiBkPXJlKGQsby5kdHlwZSksbD9XKGQsW2Quc2hhcGVbMV0sZC5zaGFwZVsyXSxkLnNoYXBlWzNdLGQuc2hhcGVbNF1dKTpkfXZhciBqdj1MKHthdmdQb29sM2RfOm1QfSk7ZnVuY3Rpb24gZlAoZSx0PTApe0EoZS5sZW5ndGg+PTEsKCk9PlwiUGFzcyBhdCBsZWFzdCBvbmUgdGVuc29yIHRvIGNvbmNhdFwiKTtsZXQgbj1iYyhlLFwidGVuc29yc1wiLFwiY29uY2F0XCIsXCJzdHJpbmdfb3JfbnVtZXJpY1wiKTtpZihuWzBdLmR0eXBlPT09XCJjb21wbGV4NjRcIiYmbi5mb3JFYWNoKHM9PntpZihzLmR0eXBlIT09XCJjb21wbGV4NjRcIil0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb25jYXRlbmF0ZSBjb21wbGV4NjQgdGVuc29ycyB3aXRoIGEgdGVuc29yXG4gICAgICAgICAgd2l0aCBkdHlwZSAke3MuZHR5cGV9LiBgKX0pLG4ubGVuZ3RoPT09MSlyZXR1cm4gc3IoblswXSk7bGV0IGE9bixyPXtheGlzOnR9O3JldHVybiBQLnJ1bktlcm5lbChzdSxhLHIpfXZhciBldD1MKHtjb25jYXRfOmZQfSk7ZnVuY3Rpb24gZ1AoZSx0LG49ITEsYT0hMSl7bGV0IHI9RShlLFwiYVwiLFwibWF0TXVsXCIpLHM9RSh0LFwiYlwiLFwibWF0TXVsXCIpO1tyLHNdPV90KHIscyk7bGV0IGk9e2E6cixiOnN9LG89e3RyYW5zcG9zZUE6bix0cmFuc3Bvc2VCOmF9O3JldHVybiBQLnJ1bktlcm5lbChSaSxpLG8pfXZhciAkZT1MKHttYXRNdWxfOmdQfSk7ZnVuY3Rpb24gYlAoZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwic2lnbW9pZFwiLFwiZmxvYXQzMlwiKX07cmV0dXJuIFAucnVuS2VybmVsKE1vLHQpfXZhciBoYT1MKHtzaWdtb2lkXzpiUH0pO2Z1bmN0aW9uIHlQKGUsdCxuKXtsZXQgYT1FKGUsXCJ4XCIsXCJzbGljZVwiLFwic3RyaW5nX29yX251bWVyaWNcIik7aWYoYS5yYW5rPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJTbGljaW5nIHNjYWxhciBpcyBub3QgcG9zc2libGVcIik7bGV0IHI9e3g6YX0scz17YmVnaW46dCxzaXplOm59O3JldHVybiBQLnJ1bktlcm5lbChCdSxyLHMpfXZhciBWZT1MKHtzbGljZV86eVB9KTtmdW5jdGlvbiB4UChlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJ0YW5oXCIsXCJmbG9hdDMyXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoVW8sdCl9dmFyIGNzPUwoe3RhbmhfOnhQfSk7ZnVuY3Rpb24gdlAoZSx0LG4sYSxyLHMpe2xldCBpPUUoZSxcImZvcmdldEJpYXNcIixcImJhc2ljTFNUTUNlbGxcIiksbz1FKHQsXCJsc3RtS2VybmVsXCIsXCJiYXNpY0xTVE1DZWxsXCIpLGw9RShuLFwibHN0bUJpYXNcIixcImJhc2ljTFNUTUNlbGxcIiksdT1FKGEsXCJkYXRhXCIsXCJiYXNpY0xTVE1DZWxsXCIpLHA9RShyLFwiY1wiLFwiYmFzaWNMU1RNQ2VsbFwiKSxkPUUocyxcImhcIixcImJhc2ljTFNUTUNlbGxcIiksYz1ldChbdSxkXSwxKSxoPSRlKGMsbyksbT1YKGgsbCksZj1tLnNoYXBlWzBdLGc9bS5zaGFwZVsxXS80LGI9W2YsZ10seT1WZShtLFswLDBdLGIpLHg9VmUobSxbMCxnXSxiKSx2PVZlKG0sWzAsZyoyXSxiKSxJPVZlKG0sWzAsZyozXSxiKSxOPVgoeihoYSh5KSxjcyh4KSkseihwLGhhKFgoaSx2KSkpKSxDPXooY3MoTiksaGEoSSkpO3JldHVybltOLENdfXZhciBTTj1MKHtiYXNpY0xTVE1DZWxsXzp2UH0pO2Z1bmN0aW9uIHdQKGUsdCxuKXtsZXQgYT1FKGUsXCJ4XCIsXCJiYXRjaFRvU3BhY2VORFwiKSxyPXQucmVkdWNlKChvLGwpPT5vKmwpO0EoYS5yYW5rPj0xK3QubGVuZ3RoLCgpPT5gaW5wdXQgcmFuayBpcyAke2EucmFua30gYnV0IHNob3VsZCBiZSA+IHRoYW4gYmxvY2tTaGFwZS5sZW5ndGggJHt0Lmxlbmd0aH1gKSxBKG4ubGVuZ3RoPT09dC5sZW5ndGgsKCk9PmBjcm9wcy5sZW5ndGggaXMgJHtuLmxlbmd0aH0gYnV0IHNob3VsZCBiZSBlcXVhbCB0byBibG9ja1NoYXBlLmxlbmd0aCAgJHt0Lmxlbmd0aH1gKSxBKGEuc2hhcGVbMF0lcj09PTAsKCk9PmBpbnB1dCB0ZW5zb3IgYmF0Y2ggaXMgJHthLnNoYXBlWzBdfSBidXQgaXMgbm90IGRpdmlzaWJsZSBieSB0aGUgcHJvZHVjdCBvZiB0aGUgZWxlbWVudHMgb2YgYmxvY2tTaGFwZSAke3Quam9pbihcIiAqIFwiKX0gPT09ICR7cn1gKTtsZXQgcz17eDphfSxpPXtibG9ja1NoYXBlOnQsY3JvcHM6bn07cmV0dXJuIFAucnVuS2VybmVsKG51LHMsaSl9dmFyIGlkPUwoe2JhdGNoVG9TcGFjZU5EXzp3UH0pO2Z1bmN0aW9uIGtQKGUpe2xldCB0O3JldHVybiBlLnJhbms9PT0wfHxlLnJhbms9PT0xP3Q9VyhlLFsxLDEsMSxlLnNpemVdKTplLnJhbms9PT0yP3Q9VyhlLFsxLDEsZS5zaGFwZVswXSxlLnNoYXBlWzFdXSk6ZS5yYW5rPT09Mz90PVcoZSxbMSxlLnNoYXBlWzBdLGUuc2hhcGVbMV0sZS5zaGFwZVsyXV0pOnQ9ZSx0fWZ1bmN0aW9uIElQKGUsdCxuLGEscixzKXtzPT1udWxsJiYocz0uMDAxKTtsZXQgaT1FKGUsXCJ4XCIsXCJiYXRjaE5vcm1cIiksbz1FKHQsXCJtZWFuXCIsXCJiYXRjaE5vcm1cIiksbD1FKG4sXCJ2YXJpYW5jZVwiLFwiYmF0Y2hOb3JtXCIpLHU7ciE9bnVsbCYmKHU9RShyLFwic2NhbGVcIixcImJhdGNoTm9ybVwiKSk7bGV0IHA7YSE9bnVsbCYmKHA9RShhLFwib2Zmc2V0XCIsXCJiYXRjaE5vcm1cIikpLEEoby5yYW5rPT09bC5yYW5rLCgpPT5cIkJhdGNoIG5vcm1hbGl6YXRpb24gZ3JhZGllbnQgcmVxdWlyZXMgbWVhbiBhbmQgdmFyaWFuY2UgdG8gaGF2ZSBlcXVhbCByYW5rcy5cIiksQShwPT1udWxsfHxvLnJhbms9PT1wLnJhbmssKCk9PlwiQmF0Y2ggbm9ybWFsaXphdGlvbiBncmFkaWVudCByZXF1aXJlcyBtZWFuIGFuZCBvZmZzZXQgdG8gaGF2ZSBlcXVhbCByYW5rcy5cIiksQSh1PT1udWxsfHxvLnJhbms9PT11LnJhbmssKCk9PlwiQmF0Y2ggbm9ybWFsaXphdGlvbiBncmFkaWVudCByZXF1aXJlcyBtZWFuIGFuZCBzY2FsZSB0byBoYXZlIGVxdWFsIHJhbmtzLlwiKTtsZXQgZD17eDprUChpKSxzY2FsZTp1LG9mZnNldDpwLG1lYW46byx2YXJpYW5jZTpsfSxjPXt2YXJpYW5jZUVwc2lsb246c30saD1QLnJ1bktlcm5lbChKaSxkLGMpO3JldHVybiBXKGgsaS5zaGFwZSl9dmFyIE5zPUwoe2JhdGNoTm9ybV86SVB9KTtmdW5jdGlvbiBTUChlLHQsbixhLHIscyl7bGV0IGk9RShlLFwieFwiLFwiYmF0Y2hOb3JtXCIpLG89RSh0LFwibWVhblwiLFwiYmF0Y2hOb3JtXCIpLGw9RShuLFwidmFyaWFuY2VcIixcImJhdGNoTm9ybVwiKSx1O3IhPW51bGwmJih1PUUocixcInNjYWxlXCIsXCJiYXRjaE5vcm1cIikpO2xldCBwO3JldHVybiBhIT1udWxsJiYocD1FKGEsXCJvZmZzZXRcIixcImJhdGNoTm9ybVwiKSksQShpLnJhbms9PT0yLCgpPT5gRXJyb3IgaW4gYmF0Y2hOb3JtMkQ6IHggbXVzdCBiZSByYW5rIDIgYnV0IGdvdCByYW5rICR7aS5yYW5rfS5gKSxBKG8ucmFuaz09PTJ8fG8ucmFuaz09PTEsKCk9PmBFcnJvciBpbiBiYXRjaE5vcm0yRDogbWVhbiBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgYnV0IGdvdCByYW5rICR7by5yYW5rfS5gKSxBKGwucmFuaz09PTJ8fGwucmFuaz09PTEsKCk9PmBFcnJvciBpbiBiYXRjaE5vcm0yRDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayAke2wucmFua30uYCksdSE9bnVsbCYmQSh1LnJhbms9PT0yfHx1LnJhbms9PT0xLCgpPT5gRXJyb3IgaW4gYmF0Y2hOb3JtMkQ6IHNjYWxlIG11c3QgYmUgcmFuayAyIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgJHt1LnJhbmt9LmApLHAhPW51bGwmJkEocC5yYW5rPT09Mnx8cC5yYW5rPT09MSwoKT0+YEVycm9yIGluIGJhdGNoTm9ybTJEOiBvZmZzZXQgbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayAke3AucmFua30uYCksTnMoaSxvLGwscCx1LHMpfXZhciBxdj1MKHtiYXRjaE5vcm0yZF86U1B9KTtmdW5jdGlvbiBOUChlLHQsbixhLHIscyl7bGV0IGk9RShlLFwieFwiLFwiYmF0Y2hOb3JtXCIpLG89RSh0LFwibWVhblwiLFwiYmF0Y2hOb3JtXCIpLGw9RShuLFwidmFyaWFuY2VcIixcImJhdGNoTm9ybVwiKSx1O3IhPW51bGwmJih1PUUocixcInNjYWxlXCIsXCJiYXRjaE5vcm1cIikpO2xldCBwO3JldHVybiBhIT1udWxsJiYocD1FKGEsXCJvZmZzZXRcIixcImJhdGNoTm9ybVwiKSksQShpLnJhbms9PT0zLCgpPT5gRXJyb3IgaW4gYmF0Y2hOb3JtM0Q6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rICR7aS5yYW5rfS5gKSxBKG8ucmFuaz09PTN8fG8ucmFuaz09PTEsKCk9PmBFcnJvciBpbiBiYXRjaE5vcm0zRDogbWVhbiBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgYnV0IGdvdCByYW5rICR7by5yYW5rfS5gKSxBKGwucmFuaz09PTN8fGwucmFuaz09PTEsKCk9PmBFcnJvciBpbiBiYXRjaE5vcm0zRDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayAke2wucmFua30uYCksdSE9bnVsbCYmQSh1LnJhbms9PT0zfHx1LnJhbms9PT0xLCgpPT5gRXJyb3IgaW4gYmF0Y2hOb3JtM0Q6IHNjYWxlIG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgJHt1LnJhbmt9LmApLHAhPW51bGwmJkEocC5yYW5rPT09M3x8cC5yYW5rPT09MSwoKT0+YEVycm9yIGluIGJhdGNoTm9ybTNEOiBvZmZzZXQgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayAke3AucmFua30uYCksTnMoaSxvLGwscCx1LHMpfXZhciBLdj1MKHtiYXRjaE5vcm0zZF86TlB9KTtmdW5jdGlvbiBUUChlLHQsbixhLHIscyl7bGV0IGk9RShlLFwieFwiLFwiYmF0Y2hOb3JtXCIpLG89RSh0LFwibWVhblwiLFwiYmF0Y2hOb3JtXCIpLGw9RShuLFwidmFyaWFuY2VcIixcImJhdGNoTm9ybVwiKSx1O3IhPW51bGwmJih1PUUocixcInNjYWxlXCIsXCJiYXRjaE5vcm1cIikpO2xldCBwO3JldHVybiBhIT1udWxsJiYocD1FKGEsXCJvZmZzZXRcIixcImJhdGNoTm9ybVwiKSksQShpLnJhbms9PT00LCgpPT5gRXJyb3IgaW4gYmF0Y2hOb3JtNEQ6IHggbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rICR7aS5yYW5rfS5gKSxBKG8ucmFuaz09PTR8fG8ucmFuaz09PTEsKCk9PmBFcnJvciBpbiBiYXRjaE5vcm00RDogbWVhbiBtdXN0IGJlIHJhbmsgNCBvciByYW5rIDEgYnV0IGdvdCByYW5rICR7by5yYW5rfS5gKSxBKGwucmFuaz09PTR8fGwucmFuaz09PTEsKCk9PmBFcnJvciBpbiBiYXRjaE5vcm00RDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayAke2wucmFua30uYCksdSE9bnVsbCYmQSh1LnJhbms9PT00fHx1LnJhbms9PT0xLCgpPT5gRXJyb3IgaW4gYmF0Y2hOb3JtNEQ6IHNjYWxlIG11c3QgYmUgcmFuayA0IG9yIHJhbmsgMSBidXQgZ290IHJhbmsgJHt1LnJhbmt9LmApLHAhPW51bGwmJkEocC5yYW5rPT09NHx8cC5yYW5rPT09MSwoKT0+YEVycm9yIGluIGJhdGNoTm9ybTREOiBvZmZzZXQgbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayAke3AucmFua30uYCksTnMoaSxvLGwscCx1LHMpfXZhciBYdj1MKHtiYXRjaE5vcm00ZF86VFB9KTtmdW5jdGlvbiBDUChlLHQsbil7bGV0IGE9RShlLFwieFwiLFwiYmluY291bnRcIikscj1FKHQsXCJ3ZWlnaHRzXCIsXCJiaW5jb3VudFwiKTtBKGEuZHR5cGU9PT1cImludDMyXCIsKCk9PmBFcnJvciBpbiBiaW5jb3VudDogaW5wdXQgZHR5cGUgbXVzdCBiZSBpbnQzMiwgYnV0IGdvdCAke2EuZHR5cGV9YCksQShuPj0wLCgpPT5gc2l6ZSBtdXN0IGJlIG5vbi1uZWdhdGl2ZSwgYnV0IGdvdCAke259LmApLEEoci5zaXplPT09YS5zaXplfHxyLnNpemU9PT0wLCgpPT5gRXJyb3IgaW4gYmluY291bnQ6IHdlaWdodHMgbXVzdCBoYXZlIHRoZSBzYW1lIHNpemUgYXMgaW5wdXQgb3IwLWxlbmd0aCwgYnV0IGdvdCBpbnB1dCBzaGFwZTogJHthLnNoYXBlfSwgd2VpZ2h0cyBzaGFwZTogJHtyLnNoYXBlfS5gKTtsZXQgcz17eDphLHdlaWdodHM6cn0saT17c2l6ZTpufTtyZXR1cm4gUC5ydW5LZXJuZWwoYXUscyxpKX12YXIgWXY9TCh7YmluY291bnRfOkNQfSk7ZnVuY3Rpb24gRVAoZSx0KXtsZXQgbj1FKGUsXCJ4XCIsXCJiaXR3aXNlQW5kXCIpLGE9RSh0LFwieVwiLFwiYml0d2lzZUFuZFwiKTtpZighQXIobi5zaGFwZSxhLnNoYXBlKSl0aHJvdyBuZXcgRXJyb3IoYEJpdHdpc2VBbmQ6IFRlbnNvcnMgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlLiB4OiAke24uc2hhcGV9LCB5OiAke2Euc2hhcGV9YCk7aWYobi5kdHlwZSE9PVwiaW50MzJcInx8YS5kdHlwZSE9PVwiaW50MzJcIil0aHJvdyBuZXcgRXJyb3IoYEJpdHdpc2VBbmQ6IE9ubHkgc3VwcG9ydHMgJ2ludDMyJyB2YWx1ZXMgaW4gdGVuc29yLCBmb3VuZCB0eXBlIG9mIHg6ICR7bi5kdHlwZX0gYW5kIHR5cGUgb2YgeTogJHthLmR0eXBlfWApO2xldCByPXthOm4sYjphfTtyZXR1cm4gUC5ydW5LZXJuZWwocnUscil9dmFyIE5OPUwoe2JpdHdpc2VBbmRfOkVQfSk7ZnVuY3Rpb24gX1AoZSx0KXtsZXQgbj1FKGUsXCJzMFwiLFwiYnJvYWRjYXN0QXJnc1wiLFwiaW50MzJcIiksYT1FKHQsXCJzMVwiLFwiYnJvYWRjYXN0QXJnc1wiLFwiaW50MzJcIik7aWYobi5yYW5rIT09MSl0aHJvdyBuZXcgRXJyb3IoYGJyb2FkY2FzdEFyZ3MoKTogZmlyc3QgaW5wdXQgbXVzdCBiZSBhIHZlY3RvciAocmFuaz0xKS4gSGFzIHJhbmsgJHtuLnJhbmt9YCk7aWYoYS5yYW5rIT09MSl0aHJvdyBuZXcgRXJyb3IoYGJyb2FkY2FzdEFyZ3MoKTogc2Vjb25kIGlucHV0IG11c3QgYmUgYSB2ZWN0b3IgKHJhbms9MSkuIEhhcyByYW5rICR7YS5yYW5rfWApO2xldCByPXtzMDpuLHMxOmF9O3JldHVybiBQLnJ1bktlcm5lbChNYyxyKX12YXIgVE49TCh7YnJvYWRjYXN0QXJnc186X1B9KTtmdW5jdGlvbiBBUChlLHQpe2xldCBuPUUoZSxcImJyb2FkY2FzdFRvXCIsXCJ4XCIpLGE9bi5zaGFwZTtpZihuYSh0KSx0Lmxlbmd0aDxuLnJhbmspdGhyb3cgbmV3IEVycm9yKGBicm9hZGNhc3RUbygpOiBzaGFwZS5sZW5ndGg9JHt0Lmxlbmd0aH0gPCBpbnB1dC5yYW5rPSR7bi5yYW5rfS5gKTtpZih0Lmxlbmd0aD5uLnJhbmspe2xldCBsPW4uc2hhcGUuc2xpY2UoKTtmb3IoO2wubGVuZ3RoPHQubGVuZ3RoOylsLnVuc2hpZnQoMSk7bj1XKG4sbCl9bGV0IHI9bi5zaGFwZSxzPUFycmF5LmZyb20odCk7Zm9yKGxldCBsPXQubGVuZ3RoLTE7bD49MDtsLS0paWYocltsXT09PXRbbF0pc1tsXT0xO2Vsc2UgaWYobi5zaGFwZVtsXSE9PTEpdGhyb3cgbmV3IEVycm9yKGBicm9hZGNhc3RUbygpOiBbJHthfV0gY2Fubm90IGJlIGJyb2FkY2FzdCB0byBbJHt0fV0uYCk7aWYocy5tYXAoKGwsdSk9Pmw+MT91Oi0xKS5maWx0ZXIobD0+bD49MCkubGVuZ3RoPT09MClyZXR1cm4gc3Iobik7bGV0IGk9e3g6bn0sbz17cmVwczpzfTtyZXR1cm4gUC5ydW5LZXJuZWwoa3MsaSxvKX12YXIgYWk9TCh7YnJvYWRjYXN0VG9fOkFQfSk7ZnVuY3Rpb24gRlAoZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwiY2VpbFwiLFwiZmxvYXQzMlwiKX07cmV0dXJuIFAucnVuS2VybmVsKE9pLHQpfXZhciBadj1MKHtjZWlsXzpGUH0pO2Z1bmN0aW9uIHluKGUsdCxuKXtuYShlKSxuPW58fCRjKHQpO2xldCBhPXtzaGFwZTplLHZhbHVlOnQsZHR5cGU6bn07cmV0dXJuIFAucnVuS2VybmVsKHpjLHt9LGEpfWZ1bmN0aW9uICRQKGUsdCxuKXtsZXQgYT1FKGUsXCJ4XCIsXCJjbGlwQnlWYWx1ZVwiKTtpZihBKHQ8PW4sKCk9PmBFcnJvciBpbiBjbGlwOiBtaW4gKCR7dH0pIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIG1heCAoJHtufSkuYCksdD09PW4pcmV0dXJuIHluKGEuc2hhcGUsdCxhLmR0eXBlKTtsZXQgcj17eDphfSxzPXtjbGlwVmFsdWVNaW46dCxjbGlwVmFsdWVNYXg6bn07cmV0dXJuIFAucnVuS2VybmVsKHdzLHIscyl9dmFyIGFuPUwoe2NsaXBCeVZhbHVlXzokUH0pO2Z1bmN0aW9uIERQKGUpe3JldHVybiBldChlLDApfXZhciBKdj1MKHtjb25jYXQxZF86RFB9KTtmdW5jdGlvbiBSUChlLHQpe3JldHVybiBldChlLHQpfXZhciBRdj1MKHtjb25jYXQyZF86UlB9KTtmdW5jdGlvbiBNUChlLHQpe3JldHVybiBldChlLHQpfXZhciBldz1MKHtjb25jYXQzZF86TVB9KTtmdW5jdGlvbiBPUChlLHQpe3JldHVybiBldChlLHQpfXZhciB0dz1MKHtjb25jYXQ0ZF86T1B9KTtmdW5jdGlvbiBQUChlLHQsbixhLHI9XCJOSFdDXCIscz1bMSwxXSxpKXtsZXQgbz1FKGUsXCJ4XCIsXCJjb252MmRcIixcImZsb2F0MzJcIiksbD1FKHQsXCJmaWx0ZXJcIixcImNvbnYyZFwiLFwiZmxvYXQzMlwiKSx1PW8scD0hMTtvLnJhbms9PT0zJiYocD0hMCx1PVcobyxbMSxvLnNoYXBlWzBdLG8uc2hhcGVbMV0sby5zaGFwZVsyXV0pKSxBKHUucmFuaz09PTQsKCk9PmBFcnJvciBpbiBjb252MmQ6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgJHt1LnJhbmt9LmApLEEobC5yYW5rPT09NCwoKT0+YEVycm9yIGluIGNvbnYyZDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgJHtsLnJhbmt9LmApLFRuKFwiY29udjJkXCIsYSxpKTtsZXQgZD1yPT09XCJOSFdDXCI/dS5zaGFwZVszXTp1LnNoYXBlWzFdO0EoZD09PWwuc2hhcGVbMl0sKCk9PmBFcnJvciBpbiBjb252MmQ6IGRlcHRoIG9mIGlucHV0ICgke2R9KSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgJHtsLnNoYXBlWzJdfS5gKSxBKGRyKG4scyksKCk9PmBFcnJvciBpbiBjb252MkQ6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzICR7bn0gYW5kIGRpbGF0aW9ucyAnJHtzfSdgKSxBKGhpKHMpLCgpPT5cIkVycm9yIGluIGNvbnYyRDogRGlsYXRlZCByYXRlcyBzaG91bGQgYmUgbGFyZ2VyIHRoYW4gMC5cIiksQShoaShuKSwoKT0+XCJFcnJvciBpbiBjb252MkQ6IFN0cmlkZXMgc2hvdWxkIGJlIGxhcmdlciB0aGFuIDAuXCIpO2xldCBjPXt4OnUsZmlsdGVyOmx9LGg9e3N0cmlkZXM6bixwYWQ6YSxkYXRhRm9ybWF0OnIsZGlsYXRpb25zOnMsZGltUm91bmRpbmdNb2RlOml9LG09UC5ydW5LZXJuZWwoUGksYyxoKTtyZXR1cm4gcD9XKG0sW20uc2hhcGVbMV0sbS5zaGFwZVsyXSxtLnNoYXBlWzNdXSk6bX12YXIgJHQ9TCh7Y29udjJkXzpQUH0pO2Z1bmN0aW9uIExQKGUsdCxuLGEscj1cIk5XQ1wiLHM9MSxpKXtsZXQgbz1FKGUsXCJ4XCIsXCJjb252MWRcIiksbD1FKHQsXCJmaWx0ZXJcIixcImNvbnYxZFwiKSx1PW8scD0hMTtvLnJhbms9PT0yJiYocD0hMCx1PVcobyxbMSxvLnNoYXBlWzBdLG8uc2hhcGVbMV1dKSksQSh1LnJhbms9PT0zLCgpPT5gRXJyb3IgaW4gY29udjFkOiBpbnB1dCBtdXN0IGJlIHJhbmsgMywgYnV0IGdvdCByYW5rICR7dS5yYW5rfS5gKSxBKGwucmFuaz09PTMsKCk9PmBFcnJvciBpbiBjb252MWQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgMywgYnV0IGdvdCByYW5rICR7bC5yYW5rfS5gKSxUbihcImNvbnYxZFwiLGEsaSksQSh1LnNoYXBlWzJdPT09bC5zaGFwZVsxXSwoKT0+YEVycm9yIGluIGNvbnYxZDogZGVwdGggb2YgaW5wdXQgKCR7dS5zaGFwZVsyXX0pIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIGZpbHRlciAke2wuc2hhcGVbMV19LmApLEEoZHIobixzKSwoKT0+YEVycm9yIGluIGNvbnYxRDogRWl0aGVyIHN0cmlkZSBvciBkaWxhdGlvbiBtdXN0IGJlIDEuIEdvdCBzdHJpZGUgJHtufSBhbmQgZGlsYXRpb24gJyR7c30nYCksQShoaShzKSwoKT0+XCJFcnJvciBpbiBjb252MUQ6IERpbGF0ZWQgcmF0ZXMgc2hvdWxkIGJlIGxhcmdlciB0aGFuIDAuXCIpLEEoaGkobiksKCk9PlwiRXJyb3IgaW4gY29udjFEOiBTdHJpZGUgc2hvdWxkIGJlIGxhcmdlciB0aGFuIDAuXCIpLEEocj09PVwiTldDXCIsKCk9PmBFcnJvciBpbiBjb252MWQ6IGdvdCBkYXRhRm9ybWF0IG9mICR7cn0gYnV0IG9ubHkgTldDIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuYCk7bGV0IGQ9VyhsLFsxLGwuc2hhcGVbMF0sbC5zaGFwZVsxXSxsLnNoYXBlWzJdXSksYz1XKHUsW3Uuc2hhcGVbMF0sMSx1LnNoYXBlWzFdLHUuc2hhcGVbMl1dKSxoPSR0KGMsZCxbMSxuXSxhLFwiTkhXQ1wiLFsxLHNdLGkpO3JldHVybiBwP1coaCxbaC5zaGFwZVsyXSxoLnNoYXBlWzNdXSk6VyhoLFtoLnNoYXBlWzBdLGguc2hhcGVbMl0saC5zaGFwZVszXV0pfXZhciB6bT1MKHtjb252MWRfOkxQfSk7ZnVuY3Rpb24gelAoZSx0LG4sYSxyLHM9XCJOSFdDXCIsaSl7QShlLmxlbmd0aD09PXQucmFuaywoKT0+YExlbmd0aCBvZiBpblNoYXBlICgke2UubGVuZ3RofSkgYW5kIHJhbmsgb2YgZHkgKCR7dC5yYW5rfSkgbXVzdCBtYXRjaGApO2xldCBvPWUsbD10LHU9ITE7dC5yYW5rPT09MyYmKHU9ITAsbD1XKHQsWzEsdC5zaGFwZVswXSx0LnNoYXBlWzFdLHQuc2hhcGVbMl1dKSxvPVsxLGVbMF0sZVsxXSxlWzJdXSksQShvLmxlbmd0aD09PTQsKCk9PmBFcnJvciBpbiBjb252MmREZXJJbnB1dDogaW5TaGFwZSBtdXN0IGJlIGxlbmd0aCA0LCBidXQgZ290IGxlbmd0aCAke28ubGVuZ3RofS5gKSxBKGwucmFuaz09PTQsKCk9PmBFcnJvciBpbiBjb252MmREZXJJbnB1dDogZHkgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayAke2wucmFua31gKSxBKG4ucmFuaz09PTQsKCk9PmBFcnJvciBpbiBjb252MmREZXJJbnB1dDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgJHtuLnJhbmt9YCk7bGV0IHA9cz09PVwiTkhXQ1wiP29bM106b1sxXSxkPXM9PT1cIk5IV0NcIj9sLnNoYXBlWzNdOmwuc2hhcGVbMV07QShwPT09bi5zaGFwZVsyXSwoKT0+YEVycm9yIGluIGNvbnYyZERlcklucHV0OiBkZXB0aCBvZiBpbnB1dCAoJHtwfSkgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyICR7bi5zaGFwZVsyXX0uYCksQShkPT09bi5zaGFwZVszXSwoKT0+YEVycm9yIGluIGNvbnYyZERlcklucHV0OiBkZXB0aCBvZiBvdXRwdXQgKCR7ZH0pIG11c3QgbWF0Y2ggb3V0cHV0IGRlcHRoIGZvciBmaWx0ZXIgJHtuLnNoYXBlWzNdfS5gKSxUbihcImNvbnYyZERlcklucHV0XCIscixpKTtsZXQgYz17ZHk6bCxmaWx0ZXI6bn0saD17c3RyaWRlczphLHBhZDpyLGRhdGFGb3JtYXQ6cyxkaW1Sb3VuZGluZ01vZGU6aSxpbnB1dFNoYXBlOm99LG09UC5ydW5LZXJuZWwoTGksYyxoKTtyZXR1cm4gdT9XKG0sW20uc2hhcGVbMV0sbS5zaGFwZVsyXSxtLnNoYXBlWzNdXSk6bX12YXIgbnc9TCh7Y29udjJEQmFja3Byb3BJbnB1dF86elB9KTtmdW5jdGlvbiBXUChlLHQsbixhLHIscyl7bGV0IGk9RShlLFwieFwiLFwiY29udjJkVHJhbnNwb3NlXCIpLG89RSh0LFwiZmlsdGVyXCIsXCJjb252MmRUcmFuc3Bvc2VcIik7cmV0dXJuIG53KG4saSxvLGEscixcIk5IV0NcIixzKX12YXIgV209TCh7Y29udjJkVHJhbnNwb3NlXzpXUH0pO2Z1bmN0aW9uIEJQKGUsdCxuLGEscj1cIk5ESFdDXCIscz1bMSwxLDFdKXtsZXQgaT1FKGUsXCJ4XCIsXCJjb252M2RcIiksbz1FKHQsXCJmaWx0ZXJcIixcImNvbnYzZFwiKSxsPWksdT0hMTtpLnJhbms9PT00JiYodT0hMCxsPVcoaSxbMSxpLnNoYXBlWzBdLGkuc2hhcGVbMV0saS5zaGFwZVsyXSxpLnNoYXBlWzNdXSkpLEEobC5yYW5rPT09NSwoKT0+YEVycm9yIGluIGNvbnYzZDogaW5wdXQgbXVzdCBiZSByYW5rIDUsIGJ1dCBnb3QgcmFuayAke2wucmFua30uYCksQShvLnJhbms9PT01LCgpPT5gRXJyb3IgaW4gY29udjNkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDUsIGJ1dCBnb3QgcmFuayAke28ucmFua30uYCksQShsLnNoYXBlWzRdPT09by5zaGFwZVszXSwoKT0+YEVycm9yIGluIGNvbnYzZDogZGVwdGggb2YgaW5wdXQgKCR7bC5zaGFwZVs0XX0pIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIGZpbHRlciAke28uc2hhcGVbM119LmApLEEoZHIobixzKSwoKT0+YEVycm9yIGluIGNvbnYzRDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgJHtufSBhbmQgZGlsYXRpb25zICcke3N9J2ApLEEocj09PVwiTkRIV0NcIiwoKT0+YEVycm9yIGluIGNvbnYzZDogZ290IGRhdGFGb3JtYXQgb2YgJHtyfSBidXQgb25seSBOREhXQyBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLmApLEEoaGkocyksKCk9PlwiRXJyb3IgaW4gY29udjNEOiBEaWxhdGVkIHJhdGVzIHNob3VsZCBiZSBsYXJnZXIgdGhhbiAwLlwiKSxBKGhpKG4pLCgpPT5cIkVycm9yIGluIGNvbnYzRDogU3RyaWRlcyBzaG91bGQgYmUgbGFyZ2VyIHRoYW4gMC5cIik7bGV0IHA9e3g6bCxmaWx0ZXI6b30sZD17c3RyaWRlczpuLHBhZDphLGRhdGFGb3JtYXQ6cixkaWxhdGlvbnM6c30sYz1QLnJ1bktlcm5lbCh6aSxwLGQpO3JldHVybiB1P1coYyxbYy5zaGFwZVsxXSxjLnNoYXBlWzJdLGMuc2hhcGVbM10sYy5zaGFwZVs0XV0pOmN9dmFyIGF3PUwoe2NvbnYzZF86QlB9KTtmdW5jdGlvbiBWUChlLHQsbixhLHIpe0EoZS5sZW5ndGg9PT10LnJhbmssKCk9PmBMZW5ndGggb2YgaW5TaGFwZSAoJHtlLmxlbmd0aH0pIGFuZCByYW5rIG9mIGR5ICgke3QucmFua30pIG11c3QgbWF0Y2hgKTtsZXQgcz1lLGk9dCxvPSExO3QucmFuaz09PTQmJihvPSEwLGk9Vyh0LFsxLHQuc2hhcGVbMF0sdC5zaGFwZVsxXSx0LnNoYXBlWzJdLHQuc2hhcGVbM11dKSxzPVsxLGVbMF0sZVsxXSxlWzJdLGVbM11dKTtsZXQgbD1zWzRdLHU9aS5zaGFwZVs0XTtBKHMubGVuZ3RoPT09NSwoKT0+YEVycm9yIGluIGNvbnYzZERlcklucHV0OiBpblNoYXBlIG11c3QgYmUgbGVuZ3RoIDUsIGJ1dCBnb3QgbGVuZ3RoICR7cy5sZW5ndGh9LmApLEEoaS5yYW5rPT09NSwoKT0+YEVycm9yIGluIGNvbnYzZERlcklucHV0OiBkeSBtdXN0IGJlIHJhbmsgNSwgYnV0IGdvdCByYW5rICR7aS5yYW5rfWApLEEobi5yYW5rPT09NSwoKT0+YEVycm9yIGluIGNvbnYzZERlcklucHV0OiBmaWx0ZXIgbXVzdCBiZSByYW5rIDUsIGJ1dCBnb3QgcmFuayAke24ucmFua31gKSxBKGw9PT1uLnNoYXBlWzNdLCgpPT5gRXJyb3IgaW4gY29udjNkRGVySW5wdXQ6IGRlcHRoIG9mIGlucHV0ICgke2x9KSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgJHtuLnNoYXBlWzNdfS5gKSxBKHU9PT1uLnNoYXBlWzRdLCgpPT5gRXJyb3IgaW4gY29udjNkRGVySW5wdXQ6IGRlcHRoIG9mIG91dHB1dCAoJHt1fSkgbXVzdCBtYXRjaCBvdXRwdXQgZGVwdGggZm9yIGZpbHRlciAke24uc2hhcGVbNF19LmApO2xldCBwPXtkeTppLGZpbHRlcjpufSxkPXtwYWQ6cixzdHJpZGVzOmEsaW5wdXRTaGFwZTpzfSxjPVAucnVuS2VybmVsKG91LHAsZCk7cmV0dXJuIG8/VyhjLFtjLnNoYXBlWzFdLGMuc2hhcGVbMl0sYy5zaGFwZVszXSxjLnNoYXBlWzRdXSk6Y312YXIgQ049TCh7Y29udjNEQmFja3Byb3BJbnB1dF86VlB9KTtmdW5jdGlvbiBVUChlLHQsbixhLHIpe2xldCBzPUUoZSxcInhcIixcImNvbnYzZFRyYW5zcG9zZVwiKSxpPUUodCxcImZpbHRlclwiLFwiY29udjNkVHJhbnNwb3NlXCIpO3JldHVybiBDTihuLHMsaSxhLHIpfXZhciBydz1MKHtjb252M2RUcmFuc3Bvc2VfOlVQfSk7ZnVuY3Rpb24gR1AoZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwiY29zXCIsXCJmbG9hdDMyXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoV2ksdCl9dmFyIG9kPUwoe2Nvc186R1B9KTtmdW5jdGlvbiBIUChlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJjb3NoXCIsXCJmbG9hdDMyXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoQmksdCl9dmFyIEJtPUwoe2Nvc2hfOkhQfSk7ZnVuY3Rpb24galAoZSx0PTAsbj0hMSxhPSExKXtsZXQgcj17eDpFKGUsXCJ4XCIsXCJjdW1wcm9kXCIpfSxzPXtheGlzOnQsZXhjbHVzaXZlOm4scmV2ZXJzZTphfTtyZXR1cm4gUC5ydW5LZXJuZWwobHUscixzKX12YXIgd2M9TCh7Y3VtcHJvZF86alB9KTtmdW5jdGlvbiBxUChlLHQ9MCxuPSExLGE9ITEpe2xldCByPXt4OkUoZSxcInhcIixcImN1bXN1bVwiKX0scz17YXhpczp0LGV4Y2x1c2l2ZTpuLHJldmVyc2U6YX07cmV0dXJuIFAucnVuS2VybmVsKFZpLHIscyl9dmFyIFZtPUwoe2N1bXN1bV86cVB9KTtmdW5jdGlvbiBLUChlLHQsbixhPSExKXtsZXQgcj1FKGUsXCJ4XCIsXCJkZW5zZUJpbmNvdW50XCIpLHM9RSh0LFwid2VpZ2h0c1wiLFwiZGVuc2VCaW5jb3VudFwiKTtBKHIuZHR5cGU9PT1cImludDMyXCIsKCk9PmBFcnJvciBpbiBkZW5zZUJpbmNvdW50OiBpbnB1dCBkdHlwZSBtdXN0IGJlIGludDMyLCBidXQgZ290ICR7ci5kdHlwZX1gKSxBKHIucmFuazw9MiwoKT0+YEVycm9yIGluIGRlbnNlQmluY291bnQ6IGlucHV0IG11c3QgYmUgYXQgbW9zdCByYW5rIDIsIGJ1dCBnb3QgcmFuayAke3IucmFua30uYCksQShuPj0wLCgpPT5gc2l6ZSBtdXN0IGJlIG5vbi1uZWdhdGl2ZSwgYnV0IGdvdCAke259LmApLEEocy5zaXplPT09ci5zaXplfHxzLnNpemU9PT0wLCgpPT5gRXJyb3IgaW4gZGVuc2VCaW5jb3VudDogd2VpZ2h0cyBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGUgYXMgeCBvciAwLWxlbmd0aCwgYnV0IGdvdCB4IHNoYXBlOiAke3Iuc2hhcGV9LCB3ZWlnaHRzIHNoYXBlOiAke3Muc2hhcGV9LmApO2xldCBpPXt4OnIsd2VpZ2h0czpzfSxvPXtzaXplOm4sYmluYXJ5T3V0cHV0OmF9O3JldHVybiBQLnJ1bktlcm5lbChQYyxpLG8pfXZhciBYaD1MKHtkZW5zZUJpbmNvdW50XzpLUH0pO2Z1bmN0aW9uIFhQKGUsdCxuPVwiTkhXQ1wiKXtsZXQgYT1FKGUsXCJ4XCIsXCJkZXB0aFRvU3BhY2VcIixcImZsb2F0MzJcIikscj1uPT09XCJOSFdDXCI/YS5zaGFwZVsxXTphLnNoYXBlWzJdLHM9bj09PVwiTkhXQ1wiP2Euc2hhcGVbMl06YS5zaGFwZVszXSxpPW49PT1cIk5IV0NcIj9hLnNoYXBlWzNdOmEuc2hhcGVbMV07QSh0PjEsKCk9PmBibG9ja1NpemUgc2hvdWxkIGJlID4gMSBmb3IgZGVwdGhUb1NwYWNlLCBidXQgd2FzOiAke3R9YCksQShyKnQ+PTAsKCk9PmBOZWdhdGl2ZSBkaW1lbnNpb24gc2l6ZSBjYXVzZWQgYnkgb3ZlcmZsb3cgd2hlbiBtdWx0aXBseWluZ1xuICAgICR7cn0gYW5kICR7dH0gIGZvciBkZXB0aFRvU3BhY2Ugd2l0aCBpbnB1dCBzaGFwZVxuICAgICR7YS5zaGFwZX1gKSxBKHMqdD49MCwoKT0+YE5lZ2F0aXZlIGRpbWVuc2lvbiBzaXplIGNhdXNlZCBieSBvdmVyZmxvdyB3aGVuIG11bHRpcGx5aW5nXG4gICAgJHtzfSBhbmQgJHt0fSBmb3IgZGVwdGhUb1NwYWNlIHdpdGggaW5wdXQgc2hhcGVcbiAgICAgICAgJHthLnNoYXBlfWApLEEoaSUodCp0KT09PTAsKCk9PmBEaW1lbnNpb24gc2l6ZSBtdXN0IGJlIGV2ZW5seSBkaXZpc2libGUgYnkgJHt0KnR9IGJ1dCBpcyAke2l9IGZvciBkZXB0aFRvU3BhY2Ugd2l0aCBpbnB1dCBzaGFwZSAke2Euc2hhcGV9YCk7bGV0IG89e3g6YX0sbD17YmxvY2tTaXplOnQsZGF0YUZvcm1hdDpufTtyZXR1cm4gUC5ydW5LZXJuZWwocHUsbyxsKX12YXIgc3c9TCh7ZGVwdGhUb1NwYWNlXzpYUH0pO2Z1bmN0aW9uIFlQKGUsdCxuLGEscj1cIk5IV0NcIixzPVsxLDFdLGkpe2xldCBvPUUoZSxcInhcIixcImRlcHRod2lzZUNvbnYyZFwiLFwiZmxvYXQzMlwiKSxsPUUodCxcImZpbHRlclwiLFwiZGVwdGh3aXNlQ29udjJkXCIsXCJmbG9hdDMyXCIpLHU9byxwPSExO28ucmFuaz09PTMmJihwPSEwLHU9VyhvLFsxLG8uc2hhcGVbMF0sby5zaGFwZVsxXSxvLnNoYXBlWzJdXSkpLEEodS5yYW5rPT09NCwoKT0+YEVycm9yIGluIGRlcHRod2lzZUNvbnYyZDogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayAke3UucmFua30uYCksQShsLnJhbms9PT00LCgpPT5gRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayAke2wucmFua30uYCk7bGV0IGQ9cj09PVwiTkhXQ1wiP3Uuc2hhcGVbM106dS5zaGFwZVsxXTtBKGQ9PT1sLnNoYXBlWzJdLCgpPT5gRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBudW1iZXIgb2YgaW5wdXQgY2hhbm5lbHMgKCR7ZH0pIG11c3QgbWF0Y2ggdGhlIGluQ2hhbm5lbHMgZGltZW5zaW9uIGluIGZpbHRlciAke2wuc2hhcGVbMl19LmApLFRuKFwiZGVwdGh3aXNlQ29udjJkXCIsYSxpKTtsZXQgYz17eDp1LGZpbHRlcjpsfSxoPXtzdHJpZGVzOm4scGFkOmEsZGF0YUZvcm1hdDpyLGRpbGF0aW9uczpzLGRpbVJvdW5kaW5nTW9kZTppfSxtPVAucnVuS2VybmVsKFVpLGMsaCk7cmV0dXJuIHA/VyhtLFttLnNoYXBlWzFdLG0uc2hhcGVbMl0sbS5zaGFwZVszXV0pOm19dmFyIFRzPUwoe2RlcHRod2lzZUNvbnYyZF86WVB9KTtmdW5jdGlvbiBaUChlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJkaWFnXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoTGMsdCl9dmFyIEVOPUwoe2RpYWdfOlpQfSk7ZnVuY3Rpb24gSlAoZSx0LG4sYSxyPVsxLDFdLHM9XCJOSFdDXCIpe2xldCBpPUUoZSxcInhcIixcImRpbGF0aW9uMmRcIiksbz1FKHQsXCJmaWx0ZXJcIixcImRpbGF0aW9uMmRcIik7QShpLnJhbms9PT0zfHxpLnJhbms9PT00LCgpPT5gRXJyb3IgaW4gZGlsYXRpb24yZDogaW5wdXQgbXVzdCBiZSByYW5rIDMgb3IgNCwgYnV0IGdvdCByYW5rICR7aS5yYW5rfS5gKSxBKG8ucmFuaz09PTMsKCk9PmBFcnJvciBpbiBkaWxhdGlvbjJkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDMsIGJ1dCBnb3QgcmFuayAke28ucmFua30uYCksQShzPT09XCJOSFdDXCIsKCk9PmBFcnJvciBpbiBkaWxhdGlvbjJkOiBPbmx5IE5IV0MgaXMgY3VycmVudGx5IHN1cHBvcnRlZCwgYnV0IGdvdCBkYXRhRm9ybWF0IG9mICR7c31gKTtsZXQgbD1pLHU9ITE7aS5yYW5rPT09MyYmKGw9VyhpLFsxLGkuc2hhcGVbMF0saS5zaGFwZVsxXSxpLnNoYXBlWzJdXSksdT0hMCksQShsLnNoYXBlWzNdPT09by5zaGFwZVsyXSwoKT0+YEVycm9yIGluIGRpbGF0aW9uMmQ6ICBpbnB1dCBhbmQgZmlsdGVyIG11c3QgaGF2ZSB0aGUgc2FtZSBkZXB0aDogJHtsLnNoYXBlWzNdfSB2cyAke28uc2hhcGVbMl19YCk7bGV0IHA9e3g6bCxmaWx0ZXI6b30sZD17c3RyaWRlczpuLHBhZDphLGRpbGF0aW9uczpyfSxjPVAucnVuS2VybmVsKEdpLHAsZCk7cmV0dXJuIHU/VyhjLFtjLnNoYXBlWzFdLGMuc2hhcGVbMl0sYy5zaGFwZVszXV0pOmN9dmFyIGl3PUwoe2RpbGF0aW9uMmRfOkpQfSksSnU9e307X2UoSnUse2Fzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlOigpPT5jdCxnZXRCcm9hZGNhc3REaW1zOigpPT5fTixnZXRSZWR1Y3Rpb25BeGVzOigpPT5CdH0pO2Z1bmN0aW9uIF9OKGUsdCl7bGV0IG49ZS5sZW5ndGgsYT1bXTtmb3IobGV0IHI9MDtyPG47cisrKXtsZXQgcz1uLTEtcixpPWVbc118fDE7KHRbdC5sZW5ndGgtMS1yXXx8MSk+MSYmaT09PTEmJmEudW5zaGlmdChzKX1yZXR1cm4gYX1mdW5jdGlvbiBCdChlLHQpe2xldCBuPVtdO2ZvcihsZXQgYT0wO2E8dC5sZW5ndGg7YSsrKXtsZXQgcj1lW2UubGVuZ3RoLWEtMV0scz10Lmxlbmd0aC1hLTEsaT10W3NdOyhyPT1udWxsfHxyPT09MSYmaT4xKSYmbi51bnNoaWZ0KHMpfXJldHVybiBufWZ1bmN0aW9uIGN0KGUsdCl7bGV0IG49TWF0aC5tYXgoZS5sZW5ndGgsdC5sZW5ndGgpLGE9bmV3IEFycmF5KG4pO2ZvcihsZXQgcj0wO3I8bjtyKyspe2xldCBzPWVbZS5sZW5ndGgtci0xXTtzPT1udWxsJiYocz0xKTtsZXQgaT10W3QubGVuZ3RoLXItMV07aWYoaT09bnVsbCYmKGk9MSkscz09PTEpYVtuLXItMV09aTtlbHNlIGlmKGk9PT0xKWFbbi1yLTFdPXM7ZWxzZSBpZihzIT09aSl7bGV0IG89YE9wZXJhbmRzIGNvdWxkIG5vdCBiZSBicm9hZGNhc3QgdG9nZXRoZXIgd2l0aCBzaGFwZXMgJHtlfSBhbmQgJHt0fS5gO3Rocm93IEVycm9yKG8pfWVsc2UgYVtuLXItMV09c31yZXR1cm4gYX1mdW5jdGlvbiBRUChlLHQpe2xldCBuPUUoZSxcImFcIixcImVxdWFsXCIsXCJzdHJpbmdfb3JfbnVtZXJpY1wiKSxhPUUodCxcImJcIixcImVxdWFsXCIsXCJzdHJpbmdfb3JfbnVtZXJpY1wiKTtbbixhXT1fdChuLGEpLGN0KG4uc2hhcGUsYS5zaGFwZSk7bGV0IHI9e2E6bixiOmF9O3JldHVybiBQLnJ1bktlcm5lbChkdSxyKX12YXIgSm49TCh7ZXF1YWxfOlFQfSk7ZnVuY3Rpb24gZTMoZSx0LG4pe2xldCBhPUUodCxcImFcIixcIndoZXJlXCIpLHI9RShuLFwiYlwiLFwid2hlcmVcIikscz1FKGUsXCJjb25kaXRpb25cIixcIndoZXJlXCIsXCJib29sXCIpLGk9Y3QoY3Qocy5zaGFwZSxhLnNoYXBlKSxyLnNoYXBlKSxvPWFpKHMsaSksbD1haShhLGkpLHU9YWkocixpKSxwPXtjb25kaXRpb246byx0OmwsZTp1fTtyZXR1cm4gUC5ydW5LZXJuZWwoV3UscCl9dmFyIG5uPUwoe3doZXJlXzplM30pO2Z1bmN0aW9uIHQzKGUpe2xldCB0PXt4OkUoZSxcInhcIixcInplcm9zTGlrZVwiKX07cmV0dXJuIFAucnVuS2VybmVsKFl1LHQpfXZhciBxZT1MKHt6ZXJvc0xpa2VfOnQzfSk7ZnVuY3Rpb24gbjMoZSx0KXtsZXQgbj1FKGUsXCJhXCIsXCJkaXZcIiksYT1FKHQsXCJiXCIsXCJkaXZcIik7W24sYV09X3QobixhKTtsZXQgcj1oZShuLGEpLHM9cWUociksaT1KbihhLHMpO3JldHVybiBubihpLHMscil9dmFyIG93PUwoe2Rpdk5vTmFuXzpuM30pO2Z1bmN0aW9uIGEzKGUsdCl7bGV0IG49RShlLFwidDFcIixcImRvdFwiKSxhPUUodCxcInQyXCIsXCJkb3RcIik7QSgobi5yYW5rPT09MXx8bi5yYW5rPT09MikmJihhLnJhbms9PT0xfHxhLnJhbms9PT0yKSwoKT0+YEVycm9yIGluIGRvdDogaW5wdXRzIG11c3QgYWxsIGJlIHJhbmsgMSBvciAyLCBidXQgZ290IHJhbmtzICR7bi5yYW5rfSBhbmQgJHthLnJhbmt9LmApO2xldCByPW4ucmFuaz09PTE/bi5zaXplOm4uc2hhcGVbMV0scz1hLnJhbms9PT0xP2Euc2l6ZTphLnNoYXBlWzBdO2lmKEEocj09PXMsKCk9PmBFcnJvciBpbiBkb3Q6IGlubmVyIGRpbWVuc2lvbnMgb2YgaW5wdXRzIG11c3QgbWF0Y2gsIGJ1dCBnb3QgJHtyfSBhbmQgJHtzfS5gKSxuLnJhbms9PT0xJiZhLnJhbms9PT0xKXtsZXQgaT1XKG4sWzEsLTFdKSxvPVcoYSxbLTEsMV0pLGw9JGUoaSxvKTtyZXR1cm4gVyhsLFtdKX1lbHNlIGlmKG4ucmFuaz09PTEmJmEucmFuaz09PTIpe2xldCBpPVcobixbMSwtMV0pLG89VyhhLFthLnNoYXBlWzBdLGEuc2hhcGVbMV1dKSxsPSRlKGksbyk7cmV0dXJuIFcobCxbbC5zaXplXSl9ZWxzZSBpZihuLnJhbms9PT0yJiZhLnJhbms9PT0xKXtsZXQgaT1XKGEsWy0xLDFdKSxvPSRlKG4saSk7cmV0dXJuIFcobyxbby5zaXplXSl9ZWxzZXtsZXQgaT1XKGEsW2Euc2hhcGVbMF0sYS5zaGFwZVsxXV0pO3JldHVybiAkZShuLGkpfX12YXIgbHc9TCh7ZG90XzphM30pO2Z1bmN0aW9uIHIzKGUsLi4udCl7bGV0IG49dC5tYXAoKHIscyk9PkUocixgdGVuc29ycyR7c31gLFwiZWluc3VtXCIpKSxhPXtlcXVhdGlvbjplfTtyZXR1cm4gUC5ydW5LZXJuZWwoVG0sbixhKX12YXIgWnM9TCh7ZWluc3VtXzpyM30pO2Z1bmN0aW9uIHMzKGUpe2xldCB0PXt4OkUoZSxcInhcIixcImVsdVwiLFwiZmxvYXQzMlwiKX07cmV0dXJuIFAucnVuS2VybmVsKGppLHQpfXZhciBRdT1MKHtlbHVfOnMzfSk7ZnVuY3Rpb24gaTMoZSx0KXtsZXQgbj1FKGUsXCJ4XCIsXCJlbnN1cmVTaGFwZVwiLFwic3RyaW5nX29yX251bWVyaWNcIik7aWYoIVJTKG4uc2hhcGUsdCkpdGhyb3cgbmV3IEVycm9yKGBFbnN1cmVTaGFwZTogU2hhcGUgb2YgdGVuc29yICR7bi5zaGFwZX0gaXMgbm90IGNvbXBhdGlibGUgd2l0aCBleHBlY3RlZCBzaGFwZSAke3R9YCk7cmV0dXJuIGV9dmFyIEFOPUwoe2Vuc3VyZVNoYXBlXzppM30pO2Z1bmN0aW9uIG8zKGUpe2xldCB0PUUoZSxcInhcIixcImVyZlwiKTtBKHQuZHR5cGU9PT1cImludDMyXCJ8fHQuZHR5cGU9PT1cImZsb2F0MzJcIiwoKT0+XCJJbnB1dCBkdHlwZSBtdXN0IGJlIGBpbnQzMmAgb3IgYGZsb2F0MzJgLlwiKSx0LmR0eXBlPT09XCJpbnQzMlwiJiYodD1yZSh0LFwiZmxvYXQzMlwiKSk7bGV0IG49e3g6dH07cmV0dXJuIFAucnVuS2VybmVsKHFpLG4pfXZhciBVbT1MKHtlcmZfOm8zfSk7ZnVuY3Rpb24gdXcoZSx0KXtmb3IobGV0IG49MDtuPGUubGVuZ3RoOysrbilpZihlW2UubGVuZ3RoLW4tMV0hPT10LTEtbilyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBGTihlLHQsbil7bGV0IGE9ZS5sZW5ndGgrdC5sZW5ndGgscj1bXSxzPTAsaT0wO2ZvcihsZXQgbz0wO288YTtvKyspbi5pbmRleE9mKG8pPT09LTE/ci5wdXNoKGVbcysrXSk6ci5wdXNoKHRbaSsrXSk7cmV0dXJuIHJ9ZnVuY3Rpb24gJE4oZSx0KXtsZXQgbj1bXSxhPWUubGVuZ3RoO2ZvcihsZXQgcz0wO3M8YTtzKyspdC5pbmRleE9mKHMpPT09LTEmJm4ucHVzaChlW3NdKTtsZXQgcj10Lm1hcChzPT5lW3NdKTtyZXR1cm5bbixyXX1mdW5jdGlvbiBtaShlLHQpe2xldCBuPXQubWFwKGE9PjEpO3JldHVybiBGTihlLG4sdCl9ZnVuY3Rpb24gbDMoZSx0LG4pe0EodXcodCxuKSwoKT0+YCR7ZX0gc3VwcG9ydHMgb25seSBpbm5lci1tb3N0IGF4ZXMgZm9yIG5vdy4gR290IGF4ZXMgJHt0fSBhbmQgcmFuay0ke259IGlucHV0LmApfWZ1bmN0aW9uIEROKGUsdCl7aWYodXcoZSx0KSlyZXR1cm4gbnVsbDtsZXQgbj1bXTtmb3IobGV0IGE9MDthPHQ7KythKWUuaW5kZXhPZihhKT09PS0xJiZuLnB1c2goYSk7cmV0dXJuIGUuZm9yRWFjaChhPT5uLnB1c2goYSkpLG59ZnVuY3Rpb24gcHcoZSl7cmV0dXJuIGUubWFwKCh0LG4pPT5bbix0XSkuc29ydCgodCxuKT0+dFsxXS1uWzFdKS5tYXAodD0+dFswXSl9ZnVuY3Rpb24gdTMoZSx0KXtsZXQgbj1bXTtmb3IobGV0IGE9dC1lO2E8dDsrK2Epbi5wdXNoKGEpO3JldHVybiBufWZ1bmN0aW9uIHAzKGUsdD1udWxsLG49ITEpe2xldCBhPXt4OkUoZSxcInhcIixcIm1heFwiKX0scj17cmVkdWN0aW9uSW5kaWNlczp0LGtlZXBEaW1zOm59O3JldHVybiBQLnJ1bktlcm5lbChsbyxhLHIpfXZhciBtYT1MKHttYXhfOnAzfSk7ZnVuY3Rpb24gYzMoZSx0PW51bGwsbj0hMSl7bGV0IGE9e3g6RShlLFwieFwiLFwibWluXCIpfSxyPXtheGlzOnQsa2VlcERpbXM6bn07cmV0dXJuIFAucnVuS2VybmVsKGhvLGEscil9dmFyIE9sPUwoe21pbl86YzN9KTtmdW5jdGlvbiBkMyhlLHQpe2xldCBuPUUoZSxcImJhc2VcIixcInBvd1wiKSxhPUUodCxcImV4cFwiLFwicG93XCIpO1tuLGFdPV90KG4sYSk7bGV0IHI9e2E6bixiOmF9O3JldHVybiBQLnJ1bktlcm5lbCh2byxyKX12YXIgdXI9TCh7cG93XzpkM30pO2Z1bmN0aW9uIHhlKGUsdCl7aWYoKGVuKGUpJiZ0IT09XCJzdHJpbmdcInx8QXJyYXkuaXNBcnJheShlKSkmJnQhPT1cImNvbXBsZXg2NFwiKXRocm93IG5ldyBFcnJvcihcIkVycm9yIGNyZWF0aW5nIGEgbmV3IFNjYWxhcjogdmFsdWUgbXVzdCBiZSBhIHByaW1pdGl2ZSAobnVtYmVyfGJvb2xlYW58c3RyaW5nKVwiKTtpZih0PT09XCJzdHJpbmdcIiYmZW4oZSkmJiEoZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKXRocm93IG5ldyBFcnJvcihcIldoZW4gbWFraW5nIGEgc2NhbGFyIGZyb20gZW5jb2RlZCBzdHJpbmcsIHRoZSB2YWx1ZSBtdXN0IGJlIGBVaW50OEFycmF5YC5cIik7cmV0dXJuIFNzKGUsW10sW10sdCl9ZnVuY3Rpb24gaDMoZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwic3FydFwiLFwiZmxvYXQzMlwiKX07cmV0dXJuIFAucnVuS2VybmVsKFBvLHQpfXZhciBybj1MKHtzcXJ0XzpoM30pO2Z1bmN0aW9uIG0zKGUpe2xldCB0PUUoZSxcInhcIixcInNxdWFyZVwiKSxuPXt9O3JldHVybiBQLnJ1bktlcm5lbChcIlNxdWFyZVwiLHt4OnR9LG4pfXZhciBwdD1MKHtzcXVhcmVfOm0zfSk7ZnVuY3Rpb24gZjMoZSx0PW51bGwsbj0hMSl7bGV0IGE9RShlLFwieFwiLFwic3VtXCIpO2EuZHR5cGU9PT1cImJvb2xcIiYmKGE9cmUoYSxcImludDMyXCIpKTtsZXQgcj17eDphfSxzPXtheGlzOnQsa2VlcERpbXM6bn07cmV0dXJuIFAucnVuS2VybmVsKExvLHIscyl9dmFyIGZlPUwoe3N1bV86ZjN9KTtmdW5jdGlvbiBnMyhlLHQ9XCJldWNsaWRlYW5cIixuPW51bGwsYT0hMSl7ZT1FKGUsXCJ4XCIsXCJub3JtXCIpO2xldCByPVJOKGUsdCxuKSxzPXIuc2hhcGU7aWYoYSl7bGV0IGk9QWEobixlLnNoYXBlKTtzPW1pKHIuc2hhcGUsaSl9cmV0dXJuIFcocixzKX1mdW5jdGlvbiBSTihlLHQsbj1udWxsKXtpZihlLnJhbms9PT0wKXJldHVybiBMdChlKTtpZihlLnJhbmshPT0xJiZuPT09bnVsbClyZXR1cm4gUk4oVyhlLFstMV0pLHQsbik7aWYoZS5yYW5rPT09MXx8dHlwZW9mIG49PVwibnVtYmVyXCJ8fEFycmF5LmlzQXJyYXkobikmJm4ubGVuZ3RoPT09MSl7aWYodD09PTEpcmV0dXJuIGZlKEx0KGUpLG4pO2lmKHQ9PT0xLzApcmV0dXJuIG1hKEx0KGUpLG4pO2lmKHQ9PT0tMS8wKXJldHVybiBPbChMdChlKSxuKTtpZih0PT09XCJldWNsaWRlYW5cInx8dD09PTIpcmV0dXJuIHJuKGZlKHVyKEx0KGUpLHhlKDIsXCJpbnQzMlwiKSksbikpO3Rocm93IG5ldyBFcnJvcihgRXJyb3IgaW4gbm9ybTogaW52YWxpZCBvcmQgdmFsdWU6ICR7dH1gKX1pZihBcnJheS5pc0FycmF5KG4pJiZuLmxlbmd0aD09PTIpe2lmKHQ9PT0xKXJldHVybiBtYShmZShMdChlKSxuWzBdKSxuWzFdLTEpO2lmKHQ9PT0xLzApcmV0dXJuIG1hKGZlKEx0KGUpLG5bMV0pLG5bMF0pO2lmKHQ9PT0tMS8wKXJldHVybiBPbChmZShMdChlKSxuWzFdKSxuWzBdKTtpZih0PT09XCJmcm9cInx8dD09PVwiZXVjbGlkZWFuXCIpcmV0dXJuIHJuKGZlKHB0KGUpLG4pKTt0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGluIG5vcm06IGludmFsaWQgb3JkIHZhbHVlOiAke3R9YCl9dGhyb3cgbmV3IEVycm9yKGBFcnJvciBpbiBub3JtOiBpbnZhbGlkIGF4aXM6ICR7bn1gKX12YXIgZXA9TCh7bm9ybV86ZzN9KTtmdW5jdGlvbiBiMyhlLHQ9bnVsbCxuPSExKXtyZXR1cm4gZXAoZSxcImV1Y2xpZGVhblwiLHQsbil9dmFyIGN3PUwoe2V1Y2xpZGVhbk5vcm1fOmIzfSk7ZnVuY3Rpb24geTMoZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwiZXhwXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoS2ksdCl9dmFyIGRuPUwoe2V4cF86eTN9KTtmdW5jdGlvbiB4MyhlLHQ9MCl7bGV0IG49RShlLFwieFwiLFwiZXhwYW5kRGltc1wiLFwic3RyaW5nX29yX251bWVyaWNcIik7QSh0PD1uLnJhbmssKCk9PlwiQXhpcyBtdXN0IGJlIDw9IHJhbmsgb2YgdGhlIHRlbnNvclwiKTtsZXQgYT17aW5wdXQ6bn0scj17ZGltOnR9O3JldHVybiBQLnJ1bktlcm5lbChodSxhLHIpfXZhciBHdD1MKHtleHBhbmREaW1zXzp4M30pO2Z1bmN0aW9uIHYzKGUpe2xldCB0PXt4OkUoZSxcInhcIixcImV4cG0xXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoWGksdCl9dmFyIGR3PUwoe2V4cG0xXzp2M30pO2Z1bmN0aW9uIHczKGUsdCl7bGV0IG49RShlLFwieFwiLFwidGlsZVwiLFwic3RyaW5nX29yX251bWVyaWNcIik7QShuLnJhbms9PT10Lmxlbmd0aCwoKT0+YEVycm9yIGluIHRyYW5zcG9zZTogcmFuayBvZiBpbnB1dCAke24ucmFua30gbXVzdCBtYXRjaCBsZW5ndGggb2YgcmVwcyAke3R9LmApO2xldCBhPXt4Om59LHI9e3JlcHM6dH07cmV0dXJuIFAucnVuS2VybmVsKGtzLGEscil9dmFyIE9uPUwoe3RpbGVfOnczfSk7ZnVuY3Rpb24gazMoZSx0LG4sYT1cImZsb2F0MzJcIil7dD09bnVsbCYmKHQ9ZSk7bGV0IHI9T2UoW2UsdF0sYSkscz1lPD10P2U6dDtmb3IobGV0IG89MDtvPHM7KytvKXIuc2V0KDEsbyxvKTtsZXQgaT1XKHIudG9UZW5zb3IoKSxbZSx0XSk7aWYobj09bnVsbClyZXR1cm4gaTtpZihuLmxlbmd0aD09PTEpcmV0dXJuIE9uKEd0KGksMCksW25bMF0sMSwxXSk7aWYobi5sZW5ndGg9PT0yKXJldHVybiBPbihHdChHdChpLDApLDApLFtuWzBdLG5bMV0sMSwxXSk7aWYobi5sZW5ndGg9PT0zKXJldHVybiBPbihHdChHdChHdChpLDApLDApLDApLFtuWzBdLG5bMV0sblsyXSwxLDFdKTt0aHJvdyBuZXcgRXJyb3IoYGV5ZSgpIGN1cnJlbnRseSBzdXBwb3J0cyBvbmx5IDFEIGFuZCAyRCBiYXRjaFNoYXBlcywgYnV0IHJlY2VpdmVkICR7bi5sZW5ndGh9RC5gKX12YXIgR209TCh7ZXllXzprM30pO2Z1bmN0aW9uIEkzKGUpe2xldCB0PXt4OkUoZSxcInhcIixcImZsb29yXCIsXCJmbG9hdDMyXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoWWksdCl9dmFyIHRwPUwoe2Zsb29yXzpJM30pO2Z1bmN0aW9uIFMzKGUsdCxuPTAsYT0wKXtsZXQgcj1FKGUsXCJ4XCIsXCJnYXRoZXJcIikscz1FKHQsXCJpbmRpY2VzXCIsXCJnYXRoZXJcIixcImludDMyXCIpLGk9e3g6cixpbmRpY2VzOnN9LG89e2F4aXM6bixiYXRjaERpbXM6YX07cmV0dXJuIFAucnVuS2VybmVsKGZ1LGksbyl9dmFyIG5wPUwoe2dhdGhlcl86UzN9KTtmdW5jdGlvbiBOMyhlLHQpe2xldCBuPUUoZSxcImFcIixcImdyZWF0ZXJcIixcInN0cmluZ19vcl9udW1lcmljXCIpLGE9RSh0LFwiYlwiLFwiZ3JlYXRlclwiLFwic3RyaW5nX29yX251bWVyaWNcIik7W24sYV09X3QobixhKSxjdChuLnNoYXBlLGEuc2hhcGUpO2xldCByPXthOm4sYjphfTtyZXR1cm4gUC5ydW5LZXJuZWwoYnUscil9dmFyIENuPUwoe2dyZWF0ZXJfOk4zfSk7ZnVuY3Rpb24gVDMoZSx0KXtsZXQgbj1FKGUsXCJhXCIsXCJncmVhdGVyRXF1YWxcIixcInN0cmluZ19vcl9udW1lcmljXCIpLGE9RSh0LFwiYlwiLFwiZ3JlYXRlckVxdWFsXCIsXCJzdHJpbmdfb3JfbnVtZXJpY1wiKTtbbixhXT1fdChuLGEpLGN0KG4uc2hhcGUsYS5zaGFwZSk7bGV0IHI9e2E6bixiOmF9O3JldHVybiBQLnJ1bktlcm5lbChRaSxyKX12YXIgJHI9TCh7Z3JlYXRlckVxdWFsXzpUM30pO2Z1bmN0aW9uIEMzKGUpe2xldCB0PXtpbnB1dDpFKGUsXCJpbnB1dFwiLFwiaW1hZ1wiKX07cmV0dXJuIFAucnVuS2VybmVsKF9tLHQpfXZhciBsZD1MKHtpbWFnXzpDM30pO2Z1bmN0aW9uIEUzKGUpe2xldCB0PXt4OkUoZSxcInhcIixcImlzRmluaXRlXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwodG8sdCl9dmFyIGh3PUwoe2lzRmluaXRlXzpFM30pO2Z1bmN0aW9uIF8zKGUpe2xldCB0PXt4OkUoZSxcInhcIixcImlzSW5mXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwobm8sdCl9dmFyIG13PUwoe2lzSW5mXzpfM30pO2Z1bmN0aW9uIEEzKGUpe2xldCB0PXt4OkUoZSxcInhcIixcImlzTmFOXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoYW8sdCl9dmFyIGZ3PUwoe2lzTmFOXzpBM30pO2Z1bmN0aW9uIEYzKGUsdD0uMil7bGV0IG49e3g6RShlLFwieFwiLFwibGVha3lSZWx1XCIpfSxhPXthbHBoYTp0fTtyZXR1cm4gUC5ydW5LZXJuZWwocm8sbixhKX12YXIgdWQ9TCh7bGVha3lSZWx1XzpGM30pO2Z1bmN0aW9uICQzKGUsdCl7bGV0IG49RShlLFwiYVwiLFwibGVzc1wiLFwic3RyaW5nX29yX251bWVyaWNcIiksYT1FKHQsXCJiXCIsXCJsZXNzXCIsXCJzdHJpbmdfb3JfbnVtZXJpY1wiKTtbbixhXT1fdChuLGEpLGN0KG4uc2hhcGUsYS5zaGFwZSk7bGV0IHI9e2E6bixiOmF9O3JldHVybiBQLnJ1bktlcm5lbCh5dSxyKX12YXIgUGw9TCh7bGVzc186JDN9KTtmdW5jdGlvbiBEMyhlLHQpe2xldCBuPUUoZSxcImFcIixcImxlc3NFcXVhbFwiLFwic3RyaW5nX29yX251bWVyaWNcIiksYT1FKHQsXCJiXCIsXCJsZXNzRXF1YWxcIixcInN0cmluZ19vcl9udW1lcmljXCIpO1tuLGFdPV90KG4sYSksY3Qobi5zaGFwZSxhLnNoYXBlKTtsZXQgcj17YTpuLGI6YX07cmV0dXJuIFAucnVuS2VybmVsKHh1LHIpfXZhciBDcz1MKHtsZXNzRXF1YWxfOkQzfSk7ZnVuY3Rpb24gTU4oZSx0LG4pe2lmKG48PTApdGhyb3cgbmV3IEVycm9yKFwiVGhlIG51bWJlciBvZiB2YWx1ZXMgc2hvdWxkIGJlIHBvc2l0aXZlLlwiKTtsZXQgYT17c3RhcnQ6ZSxzdG9wOnQsbnVtOm59O3JldHVybiBQLnJ1bktlcm5lbCh2dSx7fSxhKX1mdW5jdGlvbiBSMyhlLHQ9NSxuPTEsYT0xLHI9LjUpe2xldCBzPUUoZSxcInhcIixcImxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uXCIpO0Eocy5yYW5rPT09NHx8cy5yYW5rPT09MywoKT0+YEVycm9yIGluIGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uOiB4IG11c3QgYmUgcmFuayAzIG9yIDQgYnV0IGdvdFxuICAgICAgICAgICAgICAgcmFuayAke3MucmFua30uYCksQSgkbCh0KSwoKT0+YEVycm9yIGluIGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uOiBkZXB0aFJhZGl1cyBtdXN0IGJlIGFuIGludGVnZXIgYnV0IGdvdCBkZXB0aFJhZGl1cyAke3R9LmApO2xldCBpPXMsbz0hMTtzLnJhbms9PT0zJiYobz0hMCxpPVcocyxbMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0scy5zaGFwZVsyXV0pKTtsZXQgbD17eDppfSx1PXtkZXB0aFJhZGl1czp0LGJpYXM6bixhbHBoYTphLGJldGE6cn0scD1QLnJ1bktlcm5lbChvbyxsLHUpO3JldHVybiBvP1cocCxbcC5zaGFwZVsxXSxwLnNoYXBlWzJdLHAuc2hhcGVbM11dKTpwfXZhciBndz1MKHtsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbl86UjN9KTtmdW5jdGlvbiBNMyhlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJsb2dcIixcImZsb2F0MzJcIil9O3JldHVybiBQLnJ1bktlcm5lbChzbyx0KX12YXIgUW49TCh7bG9nXzpNM30pO2Z1bmN0aW9uIE8zKGUpe2xldCB0PXt4OkUoZSxcInhcIixcImxvZzFwXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoaW8sdCl9dmFyIHBkPUwoe2xvZzFwXzpPM30pO2Z1bmN0aW9uIFAzKGUpe3JldHVybiBBKHNzKGUpLCgpPT5cIlRoZSBmIHBhc3NlZCBpbiBncmFkKGYpIG11c3QgYmUgYSBmdW5jdGlvblwiKSwodCxuKT0+e2xldCBhPUUodCxcInhcIixcInRmLmdyYWRcIixcInN0cmluZ19vcl9udW1lcmljXCIpLHI9biE9bnVsbD9FKG4sXCJkeVwiLFwidGYuZ3JhZFwiKTpudWxsO3JldHVybiBQLnRpZHkoKCk9PntsZXR7dmFsdWU6cyxncmFkczppfT1QLmdyYWRpZW50cygoKT0+ZShhKSxbYV0scik7cmV0dXJuIHIhPW51bGwmJk5uKHMuc2hhcGUsci5zaGFwZSxcIlRoZSBzaGFwZSBvZiBkeSBwYXNzZWQgaW4gZ3JhZChmKSh4LCBkeSkgbXVzdCBtYXRjaCB0aGUgc2hhcGUgcmV0dXJuZWQgYnkgZih4KVwiKSxIbShpKSxpWzBdfSl9fWZ1bmN0aW9uIEwzKGUpe3JldHVybiBBKHNzKGUpLCgpPT5cIlRoZSBmIHBhc3NlZCBpbiBncmFkcyhmKSBtdXN0IGJlIGEgZnVuY3Rpb25cIiksKHQsbik9PntBKEFycmF5LmlzQXJyYXkodCksKCk9PlwiVGhlIGFyZ3MgcGFzc2VkIGluIGdyYWRzKGYpKGFyZ3MpIG11c3QgYmUgYW4gYXJyYXkgb2YgYFRlbnNvcmBzIG9yIGBUZW5zb3JMaWtlYHNcIik7bGV0IGE9YmModCxcImFyZ3NcIixcInRmLmdyYWRzXCIsXCJzdHJpbmdfb3JfbnVtZXJpY1wiKSxyPW4hPW51bGw/RShuLFwiZHlcIixcInRmLmdyYWRzXCIpOm51bGw7cmV0dXJuIFAudGlkeSgoKT0+e2xldHt2YWx1ZTpzLGdyYWRzOml9PVAuZ3JhZGllbnRzKCgpPT5lKC4uLmEpLGEscik7cmV0dXJuIHIhPW51bGwmJk5uKHMuc2hhcGUsci5zaGFwZSxcIlRoZSBzaGFwZSBvZiBkeSBwYXNzZWQgaW4gZ3JhZHMoZikoW3gxLC4uLl0sIGR5KSBtdXN0IG1hdGNoIHRoZSBzaGFwZSByZXR1cm5lZCBieSBmKFt4MSwuLi5dKVwiKSxIbShpKSxpfSl9fWZ1bmN0aW9uIHozKGUpe3JldHVybiBBKHNzKGUpLCgpPT5cIlRoZSBmIHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWQoZikgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpLCh0LG4pPT57QSh0IGluc3RhbmNlb2YgQ2UsKCk9PlwiVGhlIHggcGFzc2VkIGluIHZhbHVlQW5kR3JhZChmKSh4KSBtdXN0IGJlIGEgdGVuc29yXCIpLEEobj09bnVsbHx8biBpbnN0YW5jZW9mIENlLCgpPT5cIlRoZSBkeSBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkKGYpKHgsIGR5KSBtdXN0IGJlIGEgdGVuc29yXCIpO2xldHtncmFkczphLHZhbHVlOnJ9PVAuZ3JhZGllbnRzKCgpPT5lKHQpLFt0XSxuKTtyZXR1cm4gSG0oYSkse2dyYWQ6YVswXSx2YWx1ZTpyfX19ZnVuY3Rpb24gVzMoZSl7cmV0dXJuIEEoc3MoZSksKCk9PlwiVGhlIGYgcGFzc2VkIGluIHZhbHVlQW5kR3JhZHMoZikgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpLCh0LG4pPT57QShBcnJheS5pc0FycmF5KHQpJiZ0LmV2ZXJ5KHI9PnIgaW5zdGFuY2VvZiBDZSksKCk9PlwiVGhlIGFyZ3MgcGFzc2VkIGluIHZhbHVlQW5kR3JhZHMoZikoYXJncykgbXVzdCBiZSBhcnJheSBvZiB0ZW5zb3JzXCIpLEEobj09bnVsbHx8biBpbnN0YW5jZW9mIENlLCgpPT5cIlRoZSBkeSBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkcyhmKShhcmdzLCBkeSkgbXVzdCBiZSBhIHRlbnNvclwiKTtsZXQgYT1QLmdyYWRpZW50cygoKT0+ZSguLi50KSx0LG4pO3JldHVybiBuIT1udWxsJiZObihhLnZhbHVlLnNoYXBlLG4uc2hhcGUsXCJUaGUgc2hhcGUgb2YgZHkgcGFzc2VkIGluIHZhbHVlQW5kR3JhZHMoZikoW3gxLC4uLl0sIGR5KSBtdXN0IG1hdGNoIHRoZSBzaGFwZSByZXR1cm5lZCBieSBmKFt4MSwuLi5dKVwiKSxIbShhLmdyYWRzKSxhfX1mdW5jdGlvbiBPTihlLHQpe0Eoc3MoZSksKCk9PlwiVGhlIGYgcGFzc2VkIGluIHZhcmlhYmxlR3JhZHMoZikgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpLEEodD09bnVsbHx8QXJyYXkuaXNBcnJheSh0KSYmdC5ldmVyeSh1PT51IGluc3RhbmNlb2Ygb3MpLCgpPT5cIlRoZSB2YXJMaXN0IHBhc3NlZCBpbiB2YXJpYWJsZUdyYWRzKGYsIHZhckxpc3QpIG11c3QgYmUgYW4gYXJyYXkgb2YgdmFyaWFibGVzXCIpO2xldCBuPXQhPW51bGw7aWYoIW4pe3Q9W107Zm9yKGxldCB1IGluIFAucmVnaXN0ZXJlZFZhcmlhYmxlcyl0LnB1c2goUC5yZWdpc3RlcmVkVmFyaWFibGVzW3VdKX1sZXQgYT1uP3QuZmlsdGVyKHU9PiF1LnRyYWluYWJsZSk6bnVsbCxyPXQubGVuZ3RoO3Q9dC5maWx0ZXIodT0+dS50cmFpbmFibGUpLEEodC5sZW5ndGg+MCwoKT0+YHZhcmlhYmxlR3JhZHMoKSBleHBlY3RzIGF0IGxlYXN0IG9uZSBvZiB0aGUgaW5wdXQgdmFyaWFibGVzIHRvIGJlIHRyYWluYWJsZSwgYnV0IG5vbmUgb2YgdGhlICR7cn0gdmFyaWFibGVzIGlzIHRyYWluYWJsZS5gKTtsZXQgcz0hMCx7dmFsdWU6aSxncmFkczpvfT1QLmdyYWRpZW50cyhlLHQsbnVsbCxzKTtBKG8uc29tZSh1PT51IT1udWxsKSwoKT0+XCJDYW5ub3QgZmluZCBhIGNvbm5lY3Rpb24gYmV0d2VlbiBhbnkgdmFyaWFibGUgYW5kIHRoZSByZXN1bHQgb2YgdGhlIGxvc3MgZnVuY3Rpb24geT1mKHgpLiBQbGVhc2UgbWFrZSBzdXJlIHRoZSBvcGVyYXRpb25zIHRoYXQgdXNlIHZhcmlhYmxlcyBhcmUgaW5zaWRlIHRoZSBmdW5jdGlvbiBmIHBhc3NlZCB0byBtaW5pbWl6ZSgpLlwiKSxBKGkucmFuaz09PTAsKCk9PmBUaGUgZiBwYXNzZWQgaW4gdmFyaWFibGVHcmFkcyhmKSBtdXN0IHJldHVybiBhIHNjYWxhciwgYnV0IGl0IHJldHVybmVkIGEgcmFuay0ke2kucmFua30gdGVuc29yYCk7bGV0IGw9e307cmV0dXJuIHQuZm9yRWFjaCgodSxwKT0+e29bcF0hPW51bGwmJihsW3UubmFtZV09b1twXSl9KSxhIT1udWxsJiZhLmZvckVhY2godT0+bFt1Lm5hbWVdPW51bGwpLHt2YWx1ZTppLGdyYWRzOmx9fWZ1bmN0aW9uIHByKGUpe3JldHVybiBQLmN1c3RvbUdyYWQoZSl9ZnVuY3Rpb24gSG0oZSl7aWYoZS5maWx0ZXIodD0+dD09bnVsbCkubGVuZ3RoPjApdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29tcHV0ZSBncmFkaWVudCBvZiB5PWYoeCkgd2l0aCByZXNwZWN0IHRvIHguIE1ha2Ugc3VyZSB0aGF0XG4gICAgdGhlIGYgeW91IHBhc3NlZCBlbmNsb3NlcyBhbGwgb3BlcmF0aW9ucyB0aGF0IGxlYWQgZnJvbSB4IHRvIHkuYCl9ZnVuY3Rpb24gQjMoZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwibmVnXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoQ3UsdCl9dmFyIHl0PUwoe25lZ186QjN9KTtmdW5jdGlvbiBWMyhlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJzb2Z0cGx1c1wiKX07cmV0dXJuIFAucnVuS2VybmVsKE9vLHQpfXZhciBHbz1MKHtzb2Z0cGx1c186VjN9KTtmdW5jdGlvbiBVMyhlKXtsZXQgdD1FKGUsXCJ4XCIsXCJsb2dTaWdtb2lkXCIpO3JldHVybiBwcihuPT4oe3ZhbHVlOnl0KEdvKHl0KG4pKSksZ3JhZEZ1bmM6YT0+eihhLGhhKHl0KG4pKSl9KSkodCl9dmFyIGJ3PUwoe2xvZ1NpZ21vaWRfOlUzfSk7ZnVuY3Rpb24gRzMoZSx0KXtsZXQgbj1FKGUsXCJhXCIsXCJzdWJcIiksYT1FKHQsXCJiXCIsXCJzdWJcIik7W24sYV09X3QobixhKTtsZXQgcj17YTpuLGI6YX07cmV0dXJuIFAucnVuS2VybmVsKEJvLHIpfXZhciBwZT1MKHtzdWJfOkczfSk7ZnVuY3Rpb24gSDMoZSx0PS0xKXtsZXQgbj1FKGUsXCJsb2dpdHNcIixcImxvZ1NvZnRtYXhcIik7aWYodD09PS0xJiYodD1uLnJhbmstMSksdCE9PW4ucmFuay0xKXRocm93IEVycm9yKGBMb2cgU29mdG1heCBhbG9uZyBhIG5vbi1sYXN0IGRpbWVuc2lvbiBpcyBub3QgeWV0IHN1cHBvcnRlZC4gTG9naXRzIHdhcyByYW5rICR7bi5yYW5rfSBhbmQgYXhpcyB3YXMgJHt0fWApO3JldHVybiBwcigoYSxyKT0+e2xldCBzPW1hKGEsdCwhMCksaT1wZShhLHMpLG89cGUocmUoaSxcImZsb2F0MzJcIiksUW4oZmUoZG4oaSksdCwhMCkpKTtyZXR1cm4gcihbb10pLHt2YWx1ZTpvLGdyYWRGdW5jOihsLHUpPT57bGV0W3BdPXUsZD0hMCxjPWRuKHApO3JldHVybiBwZShsLHooZmUobCx0LGQpLGMpKX19fSkobil9dmFyIGptPUwoe2xvZ1NvZnRtYXhfOkgzfSk7ZnVuY3Rpb24gajMoZSx0PW51bGwsbj0hMSl7bGV0IGE9RShlLFwieFwiLFwibG9nU3VtRXhwXCIpLHI9QWEodCxhLnNoYXBlKSxzPW1hKGEsciwhMCksaT1wZShhLHMpLG89ZG4oaSksbD1mZShvLHIpLHU9UW4obCkscD1YKFcocyx1LnNoYXBlKSx1KTtpZihuKXtsZXQgZD1taShwLnNoYXBlLHIpO3JldHVybiBXKHAsZCl9cmV0dXJuIHB9dmFyIGNkPUwoe2xvZ1N1bUV4cF86ajN9KTtmdW5jdGlvbiBxMyhlLHQpe2xldCBuPUUoZSxcImFcIixcImxvZ2ljYWxBbmRcIixcImJvb2xcIiksYT1FKHQsXCJiXCIsXCJsb2dpY2FsQW5kXCIsXCJib29sXCIpO2N0KG4uc2hhcGUsYS5zaGFwZSk7bGV0IHI9e2E6bixiOmF9O3JldHVybiBQLnJ1bktlcm5lbCh3dSxyKX12YXIgX2E9TCh7bG9naWNhbEFuZF86cTN9KTtmdW5jdGlvbiBLMyhlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJsb2dpY2FsTm90XCIsXCJib29sXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoa3UsdCl9dmFyIGRkPUwoe2xvZ2ljYWxOb3RfOkszfSk7ZnVuY3Rpb24gWDMoZSx0KXtsZXQgbj1FKGUsXCJhXCIsXCJsb2dpY2FsT3JcIixcImJvb2xcIiksYT1FKHQsXCJiXCIsXCJsb2dpY2FsT3JcIixcImJvb2xcIik7Y3Qobi5zaGFwZSxhLnNoYXBlKTtsZXQgcj17YTpuLGI6YX07cmV0dXJuIFAucnVuS2VybmVsKEl1LHIpfXZhciBxbT1MKHtsb2dpY2FsT3JfOlgzfSk7ZnVuY3Rpb24gWTMoZSx0KXtsZXQgbj1FKGUsXCJhXCIsXCJsb2dpY2FsWG9yXCIsXCJib29sXCIpLGE9RSh0LFwiYlwiLFwibG9naWNhbFhvclwiLFwiYm9vbFwiKTtyZXR1cm4gY3Qobi5zaGFwZSxhLnNoYXBlKSxfYShxbShlLHQpLGRkKF9hKGUsdCkpKX12YXIgeXc9TCh7bG9naWNhbFhvcl86WTN9KSx2aD0yMTQ3NDgzNjQ4O2Z1bmN0aW9uIFozKGUsdCxuPVwibGVmdFwiKXtsZXQgYT1FKGUsXCJzb3J0ZWRTZXF1ZW5jZVwiLFwic2VhcmNoU29ydGVkXCIpLHI9RSh0LFwidmFsdWVzXCIsXCJzZWFyY2hTb3J0ZWRcIikscz1hLnNoYXBlW2Euc2hhcGUubGVuZ3RoLTFdLGk9ci5zaGFwZVtyLnNoYXBlLmxlbmd0aC0xXSxvPVcoYSxbLTEsc10pLGw9VyhyLFstMSxpXSk7aWYoby5yYW5rPDIpdGhyb3cgbmV3IEVycm9yKFwiU29ydGVkIGlucHV0IGFyZ3VtZW50IG11c3QgYmUgYXQgbGVhc3QgMi1kaW1lbnNpb25hbFwiKTtpZihvLnNoYXBlWzBdIT09bC5zaGFwZVswXSl0aHJvdyBuZXcgRXJyb3IoXCJMZWFkaW5nIGRpbWVuc2lvbiBvZiAnc29ydGVkU2VxdWVuY2UnIGFuZCAndmFsdWVzJyBtdXN0IG1hdGNoLlwiKTtpZihvdChsLnNoYXBlKT49dmgpdGhyb3cgbmV3IEVycm9yKGB2YWx1ZXMgdGVuc29yIHNpemUgbXVzdCBsZXNzIHRoYW4gJHt2aH1gKTtpZihvLnNoYXBlWzFdPj12aCl0aHJvdyBuZXcgRXJyb3IoYHRyYWlsaW5nIGRpbV9zaXplIG11c3QgbGVzcyB0aGFuICR7dmh9IGZvciBpbnQzMiBvdXRwdXQgdHlwZSwgd2FzICR7by5zaGFwZVsxXX1gKTtsZXQgdT17c29ydGVkU2VxdWVuY2U6byx2YWx1ZXM6bH0scD17c2lkZTpufTtyZXR1cm4gUC5ydW5LZXJuZWwoenUsdSxwKX12YXIgS209TCh7c2VhcmNoU29ydGVkXzpaM30pO2Z1bmN0aW9uIFBOKGUsdCl7cmV0dXJuIEttKGUsdCxcImxlZnRcIil9ZnVuY3Rpb24gSjMoZSx0LG4sYSxyKXtsZXQgcz1FKGUsXCJ4XCIsXCJtYXhQb29sXCIpLGk9MSxvPXMsbD0hMTtzLnJhbms9PT0zJiYobD0hMCxvPVcocyxbMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0scy5zaGFwZVsyXV0pKSxBKG8ucmFuaz09PTQsKCk9PmBFcnJvciBpbiBtYXhQb29sOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgJHtvLnJhbmt9LmApLEEoZHIobixpKSwoKT0+YEVycm9yIGluIG1heFBvb2w6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzICR7bn0gYW5kIGRpbGF0aW9ucyAnJHtpfSdgKSxUbihcIm1heFBvb2xcIixhLHIpO2xldCB1PXt4Om99LHA9e2ZpbHRlclNpemU6dCxzdHJpZGVzOm4scGFkOmEsZGltUm91bmRpbmdNb2RlOnJ9LGQ9UC5ydW5LZXJuZWwocG8sdSxwKTtyZXR1cm4gbD9XKGQsW2Quc2hhcGVbMV0sZC5zaGFwZVsyXSxkLnNoYXBlWzNdXSk6ZH12YXIgRHQ9TCh7bWF4UG9vbF86SjN9KTtmdW5jdGlvbiBRMyhlLHQ9WzEsMSwxXSxuLGEscixzPVwiTkRIV0NcIil7bGV0IGk9RShlLFwieFwiLFwibWF4UG9vbDNkXCIpLG89aSxsPSExO2kucmFuaz09PTQmJihsPSEwLG89VyhpLFsxLGkuc2hhcGVbMF0saS5zaGFwZVsxXSxpLnNoYXBlWzJdLGkuc2hhcGVbM11dKSksQShvLnJhbms9PT01LCgpPT5gRXJyb3IgaW4gbWF4UG9vbDNkOiB4IG11c3QgYmUgcmFuayA1IGJ1dCBnb3QgcmFuayAke28ucmFua30uYCksQShzPT09XCJOREhXQ1wiLCgpPT5gRXJyb3IgaW4gbWF4UG9vbDNkOiBPbmx5IE5ESFdDIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQsIGJ1dCBnb3QgZGF0YUZvcm1hdCBvZiAke3N9YCksVG4oXCJtYXhQb29sM2RcIixhLHIpO2xldCB1PXt4Om99LHA9e2ZpbHRlclNpemU6dCxzdHJpZGVzOm4scGFkOmEsZGltUm91bmRpbmdNb2RlOnIsZGF0YUZvcm1hdDpzfSxkPVAucnVuS2VybmVsKE51LHUscCk7cmV0dXJuIGw/VyhkLFtkLnNoYXBlWzFdLGQuc2hhcGVbMl0sZC5zaGFwZVszXSxkLnNoYXBlWzRdXSk6ZH12YXIgeHc9TCh7bWF4UG9vbDNkXzpRM30pO2Z1bmN0aW9uIGVMKGUsdCxuLGEscj0hMSl7bGV0IHM9e3g6RShlLFwieFwiLFwibWF4UG9vbFdpdGhBcmdtYXhcIil9LGk9e2ZpbHRlclNpemU6dCxzdHJpZGVzOm4scGFkOmEsaW5jbHVkZUJhdGNoSW5JbmRleDpyfSxvPVAucnVuS2VybmVsKFZjLHMsaSk7cmV0dXJue3Jlc3VsdDpvWzBdLGluZGV4ZXM6b1sxXX19dmFyIExOPUwoe21heFBvb2xXaXRoQXJnbWF4XzplTH0pO2Z1bmN0aW9uIHRMKGUsdCl7bGV0IG49RShlLFwiYVwiLFwibWF4aW11bVwiKSxhPUUodCxcImJcIixcIm1heGltdW1cIik7W24sYV09X3QobixhKSxuLmR0eXBlPT09XCJib29sXCImJihuPXJlKG4sXCJpbnQzMlwiKSxhPXJlKGEsXCJpbnQzMlwiKSksY3Qobi5zaGFwZSxhLnNoYXBlKTtsZXQgcj17YTpuLGI6YX07cmV0dXJuIFAucnVuS2VybmVsKHVvLHIpfXZhciBocj1MKHttYXhpbXVtXzp0TH0pO2Z1bmN0aW9uIG5MKGUsdD1udWxsLG49ITEpe2xldCBhPXt4OkUoZSxcInhcIixcIm1lYW5cIil9LHI9e2F4aXM6dCxrZWVwRGltczpufTtyZXR1cm4gUC5ydW5LZXJuZWwoY28sYSxyKX12YXIgQ3Q9TCh7bWVhbl86bkx9KTtmdW5jdGlvbiBJdChlLHQ9XCJmbG9hdDMyXCIpe2lmKG5hKGUpLHQ9PT1cImNvbXBsZXg2NFwiKXtsZXQgYT1JdChlLFwiZmxvYXQzMlwiKSxyPUl0KGUsXCJmbG9hdDMyXCIpO3JldHVybiBfcihhLHIpfWxldCBuPXhtKG90KGUpLHQpO3JldHVybiBQLm1ha2VUZW5zb3IobixlLHQpfWZ1bmN0aW9uIFBuKGUsdD1cImZsb2F0MzJcIil7aWYobmEoZSksdD09PVwiY29tcGxleDY0XCIpe2xldCBhPVBuKGUsXCJmbG9hdDMyXCIpLHI9SXQoZSxcImZsb2F0MzJcIik7cmV0dXJuIF9yKGEscil9bGV0IG49TnYob3QoZSksdCk7cmV0dXJuIFAubWFrZVRlbnNvcihuLGUsdCl9ZnVuY3Rpb24gek4oZSx0LHtpbmRleGluZzpuPVwieHlcIn09e30pe2lmKG4hPT1cInh5XCImJm4hPT1cImlqXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtufSBpcyBub3QgYSB2YWxpZCB0aGlyZCBhcmd1bWVudCB0byBtZXNoZ3JpZGApO2lmKGU9PT12b2lkIDApcmV0dXJuW107bGV0IGE9RShlLFwieFwiLFwibWVzaGdyaWRcIixlIGluc3RhbmNlb2YgQ2U/ZS5kdHlwZTpcImZsb2F0MzJcIik7aWYodD09PXZvaWQgMClyZXR1cm5bYV07bGV0IHI9RSh0LFwieVwiLFwibWVzaGdyaWRcIix0IGluc3RhbmNlb2YgQ2U/dC5kdHlwZTpcImZsb2F0MzJcIikscz1vdChhLnNoYXBlKSxpPW90KHIuc2hhcGUpO3JldHVybiBuPT09XCJ4eVwiPyhhPVcoYSxbMSwtMV0pLHI9VyhyLFstMSwxXSksWyRlKFBuKFtpLDFdLGEuZHR5cGUpLGEpLCRlKHIsUG4oWzEsc10sci5kdHlwZSkpXSk6KGE9VyhhLFstMSwxXSkscj1XKHIsWzEsLTFdKSxbJGUoYSxQbihbMSxpXSxhLmR0eXBlKSksJGUoUG4oW3MsMV0sci5kdHlwZSkscildKX1mdW5jdGlvbiBhTChlLHQpe2xldCBuPUUoZSxcImFcIixcIm1pbmltdW1cIiksYT1FKHQsXCJiXCIsXCJtaW5pbXVtXCIpO1tuLGFdPV90KG4sYSksbi5kdHlwZT09PVwiYm9vbFwiJiYobj1yZShuLFwiaW50MzJcIiksYT1yZShhLFwiaW50MzJcIikpLGN0KG4uc2hhcGUsYS5zaGFwZSk7bGV0IHI9e2E6bixiOmF9O3JldHVybiBQLnJ1bktlcm5lbChtbyxyKX12YXIgZHM9TCh7bWluaW11bV86YUx9KTtmdW5jdGlvbiByTChlLHQsbil7QShuPT09XCJyZWZsZWN0XCJ8fG49PT1cInN5bW1ldHJpY1wiLCgpPT5gSW52YWxpZCBtb2RlLiBNb2RlIG11c3QgYmUgZWl0aGVyIHJlZmxlY3Qgb3Igc3ltbWV0cmljLiBHb3QgJHtufS5gKTtsZXQgYT1FKGUsXCJ4XCIsXCJtaXJyb3JQYWRcIik7aWYoYS5yYW5rPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJtaXJyb3JQYWQoc2NhbGFyKSBpcyBub3QgZGVmaW5lZC4gUGFzcyBub24tc2NhbGFyIHRvIG1pcnJvclBhZFwiKTtBKHQubGVuZ3RoPT09YS5yYW5rLCgpPT5gUGFkZGluZyBkb2Vzbid0IG1hdGNoIGlucHV0LiBNdXN0IGJlICR7YS5yYW5rfS4gR290ICR7dC5sZW5ndGh9LmApO2xldCByPW49PT1cInJlZmxlY3RcIj8xOjA7Zm9yKGxldCBvPTA7bzxhLnJhbms7bysrKUEodFtvXS5sZW5ndGg9PT0yLCgpPT5cIkludmFsaWQgbnVtYmVyIG9mIHBhZGRpbmdzLiBNdXN0IGJlIGxlbmd0aCBvZiAyIGVhY2guXCIpLEEodFtvXVswXT49MCYmdFtvXVswXTw9YS5zaGFwZVtvXS1yJiZ0W29dWzFdPj0wJiZ0W29dWzFdPD1hLnNoYXBlW29dLXIsKCk9PmBQYWRkaW5nIGluIGRpbWVuc2lvbiAke299IGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHthLnNoYXBlW29dLXJ9IG9yIGxlc3MgdGhhbiAwIGZvciBpbnB1dCBvZiBzaGFwZSAke2Euc2hhcGV9YCk7bGV0IHM9e3BhZGRpbmdzOnQsbW9kZTpufSxpPXt4OmF9O3JldHVybiBQLnJ1bktlcm5lbChmbyxpLHMpfXZhciB2dz1MKHttaXJyb3JQYWRfOnJMfSk7ZnVuY3Rpb24gc0woZSx0KXtsZXQgbj1FKGUsXCJhXCIsXCJtb2RcIiksYT1FKHQsXCJiXCIsXCJtb2RcIik7W24sYV09X3QobixhKTtsZXQgcj17YTpuLGI6YX07cmV0dXJuIFAucnVuS2VybmVsKGdvLHIpfXZhciB3dz1MKHttb2RfOnNMfSk7ZnVuY3Rpb24gaUwoZSx0PW51bGwsbj0hMSl7ZT1FKGUsXCJ4XCIsXCJtb21lbnRzXCIpO2xldCBhPUFhKHQsZS5zaGFwZSkscj1DdChlLGEsbikscz1yLnNoYXBlO258fChzPW1pKHIuc2hhcGUsYSkpO2xldCBpPXB0KHBlKHJlKGUsXCJmbG9hdDMyXCIpLFcocixzKSkpLG89Q3QoaSxhLG4pO3JldHVybnttZWFuOnIsdmFyaWFuY2U6b319dmFyIGhkPUwoe21vbWVudHNfOmlMfSk7ZnVuY3Rpb24gb0woZSx0LG4sYSl7bGV0IHI9RSh0LFwiZGF0YVwiLFwibXVsdGlSTk5DZWxsXCIpLHM9YmMobixcImNcIixcIm11bHRpUk5OQ2VsbFwiKSxpPWJjKGEsXCJoXCIsXCJtdWx0aVJOTkNlbGxcIiksbz1yLGw9W107Zm9yKGxldCBkPTA7ZDxlLmxlbmd0aDtkKyspe2xldCBjPWVbZF0obyxzW2RdLGlbZF0pO2wucHVzaChjWzBdKSxsLnB1c2goY1sxXSksbz1jWzFdfWxldCB1PVtdLHA9W107Zm9yKGxldCBkPTA7ZDxsLmxlbmd0aDtkKz0yKXUucHVzaChsW2RdKSxwLnB1c2gobFtkKzFdKTtyZXR1cm5bdSxwXX12YXIgV049TCh7bXVsdGlSTk5DZWxsXzpvTH0pO2Z1bmN0aW9uIGxMKGUsdCxuLGE9ITEpe2xldCByPUUoZSxcImxvZ2l0c1wiLFwibXVsdGlub21pYWxcIikscz1yLnNpemUsaT1yLnJhbms7aWYoczwyKXRocm93IG5ldyBFcnJvcihgRXJyb3IgaW4gbXVsdGlub21pYWw6IHlvdSBuZWVkIGF0IGxlYXN0IDIgb3V0Y29tZXMsIGJ1dCBnb3QgJHtzfS5gKTtpZihpPjIpdGhyb3cgbmV3IEVycm9yKGBSYW5rIG9mIHByb2JhYmlsaXRpZXMgbXVzdCBiZSAxIG9yIDIsIGJ1dCBpcyAke2l9YCk7bj1ufHxNYXRoLnJhbmRvbSgpO2xldCBvPXtsb2dpdHM6aT09PTE/VyhyLFsxLC0xXSk6cn0sbD17bnVtU2FtcGxlczp0LHNlZWQ6bixub3JtYWxpemVkOmF9LHU9UC5ydW5LZXJuZWwoVHUsbyxsKTtyZXR1cm4gaT09PTE/Vyh1LFt1LnNpemVdKTp1fXZhciBCTj1MKHttdWx0aW5vbWlhbF86bEx9KTtmdW5jdGlvbiB1TChlLHQpe2xldCBuPUUoZSxcImFcIixcIm5vdEVxdWFsXCIsXCJzdHJpbmdfb3JfbnVtZXJpY1wiKSxhPUUodCxcImJcIixcIm5vdEVxdWFsXCIsXCJzdHJpbmdfb3JfbnVtZXJpY1wiKTtbbixhXT1fdChuLGEpLGN0KG4uc2hhcGUsYS5zaGFwZSk7bGV0IHI9e2E6bixiOmF9O3JldHVybiBQLnJ1bktlcm5lbChFdSxyKX12YXIgZmk9TCh7bm90RXF1YWxfOnVMfSk7ZnVuY3Rpb24gcEwoZSx0LG49MSxhPTAscj1cImludDMyXCIpe2lmKHQ8Mil0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGluIG9uZUhvdDogZGVwdGggbXVzdCBiZSA+PTIsIGJ1dCBpdCBpcyAke3R9YCk7bGV0IHM9e2luZGljZXM6RShlLFwiaW5kaWNlc1wiLFwib25lSG90XCIsXCJpbnQzMlwiKX0saT17ZHR5cGU6cixkZXB0aDp0LG9uVmFsdWU6bixvZmZWYWx1ZTphfTtyZXR1cm4gUC5ydW5LZXJuZWwoeW8scyxpKX12YXIgTGw9TCh7b25lSG90XzpwTH0pO2Z1bmN0aW9uIGNMKGUpe2xldCB0PXt4OkUoZSxcInhcIixcIm9uZXNMaWtlXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoJHUsdCl9dmFyIGVhPUwoe29uZXNMaWtlXzpjTH0pO2Z1bmN0aW9uIGRMKGUsdCl7bGV0IG49RShlLFwidjFcIixcIm91dGVyUHJvZHVjdFwiKSxhPUUodCxcInYyXCIsXCJvdXRlclByb2R1Y3RcIik7QShuLnJhbms9PT0xJiZhLnJhbms9PT0xLCgpPT5gRXJyb3IgaW4gb3V0ZXJQcm9kdWN0OiBpbnB1dHMgbXVzdCBiZSByYW5rIDEsIGJ1dCBnb3QgcmFua3MgJHtuLnJhbmt9IGFuZCAke2EucmFua30uYCk7bGV0IHI9VyhuLFstMSwxXSkscz1XKGEsWzEsLTFdKTtyZXR1cm4gJGUocixzKX12YXIgVk49TCh7b3V0ZXJQcm9kdWN0XzpkTH0pO2Z1bmN0aW9uIGhMKGUsdCxuPTApe2xldCBhPUUoZSxcInhcIixcInBhZFwiKTtpZihhLnJhbms9PT0wKXRocm93IG5ldyBFcnJvcihcInBhZChzY2FsYXIpIGlzIG5vdCBkZWZpbmVkLiBQYXNzIG5vbi1zY2FsYXIgdG8gcGFkXCIpO2xldCByPXtwYWRkaW5nczp0LGNvbnN0YW50VmFsdWU6bn0scz17eDphfTtyZXR1cm4gUC5ydW5LZXJuZWwoeG8scyxyKX12YXIgeGE9TCh7cGFkXzpoTH0pO2Z1bmN0aW9uIG1MKGUsdCxuPTApe3JldHVybiBBKHQubGVuZ3RoPT09MiwoKT0+XCJJbnZhbGlkIG51bWJlciBvZiBwYWRkaW5ncy4gTXVzdCBiZSBsZW5ndGggb2YgMi5cIikseGEoZSxbdF0sbil9dmFyIFVOPUwoe3BhZDFkXzptTH0pO2Z1bmN0aW9uIGZMKGUsdCxuPTApe3JldHVybiBBKHQubGVuZ3RoPT09MiYmdFswXS5sZW5ndGg9PT0yJiZ0WzFdLmxlbmd0aD09PTIsKCk9PlwiSW52YWxpZCBudW1iZXIgb2YgcGFkZGluZ3MuIE11c3QgYmUgbGVuZ3RoIG9mIDIgZWFjaC5cIikseGEoZSx0LG4pfXZhciBHTj1MKHtwYWQyZF86Zkx9KTtmdW5jdGlvbiBnTChlLHQsbj0wKXtyZXR1cm4gQSh0Lmxlbmd0aD09PTMmJnRbMF0ubGVuZ3RoPT09MiYmdFsxXS5sZW5ndGg9PT0yJiZ0WzJdLmxlbmd0aD09PTIsKCk9PlwiSW52YWxpZCBudW1iZXIgb2YgcGFkZGluZ3MuIE11c3QgYmUgbGVuZ3RoIG9mIDIgZWFjaC5cIikseGEoZSx0LG4pfXZhciBITj1MKHtwYWQzZF86Z0x9KTtmdW5jdGlvbiBiTChlLHQsbj0wKXtyZXR1cm4gQSh0Lmxlbmd0aD09PTQmJnRbMF0ubGVuZ3RoPT09MiYmdFsxXS5sZW5ndGg9PT0yJiZ0WzJdLmxlbmd0aD09PTImJnRbM10ubGVuZ3RoPT09MiwoKT0+XCJJbnZhbGlkIG51bWJlciBvZiBwYWRkaW5ncy4gTXVzdCBiZSBsZW5ndGggb2YgMiBlYWNoLlwiKSx4YShlLHQsbil9dmFyIGpOPUwoe3BhZDRkXzpiTH0pO2Z1bmN0aW9uIHlMKGUsdCxuKXtsZXQgYT1FKGUsXCJ4XCIsXCJzcGFjZVRvQmF0Y2hORFwiKTtBKGEucmFuaz49MSt0Lmxlbmd0aCwoKT0+YGlucHV0IHJhbmsgJHthLnJhbmt9IHNob3VsZCBiZSA+IHRoYW4gW2Jsb2NrU2hhcGVdICR7dC5sZW5ndGh9YCksQShuLmxlbmd0aD09PXQubGVuZ3RoLCgpPT5gcGFkZGluZ3Muc2hhcGVbMF0gJHtuLmxlbmd0aH0gbXVzdCBiZSBlcXVhbCB0byBbYmxvY2tTaGFwZV0gJHt0Lmxlbmd0aH1gKSxBKGEuc2hhcGUucmVkdWNlKChpLG8sbCk9Pmw+MCYmbDw9dC5sZW5ndGg/aSYmKG8rbltsLTFdWzBdK25bbC0xXVsxXSkldFtsLTFdPT09MDppLCEwKSwoKT0+YGlucHV0IHNwYXRpYWwgZGltZW5zaW9ucyAke2Euc2hhcGUuc2xpY2UoMSl9IHdpdGggcGFkZGluZ3MgJHtuLnRvU3RyaW5nKCl9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IGJsb2NrU2hhcGVzICR7dC50b1N0cmluZygpfWApO2xldCByPXt4OmF9LHM9e2Jsb2NrU2hhcGU6dCxwYWRkaW5nczpufTtyZXR1cm4gUC5ydW5LZXJuZWwoVnUscixzKX12YXIgbWQ9TCh7c3BhY2VUb0JhdGNoTkRfOnlMfSk7ZnVuY3Rpb24geEwoZSx0LG4sYSxyLHMsaSl7cj09bnVsbCYmKHI9WzEsMV0pLHM9PW51bGwmJihzPTEpLGE9PT0wJiYoYT1cInZhbGlkXCIpO2xldCBvPUUoZSxcInhcIixcIm1heFBvb2xcIiksbD1vLHU9ITE7by5yYW5rPT09MyYmKHU9ITAsbD1XKG8sWzEsby5zaGFwZVswXSxvLnNoYXBlWzFdLG8uc2hhcGVbMl1dKSksQShkcihzLHIpLCgpPT5gRXJyb3IgaW4gcG9vbDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgJHtzfSBhbmQgZGlsYXRpb25zICcke3J9J2ApO2xldCBwPXdOKGwuc2hhcGUsdCxzLHIsYSksZD1bcC5kaWxhdGlvbkhlaWdodCxwLmRpbGF0aW9uV2lkdGhdLGM7YT09PVwic2FtZVwiP2M9d0woW3AuZmlsdGVySGVpZ2h0LHAuZmlsdGVyV2lkdGhdLGQpOmM9W1swLDBdLFswLDBdXTtsZXQgaD1kWzBdPT09MSYmZFsxXT09PTEsW20sZl09dkwoW3AuaW5IZWlnaHQscC5pbldpZHRoXSxkLGMpLGc9aD9hOlwidmFsaWRcIixiPWg/bDptZChsLGQsbSkseT0obj09PVwiYXZnXCI/KCk9PnlhKGIsdCxzLGcsaSk6KCk9PkR0KGIsdCxzLGcsaSkpKCkseD1oP3k6aWQoeSxkLGYpO3JldHVybiB1P1coeCxbeC5zaGFwZVsxXSx4LnNoYXBlWzJdLHguc2hhcGVbM11dKTp4fWZ1bmN0aW9uIHZMKGUsdCxuKXtsZXQgYT1uLm1hcChwPT5wWzBdKSxyPW4ubWFwKHA9PnBbMV0pLHM9ZS5jb25jYXQoYSxyKSxpPXQubWFwKChwLGQpPT4ocC1zW2RdJXApJXApLG89ci5tYXAoKHAsZCk9PnAraVtkXSksbD10Lm1hcCgocCxkKT0+W2FbZF0sb1tkXV0pLHU9dC5tYXAoKHAsZCk9PlswLGlbZF1dKTtyZXR1cm5bbCx1XX1mdW5jdGlvbiB3TChlLHQpe2xldCBuPWUubWFwKChzLGkpPT5zKyhzLTEpKih0W2ldLTEpKS5tYXAocz0+cy0xKSxhPW4ubWFwKHM9Pk1hdGguZmxvb3Iocy8yKSkscj1uLm1hcCgocyxpKT0+cy1hW2ldKTtyZXR1cm4gbi5tYXAoKHMsaSk9PlthW2ldLHJbaV1dKX12YXIga3c9TCh7cG9vbF86eEx9KTtmdW5jdGlvbiBrTChlLHQpe2xldCBuPUUoZSxcInhcIixcInByZWx1XCIpLGE9RSh0LFwiYWxwaGFcIixcInByZWx1XCIpLHI9e3g6bixhbHBoYTphfTtyZXR1cm4gUC5ydW5LZXJuZWwod28scil9dmFyIGZkPUwoe3ByZWx1XzprTH0pO2Z1bmN0aW9uIElMKGUsdD1udWxsLG49ITEpe2xldCBhPUUoZSxcInhcIixcInByb2RcIik7YS5kdHlwZT09PVwiYm9vbFwiJiYoYT1yZShhLFwiaW50MzJcIikpO2xldCByPXt4OmF9LHM9e2F4aXM6dCxrZWVwRGltczpufTtyZXR1cm4gUC5ydW5LZXJuZWwoa28scixzKX12YXIgSXc9TCh7cHJvZF86SUx9KTtmdW5jdGlvbiBTTChlLHQsbixhKXtsZXQgcj1lLm1hcCgocCxkKT0+RShwLGB0ZW5zb3JzJHtkfWAsXCJyYWdnZWRHYXRoZXJcIixcImludDMyXCIpKSxzPUUodCxcInBhcmFtc0RlbnNlVmFsdWVzXCIsXCJyYWdnZWRHYXRoZXJcIiksaT1FKG4sXCJpbmRpY2VzXCIsXCJyYWdnZWRHYXRoZXJcIixcImludDMyXCIpLG89e3BhcmFtc05lc3RlZFNwbGl0czpyLHBhcmFtc0RlbnNlVmFsdWVzOnMsaW5kaWNlczppfSxsPXtvdXRwdXRSYWdnZWRSYW5rOmF9LHU9UC5ydW5LZXJuZWwoQW0sbyxsKTtyZXR1cm57b3V0cHV0TmVzdGVkU3BsaXRzOnUuc2xpY2UoMCx1Lmxlbmd0aC0xKSxvdXRwdXREZW5zZVZhbHVlczp1W3UubGVuZ3RoLTFdfX12YXIgcU49TCh7cmFnZ2VkR2F0aGVyXzpTTH0pO2Z1bmN0aW9uIE5MKGUsdCxuKXtsZXQgYT1FKGUsXCJzdGFydHNcIixcInJhZ2dlZFJhbmdlXCIpLHI9RSh0LFwibGltaXRzXCIsXCJyYWdnZWRSYW5nZVwiLGEuZHR5cGUpLHM9RShuLFwiZGVsdGFzXCIsXCJyYWdnZWRSYW5nZVwiLGEuZHR5cGUpLGk9e3N0YXJ0czphLGxpbWl0czpyLGRlbHRhczpzfSxvPVAucnVuS2VybmVsKEZtLGkpO3JldHVybntydE5lc3RlZFNwbGl0czpvWzBdLHJ0RGVuc2VWYWx1ZXM6b1sxXX19dmFyIEtOPUwoe3JhZ2dlZFJhbmdlXzpOTH0pO2Z1bmN0aW9uIFRMKGUsdCxuLGEscil7bGV0IHM9RShlLFwic2hhcGVcIixcInJhZ2dlZFRlbnNvclRvVGVuc29yXCIsXCJpbnQzMlwiKSxpPUUodCxcInZhbHVlc1wiLFwicmFnZ2VkVGVuc29yVG9UZW5zb3JcIiksbz1FKG4sXCJkZWZhdWx0VmFsdWVcIixcInJhZ2dlZFRlbnNvclRvVGVuc29yXCIsaS5kdHlwZSksbD1hLm1hcCgoZCxjKT0+RShkLGB0ZW5zb3JzJHtjfWAsXCJyYWdnZWRUZW5zb3JUb1RlbnNvclwiLFwiaW50MzJcIikpLHU9e3NoYXBlOnMsdmFsdWVzOmksZGVmYXVsdFZhbHVlOm8scm93UGFydGl0aW9uVGVuc29yczpsfSxwPXtyb3dQYXJ0aXRpb25UeXBlczpyfTtyZXR1cm4gUC5ydW5LZXJuZWwoJG0sdSxwKX12YXIgWE49TCh7cmFnZ2VkVGVuc29yVG9UZW5zb3JfOlRMfSk7ZnVuY3Rpb24gQ0woZSx0LG4pe25hKGUpO2xldCBhPW90KGUpLHI9bnVsbDtpZihuPT1udWxsfHxuPT09XCJmbG9hdDMyXCIpcj1uZXcgRmxvYXQzMkFycmF5KGEpO2Vsc2UgaWYobj09PVwiaW50MzJcIilyPW5ldyBJbnQzMkFycmF5KGEpO2Vsc2UgaWYobj09PVwiYm9vbFwiKXI9bmV3IFVpbnQ4QXJyYXkoYSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YSB0eXBlICR7bn1gKTtmb3IobGV0IHM9MDtzPGE7cysrKXJbc109dCgpO3JldHVybiBQLm1ha2VUZW5zb3IocixlLG4pfXZhciBZTj1MKHtyYW5kXzpDTH0pLFN3PXhzKGJtKCkpLFpOPXt9O19lKFpOLHtURVNUX0VQU0lMT05fRkxPQVQxNjooKT0+Sk4sY3JlYXRlVmlkZW9FbGVtZW50OigpPT5NTCxlbmNvZGVTdHJpbmdzOigpPT5RTixleHBlY3RBcnJheUJ1ZmZlcnNFcXVhbDooKT0+UkwsZXhwZWN0QXJyYXlzQ2xvc2U6KCk9Pl9MLGV4cGVjdEFycmF5c0VxdWFsOigpPT5GTCxleHBlY3ROdW1iZXJzQ2xvc2U6KCk9PiRMLGV4cGVjdFByb21pc2VUb0ZhaWw6KCk9PkFMLGV4cGVjdFZhbHVlc0luUmFuZ2U6KCk9PkRMLHBsYXk6KCk9Pk9MLHRlc3RFcHNpbG9uOigpPT5Od30pO3ZhciBFTD0uMDAxLEpOPS4xO2Z1bmN0aW9uIF9MKGUsdCxuKXtyZXR1cm4gbj09bnVsbCYmKG49TncoKSksUngoZSx0LChhLHIpPT5UdyhhLHIsbikpfWZ1bmN0aW9uIE53KCl7cmV0dXJuIFAuYmFja2VuZC5mbG9hdFByZWNpc2lvbigpPT09MzI/RUw6Sk59ZnVuY3Rpb24gUngoZSx0LG4pe2xldCBhPSEwO2lmKChlbihlKXx8ZW4odCkpJiYoYT0hMSksZW4oZSkmJmVuKHQpJiYoYT0hMCksYSl7bGV0IGk9ZS5jb25zdHJ1Y3Rvci5uYW1lLG89dC5jb25zdHJ1Y3Rvci5uYW1lO2lmKGkhPT1vKXRocm93IG5ldyBFcnJvcihgQXJyYXlzIGFyZSBvZiBkaWZmZXJlbnQgdHlwZS4gQWN0dWFsOiAke2l9LiBFeHBlY3RlZDogJHtvfWApfWlmKEFycmF5LmlzQXJyYXkoZSkmJkFycmF5LmlzQXJyYXkodCkpe2xldCBpPWxyKGUpLG89bHIodCk7aWYoIUFyKGksbykpdGhyb3cgbmV3IEVycm9yKGBBcnJheXMgaGF2ZSBkaWZmZXJlbnQgc2hhcGVzLiBBY3R1YWw6IFske2l9XS4gRXhwZWN0ZWQ6IFske299XWApfWxldCByPWVuKGUpP2U6aXMoZSkscz1lbih0KT90OmlzKHQpO2lmKHIubGVuZ3RoIT09cy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBBcnJheXMgaGF2ZSBkaWZmZXJlbnQgbGVuZ3RocyBhY3R1YWw6ICR7ci5sZW5ndGh9IHZzIGV4cGVjdGVkOiAke3MubGVuZ3RofS5cbkFjdHVhbDogICAke3J9LlxuRXhwZWN0ZWQ6ICR7c30uYCk7Zm9yKGxldCBpPTA7aTxzLmxlbmd0aDsrK2kpe2xldCBvPXJbaV0sbD1zW2ldO2lmKCFuKG8sbCkpdGhyb3cgbmV3IEVycm9yKGBBcnJheXMgZGlmZmVyOiBhY3R1YWxbJHtpfV0gPSAke299LCBleHBlY3RlZFske2l9XSA9ICR7bH0uXG5BY3R1YWw6ICAgJHtyfS5cbkV4cGVjdGVkOiAke3N9LmApfXR5cGVvZiBleHBlY3QhPVwidW5kZWZpbmVkXCImJmV4cGVjdCgpLm5vdGhpbmcoKX1mdW5jdGlvbiBBTChlLHQpe2UoKS50aGVuKCgpPT50LmZhaWwoKSwoKT0+dCgpKSx0eXBlb2YgZXhwZWN0IT1cInVuZGVmaW5lZFwiJiZleHBlY3QoKS5ub3RoaW5nKCl9ZnVuY3Rpb24gRkwoZSx0KXtsZXQgbj10eXBlb2YgdD09XCJzdHJpbmdcInx8dHlwZW9mIHQ9PVwibnVtYmVyXCJ8fHR5cGVvZiB0PT1cImJvb2xlYW5cIj9bdF06dDtyZXR1cm4gSnIoZSl8fEpyKGVbMF0pfHxKcih0KXx8SnIodFswXSk/UngoZSxuLChhLHIpPT5hPT1yKTpSeChlLHQsKGEscik9PlR3KGEsciwwKSl9ZnVuY3Rpb24gJEwoZSx0LG4pe2lmKG49PW51bGwmJihuPU53KCkpLCFUdyhlLHQsbikpdGhyb3cgbmV3IEVycm9yKGBOdW1iZXJzIGRpZmZlcjogYWN0dWFsID09PSAke2V9LCBleHBlY3RlZCA9PT0gJHt0fWApO3R5cGVvZiBleHBlY3QhPVwidW5kZWZpbmVkXCImJmV4cGVjdCgpLm5vdGhpbmcoKX1mdW5jdGlvbiBUdyhlLHQsbil7cmV0dXJuIWlzRmluaXRlKGUpJiYhaXNGaW5pdGUodCk/ITA6IShpc05hTihlKXx8aXNOYU4odCl8fE1hdGguYWJzKGUtdCk+bil9ZnVuY3Rpb24gREwoZSx0LG4pe2ZvcihsZXQgYT0wO2E8ZS5sZW5ndGg7YSsrKWlmKGVbYV08dHx8ZVthXT5uKXRocm93IG5ldyBFcnJvcihgVmFsdWUgb3V0IG9mIHJhbmdlOiR7ZVthXX0gbG93OiAke3R9LCBoaWdoOiAke259YCl9ZnVuY3Rpb24gUkwoZSx0KXtsZXQgbj1uZXcgRmxvYXQzMkFycmF5KGUpLGE9bmV3IEZsb2F0MzJBcnJheSh0KTtpZihuLmxlbmd0aCE9PWEubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgQXJyYXlCdWZmZXIgdG8gYmUgb2YgbGVuZ3RoICR7YS5sZW5ndGh9LCBidXQgaXQgd2FzICR7bi5sZW5ndGh9YCk7Zm9yKGxldCByPTA7cjxhLmxlbmd0aDtyKyspaWYobltyXSE9PWFbcl0pdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBBcnJheUJ1ZmZlciB2YWx1ZSBhdCAke3J9IHRvIGJlICR7YVtyXX0gYnV0IGdvdCAke25bcl19IGluc3RlYWRgKX1mdW5jdGlvbiBRTihlKXtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl7bGV0IG49ZVt0XTtBcnJheS5pc0FycmF5KG4pP1FOKG4pOmVbdF09bmQobil9cmV0dXJuIGV9ZnVuY3Rpb24gTUwoZSl7bGV0IHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO3JldHVyblwicGxheXNJbmxpbmVcImluIHQmJih0LnBsYXlzSW5saW5lPSEwKSx0Lm11dGVkPSEwLHQubG9vcD0hMCx0LnN0eWxlLnBvc2l0aW9uPVwiZml4ZWRcIix0LnN0eWxlLmxlZnQ9XCIwcHhcIix0LnN0eWxlLnRvcD1cIjBweFwiLHQucHJlbG9hZD1cImF1dG9cIix0LmFwcGVuZENoaWxkKGUpLG5ldyBQcm9taXNlKG49Pnt0LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRkYXRhXCIsYT0+bih0KSksdC5sb2FkKCl9KX1hc3luYyBmdW5jdGlvbiBPTChlKXthd2FpdCBlLnBsYXkoKSxcInJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2tcImluIGUmJmF3YWl0IG5ldyBQcm9taXNlKHQ9PntlLnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2sodCl9KX12YXIgQ3c9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4sYSxyKXt0aGlzLm1lYW49ZSx0aGlzLnN0ZERldj10LHRoaXMuZHR5cGU9bix0aGlzLm5leHRWYWw9TmFOLHRoaXMudHJ1bmNhdGVkPWEsdGhpcy50cnVuY2F0ZWQmJih0aGlzLnVwcGVyPXRoaXMubWVhbit0aGlzLnN0ZERldioyLHRoaXMubG93ZXI9dGhpcy5tZWFuLXRoaXMuc3RkRGV2KjIpO2xldCBzPXJ8fE1hdGgucmFuZG9tKCk7dGhpcy5yYW5kb209U3cuYWxlYShzLnRvU3RyaW5nKCkpfW5leHRWYWx1ZSgpe2lmKCFpc05hTih0aGlzLm5leHRWYWwpKXtsZXQgYT10aGlzLm5leHRWYWw7cmV0dXJuIHRoaXMubmV4dFZhbD1OYU4sYX1sZXQgZSx0LG49ITE7Zm9yKDshbjspe2xldCBhLHIscztkbyBhPTIqdGhpcy5yYW5kb20oKS0xLHI9Mip0aGlzLnJhbmRvbSgpLTEscz1hKmErcipyO3doaWxlKHM+PTF8fHM9PT0wKTtsZXQgaT1NYXRoLnNxcnQoLTIqTWF0aC5sb2cocykvcyk7ZT10aGlzLm1lYW4rdGhpcy5zdGREZXYqYSppLHQ9dGhpcy5tZWFuK3RoaXMuc3RkRGV2KnIqaSwoIXRoaXMudHJ1bmNhdGVkfHx0aGlzLmlzVmFsaWRUcnVuY2F0ZWQoZSkpJiYobj0hMCl9cmV0dXJuKCF0aGlzLnRydW5jYXRlZHx8dGhpcy5pc1ZhbGlkVHJ1bmNhdGVkKHQpKSYmKHRoaXMubmV4dFZhbD10aGlzLmNvbnZlcnRWYWx1ZSh0KSksdGhpcy5jb252ZXJ0VmFsdWUoZSl9Y29udmVydFZhbHVlKGUpe3JldHVybiB0aGlzLmR0eXBlPT1udWxsfHx0aGlzLmR0eXBlPT09XCJmbG9hdDMyXCI/ZTpNYXRoLnJvdW5kKGUpfWlzVmFsaWRUcnVuY2F0ZWQoZSl7cmV0dXJuIGU8PXRoaXMudXBwZXImJmU+PXRoaXMubG93ZXJ9fSxQTD1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixhKXt0aGlzLmFscGhhPWUsdGhpcy5iZXRhPTEvdCx0aGlzLmR0eXBlPW47bGV0IHI9YXx8TWF0aC5yYW5kb20oKTt0aGlzLnJhbmR1PVN3LmFsZWEoci50b1N0cmluZygpKSx0aGlzLnJhbmRuPW5ldyBDdygwLDEsbiwhMSx0aGlzLnJhbmR1KCkpLGU8MT90aGlzLmQ9ZSsyLzM6dGhpcy5kPWUtMS8zLHRoaXMuYz0xL01hdGguc3FydCg5KnRoaXMuZCl9bmV4dFZhbHVlKCl7bGV0IGUsdCxuLGEscixzO2Zvcig7Oyl7ZG8gYT10aGlzLnJhbmRuLm5leHRWYWx1ZSgpLHM9MSt0aGlzLmMqYTt3aGlsZShzPD0wKTtpZihzKj1zKnMsZT1hKmEsdD0xLS4zMzEqZSplLG49LjUqZSt0aGlzLmQqKDEtcytNYXRoLmxvZyhzKSkscj10aGlzLnJhbmR1KCkscjx0fHxNYXRoLmxvZyhyKTxuKWJyZWFrfXJldHVybiBzPTEvdGhpcy5iZXRhKnRoaXMuZCpzLHRoaXMuYWxwaGE8MSYmKHMqPU1hdGgucG93KHRoaXMucmFuZHUoKSwxL3RoaXMuYWxwaGEpKSx0aGlzLmNvbnZlcnRWYWx1ZShzKX1jb252ZXJ0VmFsdWUoZSl7cmV0dXJuIHRoaXMuZHR5cGU9PT1cImZsb2F0MzJcIj9lOk1hdGgucm91bmQoZSl9fSxMTD1jbGFzc3tjb25zdHJ1Y3RvcihlPTAsdD0xLG4sYSl7aWYodGhpcy5jYW5SZXR1cm5GbG9hdD0oKT0+dGhpcy5kdHlwZT09bnVsbHx8dGhpcy5kdHlwZT09PVwiZmxvYXQzMlwiLHRoaXMubWluPWUsdGhpcy5yYW5nZT10LWUsdGhpcy5kdHlwZT1uLGE9PW51bGwmJihhPU1hdGgucmFuZG9tKCkpLHR5cGVvZiBhPT1cIm51bWJlclwiJiYoYT1hLnRvU3RyaW5nKCkpLCF0aGlzLmNhblJldHVybkZsb2F0KCkmJnRoaXMucmFuZ2U8PTEpdGhyb3cgbmV3IEVycm9yKGBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuICR7ZX0gLSAke3R9IDw9IDEgYW5kIGR0eXBlIGlzIG5vdCBmbG9hdGApO3RoaXMucmFuZG9tPVN3LmFsZWEoYSl9Y29udmVydFZhbHVlKGUpe3JldHVybiB0aGlzLmNhblJldHVybkZsb2F0KCk/ZTpNYXRoLnJvdW5kKGUpfW5leHRWYWx1ZSgpe3JldHVybiB0aGlzLmNvbnZlcnRWYWx1ZSh0aGlzLm1pbit0aGlzLnJhbmdlKnRoaXMucmFuZG9tKCkpfX07ZnVuY3Rpb24gekwoZSx0LG49MSxhPVwiZmxvYXQzMlwiLHIpe2lmKG5hKGUpLG49PW51bGwmJihuPTEpLGE9PW51bGwmJihhPVwiZmxvYXQzMlwiKSxhIT09XCJmbG9hdDMyXCImJmEhPT1cImludDMyXCIpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGUgJHthfWApO2xldCBzPW5ldyBQTCh0LG4sYSxyKSxpPU9lKGUsYSk7Zm9yKGxldCBvPTA7bzxpLnZhbHVlcy5sZW5ndGg7bysrKWkudmFsdWVzW29dPXMubmV4dFZhbHVlKCk7cmV0dXJuIGkudG9UZW5zb3IoKX12YXIgZVQ9TCh7cmFuZG9tR2FtbWFfOnpMfSk7ZnVuY3Rpb24gV0woZSx0PTAsbj0xLGEscil7aWYobmEoZSksYSE9bnVsbCYmYT09PVwiYm9vbFwiKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlICR7YX1gKTtsZXQgcz1uZXcgQ3codCxuLGEsITEsciksaT1PZShlLGEpO2ZvcihsZXQgbz0wO288aS52YWx1ZXMubGVuZ3RoO28rKylpLnZhbHVlc1tvXT1zLm5leHRWYWx1ZSgpO3JldHVybiBpLnRvVGVuc29yKCl9dmFyIFhtPUwoe3JhbmRvbU5vcm1hbF86V0x9KTtmdW5jdGlvbiBCTChlLHQsbil7aWYodCE9bnVsbCYmdD09PVwiYm9vbFwiKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlICR7dH1gKTtyZXR1cm4gWG0oZSwwLDEsdCxuKX12YXIgdFQ9TCh7cmFuZG9tU3RhbmRhcmROb3JtYWxfOkJMfSk7ZnVuY3Rpb24gVkwoZSx0PTAsbj0xLGE9XCJmbG9hdDMyXCIscil7bmEoZSk7bGV0IHM9T2UoZSxhKSxpPW5ldyBMTCh0LG4sbnVsbCxyKTtmb3IobGV0IG89MDtvPHMudmFsdWVzLmxlbmd0aDtvKyspcy52YWx1ZXNbb109aS5uZXh0VmFsdWUoKTtyZXR1cm4gcy50b1RlbnNvcigpfXZhciBFcz1MKHtyYW5kb21Vbmlmb3JtXzpWTH0pO2Z1bmN0aW9uIFVMKGUsdCxuLGEpe3JldHVybiBFcyhlLHQsbixcImludDMyXCIsYSl9dmFyIG5UPUwoe3JhbmRvbVVuaWZvcm1JbnRfOlVMfSk7ZnVuY3Rpb24gZ2koZSx0LG49MSxhPVwiZmxvYXQzMlwiKXtpZihuPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaGF2ZSBhIHN0ZXAgb2YgemVyb1wiKTtsZXQgcj17c3RhcnQ6ZSxzdG9wOnQsc3RlcDpuLGR0eXBlOmF9O3JldHVybiBQLnJ1bktlcm5lbChVYyx7fSxyKX1mdW5jdGlvbiBHTChlKXtsZXQgdD17aW5wdXQ6RShlLFwiaW5wdXRcIixcInJlYWxcIil9O3JldHVybiBQLnJ1bktlcm5lbChEbSx0KX12YXIgemw9TCh7cmVhbF86R0x9KTtmdW5jdGlvbiBITChlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJyZWNpcHJvY2FsXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoSW8sdCl9dmFyIEV3PUwoe3JlY2lwcm9jYWxfOkhMfSk7ZnVuY3Rpb24gakwoZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwicmVsdVwiKX07cmV0dXJuIFAucnVuS2VybmVsKFNvLHQpfXZhciBLZT1MKHtyZWx1XzpqTH0pO2Z1bmN0aW9uIHFMKGUpe2xldCB0PXt4OkUoZSxcInhcIixcInJlbHU2XCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoQ28sdCl9dmFyIFltPUwoe3JlbHU2XzpxTH0pO2Z1bmN0aW9uIEtMKGUsdCl7bGV0IG49e3g6RShlLFwieFwiLFwicmV2ZXJzZVwiKX0sYT17ZGltczp0fTtyZXR1cm4gUC5ydW5LZXJuZWwoRW8sbixhKX12YXIgYmE9TCh7cmV2ZXJzZV86S0x9KTtmdW5jdGlvbiBYTChlKXtsZXQgdD1FKGUsXCJ4XCIsXCJyZXZlcnNlXCIpO3JldHVybiBBKHQucmFuaz09PTEsKCk9PmBFcnJvciBpbiByZXZlcnNlMUQ6IHggbXVzdCBiZSByYW5rIDEgYnV0IGdvdCByYW5rICR7dC5yYW5rfS5gKSxiYSh0LDApfXZhciBhVD1MKHtyZXZlcnNlMWRfOlhMfSk7ZnVuY3Rpb24gWUwoZSx0KXtsZXQgbj1FKGUsXCJ4XCIsXCJyZXZlcnNlXCIpO3JldHVybiBBKG4ucmFuaz09PTIsKCk9PmBFcnJvciBpbiByZXZlcnNlMkQ6IHggbXVzdCBiZSByYW5rIDIgYnV0IGdvdCByYW5rICR7bi5yYW5rfS5gKSxiYShuLHQpfXZhciByVD1MKHtyZXZlcnNlMmRfOllMfSk7ZnVuY3Rpb24gWkwoZSx0KXtsZXQgbj1FKGUsXCJ4XCIsXCJyZXZlcnNlXCIpO3JldHVybiBBKG4ucmFuaz09PTMsKCk9PmBFcnJvciBpbiByZXZlcnNlM0Q6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rICR7bi5yYW5rfS5gKSxiYShuLHQpfXZhciBzVD1MKHtyZXZlcnNlM2RfOlpMfSk7ZnVuY3Rpb24gSkwoZSx0KXtsZXQgbj1FKGUsXCJ4XCIsXCJyZXZlcnNlXCIpO3JldHVybiBBKG4ucmFuaz09PTQsKCk9PmBFcnJvciBpbiByZXZlcnNlNEQ6IHggbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rICR7bi5yYW5rfS5gKSxiYShuLHQpfXZhciBpVD1MKHtyZXZlcnNlNGRfOkpMfSk7ZnVuY3Rpb24gUUwoZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwicm91bmRcIil9O3JldHVybiBQLnJ1bktlcm5lbChfbyx0KX12YXIgWm09TCh7cm91bmRfOlFMfSk7ZnVuY3Rpb24gZXooZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwicnNxcnRcIixcImZsb2F0MzJcIil9O3JldHVybiBQLnJ1bktlcm5lbChBbyx0KX12YXIgSm09TCh7cnNxcnRfOmV6fSk7ZnVuY3Rpb24gdHooZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwic2VsdVwiKX07cmV0dXJuIFAucnVuS2VybmVsKEZvLHQpfXZhciBRbT1MKHtzZWx1Xzp0en0pO2Z1bmN0aW9uIG56KGUsdCxuLGEscixzPVsxLDFdLGk9XCJOSFdDXCIpe2xldCBvPUUoZSxcInhcIixcInNlcGFyYWJsZUNvbnYyZFwiKSxsPUUodCxcImRlcHRod2lzZUZpbHRlclwiLFwic2VwYXJhYmxlQ29udjJkXCIpLHU9RShuLFwicG9pbnR3aXNlRmlsdGVyXCIsXCJzZXBhcmFibGVDb252MmRcIikscD1vLGQ9ITE7aWYoby5yYW5rPT09MyYmKGQ9ITAscD1XKG8sWzEsby5zaGFwZVswXSxvLnNoYXBlWzFdLG8uc2hhcGVbMl1dKSksaT09PVwiTkNIV1wiKXRocm93IG5ldyBFcnJvcihcInNlcGFyYWJsZUNvbnYyZCBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCBkYXRhRm9ybWF0IE5DSFc7IG9ubHkgTkhXQyBpcyBzdXBwb3J0ZWRcIik7QShwLnJhbms9PT00LCgpPT5gRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rICR7cC5yYW5rfS5gKSxBKGwucmFuaz09PTQsKCk9PmBFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IGRlcHRod2lzZSBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayAke2wucmFua30uYCksQSh1LnJhbms9PT00LCgpPT5gRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiBwb2ludHdpc2UgZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgJHtsLnJhbmt9LmApLEEodS5zaGFwZVswXT09PTEsKCk9PmBFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IHRoZSBmaXJzdCBkaW1lbnNpb24gb2YgcG9pbnR3aXNlIGZpbHRlciAgbXVzdCBiZSAxLCBidXQgZ290ICR7dS5zaGFwZVswXX0uYCksQSh1LnNoYXBlWzFdPT09MSwoKT0+YEVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogdGhlIHNlY29uZCBkaW1lbnNpb24gb2YgcG9pbnR3aXNlIGZpbHRlciBtdXN0IGJlIDEsIGJ1dCBnb3QgJHt1LnNoYXBlWzFdfS5gKTtsZXQgYz1sLnNoYXBlWzJdLGg9bC5zaGFwZVszXTtBKHUuc2hhcGVbMl09PT1jKmgsKCk9PmBFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IHRoZSB0aGlyZCBkaW1lbnNpb24gb2YgcG9pbnR3aXNlIGZpbHRlciBtdXN0IGJlICR7YypofSwgYnV0IGdvdCAke3Uuc2hhcGVbMl19LmApO2xldCBtPVRzKHAsbCxhLHIsaSxzKSxmPSR0KG0sdSwxLFwidmFsaWRcIixpKTtyZXR1cm4gZD9XKGYsW2Yuc2hhcGVbMV0sZi5zaGFwZVsyXSxmLnNoYXBlWzNdXSk6Zn12YXIgX3M9TCh7c2VwYXJhYmxlQ29udjJkXzpuen0pO2FzeW5jIGZ1bmN0aW9uIGF6KGUsdCl7bGV0IG49RShlLFwieFwiLFwic2V0ZGlmZjFkXCIpLGE9RSh0LFwieVwiLFwic2V0ZGlmZjFkXCIpO0Eobi5kdHlwZT09PWEuZHR5cGUsKCk9PmB4IGFuZCB5IHNob3VsZCBoYXZlIHRoZSBzYW1lIGR0eXBlLCBidXQgZ290IHggKCR7bi5kdHlwZX0pIGFuZCB5ICgke2EuZHR5cGV9KS5gKSxBKG4ucmFuaz09PTEsKCk9PmB4IHNob3VsZCBiZSAxRCB0ZW5zb3IsIGJ1dCBnb3QgeCAoJHtuLnNoYXBlfSkuYCksQShhLnJhbms9PT0xLCgpPT5geSBzaG91bGQgYmUgMUQgdGVuc29yLCBidXQgZ290IHkgKCR7YS5zaGFwZX0pLmApO2xldCByPWF3YWl0IG4uZGF0YSgpLHM9YXdhaXQgYS5kYXRhKCksaT1uZXcgU2V0KHMpLG89MDtmb3IobGV0IHA9MDtwPHIubGVuZ3RoO3ArKylpLmhhcyhyW3BdKXx8bysrO2xldCBsPW5ldyBXdChbb10sbi5kdHlwZSksdT1uZXcgV3QoW29dLFwiaW50MzJcIik7Zm9yKGxldCBwPTAsZD0wO3A8ci5sZW5ndGg7cCsrKWkuaGFzKHJbcF0pfHwobC52YWx1ZXNbZF09cltwXSx1LnZhbHVlc1tkXT1wLGQrKyk7cmV0dXJuW2wudG9UZW5zb3IoKSx1LnRvVGVuc29yKCldfXZhciBvVD1hejtmdW5jdGlvbiByeihlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJzaWduXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoUm8sdCl9dmFyIF93PUwoe3NpZ25fOnJ6fSk7ZnVuY3Rpb24gc3ooZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwic2luXCIsXCJmbG9hdDMyXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoJG8sdCl9dmFyIGVmPUwoe3Npbl86c3p9KTtmdW5jdGlvbiBpeihlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJzaW5oXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoRG8sdCl9dmFyIHRmPUwoe3NpbmhfOml6fSk7ZnVuY3Rpb24gb3ooZSx0LG4pe2xldCBhPUUoZSxcInhcIixcInNsaWNlMWRcIik7cmV0dXJuIEEoYS5yYW5rPT09MSwoKT0+YHNsaWNlMWQgZXhwZWN0cyBhIHJhbmstMSB0ZW5zb3IsIGJ1dCBnb3QgYSByYW5rLSR7YS5yYW5rfSB0ZW5zb3JgKSxWZShhLFt0XSxbbl0pfXZhciBnZD1MKHtzbGljZTFkXzpven0pO2Z1bmN0aW9uIGx6KGUsdCxuKXtsZXQgYT1FKGUsXCJ4XCIsXCJzbGljZTJkXCIpO3JldHVybiBBKGEucmFuaz09PTIsKCk9PmBzbGljZTJkIGV4cGVjdHMgYSByYW5rLTIgdGVuc29yLCBidXQgZ290IGEgcmFuay0ke2EucmFua30gdGVuc29yYCksVmUoYSx0LG4pfXZhciBuZj1MKHtzbGljZTJkXzpsen0pO2Z1bmN0aW9uIHV6KGUsdCxuKXtsZXQgYT1FKGUsXCJ4XCIsXCJzbGljZTNkXCIpO3JldHVybiBBKGEucmFuaz09PTMsKCk9PmBzbGljZTNkIGV4cGVjdHMgYSByYW5rLTMgdGVuc29yLCBidXQgZ290IGEgcmFuay0ke2EucmFua30gdGVuc29yYCksVmUoYSx0LG4pfXZhciBIbz1MKHtzbGljZTNkXzp1en0pO2Z1bmN0aW9uIHB6KGUsdCxuKXtsZXQgYT1FKGUsXCJ4XCIsXCJzbGljZTRkXCIpO3JldHVybiBBKGEucmFuaz09PTQsKCk9PmBzbGljZTRkIGV4cGVjdHMgYSByYW5rLTQgdGVuc29yLCBidXQgZ290IGEgcmFuay0ke2EucmFua30gdGVuc29yYCksVmUoYSx0LG4pfXZhciBXbD1MKHtzbGljZTRkXzpwen0pO2Z1bmN0aW9uIGN6KGUsdD0tMSl7bGV0IG49RShlLFwibG9naXRzXCIsXCJzb2Z0bWF4XCIsXCJmbG9hdDMyXCIpO2lmKHQ9PT0tMSYmKHQ9bi5yYW5rLTEpLHQhPT1uLnJhbmstMSl0aHJvdyBFcnJvcihgU29mdG1heCBhbG9uZyBhIG5vbi1sYXN0IGRpbWVuc2lvbiBpcyBub3QgeWV0IHN1cHBvcnRlZC4gTG9naXRzIHdhcyByYW5rICR7bi5yYW5rfSBhbmQgZGltIHdhcyAke3R9YCk7bGV0IGE9e2xvZ2l0czpufSxyPXtkaW06dH07cmV0dXJuIFAucnVuS2VybmVsKHpvLGEscil9dmFyIHFhPUwoe3NvZnRtYXhfOmN6fSk7ZnVuY3Rpb24gZHooZSl7QShlLmR0eXBlPT09XCJjb21wbGV4NjRcIiwoKT0+YFRoZSBkdHlwZSBmb3IgdGYuc3BlY3RyYWwuZmZ0KCkgbXVzdCBiZSBjb21wbGV4NjQgYnV0IGdvdCAke2UuZHR5cGV9LmApO2xldCB0PXtpbnB1dDplfTtyZXR1cm4gUC5ydW5LZXJuZWwoQ20sdCl9dmFyIGJkPUwoe2ZmdF86ZHp9KTtmdW5jdGlvbiBoeihlKXtBKGUuZHR5cGU9PT1cImNvbXBsZXg2NFwiLCgpPT5gVGhlIGR0eXBlIGZvciB0Zi5zcGVjdHJhbC5pZmZ0KCkgbXVzdCBiZSBjb21wbGV4NjQgYnV0IGdvdCAke2UuZHR5cGV9LmApO2xldCB0PXtpbnB1dDplfTtyZXR1cm4gUC5ydW5LZXJuZWwoRW0sdCl9dmFyIEJsPUwoe2lmZnRfOmh6fSk7ZnVuY3Rpb24gbXooZSl7bGV0IHQ9ZS5zaGFwZVtlLnNoYXBlLmxlbmd0aC0xXSxuPWUuc2l6ZS90LGE7aWYodDw9Mil7bGV0IHI9VyhlLFtuLHRdKTthPUJsKHIpfWVsc2V7bGV0IHI9W24sMioodC0xKV0scz1XKHpsKGUpLFtuLHRdKSxpPVcobGQoZSksW24sdF0pLG89YmEoVmUocyxbMCwxXSxbbix0LTJdKSwxKSxsPXooYmEoVmUoaSxbMCwxXSxbbix0LTJdKSwxKSx4ZSgtMSkpLHU9ZXQoW3Msb10sMSkscD1ldChbaSxsXSwxKSxkPVcoX3IodSxwKSxbclswXSxyWzFdXSk7YT1CbChkKX1pZihhPXpsKGEpLGUucmFuaz09PTMmJmUuc2hhcGVbMF0hPT0wKXtsZXQgcj1hLHM9ZS5zaGFwZVswXTthPVcoYSxbcyxhLnNoYXBlWzBdL3MsYS5zaGFwZVsxXV0pLHIuZGlzcG9zZSgpfXJldHVybiBhfXZhciBhZj1MKHtpcmZmdF86bXp9KTtmdW5jdGlvbiBmeihlLHQsbj0wKXtsZXQgYT17eDpFKGUsXCJ4XCIsXCJzcGxpdFwiKX0scj17bnVtT3JTaXplU3BsaXRzOnQsYXhpczpufTtyZXR1cm4gUC5ydW5LZXJuZWwoVXUsYSxyKX12YXIgTG49TCh7c3BsaXRfOmZ6fSk7ZnVuY3Rpb24gZ3ooZSx0KXtBKGUuZHR5cGU9PT1cImZsb2F0MzJcIiwoKT0+YFRoZSBkdHlwZSBmb3IgcmZmdCgpIG11c3QgYmUgcmVhbCB2YWx1ZSBidXQgZ290ICR7ZS5kdHlwZX1gKTtsZXQgbj1lLnNoYXBlW2Uuc2hhcGUubGVuZ3RoLTFdLGE9ZS5zaXplL24scjtpZih0IT1udWxsJiZ0PG4pe2xldCBtPWUuc2hhcGUubWFwKGc9PjApLGY9ZS5zaGFwZS5tYXAoZz0+Zyk7ZltlLnNoYXBlLmxlbmd0aC0xXT10LHI9VmUoZSxtLGYpLG49dH1lbHNlIGlmKHQhPW51bGwmJnQ+bil7bGV0IG09ZS5zaGFwZS5tYXAoZj0+Zik7bVtlLnNoYXBlLmxlbmd0aC0xXT10LW4scj1ldChbZSxJdChtKV0sZS5zaGFwZS5sZW5ndGgtMSksbj10fWVsc2Ugcj1lO2xldCBzPXFlKHIpLGk9VyhfcihyLHMpLFthLG5dKSxvPWJkKGkpLGw9TWF0aC5mbG9vcihuLzIpKzEsdT16bChvKSxwPWxkKG8pLGQ9TG4odSxbbCxuLWxdLHUuc2hhcGUubGVuZ3RoLTEpLGM9TG4ocCxbbCxuLWxdLHAuc2hhcGUubGVuZ3RoLTEpLGg9ci5zaGFwZS5zbGljZSgpO3JldHVybiBoW3Iuc2hhcGUubGVuZ3RoLTFdPWwsVyhfcihkWzBdLGNbMF0pLGgpfXZhciB5ZD1MKHtyZmZ0Xzpnen0pO2Z1bmN0aW9uIGJ6KGUsdCl7bGV0IG49RShlLFwiYVwiLFwic3F1YXJlZERpZmZlcmVuY2VcIiksYT1FKHQsXCJiXCIsXCJzcXVhcmVkRGlmZmVyZW5jZVwiKTtbbixhXT1fdChuLGEpLGN0KG4uc2hhcGUsYS5zaGFwZSk7bGV0IHI9e2E6bixiOmF9LHM9e307cmV0dXJuIFAucnVuS2VybmVsKFdvLHIscyl9dmFyIHJmPUwoe3NxdWFyZWREaWZmZXJlbmNlXzpien0pO2Z1bmN0aW9uIHl6KGUsdCl7bGV0IG49RShlLFwieFwiLFwic3F1ZWV6ZVwiLFwic3RyaW5nX29yX251bWVyaWNcIik7cmV0dXJuIFcobixNUyhuLnNoYXBlLHQpLm5ld1NoYXBlKX12YXIgQXM9TCh7c3F1ZWV6ZV86eXp9KTtmdW5jdGlvbiB4eihlLHQ9MCl7bGV0IG49YmMoZSxcInRlbnNvcnNcIixcInN0YWNrXCIsXCJzdHJpbmdfb3JfbnVtZXJpY1wiKTtBKG4ubGVuZ3RoPj0xLCgpPT5cIlBhc3MgYXQgbGVhc3Qgb25lIHRlbnNvciB0byB0Zi5zdGFja1wiKSxuLmxlbmd0aD4wJiZBKHQ8PW5bMF0ucmFuaywoKT0+XCJBeGlzIG11c3QgYmUgPD0gcmFuayBvZiB0aGUgdGVuc29yXCIpO2xldCBhPW4scj17YXhpczp0fTtyZXR1cm4gUC5ydW5LZXJuZWwoRHUsYSxyKX12YXIgQXQ9TCh7c3RhY2tfOnh6fSk7ZnVuY3Rpb24gdnooZSx0PTApe2xldCBuPXt4OkUoZSxcInhcIixcInN0ZXBcIil9LGE9e2FscGhhOnR9O3JldHVybiBQLnJ1bktlcm5lbChJcyxuLGEpfXZhciBqbz1MKHtzdGVwXzp2en0pO2Z1bmN0aW9uIHd6KGUsdCxuLGEscj0wLHM9MCxpPTAsbz0wLGw9MCl7bGV0IHU9e3g6RShlLFwieFwiLFwic3RyaWRlZFNsaWNlXCIsXCJzdHJpbmdfb3JfbnVtZXJpY1wiKX0scD17YmVnaW46dCxlbmQ6bixzdHJpZGVzOmEsYmVnaW5NYXNrOnIsZW5kTWFzazpzLGVsbGlwc2lzTWFzazppLG5ld0F4aXNNYXNrOm8sc2hyaW5rQXhpc01hc2s6bH07cmV0dXJuIFAucnVuS2VybmVsKGp1LHUscCl9dmFyIEF3PUwoe3N0cmlkZWRTbGljZV86d3p9KTtmdW5jdGlvbiBreihlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJ0YW5cIixcImZsb2F0MzJcIil9O3JldHVybiBQLnJ1bktlcm5lbChWbyx0KX12YXIgRnc9TCh7dGFuXzpren0pO2Z1bmN0aW9uIGplKGUsdCl7U2koZSk7bGV0IG49bHIoZSx0KTtpZihuLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yMWQoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgYSBmbGF0L1R5cGVkQXJyYXlcIik7cmV0dXJuIFNzKGUsbnVsbCxuLHQpfWZ1bmN0aW9uIEVhKGUsdCxuKXtpZihTaShlKSx0IT1udWxsJiZ0Lmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yMmQoKSByZXF1aXJlcyBzaGFwZSB0byBoYXZlIHR3byBudW1iZXJzXCIpO2xldCBhPWxyKGUsbik7aWYoYS5sZW5ndGghPT0yJiZhLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yMmQoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgbnVtYmVyW11bXSBvciBmbGF0L1R5cGVkQXJyYXlcIik7aWYoYS5sZW5ndGg9PT0xJiZ0PT1udWxsKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjJkKCkgcmVxdWlyZXMgc2hhcGUgdG8gYmUgcHJvdmlkZWQgd2hlbiBgdmFsdWVzYCBhcmUgYSBmbGF0L1R5cGVkQXJyYXlcIik7cmV0dXJuIFNzKGUsdCxhLG4pfWZ1bmN0aW9uIHhkKGUsdCxuKXtpZihTaShlKSx0IT1udWxsJiZ0Lmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yM2QoKSByZXF1aXJlcyBzaGFwZSB0byBoYXZlIHRocmVlIG51bWJlcnNcIik7bGV0IGE9bHIoZSxuKTtpZihhLmxlbmd0aCE9PTMmJmEubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IzZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdW10gb3IgZmxhdC9UeXBlZEFycmF5XCIpO2lmKGEubGVuZ3RoPT09MSYmdD09bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IzZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGJlIHByb3ZpZGVkIHdoZW4gYHZhbHVlc2AgYXJlIGEgZmxhdCBhcnJheVwiKTtyZXR1cm4gU3MoZSx0LGEsbil9ZnVuY3Rpb24gRmEoZSx0LG4pe2lmKFNpKGUpLHQhPW51bGwmJnQubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I0ZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGhhdmUgZm91ciBudW1iZXJzXCIpO2xldCBhPWxyKGUsbik7aWYoYS5sZW5ndGghPT00JiZhLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNGQoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgbnVtYmVyW11bXVtdW10gb3IgZmxhdC9UeXBlZEFycmF5XCIpO2lmKGEubGVuZ3RoPT09MSYmdD09bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I0ZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGJlIHByb3ZpZGVkIHdoZW4gYHZhbHVlc2AgYXJlIGEgZmxhdCBhcnJheVwiKTtyZXR1cm4gU3MoZSx0LGEsbil9ZnVuY3Rpb24gbFQoZSx0LG4pe2lmKFNpKGUpLHQhPW51bGwmJnQubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I1ZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGhhdmUgZml2ZSBudW1iZXJzXCIpO2xldCBhPWxyKGUsbik7aWYoYS5sZW5ndGghPT01JiZhLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNWQoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgbnVtYmVyW11bXVtdW11bXSBvciBmbGF0L1R5cGVkQXJyYXlcIik7aWYoYS5sZW5ndGg9PT0xJiZ0PT1udWxsKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjVkKCkgcmVxdWlyZXMgc2hhcGUgdG8gYmUgcHJvdmlkZWQgd2hlbiBgdmFsdWVzYCBhcmUgYSBmbGF0IGFycmF5XCIpO3JldHVybiBTcyhlLHQsYSxuKX1mdW5jdGlvbiB1VChlLHQsbil7aWYoU2koZSksdCE9bnVsbCYmdC5sZW5ndGghPT02KXRocm93IG5ldyBFcnJvcihcInRlbnNvcjZkKCkgcmVxdWlyZXMgc2hhcGUgdG8gaGF2ZSBzaXggbnVtYmVyc1wiKTtsZXQgYT1scihlLG4pO2lmKGEubGVuZ3RoIT09NiYmYS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjZkKCkgcmVxdWlyZXMgdmFsdWVzIHRvIGJlIG51bWJlcltdW11bXVtdW11bXSBvciBmbGF0L1R5cGVkQXJyYXlcIik7aWYoYS5sZW5ndGg9PT0xJiZ0PT1udWxsKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjZkKCkgcmVxdWlyZXMgc2hhcGUgdG8gYmUgcHJvdmlkZWQgd2hlbiBgdmFsdWVzYCBhcmUgYSBmbGF0IGFycmF5XCIpO3JldHVybiB0PXR8fGEsU3MoZSx0LGEsbil9dmFyIHNmPXt9O19lKHNmLHtjYWxjdWxhdGVTaGFwZXM6KCk9PnBULHZhbGlkYXRlSW5wdXQ6KCk9Pm9mLHZhbGlkYXRlVXBkYXRlU2hhcGU6KCk9PiR3fSk7ZnVuY3Rpb24gJHcoZSx0LG4pe2xldCBhPXQucmFuaz4xP3Quc2hhcGVbdC5yYW5rLTFdOjEscj10LnJhbms+MT90LnJhbmstMToxLHM9YE11c3QgaGF2ZSB1cGRhdGVzLnNoYXBlID0gaW5kaWNlcy5zaGFwZVs6YmF0Y2hEaW1dICsgc2hhcGVbc2xpY2VEaW06XSwgZ290IHVwZGF0ZXMuc2hhcGU6ICR7bi5zaGFwZX0sIGluZGljZXMuc2hhcGU6ICR7dC5zaGFwZX0sIHNoYXBlOiAke2V9LCBzbGljZURpbTogJHthfSwgYW5kIGJhdGNoRGltOiAke3J9LmA7aWYobi5yYW5rPHIpdGhyb3cgbmV3IEVycm9yKHMrYCB1cGRhdGUucmFuayA8ICR7cn0uIGApO2lmKGUubGVuZ3RoPGErKG4ucmFuay1yKSl0aHJvdyBuZXcgRXJyb3IocytgIE91dHB1dCBzaGFwZSBsZW5ndGggPCAke2ErKG4ucmFuay1yKX1gKTtpZihuLnJhbmshPT1yK2UubGVuZ3RoLWEpdGhyb3cgbmV3IEVycm9yKHMrYCB1cGRhdGUucmFuayAhPSAke3IrZS5sZW5ndGgtYX1gKTtmb3IobGV0IGk9MDtpPHI7KytpKWlmKG4uc2hhcGVbaV0hPT10LnNoYXBlW2ldKXRocm93IG5ldyBFcnJvcihzK2AgdXBkYXRlcy5zaGFwZVske2l9XSAoJHtuLnNoYXBlW2ldfSkgIT0gaW5kaWNlcy5zaGFwZVske2l9XSAoJHt0LnNoYXBlW2ldfSkuYCk7Zm9yKGxldCBpPTA7aTxuLnJhbmstcjsrK2kpaWYobi5zaGFwZVtpK3JdIT09ZVtpK2FdKXRocm93IG5ldyBFcnJvcihzK2AgdXBkYXRlcy5zaGFwZVske2krcn1dICgke24uc2hhcGVbaStyXX0pICE9IHNoYXBlWyR7aStyfV0gKCR7ZVtpK3JdfSlgKX1mdW5jdGlvbiBvZihlLHQsbil7aWYodC5yYW5rPDEpdGhyb3cgbmV3IEVycm9yKGB0Zi5zY2F0dGVyTkQoKSBleHBlY3RzIHRoZSBpbmRpY2VzIHRvIGJlIHJhbmsgMSBvciBoaWdoZXIsIGJ1dCB0aGUgcmFuayB3YXMgJHt0LnJhbmt9LmApO2lmKGUucmFuazwxKXRocm93IG5ldyBFcnJvcihgdGYuc2NhdHRlck5EKCkgZXhwZWN0cyB0aGUgdXBkYXRlcyB0byBiZSByYW5rIDEgb3IgaGlnaGVyLCBidXQgdGhlIHJhbmsgd2FzICR7ZS5yYW5rfS5gKTtpZih0LmR0eXBlIT09XCJpbnQzMlwiKXRocm93IG5ldyBFcnJvcihgVGhlIGR0eXBlIG9mICdpbmRpY2VzJyBzaG91bGQgYmUgaW50MzIsIGJ1dCBnb3QgZHR5cGU6ICR7dC5kdHlwZX1gKTtpZihuLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihgT3V0cHV0IHJhbmsgbXVzdCBiZSBncmVhdGVyIG9yIGVxdWFsIHRvIDEsIGJ1dCBnb3Qgc2hhcGU6ICR7bn1gKTtpZihuLmxlbmd0aD09PTApe2lmKHQuc2l6ZT09PTApdGhyb3cgbmV3IEVycm9yKGBJbmRpY2VzIHNwZWNpZmllZCBmb3IgZW1wdHkgb3V0cHV0LiBpbmRpY2VzIHNoYXBlOiAke3Quc2hhcGV9YCk7aWYoZS5zaXplPT09MCl0aHJvdyBuZXcgRXJyb3IoYFVwZGF0ZXMgc3BlY2lmaWVkIGZvciBlbXB0eSBvdXRwdXQuIHVwZGF0ZXMgc2hhcGU6ICR7ZS5zaGFwZX1gKX0kdyhuLHQsZSl9ZnVuY3Rpb24gcFQoZSx0LG4pe2xldCBhPXQuc2hhcGUubGVuZ3RoLHI9YT4xP3Quc2hhcGVbYS0xXToxLHM9bi5sZW5ndGgsaT0xO2ZvcihsZXQgZD1yO2Q8czsrK2QpaSo9bltkXTtsZXQgbz1yPDE/MTpyLGw9b3QodC5zaGFwZSkvbyx1PVsuLi5YbChuLnNsaWNlKDAscikpLDFdLHA9b3Qobik7cmV0dXJue3NsaWNlUmFuazpyLG51bVVwZGF0ZXM6bCxzbGljZVNpemU6aSxzdHJpZGVzOnUsb3V0cHV0U2l6ZTpwfX1mdW5jdGlvbiBJeihlLHQsbil7bGV0IGE9RShlLFwidGVuc29yXCIsXCJ0ZW5zb3JTY2F0dGVydXBkYXRlXCIpLHI9RSh0LFwiaW5kaWNlc1wiLFwidGVuc29yU2NhdHRlcnVwZGF0ZVwiLFwiaW50MzJcIikscz1FKG4sXCJ1cGRhdGVzXCIsXCJ0ZW5zb3JTY2F0dGVydXBkYXRlXCIpO2lmKG9mKHMscixhLnNoYXBlKSxhLmR0eXBlIT09cy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoYHRlbnNvciBhbmQgdXBkYXRlcyBtdXN0IGhhdmUgdGhlIHNhbWUgZHR5cGUsIGluc3RlYWQgdGhleSBhcmUgJHthLmR0eXBlfSBhbmQgJHtzLmR0eXBlfS5gKTtsZXQgaT17dGVuc29yOmEsaW5kaWNlczpyLHVwZGF0ZXM6c30sbz17fTtyZXR1cm4gUC5ydW5LZXJuZWwoTHUsaSxvKX12YXIgY1Q9TCh7dGVuc29yU2NhdHRlclVwZGF0ZV86SXp9KTtmdW5jdGlvbiBTeihlLHQ9MSxuPSEwKXtsZXQgYT1FKGUsXCJ4XCIsXCJ0b3BrXCIpO2lmKGEucmFuaz09PTApdGhyb3cgbmV3IEVycm9yKFwidG9waygpIGV4cGVjdHMgdGhlIGlucHV0IHRvIGJlIG9mIHJhbmsgMSBvciBoaWdoZXJcIik7bGV0IHI9YS5zaGFwZVthLnNoYXBlLmxlbmd0aC0xXTtpZih0PDApdGhyb3cgbmV3IEVycm9yKGAnaycgcGFzc2VkIHRvIHRvcGsoKSBtdXN0IGJlID49IDAgYnV0IGdvdCAke3R9YCk7aWYodD5yKXRocm93IG5ldyBFcnJvcihgJ2snIHBhc3NlZCB0byB0b3BrKCkgbXVzdCBiZSA8PSB0aGUgbGFzdCBkaW1lbnNpb24gKCR7cn0pIGJ1dCBnb3QgJHt0fWApO2xldCBzPXt4OmF9LGk9e2s6dCxzb3J0ZWQ6bn0sW28sbF09UC5ydW5LZXJuZWwocXUscyxpKTtyZXR1cm57dmFsdWVzOm8saW5kaWNlczpsfX12YXIgRHc9TCh7dG9wa186U3p9KTtmdW5jdGlvbiBOeihlLHQ9MCxuPTEsYSxyKXtpZihuYShlKSxhIT1udWxsJiZhPT09XCJib29sXCIpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZGF0YSB0eXBlICQgeyBkdHlwZSB9XCIpO2xldCBzPW5ldyBDdyh0LG4sYSwhMCxyKSxpPU9lKGUsYSk7Zm9yKGxldCBvPTA7bzxpLnZhbHVlcy5sZW5ndGg7bysrKWkudmFsdWVzW29dPXMubmV4dFZhbHVlKCk7cmV0dXJuIGkudG9UZW5zb3IoKX12YXIgbGY9TCh7dHJ1bmNhdGVkTm9ybWFsXzpOen0pO2Z1bmN0aW9uIFR6KGUsdD0wKXtsZXQgbj1FKGUsXCJ4XCIsXCJ1bmlxdWVcIixcInN0cmluZ19vcl9udW1lcmljXCIpO0Eobi5yYW5rPjAsKCk9PlwiVGhlIGlucHV0IHRlbnNvciBtdXN0IGJlIGF0IGxlYXN0IDFEXCIpO2xldCBhPXt4Om59LHI9e2F4aXM6dH0sW3MsaV09UC5ydW5LZXJuZWwoSmMsYSxyKTtyZXR1cm57dmFsdWVzOnMsaW5kaWNlczppfX12YXIgUnc9TCh7dW5pcXVlXzpUen0pO2Z1bmN0aW9uIEN6KGUsdCxuKXtsZXQgYT1FKGUsXCJ4XCIsXCJ1bnNvcnRlZFNlZ21lbnRTdW1cIikscj1FKHQsXCJzZWdtZW50SWRzXCIsXCJ1bnNvcnRlZFNlZ21lbnRTdW1cIixcImludDMyXCIpO0EoJGwobiksKCk9PlwibnVtU2VnbWVudHMgbXVzdCBiZSBvZiBkdHlwZSBpbnRcIik7bGV0IHM9e3g6YSxzZWdtZW50SWRzOnJ9LGk9e251bVNlZ21lbnRzOm59O3JldHVybiBQLnJ1bktlcm5lbChRYyxzLGkpfXZhciB1Zj1MKHt1bnNvcnRlZFNlZ21lbnRTdW1fOkN6fSk7ZnVuY3Rpb24gRXooZSx0PTApe2xldCBuPUUoZSxcInhcIixcInVuc3RhY2tcIixcInN0cmluZ19vcl9udW1lcmljXCIpO0EodD49LW4uc2hhcGUubGVuZ3RoJiZ0PG4uc2hhcGUubGVuZ3RoLCgpPT5gQXhpcyA9ICR7dH0gaXMgbm90IGluIFstJHtuLnNoYXBlLmxlbmd0aH0sICR7bi5zaGFwZS5sZW5ndGh9KWApO2xldCBhPXt2YWx1ZTpufSxyPXtheGlzOnR9O3JldHVybiBQLnJ1bktlcm5lbChYdSxhLHIpfXZhciBkdD1MKHt1bnN0YWNrXzpFen0pO2Z1bmN0aW9uIGRUKGUsdCl7cmV0dXJuIEttKGUsdCxcInJpZ2h0XCIpfWZ1bmN0aW9uIE13KGUsdD0hMCxuLGEpe3JldHVybiBQLm1ha2VWYXJpYWJsZShlLHQsbixhKX1mdW5jdGlvbiBoVChlLHQpe2xldCBuPVtdO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cysrKXRbc10mJm4ucHVzaChzKTtsZXQgYT1PZShlLFwiaW50MzJcIikscj1PZShbbi5sZW5ndGgsZS5sZW5ndGhdLFwiaW50MzJcIik7Zm9yKGxldCBzPTA7czxuLmxlbmd0aDtzKyspe2xldCBpPWEuaW5kZXhUb0xvYyhuW3NdKSxvPXMqZS5sZW5ndGg7ci52YWx1ZXMuc2V0KGksbyl9cmV0dXJuIHIudG9UZW5zb3IoKX1hc3luYyBmdW5jdGlvbiBfeihlKXtsZXQgdD1FKGUsXCJjb25kaXRpb25cIixcIndoZXJlQXN5bmNcIixcImJvb2xcIiksbj1hd2FpdCB0LmRhdGEoKSxhPWhUKHQuc2hhcGUsbik7cmV0dXJuIGUhPT10JiZ0LmRpc3Bvc2UoKSxhfXZhciBPdz1fejthc3luYyBmdW5jdGlvbiBBeihlLHQsbil7bGV0IGE9RShlLFwidGVuc29yXCIsXCJib29sTWFza1wiKSxyPUUodCxcIm1hc2tcIixcImJvb2xNYXNrXCIsXCJib29sXCIpLHM9bj09bnVsbD8wOm4saT1yLnJhbmssbz1hLnNoYXBlO0EoaT4wLCgpPT5cIm1hc2sgY2Fubm90IGJlIHNjYWxhclwiKSxObihvLnNsaWNlKHMscytpKSxyLnNoYXBlLFwibWFzaydzIHNoYXBlIG11c3QgbWF0Y2ggdGhlIGZpcnN0IEsgZGltZW5zaW9ucyBvZiB0ZW5zb3IncyBzaGFwZSxcIik7bGV0IGw9MTtmb3IobGV0IGY9cztmPHMraTtmKyspbCo9b1tmXTtsZXQgdT1vLnNsaWNlKDAscykuY29uY2F0KFtsXSxvLnNsaWNlKHMraSkpLHA9VyhhLHUpLGQ9VyhyLFstMV0pLGM9YXdhaXQgT3coZCksaD1BcyhjLFsxXSksbT1ucChwLGgscyk7cmV0dXJuIGUhPT1hJiZhLmRpc3Bvc2UoKSx0IT09ciYmci5kaXNwb3NlKCksaC5kaXNwb3NlKCkscC5kaXNwb3NlKCksZC5kaXNwb3NlKCksYy5kaXNwb3NlKCksbX12YXIgbVQ9QXo7ZnVuY3Rpb24gRnooZSx0LG4pe2xldCBhPUUoZSxcInhcIixcInRyYW5zcG9zZVwiKTtpZih0PT1udWxsJiYodD1hLnNoYXBlLm1hcCgoaSxvKT0+bykucmV2ZXJzZSgpKSxBKGEucmFuaz09PXQubGVuZ3RoLCgpPT5gRXJyb3IgaW4gdHJhbnNwb3NlOiByYW5rIG9mIGlucHV0ICR7YS5yYW5rfSBtdXN0IG1hdGNoIGxlbmd0aCBvZiBwZXJtICR7dH0uYCksdC5mb3JFYWNoKGk9PntBKGk+PTAmJmk8YS5yYW5rLCgpPT5gQWxsIGVudHJpZXMgaW4gJ3Blcm0nIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAke2EucmFuay0xfSBidXQgZ290ICR7dH1gKX0pLGEucmFuazw9MSlyZXR1cm4gYS5jbG9uZSgpO2xldCByPXt4OmF9LHM9e3Blcm06dH07cmV0dXJuIGEuZHR5cGU9PT1cImNvbXBsZXg2NFwiP08oKCk9PntsZXQgaT16bChhKSxvPWxkKGEpO3JldHVybiBpPVAucnVuS2VybmVsKENyLHt4Oml9LHMpLG89UC5ydW5LZXJuZWwoQ3Ise3g6b30scyksbiYmKG89eXQobykpLF9yKGksbyl9KTpQLnJ1bktlcm5lbChDcixyLHMpfXZhciBEZT1MKHt0cmFuc3Bvc2VfOkZ6fSk7ZnVuY3Rpb24gJHooZSx0LG4sYSxyPSEwKXtsZXQgcz1FKGUsXCJ2XCIsXCJtb3ZpbmdBdmVyYWdlXCIpLGk9RSh0LFwieFwiLFwibW92aW5nQXZlcmFnZVwiKSxvPUUobixcImRlY2F5XCIsXCJtb3ZpbmdBdmVyYWdlXCIpO3ROKHMsaSksQShBcihzLnNoYXBlLGkuc2hhcGUpLCgpPT5cIlNoYXBlIG1pc21hdGNoIGluIHYgYW5kIHhcIik7bGV0IGw9eGUoMSksdT1wZShsLG8pLHA9eihwZShpLHMpLHUpO2lmKHIpe0EoYSE9bnVsbCwoKT0+XCJXaGVuIHVzaW5nIHplcm9EZWJpYXM6IHRydWUsIHN0ZXAgaXMgcmVxdWlyZWQuXCIpO2xldCBkPUUoYSxcInN0ZXBcIixcIm1vdmluZ0F2ZXJhZ2VcIik7cD1oZShwLHBlKGwsdXIobyxkKSkpfXJldHVybiBYKHMscCl9dmFyIGZUPUwoe21vdmluZ0F2ZXJhZ2VfOiR6fSk7ZnVuY3Rpb24gRHooZSx0LG4pe25hKG4pO2xldCBhPUUoZSxcImluZGljZXNcIixcInNjYXR0ZXJORFwiLFwiaW50MzJcIikscj1FKHQsXCJ1cGRhdGVzXCIsXCJzY2F0dGVyTkRcIik7b2YocixhLG4pO2xldCBzPXtpbmRpY2VzOmEsdXBkYXRlczpyfSxpPXtzaGFwZTpufTtyZXR1cm4gUC5ydW5LZXJuZWwoUHUscyxpKX12YXIgZ1Q9TCh7c2NhdHRlck5EXzpEen0pO2Z1bmN0aW9uIFJ6KGUsdCxuLGEpe2lmKGUuZHR5cGUhPT1cImludDMyXCIpdGhyb3cgbmV3IEVycm9yKGB0Zi5zcGFyc2VUb0RlbnNlKCkgZXhwZWN0cyB0aGUgaW5kaWNlcyB0byBiZSBpbnQzMiB0eXBlLCBidXQgdGhlIGR0eXBlIHdhcyAke2UuZHR5cGV9LmApO2lmKGUucmFuaz4yKXRocm93IG5ldyBFcnJvcihgc3BhcnNlSW5kaWNlcyBzaG91bGQgYmUgYSBzY2FsYXIsIHZlY3Rvciwgb3IgbWF0cml4LCBidXQgZ290IHNoYXBlICR7ZS5zaGFwZX0uYCk7bGV0IHI9ZS5yYW5rPjA/ZS5zaGFwZVswXToxLHM9ZS5yYW5rPjE/ZS5zaGFwZVsxXToxO2lmKG4ubGVuZ3RoIT09cyl0aHJvdyBuZXcgRXJyb3IoYG91dHB1dFNoYXBlIGhhcyBpbmNvcnJlY3QgbnVtYmVyIG9mIGVsZW1lbnRzOiwgJHtuLmxlbmd0aH0sIHNob3VsZCBiZTogJHtzfS5gKTtsZXQgaT10LnNpemU7aWYoISh0LnJhbms9PT0wfHx0LnJhbms9PT0xJiZpPT09cikpdGhyb3cgbmV3IEVycm9yKGBzcGFyc2VWYWx1ZXMgaGFzIGluY29ycmVjdCBzaGFwZSAke3Quc2hhcGV9LCBzaG91bGQgYmUgW10gb3IgWyR7cn1dYCk7aWYodC5kdHlwZSE9PWEuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwic3BhcnNlVmFsdWVzLmR0eXBlIG11c3QgbWF0Y2ggZGVmYXVsdFZhbHVlcy5kdHlwZVwiKX1mdW5jdGlvbiBNeihlLHQsbixhPTApe25hKG4pO2xldCByPUUoZSxcInNwYXJzZUluZGljZXNcIixcInNwYXJzZVRvRGVuc2VcIixcImludDMyXCIpLHM9RSh0LFwic3BhcnNlVmFsdWVzXCIsXCJzcGFyc2VUb0RlbnNlXCIsXCJzdHJpbmdfb3JfbnVtZXJpY1wiKSxpPUUoYSxcImRlZmF1bHRWYWx1ZVwiLFwic3BhcnNlVG9EZW5zZVwiLHMuZHR5cGUpO1J6KHIscyxuLGkpO2xldCBvPXtzcGFyc2VJbmRpY2VzOnIsc3BhcnNlVmFsdWVzOnMsZGVmYXVsdFZhbHVlOml9LGw9e291dHB1dFNoYXBlOm59O3JldHVybiBQLnJ1bktlcm5lbChIdSxvLGwpfXZhciBiVD1MKHtzcGFyc2VUb0RlbnNlXzpNen0pO2Z1bmN0aW9uIE96KGUsdCl7bGV0IG49RSh0LFwiaW5kaWNlc1wiLFwiZ2F0aGVyTkRcIixcImludDMyXCIpLGE9e3BhcmFtczpFKGUsXCJ4XCIsXCJnYXRoZXJORFwiLFwic3RyaW5nX29yX251bWVyaWNcIiksaW5kaWNlczpufTtyZXR1cm4gUC5ydW5LZXJuZWwoZ3UsYSl9dmFyIHlUPUwoe2dhdGhlck5EXzpPen0pO2Z1bmN0aW9uIFB6KGUsdCl7aWYodD09bnVsbClyZXR1cm4gZS5zaGFwZS5zbGljZSgpO2lmKEFyKGUuc2hhcGUsdCkpcmV0dXJuIHQ7aWYoZS5zaGFwZS5sZW5ndGg9PT10Lmxlbmd0aCl7bGV0IG49W107Zm9yKGxldCBhPTA7YTxlLnNoYXBlLmxlbmd0aDthKyspdFthXT09bnVsbCYmZS5zaGFwZVthXSE9bnVsbD9uLnB1c2goZS5zaGFwZVthXSk6bi5wdXNoKHRbYV0pO3JldHVybiBufXJldHVybiB0fWZ1bmN0aW9uIEx6KGUsdCxuLGEpe2xldCByPUUoZSxcInhcIixcImRyb3BvdXRcIik7aWYoQShyLmR0eXBlPT09XCJmbG9hdDMyXCIsKCk9PmB4IGhhcyB0byBiZSBhIGZsb2F0aW5nIHBvaW50IHRlbnNvciBzaW5jZSBpdCdzIGdvaW5nIHRvIGJlIHNjYWxlZCwgYnV0IGdvdCBhICR7ci5kdHlwZX0gdGVuc29yIGluc3RlYWQuYCksQSh0Pj0wJiZ0PDEsKCk9PmByYXRlIG11c3QgYmUgYSBmbG9hdCBpbiB0aGUgcmFuZ2UgWzAsIDEpLCBidXQgZ290ICR7dH0uYCksdD09PTApcmV0dXJuIGUgaW5zdGFuY2VvZiBDZT9yLmNsb25lKCk6cjtsZXQgcz1QeihyLG4pLGk9MS10LG89aGUodHAoWChFcyhzLDAsMSxcImZsb2F0MzJcIixhKSxpKSksaSk7cmV0dXJuIHoocixvKX12YXIgUHc9TCh7ZHJvcG91dF86THp9KTtmdW5jdGlvbiBMdyhlKXtyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnBvdygyLE1hdGguY2VpbChNYXRoLmxvZyhlKS9NYXRoLmxvZygyKSkpKX1mdW5jdGlvbiBwZihlLHQsbil7bGV0IGE9MS1lJTIscj1uZXcgRmxvYXQzMkFycmF5KGUpO2ZvcihsZXQgcz0wO3M8ZTsrK3Mpe2xldCBpPTIqTWF0aC5QSSpzLyhlK2EtMSk7cltzXT10LW4qTWF0aC5jb3MoaSl9cmV0dXJuIGplKHIsXCJmbG9hdDMyXCIpfWFzeW5jIGZ1bmN0aW9uIHp6KGUsdCxuPTEpe2xldCBhPUUoZSxcInByZWRpY3Rpb25zXCIsXCJpblRvcEtcIikscj1FKHQsXCJ0YXJnZXRzXCIsXCJpblRvcEtcIik7QShhLnJhbms+MSwoKT0+YGluVG9wSygpIGV4cGVjdHMgdGhlIHByZWRpY3Rpb25zIHRvIGJlIG9mIHJhbmsgMiBvciBoaWdoZXIsIGJ1dCBnb3QgJHthLnJhbmt9YCksQShhLnJhbmstMT09PXIucmFuaywoKT0+YHByZWRpY3Rpb25zIHJhbmsgc2hvdWxkIGJlIDEgbGFyZ2VyIHRoYW4gdGFyZ2V0cyByYW5rLCBidXQgZ290IHByZWRpY3Rpb25zIHJhbmsgJHthLnJhbmt9IGFuZCB0YXJnZXRzIHJhbmsgJHtyLnJhbmt9YCksTm4oYS5zaGFwZS5zbGljZSgwLGEuc2hhcGUubGVuZ3RoLTEpLHIuc2hhcGUsXCJwcmVkaWN0aW9ucydzIHNoYXBlIHNob3VsZCBiZSBhbGlnbiB3aXRoIHRoZSB0YXJnZXRzJyBzaGFwZSwgZXhjZXB0IHRoZSBsYXN0IGRpbWVuc2lvbi5cIik7bGV0IHM9YS5zaGFwZVthLnNoYXBlLmxlbmd0aC0xXTtBKG4+MCYmbjw9cywoKT0+YCdrJyBwYXNzZWQgdG8gaW5Ub3BLKCkgbXVzdCBiZSA+IDAgJiYgPD0gdGhlIHByZWRpY3Rpb25zIGxhc3QgZGltZW5zaW9uICgke3N9KSwgYnV0IGdvdCAke259YCk7bGV0IGk9YXdhaXQgYS5kYXRhKCksbz1hd2FpdCByLmRhdGEoKSxbbCx1XT1baS5sZW5ndGgvcyxzXSxwPU9TKFwiYm9vbFwiLGwpO2ZvcihsZXQgZD0wO2Q8bDtkKyspe2xldCBjPWQqdSxoPWkuc3ViYXJyYXkoYyxjK3UpLG09W107Zm9yKGxldCBmPTA7ZjxoLmxlbmd0aDtmKyspbS5wdXNoKHt2YWx1ZTpoW2ZdLGluZGV4OmZ9KTttLnNvcnQoKGYsZyk9PmcudmFsdWUtZi52YWx1ZSkscFtkXT0wO2ZvcihsZXQgZj0wO2Y8bjtmKyspaWYobVtmXS5pbmRleD09PW9bZF0pe3BbZF09MTticmVha319cmV0dXJuIGUhPT1hJiZhLmRpc3Bvc2UoKSx0IT09ciYmci5kaXNwb3NlKCksYm4ocCxyLnNoYXBlLFwiYm9vbFwiKX12YXIgeFQ9enosVmw9e307X2UoVmwse2NvbnYyZDooKT0+VnosZGVwdGh3aXNlQ29udjJkOigpPT5qeixtYXRNdWw6KCk9Pkt6fSk7ZnVuY3Rpb24gV3ooZSx0LG4sYSxyLHM9XCJOSFdDXCIsaSl7bGV0IG89ZTtlLnJhbms9PT0zJiYobz1XKGUsWzEsZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl1dKSk7bGV0IGw9dDtsLnJhbms9PT0zJiYobD1XKHQsWzEsdC5zaGFwZVswXSx0LnNoYXBlWzFdLHQuc2hhcGVbMl1dKSksQShvLnJhbms9PT00LCgpPT5gRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCBzaGFwZSAke28uc2hhcGV9LmApLEEobC5yYW5rPT09NCwoKT0+YEVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZHkgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3Qgc2hhcGUgJHtsLnNoYXBlfS5gKSxBKG4ubGVuZ3RoPT09NCwoKT0+YEVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZmlsdGVyU2hhcGUgbXVzdCBiZSBsZW5ndGggNCwgYnV0IGdvdCAke259LmApO2xldCB1PXM9PT1cIk5IV0NcIj9vLnNoYXBlWzNdOm8uc2hhcGVbMV0scD1zPT09XCJOSFdDXCI/bC5zaGFwZVszXTpsLnNoYXBlWzFdO0EodT09PW5bMl0sKCk9PmBFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGRlcHRoIG9mIGlucHV0ICR7dX0pIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggaW4gZmlsdGVyICgke25bMl19LmApLEEocD09PW5bM10sKCk9PmBFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGRlcHRoIG9mIGR5ICgke3B9KSBtdXN0IG1hdGNoIG91dHB1dCBkZXB0aCBmb3IgZmlsdGVyICgke25bM119KS5gKSxUbihcImNvbnYyZERlckZpbHRlclwiLHIsaSk7bGV0IGQ9e3g6byxkeTpsfSxjPXtzdHJpZGVzOmEscGFkOnIsZGF0YUZvcm1hdDpzLGRpbVJvdW5kaW5nTW9kZTppLGZpbHRlclNoYXBlOm59O3JldHVybiBQLnJ1bktlcm5lbChrbSxkLGMpfXZhciB6dz1MKHtjb252MkRCYWNrcHJvcEZpbHRlcl86V3p9KTtmdW5jdGlvbiBjZihlLHQsbil7aWYobj09bnVsbHx8bj09PVwibGluZWFyXCIpcmV0dXJuIGU7aWYobj09PVwicmVsdVwiKXJldHVybiB6KGUsam8odCkpO3Rocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbXB1dGUgZ3JhZGllbnQgZm9yIGZ1c2VkIGFjdGl2YXRpb24gJHtufS5gKX1mdW5jdGlvbiBkZihlLHQpe2xldCBuPXQsYT1CdChlLnNoYXBlLHQuc2hhcGUpO3JldHVybiBhLmxlbmd0aD4wJiYobj1mZShuLGEpKSxXKG4sZS5zaGFwZSl9ZnVuY3Rpb24gaGYoZSx0LG4sYSl7aWYodD09PVwibGluZWFyXCIpcmV0dXJuIGU7aWYodD09PVwicmVsdVwiKXJldHVybiBLZShlKTtpZih0PT09XCJlbHVcIilyZXR1cm4gUXUoZSk7aWYodD09PVwicmVsdTZcIilyZXR1cm4gWW0oZSk7aWYodD09PVwicHJlbHVcIilyZXR1cm4gZmQoZSxuKTtpZih0PT09XCJsZWFreXJlbHVcIilyZXR1cm4gdWQoZSxhKTtpZih0PT09XCJzaWdtb2lkXCIpcmV0dXJuIGhhKGUpO3Rocm93IG5ldyBFcnJvcihgVW5rbm93biBmdXNlZCBhY3RpdmF0aW9uICR7dH0uYCl9dmFyIG1mPShlLHQpPT4hKGU+MCl8fHQ9PT1cImxpbmVhclwiO2Z1bmN0aW9uIEJ6KHt4OmUsZmlsdGVyOnQsc3RyaWRlczpuLHBhZDphLGRhdGFGb3JtYXQ6cj1cIk5IV0NcIixkaWxhdGlvbnM6cz1bMSwxXSxkaW1Sb3VuZGluZ01vZGU6aSxiaWFzOm8sYWN0aXZhdGlvbjpsPVwibGluZWFyXCIscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czp1LGxlYWt5cmVsdUFscGhhOnB9KXtpZihsPWx8fFwibGluZWFyXCIsbWYoUC5zdGF0ZS5ncmFkaWVudERlcHRoLGwpPT09ITEpe0Eocj09PVwiTkhXQ1wiLCgpPT5gRXJyb3IgaW4gZnVzZWQgY29udjJkOiBnb3QgZGF0YUZvcm1hdCBvZiAke3J9IGJ1dCBvbmx5IE5IV0MgaXMgY3VycmVudGx5IHN1cHBvcnRlZCBmb3IgdGhlIGNhc2Ugb2YgZ3JhZGllbnQgZGVwdGggaXMgMCBhbmQgdGhlIGFjdGl2YXRpb24gaXMgbm90IGxpbmVhci5gKTtsZXQgTj0kdChlLHQsbixhLHIscyxpKTtyZXR1cm4gbyE9bnVsbCYmKE49WChOLG8pKSxoZihOLGwsdSxwKX1sZXQgZD1FKGUsXCJ4XCIsXCJjb252MmRcIixcImZsb2F0MzJcIiksYz1FKHQsXCJmaWx0ZXJcIixcImNvbnYyZFwiLFwiZmxvYXQzMlwiKSxoPWQsbT0hMTtkLnJhbms9PT0zJiYobT0hMCxoPVcoZCxbMSxkLnNoYXBlWzBdLGQuc2hhcGVbMV0sZC5zaGFwZVsyXV0pKSxBKGgucmFuaz09PTQsKCk9PmBFcnJvciBpbiBmdXNlZCBjb252MmQ6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgJHtoLnJhbmt9LmApLEEoYy5yYW5rPT09NCwoKT0+YEVycm9yIGluIGZ1c2VkIGNvbnYyZDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgJHtjLnJhbmt9LmApLFRuKFwiZnVzZWQgY29udjJkXCIsYSxpKTtsZXQgZj1yPT09XCJOSFdDXCI/aC5zaGFwZVszXTpoLnNoYXBlWzFdO0EoYy5zaGFwZVsyXT09PWYsKCk9PmBFcnJvciBpbiBjb252MmQ6IGRlcHRoIG9mIGlucHV0ICgke2Z9KSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgJHtjLnNoYXBlWzJdfS5gKSxBKGRyKG4scyksKCk9PmBFcnJvciBpbiBjb252MkQ6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzICR7bn0gYW5kIGRpbGF0aW9ucyAnJHtzfSdgKTtsZXQgZz1zZChoLnNoYXBlLGMuc2hhcGUsbixzLGEsaSksYjtvIT1udWxsJiYoYj1FKG8sXCJiaWFzXCIsXCJmdXNlZCBjb252MmRcIiksW2JdPV90KGIsZCkscj09PVwiTkhXQ1wiP2N0KGcub3V0U2hhcGUsYi5zaGFwZSk6KEEoYi5zaGFwZS5sZW5ndGg8PTEsKCk9PmBFcnJvciBpbiBmdXNlZCBjb252MmQ6IG9ubHkgc3VwcG9ydHMgc2NhbGFyIG9yIDEtRCBUZW5zb3IgYmlhcyBmb3IgTkNIVyBmb3JtYXQgYnV0IGdvdCB0aGUgYmlhcyBvZiByYW5rLSR7Yi5zaGFwZS5sZW5ndGh9LmApLEEoYi5zaGFwZS5sZW5ndGg9PT0wfHxiLnNoYXBlWzBdPT09Zy5vdXRDaGFubmVsc3x8Yi5zaGFwZVswXT09PTEsKCk9PmBFcnJvciBpbiBmdXNlZCBjb252MmQ6IGJpYXMgc2hhcGUgKCR7Yi5zaGFwZX0pIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIG51bWJlciBvZiBvdXRwdXQgY2hhbm5lbHMgKCR7Zy5vdXRDaGFubmVsc30pYCkpKTtsZXQgeTtpZih1IT1udWxsKXtsZXQgTj11LnNoYXBlO2lmKEEoTi5sZW5ndGg8PTF8fE4ubGVuZ3RoPT09MywoKT0+YEVycm9yIGluIGZ1c2VkIGNvbnYyZDogb25seSBzdXBwb3J0cyBzY2FsYXIsIDEtRCBUZW5zb3Igb3IgMy1EIFRlbnNvciBQUmVMVSBhY3RpdmF0aW9uIHdlaWdodHMgYnV0IGdvdCBhIHRlbnNvciBvZiByYW5rLSR7Ti5sZW5ndGh9LmApLE4ubGVuZ3RoPT09MSlBKE5bMF09PT0xfHxOWzBdPT09Zy5vdXRDaGFubmVscywoKT0+YEVycm9yIGluIGZ1c2VkIGNvbnYyZDogUFJlTFUgYWN0aXZhdGlvbiB3ZWlnaHRzICgke059KSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBudW1iZXIgb2Ygb3V0cHV0IGNoYW5uZWxzICgke2cub3V0Q2hhbm5lbHN9KS5gKTtlbHNlIGlmKE4ubGVuZ3RoPT09Myl0cnl7Y3QoTixnLm91dFNoYXBlKX1jYXRjaChDKXtsZXQgXz1gRXJyb3IgaW4gZnVzZWQgY29udjJkOiBQUmVMVSBhY3RpdmF0aW9uIHdlaWdodHMgKCR7Tn0pIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIG91dHB1dCBzaGFwZSBvZiB0aGUgY29udjJkICgke2cub3V0U2hhcGV9KS5gO3Rocm93IEVycm9yKF8pfXk9RSh1LFwicHJlbHUgd2VpZ2h0c1wiLFwiZnVzZWQgY29udjJkXCIpfWxldCB4PShOLEMpPT57QShyPT09XCJOSFdDXCIsKCk9PmBFcnJvciBpbiBncmFkaWVudCBvZiBmdXNlZCBjb252MkQ6IGdvdCBkYXRhRm9ybWF0IG9mICR7cn0gYnV0IG9ubHkgTkhXQyBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLmApO2xldFtfLEYsRCwkXT1DLFM9Y2YoTixELGwpO0EocHMocyksKCk9PmBFcnJvciBpbiBncmFkaWVudCBvZiBmdXNlZCBjb252MkQ6IGRpbGF0aW9uIHJhdGVzIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3QgeWV0IHN1cHBvcnRlZCBpbiBncmFkaWVudHMuIEdvdCBkaWxhdGlvbnMgJyR7c30nYCk7bGV0IE09bncoRi5zaGFwZSxTLF8sbixhKSxCPXp3KEYsUyxfLnNoYXBlLG4sYSksVT1bTSxCXTtpZigkIT1udWxsKXtsZXQgSD1kZigkLFMpO1UucHVzaChIKX1yZXR1cm4gVX0sdj17eDpoLGZpbHRlcjpjLGJpYXM6YixwcmVsdUFjdGl2YXRpb25XZWlnaHRzOnl9LEk9e3N0cmlkZXM6bixwYWQ6YSxkYXRhRm9ybWF0OnIsZGlsYXRpb25zOnMsZGltUm91bmRpbmdNb2RlOmksYWN0aXZhdGlvbjpsLGxlYWt5cmVsdUFscGhhOnB9O3JldHVybiBvPT1udWxsP3ByKChOLEMsXyk9PntsZXQgRj1QLnJ1bktlcm5lbChvaSx2LEkpO3JldHVybiBfKFtDLE4sRl0pLG0mJihGPVcoRixbRi5zaGFwZVsxXSxGLnNoYXBlWzJdLEYuc2hhcGVbM11dKSkse3ZhbHVlOkYsZ3JhZEZ1bmM6eH19KShoLGMpOnByKChOLEMsXyxGKT0+e2xldCBEPVAucnVuS2VybmVsKG9pLHYsSSk7cmV0dXJuIEYoW0MsTixELF9dKSxtJiYoRD1XKEQsW0Quc2hhcGVbMV0sRC5zaGFwZVsyXSxELnNoYXBlWzNdXSkpLHt2YWx1ZTpELGdyYWRGdW5jOnh9fSkoaCxjLGIpfXZhciBWej1MKHtmdXNlZENvbnYyZF86Qnp9KTtmdW5jdGlvbiBVeihlLHQsbixhLHIscz1bMSwxXSxpKXtsZXQgbz1lO2UucmFuaz09PTMmJihvPVcoZSxbMSxlLnNoYXBlWzBdLGUuc2hhcGVbMV0sZS5zaGFwZVsyXV0pKTtsZXQgbD10O2wucmFuaz09PTMmJihsPVcodCxbMSx0LnNoYXBlWzBdLHQuc2hhcGVbMV0sdC5zaGFwZVsyXV0pKTtsZXQgdT17eDpvLGR5Omx9LHA9e3N0cmlkZXM6YSxwYWQ6cixkaW1Sb3VuZGluZ01vZGU6aSxkaWxhdGlvbnM6cyxmaWx0ZXJTaGFwZTpufTtyZXR1cm4gUC5ydW5LZXJuZWwoSW0sdSxwKX12YXIgdlQ9TCh7ZGVwdGh3aXNlQ29udjJkTmF0aXZlQmFja3Byb3BGaWx0ZXJfOlV6fSk7ZnVuY3Rpb24gR3ooZSx0LG4sYSxyLHM9WzEsMV0saSl7bGV0IG89dCxsPSExO3QucmFuaz09PTMmJihsPSEwLG89Vyh0LFsxLHQuc2hhcGVbMF0sdC5zaGFwZVsxXSx0LnNoYXBlWzJdXSkpO2xldCB1PXtkeTpvLGZpbHRlcjpufSxwPXtzdHJpZGVzOmEscGFkOnIsZGltUm91bmRpbmdNb2RlOmksZGlsYXRpb25zOnMsaW5wdXRTaGFwZTplfSxkPVAucnVuS2VybmVsKFNtLHUscCk7cmV0dXJuIGw/VyhkLFtkLnNoYXBlWzFdLGQuc2hhcGVbMl0sZC5zaGFwZVszXV0pOmR9dmFyIHdUPUwoe2RlcHRod2lzZUNvbnYyZE5hdGl2ZUJhY2twcm9wSW5wdXRfOkd6fSk7ZnVuY3Rpb24gSHooe3g6ZSxmaWx0ZXI6dCxzdHJpZGVzOm4scGFkOmEsZGF0YUZvcm1hdDpyPVwiTkhXQ1wiLGRpbGF0aW9uczpzPVsxLDFdLGRpbVJvdW5kaW5nTW9kZTppLGJpYXM6byxhY3RpdmF0aW9uOmw9XCJsaW5lYXJcIixwcmVsdUFjdGl2YXRpb25XZWlnaHRzOnUsbGVha3lyZWx1QWxwaGE6cH0pe2lmKG1mKFAuc3RhdGUuZ3JhZGllbnREZXB0aCxsKT09PSExKXtsZXQgST1UcyhlLHQsbixhLHIscyxpKTtyZXR1cm4gbyE9bnVsbCYmKEk9WChJLG8pKSxoZihJLGwsdSxwKX1sZXQgZD1FKGUsXCJ4XCIsXCJkZXB0aHdpc2VDb252MmRcIixcImZsb2F0MzJcIiksYz1FKHQsXCJmaWx0ZXJcIixcImRlcHRod2lzZUNvbnYyZFwiLFwiZmxvYXQzMlwiKSxoPWQsbT0hMTtkLnJhbms9PT0zJiYobT0hMCxoPVcoZCxbMSxkLnNoYXBlWzBdLGQuc2hhcGVbMV0sZC5zaGFwZVsyXV0pKSxBKGgucmFuaz09PTQsKCk9PmBFcnJvciBpbiBmdXNlZCBkZXB0aHdpc2VDb252MmQ6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgJHtoLnJhbmt9LmApLEEoYy5yYW5rPT09NCwoKT0+YEVycm9yIGluIGZ1c2VkIGRlcHRod2lzZUNvbnYyZDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgJHtjLnJhbmt9LmApLEEoaC5zaGFwZVszXT09PWMuc2hhcGVbMl0sKCk9PmBFcnJvciBpbiBmdXNlZCBkZXB0aHdpc2VDb252MmQ6IG51bWJlciBvZiBpbnB1dCBjaGFubmVscyAoJHtoLnNoYXBlWzNdfSkgbXVzdCBtYXRjaCB0aGUgaW5DaGFubmVscyBkaW1lbnNpb24gaW4gZmlsdGVyICR7Yy5zaGFwZVsyXX0uYCkscz09bnVsbCYmKHM9WzEsMV0pLEEoZHIobixzKSwoKT0+YEVycm9yIGluIGZ1c2VkIGRlcHRod2lzZUNvbnYyZDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgJHtufSBhbmQgZGlsYXRpb25zICcke3N9J2ApLFRuKFwiZnVzZWQgZGVwdGh3aXNlQ29udjJkXCIsYSxpKTtsZXQgZj1zZChoLnNoYXBlLGMuc2hhcGUsbixzLGEsaSwhMCksZztvIT1udWxsJiYoZz1FKG8sXCJiaWFzXCIsXCJmdXNlZCBjb252MmRcIiksW2ddPV90KGcsZCksY3QoZi5vdXRTaGFwZSxnLnNoYXBlKSk7bGV0IGI7dSE9bnVsbCYmKGI9RSh1LFwicHJlbHUgd2VpZ2h0c1wiLFwiZnVzZWQgZGVwdGh3aXNlQ29udjJkXCIpKTtsZXQgeT0oSSxOKT0+e0EocHMocyksKCk9PmBFcnJvciBpbiBncmFkaWVudCBvZiBmdXNlZCBkZXB0aHdpc2VDb252MmQ6IGRpbGF0aW9uIHJhdGVzIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3QgeWV0IHN1cHBvcnRlZC4gR290IGRpbGF0aW9ucyAnJHtzfSdgKTtsZXRbQyxfLEYsRF09TiwkPWNmKEksRixsKSxTPXdUKF8uc2hhcGUsJCxDLG4sYSxzLGkpLE09dlQoXywkLEMuc2hhcGUsbixhLHMsaSk7aWYoRCE9bnVsbCl7bGV0IEI9ZGYoZywkKTtyZXR1cm5bUyxNLEJdfXJldHVybltTLE1dfSx4PXt4OmgsZmlsdGVyOmMsYmlhczpnLHByZWx1QWN0aXZhdGlvbldlaWdodHM6Yn0sdj17c3RyaWRlczpuLHBhZDphLGRhdGFGb3JtYXQ6cixkaWxhdGlvbnM6cyxkaW1Sb3VuZGluZ01vZGU6aSxhY3RpdmF0aW9uOmwsbGVha3lyZWx1QWxwaGE6cH07cmV0dXJuIG89PW51bGw/cHIoKEksTixDKT0+e2xldCBfPVAucnVuS2VybmVsKGxpLHgsdik7cmV0dXJuIEMoW04sSSxfXSksbSYmKF89VyhfLFtfLnNoYXBlWzFdLF8uc2hhcGVbMl0sXy5zaGFwZVszXV0pKSx7dmFsdWU6XyxncmFkRnVuYzp5fX0pKGgsYyk6cHIoKEksTixDLF8pPT57bGV0IEY9UC5ydW5LZXJuZWwobGkseCx2KTtyZXR1cm4gXyhbTixJLEYsQ10pLG0mJihGPVcoRixbRi5zaGFwZVsxXSxGLnNoYXBlWzJdLEYuc2hhcGVbM11dKSkse3ZhbHVlOkYsZ3JhZEZ1bmM6eX19KShoLGMsZyl9dmFyIGp6PUwoe2Z1c2VkRGVwdGh3aXNlQ29udjJkXzpIen0pO2Z1bmN0aW9uIHF6KHthOmUsYjp0LHRyYW5zcG9zZUE6bj0hMSx0cmFuc3Bvc2VCOmE9ITEsYmlhczpyLGFjdGl2YXRpb246cz1cImxpbmVhclwiLHByZWx1QWN0aXZhdGlvbldlaWdodHM6aSxsZWFreXJlbHVBbHBoYTpvPS4yfSl7aWYobWYoUC5zdGF0ZS5ncmFkaWVudERlcHRoLHMpPT09ITEpe2xldCBEPSRlKGUsdCxuLGEpO3JldHVybiByIT1udWxsJiYoRD1YKEQscikpLGhmKEQscyxpLG8pfWxldCBsPUUoZSxcImFcIixcImZ1c2VkIG1hdE11bFwiKSx1PUUodCxcImJcIixcImZ1c2VkIG1hdE11bFwiKTtbbCx1XT1fdChsLHUpO2xldCBwPW4/bC5zaGFwZVtsLnJhbmstMl06bC5zaGFwZVtsLnJhbmstMV0sZD1hP3Uuc2hhcGVbdS5yYW5rLTFdOnUuc2hhcGVbdS5yYW5rLTJdLGM9bj9sLnNoYXBlW2wucmFuay0xXTpsLnNoYXBlW2wucmFuay0yXSxoPWE/dS5zaGFwZVt1LnJhbmstMl06dS5zaGFwZVt1LnJhbmstMV0sbT1sLnNoYXBlLnNsaWNlKDAsLTIpLGY9dS5zaGFwZS5zbGljZSgwLC0yKSxnPW90KG0pLGI9b3QoZik7QShwPT09ZCwoKT0+YEVycm9yIGluIGZ1c2VkIG1hdE11bDogaW5uZXIgc2hhcGVzICgke3B9KSBhbmQgKCR7ZH0pIG9mIFRlbnNvcnMgd2l0aCBzaGFwZXMgJHtsLnNoYXBlfSBhbmQgJHt1LnNoYXBlfSBhbmQgdHJhbnNwb3NlQT0ke259IGFuZCB0cmFuc3Bvc2VCPSR7YX0gbXVzdCBtYXRjaC5gKTtsZXQgeT1jdChsLnNoYXBlLnNsaWNlKDAsLTIpLHUuc2hhcGUuc2xpY2UoMCwtMikpLmNvbmNhdChbYyxoXSkseD1uP1cobCxbZyxwLGNdKTpXKGwsW2csYyxwXSksdj1hP1codSxbYixoLGRdKTpXKHUsW2IsZCxoXSksSTtyIT1udWxsJiYoST1FKHIsXCJiaWFzXCIsXCJmdXNlZCBtYXRNdWxcIiksW0ldPV90KEksbCksY3QoeSxJLnNoYXBlKSk7bGV0IE47aSE9bnVsbCYmKE49RShpLFwicHJlbHUgd2VpZ2h0c1wiLFwiZnVzZWQgbWF0TXVsXCIpKTtsZXQgQz0oRCwkKT0+e2xldFtTLE0sQixVXT0kLEg9Y2YoVyhELEIuc2hhcGUpLEIscykscSxLO2lmKCFuJiYhYT8ocT0kZShILE0sITEsITApLEs9JGUoUyxILCEwLCExKSk6IW4mJmE/KHE9JGUoSCxNLCExLCExKSxLPSRlKEgsUywhMCwhMSkpOm4mJiFhPyhxPSRlKE0sSCwhMSwhMCksSz0kZShTLEgsITEsITEpKToocT0kZShNLEgsITAsITApLEs9JGUoSCxTLCEwLCEwKSksciE9bnVsbCl7bGV0IFo9ZGYoVSxIKTtyZXR1cm5bcSxLLFpdfWVsc2UgcmV0dXJuW3EsS119LF89e2E6eCxiOnYsYmlhczpJLHByZWx1QWN0aXZhdGlvbldlaWdodHM6Tn0sRj17dHJhbnNwb3NlQTpuLHRyYW5zcG9zZUI6YSxhY3RpdmF0aW9uOnMsbGVha3lyZWx1QWxwaGE6b307cmV0dXJuIHI9PW51bGw/cHIoKEQsJCxTKT0+e2xldCBNPVAucnVuS2VybmVsKGlpLF8sRik7cmV0dXJuIFMoW0QsJCxNXSkse3ZhbHVlOlcoTSx5KSxncmFkRnVuYzpDfX0pKHgsdik6cHIoKEQsJCxTLE0pPT57bGV0IEI9UC5ydW5LZXJuZWwoaWksXyxGKTtyZXR1cm4gTShbRCwkLEIsU10pLHt2YWx1ZTpXKEIseSksZ3JhZEZ1bmM6Q319KSh4LHYsSSl9dmFyIEt6PUwoe2Z1c2VkTWF0TXVsXzpxen0pO2Z1bmN0aW9uIFh6KGUpe3JldHVybiBwZihlLC41NCwuNDYpfXZhciBZej1MKHtoYW1taW5nV2luZG93XzpYen0pO2Z1bmN0aW9uIFp6KGUpe3JldHVybiBwZihlLC41LC41KX12YXIga1Q9TCh7aGFubldpbmRvd186Wnp9KTtmdW5jdGlvbiBKeihlLHQsbixhPSExLHI9MCl7bGV0IHM9MCxpPVtdO2Zvcig7cyt0PD1lLnNpemU7KWkucHVzaChWZShlLHMsdCkpLHMrPW47aWYoYSlmb3IoO3M8ZS5zaXplOyl7bGV0IG89cyt0LWUuc2l6ZSxsPWV0KFtWZShlLHMsdC1vKSx5bihbb10scildKTtpLnB1c2gobCkscys9bn1yZXR1cm4gaS5sZW5ndGg9PT0wP0VhKFtdLFswLHRdKTpXKGV0KGkpLFtpLmxlbmd0aCx0XSl9dmFyIElUPUwoe2ZyYW1lXzpKen0pO2Z1bmN0aW9uIFF6KGUsdCxuLGEscj1rVCl7YT09bnVsbCYmKGE9THcodCkpO2xldCBzPUlUKGUsdCxuKSxpPXoocyxyKHQpKTtyZXR1cm4geWQoaSxhKX12YXIgZVc9TCh7c3RmdF86UXp9KTtmdW5jdGlvbiB0VyhlLHQsbixhLHI9XCJiaWxpbmVhclwiLHM9MCl7bGV0IGk9RShlLFwiaW1hZ2VcIixcImNyb3BBbmRSZXNpemVcIiksbz1FKHQsXCJib3hlc1wiLFwiY3JvcEFuZFJlc2l6ZVwiLFwiZmxvYXQzMlwiKSxsPUUobixcImJveEluZFwiLFwiY3JvcEFuZFJlc2l6ZVwiLFwiaW50MzJcIiksdT1vLnNoYXBlWzBdO0EoaS5yYW5rPT09NCwoKT0+YEVycm9yIGluIGNyb3BBbmRSZXNpemU6IGltYWdlIG11c3QgYmUgcmFuayA0LGJ1dCBnb3QgcmFuayAke2kucmFua30uYCksQShvLnJhbms9PT0yJiZvLnNoYXBlWzFdPT09NCwoKT0+YEVycm9yIGluIGNyb3BBbmRSZXNpemU6IGJveGVzIG11c3QgYmUgaGF2ZSBzaXplIFske3V9LDRdIGJ1dCBoYWQgc2hhcGUgJHtvLnNoYXBlfS5gKSxBKGwucmFuaz09PTEmJmwuc2hhcGVbMF09PT11LCgpPT5gRXJyb3IgaW4gY3JvcEFuZFJlc2l6ZTogYm94SW5kIG11c3QgYmUgaGF2ZSBzaXplIFske3V9XSBidXQgaGFkIHNoYXBlICR7by5zaGFwZX0uYCksQShhLmxlbmd0aD09PTIsKCk9PmBFcnJvciBpbiBjcm9wQW5kUmVzaXplOiBjcm9wU2l6ZSBtdXN0IGJlIG9mIGxlbmd0aCAyLCBidXQgZ290IGxlbmd0aCAke2EubGVuZ3RofS5gKSxBKGFbMF0+PTEmJmFbMV0+PTEsKCk9PmBjcm9wU2l6ZSBtdXN0IGJlIGF0bGVhc3QgWzEsMV0sIGJ1dCB3YXMgJHthfWApLEEocj09PVwiYmlsaW5lYXJcInx8cj09PVwibmVhcmVzdFwiLCgpPT5gbWV0aG9kIG11c3QgYmUgYmlsaW5lYXIgb3IgbmVhcmVzdCwgYnV0IHdhcyAke3J9YCk7bGV0IHA9e2ltYWdlOmksYm94ZXM6byxib3hJbmQ6bH0sZD17bWV0aG9kOnIsZXh0cmFwb2xhdGlvblZhbHVlOnMsY3JvcFNpemU6YX07cmV0dXJuIFAucnVuS2VybmVsKHV1LHAsZCl9dmFyIG5XPUwoe2Nyb3BBbmRSZXNpemVfOnRXfSk7ZnVuY3Rpb24gYVcoZSl7bGV0IHQ9RShlLFwiaW1hZ2VcIixcImZsaXBMZWZ0UmlnaHRcIixcImZsb2F0MzJcIik7QSh0LnJhbms9PT00LCgpPT5gRXJyb3IgaW4gZmxpcExlZnRSaWdodDogaW1hZ2UgbXVzdCBiZSByYW5rIDQsYnV0IGdvdCByYW5rICR7dC5yYW5rfS5gKTtsZXQgbj17aW1hZ2U6dH07cmV0dXJuIFAucnVuS2VybmVsKG11LG4se30pfXZhciByVz1MKHtmbGlwTGVmdFJpZ2h0XzphV30pO2Z1bmN0aW9uIHNXKGUpe2xldCB0PUUoZSxcImltYWdlXCIsXCJncmF5c2NhbGVUb1JHQlwiKSxuPXQucmFuay0xLGE9dC5zaGFwZVtuXTtBKHQucmFuaz49MiwoKT0+YEVycm9yIGluIGdyYXlzY2FsZVRvUkdCOiBpbWFnZXMgbXVzdCBiZSBhdCBsZWFzdCByYW5rIDIsIGJ1dCBnb3QgcmFuayAke3QucmFua30uYCksQShhPT09MSwoKT0+YEVycm9yIGluIGdyYXlzY2FsZVRvUkdCOiBsYXN0IGRpbWVuc2lvbiBvZiBhIGdyYXlzY2FsZSBpbWFnZSBzaG91bGQgYmUgc2l6ZSAxLCBidXQgZ290IHNpemUgJHthfS5gKTtsZXQgcj1uZXcgQXJyYXkodC5yYW5rKTtyZXR1cm4gci5maWxsKDEsMCxuKSxyW25dPTMsT24odCxyKX12YXIgaVc9TCh7Z3JheXNjYWxlVG9SR0JfOnNXfSk7ZnVuY3Rpb24gb1coZSl7bGV0IHQ9RShlLFwiaW1hZ2VcIixcIlJHQlRvR3JheXNjYWxlXCIpLG49dC5yYW5rLTEsYT10LnNoYXBlW25dO0EodC5yYW5rPj0yLCgpPT5gRXJyb3IgaW4gUkdCVG9HcmF5c2NhbGU6IGltYWdlcyBtdXN0IGJlIGF0IGxlYXN0IHJhbmsgMiwgYnV0IGdvdCByYW5rICR7dC5yYW5rfS5gKSxBKGE9PT0zLCgpPT5gRXJyb3IgaW4gUkdCVG9HcmF5c2NhbGU6IGxhc3QgZGltZW5zaW9uIG9mIGFuIFJHQiBpbWFnZSBzaG91bGQgYmUgc2l6ZSAzLCBidXQgZ290IHNpemUgJHthfS5gKTtsZXQgcj10LmR0eXBlLHM9cmUodCxcImZsb2F0MzJcIiksaT1qZShbLjI5ODksLjU4NywuMTE0XSksbztzd2l0Y2godC5yYW5rKXtjYXNlIDI6bz1acyhcImlqLGotPmlcIixzLGkpO2JyZWFrO2Nhc2UgMzpvPVpzKFwiaWprLGstPmlqXCIscyxpKTticmVhaztjYXNlIDQ6bz1acyhcImlqa2wsbC0+aWprXCIscyxpKTticmVhaztjYXNlIDU6bz1acyhcImlqa2xtLG0tPmlqa2xcIixzLGkpO2JyZWFrO2Nhc2UgNjpvPVpzKFwiaWprbG1uLG4tPmlqa2xtXCIscyxpKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIk5vdCBhIHZhbGlkIHRlbnNvciByYW5rLlwiKX1yZXR1cm4gbz1HdChvLC0xKSxyZShvLHIpfXZhciBsVz1MKHtyZ2JUb0dyYXlzY2FsZV86b1d9KTtmdW5jdGlvbiB1VyhlLHQsbj0wLGE9LjUpe2xldCByPUUoZSxcImltYWdlXCIsXCJyb3RhdGVXaXRoT2Zmc2V0XCIsXCJmbG9hdDMyXCIpO0Eoci5yYW5rPT09NCwoKT0+YEVycm9yIGluIHJvdGF0ZVdpdGhPZmZzZXQ6IGltYWdlIG11c3QgYmUgcmFuayA0LGJ1dCBnb3QgcmFuayAke3IucmFua30uYCk7bGV0IHM9e2ltYWdlOnJ9LGk9e3JhZGlhbnM6dCxmaWxsVmFsdWU6bixjZW50ZXI6YX07cmV0dXJuIFAucnVuS2VybmVsKFp1LHMsaSl9dmFyIHBXPUwoe3JvdGF0ZVdpdGhPZmZzZXRfOnVXfSk7ZnVuY3Rpb24gYXAoZSx0LG4sYSxyLHMpe2E9PW51bGwmJihhPS41KSxyPT1udWxsJiYocj1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpLHM9PW51bGwmJihzPTApO2xldCBpPWUuc2hhcGVbMF07cmV0dXJuIG49TWF0aC5taW4obixpKSxBKDA8PWEmJmE8PTEsKCk9PmBpb3VUaHJlc2hvbGQgbXVzdCBiZSBpbiBbMCwgMV0sIGJ1dCB3YXMgJyR7YX0nYCksQShlLnJhbms9PT0yLCgpPT5gYm94ZXMgbXVzdCBiZSBhIDJEIHRlbnNvciwgYnV0IHdhcyBvZiByYW5rICcke2UucmFua30nYCksQShlLnNoYXBlWzFdPT09NCwoKT0+YGJveGVzIG11c3QgaGF2ZSA0IGNvbHVtbnMsIGJ1dCAybmQgZGltZW5zaW9uIHdhcyAke2Uuc2hhcGVbMV19YCksQSh0LnJhbms9PT0xLCgpPT5cInNjb3JlcyBtdXN0IGJlIGEgMUQgdGVuc29yXCIpLEEodC5zaGFwZVswXT09PWksKCk9PmBzY29yZXMgaGFzIGluY29tcGF0aWJsZSBzaGFwZSB3aXRoIGJveGVzLiBFeHBlY3RlZCAke2l9LCBidXQgd2FzICR7dC5zaGFwZVswXX1gKSxBKDA8PXMmJnM8PTEsKCk9PmBzb2Z0Tm1zU2lnbWEgbXVzdCBiZSBpbiBbMCwgMV0sIGJ1dCB3YXMgJyR7c30nYCkse21heE91dHB1dFNpemU6bixpb3VUaHJlc2hvbGQ6YSxzY29yZVRocmVzaG9sZDpyLHNvZnRObXNTaWdtYTpzfX1mdW5jdGlvbiBjVyhlLHQsbixhPS41LHI9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKXtsZXQgcz1FKGUsXCJib3hlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25cIixcImZsb2F0MzJcIiksaT1FKHQsXCJzY29yZXNcIixcIm5vbk1heFN1cHByZXNzaW9uXCIsXCJmbG9hdDMyXCIpLG89YXAocyxpLG4sYSxyKTtuPW8ubWF4T3V0cHV0U2l6ZSxhPW8uaW91VGhyZXNob2xkLHI9by5zY29yZVRocmVzaG9sZDtsZXQgbD17bWF4T3V0cHV0U2l6ZTpuLGlvdVRocmVzaG9sZDphLHNjb3JlVGhyZXNob2xkOnJ9O3JldHVybiBQLnJ1bktlcm5lbChfdSx7Ym94ZXM6cyxzY29yZXM6aX0sbCl9dmFyIGRXPUwoe25vbk1heFN1cHByZXNzaW9uXzpjV30pO2Z1bmN0aW9uIGhXKGUsdCxuKXtsZXQgYT1tVyhlLHQsbikscj1hPDA/LShhKzEpOmE7ZS5zcGxpY2UociwwLHQpfWZ1bmN0aW9uIG1XKGUsdCxuKXtyZXR1cm4gZ1coZSx0LG58fGZXKX1mdW5jdGlvbiBmVyhlLHQpe3JldHVybiBlPnQ/MTplPHQ/LTE6MH1mdW5jdGlvbiBnVyhlLHQsbil7bGV0IGE9MCxyPWUubGVuZ3RoLHM9MCxpPSExO2Zvcig7YTxyOyl7cz1hKyhyLWE+Pj4xKTtsZXQgbz1uKHQsZVtzXSk7bz4wP2E9cysxOihyPXMsaT0hbyl9cmV0dXJuIGk/YTotYS0xfWZ1bmN0aW9uIFNUKGUsdCxuLGEscil7cmV0dXJuIFd3KGUsdCxuLGEsciwwKX1mdW5jdGlvbiBOVChlLHQsbixhLHIscyl7cmV0dXJuIFd3KGUsdCxuLGEsciwwLCExLHMsITApfWZ1bmN0aW9uIFRUKGUsdCxuLGEscixzKXtyZXR1cm4gV3coZSx0LG4sYSxyLHMsITApfWZ1bmN0aW9uIFd3KGUsdCxuLGEscixzLGk9ITEsbz0hMSxsPSExKXtsZXQgdT1bXTtmb3IobGV0IGc9MDtnPHQubGVuZ3RoO2crKyl0W2ddPnImJnUucHVzaCh7c2NvcmU6dFtnXSxib3hJbmRleDpnLHN1cHByZXNzQmVnaW5JbmRleDowfSk7dS5zb3J0KHRJKTtsZXQgcD1zPjA/LS41L3M6MCxkPVtdLGM9W107Zm9yKDtkLmxlbmd0aDxuJiZ1Lmxlbmd0aD4wOyl7bGV0IGc9dS5wb3AoKSx7c2NvcmU6Yixib3hJbmRleDp5LHN1cHByZXNzQmVnaW5JbmRleDp4fT1nO2lmKGI8cilicmVhaztsZXQgdj0hMTtmb3IobGV0IEk9ZC5sZW5ndGgtMTtJPj14Oy0tSSl7bGV0IE49YlcoZSx5LGRbSV0pO2lmKE4+PWEpe3Y9ITA7YnJlYWt9aWYoZy5zY29yZT1nLnNjb3JlKnlXKGEscCxOKSxnLnNjb3JlPD1yKWJyZWFrfWcuc3VwcHJlc3NCZWdpbkluZGV4PWQubGVuZ3RoLHZ8fChnLnNjb3JlPT09Yj8oZC5wdXNoKHkpLGMucHVzaChnLnNjb3JlKSk6Zy5zY29yZT5yJiZoVyh1LGcsdEkpKX1sZXQgaD1kLmxlbmd0aCxtPW4taDtvJiZtPjAmJihkLnB1c2goLi4ubmV3IEFycmF5KG0pLmZpbGwoMCkpLGMucHVzaCguLi5uZXcgQXJyYXkobSkuZmlsbCgwKSkpO2xldCBmPXtzZWxlY3RlZEluZGljZXM6ZH07cmV0dXJuIGkmJihmLnNlbGVjdGVkU2NvcmVzPWMpLGwmJihmLnZhbGlkT3V0cHV0cz1oKSxmfWZ1bmN0aW9uIGJXKGUsdCxuKXtsZXQgYT1lLnN1YmFycmF5KHQqNCx0KjQrNCkscj1lLnN1YmFycmF5KG4qNCxuKjQrNCkscz1NYXRoLm1pbihhWzBdLGFbMl0pLGk9TWF0aC5taW4oYVsxXSxhWzNdKSxvPU1hdGgubWF4KGFbMF0sYVsyXSksbD1NYXRoLm1heChhWzFdLGFbM10pLHU9TWF0aC5taW4oclswXSxyWzJdKSxwPU1hdGgubWluKHJbMV0sclszXSksZD1NYXRoLm1heChyWzBdLHJbMl0pLGM9TWF0aC5tYXgoclsxXSxyWzNdKSxoPShvLXMpKihsLWkpLG09KGQtdSkqKGMtcCk7aWYoaDw9MHx8bTw9MClyZXR1cm4gMDtsZXQgZj1NYXRoLm1heChzLHUpLGc9TWF0aC5tYXgoaSxwKSxiPU1hdGgubWluKG8sZCkseT1NYXRoLm1pbihsLGMpLHg9TWF0aC5tYXgoYi1mLDApKk1hdGgubWF4KHktZywwKTtyZXR1cm4geC8oaCttLXgpfWZ1bmN0aW9uIHlXKGUsdCxuKXtsZXQgYT1NYXRoLmV4cCh0Km4qbik7cmV0dXJuIG48PWU/YTowfWZ1bmN0aW9uIHRJKGUsdCl7cmV0dXJuIGUuc2NvcmUtdC5zY29yZXx8ZS5zY29yZT09PXQuc2NvcmUmJnQuYm94SW5kZXgtZS5ib3hJbmRleH1hc3luYyBmdW5jdGlvbiB4VyhlLHQsbixhPS41LHI9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKXtsZXQgcz1FKGUsXCJib3hlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25Bc3luY1wiKSxpPUUodCxcInNjb3Jlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25Bc3luY1wiKSxvPWFwKHMsaSxuLGEscik7bj1vLm1heE91dHB1dFNpemUsYT1vLmlvdVRocmVzaG9sZCxyPW8uc2NvcmVUaHJlc2hvbGQ7bGV0IGw9YXdhaXQgUHJvbWlzZS5hbGwoW3MuZGF0YSgpLGkuZGF0YSgpXSksdT1sWzBdLHA9bFsxXSx7c2VsZWN0ZWRJbmRpY2VzOmR9PVNUKHUscCxuLGEscik7cmV0dXJuIHMhPT1lJiZzLmRpc3Bvc2UoKSxpIT09dCYmaS5kaXNwb3NlKCksamUoZCxcImludDMyXCIpfXZhciB2Vz14VztmdW5jdGlvbiB3VyhlLHQsbixhPS41LHI9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLHM9MCl7bGV0IGk9RShlLFwiYm94ZXNcIixcIm5vbk1heFN1cHByZXNzaW9uXCIpLG89RSh0LFwic2NvcmVzXCIsXCJub25NYXhTdXBwcmVzc2lvblwiKSxsPWFwKGksbyxuLGEscixzKTtuPWwubWF4T3V0cHV0U2l6ZSxhPWwuaW91VGhyZXNob2xkLHI9bC5zY29yZVRocmVzaG9sZCxzPWwuc29mdE5tc1NpZ21hO2xldCB1PXtib3hlczppLHNjb3JlczpvfSxwPXttYXhPdXRwdXRTaXplOm4saW91VGhyZXNob2xkOmEsc2NvcmVUaHJlc2hvbGQ6cixzb2Z0Tm1zU2lnbWE6c30sZD1QLnJ1bktlcm5lbChGdSx1LHApO3JldHVybntzZWxlY3RlZEluZGljZXM6ZFswXSxzZWxlY3RlZFNjb3JlczpkWzFdfX12YXIga1c9TCh7bm9uTWF4U3VwcHJlc3Npb25XaXRoU2NvcmVfOndXfSk7YXN5bmMgZnVuY3Rpb24gSVcoZSx0LG4sYT0uNSxyPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSxzPTApe2xldCBpPUUoZSxcImJveGVzXCIsXCJub25NYXhTdXBwcmVzc2lvbkFzeW5jXCIpLG89RSh0LFwic2NvcmVzXCIsXCJub25NYXhTdXBwcmVzc2lvbkFzeW5jXCIpLGw9YXAoaSxvLG4sYSxyLHMpO249bC5tYXhPdXRwdXRTaXplLGE9bC5pb3VUaHJlc2hvbGQscj1sLnNjb3JlVGhyZXNob2xkLHM9bC5zb2Z0Tm1zU2lnbWE7bGV0IHU9YXdhaXQgUHJvbWlzZS5hbGwoW2kuZGF0YSgpLG8uZGF0YSgpXSkscD11WzBdLGQ9dVsxXSx7c2VsZWN0ZWRJbmRpY2VzOmMsc2VsZWN0ZWRTY29yZXM6aH09VFQocCxkLG4sYSxyLHMpO3JldHVybiBpIT09ZSYmaS5kaXNwb3NlKCksbyE9PXQmJm8uZGlzcG9zZSgpLHtzZWxlY3RlZEluZGljZXM6amUoYyxcImludDMyXCIpLHNlbGVjdGVkU2NvcmVzOmplKGgpfX12YXIgU1c9SVc7ZnVuY3Rpb24gTlcoZSx0LG4sYT0uNSxyPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSxzPSExKXtsZXQgaT1FKGUsXCJib3hlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25cIiksbz1FKHQsXCJzY29yZXNcIixcIm5vbk1heFN1cHByZXNzaW9uXCIpLGw9YXAoaSxvLG4sYSxyLG51bGwpLHU9bC5tYXhPdXRwdXRTaXplLHA9bC5pb3VUaHJlc2hvbGQsZD1sLnNjb3JlVGhyZXNob2xkLGM9e2JveGVzOmksc2NvcmVzOm99LGg9e21heE91dHB1dFNpemU6dSxpb3VUaHJlc2hvbGQ6cCxzY29yZVRocmVzaG9sZDpkLHBhZFRvTWF4T3V0cHV0U2l6ZTpzfSxtPVAucnVuS2VybmVsKEF1LGMsaCk7cmV0dXJue3NlbGVjdGVkSW5kaWNlczptWzBdLHZhbGlkT3V0cHV0czptWzFdfX12YXIgVFc9TCh7bm9uTWF4U3VwcHJlc3Npb25QYWRkZWRfOk5XfSk7YXN5bmMgZnVuY3Rpb24gQ1coZSx0LG4sYT0uNSxyPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSxzPSExKXtsZXQgaT1FKGUsXCJib3hlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25Bc3luY1wiKSxvPUUodCxcInNjb3Jlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25Bc3luY1wiKSxsPWFwKGksbyxuLGEscixudWxsKSx1PWwubWF4T3V0cHV0U2l6ZSxwPWwuaW91VGhyZXNob2xkLGQ9bC5zY29yZVRocmVzaG9sZCxbYyxoXT1hd2FpdCBQcm9taXNlLmFsbChbaS5kYXRhKCksby5kYXRhKCldKSx7c2VsZWN0ZWRJbmRpY2VzOm0sdmFsaWRPdXRwdXRzOmZ9PU5UKGMsaCx1LHAsZCxzKTtyZXR1cm4gaSE9PWUmJmkuZGlzcG9zZSgpLG8hPT10JiZvLmRpc3Bvc2UoKSx7c2VsZWN0ZWRJbmRpY2VzOmplKG0sXCJpbnQzMlwiKSx2YWxpZE91dHB1dHM6eGUoZixcImludDMyXCIpfX12YXIgRVc9Q1c7ZnVuY3Rpb24gX1coZSx0LG49ITEsYT0hMSl7bGV0IHI9RShlLFwiaW1hZ2VzXCIsXCJyZXNpemVCaWxpbmVhclwiKTtBKHIucmFuaz09PTN8fHIucmFuaz09PTQsKCk9PmBFcnJvciBpbiByZXNpemVCaWxpbmVhcjogeCBtdXN0IGJlIHJhbmsgMyBvciA0LCBidXQgZ290IHJhbmsgJHtyLnJhbmt9LmApLEEodC5sZW5ndGg9PT0yLCgpPT5gRXJyb3IgaW4gcmVzaXplQmlsaW5lYXI6IG5ldyBzaGFwZSBtdXN0IDJELCBidXQgZ290IHNoYXBlICR7dH0uYCksQShhPT09ITF8fG49PT0hMSwoKT0+XCJFcnJvciBpbiByZXNpemVCaWxpbmVhcjogSWYgaGFsZlBpeGVsQ2VudGVycyBpcyB0cnVlLCBhbGlnbkNvcm5lcnMgbXVzdCBiZSBmYWxzZS5cIik7bGV0IHM9cixpPSExO3IucmFuaz09PTMmJihpPSEwLHM9VyhyLFsxLHIuc2hhcGVbMF0sci5zaGFwZVsxXSxyLnNoYXBlWzJdXSkpO2xldFtdPXQsbz17aW1hZ2VzOnN9LGw9e2FsaWduQ29ybmVyczpuLGhhbGZQaXhlbENlbnRlcnM6YSxzaXplOnR9LHU9UC5ydW5LZXJuZWwoVG8sbyxsKTtyZXR1cm4gaT9XKHUsW3Uuc2hhcGVbMV0sdS5zaGFwZVsyXSx1LnNoYXBlWzNdXSk6dX12YXIgQ1Q9TCh7cmVzaXplQmlsaW5lYXJfOl9XfSk7ZnVuY3Rpb24gQVcoZSx0LG49ITEsYT0hMSl7bGV0IHI9RShlLFwiaW1hZ2VzXCIsXCJyZXNpemVOZWFyZXN0TmVpZ2hib3JcIik7QShyLnJhbms9PT0zfHxyLnJhbms9PT00LCgpPT5gRXJyb3IgaW4gcmVzaXplTmVhcmVzdE5laWdoYm9yOiB4IG11c3QgYmUgcmFuayAzIG9yIDQsIGJ1dCBnb3QgcmFuayAke3IucmFua30uYCksQSh0Lmxlbmd0aD09PTIsKCk9PmBFcnJvciBpbiByZXNpemVOZWFyZXN0TmVpZ2hib3I6IG5ldyBzaGFwZSBtdXN0IDJELCBidXQgZ290IHNoYXBlICR7dH0uYCksQShyLmR0eXBlPT09XCJmbG9hdDMyXCJ8fHIuZHR5cGU9PT1cImludDMyXCIsKCk9PlwiYGltYWdlc2AgbXVzdCBoYXZlIGBpbnQzMmAgb3IgYGZsb2F0MzJgIGFzIGR0eXBlXCIpLEEoYT09PSExfHxuPT09ITEsKCk9PlwiRXJyb3IgaW4gcmVzaXplTmVhcmVzdE5laWdoYm9yOiBJZiBoYWxmUGl4ZWxDZW50ZXJzIGlzIHRydWUsIGFsaWduQ29ybmVycyBtdXN0IGJlIGZhbHNlLlwiKTtsZXQgcz1yLGk9ITE7ci5yYW5rPT09MyYmKGk9ITAscz1XKHIsWzEsci5zaGFwZVswXSxyLnNoYXBlWzFdLHIuc2hhcGVbMl1dKSk7bGV0W109dCxvPXtpbWFnZXM6c30sbD17YWxpZ25Db3JuZXJzOm4saGFsZlBpeGVsQ2VudGVyczphLHNpemU6dH0sdT1QLnJ1bktlcm5lbChObyxvLGwpO3JldHVybiBpP1codSxbdS5zaGFwZVsxXSx1LnNoYXBlWzJdLHUuc2hhcGVbM11dKTp1fXZhciBFVD1MKHtyZXNpemVOZWFyZXN0TmVpZ2hib3JfOkFXfSk7ZnVuY3Rpb24gRlcoZSx0PVwiYmluYXJ5XCIsbj0hMSxhPS41KXtsZXQgcj1FKGUsXCJpbWFnZVwiLFwidGhyZXNob2xkXCIpLHM9LjI5ODksaT0uNTg3LG89LjExNCxsPXIuc2hhcGVbMF0qci5zaGFwZVsxXSx1PXooamUoW2FdKSwyNTUpLHAsZCxjLGg7aWYoQShyLnJhbms9PT0zLCgpPT5gRXJyb3IgaW4gdGhyZXNob2xkOiBpbWFnZSBtdXN0IGJlIHJhbmsgMyxidXQgZ290IHJhbmsgJHtyLnJhbmt9LmApLEEoci5zaGFwZVsyXT09PTN8fHIuc2hhcGVbMl09PT0xLCgpPT5gRXJyb3IgaW4gdGhyZXNob2xkOiBpbWFnZSBjb2xvciBjaGFubmVsIG11c3QgYmUgZXF1YWwgdG8gMyBvciAxYnV0IGdvdCAke3Iuc2hhcGVbMl19LmApLEEoci5kdHlwZT09PVwiaW50MzJcInx8ci5kdHlwZT09PVwiZmxvYXQzMlwiLCgpPT5gRXJyb3IgaW4gZHR5cGU6IGltYWdlIGR0eXBlIG11c3QgYmUgaW50MzIgb3IgZmxvYXQzMixidXQgZ290IGR0eXBlICR7ci5kdHlwZX0uYCksQSh0PT09XCJvdHN1XCJ8fHQ9PT1cImJpbmFyeVwiLCgpPT5gTWV0aG9kIG11c3QgYmUgYmluYXJ5IG9yIG90c3UsIGJ1dCB3YXMgJHt0fWApLHIuc2hhcGVbMl09PT0zKXtbcCxkLGNdPUxuKHIsWzEsMSwxXSwtMSk7bGV0IGY9eihwLHMpLGc9eihkLGkpLGI9eihjLG8pO2g9WChYKGYsZyksYil9ZWxzZSBoPWU7aWYodD09PVwib3RzdVwiKXtsZXQgZj1ZdihyZShabShoKSxcImludDMyXCIpLGJuKFtdKSwyNTYpO3U9JFcoZixsKX1sZXQgbT1uP0NzKGgsdSk6Q24oaCx1KTtyZXR1cm4gcmUoeihtLDI1NSksXCJpbnQzMlwiKX1mdW5jdGlvbiAkVyhlLHQpe2xldCBuPWplKFstMV0pLGE9amUoWzBdKSxyPWplKFswXSkscyxpLG8sbCx1LHA7Zm9yKGxldCBkPTA7ZDxlLnNpemUtMTtkKyspe3M9VmUoZSwwLGQrMSksaT1WZShlLGQrMSksdT1oZShmZShzKSx0KSxwPWhlKGZlKGkpLHQpO2xldCBjPWZlKHoocyxnaSgwLHMuc2l6ZSkpKTtvPWhlKGMsZmUocykpO2xldCBoPXluKGkuc2hhcGUscy5zaXplKSxtPVgoZ2koMCxpLnNpemUpLGgpLGY9eihpLG0pO2w9aGUoZmUoZiksZmUoaSkpO2xldCBnPXBlKG8sbCksYj1wZShvLGwpLHk9eih1LHApO3I9eih6KHksZyksYik7bGV0IHg9Q24ocixhKTthPW5uKHgscixhKSxuPW5uKHgsamUoW2RdKSxuKX1yZXR1cm4gbn12YXIgRFc9TCh7dGhyZXNob2xkXzpGV30pO2Z1bmN0aW9uIFJXKGUsdCxuPVwibmVhcmVzdFwiLGE9XCJjb25zdGFudFwiLHI9MCxzKXtsZXQgaT1FKGUsXCJpbWFnZVwiLFwidHJhbnNmb3JtXCIsXCJmbG9hdDMyXCIpLG89RSh0LFwidHJhbnNmb3Jtc1wiLFwidHJhbnNmb3JtXCIsXCJmbG9hdDMyXCIpO0EoaS5yYW5rPT09NCwoKT0+YEVycm9yIGluIHRyYW5zZm9ybTogaW1hZ2UgbXVzdCBiZSByYW5rIDQsYnV0IGdvdCByYW5rICR7aS5yYW5rfS5gKSxBKG8ucmFuaz09PTImJihvLnNoYXBlWzBdPT09aS5zaGFwZVswXXx8by5zaGFwZVswXT09PTEpJiZvLnNoYXBlWzFdPT09OCwoKT0+XCJFcnJvciBpbiB0cmFuc2Zvcm06IElucHV0IHRyYW5zZm9ybSBzaG91bGQgYmUgYmF0Y2ggeCA4IG9yIDEgeCA4XCIpLEEocz09bnVsbHx8cy5sZW5ndGg9PT0yLCgpPT5gRXJyb3IgaW4gdHJhbnNmb3JtOiBvdXRwdXRTaGFwZSBtdXN0IGJlIFtoZWlnaHQsIHdpZHRoXSBvciBudWxsLCBidXQgZ290ICR7c30uYCk7bGV0IGw9e2ltYWdlOmksdHJhbnNmb3JtczpvfSx1PXtpbnRlcnBvbGF0aW9uOm4sZmlsbE1vZGU6YSxmaWxsVmFsdWU6cixvdXRwdXRTaGFwZTpzfTtyZXR1cm4gUC5ydW5LZXJuZWwoS3UsbCx1KX12YXIgTVc9TCh7dHJhbnNmb3JtXzpSV30pO2Z1bmN0aW9uIE9XKGUsdCxuKXtsZXQgYT1FKGUsXCJhXCIsXCJiYW5kUGFydFwiKTtBKGEucmFuaz49MiwoKT0+YGJhbmRQYXJ0KCk6IFJhbmsgbXVzdCBiZSBhdCBsZWFzdCAyLCBnb3QgJHthLnJhbmt9LmApO2xldCByPWEuc2hhcGUsW3MsaV09YS5zaGFwZS5zbGljZSgtMiksbyxsO3R5cGVvZiB0PT1cIm51bWJlclwiPyhBKHQlMT09PTAsKCk9PmBiYW5kUGFydCgpOiBudW1Mb3dlciBtdXN0IGJlIGFuIGludGVnZXIsIGdvdCAke3R9LmApLEEodDw9cywoKT0+YGJhbmRQYXJ0KCk6IG51bUxvd2VyICgke3R9KSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiByb3dzICgke3N9KS5gKSxvPUUodDwwP3M6dCxcIm51bUxvd2VyXCIsXCJiYW5kUGFydFwiKSk6KEEodC5kdHlwZT09PVwiaW50MzJcIiwoKT0+XCJiYW5kUGFydCgpOiBudW1Mb3dlcidzIGR0eXBlIG11c3QgYmUgYW4gaW50MzIuXCIpLG89bm4oUGwodCwwKSxzLGRzKHQscykpKSx0eXBlb2Ygbj09XCJudW1iZXJcIj8oQShuJTE9PT0wLCgpPT5gYmFuZFBhcnQoKTogbnVtVXBwZXIgbXVzdCBiZSBhbiBpbnRlZ2VyLCBnb3QgJHtufS5gKSxBKG48PWksKCk9PmBiYW5kUGFydCgpOiBudW1VcHBlciAoJHtufSkgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2YgY29sdW1ucyAoJHtpfSkuYCksbD1FKG48MD9pOm4sXCJudW1VcHBlclwiLFwiYmFuZFBhcnRcIikpOihBKG4uZHR5cGU9PT1cImludDMyXCIsKCk9PlwiYmFuZFBhcnQoKTogbnVtVXBwZXIncyBkdHlwZSBtdXN0IGJlIGFuIGludDMyLlwiKSxsPW5uKFBsKG4sMCksaSxkcyhuLGkpKSk7bGV0IHU9VyhnaSgwLHMsMSxcImludDMyXCIpLFstMSwxXSkscD1naSgwLGksMSxcImludDMyXCIpLGQ9cGUodSxwKSxjPV9hKENzKGQsbyksJHIoZCx5dChsKSkpLGg9SXQoW3MsaV0sYS5kdHlwZSk7cmV0dXJuIFcoQXQoZHQoVyhhLFstMSxzLGldKSkubWFwKG09Pm5uKGMsbSxoKSkpLHIpfXZhciBQVz1MKHtiYW5kUGFydF86T1d9KTtmdW5jdGlvbiBMVyhlKXtsZXQgdDtpZihBcnJheS5pc0FycmF5KGUpKXt0PSExLEEoZSE9bnVsbCYmZS5sZW5ndGg+MCwoKT0+XCJHcmFtLVNjaG1pZHQgcHJvY2VzczogaW5wdXQgbXVzdCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkLCBvciBlbXB0eVwiKTtsZXQgcj1lWzBdLnNoYXBlWzBdO2ZvcihsZXQgcz0xO3M8ZS5sZW5ndGg7KytzKUEoZVtzXS5zaGFwZVswXT09PXIsKCk9PmBHcmFtLVNjaG1pZHQ6IE5vbi11bmlxdWUgbGVuZ3RocyBmb3VuZCBpbiB0aGUgaW5wdXQgdmVjdG9yczogKCR7ZVtzXS5zaGFwZVswXX0gdnMuICR7cn0pYCl9ZWxzZSB0PSEwLGU9TG4oZSxlLnNoYXBlWzBdLDApLm1hcChyPT5BcyhyLFswXSkpO0EoZS5sZW5ndGg8PWVbMF0uc2hhcGVbMF0sKCk9PmBHcmFtLVNjaG1pZHQ6IE51bWJlciBvZiB2ZWN0b3JzICgke2UubGVuZ3RofSkgZXhjZWVkcyBudW1iZXIgb2YgZGltZW5zaW9ucyAoJHtlWzBdLnNoYXBlWzBdfSkuYCk7bGV0IG49W10sYT1lO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7KytyKW4ucHVzaChQLnRpZHkoKCk9PntsZXQgcz1hW3JdO2lmKHI+MClmb3IobGV0IGk9MDtpPHI7KytpKXtsZXQgbz16KGZlKHoobltpXSxzKSksbltpXSk7cz1wZShzLG8pfXJldHVybiBoZShzLGVwKHMsXCJldWNsaWRlYW5cIikpfSkpO3JldHVybiB0P0F0KG4sMCk6bn12YXIgelc9TCh7Z3JhbVNjaG1pZHRfOkxXfSk7ZnVuY3Rpb24gV1coZSx0PSExKXtpZihBKGUucmFuaz49MiwoKT0+YHFyKCkgcmVxdWlyZXMgaW5wdXQgdGVuc29yIHRvIGhhdmUgYSByYW5rID49IDIsIGJ1dCBnb3QgcmFuayAke2UucmFua31gKSxlLnJhbms9PT0yKXJldHVybiBuSShlLHQpO3tsZXQgbj1lLnNoYXBlLnNsaWNlKDAsZS5zaGFwZS5sZW5ndGgtMikucmVkdWNlKChsLHUpPT5sKnUpLGE9ZHQoVyhlLFtuLGUuc2hhcGVbZS5zaGFwZS5sZW5ndGgtMl0sZS5zaGFwZVtlLnNoYXBlLmxlbmd0aC0xXV0pLDApLHI9W10scz1bXTthLmZvckVhY2gobD0+e2xldFt1LHBdPW5JKGwsdCk7ci5wdXNoKHUpLHMucHVzaChwKX0pO2xldCBpPVcoQXQociwwKSxlLnNoYXBlKSxvPVcoQXQocywwKSxlLnNoYXBlKTtyZXR1cm5baSxvXX19ZnVuY3Rpb24gbkkoZSx0PSExKXtyZXR1cm4gUC50aWR5KCgpPT57QShlLnNoYXBlLmxlbmd0aD09PTIsKCk9PmBxcjJkKCkgcmVxdWlyZXMgYSAyRCBUZW5zb3IsIGJ1dCBnb3QgYSAke2Uuc2hhcGUubGVuZ3RofUQgVGVuc29yLmApO2xldCBuPWUuc2hhcGVbMF0sYT1lLnNoYXBlWzFdLHI9R20obikscz1zcihlKSxpPUVhKFtbMV1dLFsxLDFdKSxvPXNyKGkpLGw9bj49YT9hOm47Zm9yKGxldCB1PTA7dTxsOysrdSl7bGV0IHA9cyxkPW8sYz1yO1tvLHMscl09UC50aWR5KCgpPT57bGV0IGg9VmUocyxbdSx1XSxbbi11LDFdKSxtPWVwKGgpLGY9VmUocyxbdSx1XSxbMSwxXSksZz1ubihDbihmLDApLEVhKFtbLTFdXSksRWEoW1sxXV0pKSxiPXBlKGYseihnLG0pKSx5PWhlKGgsYik7eS5zaGFwZVswXT09PTE/bz1zcihpKTpvPWV0KFtpLFZlKHksWzEsMF0sW3kuc2hhcGVbMF0tMSx5LnNoYXBlWzFdXSldLDApO2xldCB4PXl0KGhlKCRlKGcsYiksbSkpLHY9VmUocyxbdSwwXSxbbi11LGFdKSxJPXooeCxvKSxOPURlKG8pO2lmKHU9PT0wKXM9cGUodiwkZShJLCRlKE4sdikpKTtlbHNle2xldCBGPXBlKHYsJGUoSSwkZShOLHYpKSk7cz1ldChbVmUocyxbMCwwXSxbdSxhXSksRl0sMCl9bGV0IEM9RGUoSSksXz1WZShyLFswLHVdLFtuLHIuc2hhcGVbMV0tdV0pO2lmKHU9PT0wKXI9cGUoXywkZSgkZShfLG8pLEMpKTtlbHNle2xldCBGPXBlKF8sJGUoJGUoXyxvKSxDKSk7cj1ldChbVmUocixbMCwwXSxbbix1XSksRl0sMSl9cmV0dXJuW28scyxyXX0pLEVlKFtwLGQsY10pfXJldHVybiF0JiZuPmEmJihyPVZlKHIsWzAsMF0sW24sYV0pLHM9VmUocyxbMCwwXSxbYSxhXSkpLFtyLHNdfSl9dmFyIEJXPUwoe3FyXzpXV30pLGtuOyhmdW5jdGlvbihlKXtlW2UuTk9ORT0wXT1cIk5PTkVcIixlW2UuTUVBTj0xXT1cIk1FQU5cIixlW2UuU1VNPTJdPVwiU1VNXCIsZVtlLlNVTV9CWV9OT05aRVJPX1dFSUdIVFM9M109XCJTVU1fQllfTk9OWkVST19XRUlHSFRTXCJ9KShrbnx8KGtuPXt9KSk7ZnVuY3Rpb24gVlcoZSx0LG49a24uU1VNX0JZX05PTlpFUk9fV0VJR0hUUyl7bGV0IGE9RShlLFwibG9zc2VzXCIsXCJjb21wdXRlV2VpZ2h0ZWRMb3NzXCIpLHI9bnVsbDt0IT1udWxsJiYocj1FKHQsXCJ3ZWlnaHRzXCIsXCJjb21wdXRlV2VpZ2h0ZWRMb3NzXCIpKTtsZXQgcz1yPT1udWxsP2E6eihhLHIpO2lmKG49PT1rbi5OT05FKXJldHVybiBzO2lmKG49PT1rbi5TVU0pcmV0dXJuIGZlKHMpO2lmKG49PT1rbi5NRUFOKXtpZihyPT1udWxsKXJldHVybiBDdChzKTt7bGV0IGk9YS5zaXplL3Iuc2l6ZSxvPWhlKGZlKHMpLGZlKHIpKTtyZXR1cm4gaT4xP2hlKG8seGUoaSkpOm99fWlmKG49PT1rbi5TVU1fQllfTk9OWkVST19XRUlHSFRTKXtpZihyPT1udWxsKXJldHVybiBoZShmZShzKSx4ZShhLnNpemUpKTt7bGV0IGk9eihyLFBuKGEuc2hhcGUpKSxvPXJlKGZlKGZpKGkseGUoMCkpKSxcImZsb2F0MzJcIik7cmV0dXJuIGhlKGZlKHMpLG8pfX10aHJvdyBFcnJvcihgVW5rbm93biByZWR1Y3Rpb246ICR7bn1gKX12YXIgRHI9TCh7Y29tcHV0ZVdlaWdodGVkTG9zc186Vld9KTtmdW5jdGlvbiBVVyhlLHQsbixhPWtuLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpe2xldCByPUUoZSxcImxhYmVsc1wiLFwiYWJzb2x1dGVEaWZmZXJlbmNlXCIpLHM9RSh0LFwicHJlZGljdGlvbnNcIixcImFic29sdXRlRGlmZmVyZW5jZVwiKSxpPW51bGw7biE9bnVsbCYmKGk9RShuLFwid2VpZ2h0c1wiLFwiYWJzb2x1dGVEaWZmZXJlbmNlXCIpKSxObihyLnNoYXBlLHMuc2hhcGUsXCJFcnJvciBpbiBhYnNvbHV0ZURpZmZlcmVuY2U6IFwiKTtsZXQgbz1MdChwZShyLHMpKTtyZXR1cm4gRHIobyxpLGEpfXZhciBHVz1MKHthYnNvbHV0ZURpZmZlcmVuY2VfOlVXfSk7ZnVuY3Rpb24gSFcoZSx0LG4sYSxyPWtuLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpe2xldCBzPUUoZSxcImxhYmVsc1wiLFwiY29zaW5lRGlzdGFuY2VcIiksaT1FKHQsXCJwcmVkaWN0aW9uc1wiLFwiY29zaW5lRGlzdGFuY2VcIiksbz1udWxsO2EhPW51bGwmJihvPUUoYSxcIndlaWdodHNcIixcImNvc2luZURpc3RhbmNlXCIpKSxObihzLnNoYXBlLGkuc2hhcGUsXCJFcnJvciBpbiBjb3NpbmVEaXN0YW5jZTogXCIpO2xldCBsPXhlKDEpLHU9cGUobCxmZSh6KHMsaSksbiwhMCkpO3JldHVybiBEcih1LG8scil9dmFyIGpXPUwoe2Nvc2luZURpc3RhbmNlXzpIV30pO2Z1bmN0aW9uIHFXKGUsdCxuLGE9a24uU1VNX0JZX05PTlpFUk9fV0VJR0hUUyl7bGV0IHI9RShlLFwibGFiZWxzXCIsXCJoaW5nZUxvc3NcIikscz1FKHQsXCJwcmVkaWN0aW9uc1wiLFwiaGluZ2VMb3NzXCIpLGk9bnVsbDtuIT1udWxsJiYoaT1FKG4sXCJ3ZWlnaHRzXCIsXCJoaW5nZUxvc3NcIikpLE5uKHIuc2hhcGUscy5zaGFwZSxcIkVycm9yIGluIGhpbmdlTG9zczogXCIpO2xldCBvPXhlKDEpO3I9cGUoeih4ZSgyKSxyKSxvKTtsZXQgbD1LZShwZShvLHoocixzKSkpO3JldHVybiBEcihsLGksYSl9dmFyIEtXPUwoe2hpbmdlTG9zc186cVd9KTtmdW5jdGlvbiBYVyhlLHQsbixhPTEscj1rbi5TVU1fQllfTk9OWkVST19XRUlHSFRTKXtsZXQgcz1FKGUsXCJsYWJlbHNcIixcImh1YmVyTG9zc1wiKSxpPUUodCxcInByZWRpY3Rpb25zXCIsXCJodWJlckxvc3NcIiksbz1udWxsO24hPW51bGwmJihvPUUobixcIndlaWdodHNcIixcImh1YmVyTG9zc1wiKSksTm4ocy5zaGFwZSxpLnNoYXBlLFwiRXJyb3IgaW4gaHViZXJMb3NzOiBcIik7bGV0IGw9eGUoYSksdT1MdChwZShpLHMpKSxwPWRzKHUsbCksZD1wZSh1LHApLGM9WCh6KHhlKC41KSxwdChwKSkseihsLGQpKTtyZXR1cm4gRHIoYyxvLHIpfXZhciBZVz1MKHtodWJlckxvc3NfOlhXfSk7ZnVuY3Rpb24gWlcoZSx0LG4sYT0xZS03LHI9a24uU1VNX0JZX05PTlpFUk9fV0VJR0hUUyl7bGV0IHM9RShlLFwibGFiZWxzXCIsXCJsb2dMb3NzXCIpLGk9RSh0LFwicHJlZGljdGlvbnNcIixcImxvZ0xvc3NcIiksbz1udWxsO24hPW51bGwmJihvPUUobixcIndlaWdodHNcIixcImxvZ0xvc3NcIikpLE5uKHMuc2hhcGUsaS5zaGFwZSxcIkVycm9yIGluIGxvZ0xvc3M6IFwiKTtsZXQgbD14ZSgxKSx1PXhlKGEpLHA9eXQoeihzLFFuKFgoaSx1KSkpKSxkPXoocGUobCxzKSxRbihYKHBlKGwsaSksdSkpKSxjPXBlKHAsZCk7cmV0dXJuIERyKGMsbyxyKX12YXIgSlc9TCh7bG9nTG9zc186Wld9KTtmdW5jdGlvbiBRVyhlLHQsbixhPWtuLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpe2xldCByPUUoZSxcImxhYmVsc1wiLFwibWVhblNxdWFyZWRFcnJvclwiKSxzPUUodCxcInByZWRpY3Rpb25zXCIsXCJtZWFuU3F1YXJlZEVycm9yXCIpLGk9bnVsbDtuIT1udWxsJiYoaT1FKG4sXCJ3ZWlnaHRzXCIsXCJtZWFuU3F1YXJlZEVycm9yXCIpKSxObihyLnNoYXBlLHMuc2hhcGUsXCJFcnJvciBpbiBtZWFuU3F1YXJlZEVycm9yOiBcIik7bGV0IG89cmYocixzKTtyZXR1cm4gRHIobyxpLGEpfXZhciBlQj1MKHttZWFuU3F1YXJlZEVycm9yXzpRV30pO2Z1bmN0aW9uIHRCKGUsdCl7bGV0IG49RShlLFwibGFiZWxzXCIsXCJzaWdtb2lkQ3Jvc3NFbnRyb3B5V2l0aExvZ2l0c1wiKSxhPUUodCxcImxvZ2l0c1wiLFwic2lnbW9pZENyb3NzRW50cm9weVdpdGhMb2dpdHNcIik7Tm4obi5zaGFwZSxhLnNoYXBlLFwiRXJyb3IgaW4gc2lnbW9pZENyb3NzRW50cm9weVdpdGhMb2dpdHM6IFwiKTtsZXQgcj1LZShhKSxzPXooYSxuKSxpPXBkKGRuKHl0KEx0KGEpKSkpO3JldHVybiBYKHBlKHIscyksaSl9ZnVuY3Rpb24gbkIoZSx0LG4sYT0wLHI9a24uU1VNX0JZX05PTlpFUk9fV0VJR0hUUyl7bGV0IHM9RShlLFwibXVsdGlDbGFzc0xhYmVsc1wiLFwic2lnbW9pZENyb3NzRW50cm9weVwiKSxpPUUodCxcImxvZ2l0c1wiLFwic2lnbW9pZENyb3NzRW50cm9weVwiKSxvPW51bGw7aWYobiE9bnVsbCYmKG89RShuLFwid2VpZ2h0c1wiLFwic2lnbW9pZENyb3NzRW50cm9weVwiKSksTm4ocy5zaGFwZSxpLnNoYXBlLFwiRXJyb3IgaW4gc2lnbW9pZENyb3NzRW50cm9weTogXCIpLGE+MCl7bGV0IHU9eGUoYSkscD14ZSgxKSxkPXhlKC41KTtzPVgoeihzLHBlKHAsdSkpLHooZCx1KSl9bGV0IGw9dEIocyxpKTtyZXR1cm4gRHIobCxvLHIpfXZhciBhQj1MKHtzaWdtb2lkQ3Jvc3NFbnRyb3B5XzpuQn0pO2Z1bmN0aW9uIHJCKGUsdCxuPS0xKXtpZihuPT09LTEmJihuPXQucmFuay0xKSxuIT09dC5yYW5rLTEpdGhyb3cgRXJyb3IoYFNvZnRtYXggY3Jvc3MgZW50cm9weSBhbG9uZyBhIG5vbi1sYXN0IGRpbWVuc2lvbiBpcyBub3QgeWV0IHN1cHBvcnRlZC4gTGFiZWxzIC8gbG9naXRzIHdhcyByYW5rICR7dC5yYW5rfSBhbmQgZGltIHdhcyAke259YCk7cmV0dXJuIHByKChhLHIscyk9PntsZXQgaT1jZChyLFtuXSwhMCksbz1wZShyZShyLFwiZmxvYXQzMlwiKSxpKTtzKFthLG9dKTtsZXQgbD15dCh6KG8sYSkpO3JldHVybnt2YWx1ZTpmZShsLFtuXSksZ3JhZEZ1bmM6KHUscCk9PntsZXRbZCxjXT1wLGg9bWkodS5zaGFwZSxbbl0pO3JldHVyblt6KFcodSxoKSxwZShyZShkLFwiZmxvYXQzMlwiKSxkbihjKSkpLHooVyh1LGgpLHBlKGRuKGMpLHJlKGQsXCJmbG9hdDMyXCIpKSldfX19KShlLHQpfWZ1bmN0aW9uIHNCKGUsdCxuLGE9MCxyPWtuLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpe2xldCBzPUUoZSxcIm9uZWhvdExhYmVsc1wiLFwic29mdG1heENyb3NzRW50cm9weVwiKSxpPUUodCxcImxvZ2l0c1wiLFwic29mdG1heENyb3NzRW50cm9weVwiKSxvPW51bGw7aWYobiE9bnVsbCYmKG89RShuLFwid2VpZ2h0c1wiLFwic29mdG1heENyb3NzRW50cm9weVwiKSksTm4ocy5zaGFwZSxpLnNoYXBlLFwiRXJyb3IgaW4gc29mdG1heENyb3NzRW50cm9weTogXCIpLGE+MCl7bGV0IHU9eGUoYSkscD14ZSgxKSxkPXhlKHMuc2hhcGVbMV0pO3M9WCh6KHMscGUocCx1KSksaGUodSxkKSl9bGV0IGw9ckIocyxpKTtyZXR1cm4gRHIobCxvLHIpfXZhciBpQj1MKHtzb2Z0bWF4Q3Jvc3NFbnRyb3B5XzpzQn0pO2Z1bmN0aW9uIG9CKGUsdCxuLGEpe2xldCByPUUoZSxcImluZGljZXNcIixcInNwYXJzZUZpbGxFbXB0eVJvd3NcIixcImludDMyXCIpLHM9RSh0LFwidmFsdWVzXCIsXCJzcGFyc2VGaWxsRW1wdHlSb3dzXCIpLGk9RShuLFwiZGVuc2VTaGFwZVwiLFwic3BhcnNlRmlsbEVtcHR5Um93c1wiLFwiaW50MzJcIiksbz1FKGEsXCJkZWZhdWx0VmFsdWVcIixcInNwYXJzZUZpbGxFbXB0eVJvd3NcIixzLmR0eXBlKTtpZihyLnJhbmshPT0yKXRocm93IG5ldyBFcnJvcihgSW5kaWNlcyBzaG91bGQgYmUgVGVuc29yMkQgYnV0IHJlY2VpdmVkIHNoYXBlXG4gICAgICAgICR7ci5zaGFwZX1gKTtpZihzLnJhbmshPT0xKXRocm93IG5ldyBFcnJvcihgVmFsdWVzIHNob3VsZCBiZSBUZW5zb3IxRCBidXQgcmVjZWl2ZWQgc2hhcGUgJHtzLnNoYXBlfWApO2lmKGkucmFuayE9PTEpdGhyb3cgbmV3IEVycm9yKGBEZW5zZSBzaGFwZSBzaG91bGQgYmUgVGVuc29yMUQgYnV0IHJlY2VpdmVkIHNoYXBlICR7aS5zaGFwZX1gKTtpZihvLnJhbmshPT0wKXRocm93IG5ldyBFcnJvcihgRGVmYXVsdCB2YWx1ZSBzaG91bGQgYmUgYSBzY2FsYXIgYnV0IHJlY2VpdmVkIHNoYXBlICR7by5zaGFwZX1gKTtsZXQgbD17aW5kaWNlczpyLHZhbHVlczpzLGRlbnNlU2hhcGU6aSxkZWZhdWx0VmFsdWU6b30sdT1QLnJ1bktlcm5lbChHYyxsKTtyZXR1cm57b3V0cHV0SW5kaWNlczp1WzBdLG91dHB1dFZhbHVlczp1WzFdLGVtcHR5Um93SW5kaWNhdG9yOnVbMl0scmV2ZXJzZUluZGV4TWFwOnVbM119fXZhciBsQj1MKHtzcGFyc2VGaWxsRW1wdHlSb3dzXzpvQn0pO2Z1bmN0aW9uIHVCKGUsdCxuKXtsZXQgYT1FKGUsXCJpbnB1dEluZGljZXNcIixcInNwYXJzZVJlc2hhcGVcIixcImludDMyXCIpLHI9RSh0LFwiaW5wdXRTaGFwZVwiLFwic3BhcnNlUmVzaGFwZVwiLFwiaW50MzJcIikscz1FKG4sXCJuZXdTaGFwZVwiLFwic3BhcnNlUmVzaGFwZVwiLFwiaW50MzJcIik7aWYoYS5yYW5rIT09Mil0aHJvdyBuZXcgRXJyb3IoYElucHV0IGluZGljZXMgc2hvdWxkIGJlIFRlbnNvcjJEIGJ1dCByZWNlaXZlZCBzaGFwZVxuICAgICAgICAke2Euc2hhcGV9YCk7aWYoci5yYW5rIT09MSl0aHJvdyBuZXcgRXJyb3IoYElucHV0IHNoYXBlIHNob3VsZCBiZSBUZW5zb3IxRCBidXQgcmVjZWl2ZWQgc2hhcGUgJHtyLnNoYXBlfWApO2lmKHMucmFuayE9PTEpdGhyb3cgbmV3IEVycm9yKGBOZXcgc2hhcGUgc2hvdWxkIGJlIFRlbnNvcjFEIGJ1dCByZWNlaXZlZCBzaGFwZSAke3Muc2hhcGV9YCk7bGV0IGk9e2lucHV0SW5kaWNlczphLGlucHV0U2hhcGU6cixuZXdTaGFwZTpzfSxvPVAucnVuS2VybmVsKEd1LGkpO3JldHVybntvdXRwdXRJbmRpY2VzOm9bMF0sb3V0cHV0U2hhcGU6b1sxXX19dmFyIHBCPUwoe3NwYXJzZVJlc2hhcGVfOnVCfSk7ZnVuY3Rpb24gY0IoZSx0LG4pe2xldCBhPUUoZSxcImRhdGFcIixcInNwYXJzZVNlZ21lbnRNZWFuXCIpLHI9RSh0LFwiaW5kaWNlc1wiLFwic3BhcnNlU2VnbWVudE1lYW5cIixcImludDMyXCIpLHM9RShuLFwic2VnbWVudElkc1wiLFwic3BhcnNlU2VnbWVudE1lYW5cIixcImludDMyXCIpO2lmKGEucmFuazwxKXRocm93IG5ldyBFcnJvcihcIkRhdGEgc2hvdWxkIGJlIGF0IGxlYXN0IDEgZGltZW5zaW9uYWwgYnV0IHJlY2VpdmVkIHNjYWxhclwiKTtpZihyLnJhbmshPT0xKXRocm93IG5ldyBFcnJvcihgSW5kaWNlcyBzaG91bGQgYmUgVGVuc29yMUQgYnV0IHJlY2VpdmVkIHNoYXBlXG4gICAgICAgICAgJHtyLnNoYXBlfWApO2lmKHMucmFuayE9PTEpdGhyb3cgbmV3IEVycm9yKGBTZWdtZW50IGlkcyBzaG91bGQgYmUgVGVuc29yMUQgYnV0IHJlY2VpdmVkIHNoYXBlXG4gICAgICAgICAgJHtzLnNoYXBlfWApO2xldCBpPXtkYXRhOmEsaW5kaWNlczpyLHNlZ21lbnRJZHM6c307cmV0dXJuIFAucnVuS2VybmVsKEhjLGkpfXZhciBkQj1MKHtzcGFyc2VTZWdtZW50TWVhbl86Y0J9KTtmdW5jdGlvbiBoQihlLHQsbil7bGV0IGE9RShlLFwiZGF0YVwiLFwic3BhcnNlU2VnbWVudFN1bVwiKSxyPUUodCxcImluZGljZXNcIixcInNwYXJzZVNlZ21lbnRTdW1cIixcImludDMyXCIpLHM9RShuLFwic2VnbWVudElkc1wiLFwic3BhcnNlU2VnbWVudFN1bVwiLFwiaW50MzJcIik7aWYoYS5yYW5rPDEpdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBzaG91bGQgYmUgYXQgbGVhc3QgMSBkaW1lbnNpb25hbCBidXQgcmVjZWl2ZWQgc2NhbGFyXCIpO2lmKHIucmFuayE9PTEpdGhyb3cgbmV3IEVycm9yKGBJbmRpY2VzIHNob3VsZCBiZSBUZW5zb3IxRCBidXQgcmVjZWl2ZWQgc2hhcGVcbiAgICAgICAgICR7ci5zaGFwZX1gKTtpZihzLnJhbmshPT0xKXRocm93IG5ldyBFcnJvcihgU2VnbWVudCBpZHMgc2hvdWxkIGJlIFRlbnNvcjFEIGJ1dCByZWNlaXZlZCBzaGFwZVxuICAgICAgICAgJHtzLnNoYXBlfWApO2xldCBpPXtkYXRhOmEsaW5kaWNlczpyLHNlZ21lbnRJZHM6c307cmV0dXJuIFAucnVuS2VybmVsKGpjLGkpfXZhciBtQj1MKHtzcGFyc2VTZWdtZW50U3VtXzpoQn0pO2Z1bmN0aW9uIGZCKGUsdCxuLGEscixzLGksbyl7bGV0IGw9RShlLFwiZGF0YVwiLFwic3RyaW5nTkdyYW1zXCIsXCJzdHJpbmdcIik7aWYobC5kdHlwZSE9PVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBtdXN0IGJlIG9mIGRhdGF0eXBlIHN0cmluZ1wiKTtpZihsLnNoYXBlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKGBEYXRhIG11c3QgYmUgYSB2ZWN0b3IsIHNhdzogJHtsLnNoYXBlfWApO2xldCB1PUUodCxcImRhdGFTcGxpdHNcIixcInN0cmluZ05HcmFtc1wiKTtpZih1LmR0eXBlIT09XCJpbnQzMlwiKXRocm93IG5ldyBFcnJvcihcIkRhdGEgc3BsaXRzIG11c3QgYmUgb2YgZGF0YXR5cGUgaW50MzJcIik7bGV0IHA9e3NlcGFyYXRvcjpuLG5HcmFtV2lkdGhzOmEsbGVmdFBhZDpyLHJpZ2h0UGFkOnMscGFkV2lkdGg6aSxwcmVzZXJ2ZVNob3J0U2VxdWVuY2VzOm99LGQ9e2RhdGE6bCxkYXRhU3BsaXRzOnV9LGM9UC5ydW5LZXJuZWwoWGMsZCxwKTtyZXR1cm57bkdyYW1zOmNbMF0sbkdyYW1zU3BsaXRzOmNbMV19fXZhciBnQj1MKHtzdHJpbmdOR3JhbXNfOmZCfSk7ZnVuY3Rpb24gYkIoZSx0LG49ITApe2xldCBhPUUoZSxcImlucHV0XCIsXCJzdHJpbmdTcGxpdFwiLFwic3RyaW5nXCIpLHI9RSh0LFwiZGVsaW1pdGVyXCIsXCJzdHJpbmdTcGxpdFwiLFwic3RyaW5nXCIpO2lmKGEucmFuayE9PTEpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBzaG91bGQgYmUgVGVuc29yMUQgYnV0IHJlY2VpdmVkIHNoYXBlICR7YS5zaGFwZX1gKTtpZihyLnJhbmshPT0wKXRocm93IG5ldyBFcnJvcihgRGVsaW1pdGVyIHNob3VsZCBiZSBhIHNjYWxhciBidXQgcmVjZWl2ZWQgc2hhcGUgJHtyLnNoYXBlfWApO2xldCBzPXtza2lwRW1wdHk6bn0saT17aW5wdXQ6YSxkZWxpbWl0ZXI6cn0sbz1QLnJ1bktlcm5lbChZYyxpLHMpO3JldHVybntpbmRpY2VzOm9bMF0sdmFsdWVzOm9bMV0sc2hhcGU6b1syXX19dmFyIHlCPUwoe3N0cmluZ1NwbGl0XzpiQn0pO2Z1bmN0aW9uIHhCKGUsdCl7bGV0IG49RShlLFwiaW5wdXRcIixcInN0cmluZ1RvSGFzaEJ1Y2tldEZhc3RcIixcInN0cmluZ1wiKSxhPXtudW1CdWNrZXRzOnR9O2lmKHQ8PTApdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIG9mIGJ1Y2tldHMgbXVzdCBiZSBhdCBsZWFzdCAxXCIpO2xldCByPXtpbnB1dDpufTtyZXR1cm4gUC5ydW5LZXJuZWwoWmMscixhKX12YXIgdkI9TCh7c3RyaW5nVG9IYXNoQnVja2V0RmFzdF86eEJ9KTtmdW5jdGlvbiB3QihlLHQsbixhPSEwKXtsZXQgcj1FKGUsXCJpbnB1dFwiLFwic3RhdGljUmVnZXhSZXBsYWNlXCIsXCJzdHJpbmdcIikscz17cGF0dGVybjp0LHJld3JpdGU6bixyZXBsYWNlR2xvYmFsOmF9O3JldHVybiBQLnJ1bktlcm5lbChLYyx7eDpyfSxzKX12YXIga0I9TCh7c3RhdGljUmVnZXhSZXBsYWNlXzp3Qn0pLF9UPXtmZnQ6YmQsaWZmdDpCbCxyZmZ0OnlkLGlyZmZ0OmFmfSxBVD17aGFtbWluZ1dpbmRvdzpZeixoYW5uV2luZG93OmtULGZyYW1lOklULHN0ZnQ6ZVd9LFpuPXtmbGlwTGVmdFJpZ2h0OnJXLGdyYXlzY2FsZVRvUkdCOmlXLHJlc2l6ZU5lYXJlc3ROZWlnaGJvcjpFVCxyZXNpemVCaWxpbmVhcjpDVCxyZ2JUb0dyYXlzY2FsZTpsVyxyb3RhdGVXaXRoT2Zmc2V0OnBXLGNyb3BBbmRSZXNpemU6blcsbm9uTWF4U3VwcHJlc3Npb246ZFcsbm9uTWF4U3VwcHJlc3Npb25Bc3luYzp2Vyxub25NYXhTdXBwcmVzc2lvbldpdGhTY29yZTprVyxub25NYXhTdXBwcmVzc2lvbldpdGhTY29yZUFzeW5jOlNXLG5vbk1heFN1cHByZXNzaW9uUGFkZGVkOlRXLG5vbk1heFN1cHByZXNzaW9uUGFkZGVkQXN5bmM6RVcsdGhyZXNob2xkOkRXLHRyYW5zZm9ybTpNV30sQnc9e2JhbmRQYXJ0OlBXLGdyYW1TY2htaWR0OnpXLHFyOkJXfSxGVD17YWJzb2x1dGVEaWZmZXJlbmNlOkdXLGNvbXB1dGVXZWlnaHRlZExvc3M6RHIsY29zaW5lRGlzdGFuY2U6alcsaGluZ2VMb3NzOktXLGh1YmVyTG9zczpZVyxsb2dMb3NzOkpXLG1lYW5TcXVhcmVkRXJyb3I6ZUIsc2lnbW9pZENyb3NzRW50cm9weTphQixzb2Z0bWF4Q3Jvc3NFbnRyb3B5OmlCfSwkVD17c3BhcnNlRmlsbEVtcHR5Um93czpsQixzcGFyc2VSZXNoYXBlOnBCLHNwYXJzZVNlZ21lbnRNZWFuOmRCLHNwYXJzZVNlZ21lbnRTdW06bUJ9LERUPXtzdHJpbmdOR3JhbXM6Z0Isc3RyaW5nU3BsaXQ6eUIsc3RyaW5nVG9IYXNoQnVja2V0RmFzdDp2QixzdGF0aWNSZWdleFJlcGxhY2U6a0J9LG5lPXt9O19lKG5lLHtTZXJpYWxpemFibGU6KCk9PlJULFNlcmlhbGl6YXRpb25NYXA6KCk9Pk1ULGdldFJlZ2lzdGVyZWROYW1lOigpPT5TQixyZWdpc3RlckNsYXNzOigpPT5PVH0pO3ZhciBJQj1uZXcgTWFwLE14PW5ldyBNYXAsUlQ9Y2xhc3N7Z2V0Q2xhc3NOYW1lKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IuY2xhc3NOYW1lfXN0YXRpYyBmcm9tQ29uZmlnKGUsdCl7cmV0dXJuIG5ldyBlKHQpfX0sTVQ9Y2xhc3MgVGx7Y29uc3RydWN0b3IoKXt0aGlzLmNsYXNzTmFtZU1hcD17fX1zdGF0aWMgZ2V0TWFwKCl7cmV0dXJuIFRsLmluc3RhbmNlPT1udWxsJiYoVGwuaW5zdGFuY2U9bmV3IFRsKSxUbC5pbnN0YW5jZX1zdGF0aWMgcmVnaXN0ZXIodCl7VGwuZ2V0TWFwKCkuY2xhc3NOYW1lTWFwW3QuY2xhc3NOYW1lXT1bdCx0LmZyb21Db25maWddfX07ZnVuY3Rpb24gT1QoZSx0LG4pe0EoZS5jbGFzc05hbWUhPW51bGwsKCk9PlwiQ2xhc3MgYmVpbmcgcmVnaXN0ZXJlZCBkb2VzIG5vdCBoYXZlIHRoZSBzdGF0aWMgY2xhc3NOYW1lIHByb3BlcnR5IGRlZmluZWQuXCIpLEEodHlwZW9mIGUuY2xhc3NOYW1lPT1cInN0cmluZ1wiLCgpPT5cImNsYXNzTmFtZSBpcyByZXF1aXJlZCB0byBiZSBhIHN0cmluZywgYnV0IGdvdCB0eXBlIFwiK3R5cGVvZiBlLmNsYXNzTmFtZSksQShlLmNsYXNzTmFtZS5sZW5ndGg+MCwoKT0+XCJDbGFzcyBiZWluZyByZWdpc3RlcmVkIGhhcyBhbiBlbXB0eS1zdHJpbmcgYXMgaXRzIGNsYXNzTmFtZSwgd2hpY2ggaXMgZGlzYWxsb3dlZC5cIiksdHlwZW9mIHQ9PVwidW5kZWZpbmVkXCImJih0PVwiQ3VzdG9tXCIpLHR5cGVvZiBuPT1cInVuZGVmaW5lZFwiJiYobj1lLmNsYXNzTmFtZSk7bGV0IGE9bixyPXQrXCI+XCIrYTtyZXR1cm4gTVQucmVnaXN0ZXIoZSksSUIuc2V0KHIsZSksTXguc2V0KGUsciksZX1mdW5jdGlvbiBTQihlKXtyZXR1cm4gTXguaGFzKGUpP014LmdldChlKTplLmNsYXNzTmFtZX12YXIgUnI9Y2xhc3MgZXh0ZW5kcyBSVHttaW5pbWl6ZShlLHQ9ITEsbil7bGV0e3ZhbHVlOmEsZ3JhZHM6cn09dGhpcy5jb21wdXRlR3JhZGllbnRzKGUsbik7aWYobiE9bnVsbCl7bGV0IHM9bi5tYXAoaT0+KHtuYW1lOmkubmFtZSx0ZW5zb3I6cltpLm5hbWVdfSkpO3RoaXMuYXBwbHlHcmFkaWVudHMocyl9ZWxzZSB0aGlzLmFwcGx5R3JhZGllbnRzKHIpO3JldHVybiBFZShyKSx0P2E6KGEuZGlzcG9zZSgpLG51bGwpfWdldCBpdGVyYXRpb25zKCl7cmV0dXJuIHRoaXMuaXRlcmF0aW9uc189PW51bGwmJih0aGlzLml0ZXJhdGlvbnNfPTApLHRoaXMuaXRlcmF0aW9uc199aW5jcmVtZW50SXRlcmF0aW9ucygpe3RoaXMuaXRlcmF0aW9uc189dGhpcy5pdGVyYXRpb25zKzF9Y29tcHV0ZUdyYWRpZW50cyhlLHQpe3JldHVybiBPTihlLHQpfWRpc3Bvc2UoKXt0aGlzLml0ZXJhdGlvbnNfIT1udWxsJiZFZSh0aGlzLml0ZXJhdGlvbnNfKX1hc3luYyBzYXZlSXRlcmF0aW9ucygpe3JldHVybiB0aGlzLml0ZXJhdGlvbnNfPT1udWxsJiYodGhpcy5pdGVyYXRpb25zXz0wKSx7bmFtZTpcIml0ZXJcIix0ZW5zb3I6eGUodGhpcy5pdGVyYXRpb25zXyxcImludDMyXCIpfX1hc3luYyBnZXRXZWlnaHRzKCl7dGhyb3cgbmV3IEVycm9yKFwiZ2V0V2VpZ2h0cygpIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgdGhpcyBvcHRpbWl6ZXIgeWV0LlwiKX1hc3luYyBzZXRXZWlnaHRzKGUpe3Rocm93IG5ldyBFcnJvcihgc2V0V2VpZ2h0cygpIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgdGhpcyBvcHRpbWl6ZXIgY2xhc3MgJHt0aGlzLmdldENsYXNzTmFtZSgpfWApfWFzeW5jIGV4dHJhY3RJdGVyYXRpb25zKGUpe3JldHVybiB0aGlzLml0ZXJhdGlvbnNfPShhd2FpdCBlWzBdLnRlbnNvci5kYXRhKCkpWzBdLGUuc2xpY2UoMSl9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoUnIsU3ltYm9sLmhhc0luc3RhbmNlLHt2YWx1ZTplPT5lLm1pbmltaXplIT1udWxsJiZlLmNvbXB1dGVHcmFkaWVudHMhPW51bGwmJmUuYXBwbHlHcmFkaWVudHMhPW51bGx9KTt2YXIgVnc9Y2xhc3MgZXh0ZW5kcyBScntzdGF0aWMgZ2V0IGNsYXNzTmFtZSgpe3JldHVyblwiQWRhZGVsdGFcIn1jb25zdHJ1Y3RvcihlLHQsbj1udWxsKXtzdXBlcigpLHRoaXMubGVhcm5pbmdSYXRlPWUsdGhpcy5yaG89dCx0aGlzLmVwc2lsb249bix0aGlzLmFjY3VtdWxhdGVkR3JhZHM9W10sdGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXM9W10sbj09bnVsbCYmKHRoaXMuZXBzaWxvbj1QLmJhY2tlbmQuZXBzaWxvbigpKX1hcHBseUdyYWRpZW50cyhlKXsoQXJyYXkuaXNBcnJheShlKT9lLm1hcCh0PT50Lm5hbWUpOk9iamVjdC5rZXlzKGUpKS5mb3JFYWNoKCh0LG4pPT57bGV0IGE9UC5yZWdpc3RlcmVkVmFyaWFibGVzW3RdLHI9ITE7dGhpcy5hY2N1bXVsYXRlZEdyYWRzW25dPT1udWxsJiYodGhpcy5hY2N1bXVsYXRlZEdyYWRzW25dPXtvcmlnaW5hbE5hbWU6YCR7dH0vYWNjdW1fZ3JhZGAsdmFyaWFibGU6TygoKT0+cWUoYSkudmFyaWFibGUocikpfSksdGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXNbbl09PW51bGwmJih0aGlzLmFjY3VtdWxhdGVkVXBkYXRlc1tuXT17b3JpZ2luYWxOYW1lOmAke3R9L2FjY3VtX3ZhcmAsdmFyaWFibGU6TygoKT0+cWUoYSkudmFyaWFibGUocikpfSk7bGV0IHM9QXJyYXkuaXNBcnJheShlKT9lW25dLnRlbnNvcjplW3RdO2lmKHM9PW51bGwpcmV0dXJuO2xldCBpPXRoaXMuYWNjdW11bGF0ZWRHcmFkc1tuXS52YXJpYWJsZSxvPXRoaXMuYWNjdW11bGF0ZWRVcGRhdGVzW25dLnZhcmlhYmxlO08oKCk9PntsZXQgbD1YKHooaSx0aGlzLnJobykseihwdChzKSwxLXRoaXMucmhvKSksdT16KGhlKHJuKFgobyx0aGlzLmVwc2lsb24pKSxybihYKGksdGhpcy5lcHNpbG9uKSkpLHMpLHA9WCh6KG8sdGhpcy5yaG8pLHoocHQodSksMS10aGlzLnJobykpO2kuYXNzaWduKGwpLG8uYXNzaWduKHApO2xldCBkPVgoeih1LC10aGlzLmxlYXJuaW5nUmF0ZSksYSk7YS5hc3NpZ24oZCl9KX0pLHRoaXMuaW5jcmVtZW50SXRlcmF0aW9ucygpfWRpc3Bvc2UoKXt0aGlzLmFjY3VtdWxhdGVkVXBkYXRlcyE9bnVsbCYmKEVlKHRoaXMuYWNjdW11bGF0ZWRHcmFkcy5tYXAoZT0+ZS52YXJpYWJsZSkpLEVlKHRoaXMuYWNjdW11bGF0ZWRVcGRhdGVzLm1hcChlPT5lLnZhcmlhYmxlKSkpfWFzeW5jIGdldFdlaWdodHMoKXtsZXQgZT1bLi4udGhpcy5hY2N1bXVsYXRlZEdyYWRzLC4uLnRoaXMuYWNjdW11bGF0ZWRVcGRhdGVzXTtyZXR1cm5bYXdhaXQgdGhpcy5zYXZlSXRlcmF0aW9ucygpXS5jb25jYXQoZS5tYXAodD0+KHtuYW1lOnQub3JpZ2luYWxOYW1lLHRlbnNvcjp0LnZhcmlhYmxlfSkpKX1hc3luYyBzZXRXZWlnaHRzKGUpe2U9YXdhaXQgdGhpcy5leHRyYWN0SXRlcmF0aW9ucyhlKTtsZXQgdD1lLmxlbmd0aC8yLG49ITE7dGhpcy5hY2N1bXVsYXRlZEdyYWRzPWUuc2xpY2UoMCx0KS5tYXAoYT0+KHtvcmlnaW5hbE5hbWU6YS5uYW1lLHZhcmlhYmxlOmEudGVuc29yLnZhcmlhYmxlKG4pfSkpLHRoaXMuYWNjdW11bGF0ZWRVcGRhdGVzPWUuc2xpY2UodCx0KjIpLm1hcChhPT4oe29yaWdpbmFsTmFtZTphLm5hbWUsdmFyaWFibGU6YS50ZW5zb3IudmFyaWFibGUobil9KSl9Z2V0Q29uZmlnKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxyaG86dGhpcy5yaG8sZXBzaWxvbjp0aGlzLmVwc2lsb259fXN0YXRpYyBmcm9tQ29uZmlnKGUsdCl7cmV0dXJuIG5ldyBlKHQubGVhcm5pbmdSYXRlLHQucmhvLHQuZXBzaWxvbil9fSxVdz1jbGFzcyBleHRlbmRzIFJye3N0YXRpYyBnZXQgY2xhc3NOYW1lKCl7cmV0dXJuXCJBZGFncmFkXCJ9Y29uc3RydWN0b3IoZSx0PS4xKXtzdXBlcigpLHRoaXMubGVhcm5pbmdSYXRlPWUsdGhpcy5pbml0aWFsQWNjdW11bGF0b3JWYWx1ZT10LHRoaXMuYWNjdW11bGF0ZWRHcmFkcz1bXX1hcHBseUdyYWRpZW50cyhlKXsoQXJyYXkuaXNBcnJheShlKT9lLm1hcCh0PT50Lm5hbWUpOk9iamVjdC5rZXlzKGUpKS5mb3JFYWNoKCh0LG4pPT57bGV0IGE9UC5yZWdpc3RlcmVkVmFyaWFibGVzW3RdO3RoaXMuYWNjdW11bGF0ZWRHcmFkc1tuXT09bnVsbCYmKHRoaXMuYWNjdW11bGF0ZWRHcmFkc1tuXT17b3JpZ2luYWxOYW1lOmAke3R9L2FjY3VtdWxhdG9yYCx2YXJpYWJsZTpPKCgpPT55bihhLnNoYXBlLHRoaXMuaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWUpLnZhcmlhYmxlKCExKSl9KTtsZXQgcj1BcnJheS5pc0FycmF5KGUpP2Vbbl0udGVuc29yOmVbdF07aWYocj09bnVsbClyZXR1cm47bGV0IHM9dGhpcy5hY2N1bXVsYXRlZEdyYWRzW25dLnZhcmlhYmxlO08oKCk9PntsZXQgaT1YKHMscHQocikpO3MuYXNzaWduKGkpO2xldCBvPVgoeihoZShyLHJuKFgoaSxQLmJhY2tlbmQuZXBzaWxvbigpKSkpLC10aGlzLmxlYXJuaW5nUmF0ZSksYSk7YS5hc3NpZ24obyl9KX0pLHRoaXMuaW5jcmVtZW50SXRlcmF0aW9ucygpfWRpc3Bvc2UoKXt0aGlzLmFjY3VtdWxhdGVkR3JhZHMhPW51bGwmJkVlKHRoaXMuYWNjdW11bGF0ZWRHcmFkcy5tYXAoZT0+ZS52YXJpYWJsZSkpfWFzeW5jIGdldFdlaWdodHMoKXtyZXR1cm5bYXdhaXQgdGhpcy5zYXZlSXRlcmF0aW9ucygpXS5jb25jYXQodGhpcy5hY2N1bXVsYXRlZEdyYWRzLm1hcChlPT4oe25hbWU6ZS5vcmlnaW5hbE5hbWUsdGVuc29yOmUudmFyaWFibGV9KSkpfWFzeW5jIHNldFdlaWdodHMoZSl7ZT1hd2FpdCB0aGlzLmV4dHJhY3RJdGVyYXRpb25zKGUpO2xldCB0PSExO3RoaXMuYWNjdW11bGF0ZWRHcmFkcz1lLm1hcChuPT4oe29yaWdpbmFsTmFtZTpuLm5hbWUsdmFyaWFibGU6bi50ZW5zb3IudmFyaWFibGUodCl9KSl9Z2V0Q29uZmlnKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxpbml0aWFsQWNjdW11bGF0b3JWYWx1ZTp0aGlzLmluaXRpYWxBY2N1bXVsYXRvclZhbHVlfX1zdGF0aWMgZnJvbUNvbmZpZyhlLHQpe3JldHVybiBuZXcgZSh0LmxlYXJuaW5nUmF0ZSx0LmluaXRpYWxBY2N1bXVsYXRvclZhbHVlKX19LEd3PWNsYXNzIGV4dGVuZHMgUnJ7c3RhdGljIGdldCBjbGFzc05hbWUoKXtyZXR1cm5cIkFkYW1cIn1jb25zdHJ1Y3RvcihlLHQsbixhPW51bGwpe3N1cGVyKCksdGhpcy5sZWFybmluZ1JhdGU9ZSx0aGlzLmJldGExPXQsdGhpcy5iZXRhMj1uLHRoaXMuZXBzaWxvbj1hLHRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudD1bXSx0aGlzLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50PVtdLE8oKCk9Pnt0aGlzLmFjY0JldGExPXhlKHQpLnZhcmlhYmxlKCksdGhpcy5hY2NCZXRhMj14ZShuKS52YXJpYWJsZSgpfSksYT09bnVsbCYmKHRoaXMuZXBzaWxvbj1QLmJhY2tlbmQuZXBzaWxvbigpKX1hcHBseUdyYWRpZW50cyhlKXtsZXQgdD1BcnJheS5pc0FycmF5KGUpP2UubWFwKG49Pm4ubmFtZSk6T2JqZWN0LmtleXMoZSk7TygoKT0+e2xldCBuPXBlKDEsdGhpcy5hY2NCZXRhMSksYT1wZSgxLHRoaXMuYWNjQmV0YTIpO3QuZm9yRWFjaCgocixzKT0+e2xldCBpPVAucmVnaXN0ZXJlZFZhcmlhYmxlc1tyXSxvPSExO3RoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFtzXT09bnVsbCYmKHRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFtzXT17b3JpZ2luYWxOYW1lOmAke3J9L21gLHZhcmlhYmxlOk8oKCk9PnFlKGkpLnZhcmlhYmxlKG8pKX0pLHRoaXMuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnRbc109PW51bGwmJih0aGlzLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50W3NdPXtvcmlnaW5hbE5hbWU6YCR7cn0vdmAsdmFyaWFibGU6TygoKT0+cWUoaSkudmFyaWFibGUobykpfSk7bGV0IGw9QXJyYXkuaXNBcnJheShlKT9lW3NdLnRlbnNvcjplW3JdO2lmKGw9PW51bGwpcmV0dXJuO2xldCB1PXRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFtzXS52YXJpYWJsZSxwPXRoaXMuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnRbc10udmFyaWFibGUsZD1YKHoodSx0aGlzLmJldGExKSx6KGwsMS10aGlzLmJldGExKSksYz1YKHoocCx0aGlzLmJldGEyKSx6KHB0KGwpLDEtdGhpcy5iZXRhMikpLGg9aGUoZCxuKSxtPWhlKGMsYSk7dS5hc3NpZ24oZCkscC5hc3NpZ24oYyk7bGV0IGY9WCh6KGhlKGgsWChybihtKSx0aGlzLmVwc2lsb24pKSwtdGhpcy5sZWFybmluZ1JhdGUpLGkpO2kuYXNzaWduKGYpfSksdGhpcy5hY2NCZXRhMS5hc3NpZ24oeih0aGlzLmFjY0JldGExLHRoaXMuYmV0YTEpKSx0aGlzLmFjY0JldGEyLmFzc2lnbih6KHRoaXMuYWNjQmV0YTIsdGhpcy5iZXRhMikpfSksdGhpcy5pbmNyZW1lbnRJdGVyYXRpb25zKCl9ZGlzcG9zZSgpe3RoaXMuYWNjQmV0YTEuZGlzcG9zZSgpLHRoaXMuYWNjQmV0YTIuZGlzcG9zZSgpLHRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudCE9bnVsbCYmRWUodGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50Lm1hcChlPT5lLnZhcmlhYmxlKSksdGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudCE9bnVsbCYmRWUodGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudC5tYXAoZT0+ZS52YXJpYWJsZSkpfWFzeW5jIGdldFdlaWdodHMoKXtsZXQgZT1bLi4udGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50LC4uLnRoaXMuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnRdO3JldHVyblthd2FpdCB0aGlzLnNhdmVJdGVyYXRpb25zKCldLmNvbmNhdChlLm1hcCh0PT4oe25hbWU6dC5vcmlnaW5hbE5hbWUsdGVuc29yOnQudmFyaWFibGV9KSkpfWFzeW5jIHNldFdlaWdodHMoZSl7ZT1hd2FpdCB0aGlzLmV4dHJhY3RJdGVyYXRpb25zKGUpLE8oKCk9Pnt0aGlzLmFjY0JldGExLmFzc2lnbih1cih0aGlzLmJldGExLHRoaXMuaXRlcmF0aW9uc18rMSkpLHRoaXMuYWNjQmV0YTIuYXNzaWduKHVyKHRoaXMuYmV0YTIsdGhpcy5pdGVyYXRpb25zXysxKSl9KTtsZXQgdD1lLmxlbmd0aC8yLG49ITE7dGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50PWUuc2xpY2UoMCx0KS5tYXAoYT0+KHtvcmlnaW5hbE5hbWU6YS5uYW1lLHZhcmlhYmxlOmEudGVuc29yLnZhcmlhYmxlKG4pfSkpLHRoaXMuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnQ9ZS5zbGljZSh0LHQqMikubWFwKGE9Pih7b3JpZ2luYWxOYW1lOmEubmFtZSx2YXJpYWJsZTphLnRlbnNvci52YXJpYWJsZShuKX0pKX1nZXRDb25maWcoKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLGJldGExOnRoaXMuYmV0YTEsYmV0YTI6dGhpcy5iZXRhMixlcHNpbG9uOnRoaXMuZXBzaWxvbn19c3RhdGljIGZyb21Db25maWcoZSx0KXtyZXR1cm4gbmV3IGUodC5sZWFybmluZ1JhdGUsdC5iZXRhMSx0LmJldGEyLHQuZXBzaWxvbil9fSxIdz1jbGFzcyBleHRlbmRzIFJye3N0YXRpYyBnZXQgY2xhc3NOYW1lKCl7cmV0dXJuXCJBZGFtYXhcIn1jb25zdHJ1Y3RvcihlLHQsbixhPW51bGwscj0wKXtzdXBlcigpLHRoaXMubGVhcm5pbmdSYXRlPWUsdGhpcy5iZXRhMT10LHRoaXMuYmV0YTI9bix0aGlzLmVwc2lsb249YSx0aGlzLmRlY2F5PXIsdGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50PVtdLHRoaXMuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm09W10sTygoKT0+e3RoaXMuaXRlcmF0aW9uPXhlKDApLnZhcmlhYmxlKCksdGhpcy5hY2NCZXRhMT14ZSh0KS52YXJpYWJsZSgpfSksYT09bnVsbCYmKHRoaXMuZXBzaWxvbj1QLmJhY2tlbmQuZXBzaWxvbigpKX1hcHBseUdyYWRpZW50cyhlKXtsZXQgdD1BcnJheS5pc0FycmF5KGUpP2UubWFwKG49Pm4ubmFtZSk6T2JqZWN0LmtleXMoZSk7TygoKT0+e2xldCBuPXBlKDEsdGhpcy5hY2NCZXRhMSksYT1oZSgtdGhpcy5sZWFybmluZ1JhdGUsWCh6KHRoaXMuaXRlcmF0aW9uLHRoaXMuZGVjYXkpLDEpKTt0LmZvckVhY2goKHIscyk9PntsZXQgaT1QLnJlZ2lzdGVyZWRWYXJpYWJsZXNbcl0sbz0hMTt0aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbc109PW51bGwmJih0aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbc109e29yaWdpbmFsTmFtZTpgJHtyfS9tYCx2YXJpYWJsZTpxZShpKS52YXJpYWJsZShvKX0pLHRoaXMuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm1bc109PW51bGwmJih0aGlzLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtW3NdPXtvcmlnaW5hbE5hbWU6YCR7cn0vdmAsdmFyaWFibGU6cWUoaSkudmFyaWFibGUobyl9KTtsZXQgbD1BcnJheS5pc0FycmF5KGUpP2Vbc10udGVuc29yOmVbcl07aWYobD09bnVsbClyZXR1cm47bGV0IHU9dGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W3NdLnZhcmlhYmxlLHA9dGhpcy5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybVtzXS52YXJpYWJsZSxkPVgoeih1LHRoaXMuYmV0YTEpLHoobCwxLXRoaXMuYmV0YTEpKSxjPXoocCx0aGlzLmJldGEyKSxoPUx0KGwpLG09aHIoYyxoKTt1LmFzc2lnbihkKSxwLmFzc2lnbihtKTtsZXQgZj1YKHooaGUoYSxuKSxoZShkLFgobSx0aGlzLmVwc2lsb24pKSksaSk7aS5hc3NpZ24oZil9KSx0aGlzLml0ZXJhdGlvbi5hc3NpZ24oWCh0aGlzLml0ZXJhdGlvbiwxKSksdGhpcy5hY2NCZXRhMS5hc3NpZ24oeih0aGlzLmFjY0JldGExLHRoaXMuYmV0YTEpKX0pLHRoaXMuaW5jcmVtZW50SXRlcmF0aW9ucygpfWRpc3Bvc2UoKXt0aGlzLmFjY0JldGExLmRpc3Bvc2UoKSx0aGlzLml0ZXJhdGlvbi5kaXNwb3NlKCksdGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50IT1udWxsJiZFZSh0aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQubWFwKGU9PmUudmFyaWFibGUpKSx0aGlzLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtIT1udWxsJiZFZSh0aGlzLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtLm1hcChlPT5lLnZhcmlhYmxlKSl9YXN5bmMgZ2V0V2VpZ2h0cygpe3Rocm93IG5ldyBFcnJvcihcImdldFdlaWdodHMoKSBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIEFkYW1heCB5ZXQuXCIpfWFzeW5jIHNldFdlaWdodHMoZSl7dGhyb3cgbmV3IEVycm9yKFwic2V0V2VpZ2h0cygpIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgQWRhbWF4IHlldC5cIil9Z2V0Q29uZmlnKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxiZXRhMTp0aGlzLmJldGExLGJldGEyOnRoaXMuYmV0YTIsZXBzaWxvbjp0aGlzLmVwc2lsb24sZGVjYXk6dGhpcy5kZWNheX19c3RhdGljIGZyb21Db25maWcoZSx0KXtyZXR1cm4gbmV3IGUodC5sZWFybmluZ1JhdGUsdC5iZXRhMSx0LmJldGEyLHQuZXBzaWxvbix0LmRlY2F5KX19LGZmPWNsYXNzIGV4dGVuZHMgUnJ7c3RhdGljIGdldCBjbGFzc05hbWUoKXtyZXR1cm5cIlNHRFwifWNvbnN0cnVjdG9yKGUpe3N1cGVyKCksdGhpcy5sZWFybmluZ1JhdGU9ZSx0aGlzLnNldExlYXJuaW5nUmF0ZShlKX1hcHBseUdyYWRpZW50cyhlKXsoQXJyYXkuaXNBcnJheShlKT9lLm1hcCh0PT50Lm5hbWUpOk9iamVjdC5rZXlzKGUpKS5mb3JFYWNoKCh0LG4pPT57bGV0IGE9QXJyYXkuaXNBcnJheShlKT9lW25dLnRlbnNvcjplW3RdO2lmKGE9PW51bGwpcmV0dXJuO2xldCByPVAucmVnaXN0ZXJlZFZhcmlhYmxlc1t0XTtPKCgpPT57bGV0IHM9WCh6KHRoaXMuYyxhKSxyKTtyLmFzc2lnbihzKX0pfSksdGhpcy5pbmNyZW1lbnRJdGVyYXRpb25zKCl9c2V0TGVhcm5pbmdSYXRlKGUpe3RoaXMubGVhcm5pbmdSYXRlPWUsdGhpcy5jIT1udWxsJiZ0aGlzLmMuZGlzcG9zZSgpLHRoaXMuYz1IdCh4ZSgtZSkpfWRpc3Bvc2UoKXt0aGlzLmMuZGlzcG9zZSgpfWFzeW5jIGdldFdlaWdodHMoKXtyZXR1cm5bYXdhaXQgdGhpcy5zYXZlSXRlcmF0aW9ucygpXX1hc3luYyBzZXRXZWlnaHRzKGUpe2lmKGU9YXdhaXQgdGhpcy5leHRyYWN0SXRlcmF0aW9ucyhlKSxlLmxlbmd0aCE9PTApdGhyb3cgbmV3IEVycm9yKFwiU0dEIG9wdGltaXplciBkb2VzIG5vdCBoYXZlIHNldHRhYmxlIHdlaWdodHMuXCIpfWdldENvbmZpZygpe3JldHVybntsZWFybmluZ1JhdGU6dGhpcy5sZWFybmluZ1JhdGV9fXN0YXRpYyBmcm9tQ29uZmlnKGUsdCl7cmV0dXJuIG5ldyBlKHQubGVhcm5pbmdSYXRlKX19LGp3PWNsYXNzIGV4dGVuZHMgZmZ7c3RhdGljIGdldCBjbGFzc05hbWUoKXtyZXR1cm5cIk1vbWVudHVtXCJ9Y29uc3RydWN0b3IoZSx0LG49ITEpe3N1cGVyKGUpLHRoaXMubGVhcm5pbmdSYXRlPWUsdGhpcy5tb21lbnR1bT10LHRoaXMudXNlTmVzdGVyb3Y9bix0aGlzLmFjY3VtdWxhdGlvbnM9W10sdGhpcy5tPXhlKHRoaXMubW9tZW50dW0pfWFwcGx5R3JhZGllbnRzKGUpeyhBcnJheS5pc0FycmF5KGUpP2UubWFwKHQ9PnQubmFtZSk6T2JqZWN0LmtleXMoZSkpLmZvckVhY2goKHQsbik9PntsZXQgYT1QLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdF07dGhpcy5hY2N1bXVsYXRpb25zW25dPT1udWxsJiYodGhpcy5hY2N1bXVsYXRpb25zW25dPXtvcmlnaW5hbE5hbWU6YCR7dH0vbW9tZW50dW1gLHZhcmlhYmxlOk8oKCk9PnFlKGEpLnZhcmlhYmxlKCExKSl9KTtsZXQgcj10aGlzLmFjY3VtdWxhdGlvbnNbbl0udmFyaWFibGUscz1BcnJheS5pc0FycmF5KGUpP2Vbbl0udGVuc29yOmVbdF07cyE9bnVsbCYmTygoKT0+e2xldCBpLG89WCh6KHRoaXMubSxyKSxzKTt0aGlzLnVzZU5lc3Rlcm92P2k9WCh6KHRoaXMuYyxYKHMseihvLHRoaXMubSkpKSxhKTppPVgoeih0aGlzLmMsbyksYSksci5hc3NpZ24obyksYS5hc3NpZ24oaSl9KX0pLHRoaXMuaW5jcmVtZW50SXRlcmF0aW9ucygpfWRpc3Bvc2UoKXt0aGlzLm0uZGlzcG9zZSgpLHRoaXMuYWNjdW11bGF0aW9ucyE9bnVsbCYmRWUodGhpcy5hY2N1bXVsYXRpb25zLm1hcChlPT5lLnZhcmlhYmxlKSl9c2V0TW9tZW50dW0oZSl7dGhpcy5tb21lbnR1bT1lfWFzeW5jIGdldFdlaWdodHMoKXtyZXR1cm5bYXdhaXQgdGhpcy5zYXZlSXRlcmF0aW9ucygpXS5jb25jYXQodGhpcy5hY2N1bXVsYXRpb25zLm1hcChlPT4oe25hbWU6ZS5vcmlnaW5hbE5hbWUsdGVuc29yOmUudmFyaWFibGV9KSkpfWFzeW5jIHNldFdlaWdodHMoZSl7ZT1hd2FpdCB0aGlzLmV4dHJhY3RJdGVyYXRpb25zKGUpO2xldCB0PSExO3RoaXMuYWNjdW11bGF0aW9ucz1lLm1hcChuPT4oe29yaWdpbmFsTmFtZTpuLm5hbWUsdmFyaWFibGU6bi50ZW5zb3IudmFyaWFibGUodCl9KSl9Z2V0Q29uZmlnKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxtb21lbnR1bTp0aGlzLm1vbWVudHVtLHVzZU5lc3Rlcm92OnRoaXMudXNlTmVzdGVyb3Z9fXN0YXRpYyBmcm9tQ29uZmlnKGUsdCl7cmV0dXJuIG5ldyBlKHQubGVhcm5pbmdSYXRlLHQubW9tZW50dW0sdC51c2VOZXN0ZXJvdil9fSxxdz1jbGFzcyBleHRlbmRzIFJye3N0YXRpYyBnZXQgY2xhc3NOYW1lKCl7cmV0dXJuXCJSTVNQcm9wXCJ9Y29uc3RydWN0b3IoZSx0PS45LG49MCxhPW51bGwscj0hMSl7aWYoc3VwZXIoKSx0aGlzLmxlYXJuaW5nUmF0ZT1lLHRoaXMuZGVjYXk9dCx0aGlzLm1vbWVudHVtPW4sdGhpcy5lcHNpbG9uPWEsdGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzPVtdLHRoaXMuYWNjdW11bGF0ZWRNb21lbnRzPVtdLHRoaXMuYWNjdW11bGF0ZWRNZWFuR3JhZHM9W10sdGhpcy5jZW50ZXJlZD1yLGE9PW51bGwmJih0aGlzLmVwc2lsb249UC5iYWNrZW5kLmVwc2lsb24oKSksZT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJsZWFybmluZ1JhdGUgZm9yIFJNU1Byb3BPcHRpbWl6ZXIgbXVzdCBiZSBkZWZpbmVkLlwiKX1hcHBseUdyYWRpZW50cyhlKXsoQXJyYXkuaXNBcnJheShlKT9lLm1hcCh0PT50Lm5hbWUpOk9iamVjdC5rZXlzKGUpKS5mb3JFYWNoKCh0LG4pPT57bGV0IGE9UC5yZWdpc3RlcmVkVmFyaWFibGVzW3RdLHI9ITE7dGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW25dPT1udWxsJiYodGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW25dPXtvcmlnaW5hbE5hbWU6YCR7dH0vcm1zYCx2YXJpYWJsZTpPKCgpPT5xZShhKS52YXJpYWJsZShyKSl9KSx0aGlzLmFjY3VtdWxhdGVkTW9tZW50c1tuXT09bnVsbCYmKHRoaXMuYWNjdW11bGF0ZWRNb21lbnRzW25dPXtvcmlnaW5hbE5hbWU6YCR7dH0vbW9tZW50dW1gLHZhcmlhYmxlOk8oKCk9PnFlKGEpLnZhcmlhYmxlKHIpKX0pLHRoaXMuYWNjdW11bGF0ZWRNZWFuR3JhZHNbbl09PW51bGwmJnRoaXMuY2VudGVyZWQmJih0aGlzLmFjY3VtdWxhdGVkTWVhbkdyYWRzW25dPXtvcmlnaW5hbE5hbWU6YCR7dH0vbWdgLHZhcmlhYmxlOk8oKCk9PnFlKGEpLnZhcmlhYmxlKHIpKX0pO2xldCBzPUFycmF5LmlzQXJyYXkoZSk/ZVtuXS50ZW5zb3I6ZVt0XTtpZihzPT1udWxsKXJldHVybjtsZXQgaT10aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbbl0udmFyaWFibGUsbz10aGlzLmFjY3VtdWxhdGVkTW9tZW50c1tuXS52YXJpYWJsZTtPKCgpPT57bGV0IGw9WCh6KGksdGhpcy5kZWNheSkseihwdChzKSwxLXRoaXMuZGVjYXkpKTtpZih0aGlzLmNlbnRlcmVkKXtsZXQgdT10aGlzLmFjY3VtdWxhdGVkTWVhbkdyYWRzW25dLnZhcmlhYmxlLHA9WCh6KHUsdGhpcy5kZWNheSkseihzLDEtdGhpcy5kZWNheSkpLGQ9aGUoeihzLHRoaXMubGVhcm5pbmdSYXRlKSxybihwZShsLFgocHQocCksdGhpcy5lcHNpbG9uKSkpKSxjPVgoeihvLHRoaXMubW9tZW50dW0pLGQpO2kuYXNzaWduKGwpLHUuYXNzaWduKHApLG8uYXNzaWduKGMpO2xldCBoPXBlKGEsYyk7YS5hc3NpZ24oaCl9ZWxzZXtsZXQgdT1YKHooaSx0aGlzLmRlY2F5KSx6KHB0KHMpLDEtdGhpcy5kZWNheSkpLHA9WCh6KG8sdGhpcy5tb21lbnR1bSksaGUoeihzLHRoaXMubGVhcm5pbmdSYXRlKSxybihYKHUsdGhpcy5lcHNpbG9uKSkpKTtpLmFzc2lnbih1KSxvLmFzc2lnbihwKTtsZXQgZD1wZShhLHApO2EuYXNzaWduKGQpfX0pfSksdGhpcy5pbmNyZW1lbnRJdGVyYXRpb25zKCl9ZGlzcG9zZSgpe3RoaXMuYWNjdW11bGF0ZWRNZWFuU3F1YXJlcyE9bnVsbCYmRWUodGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzLm1hcChlPT5lLnZhcmlhYmxlKSksdGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkcyE9bnVsbCYmdGhpcy5jZW50ZXJlZCYmRWUodGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkcy5tYXAoZT0+ZS52YXJpYWJsZSkpLHRoaXMuYWNjdW11bGF0ZWRNb21lbnRzIT1udWxsJiZFZSh0aGlzLmFjY3VtdWxhdGVkTW9tZW50cy5tYXAoZT0+ZS52YXJpYWJsZSkpfWFzeW5jIGdldFdlaWdodHMoKXtsZXQgZT1bLi4udGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzLC4uLnRoaXMuYWNjdW11bGF0ZWRNb21lbnRzXTtyZXR1cm4gdGhpcy5jZW50ZXJlZCYmZS5wdXNoKC4uLnRoaXMuYWNjdW11bGF0ZWRNZWFuR3JhZHMpLFthd2FpdCB0aGlzLnNhdmVJdGVyYXRpb25zKCldLmNvbmNhdChlLm1hcCh0PT4oe25hbWU6dC5vcmlnaW5hbE5hbWUsdGVuc29yOnQudmFyaWFibGV9KSkpfWFzeW5jIHNldFdlaWdodHMoZSl7ZT1hd2FpdCB0aGlzLmV4dHJhY3RJdGVyYXRpb25zKGUpO2xldCB0PXRoaXMuY2VudGVyZWQ/ZS5sZW5ndGgvMzplLmxlbmd0aC8yLG49ITE7dGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzPWUuc2xpY2UoMCx0KS5tYXAoYT0+KHtvcmlnaW5hbE5hbWU6YS5uYW1lLHZhcmlhYmxlOmEudGVuc29yLnZhcmlhYmxlKG4pfSkpLHRoaXMuYWNjdW11bGF0ZWRNb21lbnRzPWUuc2xpY2UodCx0KjIpLm1hcChhPT4oe29yaWdpbmFsTmFtZTphLm5hbWUsdmFyaWFibGU6YS50ZW5zb3IudmFyaWFibGUobil9KSksdGhpcy5jZW50ZXJlZCYmKHRoaXMuYWNjdW11bGF0ZWRNZWFuR3JhZHM9ZS5zbGljZSh0KjIsdCozKS5tYXAoYT0+KHtvcmlnaW5hbE5hbWU6YS5uYW1lLHZhcmlhYmxlOmEudGVuc29yLnZhcmlhYmxlKG4pfSkpKX1nZXRDb25maWcoKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLGRlY2F5OnRoaXMuZGVjYXksbW9tZW50dW06dGhpcy5tb21lbnR1bSxlcHNpbG9uOnRoaXMuZXBzaWxvbixjZW50ZXJlZDp0aGlzLmNlbnRlcmVkfX1zdGF0aWMgZnJvbUNvbmZpZyhlLHQpe3JldHVybiBuZXcgZSh0LmxlYXJuaW5nUmF0ZSx0LmRlY2F5LHQubW9tZW50dW0sdC5lcHNpbG9uLHQuY2VudGVyZWQpfX0sTkI9W1Z3LFV3LEd3LEh3LGp3LHF3LGZmXTtmdW5jdGlvbiBUQigpe2ZvcihsZXQgZSBvZiBOQilPVChlKX12YXIganQ9e307X2UoanQse0NvbXBvc2l0ZUFycmF5QnVmZmVyOigpPT5Gcixicm93c2VyRmlsZXM6KCk9PkRCLGJyb3dzZXJIVFRQUmVxdWVzdDooKT0+ekIsY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnM6KCk9PmhPLGNvcHlNb2RlbDooKT0+TU8sZGVjb2RlV2VpZ2h0czooKT0+bE4sZGVjb2RlV2VpZ2h0c1N0cmVhbTooKT0+cE4sZW5jb2RlV2VpZ2h0czooKT0+b08sZnJvbU1lbW9yeTooKT0+QkIsZnJvbU1lbW9yeVN5bmM6KCk9PkJULGdldExvYWRIYW5kbGVyczooKT0+d08sZ2V0TW9kZWxBcnRpZmFjdHNGb3JKU09OOigpPT5NdixnZXRNb2RlbEFydGlmYWN0c0ZvckpTT05TeW5jOigpPT5kTixnZXRNb2RlbEFydGlmYWN0c0luZm9Gb3JKU09OOigpPT5yZCxnZXRTYXZlSGFuZGxlcnM6KCk9PnZPLGdldFdlaWdodFNwZWNzOigpPT5feCxodHRwOigpPT5Ydyxpc0hUVFBTY2hlbWU6KCk9PlB4LGxpc3RNb2RlbHM6KCk9PkRPLGxvYWRXZWlnaHRzOigpPT5NQixtb3ZlTW9kZWw6KCk9Pk9PLHJlZ2lzdGVyTG9hZFJvdXRlcjooKT0+eE8scmVnaXN0ZXJTYXZlUm91dGVyOigpPT55TyxyZW1vdmVNb2RlbDooKT0+Uk8sd2VpZ2h0c0xvYWRlckZhY3Rvcnk6KCk9PkxULHdpdGhTYXZlSGFuZGxlcjooKT0+VkIsd2l0aFNhdmVIYW5kbGVyU3luYzooKT0+VUJ9KTt2YXIgQ0I9XCJtb2RlbFwiLEVCPVwiLmpzb25cIixfQj1cIi53ZWlnaHRzLmJpblwiO2Z1bmN0aW9uIGFJKGUpe3JldHVybiBuZXcgUHJvbWlzZSh0PT5zZXRUaW1lb3V0KHQpKS50aGVuKGUpfXZhciBZaD1jbGFzcyBPeHtjb25zdHJ1Y3Rvcih0KXtpZighRygpLmdldEJvb2woXCJJU19CUk9XU0VSXCIpKXRocm93IG5ldyBFcnJvcihcImJyb3dzZXJEb3dubG9hZHMoKSBjYW5ub3QgcHJvY2VlZCBiZWNhdXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGlzIG5vdCBhIGJyb3dzZXIuXCIpO3Quc3RhcnRzV2l0aChPeC5VUkxfU0NIRU1FKSYmKHQ9dC5zbGljZShPeC5VUkxfU0NIRU1FLmxlbmd0aCkpLCh0PT1udWxsfHx0Lmxlbmd0aD09PTApJiYodD1DQiksdGhpcy5tb2RlbEpzb25GaWxlTmFtZT10K0VCLHRoaXMud2VpZ2h0RGF0YUZpbGVOYW1lPXQrX0J9YXN5bmMgc2F2ZSh0KXtpZih0eXBlb2YgZG9jdW1lbnQ9PVwidW5kZWZpbmVkXCIpdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlciBkb3dubG9hZHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudCBzaW5jZSBgZG9jdW1lbnRgIGlzIG5vdCBwcmVzZW50XCIpO2xldCBuPUZyLmpvaW4odC53ZWlnaHREYXRhKSxhPXdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtuXSx7dHlwZTpcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwifSkpO2lmKHQubW9kZWxUb3BvbG9neSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXJEb3dubG9hZHMuc2F2ZSgpIGRvZXMgbm90IHN1cHBvcnQgc2F2aW5nIG1vZGVsIHRvcG9sb2d5IGluIGJpbmFyeSBmb3JtYXRzIHlldC5cIik7e2xldCByPVt7cGF0aHM6W1wiLi9cIit0aGlzLndlaWdodERhdGFGaWxlTmFtZV0sd2VpZ2h0czp0LndlaWdodFNwZWNzfV0scz1jTih0LHIpLGk9d2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KHMpXSx7dHlwZTpcImFwcGxpY2F0aW9uL2pzb25cIn0pKSxvPXRoaXMubW9kZWxKc29uQW5jaG9yPT1udWxsP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpOnRoaXMubW9kZWxKc29uQW5jaG9yO2lmKG8uZG93bmxvYWQ9dGhpcy5tb2RlbEpzb25GaWxlTmFtZSxvLmhyZWY9aSxhd2FpdCBhSSgoKT0+by5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIikpKSx0LndlaWdodERhdGEhPW51bGwpe2xldCBsPXRoaXMud2VpZ2h0RGF0YUFuY2hvcj09bnVsbD9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTp0aGlzLndlaWdodERhdGFBbmNob3I7bC5kb3dubG9hZD10aGlzLndlaWdodERhdGFGaWxlTmFtZSxsLmhyZWY9YSxhd2FpdCBhSSgoKT0+bC5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIikpKX1yZXR1cm57bW9kZWxBcnRpZmFjdHNJbmZvOnJkKHQpfX19fTtZaC5VUkxfU0NIRU1FPVwiZG93bmxvYWRzOi8vXCI7dmFyIEFCPWNsYXNze2NvbnN0cnVjdG9yKGUpe2lmKGU9PW51bGx8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKGBXaGVuIGNhbGxpbmcgYnJvd3NlckZpbGVzLCBhdCBsZWFzdCAxIGZpbGUgaXMgcmVxdWlyZWQsIGJ1dCByZWNlaXZlZCAke2V9YCk7dGhpcy5qc29uRmlsZT1lWzBdLHRoaXMud2VpZ2h0c0ZpbGVzPWUuc2xpY2UoMSl9YXN5bmMgbG9hZCgpe3JldHVybiBuZXcgUHJvbWlzZSgoZSx0KT0+e2xldCBuPW5ldyBGaWxlUmVhZGVyO24ub25sb2FkPWE9PntsZXQgcj1KU09OLnBhcnNlKGEudGFyZ2V0LnJlc3VsdCkscz1yLm1vZGVsVG9wb2xvZ3k7aWYocz09bnVsbCl7dChuZXcgRXJyb3IoYG1vZGVsVG9wb2xvZ3kgZmllbGQgaXMgbWlzc2luZyBmcm9tIGZpbGUgJHt0aGlzLmpzb25GaWxlLm5hbWV9YCkpO3JldHVybn1pZihyLndlaWdodHNNYW5pZmVzdD09bnVsbCl7dChuZXcgRXJyb3IoYHdlaWdodE1hbmlmZXN0IGZpZWxkIGlzIG1pc3NpbmcgZnJvbSBmaWxlICR7dGhpcy5qc29uRmlsZS5uYW1lfWApKTtyZXR1cm59aWYodGhpcy53ZWlnaHRzRmlsZXMubGVuZ3RoPT09MCl7ZSh7bW9kZWxUb3BvbG9neTpzfSk7cmV0dXJufWxldCBpPU12KHIsbz0+dGhpcy5sb2FkV2VpZ2h0cyhvKSk7ZShpKX0sbi5vbmVycm9yPWE9PnQoYEZhaWxlZCB0byByZWFkIG1vZGVsIHRvcG9sb2d5IGFuZCB3ZWlnaHRzIG1hbmlmZXN0IEpTT04gZnJvbSBmaWxlICcke3RoaXMuanNvbkZpbGUubmFtZX0nLiBCcm93c2VyRmlsZXMgc3VwcG9ydHMgbG9hZGluZyBLZXJhcy1zdHlsZSB0Zi5Nb2RlbCBhcnRpZmFjdHMgb25seS5gKSxuLnJlYWRBc1RleHQodGhpcy5qc29uRmlsZSl9KX1sb2FkV2VpZ2h0cyhlKXtsZXQgdD1bXSxuPVtdO2ZvcihsZXQgcyBvZiBlKXQucHVzaCguLi5zLndlaWdodHMpLG4ucHVzaCguLi5zLnBhdGhzKTtsZXQgYT10aGlzLmNoZWNrTWFuaWZlc3RBbmRXZWlnaHRGaWxlcyhlKSxyPW4ubWFwKHM9PnRoaXMubG9hZFdlaWdodHNGaWxlKHMsYVtzXSkpO3JldHVybiBQcm9taXNlLmFsbChyKS50aGVuKHM9Plt0LHNdKX1sb2FkV2VpZ2h0c0ZpbGUoZSx0KXtyZXR1cm4gbmV3IFByb21pc2UoKG4sYSk9PntsZXQgcj1uZXcgRmlsZVJlYWRlcjtyLm9ubG9hZD1zPT57bGV0IGk9cy50YXJnZXQucmVzdWx0O24oaSl9LHIub25lcnJvcj1zPT5hKGBGYWlsZWQgdG8gd2VpZ2h0cyBkYXRhIGZyb20gZmlsZSBvZiBwYXRoICcke2V9Jy5gKSxyLnJlYWRBc0FycmF5QnVmZmVyKHQpfSl9Y2hlY2tNYW5pZmVzdEFuZFdlaWdodEZpbGVzKGUpe2xldCB0PVtdLG49dGhpcy53ZWlnaHRzRmlsZXMubWFwKHI9PmVJKHIubmFtZSkpLGE9e307Zm9yKGxldCByIG9mIGUpci5wYXRocy5mb3JFYWNoKHM9PntsZXQgaT1lSShzKTtpZih0LmluZGV4T2YoaSkhPT0tMSl0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBmaWxlIGJhc2VuYW1lIGZvdW5kIGluIHdlaWdodHMgbWFuaWZlc3Q6ICcke2l9J2ApO2lmKHQucHVzaChpKSxuLmluZGV4T2YoaSk9PT0tMSl0aHJvdyBuZXcgRXJyb3IoYFdlaWdodCBmaWxlIHdpdGggYmFzZW5hbWUgJyR7aX0nIGlzIG5vdCBwcm92aWRlZC5gKTthW3NdPXRoaXMud2VpZ2h0c0ZpbGVzW24uaW5kZXhPZihpKV19KTtpZih0Lmxlbmd0aCE9PXRoaXMud2VpZ2h0c0ZpbGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYE1pc21hdGNoIGluIHRoZSBudW1iZXIgb2YgZmlsZXMgaW4gd2VpZ2h0cyBtYW5pZmVzdCAoJHt0Lmxlbmd0aH0pIGFuZCB0aGUgbnVtYmVyIG9mIHdlaWdodCBmaWxlcyBwcm92aWRlZCAoJHt0aGlzLndlaWdodHNGaWxlcy5sZW5ndGh9KS5gKTtyZXR1cm4gYX19LEZCPWU9PkcoKS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSYmIUFycmF5LmlzQXJyYXkoZSkmJmUuc3RhcnRzV2l0aChZaC5VUkxfU0NIRU1FKT8kQihlLnNsaWNlKFloLlVSTF9TQ0hFTUUubGVuZ3RoKSk6bnVsbDtnYS5yZWdpc3RlclNhdmVSb3V0ZXIoRkIpO2Z1bmN0aW9uICRCKGU9XCJtb2RlbFwiKXtyZXR1cm4gbmV3IFloKGUpfWZ1bmN0aW9uIERCKGUpe3JldHVybiBuZXcgQUIoZSl9ZnVuY3Rpb24gckkoZSx0LG4sYSl7aShlKSxuPW49PW51bGw/MDpuLGE9YT09bnVsbD8xOmEsbyhuLGEpO2xldCByPTAscz1sPT4obC50aGVuKHU9PntsZXQgcD1uKyArK3IvZS5sZW5ndGgqKGEtbik7cmV0dXJuIHQocCksdX0pLGwpO2Z1bmN0aW9uIGkobCl7QShsIT1udWxsJiZBcnJheS5pc0FycmF5KGwpJiZsLmxlbmd0aD4wLCgpPT5cInByb21pc2VzIG11c3QgYmUgYSBub25lIGVtcHR5IGFycmF5XCIpfWZ1bmN0aW9uIG8obCx1KXtBKGw+PTAmJmw8PTEsKCk9PmBQcm9ncmVzcyBmcmFjdGlvbiBtdXN0IGJlIGluIHJhbmdlIFswLCAxXSwgYnV0IGdvdCBzdGFydEZyYWN0aW9uICR7bH1gKSxBKHU+PTAmJnU8PTEsKCk9PmBQcm9ncmVzcyBmcmFjdGlvbiBtdXN0IGJlIGluIHJhbmdlIFswLCAxXSwgYnV0IGdvdCBlbmRGcmFjdGlvbiAke3V9YCksQSh1Pj1sLCgpPT5gc3RhcnRGcmFjdGlvbiBtdXN0IGJlIG5vIG1vcmUgdGhhbiBlbmRGcmFjdGlvbiwgYnV0IGdvdCBzdGFydEZyYWN0aW9uICR7bH0gYW5kIGVuZEZyYWN0aW9uICR7dX1gKX1yZXR1cm4gUHJvbWlzZS5hbGwoZS5tYXAocykpfWFzeW5jIGZ1bmN0aW9uIFBUKGUsdCl7dD09bnVsbCYmKHQ9e30pO2xldCBuPXQuZmV0Y2hGdW5jPT1udWxsP0coKS5wbGF0Zm9ybS5mZXRjaDp0LmZldGNoRnVuYyxhPWUubWFwKHM9Pm4ocyx0LnJlcXVlc3RJbml0LHtpc0JpbmFyeTohMH0pKSxyPSh0Lm9uUHJvZ3Jlc3M9PW51bGw/YXdhaXQgUHJvbWlzZS5hbGwoYSk6YXdhaXQgckkoYSx0Lm9uUHJvZ3Jlc3MsMCwuNSkpLm1hcChzPT5zLmFycmF5QnVmZmVyKCkpO3JldHVybiB0Lm9uUHJvZ3Jlc3M9PW51bGw/YXdhaXQgUHJvbWlzZS5hbGwocik6YXdhaXQgckkocix0Lm9uUHJvZ3Jlc3MsLjUsMSl9ZnVuY3Rpb24gUkIoZSx0KXt2YXIgbjtsZXQgYT10LmZldGNoRnVuYz09bnVsbD9HKCkucGxhdGZvcm0uZmV0Y2g6dC5mZXRjaEZ1bmMscj0wLHM7cmV0dXJuKG49dC5vblByb2dyZXNzKT09PW51bGx8fG49PT12b2lkIDB8fG4uY2FsbCh0LDApLG5ldyBSZWFkYWJsZVN0cmVhbSh7cHVsbDphc3luYyBpPT57Zm9yKHZhciBvO3I8ZS5sZW5ndGg7KXtzfHwocz0oYXdhaXQgYShlW3JdLHQucmVxdWVzdEluaXQse2lzQmluYXJ5OiEwfSkpLmJvZHkuZ2V0UmVhZGVyKCkpO2xldHtkb25lOmwsdmFsdWU6dX09YXdhaXQgcy5yZWFkKCk7aWYobCl7cisrLHM9dm9pZCAwLChvPXQub25Qcm9ncmVzcyk9PT1udWxsfHxvPT09dm9pZCAwfHxvLmNhbGwodCxyL2UubGVuZ3RoKTtjb250aW51ZX1pLmVucXVldWUodSk7cmV0dXJufWkuY2xvc2UoKX19KX1hc3luYyBmdW5jdGlvbiBNQihlLHQ9XCJcIixuLGEpe3JldHVybiBMVChyPT5QVChyLHtyZXF1ZXN0SW5pdDphfSkpKGUsdCxuKX1mdW5jdGlvbiBMVChlKXtyZXR1cm4gYXN5bmModCxuPVwiXCIsYSk9PntsZXQgcj10Lm1hcCgoKT0+ITEpLHM9e30saT1hIT1udWxsP2EubWFwKCgpPT4hMSk6W10sbz1bXTtpZih0LmZvckVhY2goKGgsbSk9PntsZXQgZj0wO2gud2VpZ2h0cy5mb3JFYWNoKGc9PntsZXQgYj1cInF1YW50aXphdGlvblwiaW4gZz9nLnF1YW50aXphdGlvbi5kdHlwZTpnLmR0eXBlLHk9dWlbYl0qb3QoZy5zaGFwZSkseD0oKT0+e3JbbV09ITAsc1ttXT09bnVsbCYmKHNbbV09W10pLHNbbV0ucHVzaCh7bWFuaWZlc3RFbnRyeTpnLGdyb3VwT2Zmc2V0OmYsc2l6ZUJ5dGVzOnl9KX07YSE9bnVsbD9hLmZvckVhY2goKHYsSSk9Pnt2PT09Zy5uYW1lJiYoeCgpLGlbSV09ITApfSk6eCgpLG8ucHVzaChnLm5hbWUpLGYrPXl9KX0pLCFpLmV2ZXJ5KGg9PmgpKXtsZXQgaD1hLmZpbHRlcigobSxmKT0+IWlbZl0pO3Rocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgd2VpZ2h0cyBpbiBtYW5pZmVzdCB3aXRoIG5hbWVzOiAke2guam9pbihcIiwgXCIpfS4gXG5NYW5pZmVzdCBKU09OIGhhcyB3ZWlnaHRzIHdpdGggbmFtZXM6ICR7by5qb2luKFwiLCBcIil9LmApfWxldCBsPXIucmVkdWNlKChoLG0sZik9PihtJiZoLnB1c2goZiksaCksW10pLHU9W107bC5mb3JFYWNoKGg9Pnt0W2hdLnBhdGhzLmZvckVhY2gobT0+e2xldCBmPW4rKG4uZW5kc1dpdGgoXCIvXCIpP1wiXCI6XCIvXCIpK207dS5wdXNoKGYpfSl9KTtsZXQgcD1hd2FpdCBlKHUpLGQ9e30sYz0wO3JldHVybiBsLmZvckVhY2goaD0+e2xldCBtPXRbaF0ucGF0aHMubGVuZ3RoLGY9bmV3IEZyKHAuc2xpY2UoYyxjK20pKTtzW2hdLmZvckVhY2goZz0+e2xldCBiPWYuc2xpY2UoZy5ncm91cE9mZnNldCxnLmdyb3VwT2Zmc2V0K2cuc2l6ZUJ5dGVzKSx5PWxOKGIsW2cubWFuaWZlc3RFbnRyeV0pO2ZvcihsZXQgeCBpbiB5KWRbeF09eVt4XX0pLGMrPW19KSxkfX12YXIgT0I9XCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIixQQj1cImFwcGxpY2F0aW9uL2pzb25cIixLdz1jbGFzc3tjb25zdHJ1Y3RvcihlLHQpe2lmKHRoaXMuREVGQVVMVF9NRVRIT0Q9XCJQT1NUXCIsdD09bnVsbCYmKHQ9e30pLHRoaXMud2VpZ2h0UGF0aFByZWZpeD10LndlaWdodFBhdGhQcmVmaXgsdGhpcy53ZWlnaHRVcmxDb252ZXJ0ZXI9dC53ZWlnaHRVcmxDb252ZXJ0ZXIsdC5mZXRjaEZ1bmMhPW51bGw/KEEodHlwZW9mIHQuZmV0Y2hGdW5jPT1cImZ1bmN0aW9uXCIsKCk9PlwiTXVzdCBwYXNzIGEgZnVuY3Rpb24gdGhhdCBtYXRjaGVzIHRoZSBzaWduYXR1cmUgb2YgYGZldGNoYCAoc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkpXCIpLHRoaXMuZmV0Y2g9dC5mZXRjaEZ1bmMpOnRoaXMuZmV0Y2g9RygpLnBsYXRmb3JtLmZldGNoLEEoZSE9bnVsbCYmZS5sZW5ndGg+MCwoKT0+XCJVUkwgcGF0aCBmb3IgaHR0cCBtdXN0IG5vdCBiZSBudWxsLCB1bmRlZmluZWQgb3IgZW1wdHkuXCIpLEFycmF5LmlzQXJyYXkoZSkmJkEoZS5sZW5ndGg9PT0yLCgpPT5gVVJMIHBhdGhzIGZvciBodHRwIG11c3QgaGF2ZSBhIGxlbmd0aCBvZiAyLCAoYWN0dWFsIGxlbmd0aCBpcyAke2UubGVuZ3RofSkuYCksdGhpcy5wYXRoPWUsdC5yZXF1ZXN0SW5pdCE9bnVsbCYmdC5yZXF1ZXN0SW5pdC5ib2R5IT1udWxsKXRocm93IG5ldyBFcnJvcihcInJlcXVlc3RJbml0IGlzIGV4cGVjdGVkIHRvIGhhdmUgbm8gcHJlLWV4aXN0aW5nIGJvZHksIGJ1dCBoYXMgb25lLlwiKTt0aGlzLnJlcXVlc3RJbml0PXQucmVxdWVzdEluaXR8fHt9LHRoaXMubG9hZE9wdGlvbnM9dH1hc3luYyBzYXZlKGUpe2lmKGUubW9kZWxUb3BvbG9neSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXJIVFRQUmVxdWVzdC5zYXZlKCkgZG9lcyBub3Qgc3VwcG9ydCBzYXZpbmcgbW9kZWwgdG9wb2xvZ3kgaW4gYmluYXJ5IGZvcm1hdHMgeWV0LlwiKTtsZXQgdD1PYmplY3QuYXNzaWduKHttZXRob2Q6dGhpcy5ERUZBVUxUX01FVEhPRH0sdGhpcy5yZXF1ZXN0SW5pdCk7dC5ib2R5PW5ldyBGb3JtRGF0YTtsZXQgbj1be3BhdGhzOltcIi4vbW9kZWwud2VpZ2h0cy5iaW5cIl0sd2VpZ2h0czplLndlaWdodFNwZWNzfV0sYT1jTihlLG4pO2lmKHQuYm9keS5hcHBlbmQoXCJtb2RlbC5qc29uXCIsbmV3IEJsb2IoW0pTT04uc3RyaW5naWZ5KGEpXSx7dHlwZTpQQn0pLFwibW9kZWwuanNvblwiKSxlLndlaWdodERhdGEhPW51bGwpe2xldCBzPUZyLmpvaW4oZS53ZWlnaHREYXRhKTt0LmJvZHkuYXBwZW5kKFwibW9kZWwud2VpZ2h0cy5iaW5cIixuZXcgQmxvYihbc10se3R5cGU6T0J9KSxcIm1vZGVsLndlaWdodHMuYmluXCIpfWxldCByPWF3YWl0IHRoaXMuZmV0Y2godGhpcy5wYXRoLHQpO2lmKHIub2spcmV0dXJue21vZGVsQXJ0aWZhY3RzSW5mbzpyZChlKSxyZXNwb25zZXM6W3JdfTt0aHJvdyBuZXcgRXJyb3IoYEJyb3dzZXJIVFRQUmVxdWVzdC5zYXZlKCkgZmFpbGVkIGR1ZSB0byBIVFRQIHJlc3BvbnNlIHN0YXR1cyAke3Iuc3RhdHVzfS5gKX1hc3luYyBsb2FkTW9kZWxKU09OKCl7bGV0IGU9YXdhaXQgdGhpcy5mZXRjaCh0aGlzLnBhdGgsdGhpcy5yZXF1ZXN0SW5pdCk7aWYoIWUub2spdGhyb3cgbmV3IEVycm9yKGBSZXF1ZXN0IHRvICR7dGhpcy5wYXRofSBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAke2Uuc3RhdHVzfS4gUGxlYXNlIHZlcmlmeSB0aGlzIFVSTCBwb2ludHMgdG8gdGhlIG1vZGVsIEpTT04gb2YgdGhlIG1vZGVsIHRvIGxvYWQuYCk7bGV0IHQ7dHJ5e3Q9YXdhaXQgZS5qc29uKCl9Y2F0Y2gocil7bGV0IHM9YEZhaWxlZCB0byBwYXJzZSBtb2RlbCBKU09OIG9mIHJlc3BvbnNlIGZyb20gJHt0aGlzLnBhdGh9LmA7dGhyb3cgdGhpcy5wYXRoLmVuZHNXaXRoKFwiLnBiXCIpP3MrPVwiIFlvdXIgcGF0aCBjb250YWlucyBhIC5wYiBmaWxlIGV4dGVuc2lvbi4gU3VwcG9ydCBmb3IgLnBiIG1vZGVscyBoYXZlIGJlZW4gcmVtb3ZlZCBpbiBUZW5zb3JGbG93LmpzIDEuMCBpbiBmYXZvciBvZiAuanNvbiBtb2RlbHMuIFlvdSBjYW4gcmUtY29udmVydCB5b3VyIFB5dGhvbiBUZW5zb3JGbG93IG1vZGVsIHVzaW5nIHRoZSBUZW5zb3JGbG93LmpzIDEuMCBjb252ZXJzaW9uIHNjcmlwdHMgb3IgeW91IGNhbiBjb252ZXJ0IHlvdXIucGIgbW9kZWxzIHdpdGggdGhlICdwYjJqc29uJ05QTSBzY3JpcHQgaW4gdGhlIHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIgcmVwb3NpdG9yeS5cIjpzKz1cIiBQbGVhc2UgbWFrZSBzdXJlIHRoZSBzZXJ2ZXIgaXMgc2VydmluZyB2YWxpZCBKU09OIGZvciB0aGlzIHJlcXVlc3QuXCIsbmV3IEVycm9yKHMpfWxldCBuPXQubW9kZWxUb3BvbG9neSxhPXQud2VpZ2h0c01hbmlmZXN0O2lmKG49PW51bGwmJmE9PW51bGwpdGhyb3cgbmV3IEVycm9yKGBUaGUgSlNPTiBmcm9tIEhUVFAgcGF0aCAke3RoaXMucGF0aH0gY29udGFpbnMgbmVpdGhlciBtb2RlbCB0b3BvbG9neSBvciBtYW5pZmVzdCBmb3Igd2VpZ2h0cy5gKTtyZXR1cm4gdH1hc3luYyBsb2FkKCl7aWYodGhpcy5sb2FkT3B0aW9ucy5zdHJlYW1XZWlnaHRzKXJldHVybiB0aGlzLmxvYWRTdHJlYW0oKTtsZXQgZT1hd2FpdCB0aGlzLmxvYWRNb2RlbEpTT04oKTtyZXR1cm4gTXYoZSx0PT50aGlzLmxvYWRXZWlnaHRzKHQpKX1hc3luYyBsb2FkU3RyZWFtKCl7bGV0IGU9YXdhaXQgdGhpcy5sb2FkTW9kZWxKU09OKCksdD1hd2FpdCB0aGlzLmdldFdlaWdodFVybHMoZS53ZWlnaHRzTWFuaWZlc3QpLG49X3goZS53ZWlnaHRzTWFuaWZlc3QpLGE9KCk9PlJCKHQsdGhpcy5sb2FkT3B0aW9ucyk7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7d2VpZ2h0U3BlY3M6bixnZXRXZWlnaHRTdHJlYW06YX0pfWFzeW5jIGdldFdlaWdodFVybHMoZSl7bGV0IHQ9QXJyYXkuaXNBcnJheSh0aGlzLnBhdGgpP3RoaXMucGF0aFsxXTp0aGlzLnBhdGgsW24sYV09TEIodCkscj10aGlzLndlaWdodFBhdGhQcmVmaXh8fG4scz1bXSxpPVtdO2ZvcihsZXQgbyBvZiBlKWZvcihsZXQgbCBvZiBvLnBhdGhzKXRoaXMud2VpZ2h0VXJsQ29udmVydGVyIT1udWxsP2kucHVzaCh0aGlzLndlaWdodFVybENvbnZlcnRlcihsKSk6cy5wdXNoKHIrbCthKTtyZXR1cm4gdGhpcy53ZWlnaHRVcmxDb252ZXJ0ZXImJnMucHVzaCguLi5hd2FpdCBQcm9taXNlLmFsbChpKSksc31hc3luYyBsb2FkV2VpZ2h0cyhlKXtsZXQgdD1hd2FpdCB0aGlzLmdldFdlaWdodFVybHMoZSksbj1feChlKSxhPWF3YWl0IFBUKHQsdGhpcy5sb2FkT3B0aW9ucyk7cmV0dXJuW24sYV19fTtLdy5VUkxfU0NIRU1FX1JFR0VYPS9eaHR0cHM/OlxcL1xcLy87ZnVuY3Rpb24gTEIoZSl7bGV0IHQ9ZS5sYXN0SW5kZXhPZihcIi9cIiksbj1lLmxhc3RJbmRleE9mKFwiP1wiKSxhPWUuc3Vic3RyaW5nKDAsdCkscj1uPnQ/ZS5zdWJzdHJpbmcobik6XCJcIjtyZXR1cm5bYStcIi9cIixyXX1mdW5jdGlvbiBQeChlKXtyZXR1cm4gZS5tYXRjaChLdy5VUkxfU0NIRU1FX1JFR0VYKSE9bnVsbH12YXIgelQ9KGUsdCk9PntpZih0eXBlb2YgZmV0Y2g9PVwidW5kZWZpbmVkXCImJih0PT1udWxsfHx0LmZldGNoRnVuYz09bnVsbCkpcmV0dXJuIG51bGw7e2xldCBuPSEwO2lmKEFycmF5LmlzQXJyYXkoZSk/bj1lLmV2ZXJ5KGE9PlB4KGEpKTpuPVB4KGUpLG4pcmV0dXJuIFh3KGUsdCl9cmV0dXJuIG51bGx9O2dhLnJlZ2lzdGVyU2F2ZVJvdXRlcih6VCk7Z2EucmVnaXN0ZXJMb2FkUm91dGVyKHpUKTtmdW5jdGlvbiBYdyhlLHQpe3JldHVybiBuZXcgS3coZSx0KX1mdW5jdGlvbiB6QihlLHQpe3JldHVybiBYdyhlLHQpfXZhciBseD1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLm1vZGVsQXJ0aWZhY3RzPWV9bG9hZCgpe3JldHVybiB0aGlzLm1vZGVsQXJ0aWZhY3RzfX0sV1Q9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5zYXZlSGFuZGxlcj1lfXNhdmUoZSl7cmV0dXJuIHRoaXMuc2F2ZUhhbmRsZXIoZSl9fSxXQj1jbGFzc3tjb25zdHJ1Y3RvcihlKXtlLmxvYWQmJih0aGlzLmxvYWQ9KCk9PlByb21pc2UucmVzb2x2ZShlLmxvYWQoKSkpLGUuc2F2ZSYmKHRoaXMuc2F2ZT10PT5Qcm9taXNlLnJlc29sdmUoZS5zYXZlKHQpKSl9fTtmdW5jdGlvbiBCQihlLHQsbixhKXtsZXQgcj1hcmd1bWVudHM7cmV0dXJuIG5ldyBXQihCVCguLi5yKSl9ZnVuY3Rpb24gQlQoZSx0LG4sYSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg9PT0xP2UubW9kZWxUb3BvbG9neSE9bnVsbHx8ZS53ZWlnaHRTcGVjcyE9bnVsbD9uZXcgbHgoZSk6KGNvbnNvbGUud2FybihcIlBsZWFzZSBjYWxsIHRmLmlvLmZyb21NZW1vcnkoKSB3aXRoIG9ubHkgb25lIGFyZ3VtZW50LiBUaGUgYXJndW1lbnQgc2hvdWxkIGJlIG9mIHR5cGUgTW9kZWxBcnRpZmFjdHMuIFRoZSBtdWx0aS1hcmd1bWVudCBzaWduYXR1cmUgb2YgdGYuaW8uZnJvbU1lbW9yeSgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLlwiKSxuZXcgbHgoe21vZGVsVG9wb2xvZ3k6ZX0pKTooY29uc29sZS53YXJuKFwiUGxlYXNlIGNhbGwgdGYuaW8uZnJvbU1lbW9yeSgpIHdpdGggb25seSBvbmUgYXJndW1lbnQuIFRoZSBhcmd1bWVudCBzaG91bGQgYmUgb2YgdHlwZSBNb2RlbEFydGlmYWN0cy4gVGhlIG11bHRpLWFyZ3VtZW50IHNpZ25hdHVyZSBvZiB0Zi5pby5mcm9tTWVtb3J5KCkgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuXCIpLG5ldyBseCh7bW9kZWxUb3BvbG9neTplLHdlaWdodFNwZWNzOnQsd2VpZ2h0RGF0YTpuLHRyYWluaW5nQ29uZmlnOmF9KSl9ZnVuY3Rpb24gVkIoZSl7cmV0dXJuIG5ldyBXVChlKX1mdW5jdGlvbiBVQihlKXtyZXR1cm4gbmV3IFdUKGUpfXZhciBWVD17fTtfZShWVCx7Y29uZnVzaW9uTWF0cml4OigpPT5IQn0pO2Z1bmN0aW9uIEdCKGUsdCxuKXtsZXQgYT1FKGUsXCJsYWJlbHNcIixcImNvbmZ1c2lvbk1hdHJpeFwiKSxyPUUodCxcInByZWRpY3Rpb25zXCIsXCJjb25mdXNpb25NYXRyaXhcIik7QShuPT1udWxsfHxuPjAmJk51bWJlci5pc0ludGVnZXIobiksKCk9PmBJZiBwcm92aWRlZCwgbnVtQ2xhc3NlcyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGdvdCAke259YCksQShhLnJhbms9PT0xLCgpPT5gRXhwZWN0ZWQgdGhlIHJhbmsgb2YgbGFiZWxzIHRvIGJlIDEsIGJ1dCBnb3QgJHthLnJhbmt9YCksQShyLnJhbms9PT0xLCgpPT5gRXhwZWN0ZWQgdGhlIHJhbmsgb2YgcHJlZGljdGlvbnMgdG8gYmUgMSwgYnV0IGdvdCAke3IucmFua31gKSxBKGEuc2hhcGVbMF09PT1yLnNoYXBlWzBdLCgpPT5gTWlzbWF0Y2ggaW4gdGhlIG51bWJlciBvZiBleGFtcGxlczogJHthLnNoYXBlWzBdfSB2cy4gJHtyLnNoYXBlWzBdfS4gTGFiZWxzIGFuZCBwcmVkaWN0aW9ucyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuYCksQShuPjAmJk51bWJlci5pc0ludGVnZXIobiksKCk9PmBudW1DbGFzc2VzIGlzIHJlcXVpcmVkIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGdvdCAke259YCk7bGV0IHM9TGwocmUoYSxcImludDMyXCIpLG4pLGk9TGwocmUocixcImludDMyXCIpLG4pLG89RGUocyksbD0kZShvLGkpO3JldHVybiByZShsLFwiaW50MzJcIil9dmFyIEhCPUwoe2NvbmZ1c2lvbk1hdHJpeF86R0J9KSxxbz17fTtfZShxbyx7ZHJhdzooKT0+UUIsZnJvbVBpeGVsczooKT0+ZTQsZnJvbVBpeGVsc0FzeW5jOigpPT5ZQix0b1BpeGVsczooKT0+SkJ9KTt2YXIganMsc0k9ITE7ZnVuY3Rpb24gVVQoZSx0PTMpe2lmKHQ+NCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29uc3RydWN0IFRlbnNvciB3aXRoIG1vcmUgdGhhbiA0IGNoYW5uZWxzIGZyb20gcGl4ZWxzLlwiKTtpZihlPT1udWxsKXRocm93IG5ldyBFcnJvcihcInBpeGVscyBwYXNzZWQgdG8gdGYuYnJvd3Nlci5mcm9tUGl4ZWxzKCkgY2FuIG5vdCBiZSBudWxsXCIpO2xldCBuPSExLGE9ITEscj0hMSxzPSExLGk9ITEsbz0hMTtpZihlLmRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KW49ITA7ZWxzZSBpZih0eXBlb2YgSW1hZ2VEYXRhIT1cInVuZGVmaW5lZFwiJiZlIGluc3RhbmNlb2YgSW1hZ2VEYXRhKWE9ITA7ZWxzZSBpZih0eXBlb2YgSFRNTFZpZGVvRWxlbWVudCE9XCJ1bmRlZmluZWRcIiYmZSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpcj0hMDtlbHNlIGlmKHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50IT1cInVuZGVmaW5lZFwiJiZlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudClzPSEwO2Vsc2UgaWYoZS5nZXRDb250ZXh0IT1udWxsKWk9ITA7ZWxzZSBpZih0eXBlb2YgSW1hZ2VCaXRtYXAhPVwidW5kZWZpbmVkXCImJmUgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcClvPSEwO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBwaXhlbHMgcGFzc2VkIHRvIHRmLmJyb3dzZXIuZnJvbVBpeGVscygpIG11c3QgYmUgZWl0aGVyIGFuIEhUTUxWaWRlb0VsZW1lbnQsIEhUTUxJbWFnZUVsZW1lbnQsIEhUTUxDYW52YXNFbGVtZW50LCBJbWFnZURhdGEgaW4gYnJvd3Nlciwgb3IgT2Zmc2NyZWVuQ2FudmFzLCBJbWFnZURhdGEgaW4gd2Vid29ya2VyIG9yIHtkYXRhOiBVaW50MzJBcnJheSwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCBidXQgd2FzICR7ZS5jb25zdHJ1Y3Rvci5uYW1lfWApO2lmKGZjKEhoLFAuYmFja2VuZE5hbWUpIT1udWxsKXtsZXQgYz17cGl4ZWxzOmV9LGg9e251bUNoYW5uZWxzOnR9O3JldHVybiBQLnJ1bktlcm5lbChIaCxjLGgpfWxldFtsLHVdPXI/W2UudmlkZW9XaWR0aCxlLnZpZGVvSGVpZ2h0XTpbZS53aWR0aCxlLmhlaWdodF0scDtpZihpKXA9ZS5nZXRDb250ZXh0KFwiMmRcIikuZ2V0SW1hZ2VEYXRhKDAsMCxsLHUpLmRhdGE7ZWxzZSBpZihhfHxuKXA9ZS5kYXRhO2Vsc2UgaWYoc3x8cnx8byl7aWYoanM9PW51bGwpaWYodHlwZW9mIGRvY3VtZW50PT1cInVuZGVmaW5lZFwiKWlmKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMhPVwidW5kZWZpbmVkXCImJnR5cGVvZiBPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQhPVwidW5kZWZpbmVkXCIpanM9bmV3IE9mZnNjcmVlbkNhbnZhcygxLDEpLmdldENvbnRleHQoXCIyZFwiKTtlbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwYXJzZSBpbnB1dCBpbiBjdXJyZW50IGNvbnRleHQuIFJlYXNvbjogT2Zmc2NyZWVuQ2FudmFzIENvbnRleHQyRCByZW5kZXJpbmcgaXMgbm90IHN1cHBvcnRlZC5cIik7ZWxzZSBqcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiLHt3aWxsUmVhZEZyZXF1ZW50bHk6ITB9KTtqcy5jYW52YXMud2lkdGg9bCxqcy5jYW52YXMuaGVpZ2h0PXUsanMuZHJhd0ltYWdlKGUsMCwwLGwsdSkscD1qcy5nZXRJbWFnZURhdGEoMCwwLGwsdSkuZGF0YX1sZXQgZDtpZih0PT09NClkPW5ldyBJbnQzMkFycmF5KHApO2Vsc2V7bGV0IGM9bCp1O2Q9bmV3IEludDMyQXJyYXkoYyp0KTtmb3IobGV0IGg9MDtoPGM7aCsrKWZvcihsZXQgbT0wO208dDsrK20pZFtoKnQrbV09cFtoKjQrbV19cmV0dXJuIHhkKGQsW3UsbCx0XSxcImludDMyXCIpfWZ1bmN0aW9uIGpCKGUpe3JldHVybiBlIT1udWxsJiZlLmRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5fWZ1bmN0aW9uIHFCKCl7cmV0dXJuIHR5cGVvZiB3aW5kb3chPVwidW5kZWZpbmVkXCImJnR5cGVvZiBJbWFnZUJpdG1hcCE9XCJ1bmRlZmluZWRcIiYmd2luZG93Lmhhc093blByb3BlcnR5KFwiY3JlYXRlSW1hZ2VCaXRtYXBcIil9ZnVuY3Rpb24gS0IoZSl7cmV0dXJuIGUhPW51bGwmJmUud2lkdGghPT0wJiZlLmhlaWdodCE9PTB9ZnVuY3Rpb24gWEIoZSl7cmV0dXJuIHFCKCkmJiEoZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwKSYmS0IoZSkmJiFqQihlKX1hc3luYyBmdW5jdGlvbiBZQihlLHQ9Myl7bGV0IG49bnVsbDtpZihHKCkuZ2V0Qm9vbChcIldSQVBfVE9fSU1BR0VCSVRNQVBcIikmJlhCKGUpKXtsZXQgYTt0cnl7YT1hd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChlLHtwcmVtdWx0aXBseUFscGhhOlwibm9uZVwifSl9Y2F0Y2gocil7YT1udWxsfWEhPW51bGwmJmEud2lkdGg9PT1lLndpZHRoJiZhLmhlaWdodD09PWUuaGVpZ2h0P249YTpuPWV9ZWxzZSBuPWU7cmV0dXJuIFVUKG4sdCl9ZnVuY3Rpb24gR1QoZSl7aWYoZS5yYW5rIT09MiYmZS5yYW5rIT09Myl0aHJvdyBuZXcgRXJyb3IoYHRvUGl4ZWxzIG9ubHkgc3VwcG9ydHMgcmFuayAyIG9yIDMgdGVuc29ycywgZ290IHJhbmsgJHtlLnJhbmt9LmApO2xldCB0PWUucmFuaz09PTI/MTplLnNoYXBlWzJdO2lmKHQ+NHx8dD09PTIpdGhyb3cgbmV3IEVycm9yKGB0b1BpeGVscyBvbmx5IHN1cHBvcnRzIGRlcHRoIG9mIHNpemUgMSwgMyBvciA0IGJ1dCBnb3QgJHt0fWApO2lmKGUuZHR5cGUhPT1cImZsb2F0MzJcIiYmZS5kdHlwZSE9PVwiaW50MzJcIil0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGUgZm9yIHRvUGl4ZWxzOiAke2UuZHR5cGV9LiBQbGVhc2UgdXNlIGZsb2F0MzIgb3IgaW50MzIgdGVuc29ycy5gKX1mdW5jdGlvbiBaQihlKXtsZXQgdD0oZT09bnVsbD92b2lkIDA6ZS5hbHBoYSl8fDE7aWYodD4xfHx0PDApdGhyb3cgbmV3IEVycm9yKGBBbHBoYSB2YWx1ZSAke3R9IGlzIHN1cHBvZWQgdG8gYmUgaW4gcmFuZ2UgWzAgLSAxXS5gKX1hc3luYyBmdW5jdGlvbiBKQihlLHQpe2xldCBuPUUoZSxcImltZ1wiLFwidG9QaXhlbHNcIik7aWYoIShlIGluc3RhbmNlb2YgQ2UpKXtsZXQgdT1uO249cmUodSxcImludDMyXCIpLHUuZGlzcG9zZSgpfUdUKG4pO2xldFthLHJdPW4uc2hhcGUuc2xpY2UoMCwyKSxzPW4ucmFuaz09PTI/MTpuLnNoYXBlWzJdLGk9YXdhaXQgbi5kYXRhKCksbz1uLmR0eXBlPT09XCJmbG9hdDMyXCI/MjU1OjEsbD1uZXcgVWludDhDbGFtcGVkQXJyYXkociphKjQpO2ZvcihsZXQgdT0wO3U8YSpyOysrdSl7bGV0IHA9WzAsMCwwLDI1NV07Zm9yKGxldCBjPTA7YzxzO2MrKyl7bGV0IGg9aVt1KnMrY107aWYobi5kdHlwZT09PVwiZmxvYXQzMlwiKXtpZihoPDB8fGg+MSl0aHJvdyBuZXcgRXJyb3IoYFRlbnNvciB2YWx1ZXMgZm9yIGEgZmxvYXQzMiBUZW5zb3IgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWzAgLSAxXSBidXQgZW5jb3VudGVyZWQgJHtofS5gKX1lbHNlIGlmKG4uZHR5cGU9PT1cImludDMyXCImJihoPDB8fGg+MjU1KSl0aHJvdyBuZXcgRXJyb3IoYFRlbnNvciB2YWx1ZXMgZm9yIGEgaW50MzIgVGVuc29yIG11c3QgYmUgaW4gdGhlIHJhbmdlIFswIC0gMjU1XSBidXQgZW5jb3VudGVyZWQgJHtofS5gKTtzPT09MT8ocFswXT1oKm8scFsxXT1oKm8scFsyXT1oKm8pOnBbY109aCpvfWxldCBkPXUqNDtsW2QrMF09TWF0aC5yb3VuZChwWzBdKSxsW2QrMV09TWF0aC5yb3VuZChwWzFdKSxsW2QrMl09TWF0aC5yb3VuZChwWzJdKSxsW2QrM109TWF0aC5yb3VuZChwWzNdKX1pZih0IT1udWxsKXtzSXx8ZmMoTm0sUC5iYWNrZW5kTmFtZSkhPW51bGwmJihjb25zb2xlLndhcm4oXCJ0Zi5icm93c2VyLnRvUGl4ZWxzIGlzIG5vdCBlZmZpY2llbnQgdG8gZHJhdyB0ZW5zb3Igb24gY2FudmFzLiBQbGVhc2UgdHJ5IHRmLmJyb3dzZXIuZHJhdyBpbnN0ZWFkLlwiKSxzST0hMCksdC53aWR0aD1yLHQuaGVpZ2h0PWE7bGV0IHU9dC5nZXRDb250ZXh0KFwiMmRcIikscD1uZXcgSW1hZ2VEYXRhKGwscixhKTt1LnB1dEltYWdlRGF0YShwLDAsMCl9cmV0dXJuIG4hPT1lJiZuLmRpc3Bvc2UoKSxsfWZ1bmN0aW9uIFFCKGUsdCxuKXtsZXQgYT1FKGUsXCJpbWdcIixcImRyYXdcIik7aWYoIShlIGluc3RhbmNlb2YgQ2UpKXtsZXQgaT1hO2E9cmUoaSxcImludDMyXCIpLGkuZGlzcG9zZSgpfUdUKGEpLFpCKG49PW51bGw/dm9pZCAwOm4uaW1hZ2VPcHRpb25zKTtsZXQgcj17aW1hZ2U6YX0scz17Y2FudmFzOnQsb3B0aW9uczpufTtQLnJ1bktlcm5lbChObSxyLHMpfXZhciBlND1MKHtmcm9tUGl4ZWxzXzpVVH0pLFl3PXt9O19lKFl3LHtwcmVwYXJlQW5kVmFsaWRhdGU6KCk9PkhUfSk7ZnVuY3Rpb24gSFQoZSx0KXtsZXQgbj1lLnNoYXBlLmxlbmd0aCxhPXQuc2hhcGUubGVuZ3RoO2lmKG48MSl0aHJvdyBuZXcgRXJyb3IoYHRmLmdhdGhlck5EKCkgZXhwZWN0cyB0aGUgaW5wdXQgdG8gYmUgcmFuayAxIG9yIGhpZ2hlciwgYnV0IHRoZSByYW5rIHdhcyAke259LmApO2lmKGE8MSl0aHJvdyBuZXcgRXJyb3IoYHRmLmdhdGhlck5EKCkgZXhwZWN0cyB0aGUgaW5kaWNlcyB0byBiZSByYW5rIDEgb3IgaGlnaGVyLCBidXQgdGhlIHJhbmsgd2FzICR7YX0uYCk7aWYodC5kdHlwZSE9PVwiaW50MzJcIil0aHJvdyBuZXcgRXJyb3IoYHRmLmdhdGhlck5EKCkgZXhwZWN0cyB0aGUgaW5kaWNlcyB0byBiZSBpbnQzMiB0eXBlLCBidXQgdGhlIGR0eXBlIHdhcyAke3QuZHR5cGV9LmApO2lmKHQuc2hhcGVbYS0xXT5uKXRocm93IG5ldyBFcnJvcihgaW5kZXggaW5uZXJtb3N0IGRpbWVuc2lvbiBsZW5ndGggbXVzdCBiZSA8PSB0ZW5zb3IgcmFuazsgc2F3OiAke3Quc2hhcGVbYS0xXX0gdnMuICR7bn1gKTtpZihvdChlLnNoYXBlKT09PTApdGhyb3cgbmV3IEVycm9yKGBSZXF1ZXN0ZWQgbW9yZSB0aGFuIDAgZW50cmllcywgYnV0IGlucHV0IGlzIGVtcHR5LiBJbnB1dCBzaGFwZTogJHtlLnNoYXBlfS5gKTtsZXQgcj10LnNoYXBlLHM9cltyLmxlbmd0aC0xXSxpPTE7Zm9yKGxldCBkPTA7ZDxyLmxlbmd0aC0xOysrZClpKj1yW2RdO2xldCBvPWUuc2hhcGUsbD1yLnNsaWNlKCk7bC5wb3AoKTtsZXQgdT0xO2ZvcihsZXQgZD1zO2Q8bjsrK2QpdSo9b1tkXSxsLnB1c2gob1tkXSk7bGV0IHA9Wy4uLlhsKGUuc2hhcGUpLm1hcChkPT5kL3UpLDFdLnNsaWNlKDAscyk7cmV0dXJuW2wsaSx1LHBdfXZhciBLdD17fTtfZShLdCx7YXNzZXJ0UGFyYW1zVmFsaWQ6KCk9Pm40LGNvbXB1dGVGbGF0T2Zmc2V0OigpPT5vNCxjb21wdXRlT3V0U2hhcGU6KCk9PnI0LGdldE5vcm1hbGl6ZWRBeGVzOigpPT5zNCxpc1NsaWNlQ29udGlub3VzOigpPT5pNCxtYXNrVG9BeGVzOigpPT5hNCxwYXJzZVNsaWNlUGFyYW1zOigpPT5lMixzbGljZUluZm86KCk9Pmw0LHN0YXJ0Rm9yQXhpczooKT0+SlQsc3RhcnRJbmRpY2VzV2l0aEVsaWRlZERpbXM6KCk9PlhULHN0b3BGb3JBeGlzOigpPT5RVCxzdG9wSW5kaWNlc1dpdGhFbGlkZWREaW1zOigpPT5ZVCxzdHJpZGVzRm9yQXhpczooKT0+WlQsc3RyaWRlc1dpdGhFbGlkZWREaW1zOigpPT5qVH0pO3ZhciBMeD0tMix0ND0tMTtmdW5jdGlvbiBuNChlLHQsbil7bGV0IGE9ZS5zaGFwZS5sZW5ndGg7QShhPT09dC5sZW5ndGgsKCk9PmBFcnJvciBpbiBzbGljZSR7YX1EOiBMZW5ndGggb2YgYmVnaW4gJHt0fSBtdXN0IG1hdGNoIHRoZSByYW5rIG9mIHRoZSBhcnJheSAoJHthfSkuYCksQShhPT09bi5sZW5ndGgsKCk9PmBFcnJvciBpbiBzbGljZSR7YX1EOiBMZW5ndGggb2Ygc2l6ZSAke259IG11c3QgbWF0Y2ggdGhlIHJhbmsgb2YgdGhlIGFycmF5ICgke2F9KS5gKTtmb3IobGV0IHI9MDtyPGE7KytyKUEodFtyXStuW3JdPD1lLnNoYXBlW3JdLCgpPT5gRXJyb3IgaW4gc2xpY2Uke2F9RDogYmVnaW5bJHtyfV0gKyBzaXplWyR7cn1dICgke3Rbcl0rbltyXX0pIHdvdWxkIG92ZXJmbG93IGlucHV0LnNoYXBlWyR7cn1dICgke2Uuc2hhcGVbcl19KWApfWZ1bmN0aW9uIGE0KGUpe2xldCB0PVtdLG49MDtmb3IoO2U+MDspZSYxJiZ0LnB1c2gobiksZS89MixuKys7cmV0dXJuIHR9ZnVuY3Rpb24gcjQoZSx0LG4pe2xldCBhPVtdO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKWFbcl09TWF0aC5jZWlsKCh0W3JdLWVbcl0pL25bcl0pO3JldHVybiBhfWZ1bmN0aW9uIGpUKGUsdCxuLGEpe2xldCByPVsuLi5lXTtmb3IobGV0IHM9ci5sZW5ndGg7czxhLmxlbmd0aDtzKyspci5wdXNoKDEpO2ZvcihsZXQgcz0wO3M8bjtzKyspcz09PTA/clt0XT0xOihyLnNwbGljZSh0LDAsMSksci5wb3AoKSk7cmV0dXJuIHJ9ZnVuY3Rpb24gcVQoZSx0LG4pe3JldHVybiBuPD1lP246bi0odC0xKX1mdW5jdGlvbiBLVChlLHQpe2xldCBuPVtdO2ZvcihsZXQgYT0wO2E8ZTthKyspbi5wdXNoKHQrYSk7cmV0dXJuIG59ZnVuY3Rpb24gczQoZSx0LG4sYSxyLHMsaSxvLGwpe2xldCB1PWUubGVuZ3RoLHA9bmV3IEFycmF5KHUpLGQ9bmV3IEFycmF5KHUpLGM9bmV3IEFycmF5KHUpO2lmKHQubGVuZ3RoJiZuPjApe2xldCBoPXRbMF0sbT1uKzE7cD1YVChpLGgsbSxhLGUpLGQ9WVQobyxoLG0scixlKSxjPWpUKHMsaCxtLGUpfWVsc2UgZm9yKGxldCBoPTA7aDx1O2grKylwW2hdPUpUKGksYSxzLGUsaCxsKSxkW2hdPVFUKG8scixzLGUsaCxsKSxjW2hdPVpUKHMsaCxsKTtyZXR1cm57YmVnaW46cCxlbmQ6ZCxzdHJpZGVzOmN9fWZ1bmN0aW9uIFhUKGUsdCxuLGEscil7bGV0IHM9Wy4uLnJdLGk9S1Qobix0KTtmb3IobGV0IG89MDtvPHMubGVuZ3RoO28rKylpZihpLmluZGV4T2Yobyk+LTEpc1tvXT0wO2Vsc2V7bGV0IGw9cVQodCxuLG8pLHU9YVtsXTtlJjE8PGwmJih1PTApLHNbb109dX1yZXR1cm4gc31mdW5jdGlvbiBZVChlLHQsbixhLHIpe2xldCBzPVsuLi5yXSxpPUtUKG4sdCk7Zm9yKGxldCBvPTA7bzxzLmxlbmd0aDtvKyspaWYoaS5pbmRleE9mKG8pPi0xKXNbb109TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7ZWxzZXtsZXQgbD1xVCh0LG4sbyksdT1hW2xdO2UmMTw8bCYmKHU9TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpLHNbb109dX1mb3IobGV0IG89MDtvPHMubGVuZ3RoO28rKyl7bGV0IGw9cltvXTtzW29dPDAmJihzW29dKz1sKSxzW29dPWhjKDAsc1tvXSxyW29dKX1yZXR1cm4gc31mdW5jdGlvbiBaVChlLHQsbil7bGV0IGE9ZVt0XTtyZXR1cm4obiYxPDx0fHxhPT1udWxsKSYmKGE9MSksYX1mdW5jdGlvbiBKVChlLHQsbixhLHIscyl7bGV0IGk9dFtyXSxvPW5bcl18fDE7KGUmMTw8cnx8cyYxPDxyfHxpPT1udWxsKSYmKG8+MD9pPU51bWJlci5NSU5fU0FGRV9JTlRFR0VSOmk9TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO2xldCBsPWFbcl07cmV0dXJuIGk8MCYmKGkrPWwpLGk9aGMoMCxpLGwtMSksaX1mdW5jdGlvbiBRVChlLHQsbixhLHIscyl7bGV0IGk9dFtyXSxvPW5bcl18fDE7KGUmMTw8cnx8cyYxPDxyfHxpPT1udWxsKSYmKG8+MD9pPU51bWJlci5NQVhfU0FGRV9JTlRFR0VSOmk9TnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpO2xldCBsPWFbcl07cmV0dXJuIGk8MCYmKGkrPWwpLG8+MD9pPWhjKDAsaSxsKTppPWhjKC0xLGksbC0xKSxpfWZ1bmN0aW9uIGk0KGUsdCxuKXtsZXQgYT1uLmxlbmd0aDtmb3IobGV0IHI9MDtyPG4ubGVuZ3RoO3IrKylpZihuW3JdPjEpe2E9cjticmVha31mb3IobGV0IHI9YSsxO3I8bi5sZW5ndGg7cisrKWlmKHRbcl0+MHx8bltyXSE9PWVbcl0pcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gbzQoZSx0KXtsZXQgbj1lLmxlbmd0aD4wP2VbZS5sZW5ndGgtMV06MTtmb3IobGV0IGE9MDthPGUubGVuZ3RoLTE7YSsrKW4rPWVbYV0qdFthXTtyZXR1cm4gbn1mdW5jdGlvbiBlMihlLHQsbil7bGV0IGEscj1lLnNoYXBlLmxlbmd0aDt0eXBlb2YgdD09XCJudW1iZXJcIj9hPVt0LC4uLm5ldyBBcnJheShyLTEpLmZpbGwoMCldOnQubGVuZ3RoPHI/YT10LmNvbmNhdChuZXcgQXJyYXkoci10Lmxlbmd0aCkuZmlsbCgwKSk6YT10LnNsaWNlKCksYS5mb3JFYWNoKGk9PntBKGkhPT0tMSwoKT0+XCJzbGljZSgpIGRvZXMgbm90IHN1cHBvcnQgbmVnYXRpdmUgYmVnaW4gaW5kZXhpbmcuXCIpfSk7bGV0IHM7cmV0dXJuIG49PW51bGw/cz1uZXcgQXJyYXkocikuZmlsbCgtMSk6dHlwZW9mIG49PVwibnVtYmVyXCI/cz1bbiwuLi5uZXcgQXJyYXkoci0xKS5maWxsKC0xKV06bi5sZW5ndGg8cj9zPW4uY29uY2F0KG5ldyBBcnJheShyLW4ubGVuZ3RoKS5maWxsKC0xKSk6cz1uLHM9cy5tYXAoKGksbyk9Pmk+PTA/aTooQShpPT09LTEsKCk9PmBOZWdhdGl2ZSBzaXplIHZhbHVlcyBzaG91bGQgYmUgZXhhY3RseSAtMSBidXQgZ290ICR7aX0gZm9yIHRoZSBzbGljZSgpIHNpemUgYXQgaW5kZXggJHtvfS5gKSxlLnNoYXBlW29dLWFbb10pKSxbYSxzXX1mdW5jdGlvbiBsNChlLHQsbixhLHIscyxpLG8sbCl7bGV0IHU7aWYoYT09bnVsbD8odT1uZXcgQXJyYXkodC5sZW5ndGgpLHUuZmlsbCgxKSk6dT1hLGkhPW51bGwmJmkmaS0xKXRocm93IG5ldyBFcnJvcihcIk11bHRpcGxlIGVsbGlwc2VzIGluIHNsaWNlIGlzIG5vdCBhbGxvd2VkLlwiKTtsZXQgcD0hMSxkPXtkaW1zOnUubGVuZ3RoLG51bUFkZEF4aXNBZnRlckVsbGlwc2lzOjAsYmVnaW46dC5zbGljZSgpLGVuZDpuLnNsaWNlKCksc3RyaWRlczp1LnNsaWNlKCksYmVnaW5NYXNrOnIsZW5kTWFzazpzLGVsbGlwc2lzTWFzazppLG5ld0F4aXNNYXNrOm8sc2hyaW5rQXhpc01hc2s6bH07Zm9yKGxldCB5PTA7eTxkLmRpbXM7eSsrKXAmJjE8PHkmbyYmZC5udW1BZGRBeGlzQWZ0ZXJFbGxpcHNpcysrLDE8PHkmaSYmKHA9ITApO3B8fChkLmVsbGlwc2lzTWFza3w9MTw8ZC5kaW1zLGQuZGltcysrKTtsZXQgYz17ZGltczplLmxlbmd0aCxiZWdpbk1hc2s6MCxlbmRNYXNrOjAsYmVnaW5WYWxpZDohMSxlbmRWYWxpZDohMX07dTQoZCxjKTtsZXQgaD0hMCxtPSEwLGY9ITAsZz1bXSxiPVtdO2ZvcihsZXQgeT0wO3k8ZS5sZW5ndGg7Kyt5KXtpZihjLnN0cmlkZXNbeV09PT0wKXRocm93IEVycm9yKGBzdHJpZGVzWyR7eX1dIG11c3QgYmUgbm9uLXplcm9gKTtsZXQgeD0hIShjLnNocmlua0F4aXNNYXNrJjE8PHkpLHY9ZVt5XTtpZih2PT09LTEpe2cucHVzaCh4PzE6LTEpO2NvbnRpbnVlfWxldCBJPVtjLmJlZ2luTWFzayYxPDx5LGMuZW5kTWFzayYxPDx5XSxOPVtjLnN0cmlkZXNbeV0+MD8wOi0xLGMuc3RyaWRlc1t5XT4wP3Y6di0xXTtpZih4JiZjLnN0cmlkZXNbeV08PTApdGhyb3cgRXJyb3IoXCJvbmx5IHN0cmlkZSAxIGFsbG93ZWQgb24gbm9uLXJhbmdlIGluZGV4aW5nLlwiKTtmPWYmJmMuc3RyaWRlc1t5XT09PTE7bGV0IEM9ISEoYy5iZWdpbk1hc2smMTw8eSYmYy5lbmRNYXNrJjE8PHkpO2lmKGMuYmVnaW5WYWxpZCYmYy5lbmRWYWxpZCl7aWYoeCl7bGV0ICQ9Yy5iZWdpblt5XTwwP3YrYy5iZWdpblt5XTpjLmJlZ2luW3ldO2lmKGMuYmVnaW5beV09JCxjLmVuZFt5XT1jLmJlZ2luW3ldKzEsJDwwfHwkPj12KXRocm93IEVycm9yKGBzbGljZSBpbmRleCAke2MuYmVnaW5beV19IG9mIGRpbWVuc2lvbiAke3l9IG91dCBvZiBib3VuZHMuYCl9ZWxzZSBjLmJlZ2luW3ldPWlJKGMuYmVnaW5beV0sMCxjLnN0cmlkZXNbeV0sdixJLE4pLGMuZW5kW3ldPWlJKGMuZW5kW3ldLDEsYy5zdHJpZGVzW3ldLHYsSSxOKTtsZXQgRD1jLnN0cmlkZXNbeV09PT0xJiZjLmJlZ2luW3ldPT09MCYmYy5lbmRbeV09PT12O2g9aCYmRCxtPW0mJih5PT09MCYmYy5zdHJpZGVzW3ldPT09MXx8RCl9ZWxzZSBoPWgmJmMuc3RyaWRlc1t5XT09PTEmJkMsbT1tJiYoeT09PTAmJmMuc3RyaWRlc1t5XT09PTF8fEMpO2xldCBfLEY9ITE7aWYoYy5iZWdpblZhbGlkJiZjLmVuZFZhbGlkPyhfPWMuZW5kW3ldLWMuYmVnaW5beV0sRj0hMCk6eD8oXz0xLEY9ITApOkMmJnY+PTAmJihjLnN0cmlkZXNbeV08MD9fPS12Ol89dixGPSEwKSxGKXtsZXQgRDtfPT09MHx8XzwwIT1jLnN0cmlkZXNbeV08MD9EPTA6RD1NYXRoLnRydW5jKF8vYy5zdHJpZGVzW3ldKSsoXyVjLnN0cmlkZXNbeV0hPT0wPzE6MCksZy5wdXNoKEQpfWVsc2UgZy5wdXNoKC0xKX1mb3IobGV0IHk9MDt5PGMuZmluYWxTaGFwZUdhdGhlckluZGljZXMubGVuZ3RoOysreSl7bGV0IHg9Yy5maW5hbFNoYXBlR2F0aGVySW5kaWNlc1t5XTt4Pj0wP2IucHVzaChnW3hdKTp4PT09THgmJmIucHVzaCgxKX1yZXR1cm57ZmluYWxTaGFwZVNwYXJzZTpiLmZpbHRlcigoeSx4KT0+Yy5maW5hbFNoYXBlR2F0aGVySW5kaWNlc1t4XSE9PUx4KSxmaW5hbFNoYXBlOmIsaXNJZGVudGl0eTpoLHNsaWNlRGltMDptLGlzU2ltcGxlU2xpY2U6ZixiZWdpbjpjLmJlZ2luLGVuZDpjLmVuZCxzdHJpZGVzOmMuc3RyaWRlc319ZnVuY3Rpb24gdTQoZSx0KXt0LmJlZ2luTWFzaz0wLHQuZW5kTWFzaz0wLHQuc2hyaW5rQXhpc01hc2s9MDtsZXQgbj0wO3QuYmVnaW5WYWxpZD1lLmJlZ2luIT1udWxsLHQuZW5kVmFsaWQ9ZS5lbmQhPW51bGwsdC5iZWdpbj1uZXcgQXJyYXkodC5kaW1zKSx0LmVuZD1uZXcgQXJyYXkodC5kaW1zKSx0LnN0cmlkZXM9bmV3IEFycmF5KHQuZGltcyksdC5maW5hbFNoYXBlR2F0aGVySW5kaWNlcz1bXSx0LmZpbmFsU2hhcGVHYXRoZXJJbmRpY2VzU3BhcnNlPVtdLHQuaW5wdXRTaGFwZUdhdGhlckluZGljZXNTcGFyc2U9bmV3IEFycmF5KHQuZGltcyk7Zm9yKGxldCBhPTA7YTxlLmRpbXM7YSsrKWlmKDE8PGEmZS5lbGxpcHNpc01hc2spe2xldCByPU1hdGgubWluKHQuZGltcy0oZS5kaW1zLWEpKzErZS5udW1BZGRBeGlzQWZ0ZXJFbGxpcHNpcyx0LmRpbXMpO2Zvcig7bjxyO24rKyl0LmJlZ2luW25dPTAsdC5lbmRbbl09MCx0LnN0cmlkZXNbbl09MSx0LmJlZ2luTWFza3w9MTw8bix0LmVuZE1hc2t8PTE8PG4sdC5maW5hbFNoYXBlR2F0aGVySW5kaWNlcy5wdXNoKG4pLHQuZmluYWxTaGFwZUdhdGhlckluZGljZXNTcGFyc2UucHVzaCgtMSksdC5pbnB1dFNoYXBlR2F0aGVySW5kaWNlc1NwYXJzZVtuXT1hfWVsc2UgaWYoMTw8YSZlLm5ld0F4aXNNYXNrKXQuZmluYWxTaGFwZUdhdGhlckluZGljZXMucHVzaChMeCksdC5maW5hbFNoYXBlR2F0aGVySW5kaWNlc1NwYXJzZS5wdXNoKC0xKTtlbHNle2lmKG49PT10LmJlZ2luLmxlbmd0aCl0aHJvdyBFcnJvcihgSW5kZXggb3V0IG9mIHJhbmdlIHVzaW5nIGlucHV0IGRpbSAke259OyBpbnB1dCBoYXMgb25seSAke3QuZGltc30gZGltcywgJHt0LmJlZ2luLmxlbmd0aH0uYCk7ZS5iZWdpbiE9bnVsbCYmKHQuYmVnaW5bbl09ZS5iZWdpblthXSksZS5lbmQhPW51bGwmJih0LmVuZFtuXT1lLmVuZFthXSksdC5zdHJpZGVzW25dPWUuc3RyaWRlc1thXSxlLmJlZ2luTWFzayYxPDxhJiYodC5iZWdpbk1hc2t8PTE8PG4pLGUuZW5kTWFzayYxPDxhJiYodC5lbmRNYXNrfD0xPDxuKSxlLnNocmlua0F4aXNNYXNrJjE8PGE/KHQuZmluYWxTaGFwZUdhdGhlckluZGljZXMucHVzaCh0NCksdC5maW5hbFNoYXBlR2F0aGVySW5kaWNlc1NwYXJzZS5wdXNoKC0xKSx0LnNocmlua0F4aXNNYXNrfD0xPDxuKToodC5maW5hbFNoYXBlR2F0aGVySW5kaWNlcy5wdXNoKG4pLHQuZmluYWxTaGFwZUdhdGhlckluZGljZXNTcGFyc2UucHVzaChhKSksdC5pbnB1dFNoYXBlR2F0aGVySW5kaWNlc1NwYXJzZVtuXT1hLG4rK319ZnVuY3Rpb24gaUkoZSx0LG4sYSxyLHMpe2lmKHJbdF0pcmV0dXJuIG4+MD9zW3RdOnNbdCsxJjFdO3tsZXQgaT1lPDA/YStlOmU7cmV0dXJuIGk8c1swXT9zWzBdOmk+c1sxXT9zWzFdOml9fXZhciBwND1cIjQuMjIuMFwiLHQyPWNsYXNze3N0YXRpYyBzZ2QoZSl7cmV0dXJuIG5ldyBmZihlKX1zdGF0aWMgbW9tZW50dW0oZSx0LG49ITEpe3JldHVybiBuZXcgancoZSx0LG4pfXN0YXRpYyBybXNwcm9wKGUsdD0uOSxuPTAsYT1udWxsLHI9ITEpe3JldHVybiBuZXcgcXcoZSx0LG4sYSxyKX1zdGF0aWMgYWRhbShlPS4wMDEsdD0uOSxuPS45OTksYT1udWxsKXtyZXR1cm4gbmV3IEd3KGUsdCxuLGEpfXN0YXRpYyBhZGFkZWx0YShlPS4wMDEsdD0uOTUsbj1udWxsKXtyZXR1cm4gbmV3IFZ3KGUsdCxuKX1zdGF0aWMgYWRhbWF4KGU9LjAwMix0PS45LG49Ljk5OSxhPW51bGwscj0wKXtyZXR1cm4gbmV3IEh3KGUsdCxuLGEscil9c3RhdGljIGFkYWdyYWQoZSx0PS4xKXtyZXR1cm4gbmV3IFV3KGUsdCl9fSxYcz10MixjND10eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIT1cInVuZGVmaW5lZFwiP3JlcXVlc3RBbmltYXRpb25GcmFtZTp0eXBlb2Ygc2V0SW1tZWRpYXRlIT1cInVuZGVmaW5lZFwiP3NldEltbWVkaWF0ZTplPT5lKCk7ZnVuY3Rpb24gWncoKXtyZXR1cm4gbmV3IFByb21pc2UoZT0+YzQoKCk9PmUoKSkpfXZhciBUPXt9O19lKFQse0VSRl9BMTooKT0+VDQsRVJGX0EyOigpPT5DNCxFUkZfQTM6KCk9PkU0LEVSRl9BNDooKT0+XzQsRVJGX0E1OigpPT5BNCxFUkZfUDooKT0+TjQsUEFSQUxMRUxJWkVfVEhSRVNIT0xEOigpPT5KdyxSb3dQYXJ0aXRpb25UeXBlOigpPT5lcixTRUxVX1NDQUxFOigpPT5hMixTRUxVX1NDQUxFQUxQSEE6KCk9Pm4yLGFwcGx5QWN0aXZhdGlvbjooKT0+aGYsYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGU6KCk9PmN0LGFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zOigpPT5sMyxhc3NlcnRQYXJhbXNDb25zaXN0ZW50OigpPT5kNCxhc3NpZ25Ub1R5cGVkQXJyYXk6KCk9Pk80LGF4ZXNBcmVJbm5lck1vc3REaW1zOigpPT51dyxjYWxjdWxhdGVTaGFwZXM6KCk9PnBULGNoZWNrRWluc3VtRGltU2l6ZXM6KCk9PlY0LGNoZWNrUGFkT25EaW1Sb3VuZGluZ01vZGU6KCk9PlRuLGNvbWJpbmVMb2NhdGlvbnM6KCk9PkZOLGNvbWJpbmVSYWdnZWRUZW5zb3JUb1RlbnNvclNoYXBlczooKT0+bTQsY29tcGxleFdpdGhFdmVuSW5kZXg6KCk9PkQ0LGNvbXBsZXhXaXRoT2RkSW5kZXg6KCk9PlI0LGNvbXB1dGVDb252MkRJbmZvOigpPT5zZCxjb21wdXRlQ29udjNESW5mbzooKT0+a04sY29tcHV0ZURlZmF1bHRQYWQ6KCk9Pkh2LGNvbXB1dGVEaWxhdGlvbjJESW5mbzooKT0+aVAsY29tcHV0ZU9wdGltYWxXaW5kb3dTaXplOigpPT55NCxjb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzOigpPT4kTixjb21wdXRlT3V0U2hhcGU6KCk9Pmg0LGNvbXB1dGVQb29sMkRJbmZvOigpPT53Tixjb21wdXRlUG9vbDNESW5mbzooKT0+b1AsY29udmVydENvbnYyRERhdGFGb3JtYXQ6KCk9PklOLGRlY29kZUVpbnN1bUVxdWF0aW9uOigpPT5XNCxlaXRoZXJTdHJpZGVzT3JEaWxhdGlvbnNBcmVPbmU6KCk9PmRyLGV4cGFuZFNoYXBlVG9LZWVwRGltOigpPT5taSxleHBvbmVudDooKT0+TDQsZXhwb25lbnRzOigpPT5QNCxmcm9tU3RyaW5nQXJyYXlUb1VpbnQ4OigpPT51Vixmcm9tVWludDhUb1N0cmluZ0FycmF5OigpPT5sVixnZXRBeGVzUGVybXV0YXRpb246KCk9PkROLGdldEJyb2FkY2FzdERpbXM6KCk9Pl9OLGdldENvbXBsZXhXaXRoSW5kZXg6KCk9Pk00LGdldEVpbnN1bUNvbXB1dGVQYXRoOigpPT5VNCxnZXRFaW5zdW1QZXJtdXRhdGlvbjooKT0+QjQsZ2V0RnVzZWRCaWFzR3JhZGllbnQ6KCk9PmRmLGdldEZ1c2VkRHlBY3RpdmF0aW9uOigpPT5jZixnZXRJbWFnZUNlbnRlcjooKT0+eDQsZ2V0SW5uZXJNb3N0QXhlczooKT0+dTMsZ2V0UGVybXV0ZWQ6KCk9Pnc0LGdldFJhZ2dlZFJhbms6KCk9Pmc0LGdldFJlZHVjdGlvbkF4ZXM6KCk9PkJ0LGdldFJlc2hhcGVkOigpPT52NCxnZXRSZXNoYXBlZFBlcm11dGVkOigpPT5rNCxnZXRSb3dQYXJ0aXRpb25UeXBlc0hlbHBlcjooKT0+ZjQsZ2V0U2xpY2VCZWdpbkNvb3JkczooKT0+STQsZ2V0U2xpY2VTaXplOigpPT5TNCxnZXRTcGFyc2VGaWxsRW1wdHlSb3dzSW5kaWNlc0RlbnNlU2hhcGVNaXNtYXRjaDooKT0+cTQsZ2V0U3BhcnNlRmlsbEVtcHR5Um93c05lZ2F0aXZlSW5kZXhFcnJvck1lc3NhZ2U6KCk9Pks0LGdldFNwYXJzZUZpbGxFbXB0eVJvd3NPdXRPZlJhbmdlSW5kZXhFcnJvck1lc3NhZ2U6KCk9Plg0LGdldFNwYXJzZVJlc2hhcGVFbXB0eVRlbnNvclplcm9PdXRwdXREaW1FcnJvck1lc3NhZ2U6KCk9Pko0LGdldFNwYXJzZVJlc2hhcGVJbnB1dE91dHB1dE1pc21hdGNoRXJyb3JNZXNzYWdlOigpPT5lVixnZXRTcGFyc2VSZXNoYXBlSW5wdXRPdXRwdXRNdWx0aXBsZUVycm9yTWVzc2FnZTooKT0+UTQsZ2V0U3BhcnNlUmVzaGFwZU11bHRpcGxlTmVnYXRpdmVPbmVPdXRwdXREaW1FcnJvck1lc3NhZ2U6KCk9Plk0LGdldFNwYXJzZVJlc2hhcGVOZWdhdGl2ZU91dHB1dERpbUVycm9yTWVzc2FnZTooKT0+WjQsZ2V0U3BhcnNlU2VnbWVudFJlZHVjdGlvbkluZGljZXNPdXRPZlJhbmdlRXJyb3JNZXNzYWdlOigpPT5yVixnZXRTcGFyc2VTZWdtZW50UmVkdWN0aW9uTmVnYXRpdmVTZWdtZW50SWRzRXJyb3JNZXNzYWdlOigpPT50VixnZXRTcGFyc2VTZWdtZW50UmVkdWN0aW9uTm9uSW5jcmVhc2luZ1NlZ21lbnRJZHNFcnJvck1lc3NhZ2U6KCk9Pm5WLGdldFNwYXJzZVNlZ21lbnRSZWR1Y3Rpb25TZWdtZW50SWRPdXRPZlJhbmdlRXJyb3JNZXNzYWdlOigpPT5hVixnZXRVbmRvQXhlc1Blcm11dGF0aW9uOigpPT5wdyxpc0lkZW50aXR5UGVybXV0YXRpb246KCk9Pkc0LGxvZzooKT0+Z00sbWVyZ2VSZWFsQW5kSW1hZ0FycmF5czooKT0+RjQscHJlcGFyZUFuZFZhbGlkYXRlOigpPT5IVCxwcmVwYXJlU3BsaXRTaXplOigpPT5qNCxzZWdtZW50X3V0aWw6KCk9PnIyLHNob3VsZEZ1c2U6KCk9Pm1mLHNsaWNlX3V0aWw6KCk9Pkt0LHNwbGl0UmVhbEFuZEltYWdBcnJheXM6KCk9PiQ0LHN0cmlkZXNPckRpbGF0aW9uc0FyZVBvc2l0aXZlOigpPT5oaSx0dXBsZVZhbHVlc0FyZU9uZTooKT0+cHMsdXBjYXN0VHlwZTooKT0+ZmEsdmFsaWRhdGVEZWZhdWx0VmFsdWVTaGFwZTooKT0+YjQsdmFsaWRhdGVJbnB1dDooKT0+b2YsdmFsaWRhdGVVcGRhdGVTaGFwZTooKT0+JHcsd2FybjooKT0+WnJ9KTtmdW5jdGlvbiBkNChlLHQpe2xldCBuPWVbMF0ubGVuZ3RoO2UuZm9yRWFjaCgocixzKT0+e0Eoci5sZW5ndGg9PT1uLCgpPT5gRXJyb3IgaW4gY29uY2F0JHtufUQ6IHJhbmsgb2YgdGVuc29yc1ske3N9XSBtdXN0IGJlIHRoZSBzYW1lIGFzIHRoZSByYW5rIG9mIHRoZSByZXN0ICgke259KWApfSksQSh0Pj0wJiZ0PG4sKCk9PmBFcnJvciBpbiBjb25jYXQke259RDogYXhpcyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgJHtuLTF9LmApO2xldCBhPWVbMF07ZS5mb3JFYWNoKChyLHMpPT57Zm9yKGxldCBpPTA7aTxuO2krKylBKGk9PT10fHxyW2ldPT09YVtpXSwoKT0+YEVycm9yIGluIGNvbmNhdCR7bn1EOiBTaGFwZSBvZiB0ZW5zb3JzWyR7c31dICgke3J9KSBkb2VzIG5vdCBtYXRjaCB0aGUgc2hhcGUgb2YgdGhlIHJlc3QgKCR7YX0pIGFsb25nIHRoZSBub24tY29uY2F0ZW5hdGVkIGF4aXMgJHtzfS5gKX0pfWZ1bmN0aW9uIGg0KGUsdCl7bGV0IG49ZVswXS5zbGljZSgpO2ZvcihsZXQgYT0xO2E8ZS5sZW5ndGg7YSsrKW5bdF0rPWVbYV1bdF07cmV0dXJuIG59dmFyIGVyOyhmdW5jdGlvbihlKXtlW2UuRklSU1RfRElNX1NJWkU9MF09XCJGSVJTVF9ESU1fU0laRVwiLGVbZS5WQUxVRV9ST1dJRFM9MV09XCJWQUxVRV9ST1dJRFNcIixlW2UuUk9XX0xFTkdUSFM9Ml09XCJST1dfTEVOR1RIU1wiLGVbZS5ST1dfU1BMSVRTPTNdPVwiUk9XX1NQTElUU1wiLGVbZS5ST1dfTElNSVRTPTRdPVwiUk9XX0xJTUlUU1wiLGVbZS5ST1dfU1RBUlRTPTVdPVwiUk9XX1NUQVJUU1wifSkoZXJ8fChlcj17fSkpO2Z1bmN0aW9uIG00KGUsdCxuKXtsZXQgYT1uZXcgQXJyYXk7aWYobj09bnVsbCYmdD09bnVsbClyZXR1cm4gYTtpZih0PT1udWxsKWZvcig7YS5sZW5ndGg8ZStuLmxlbmd0aDspYS5wdXNoKC0xKTtlbHNlIGE9dC5zbGljZSgpO2lmKG49PW51bGwpcmV0dXJuIGE7aWYoZStuLmxlbmd0aCE9PWEubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgcnQgaW5wdXQuc2hhcGUgYW5kIHNoYXBlPSR7dH0gYXJlIGluY29tcGF0aWJsZTogcnQgaW5wdXQucmFuayA9ICR7ZStuLmxlbmd0aH0sIGJ1dCBzaGFwZS5yYW5rID0gJHthLmxlbmd0aH1gKTtmb3IobGV0IHI9MTtyPG4ubGVuZ3RoOysrcil7bGV0IHM9bltyXSxpPWFbYS5sZW5ndGgtbi5sZW5ndGgrcl0sbz1hW2ldO2lmKHM+PTApaWYobz49MCl7aWYobyE9PXMpdGhyb3cgbmV3IEVycm9yKGBydCBpbnB1dC5zaGFwZSBhbmQgc2hhcGU9JHt0fSBhcmUgaW5jb21wYXRpYmxlOiBydCBpbnB1dC5zaGFwZVske3IrZX1dID0gJHtzfSBidXQgc2hhcGVbJHtyK2V9XSA9ICR7b31gKX1lbHNlIGFbaV09c31yZXR1cm4gYX1mdW5jdGlvbiBmNChlKXtsZXQgdD17RklSU1RfRElNX1NJWkU6ZXIuRklSU1RfRElNX1NJWkUsVkFMVUVfUk9XSURTOmVyLlZBTFVFX1JPV0lEUyxST1dfTEVOR1RIUzplci5ST1dfTEVOR1RIUyxST1dfU1BMSVRTOmVyLlJPV19TUExJVFMsUk9XX0xJTUlUUzplci5ST1dfTElNSVRTLFJPV19TVEFSVFM6ZXIuUk9XX1NUQVJUU30sbj1bXTtmb3IobGV0IGEgb2YgZSlpZihhIGluIHQpbi5wdXNoKHRbYV0pO2Vsc2UgYnJlYWs7cmV0dXJuIG59ZnVuY3Rpb24gZzQoZSl7cmV0dXJuIGUubGVuZ3RoPT09MD8wOmVbMF09PT1lci5GSVJTVF9ESU1fU0laRT9lLmxlbmd0aC0xOmUubGVuZ3RofWZ1bmN0aW9uIGI0KGUsdCl7aWYoZT09bnVsbHx8dD09bnVsbClyZXR1cm47bGV0IG49ZS5sZW5ndGgsYT10Lmxlbmd0aDtpZihuPj1hKXRocm93IG5ldyBFcnJvcihgZGVmYXVsdFZhbHVlLnNoYXBlPSR7ZX0gYW5kIHJhZ2dlZCB0ZW5zb3IgZmxhdFZhbHVlcy5zaGFwZT0ke3R9LCBhcmUgaW5jb21wYXRpYmxlOiBkZWZhdWx0VmFsdWUucmFuayA9ICR7bn0gbXVzdCBiZSBsZXNzIHRoYW4gcmFnZ2VkIHRlbnNvciBpbnB1dCBmbGF0VmFsdWVzLnJhbmsgPSAke2F9KWApO2ZvcihsZXQgcj0wO3I8TWF0aC5taW4obixhLTEpOysrcil7bGV0IHM9ZVtyXSxpPXRbcisxXTtpZihzPj0wJiZpPj0wJiZzIT09MSYmcyE9PWkpdGhyb3cgbmV3IEVycm9yKGBkZWZhdWx0VmFsdWUuc2hhcGU9JHtlfSwgYW5kIHJhZ2dlZCB0ZW5zb3IgaW5wdXQgZmxhdFZhbHVlcy5zaGFwZT0ke3R9IGFyZSBpbmNvbXBhdGlibGU6IGRlZmF1bHRWYWx1ZS5zaGFwZVske3ItZS5sZW5ndGh9XSA9ICR7c30gYnV0IHJhZ2dlZCB0ZW5zb3IgaW5wdXQuZmxhdFZhbHVlcy5zaGFwZVske3ItZS5sZW5ndGh9XSA9ICR7aX1gKX19dmFyIEp3PTMwO2Z1bmN0aW9uIHk0KGUpe3JldHVybiBlPD1Kdz9lOkdoKGUsTWF0aC5mbG9vcihNYXRoLnNxcnQoZSkpKX1mdW5jdGlvbiB4NChlLHQsbil7bGV0IGE9bioodHlwZW9mIGU9PVwibnVtYmVyXCI/ZTplWzBdKSxyPXQqKHR5cGVvZiBlPT1cIm51bWJlclwiP2U6ZVsxXSk7cmV0dXJuW2Escl19ZnVuY3Rpb24gdjQoZSx0LG4sYT0hMCl7bGV0IHI9W107aWYoYSlyPXIuY29uY2F0KHQuc2xpY2UoMCkpLHIucHVzaChlWzBdL24pLHI9ci5jb25jYXQoZS5zbGljZSgxKSk7ZWxzZXtyPXIuY29uY2F0KGVbMF0pO2xldCBzPXQubGVuZ3RoO2ZvcihsZXQgaT0wO2k8czsrK2kpcj1yLmNvbmNhdChbZVtpKzFdL3RbaV0sdFtpXV0pO3I9ci5jb25jYXQoZS5zbGljZShzKzEpKX1yZXR1cm4gcn1mdW5jdGlvbiB3NChlLHQsbj0hMCl7bGV0IGE9W107aWYobil7YS5wdXNoKHQpO2ZvcihsZXQgcj10KzE7cjxlOysrcilyPD0yKnQ/KGEucHVzaChyKSxhLnB1c2goci0odCsxKSkpOmEucHVzaChyKX1lbHNle2xldCByPVtdLHM9W107Zm9yKGxldCBpPTE7aTxlOysraSlpPj10KjIrMXx8aSUyPT09MT9zLnB1c2goaSk6ci5wdXNoKGkpO2EucHVzaCguLi5yKSxhLnB1c2goMCksYS5wdXNoKC4uLnMpfXJldHVybiBhfWZ1bmN0aW9uIGs0KGUsdCxuLGE9ITApe2xldCByPVtdO2E/ci5wdXNoKGVbMF0vbik6ci5wdXNoKGVbMF0qbik7Zm9yKGxldCBzPTE7czxlLmxlbmd0aDsrK3Mpczw9dC5sZW5ndGg/YT9yLnB1c2godFtzLTFdKmVbc10pOnIucHVzaChlW3NdL3Rbcy0xXSk6ci5wdXNoKGVbc10pO3JldHVybiByfWZ1bmN0aW9uIEk0KGUsdCl7bGV0IG49WzBdO2ZvcihsZXQgYT0wO2E8dDsrK2Epbi5wdXNoKGVbYV1bMF0pO3JldHVybiBufWZ1bmN0aW9uIFM0KGUsdCxuKXtsZXQgYT1lLnNsaWNlKDAsMSk7Zm9yKGxldCByPTA7cjxuOysrcilhLnB1c2goZVtyKzFdLXRbcl1bMF0tdFtyXVsxXSk7cmV0dXJuIGF9dmFyIG4yPTEuNzU4MDk5MzQwODQ3Mzc2OCxhMj0xLjA1MDcwMDk4NzM1NTQ4MDUsTjQ9LjMyNzU5MTEsVDQ9LjI1NDgyOTU5MixDND0tLjI4NDQ5NjczNixFND0xLjQyMTQxMzc0MSxfND0tMS40NTMxNTIwMjcsQTQ9MS4wNjE0MDU0Mjk7ZnVuY3Rpb24gRjQoZSx0KXtpZihlLmxlbmd0aCE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgQ2Fubm90IG1lcmdlIHJlYWwgYW5kIGltYWcgYXJyYXlzIG9mIGRpZmZlcmVudCBsZW5ndGhzLiByZWFsOiR7ZS5sZW5ndGh9LCBpbWFnOiAke3QubGVuZ3RofS5gKTtsZXQgbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKjIpO2ZvcihsZXQgYT0wO2E8bi5sZW5ndGg7YSs9MiluW2FdPWVbYS8yXSxuW2ErMV09dFthLzJdO3JldHVybiBufWZ1bmN0aW9uICQ0KGUpe2xldCB0PW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgvMiksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoLzIpO2ZvcihsZXQgYT0wO2E8ZS5sZW5ndGg7YSs9Mil0W2EvMl09ZVthXSxuW2EvMl09ZVthKzFdO3JldHVybntyZWFsOnQsaW1hZzpufX1mdW5jdGlvbiBENChlKXtsZXQgdD1NYXRoLmNlaWwoZS5sZW5ndGgvNCksbj1uZXcgRmxvYXQzMkFycmF5KHQpLGE9bmV3IEZsb2F0MzJBcnJheSh0KTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrPTQpbltNYXRoLmZsb29yKHIvNCldPWVbcl0sYVtNYXRoLmZsb29yKHIvNCldPWVbcisxXTtyZXR1cm57cmVhbDpuLGltYWc6YX19ZnVuY3Rpb24gUjQoZSl7bGV0IHQ9TWF0aC5mbG9vcihlLmxlbmd0aC80KSxuPW5ldyBGbG9hdDMyQXJyYXkodCksYT1uZXcgRmxvYXQzMkFycmF5KHQpO2ZvcihsZXQgcj0yO3I8ZS5sZW5ndGg7cis9NCluW01hdGguZmxvb3Ioci80KV09ZVtyXSxhW01hdGguZmxvb3Ioci80KV09ZVtyKzFdO3JldHVybntyZWFsOm4saW1hZzphfX1mdW5jdGlvbiBNNChlLHQpe2xldCBuPWVbdCoyXSxhPWVbdCoyKzFdO3JldHVybntyZWFsOm4saW1hZzphfX1mdW5jdGlvbiBPNChlLHQsbixhKXtlW2EqMl09dCxlW2EqMisxXT1ufWZ1bmN0aW9uIFA0KGUsdCl7bGV0IG49bmV3IEZsb2F0MzJBcnJheShlLzIpLGE9bmV3IEZsb2F0MzJBcnJheShlLzIpO2ZvcihsZXQgcj0wO3I8TWF0aC5jZWlsKGUvMik7cisrKXtsZXQgcz0odD8yOi0yKSpNYXRoLlBJKihyL2UpO25bcl09TWF0aC5jb3MocyksYVtyXT1NYXRoLnNpbihzKX1yZXR1cm57cmVhbDpuLGltYWc6YX19ZnVuY3Rpb24gTDQoZSx0LG4pe2xldCBhPShuPzI6LTIpKk1hdGguUEkqKGUvdCkscj1NYXRoLmNvcyhhKSxzPU1hdGguc2luKGEpO3JldHVybntyZWFsOnIsaW1hZzpzfX12YXIgdXg9XCItPlwiLHo0PS8tPi9nLG9JPVwiLFwiLGxJPVwiLi4uXCI7ZnVuY3Rpb24gVzQoZSx0KXtlPWUucmVwbGFjZSgvXFxzL2csXCJcIik7bGV0IG49KGUubGVuZ3RoLWUucmVwbGFjZSh6NCxcIlwiKS5sZW5ndGgpL3V4Lmxlbmd0aDtpZihuPDEpdGhyb3cgbmV3IEVycm9yKFwiRXF1YXRpb25zIHdpdGhvdXQgYW4gYXJyb3cgYXJlIG5vdCBzdXBwb3J0ZWQuXCIpO2lmKG4+MSl0aHJvdyBuZXcgRXJyb3IoYEVxdWF0aW9uIG11c3QgY29udGFpbiBleGFjdGx5IG9uZSBhcnJvdyAoXCIke3V4fVwiKS5gKTtsZXRbYSxyXT1lLnNwbGl0KHV4KTtBKGEuaW5kZXhPZihsSSk9PT0tMSwoKT0+YFRoZSBlbGxpcHNpcyBub3RhdGlvbiAoXCIke2xJfVwiKSBpcyBub3Qgc3VwcG9ydGVkIHlldC5gKTtsZXQgcz1hLnNwbGl0KG9JKSxpPXMubGVuZ3RoO2lmKHQhPT1pKXRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgJHtpfSBpbnB1dCB0ZW5zb3JzLCByZWNlaXZlZCAke3R9YCk7aWYoaT4yKXRocm93IG5ldyBFcnJvcihcIlN1cHBvcnQgZm9yIG1vcmUgdGhhbiAyIGlucHV0IHRlbnNvcnMgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7bGV0IG89W107Zm9yKGxldCBjPTA7YzxyLmxlbmd0aDsrK2Mpe2xldCBoPXJbY107aWYoIXMuc29tZShtPT5tLmluZGV4T2YoaCkhPT0tMSkpdGhyb3cgbmV3IEVycm9yKGBPdXRwdXQgc3Vic2NyaXB0cyBjb250YWluIHRoZSBsYWJlbCAke2h9IG5vdCBwcmVzZW50IGluIHRoZSBpbnB1dCBzdWJzY3JpcHRzLmApO28uaW5kZXhPZihoKT09PS0xJiZvLnB1c2goaCl9Zm9yKGxldCBjPTA7YzxhLmxlbmd0aDsrK2Mpe2xldCBoPWFbY107by5pbmRleE9mKGgpPT09LTEmJmghPT1vSSYmby5wdXNoKGgpfWxldCBsPW5ldyBBcnJheShzLmxlbmd0aCk7Zm9yKGxldCBjPTA7YzxpOysrYyl7aWYobmV3IFNldChzW2NdLnNwbGl0KFwiXCIpKS5zaXplIT09c1tjXS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBGb3VuZCBkdXBsaWNhdGUgYXhlcyBpbiBpbnB1dCBjb21wb25lbnQgJHtzW2NdfS4gU3VwcG9ydCBmb3IgZHVwbGljYXRlIGF4ZXMgaW4gaW5wdXQgaXMgbm90IGltcGxlbWVudGVkIHlldC5gKTtsW2NdPVtdO2ZvcihsZXQgaD0wO2g8c1tjXS5sZW5ndGg7KytoKWxbY10ucHVzaChvLmluZGV4T2Yoc1tjXVtoXSkpfWxldCB1PW8ubGVuZ3RoLHA9ci5sZW5ndGgsZD1bXTtmb3IobGV0IGM9cDtjPHU7KytjKWQucHVzaChjKTtyZXR1cm57YWxsRGltczpvLHN1bW1lZERpbXM6ZCxpZERpbXM6bH19ZnVuY3Rpb24gQjQoZSx0KXtsZXQgbj1uZXcgQXJyYXkoZSk7bi5maWxsKC0xKTtmb3IobGV0IHI9MDtyPHQubGVuZ3RoOysrciluW3Rbcl1dPXI7bGV0IGE9W107Zm9yKGxldCByPTA7cjxlOysrciluW3JdPT09LTEmJmEucHVzaChyKTtyZXR1cm4gbj1uLmZpbHRlcihyPT5yIT09LTEpLHtwZXJtdXRhdGlvbkluZGljZXM6bixleHBhbmREaW1zOmF9fWZ1bmN0aW9uIFY0KGUsdCxuKXtsZXQgYT1uZXcgQXJyYXkoZSk7Zm9yKGxldCByPTA7cjxuLmxlbmd0aDsrK3Ipe2xldCBzPW5bcl0uc2hhcGU7Zm9yKGxldCBpPTA7aTx0W3JdLmxlbmd0aDsrK2kpYVt0W3JdW2ldXT09PXZvaWQgMD9hW3Rbcl1baV1dPXNbaV06QShhW3Rbcl1baV1dPT09c1tpXSwoKT0+YEV4cGVjdGVkIGRpbWVuc2lvbiAke2FbdFtyXVtpXV19IGF0IGF4aXMgJHtpfSBvZiBpbnB1dCBzaGFwZWQgJHtKU09OLnN0cmluZ2lmeShzKX0sIGJ1dCBnb3QgZGltZW5zaW9uICR7c1tpXX1gKX19ZnVuY3Rpb24gVTQoZSx0KXtsZXQgbj1lLGE9W10scj0wO2UubGVuZ3RoPT09MCYmbi5wdXNoKC0xKSxyPWUubGVuZ3RoKzE7Zm9yKGxldCBpPTA7aTxyOysraSlhLnB1c2goW10pO2xldCBzPVtdO2ZvcihsZXQgaT0wO2k8bi5sZW5ndGg7KytpKXtsZXQgbz1uW2ldLGw9SDQodCxvKTtmb3IobGV0IHUgb2YgbClzLmluZGV4T2YodSk9PT0tMSYmKGFbaV0ucHVzaCh1KSxzLnB1c2godSkpfXJldHVybntwYXRoOm4sc3RlcHM6YX19ZnVuY3Rpb24gRzQoZSl7cmV0dXJuIGUuZXZlcnkoKHQsbik9PnQ9PT1uKX1mdW5jdGlvbiBINChlLHQpe2xldCBuPVtdO2ZvcihsZXQgYT0wO2E8ZS5sZW5ndGg7KythKShlW2FdLmxlbmd0aD09PTB8fGVbYV0uaW5kZXhPZih0KSE9PS0xfHx0PT09LTEpJiZuLnB1c2goYSk7cmV0dXJuIG59ZnVuY3Rpb24gajQoZSx0LG49MCl7bGV0IGE9W107aWYodHlwZW9mIHQ9PVwibnVtYmVyXCIpQShlLnNoYXBlW25dJXQ9PT0wLCgpPT5cIk51bWJlciBvZiBzcGxpdHMgbXVzdCBldmVubHkgZGl2aWRlIHRoZSBheGlzLlwiKSxhPW5ldyBBcnJheSh0KS5maWxsKGUuc2hhcGVbbl0vdCk7ZWxzZXtsZXQgcj10LnJlZHVjZSgoaSxvKT0+KG89PT0tMSYmKGkrPTEpLGkpLDApO0Eocjw9MSwoKT0+XCJUaGVyZSBzaG91bGQgYmUgb25seSBvbmUgbmVnYXRpdmUgdmFsdWUgaW4gc3BsaXQgYXJyYXkuXCIpO2xldCBzPXQuaW5kZXhPZigtMSk7aWYocyE9PS0xKXtsZXQgaT10LnJlZHVjZSgobyxsKT0+bD4wP28rbDpvKTt0W3NdPWUuc2hhcGVbbl0taX1BKGUuc2hhcGVbbl09PT10LnJlZHVjZSgoaSxvKT0+aStvKSwoKT0+XCJUaGUgc3VtIG9mIHNpemVzIG11c3QgbWF0Y2ggdGhlIHNpemUgb2YgdGhlIGF4aXMgZGltZW5zaW9uLlwiKSxhPXR9cmV0dXJuIGF9ZnVuY3Rpb24gcTQoZSl7cmV0dXJuYFJlY2VpdmVkIFNwYXJzZVRlbnNvciB3aXRoIGRlbnNlU2hhcGVbMF0gPSAwIGJ1dFxuICBpbmRpY2VzLnNoYXBlWzBdID0gJHtlfWB9ZnVuY3Rpb24gSzQoZSx0KXtyZXR1cm5gaW5kaWNlcygke2V9LCAwKSBpcyBpbnZhbGlkOiAke3R9IDwgMGB9ZnVuY3Rpb24gWDQoZSx0LG4pe3JldHVybmBpbmRpY2VzKCR7ZX0sIDApIGlzIGludmFsaWQ6ICR7dH0gPj0gJHtufWB9ZnVuY3Rpb24gWTQoZSx0KXtyZXR1cm5gb25seSBvbmUgb3V0cHV0IGRpbWVuc2lvbiBtYXkgYmUgLTEsIG5vdCBib3RoICR7ZX0gYW5kICR7dH1gfWZ1bmN0aW9uIFo0KGUsdCl7cmV0dXJuYHNpemUgJHtlfSBtdXN0IGJlIG5vbi1uZWdhdGl2ZSwgbm90ICR7dH1gfWZ1bmN0aW9uIEo0KCl7cmV0dXJuXCJyZXNoYXBlIGNhbm5vdCBpbmZlciB0aGUgbWlzc2luZyBpbnB1dCBzaXplIGZvciBhbiBlbXB0eSB0ZW5zb3IgdW5sZXNzIGFsbCBzcGVjaWZpZWQgaW5wdXQgc2l6ZXMgYXJlIG5vbi16ZXJvXCJ9ZnVuY3Rpb24gUTQoZSx0KXtsZXQgbj1vdChlKSxhPW90KHQpO3JldHVybmBJbnB1dCB0byByZXNoYXBlIGlzIGEgU3BhcnNlVGVuc29yIHdpdGggJHtufVxuICBkZW5zZSB2YWx1ZXMsIGJ1dCB0aGUgcmVxdWVzdGVkIHNoYXBlIHJlcXVpcmVzIGEgbXVsdGlwbGUgb2YgJHthfS4gaW5wdXRTaGFwZT0ke2V9IG91dHB1dFNoYXBlPSAke3R9YH1mdW5jdGlvbiBlVihlLHQpe2xldCBuPW90KGUpLGE9b3QodCk7cmV0dXJuYElucHV0IHRvIHJlc2hhcGUgaXMgYSB0ZW5zb3Igd2l0aCAke259IGRlbnNlIHZhbHVlcywgYnV0IHRoZSByZXF1ZXN0ZWQgc2hhcGUgaGFzICR7YX0uIGlucHV0U2hhcGU9JHtlfSBvdXRwdXRTaGFwZT0ke3R9YH1mdW5jdGlvbiB0Vigpe3JldHVyblwic2VnbWVudCBpZHMgbXVzdCBiZSA+PSAwXCJ9ZnVuY3Rpb24gblYoKXtyZXR1cm5cInNlZ21lbnQgaWRzIGFyZSBub3QgaW5jcmVhc2luZ1wifWZ1bmN0aW9uIGFWKGUsdCl7cmV0dXJuYFNlZ21lbnQgaWQgJHtlfSBvdXQgb2YgcmFuZ2UgWzAsICR7dH0pLCBwb3NzaWJseSBiZWNhdXNlIHNlZ21lbnRJZHMgaW5wdXQgaXMgbm90IHNvcnRlZC5gfWZ1bmN0aW9uIHJWKGUsdCxuKXtyZXR1cm5gQmFkOiBpbmRpY2VzWyR7ZX1dID09ICR7dH0gb3V0IG9mIHJhbmdlIFswLCAke259KWB9dmFyIHIyPXt9O19lKHIyLHtjb2xsZWN0R2F0aGVyT3BTaGFwZUluZm86KCk9Pm9WLGNvbXB1dGVPdXRTaGFwZTooKT0+aVYsc2VnT3BDb21wdXRlT3B0aW1hbFdpbmRvd1NpemU6KCk9PnNWfSk7ZnVuY3Rpb24gc1YoZSx0KXtsZXQgbj0hMSxhO2ZvcihlPD1Kdz8oYT1lLG49ITApOmE9R2goZSxNYXRoLmZsb29yKE1hdGguc3FydChlKSkpOyFuOylhPnR8fGE9PT1lP249ITA6YT1HaChlLGErMSk7cmV0dXJuIGF9ZnVuY3Rpb24gaVYoZSx0LG4pe2xldCBhPVtdLHI9ZS5sZW5ndGg7Zm9yKGxldCBzPTA7czxyO3MrKylzIT09dD9hLnB1c2goZVtzXSk6YS5wdXNoKG4pO3JldHVybiBhfWZ1bmN0aW9uIG9WKGUsdCxuLGEpe2xldCByPXQuc2hhcGUubGVuZ3RoLHM9ZS5zaGFwZS5sZW5ndGg7aWYoYSE9PTAmJihhPC1yfHxhPnIpKXRocm93IG5ldyBFcnJvcihgRXhwZWN0IGJhdGNoRGltcyBpbiB0aGUgcmFuZ2Ugb2YgWy0ke3J9LCAke3J9XSwgYnV0IGdvdCAke2F9YCk7aWYoYTwwJiYoYSs9ciksYT5zKXRocm93IG5ldyBFcnJvcihgYmF0Y2hEaW1zICgke2F9KSBtdXN0IGJlIGxlc3MgdGhhbiByYW5rKHgpIChcbiAgICAke3N9KS5gKTtpZihuPGEpdGhyb3cgbmV3IEVycm9yKGBiYXRjaERpbXMgKCR7YX0pIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGF4aXMgKCR7bn0pLmApO2ZvcihsZXQgZD0wO2Q8YTsrK2QpaWYoZS5zaGFwZVtkXSE9PXQuc2hhcGVbZF0pdGhyb3cgbmV3IEVycm9yKGB4LnNoYXBlWyR7ZH1dOiAke2Uuc2hhcGVbZF19IHNob3VsZCBiZSBlcXVhbCB0byBpbmRpY2VzLnNoYXBlWyR7ZH1dOiAke3Quc2hhcGVbZF19LmApO2xldCBpPWUuc2hhcGVbbl0sbz1bXSxsPTEsdT0xLHA9MTtmb3IobGV0IGQ9MDtkPGE7KytkKW8ucHVzaChlLnNoYXBlW2RdKSxsKj1lLnNoYXBlW2RdO2ZvcihsZXQgZD1hO2Q8bjtkKyspby5wdXNoKGUuc2hhcGVbZF0pLHUqPWUuc2hhcGVbZF07Zm9yKGxldCBkPWE7ZDxyO2QrKylvLnB1c2godC5zaGFwZVtkXSk7Zm9yKGxldCBkPW4rMTtkPHM7ZCsrKW8ucHVzaChlLnNoYXBlW2RdKSxwKj1lLnNoYXBlW2RdO3JldHVybntiYXRjaFNpemU6bCxzbGljZVNpemU6cCxvdXRlclNpemU6dSxkaW1TaXplOmksb3V0cHV0U2hhcGU6b319ZnVuY3Rpb24gbFYoZSl7dHJ5e3JldHVybiBlLm1hcCh0PT5xaCh0KSl9Y2F0Y2godCl7dGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZGVjb2RlIGVuY29kZWQgc3RyaW5nIGJ5dGVzIGludG8gdXRmLTgsIGVycm9yOiAke3R9YCl9fWZ1bmN0aW9uIHVWKGUpe3JldHVybiBlLm1hcCh0PT5uZCh0KSl9dmFyIG1yPXt9O19lKG1yLHtub25NYXhTdXBwcmVzc2lvblYzSW1wbDooKT0+U1Qsbm9uTWF4U3VwcHJlc3Npb25WNEltcGw6KCk9Pk5ULG5vbk1heFN1cHByZXNzaW9uVjVJbXBsOigpPT5UVCx3aGVyZUltcGw6KCk9PmhUfSk7VEIoKTt2YXIgczI9e2tlcm5lbE5hbWU6WWwsaW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+eihlLGpvKHJlKG4sXCJmbG9hdDMyXCIpLC0xKSl9fX0scFY9e2tlcm5lbE5hbWU6TmksaW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+e2xldCBhPXB0KHJlKG4sXCJmbG9hdDMyXCIpKSxyPXJuKHBlKHhlKDEpLGEpKTtyZXR1cm4geXQoaGUoZSxyKSl9fX19LGNWPXtrZXJuZWxOYW1lOlRpLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W25dPXQ7cmV0dXJue3g6KCk9PntsZXQgYT1ybihwZShwdChyZShuLFwiZmxvYXQzMlwiKSksMSkpO3JldHVybiBoZShlLGEpfX19fSxkVj17a2VybmVsTmFtZTp2cyxpbnB1dHNUb1NhdmU6W1wiYVwiLFwiYlwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuLGFdPXQscj1jdChuLnNoYXBlLGEuc2hhcGUpO3JldHVybnthOigpPT57bGV0IHM9ZSxpPUJ0KG4uc2hhcGUscik7cmV0dXJuIGkubGVuZ3RoPjAmJihzPWZlKHMsaSkpLFcocyxuLnNoYXBlKX0sYjooKT0+e2xldCBzPWUsaT1CdChhLnNoYXBlLHIpO3JldHVybiBpLmxlbmd0aD4wJiYocz1mZShzLGkpKSxXKHMsYS5zaGFwZSl9fX19LGhWPXtrZXJuZWxOYW1lOkNpLHNhdmVBbGxJbnB1dHM6ITAsZ3JhZEZ1bmM6KGUsdCk9PntsZXQgbj17fTtyZXR1cm4gdC5mb3JFYWNoKChhLHIpPT57bltyXT0oKT0+ZS5jbG9uZSgpfSksbn19LG1WPXtrZXJuZWxOYW1lOlFsLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W25dPXQ7cmV0dXJue3g6KCk9PnFlKG4pfX19LGZWPXtrZXJuZWxOYW1lOmV1LGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W25dPXQ7cmV0dXJue3g6KCk9PnFlKG4pfX19LGdWPXtrZXJuZWxOYW1lOkVpLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W25dPXQ7cmV0dXJue3g6KCk9PmhlKGUscm4ocGUoeGUoMSkscHQocmUobixcImZsb2F0MzJcIikpKSkpfX19LGJWPXtrZXJuZWxOYW1lOl9pLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W25dPXQ7cmV0dXJue3g6KCk9PntsZXQgYT1ybihYKHhlKDEpLHB0KHJlKG4sXCJmbG9hdDMyXCIpKSkpO3JldHVybiBoZShlLGEpfX19fSx5Vj17a2VybmVsTmFtZTokaSxpbnB1dHNUb1NhdmU6W1wiYVwiLFwiYlwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuLGFdPXQscj1jdChuLnNoYXBlLGEuc2hhcGUpO3JldHVybnthOigpPT57bGV0IHM9WChwdChuKSxwdChhKSksaT16KGUsaGUoYSxzKSksbz1CdChuLnNoYXBlLHIpO3JldHVybiBvLmxlbmd0aD4wJiYoaT1mZShpLG8pKSxXKGksbi5zaGFwZSl9LGI6KCk9PntsZXQgcz1YKHB0KG4pLHB0KGEpKSxpPXl0KHooZSxoZShuLHMpKSksbz1CdChhLnNoYXBlLHIpO3JldHVybiBvLmxlbmd0aD4wJiYoaT1mZShpLG8pKSxXKGksYS5zaGFwZSl9fX19LHhWPXtrZXJuZWxOYW1lOkFpLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W25dPXQ7cmV0dXJue3g6KCk9PmhlKGUsWChwdChyZShuLFwiZmxvYXQzMlwiKSksMSkpfX19LHZWPXtrZXJuZWxOYW1lOkZpLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W25dPXQ7cmV0dXJue3g6KCk9PmhlKGUscGUoeGUoMSkscHQocmUobixcImZsb2F0MzJcIikpKSl9fX07ZnVuY3Rpb24gd1YoZSx0LG4sYSxyLHMpe2xldCBpPUUoZSxcImR5XCIsXCJhdmdQb29sM2RHcmFkXCIpLG89RSh0LFwiaW5wdXRcIixcImF2Z1Bvb2wzZEdyYWRcIiksbD1pLHU9byxwPSExO28ucmFuaz09PTQmJihwPSEwLGw9VyhpLFsxLGkuc2hhcGVbMF0saS5zaGFwZVsxXSxpLnNoYXBlWzJdLGkuc2hhcGVbM11dKSx1PVcobyxbMSxvLnNoYXBlWzBdLG8uc2hhcGVbMV0sby5zaGFwZVsyXSxvLnNoYXBlWzNdXSkpLEEobC5yYW5rPT09NSwoKT0+YEVycm9yIGluIGF2Z1Bvb2wzZEdyYWQ6IGR5IG11c3QgYmUgcmFuayA1IGJ1dCBnb3QgcmFuayAke2wucmFua30uYCksQSh1LnJhbms9PT01LCgpPT5gRXJyb3IgaW4gYXZnUG9vbDNkR3JhZDogaW5wdXQgbXVzdCBiZSByYW5rIDUgYnV0IGdvdCByYW5rICR7dS5yYW5rfS5gKSxUbihcImF2Z1Bvb2wzZEdyYWRcIixyLHMpO2xldCBkPXtkeTpsLGlucHV0OnV9LGM9e2ZpbHRlclNpemU6bixzdHJpZGVzOmEscGFkOnIsZGltUm91bmRpbmdNb2RlOnN9LGg9UC5ydW5LZXJuZWwoUmMsZCxjKTtyZXR1cm4gcD9XKGgsW2guc2hhcGVbMV0saC5zaGFwZVsyXSxoLnNoYXBlWzNdLGguc2hhcGVbNF1dKTpofXZhciBrVj1MKHthdmdQb29sM2RHcmFkXzp3Vn0pLElWPXtrZXJuZWxOYW1lOnR1LGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQsbik9PntsZXRbYV09dCx7ZmlsdGVyU2l6ZTpyLHN0cmlkZXM6cyxwYWQ6aSxkaW1Sb3VuZGluZ01vZGU6b309bjtyZXR1cm57eDooKT0+a1YoZSxhLHIscyxpLG8pfX19O2Z1bmN0aW9uIFNWKGUsdCxuLGEscil7bGV0IHM9RShlLFwiZHlcIixcImF2Z1Bvb2xHcmFkXCIpLGk9RSh0LFwiaW5wdXRcIixcImF2Z1Bvb2xHcmFkXCIpO0EoaS5yYW5rPT09cy5yYW5rLCgpPT5gUmFuayBvZiBpbnB1dCAoJHtpLnJhbmt9KSBkb2VzIG5vdCBtYXRjaCByYW5rIG9mIGR5ICgke3MucmFua30pYCk7bGV0IG89aSxsPXMsdT0hMTtpLnJhbms9PT0zJiYodT0hMCxvPVcoaSxbMSxpLnNoYXBlWzBdLGkuc2hhcGVbMV0saS5zaGFwZVsyXV0pLGw9VyhzLFsxLHMuc2hhcGVbMF0scy5zaGFwZVsxXSxzLnNoYXBlWzJdXSkpLEEobC5yYW5rPT09NCwoKT0+YEVycm9yIGluIGF2Z1Bvb2xHcmFkOiBkeSBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgJHtsLnJhbmt9LmApLEEoby5yYW5rPT09NCwoKT0+YEVycm9yIGluIGF2Z1Bvb2xHcmFkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgJHtvLnJhbmt9LmApO2xldCBwPXtkeTpsLGlucHV0Om99LGQ9e2ZpbHRlclNpemU6bixzdHJpZGVzOmEscGFkOnJ9LGM9UC5ydW5LZXJuZWwoRGMscCxkKTtyZXR1cm4gdT9XKGMsW2Muc2hhcGVbMV0sYy5zaGFwZVsyXSxjLnNoYXBlWzNdXSk6Y312YXIgTlY9TCh7YXZnUG9vbEdyYWRfOlNWfSksVFY9e2tlcm5lbE5hbWU6RGksaW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldFthXT10LHtmaWx0ZXJTaXplOnIsc3RyaWRlczpzLHBhZDppfT1uO3JldHVybnt4OigpPT5OVihlLGEscixzLGkpfX19LENWPXtrZXJuZWxOYW1lOlJpLGlucHV0c1RvU2F2ZTpbXCJhXCIsXCJiXCJdLGdyYWRGdW5jOihlLHQsbik9PntsZXRbYSxyXT10LHt0cmFuc3Bvc2VBOnMsdHJhbnNwb3NlQjppfT1uO3JldHVybiFzJiYhaT97YTooKT0+JGUoZSxyLCExLCEwKSxiOigpPT4kZShhLGUsITAsITEpfTohcyYmaT97YTooKT0+JGUoZSxyLCExLCExKSxiOigpPT4kZShlLGEsITAsITEpfTpzJiYhaT97YTooKT0+JGUocixlLCExLCEwKSxiOigpPT4kZShhLGUsITEsITEpfTp7YTooKT0+JGUocixlLCEwLCEwKSxiOigpPT4kZShlLGEsITAsITApfX19LEVWPXtrZXJuZWxOYW1lOm51LGdyYWRGdW5jOihlLHQsbik9PntsZXR7YmxvY2tTaGFwZTphLGNyb3BzOnJ9PW47cmV0dXJue3g6KCk9Pm1kKGUsYSxyKX19fSxfVj17a2VybmVsTmFtZTpIUyxncmFkRnVuYzooZSx0LG4pPT57bGV0IGE9bixyPWEuaW5wdXRTaGFwZSxzPWEuc2hhcGUsaT1BcnJheS5mcm9tKHMpO2ZvcihsZXQgbD1yLmxlbmd0aC0xO2w+PTA7bC0tKWlmKHJbbF09PT1zW2xdKWlbbF09MTtlbHNlIGlmKHJbbF0hPT0xKXRocm93IG5ldyBFcnJvcihgYnJvYWRjYXN0VG8oKTogWyR7cn1dIGNhbm5vdCBiZSBicm9hZGNhc3QgdG8gWyR7c31dLmApO2xldCBvPVtdO2ZvcihsZXQgbD0wO2w8aS5sZW5ndGg7bCsrKWlbbF0+MSYmby5wdXNoKGwpO3JldHVybnt4OigpPT5mZShlLG8sITApfX19LEFWPXtrZXJuZWxOYW1lOk1pLGdyYWRGdW5jOmU9Pih7eDooKT0+ZS5jbG9uZSgpfSl9LEZWPXtrZXJuZWxOYW1lOk9pLGdyYWRGdW5jOmU9Pih7eDooKT0+cWUoZSl9KX0sJFY9e2tlcm5lbE5hbWU6d3MsaW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldFthXT10LHtjbGlwVmFsdWVNaW46cixjbGlwVmFsdWVNYXg6c309bjtyZXR1cm57eDooKT0+bm4oX2EoJHIoYSxyKSxDcyhhLHMpKSxlLHFlKGUpKX19fSxEVj17a2VybmVsTmFtZTpPYyxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzpzMi5ncmFkRnVuY30sUlY9e2tlcm5lbE5hbWU6c3Usc2F2ZUFsbElucHV0czohMCxncmFkRnVuYzooZSx0LG4pPT57bGV0IGE9dC5tYXAobz0+by5zaGFwZSkse2F4aXM6cn09bixzPUFhKHIsdFswXS5zaGFwZSlbMF0saT1hLm1hcChvPT5vW3NdKTtyZXR1cm4gTG4oZSxpLHMpLm1hcChvPT4oKT0+byl9fSxNVj17a2VybmVsTmFtZTpQaSxpbnB1dHNUb1NhdmU6W1wieFwiLFwiZmlsdGVyXCJdLGdyYWRGdW5jOihlLHQsbik9PntsZXRbYSxyXT10LHtkaWxhdGlvbnM6cyxzdHJpZGVzOmkscGFkOm8sZGF0YUZvcm1hdDpsfT1uO3JldHVybiBBKHBzKHMpLCgpPT5gRXJyb3IgaW4gZ3JhZGllbnQgb2YgY29udjJEOiBkaWxhdGlvbiByYXRlcyBncmVhdGVyIHRoYW4gMSBhcmUgbm90IHlldCBzdXBwb3J0ZWQgaW4gZ3JhZGllbnRzLiBHb3QgZGlsYXRpb25zICcke3N9J2ApLHt4OigpPT5udyhhLnNoYXBlLGUscixpLG8sbCksZmlsdGVyOigpPT56dyhhLGUsci5zaGFwZSxpLG8sbCl9fX0sT1Y9e2tlcm5lbE5hbWU6TGksaW5wdXRzVG9TYXZlOltcImR5XCIsXCJmaWx0ZXJcIl0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldFthLHJdPXQse3N0cmlkZXM6cyxwYWQ6aSxkYXRhRm9ybWF0Om8sZGltUm91bmRpbmdNb2RlOmx9PW47cmV0dXJue2R5OigpPT4kdChlLHIscyxpLG8sMSxsKSxmaWx0ZXI6KCk9Pnp3KGUsYSxyLnNoYXBlLHMsaSxvLGwpfX19O2Z1bmN0aW9uIFBWKGUsdCxuLGEscil7bGV0IHM9ZTtlLnJhbms9PT00JiYocz1XKGUsWzEsZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl0sZS5zaGFwZVszXV0pKTtsZXQgaT10O2kucmFuaz09PTQmJihpPVcodCxbMSx0LnNoYXBlWzBdLHQuc2hhcGVbMV0sdC5zaGFwZVsyXSx0LnNoYXBlWzNdXSkpLEEocy5yYW5rPT09NSwoKT0+YEVycm9yIGluIGNvbnYzZERlckZpbHRlcjogaW5wdXQgbXVzdCBiZSByYW5rIDUsIGJ1dCBnb3Qgc2hhcGUgJHtzLnNoYXBlfS5gKSxBKGkucmFuaz09PTUsKCk9PmBFcnJvciBpbiBjb252M2REZXJGaWx0ZXI6IGR5IG11c3QgYmUgcmFuayA1LCBidXQgZ290IHNoYXBlICR7aS5zaGFwZX0uYCksQShuLmxlbmd0aD09PTUsKCk9PmBFcnJvciBpbiBjb252M2REZXJGaWx0ZXI6IGZpbHRlclNoYXBlIG11c3QgYmUgbGVuZ3RoIDUsIGJ1dCBnb3QgJHtufS5gKSxBKHMuc2hhcGVbNF09PT1uWzNdLCgpPT5gRXJyb3IgaW4gY29udjNkRGVyRmlsdGVyOiBkZXB0aCBvZiBpbnB1dCAke3Muc2hhcGVbNF19KSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGluIGZpbHRlciAoJHtuWzNdfS5gKSxBKGkuc2hhcGVbNF09PT1uWzRdLCgpPT5gRXJyb3IgaW4gY29udjNkRGVyRmlsdGVyOiBkZXB0aCBvZiBkeSAoJHtpLnNoYXBlWzRdfSkgbXVzdCBtYXRjaCBvdXRwdXQgZGVwdGggZm9yIGZpbHRlciAoJHtuWzRdfSkuYCk7bGV0IG89e3g6cyxkeTppfSxsPXtzdHJpZGVzOmEscGFkOnIsZmlsdGVyU2hhcGU6bn07cmV0dXJuIFAucnVuS2VybmVsKGl1LG8sbCl9dmFyIExWPUwoe2NvbnYzREJhY2twcm9wRmlsdGVyXzpQVn0pLHpWPXtrZXJuZWxOYW1lOnppLGlucHV0c1RvU2F2ZTpbXCJ4XCIsXCJmaWx0ZXJcIl0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldHtkaWxhdGlvbnM6YSxzdHJpZGVzOnIscGFkOnN9PW47QShwcyhhKSwoKT0+YEVycm9yIGluIGdyYWRpZW50IG9mIGNvbnYzRDogZGlsYXRpb24gcmF0ZXMgZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIGluIGdyYWRpZW50cy4gR290IGRpbGF0aW9ucyAnJHthfSdgKTtsZXRbaSxvXT10O3JldHVybnt4OigpPT5DTihpLnNoYXBlLGUsbyxyLHMpLGZpbHRlcjooKT0+TFYoaSxlLG8uc2hhcGUscixzKX19fSxXVj17a2VybmVsTmFtZTpXaSxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuXT10O3JldHVybnt4OigpPT56KHl0KGVmKHJlKG4sXCJmbG9hdDMyXCIpKSksZSl9fX0sQlY9e2tlcm5lbE5hbWU6QmksaW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+eih0ZihyZShuLFwiZmxvYXQzMlwiKSksZSl9fX0sVlY9e2tlcm5lbE5hbWU6VmksaW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldFthXT10LHtheGlzOnIsZXhjbHVzaXZlOnMscmV2ZXJzZTppfT1uO3JldHVybnt4OigpPT57bGV0IG89RE4oW3JdLGEucmFuayksbD1WbShlLHIscywhaSk7cmV0dXJuIG8hPW51bGwmJihsPURlKGwsbykpLGx9fX19LFVWPXtrZXJuZWxOYW1lOlVpLGlucHV0c1RvU2F2ZTpbXCJ4XCIsXCJmaWx0ZXJcIl0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldHtkaWxhdGlvbnM6YSxzdHJpZGVzOnIscGFkOnMsZGltUm91bmRpbmdNb2RlOml9PW4sbz1hPT1udWxsP1sxLDFdOmE7QShwcyhvKSwoKT0+YEVycm9yIGluIGdyYWRpZW50IG9mIGRlcHRod2lzZUNvbnYyZE5hdGl2ZTogZGlsYXRpb24gcmF0ZXMgZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkLiBHb3QgZGlsYXRpb25zICcke299J2ApO2xldFtsLHVdPXQ7cmV0dXJuIEEobC5yYW5rPT09NCwoKT0+YEVycm9yIGluIGdyYWRpZW50IG9mIGRlcHRod2lzZUNvbnYyZE5hdGl2ZTogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayAke2wucmFua30uYCksQSh1LnJhbms9PT00LCgpPT5gRXJyb3IgaW4gZ3JhZGllbnQgb2YgZGVwdGh3aXNlQ29udjJkTmF0aXZlOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayAke3UucmFua30uYCksQShsLnNoYXBlWzNdPT09dS5zaGFwZVsyXSwoKT0+YEVycm9yIGluIGdyYWRpZW50IG9mIGRlcHRod2lzZUNvbnYyZDogbnVtYmVyIG9mIGlucHV0IGNoYW5uZWxzICgke2wuc2hhcGVbM119KSBtdXN0IG1hdGNoIHRoZSBpbkNoYW5uZWxzIGRpbWVuc2lvbiBpbiBmaWx0ZXIgJHt1LnNoYXBlWzJdfS5gKSxBKGRyKHIsbyksKCk9PmBFcnJvciBpbiBncmFkaWVudCBvZiBkZXB0aHdpc2VDb252MmQ6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlICAxLiBHb3Qgc3RyaWRlcyAke3J9IGFuZCBkaWxhdGlvbnMgJyR7b30nLmApLFRuKFwiZGVwdGh3aXNlQ29udjJkXCIscyxpKSx7eDooKT0+d1QobC5zaGFwZSxlLHUscixzLG8saSksZmlsdGVyOigpPT52VChsLGUsdS5zaGFwZSxyLHMsbyxpKX19fSxHVj17a2VybmVsTmFtZTpHaSxpbnB1dHNUb1NhdmU6W1wieFwiLFwiZmlsdGVyXCJdLGdyYWRGdW5jOihlLHQsbik9PntsZXRbYSxyXT10LHM9e3g6YSxmaWx0ZXI6cixkeTplfSxpPXt4OmEsZmlsdGVyOnIsZHk6ZX07cmV0dXJue3g6KCk9PlAucnVuS2VybmVsKERsLHMsbiksZmlsdGVyOigpPT5QLnJ1bktlcm5lbChSbCxpLG4pfX19LEhWPXtrZXJuZWxOYW1lOmppLG91dHB1dHNUb1NhdmU6WyEwXSxncmFkRnVuYzooZSx0KT0+e2xldFtuXT10LGE9e2R5OmUseTpufTtyZXR1cm57eDooKT0+UC5ydW5LZXJuZWwoY3UsYSl9fX0salY9e2tlcm5lbE5hbWU6cWksaW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dCxhPXooZG4oeXQocHQobikpKSwyL01hdGguc3FydChNYXRoLlBJKSk7cmV0dXJue3g6KCk9PnooZSxhKX19fSxxVj17a2VybmVsTmFtZTpLaSxvdXRwdXRzVG9TYXZlOlshMF0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+eihlLG4pfX19LEtWPXtrZXJuZWxOYW1lOmh1LGlucHV0c1RvU2F2ZTpbXCJpbnB1dFwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuXT10O3JldHVybntpbnB1dDooKT0+VyhlLG4uc2hhcGUpfX19LFhWPXtrZXJuZWxOYW1lOlhpLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W25dPXQ7cmV0dXJue3g6KCk9PnooZSxkbihuKSl9fX0sWVY9e2tlcm5lbE5hbWU6WWksZ3JhZEZ1bmM6ZT0+KHt4OigpPT5xZShlKX0pfSxaVj17a2VybmVsTmFtZTpaaSxpbnB1dHNUb1NhdmU6W1wiYVwiLFwiYlwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuLGFdPXQscj1jdChuLnNoYXBlLGEuc2hhcGUpO3JldHVybnthOigpPT57bGV0IHM9aGUoZSxyZShhLFwiZmxvYXQzMlwiKSksaT1CdChuLnNoYXBlLHIpO3JldHVybiBpLmxlbmd0aD4wP1coZmUocyxpKSxuLnNoYXBlKTpzfSxiOigpPT57bGV0IHM9eihlLHJlKG4sXCJmbG9hdDMyXCIpKSxpPUJ0KGEuc2hhcGUscik7aS5sZW5ndGg+MCYmKHM9VyhmZShzLGkpLGEuc2hhcGUpKTtsZXQgbz1wdChhKTtyZXR1cm4geXQoaGUocyxyZShvLFwiZmxvYXQzMlwiKSkpfX19fSxKVj17a2VybmVsTmFtZTpKaSxpbnB1dHNUb1NhdmU6W1wieFwiLFwibWVhblwiLFwidmFyaWFuY2VcIixcInNjYWxlXCJdLGdyYWRGdW5jOihlLHQsbik9PntsZXR7dmFyaWFuY2VFcHNpbG9uOmF9PW4sW3IscyxpLG9dPXQsbD1vPT1udWxsP3hlKDEpOm8sdT1CdChzLnNoYXBlLHIuc2hhcGUpLHA9W107aWYocy5yYW5rPT09MSl7Zm9yKGxldCBmPTA7ZjxyLnNoYXBlLmxlbmd0aC0xOysrZilwLnB1c2goci5zaGFwZVtmXSk7cC5wdXNoKDEpfWxldCBkPXBlKHIscyksYz16KGUsbCksaD1KbShYKGkseGUoYSkpKSxtPXooeih6KGgsaCksaCkseGUoLS41KSk7cmV0dXJue3g6KCk9PnMucmFuaz09PTE/Vyh6KHooZSxPbihXKGgsWzEsMSwxLHMuc2hhcGVbMF1dKSxwKSksbCksci5zaGFwZSk6Vyh6KHooZSxoKSxsKSxyLnNoYXBlKSxtZWFuOigpPT57bGV0IGY9eih6KGgseGUoLTEpKSxjKTtyZXR1cm4gcy5yYW5rPT09MSYmKGY9ZmUoZix1KSksVyhmLHMuc2hhcGUpfSx2YXJpYW5jZTooKT0+e2xldCBmPXooeihtLGQpLGMpO3JldHVybiBzLnJhbms9PT0xJiYoZj1mZShmLHUpKSxXKGYscy5zaGFwZSl9LHNjYWxlOigpPT57bGV0IGY9eihkLGgpLGc9eihlLGYpO3JldHVybiBzLnJhbms9PT0xJiYoZz1mZShnLHUpKSxXKGcscy5zaGFwZSl9LG9mZnNldDooKT0+e2xldCBmPWU7cmV0dXJuIHMucmFuaz09PTEmJihmPWZlKGYsdSkpLFcoZixzLnNoYXBlKX19fX0sUVY9e2tlcm5lbE5hbWU6ZnUsaW5wdXRzVG9TYXZlOltcInhcIixcImluZGljZXNcIl0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldFthLHJdPXQse2F4aXM6cyxiYXRjaERpbXM6aX09bixvPUFhKHMsYS5zaGFwZSlbMF0sbD0odSxwLGQpPT4oKT0+e2xldCBjPXUuc2hhcGUsaD1wLnNpemUsbT1jLnNsaWNlKDAsbyksZj1tLmxlbmd0aCxnPWMuc2xpY2UocyxjLmxlbmd0aCkuc2xpY2UoMSksYj1nLmxlbmd0aCx5PXVJKDAsZikseD11SShmKzEsZisxK2IpLHY9cEkoW20sW2hdLGddKSxJPVcoZCx2KSxOPVcocCxbaF0pLEM9cEkoW1tmXSx5LHhdKSxfPURlKEksQyksRj11ZihfLE4sdS5zaGFwZVtvXSksRD1wdyhDKTtyZXR1cm4gRj1EZShGLEQpLEZ9O2lmKGk9PT0xKXtsZXQgdT1hLnNoYXBlWzBdLHA9YS5zcGxpdCh1LDApO3JldHVybnt4OigpPT5BdChwLm1hcCgoZCxjKT0+bChkLHIuc2xpY2UoYywxKSxlLnNsaWNlKGMsMSkpKCkpKS5yZXNoYXBlKGEuc2hhcGUpLGluZGljZXM6KCk9PnJ9fWVsc2UgcmV0dXJue3g6bChhLHIsZSksaW5kaWNlczooKT0+cn19fTtmdW5jdGlvbiB1SShlLHQpe2xldCBuPVtdO2ZvcihsZXQgYT1lO2E8dDsrK2Epbi5wdXNoKGEpO3JldHVybiBufWZ1bmN0aW9uIHBJKGUpe2xldCB0PVtdO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7KytuKWZvcihsZXQgYT0wO2E8ZVtuXS5sZW5ndGg7KythKXQucHVzaChlW25dW2FdKTtyZXR1cm4gdH12YXIgZVU9e2tlcm5lbE5hbWU6UWksaW5wdXRzVG9TYXZlOltcImFcIixcImJcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbixhXT10O3JldHVybnthOigpPT5xZShuKSxiOigpPT5xZShhKX19fSx0VT17a2VybmVsTmFtZTplbyxncmFkRnVuYzplPT4oe3g6KCk9PnJlKGUsXCJmbG9hdDMyXCIpfSl9LG5VPXtrZXJuZWxOYW1lOnRvLGdyYWRGdW5jOmU9Pih7eDooKT0+cWUoZSl9KX0sYVU9e2tlcm5lbE5hbWU6bm8sZ3JhZEZ1bmM6ZT0+KHt4OigpPT5xZShlKX0pfSxyVT17a2VybmVsTmFtZTphbyxncmFkRnVuYzplPT4oe3g6KCk9PnFlKGUpfSl9LHNVPXtrZXJuZWxOYW1lOnJvLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQsbik9PntsZXRbYV09dCx7YWxwaGE6cn09bixzPUNuKGEsMCk7cmV0dXJue3g6KCk9Pm5uKHMsZSx6KGUscikpfX19LGlVPXtrZXJuZWxOYW1lOmlvLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W25dPXQ7cmV0dXJue3g6KCk9PmhlKGUsWChuLDEpKX19fSxvVT17a2VybmVsTmFtZTpzbyxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuXT10O3JldHVybnt4OigpPT5oZShlLHJlKG4sXCJmbG9hdDMyXCIpKX19fSxsVT17a2VybmVsTmFtZTpxUyxpbnB1dHNUb1NhdmU6W10sb3V0cHV0c1RvU2F2ZTpbITBdLGdyYWRGdW5jOihlLHQsbik9PntsZXRbYV09dCx7YXhpczpyfT1uO3JldHVybntsb2dpdHM6KCk9PntsZXQgcz1kbihhKTtyZXR1cm4gcGUoZSx6KGZlKGUsciwhMCkscykpfX19fTtmdW5jdGlvbiB1VShlLHQsbixhPTUscj0xLHM9MSxpPS41KXtsZXQgbz17eDplLHk6dCxkeTpufSxsPXtkZXB0aFJhZGl1czphLGJpYXM6cixhbHBoYTpzLGJldGE6aX07cmV0dXJuIFAucnVuS2VybmVsKFN1LG8sbCl9dmFyIHBVPUwoe2xvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uQmFja3Byb3BfOnVVfSksY1U9e2tlcm5lbE5hbWU6b28saW5wdXRzVG9TYXZlOltcInhcIl0sb3V0cHV0c1RvU2F2ZTpbITBdLGdyYWRGdW5jOihlLHQsbik9PntsZXRbYSxyXT10LHtkZXB0aFJhZGl1czpzLGJpYXM6aSxhbHBoYTpvLGJldGE6bH09bjtyZXR1cm57eDooKT0+cFUoYSxyLGUscyxpLG8sbCl9fX07ZnVuY3Rpb24gaTIoZSx0LG4sYSl7cmV0dXJuIHQucmFuazxuLnJhbmsmJih0PVcodCxtaSh0LnNoYXBlLGEpKSksZS5yYW5rPG4ucmFuayYmKGU9VyhlLG1pKGUuc2hhcGUsYSkpKSx7eDooKT0+eihlLHJlKEpuKG4sdCksZS5kdHlwZSkpfX12YXIgY0k9e2tlcm5lbE5hbWU6bG8saW5wdXRzVG9TYXZlOltcInhcIl0sb3V0cHV0c1RvU2F2ZTpbITBdLGdyYWRGdW5jOihlLHQsbik9PntsZXQgYT1uLHtyZWR1Y3Rpb25JbmRpY2VzOnJ9PWEscz10WzBdLGk9dFsxXSxvPUFhKHIscy5zaGFwZSksbD1pMihlLGkscyxvKTtyZXR1cm57eDooKT0+bC54KCl9fX0sZFU9e2tlcm5lbE5hbWU6dW8saW5wdXRzVG9TYXZlOltcImFcIixcImJcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbixhXT10O3JldHVybnthOigpPT56KGUscmUoJHIobixhKSxcImZsb2F0MzJcIikpLGI6KCk9PnooZSxyZShQbChuLGEpLFwiZmxvYXQzMlwiKSl9fX07ZnVuY3Rpb24gaFUoZSx0LG4sYSxyLHMsaSl7bGV0IG89RShlLFwiZHlcIixcIm1heFBvb2wzZEdyYWRcIiksbD1FKHQsXCJpbnB1dFwiLFwibWF4UG9vbDNkR3JhZFwiKSx1PUUobixcIm91dHB1dFwiLFwibWF4UG9vbDNkR3JhZFwiKSxwPW8sZD1sLGM9dSxoPSExO2wucmFuaz09PTQmJihoPSEwLHA9VyhvLFsxLG8uc2hhcGVbMF0sby5zaGFwZVsxXSxvLnNoYXBlWzJdLG8uc2hhcGVbM11dKSxkPVcobCxbMSxsLnNoYXBlWzBdLGwuc2hhcGVbMV0sbC5zaGFwZVsyXSxsLnNoYXBlWzNdXSksYz1XKHUsWzEsdS5zaGFwZVswXSx1LnNoYXBlWzFdLHUuc2hhcGVbMl0sdS5zaGFwZVszXV0pKSxBKHAucmFuaz09PTUsKCk9PmBFcnJvciBpbiBtYXhQb29sM2RHcmFkOiBkeSBtdXN0IGJlIHJhbmsgNSBidXQgZ290IHJhbmsgJHtwLnJhbmt9LmApLEEoZC5yYW5rPT09NSwoKT0+YEVycm9yIGluIG1heFBvb2wzZEdyYWQ6IGlucHV0IG11c3QgYmUgcmFuayA1IGJ1dCBnb3QgcmFuayAke2QucmFua30uYCksQShjLnJhbms9PT01LCgpPT5gRXJyb3IgaW4gbWF4UG9vbDNkR3JhZDogb3V0cHV0IG11c3QgYmUgcmFuayA1IGJ1dCBnb3QgcmFuayAke2MucmFua30uYCksVG4oXCJtYXhQb29sM2RHcmFkXCIscyxpKTtsZXQgbT17ZHk6cCxpbnB1dDpkLG91dHB1dDpjfSxmPXtmaWx0ZXJTaXplOmEsc3RyaWRlczpyLHBhZDpzLGRpbVJvdW5kaW5nTW9kZTppfSxnPVAucnVuS2VybmVsKEJjLG0sZik7cmV0dXJuIGg/VyhnLFtnLnNoYXBlWzFdLGcuc2hhcGVbMl0sZy5zaGFwZVszXSxnLnNoYXBlWzRdXSk6Z312YXIgbVU9TCh7bWF4UG9vbDNkR3JhZF86aFV9KSxmVT17a2VybmVsTmFtZTpOdSxpbnB1dHNUb1NhdmU6W1wieFwiXSxvdXRwdXRzVG9TYXZlOlshMF0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldFthLHJdPXQse2ZpbHRlclNpemU6cyxzdHJpZGVzOmkscGFkOm8sZGltUm91bmRpbmdNb2RlOmx9PW47cmV0dXJue3g6KCk9Pm1VKGUsYSxyLHMsaSxvLGwpfX19O2Z1bmN0aW9uIGdVKGUsdCxuLGEscixzLGkpe2xldCBvPUUoZSxcImR5XCIsXCJtYXhQb29sR3JhZFwiKSxsPUUodCxcImlucHV0XCIsXCJtYXhQb29sR3JhZFwiKSx1PUUobixcIm91dHB1dFwiLFwibWF4UG9vbEdyYWRcIik7QShsLnJhbms9PT1vLnJhbmssKCk9PmBSYW5rIG9mIGlucHV0ICgke2wucmFua30pIGRvZXMgbm90IG1hdGNoIHJhbmsgb2YgZHkgKCR7by5yYW5rfSlgKSxBKG8ucmFuaz09PTQsKCk9PmBFcnJvciBpbiBtYXhQb29sR3JhZDogZHkgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rICR7by5yYW5rfS5gKSxBKGwucmFuaz09PTQsKCk9PmBFcnJvciBpbiBtYXhQb29sR3JhZDogaW5wdXQgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rICR7bC5yYW5rfS5gKSxUbihcIm1heFBvb2xHcmFkXCIscyxpKTtsZXQgcD17ZHk6byxpbnB1dDpsLG91dHB1dDp1fSxkPXtmaWx0ZXJTaXplOmEsc3RyaWRlczpyLHBhZDpzLGRpbVJvdW5kaW5nTW9kZTppfTtyZXR1cm4gUC5ydW5LZXJuZWwoV2MscCxkKX12YXIgYlU9TCh7bWF4UG9vbEdyYWRfOmdVfSkseVU9e2tlcm5lbE5hbWU6cG8saW5wdXRzVG9TYXZlOltcInhcIl0sb3V0cHV0c1RvU2F2ZTpbITBdLGdyYWRGdW5jOihlLHQsbik9PntsZXRbYSxyXT10LHtmaWx0ZXJTaXplOnMsc3RyaWRlczppLHBhZDpvfT1uO3JldHVybnt4OigpPT5iVShlLGEscixzLGksbyl9fX0seFU9e2tlcm5lbE5hbWU6Y28saW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldFthXT10LHtheGlzOnJ9PW4scz1BYShyLGEuc2hhcGUpLGk9JE4oYS5zaGFwZSxzKVsxXSxvPW90KGkpO3JldHVybnt4OigpPT57bGV0IGw9YS5zaGFwZS5zbGljZSgpO3MuZm9yRWFjaChwPT57bFtwXT0xfSk7bGV0IHU9VyhlLGwpO3JldHVybiBoZSh6KHUsUG4oYS5zaGFwZSxcImZsb2F0MzJcIikpLG8pfX19fSx2VT17a2VybmVsTmFtZTpobyxpbnB1dHNUb1NhdmU6W1wieFwiXSxvdXRwdXRzVG9TYXZlOlshMF0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldCBhPW4se2F4aXM6cn09YSxbcyxpXT10LG89QWEocixzLnNoYXBlKSxsPWkyKGUsaSxzLG8pO3JldHVybnt4OigpPT5sLngoKX19fSx3VT17a2VybmVsTmFtZTptbyxpbnB1dHNUb1NhdmU6W1wiYVwiLFwiYlwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuLGFdPXQ7cmV0dXJue2E6KCk9PnooZSxyZShDcyhuLGEpLFwiZmxvYXQzMlwiKSksYjooKT0+eihlLHJlKENuKG4sYSksXCJmbG9hdDMyXCIpKX19fSxrVT17a2VybmVsTmFtZTpmbyxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0LG4pPT57bGV0IGE9dFswXSx7cGFkZGluZ3M6cn09bixzPXIubWFwKGk9PmlbMF0pO3JldHVybnt4OigpPT5WZShlLHMsYS5zaGFwZSl9fX0sSVU9e2tlcm5lbE5hbWU6Z28saW5wdXRzVG9TYXZlOltcImFcIixcImJcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbixhXT10LHI9Y3Qobi5zaGFwZSxhLnNoYXBlKTtyZXR1cm57YTooKT0+e2xldCBzPUJ0KG4uc2hhcGUscik7cmV0dXJuIHMubGVuZ3RoPjA/VyhmZShlLHMpLG4uc2hhcGUpOmV9LGI6KCk9PntsZXQgcz16KGUseXQodHAoaGUobixhKSkpKSxpPUJ0KGEuc2hhcGUscik7cmV0dXJuIGkubGVuZ3RoPjA/VyhmZShzLGkpLGEuc2hhcGUpOnN9fX19LFNVPXtrZXJuZWxOYW1lOmJvLGlucHV0c1RvU2F2ZTpbXCJhXCIsXCJiXCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W24sYV09dCxyPWN0KG4uc2hhcGUsYS5zaGFwZSk7cmV0dXJue2E6KCk9PntsZXQgcz16KGUscmUoYSxcImZsb2F0MzJcIikpLGk9QnQobi5zaGFwZSxyKTtyZXR1cm4gaS5sZW5ndGg+MD9XKGZlKHMsaSksbi5zaGFwZSk6c30sYjooKT0+e2xldCBzPXooZSxyZShuLFwiZmxvYXQzMlwiKSksaT1CdChhLnNoYXBlLHIpO3JldHVybiBpLmxlbmd0aD4wP1coZmUocyxpKSxhLnNoYXBlKTpzfX19fSxOVT17a2VybmVsTmFtZTpDdSxncmFkRnVuYzplPT4oe3g6KCk9Pnl0KGUpfSl9LFRVPXtrZXJuZWxOYW1lOnlvLGlucHV0c1RvU2F2ZTpbXCJpbmRpY2VzXCJdLGdyYWRGdW5jOihlLHQpPT57bGV0IG49dFswXTtyZXR1cm57aW5kaWNlczooKT0+SXQobi5zaGFwZSxcImZsb2F0MzJcIil9fX0sQ1U9e2tlcm5lbE5hbWU6JHUsZ3JhZEZ1bmM6ZT0+KHt4OigpPT5xZShlKX0pfSxFVT17a2VybmVsTmFtZTpEdSxzYXZlQWxsSW5wdXRzOiEwLGdyYWRGdW5jOihlLHQsbik9PntsZXR7YXhpczphfT1uO3JldHVybiBkdChlLGEpLm1hcChyPT4oKT0+cil9fSxkST17a2VybmVsTmFtZTp4byxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0LG4pPT57bGV0IGE9dFswXSx7cGFkZGluZ3M6cn09bixzPXIubWFwKGk9PmlbMF0pO3JldHVybnt4OigpPT5WZShlLHMsYS5zaGFwZSl9fX0sX1U9e2tlcm5lbE5hbWU6dm8saW5wdXRzVG9TYXZlOltcImFcIixcImJcIl0sb3V0cHV0c1RvU2F2ZTpbITBdLGdyYWRGdW5jOihlLHQpPT57bGV0W24sYSxyXT10LHM9bixpPWEsbz1jdChzLnNoYXBlLGkuc2hhcGUpO3JldHVybnthOigpPT57bGV0IGw9cmUoaSxcImZsb2F0MzJcIiksdT16KGUseihsLHVyKHMscGUobCx4ZSgxKSkpKSkscD1CdChzLnNoYXBlLG8pO3JldHVybiBwLmxlbmd0aD4wJiYodT1mZSh1LHApKSxXKHUscy5zaGFwZSl9LGI6KCk9PntsZXQgbD1DbihzLDApLHU9bm4obCxRbihzKSxxZShzKSkscD16KGUseihyLHUpKSxkPUJ0KGkuc2hhcGUsbyk7cmV0dXJuIGQubGVuZ3RoPjAmJihwPWZlKHAsZCkpLFcocCxpLnNoYXBlKX19fX0sQVU9e2tlcm5lbE5hbWU6d28saW5wdXRzVG9TYXZlOltcInhcIixcImFscGhhXCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W24sYV09dCxyPUNuKG4sMCk7cmV0dXJue3g6KCk9Pm5uKHIsZSx6KGUsYSkpLGFscGhhOigpPT57bGV0IHM9bm4ocixxZShlKSx6KGUsbikpLGk9QnQoYS5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gaS5sZW5ndGg+MCYmKHM9ZmUocyxpKSksVyhzLGEuc2hhcGUpfX19fTtmdW5jdGlvbiBGVShlLHQsbil7bGV0IGE9ZS5zaGFwZS5zbGljZSgpO2Fbbl09MTtsZXQgcj1XKHQsYSkscz13YyhlLG4sITAsITEpLGk9d2MoZSxuLCEwLCEwKSxvPXoocyxpKTtyZXR1cm4geihyLG8pfWZ1bmN0aW9uICRVKGUsdCxuKXtsZXQgYT1lLnNoYXBlLmxlbmd0aCxyPWEtbi5sZW5ndGgscz1ULmdldEF4ZXNQZXJtdXRhdGlvbihuLGEpLGk9ZTtzIT1udWxsJiYoaT1EZShlLHMpKTtsZXQgbz1pLnNoYXBlLnNsaWNlKCksbD1vLnNwbGljZShhLW4ubGVuZ3RoLG4ubGVuZ3RoKS5yZWR1Y2UoKGQsYyk9PmQqYywxKTtvLnB1c2gobCk7bGV0IHU9aS5yZXNoYXBlKG8pLHA9RlUodSx0LHIpO2lmKHA9cC5yZXNoYXBlKGkuc2hhcGUpLHMhPW51bGwpe2xldCBkPVQuZ2V0VW5kb0F4ZXNQZXJtdXRhdGlvbihzKTtwPURlKHAsZCl9cmV0dXJuIHB9dmFyIERVPXtrZXJuZWxOYW1lOmtvLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQsbik9PntsZXRbYV09dCx7YXhpczpyfT1uLHM9W107cmV0dXJuIHI9PW51bGw/cz1hLnNoYXBlLm1hcCgoaSxvKT0+byk6dHlwZW9mIHI9PVwibnVtYmVyXCI/cz1bcl06cz1yLHt4OigpPT4kVShhLGUscyl9fX0sUlU9e2tlcm5lbE5hbWU6SGksaW5wdXRzVG9TYXZlOltcImFcIixcImJcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbixhXT10LHI9Y3Qobi5zaGFwZSxhLnNoYXBlKTtyZXR1cm57YTooKT0+e2xldCBzPWhlKGUscmUoYSxcImZsb2F0MzJcIikpLGk9QnQobi5zaGFwZSxyKTtyZXR1cm4gaS5sZW5ndGg+MD9XKGZlKHMsaSksbi5zaGFwZSk6c30sYjooKT0+e2xldCBzPXooZSxyZShuLFwiZmxvYXQzMlwiKSksaT1CdChhLnNoYXBlLHIpO2kubGVuZ3RoPjAmJihzPVcoZmUocyxpKSxhLnNoYXBlKSk7bGV0IG89cHQoYSk7cmV0dXJuIHl0KGhlKHMscmUobyxcImZsb2F0MzJcIikpKX19fX0sTVU9e2tlcm5lbE5hbWU6SW8saW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+aGUoZSx5dChwdChuKSkpfX19LE9VPXtrZXJuZWxOYW1lOkNvLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W25dPXQsYT16KENzKG4sNiksam8obikpO3JldHVybnt4OigpPT56KGUscmUoYSxcImZsb2F0MzJcIikpfX19LFBVPXtrZXJuZWxOYW1lOlNvLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W25dPXQ7cmV0dXJue3g6KCk9PnooZSxyZShqbyhuKSxcImZsb2F0MzJcIikpfX19LExVPXtrZXJuZWxOYW1lOlJ1LGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W25dPXQ7cmV0dXJue3g6KCk9PlcoZSxuLnNoYXBlKX19fSx6VT17a2VybmVsTmFtZTpUbyxpbnB1dHNUb1NhdmU6W1wiaW1hZ2VzXCJdLGdyYWRGdW5jOihlLHQsbik9PntsZXRbYV09dCxyPXtkeTplLGltYWdlczphfTtyZXR1cm57aW1hZ2VzOigpPT5QLnJ1bktlcm5lbChPdSxyLG4pfX19LFdVPXtrZXJuZWxOYW1lOk5vLGlucHV0c1RvU2F2ZTpbXCJpbWFnZXNcIl0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldFthXT10LHI9e2R5OmUsaW1hZ2VzOmF9O3JldHVybntpbWFnZXM6KCk9PlAucnVuS2VybmVsKE11LHIsbil9fX0sQlU9e2tlcm5lbE5hbWU6RW8sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldHtkaW1zOmF9PW4scj1BYShhLGUuc2hhcGUpO3JldHVybnt4OigpPT5iYShlLHIpfX19LFZVPXtrZXJuZWxOYW1lOl9vLGdyYWRGdW5jOmU9Pih7eDooKT0+cWUoZSl9KX0sVVU9e2tlcm5lbE5hbWU6QW8saW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+eXQoaGUoZSx6KHVyKG4sMS41KSwyKSkpfX19LEdVPXtrZXJuZWxOYW1lOld1LGlucHV0c1RvU2F2ZTpbXCJjb25kaXRpb25cIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57Y29uZGl0aW9uOigpPT5yZShxZShuKSxcImZsb2F0MzJcIiksdDooKT0+eihlLHJlKG4sZS5kdHlwZSkpLGU6KCk9PnooZSxyZShkZChuKSxlLmR0eXBlKSl9fX0sSFU9e2tlcm5lbE5hbWU6Rm8saW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+e2xldCBhPUNuKG4seGUoMCkpLHI9eGUobjIpLHM9eGUoYTIpLGk9eihlLHMpLG89eih6KGUsciksZG4ocmUobixcImZsb2F0MzJcIikpKTtyZXR1cm4gbm4oYSxpLG8pfX19fSxqVT17a2VybmVsTmFtZTpNbyxvdXRwdXRzVG9TYXZlOlshMF0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+eihlLHoobixwZSh4ZSgxKSxuKSkpfX19LHFVPXtrZXJuZWxOYW1lOlJvLGdyYWRGdW5jOmU9Pih7eDooKT0+cWUoZSl9KX0sS1U9e2tlcm5lbE5hbWU6JG8saW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+eihvZChyZShuLFwiZmxvYXQzMlwiKSksZSl9fX0sWFU9e2tlcm5lbE5hbWU6RG8saW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+eihCbShyZShuLFwiZmxvYXQzMlwiKSksZSl9fX0sWVU9e2tlcm5lbE5hbWU6QnUsaW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldFthXT10LHtiZWdpbjpyLHNpemU6c309bixpPWEuc2hhcGUsW28sbF09ZTIoYSxyLHMpLHU9W107Zm9yKGxldCBwPTA7cDxlLnJhbms7cCsrKXUucHVzaChbb1twXSxpW3BdLW9bcF0tbFtwXV0pO3JldHVybnt4OigpPT54YShlLHUpfX19LFpVPXtrZXJuZWxOYW1lOnpvLG91dHB1dHNUb1NhdmU6WyEwXSxncmFkRnVuYzooZSx0LG4pPT57bGV0W2FdPXQse2RpbTpyfT1uLHM9ITAsaT16KGUsYSk7cmV0dXJue2xvZ2l0czooKT0+cGUoaSx6KGZlKGksW3JdLHMpLGEpKX19fSxKVT17a2VybmVsTmFtZTpPbyxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuXT10O3JldHVybnt4OigpPT56KGUsaGEobikpfX19LGhJPXtrZXJuZWxOYW1lOlZ1LGdyYWRGdW5jOihlLHQsbik9PntsZXR7YmxvY2tTaGFwZTphLHBhZGRpbmdzOnJ9PW47cmV0dXJue3g6KCk9PmlkKGUsYSxyKX19fSxtST17a2VybmVsTmFtZTpVdSxncmFkRnVuYzooZSx0LG4pPT57bGV0e2F4aXM6YX09bjtyZXR1cm57eDooKT0+ZXQoZSxhKX19fSxRVT17a2VybmVsTmFtZTpQbyxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuXT10O3JldHVybnt4OigpPT5oZShlLHoocm4ocmUobixcImZsb2F0MzJcIikpLDIpKX19fSxlRz17a2VybmVsTmFtZTpxYyxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuXT10O3JldHVybnt4OigpPT56KGUseihyZShuLFwiZmxvYXQzMlwiKSwyKSl9fX0sdEc9e2tlcm5lbE5hbWU6V28saW5wdXRzVG9TYXZlOltcImFcIixcImJcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbixhXT10LHI9eGUoMik7cmV0dXJue2E6KCk9PnooZSx6KHIscGUobixhKSkpLGI6KCk9PnooZSx6KHIscGUoYSxuKSkpfX19LG5HPXtrZXJuZWxOYW1lOklzLGdyYWRGdW5jOmU9Pih7eDooKT0+cWUoZSl9KX0sYUc9e2tlcm5lbE5hbWU6Qm8saW5wdXRzVG9TYXZlOltcImFcIixcImJcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbixhXT10LHI9Y3Qobi5zaGFwZSxhLnNoYXBlKTtyZXR1cm57YTooKT0+e2xldCBzPWUsaT1CdChuLnNoYXBlLHIpO3JldHVybiBpLmxlbmd0aD4wJiYocz1mZShzLGkpKSxXKHMsbi5zaGFwZSl9LGI6KCk9PntsZXQgcz1lLGk9QnQoYS5zaGFwZSxyKTtyZXR1cm4gaS5sZW5ndGg+MCYmKHM9ZmUocyxpKSksVyh5dChzKSxhLnNoYXBlKX19fX0sckc9e2tlcm5lbE5hbWU6TG8saW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldFthXT10LHI9YS5zaGFwZS5zbGljZSgpLHtheGlzOnN9PW47QWEocyxhLnNoYXBlKS5mb3JFYWNoKGw9PntyW2xdPTF9KTtsZXQgaT1XKGUsciksbz16KGksUG4oYS5zaGFwZSxcImZsb2F0MzJcIikpO3JldHVybnt4OigpPT5vfX19LHNHPXtrZXJuZWxOYW1lOlZvLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W25dPXQ7cmV0dXJue3g6KCk9PmhlKGUscHQob2QobikpKX19fSxpRz17a2VybmVsTmFtZTpVbyxvdXRwdXRzVG9TYXZlOlshMF0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+eihwZSh4ZSgxKSxwdChuKSksZSl9fX0sb0c9e2tlcm5lbE5hbWU6a3MsaW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldFthXT10LHtyZXBzOnJ9PW47cmV0dXJue3g6KCk9PntsZXQgcz1xZShhKTtpZihhLnJhbms9PT0xKWZvcihsZXQgaT0wO2k8clswXTsrK2kpcz1YKHMsVmUoZSxbaSphLnNoYXBlWzBdXSxbYS5zaGFwZVswXV0pKTtlbHNlIGlmKGEucmFuaz09PTIpZm9yKGxldCBpPTA7aTxyWzBdOysraSlmb3IobGV0IG89MDtvPHJbMV07KytvKXM9WChzLFZlKGUsW2kqYS5zaGFwZVswXSxvKmEuc2hhcGVbMV1dLFthLnNoYXBlWzBdLGEuc2hhcGVbMV1dKSk7ZWxzZSBpZihhLnJhbms9PT0zKWZvcihsZXQgaT0wO2k8clswXTsrK2kpZm9yKGxldCBvPTA7bzxyWzFdOysrbylmb3IobGV0IGw9MDtsPHJbMl07KytsKXM9WChzLFZlKGUsW2kqYS5zaGFwZVswXSxvKmEuc2hhcGVbMV0sbCphLnNoYXBlWzJdXSxbYS5zaGFwZVswXSxhLnNoYXBlWzFdLGEuc2hhcGVbMl1dKSk7ZWxzZSBpZihhLnJhbms9PT00KWZvcihsZXQgaT0wO2k8clswXTsrK2kpZm9yKGxldCBvPTA7bzxyWzFdOysrbylmb3IobGV0IGw9MDtsPHJbMl07KytsKWZvcihsZXQgdT0wO3U8clszXTsrK3Upcz1YKHMsVmUoZSxbaSphLnNoYXBlWzBdLG8qYS5zaGFwZVsxXSxsKmEuc2hhcGVbMl0sdSphLnNoYXBlWzNdXSxbYS5zaGFwZVswXSxhLnNoYXBlWzFdLGEuc2hhcGVbMl0sYS5zaGFwZVszXV0pKTtlbHNlIHRocm93IG5ldyBFcnJvcihgR3JhZGllbnQgZm9yIHRpbGUgb3BlcmF0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgcmFuay0ke2EucmFua30gdGVuc29ycyB5ZXQuYCk7cmV0dXJuIHN9fX19LGxHPXtrZXJuZWxOYW1lOkNyLGdyYWRGdW5jOihlLHQsbik9PntsZXQgYT1uLHtwZXJtOnJ9PWEscz1wdyhyKTtyZXR1cm57eDooKT0+RGUoZSxzKX19fSx1Rz17a2VybmVsTmFtZTpYdSxncmFkRnVuYzooZSx0LG4pPT57bGV0IGE9bix7YXhpczpyfT1hO3JldHVybnt2YWx1ZTooKT0+QXQoZSxyKX19fSxwRz17a2VybmVsTmFtZTpRYyxpbnB1dHNUb1NhdmU6W1wic2VnbWVudElkc1wiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuXT10O3JldHVybnt4OigpPT5jRyhlLG4pfX19O2Z1bmN0aW9uIGNHKGUsdCl7bGV0IG49aHIodCxxZSh0KSksYT1ucChlLG4pLHI9JHIodCx4ZSgwLFwiaW50MzJcIikpLHM9YS5yYW5rLXIucmFuaztmb3IobGV0IG89MDtvPHM7KytvKXI9R3QocixvKzEpO3I9X2EocixQbihhLnNoYXBlLFwiYm9vbFwiKSk7bGV0IGk9cWUoYSk7cmV0dXJuIG5uKHIsYSxpKX12YXIgZEc9e2tlcm5lbE5hbWU6WXUsZ3JhZEZ1bmM6ZT0+KHt4OigpPT5xZShlKX0pfSxoRz1bczIscFYsY1YsZFYsaFYsbVYsZlYsZ1YsYlYseVYseFYsdlYsSVYsVFYsQ1YsRVYsX1YsQVYsRlYsJFYsRFYsUlYsT1YsTVYselYsV1YsQlYsVlYsVVYsR1YsUlUsSFYsalYscVYsS1YsWFYsWlYsWVYsSlYsUVYsZVUsdFUsblUsYVUsclUsc1UsaVUsb1UsbFUsY1UsY0ksY0ksZFUsZlUseVUseFUsdlUsd1Usa1UsSVUsU1UsTlUsVFUsQ1UsRVUsZEksZEksX1UsQVUsRFUsTVUsT1UsUFUsTFUselUsV1UsQlUsVlUsVVUsR1UsSFUsalUscVUsS1UsWFUsWVUsWlUsSlUsaEksaEksbUksbUksUVUsdEcsZUcsbkcsYUcsckcsc0csaUcsb0csbEcsdUcscEcsZEddO2ZvcihsZXQgZSBvZiBoRylLUyhlKTtRKCkucHJvdG90eXBlLmFicz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLEx0KHRoaXMpfTtRKCkucHJvdG90eXBlLmFjb3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxQdih0aGlzKX07USgpLnByb3RvdHlwZS5hY29zaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLEx2KHRoaXMpfTtRKCkucHJvdG90eXBlLmFkZD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxYKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUuYWxsPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksTG0odGhpcyxlLHQpfTtRKCkucHJvdG90eXBlLmFueT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHljKHRoaXMsZSx0KX07USgpLnByb3RvdHlwZS5hcmdNYXg9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksZGkodGhpcyxlKX07USgpLnByb3RvdHlwZS5hcmdNaW49ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksenYodGhpcyxlKX07USgpLnByb3RvdHlwZS5hc1NjYWxhcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLEEodGhpcy5zaXplPT09MSwoKT0+XCJUaGUgYXJyYXkgbXVzdCBoYXZlIG9ubHkgMSBlbGVtZW50LlwiKSxXKHRoaXMsW10pfTtRKCkucHJvdG90eXBlLmFzVHlwZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxyZSh0aGlzLGUpfTtRKCkucHJvdG90eXBlLmFzMUQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxXKHRoaXMsW3RoaXMuc2l6ZV0pfTtRKCkucHJvdG90eXBlLmFzMkQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxXKHRoaXMsW2UsdF0pfTtRKCkucHJvdG90eXBlLmFzM0Q9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFcodGhpcyxbZSx0LG5dKX07USgpLnByb3RvdHlwZS5hczREPWZ1bmN0aW9uKGUsdCxuLGEpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFcodGhpcyxbZSx0LG4sYV0pfTtRKCkucHJvdG90eXBlLmFzNUQ9ZnVuY3Rpb24oZSx0LG4sYSxyKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxXKHRoaXMsW2UsdCxuLGEscl0pfTtRKCkucHJvdG90eXBlLmFzaW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxXdih0aGlzKX07USgpLnByb3RvdHlwZS5hc2luaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLEJ2KHRoaXMpfTtRKCkucHJvdG90eXBlLmF0YW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxWdih0aGlzKX07USgpLnByb3RvdHlwZS5hdGFuMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxVdih0aGlzLGUpfTtRKCkucHJvdG90eXBlLmF0YW5oPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksR3YodGhpcyl9O1EoKS5wcm90b3R5cGUuYXZnUG9vbD1mdW5jdGlvbihlLHQsbixhKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx5YSh0aGlzLGUsdCxuLGEpfTtRKCkucHJvdG90eXBlLmJhdGNoVG9TcGFjZU5EPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaWQodGhpcyxlLHQpfTtRKCkucHJvdG90eXBlLmJhdGNoTm9ybT1mdW5jdGlvbihlLHQsbixhLHIpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLE5zKHRoaXMsZSx0LG4sYSxyKX07USgpLnByb3RvdHlwZS5icm9hZGNhc3RUbz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxhaSh0aGlzLGUpfTtRKCkucHJvdG90eXBlLmNhc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkscmUodGhpcyxlKX07USgpLnByb3RvdHlwZS5jZWlsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksWnYodGhpcyl9O1EoKS5wcm90b3R5cGUuY2xpcEJ5VmFsdWU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxhbih0aGlzLGUsdCl9O1EoKS5wcm90b3R5cGUuY29uY2F0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksZSBpbnN0YW5jZW9mIENlJiYoZT1bZV0pLGV0KFt0aGlzLC4uLmVdLHQpfTtRKCkucHJvdG90eXBlLmNvbnYxZD1mdW5jdGlvbihlLHQsbixhLHIscyl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksem0odGhpcyxlLHQsbixhLHIscyl9O1EoKS5wcm90b3R5cGUuY29udjJkVHJhbnNwb3NlPWZ1bmN0aW9uKGUsdCxuLGEscil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksV20odGhpcyxlLHQsbixhLHIpfTtRKCkucHJvdG90eXBlLmNvbnYyZD1mdW5jdGlvbihlLHQsbixhLHIscyl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksJHQodGhpcyxlLHQsbixhLHIscyl9O1EoKS5wcm90b3R5cGUuY29zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksb2QodGhpcyl9O1EoKS5wcm90b3R5cGUuY29zaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLEJtKHRoaXMpfTtRKCkucHJvdG90eXBlLmN1bXByb2Q9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHdjKHRoaXMsZSx0LG4pfTtRKCkucHJvdG90eXBlLmN1bXN1bT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksVm0odGhpcyxlLHQsbil9O1EoKS5wcm90b3R5cGUuZGVwdGhUb1NwYWNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksc3codGhpcyxlLHQpfTtRKCkucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyZD1mdW5jdGlvbihlLHQsbixhLHIscyl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksVHModGhpcyxlLHQsbixhLHIscyl9O1EoKS5wcm90b3R5cGUuZGlsYXRpb24yZD1mdW5jdGlvbihlLHQsbixhLHIpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGl3KHRoaXMsZSx0LG4sYSxyKX07USgpLnByb3RvdHlwZS5kaXZOb05hbj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvdyh0aGlzLGUpfTtRKCkucHJvdG90eXBlLmRpdj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxoZSh0aGlzLGUpfTtRKCkucHJvdG90eXBlLmRvdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxsdyh0aGlzLGUpfTtRKCkucHJvdG90eXBlLmVsdT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFF1KHRoaXMpfTtRKCkucHJvdG90eXBlLmVxdWFsPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLEpuKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUuZXJmPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksVW0odGhpcyl9O1EoKS5wcm90b3R5cGUuZXVjbGlkZWFuTm9ybT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGN3KHRoaXMsZSx0KX07USgpLnByb3RvdHlwZS5leHA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxkbih0aGlzKX07USgpLnByb3RvdHlwZS5leHBhbmREaW1zPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLEd0KHRoaXMsZSl9O1EoKS5wcm90b3R5cGUuZXhwbTE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxkdyh0aGlzKX07USgpLnByb3RvdHlwZS5mZnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxiZCh0aGlzKX07USgpLnByb3RvdHlwZS5mbGF0dGVuPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksVyh0aGlzLFt0aGlzLnNpemVdKX07USgpLnByb3RvdHlwZS5mbG9vcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRwKHRoaXMpfTtRKCkucHJvdG90eXBlLmZsb29yRGl2PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFBtKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUuZ2F0aGVyPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxucCh0aGlzLGUsdCxuKX07USgpLnByb3RvdHlwZS5ncmVhdGVyRXF1YWw9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksJHIodGhpcyxlKX07USgpLnByb3RvdHlwZS5ncmVhdGVyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLENuKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUuaWZmdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLEJsKHRoaXMpfTtRKCkucHJvdG90eXBlLmlyZmZ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksYWYodGhpcyl9O1EoKS5wcm90b3R5cGUuaXNGaW5pdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxodyh0aGlzKX07USgpLnByb3RvdHlwZS5pc0luZj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG13KHRoaXMpfTtRKCkucHJvdG90eXBlLmlzTmFOPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksZncodGhpcyl9O1EoKS5wcm90b3R5cGUubGVha3lSZWx1PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHVkKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUubGVzc0VxdWFsPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLENzKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUubGVzcz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxQbCh0aGlzLGUpfTtRKCkucHJvdG90eXBlLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uPWZ1bmN0aW9uKGUsdCxuLGEpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGd3KHRoaXMsZSx0LG4sYSl9O1EoKS5wcm90b3R5cGUubG9nU2lnbW9pZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGJ3KHRoaXMpfTtRKCkucHJvdG90eXBlLmxvZ1NvZnRtYXg9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksam0odGhpcyxlKX07USgpLnByb3RvdHlwZS5sb2dTdW1FeHA9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxjZCh0aGlzLGUsdCl9O1EoKS5wcm90b3R5cGUubG9nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksUW4odGhpcyl9O1EoKS5wcm90b3R5cGUubG9nMXA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxwZCh0aGlzKX07USgpLnByb3RvdHlwZS5sb2dpY2FsQW5kPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLF9hKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUubG9naWNhbE5vdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGRkKHRoaXMpfTtRKCkucHJvdG90eXBlLmxvZ2ljYWxPcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxxbSh0aGlzLGUpfTtRKCkucHJvdG90eXBlLmxvZ2ljYWxYb3I9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseXcodGhpcyxlKX07USgpLnByb3RvdHlwZS5tYXRNdWw9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLCRlKHRoaXMsZSx0LG4pfTtRKCkucHJvdG90eXBlLm1heFBvb2w9ZnVuY3Rpb24oZSx0LG4sYSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksRHQodGhpcyxlLHQsbixhKX07USgpLnByb3RvdHlwZS5tYXg9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxtYSh0aGlzLGUsdCl9O1EoKS5wcm90b3R5cGUubWF4aW11bT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxocih0aGlzLGUpfTtRKCkucHJvdG90eXBlLm1lYW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxDdCh0aGlzLGUsdCl9O1EoKS5wcm90b3R5cGUubWluPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksT2wodGhpcyxlLHQpfTtRKCkucHJvdG90eXBlLm1pbmltdW09ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksZHModGhpcyxlKX07USgpLnByb3RvdHlwZS5taXJyb3JQYWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx2dyh0aGlzLGUsdCl9O1EoKS5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHd3KHRoaXMsZSl9O1EoKS5wcm90b3R5cGUubXVsPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHoodGhpcyxlKX07USgpLnByb3RvdHlwZS5uZWc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx5dCh0aGlzKX07USgpLnByb3RvdHlwZS5ub3JtPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxlcCh0aGlzLGUsdCxuKX07USgpLnByb3RvdHlwZS5ub3RFcXVhbD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxmaSh0aGlzLGUpfTtRKCkucHJvdG90eXBlLm9uZUhvdD1mdW5jdGlvbihlLHQ9MSxuPTApe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLExsKHRoaXMsZSx0LG4pfTtRKCkucHJvdG90eXBlLm9uZXNMaWtlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksZWEodGhpcyl9O1EoKS5wcm90b3R5cGUucGFkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseGEodGhpcyxlLHQpfTtRKCkucHJvdG90eXBlLnBvb2w9ZnVuY3Rpb24oZSx0LG4sYSxyLHMpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGt3KHRoaXMsZSx0LG4sYSxyLHMpfTtRKCkucHJvdG90eXBlLnBvdz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx1cih0aGlzLGUpfTtRKCkucHJvdG90eXBlLnByZWx1PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGZkKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUucHJvZD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLEl3KHRoaXMsZSx0KX07USgpLnByb3RvdHlwZS5yZWNpcHJvY2FsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksRXcodGhpcyl9O1EoKS5wcm90b3R5cGUucmVsdT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLEtlKHRoaXMpfTtRKCkucHJvdG90eXBlLnJlbHU2PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksWW0odGhpcyl9O1EoKS5wcm90b3R5cGUucmVzaGFwZUFzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFcodGhpcyxlLnNoYXBlKX07USgpLnByb3RvdHlwZS5yZXNoYXBlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFcodGhpcyxlKX07USgpLnByb3RvdHlwZS5yZXNpemVCaWxpbmVhcj1mdW5jdGlvbihlLHQsbil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksQ1QodGhpcyxlLHQsbil9O1EoKS5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxFVCh0aGlzLGUsdCxuKX07USgpLnByb3RvdHlwZS5yZXZlcnNlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGJhKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUucmZmdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHlkKHRoaXMpfTtRKCkucHJvdG90eXBlLnJvdW5kPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksWm0odGhpcyl9O1EoKS5wcm90b3R5cGUucnNxcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxKbSh0aGlzKX07USgpLnByb3RvdHlwZS5zZWx1PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksUW0odGhpcyl9O1EoKS5wcm90b3R5cGUuc2VwYXJhYmxlQ29udjJkPWZ1bmN0aW9uKGUsdCxuLGEscixzKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxfcyh0aGlzLGUsdCxuLGEscixzKX07USgpLnByb3RvdHlwZS5zaWdtb2lkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaGEodGhpcyl9O1EoKS5wcm90b3R5cGUuc2lnbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLF93KHRoaXMpfTtRKCkucHJvdG90eXBlLnNpbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGVmKHRoaXMpfTtRKCkucHJvdG90eXBlLnNpbmg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0Zih0aGlzKX07USgpLnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFZlKHRoaXMsZSx0KX07USgpLnByb3RvdHlwZS5zb2Z0bWF4PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHFhKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUuc29mdHBsdXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxHbyh0aGlzKX07USgpLnByb3RvdHlwZS5zcGFjZVRvQmF0Y2hORD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG1kKHRoaXMsZSx0KX07USgpLnByb3RvdHlwZS5zcGxpdD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLExuKHRoaXMsZSx0KX07USgpLnByb3RvdHlwZS5zcXJ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkscm4odGhpcyl9O1EoKS5wcm90b3R5cGUuc3F1YXJlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkscHQodGhpcyl9O1EoKS5wcm90b3R5cGUuc3F1YXJlZERpZmZlcmVuY2U9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkscmYodGhpcyxlKX07USgpLnByb3RvdHlwZS5zcXVlZXplPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLEFzKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUuc3RhY2s9ZnVuY3Rpb24oZSx0KXt0aGlzLnRocm93SWZEaXNwb3NlZCgpO2xldCBuPWUgaW5zdGFuY2VvZiBDZT9bdGhpcyxlXTpbdGhpcywuLi5lXTtyZXR1cm4gQXQobix0KX07USgpLnByb3RvdHlwZS5zdGVwPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGpvKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUuc3RyaWRlZFNsaWNlPWZ1bmN0aW9uKGUsdCxuLGEscixzLGksbyl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksQXcodGhpcyxlLHQsbixhLHIscyxpLG8pfTtRKCkucHJvdG90eXBlLnN1Yj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxwZSh0aGlzLGUpfTtRKCkucHJvdG90eXBlLnN1bT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGZlKHRoaXMsZSx0KX07USgpLnByb3RvdHlwZS50YW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxGdyh0aGlzKX07USgpLnByb3RvdHlwZS50YW5oPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksY3ModGhpcyl9O1EoKS5wcm90b3R5cGUudGlsZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxPbih0aGlzLGUpfTtRKCkucHJvdG90eXBlLnRvQm9vbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHJlKHRoaXMsXCJib29sXCIpfTtRKCkucHJvdG90eXBlLnRvRmxvYXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxyZSh0aGlzLFwiZmxvYXQzMlwiKX07USgpLnByb3RvdHlwZS50b0ludD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHJlKHRoaXMsXCJpbnQzMlwiKX07USgpLnByb3RvdHlwZS50b3BrPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksRHcodGhpcyxlLHQpfTtRKCkucHJvdG90eXBlLnRyYW5zcG9zZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxEZSh0aGlzLGUpfTtRKCkucHJvdG90eXBlLnVuaXF1ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxSdyh0aGlzLGUpfTtRKCkucHJvdG90eXBlLnVuc29ydGVkU2VnbWVudFN1bT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHVmKHRoaXMsZSx0KX07USgpLnByb3RvdHlwZS51bnN0YWNrPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGR0KHRoaXMsZSl9O1EoKS5wcm90b3R5cGUud2hlcmU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxubihlLHRoaXMsdCl9O1EoKS5wcm90b3R5cGUuemVyb3NMaWtlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkscWUodGhpcyl9O3ZhciBYcj1jbGFzcyBvMiBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLG8yLnByb3RvdHlwZSl9fSxhcj1jbGFzcyBsMiBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLGwyLnByb3RvdHlwZSl9fSxWPWNsYXNzIHUyIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IodCl7c3VwZXIodCksT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsdTIucHJvdG90eXBlKX19LHplPWNsYXNzIHAyIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IodCl7c3VwZXIodCksT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMscDIucHJvdG90eXBlKX19LG1HPWNsYXNzIGMyIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IodCl7c3VwZXIodCksT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsYzIucHJvdG90eXBlKX19LGQyPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMubWF4RW50cmllcz1lfHwxMDAsdGhpcy5jYWNoZT1uZXcgTWFwfWdldChlKXtsZXQgdDtyZXR1cm4gdGhpcy5jYWNoZS5oYXMoZSkmJih0PXRoaXMuY2FjaGUuZ2V0KGUpLHRoaXMuY2FjaGUuZGVsZXRlKGUpLHRoaXMuY2FjaGUuc2V0KGUsdCkpLHR9cHV0KGUsdCl7aWYodGhpcy5jYWNoZS5oYXMoZSkpdGhpcy5jYWNoZS5kZWxldGUoZSk7ZWxzZSBpZih0aGlzLmNhY2hlLnNpemU+PXRoaXMubWF4RW50cmllcyl7bGV0IG49dGhpcy5jYWNoZS5rZXlzKCkubmV4dCgpLnZhbHVlO3RoaXMuY2FjaGUuZGVsZXRlKG4pfXRoaXMuY2FjaGUuc2V0KGUsdCl9Z2V0TWF4RW50cmllcygpe3JldHVybiB0aGlzLm1heEVudHJpZXN9c2V0TWF4RW50cmllcyhlKXtpZihlPDApdGhyb3cgbmV3IEVycm9yKGBUaGUgbWF4RW50cmllcyBvZiBMUlUgY2FjaGVzIG11c3QgYmUgYXQgbGVhc3QgMCwgYnV0IGdvdCAke2V9LmApO2lmKHRoaXMubWF4RW50cmllcz5lKWZvcihsZXQgdD0wO3Q8dGhpcy5tYXhFbnRyaWVzLWU7dCsrKXtsZXQgbj10aGlzLmNhY2hlLmtleXMoKS5uZXh0KCkudmFsdWU7dGhpcy5jYWNoZS5kZWxldGUobil9dGhpcy5tYXhFbnRyaWVzPWV9fTtmdW5jdGlvbiBiaShlLHQpe2lmKEFycmF5LmlzQXJyYXkoZSkpe2xldCBuPVtdO2ZvcihsZXQgYT0wO2E8dDthKyspbj1uLmNvbmNhdChlKTtyZXR1cm4gbn1lbHNle2xldCBuPW5ldyBBcnJheSh0KTtyZXR1cm4gbi5maWxsKGUpLG59fWZ1bmN0aW9uIHRyKGUsdCl7aWYoIWUpdGhyb3cgbmV3IG1HKHQpfWZ1bmN0aW9uIGZJKGUsdCl7bGV0IG49MDtmb3IobGV0IGEgb2YgZSlhPT09dCYmbisrO3JldHVybiBufWZ1bmN0aW9uIE1uKGUpe3JldHVybiBlLmxlbmd0aD09PTE/ZVswXTplfWZ1bmN0aW9uIGl0KGUpe3JldHVybiBBcnJheS5pc0FycmF5KGUpP2U6W2VdfWZ1bmN0aW9uIElyKGUpe2xldCB0PWUucmVwbGFjZSgvKC4pKFtBLVpdW2EtejAtOV0rKS9nLFwiJDFfJDJcIikucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZyxcIiQxXyQyXCIpLnRvTG93ZXJDYXNlKCk7cmV0dXJuIHRbMF0hPT1cIl9cIj90OlwicHJpdmF0ZVwiK3R9ZnVuY3Rpb24gSnMoZSl7cmV0dXJuIGUubGVuZ3RoPD0xfHxlLmluZGV4T2YoXCJfXCIpPT09LTE/ZTplLnJlcGxhY2UoL1tfXSsoXFx3fCQpL2csKHQsbik9Pm4udG9VcHBlckNhc2UoKSl9dmFyIFNhPXt9O2Z1bmN0aW9uIFF3KGUpe2lmKGU9PW51bGwpcmV0dXJuIG51bGw7bGV0IHQ9e307cmV0dXJuIHQuY2xhc3NOYW1lPWUuZ2V0Q2xhc3NOYW1lKCksdC5jb25maWc9ZS5nZXRDb25maWcoKSx0fWZ1bmN0aW9uIHp4KGUpe2lmKCEoZT09bnVsbHx8dHlwZW9mIGUhPVwib2JqZWN0XCIpKWlmKEFycmF5LmlzQXJyYXkoZSkpZS5mb3JFYWNoKHQ9Pnp4KHQpKTtlbHNle2xldCB0PU9iamVjdC5rZXlzKGUpO2ZvcihsZXQgbiBvZiB0KXtsZXQgYT1lW25dO2EhPW51bGwmJnR5cGVvZiBhPT1cIm9iamVjdFwiJiYoIUFycmF5LmlzQXJyYXkoYSkmJmEudHlwZT09PVwibmRhcnJheVwiJiZ0eXBlb2YgYS52YWx1ZT09XCJudW1iZXJcIj9lW25dPWEudmFsdWU6engoYSkpfX19ZnVuY3Rpb24gdmQoZSx0PXt9LG49e30sYT1cIm9iamVjdFwiLHI9ITEpe2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiKXtsZXQgcz1lLGk7aWYocyBpbiBuKWk9bltzXTtlbHNlIGlmKHMgaW4gU2EpaT1TYVtzXTtlbHNlIGlmKGk9dFtzXSxpPT1udWxsKXRocm93IG5ldyBWKGBVbmtub3duICR7YX06ICR7ZX0uIFRoaXMgbWF5IGJlIGR1ZSB0byBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxuMS4gVGhlICR7YX0gaXMgZGVmaW5lZCBpbiBQeXRob24sIGluIHdoaWNoIGNhc2UgaXQgbmVlZHMgdG8gYmUgcG9ydGVkIHRvIFRlbnNvckZsb3cuanMgb3IgeW91ciBKYXZhU2NyaXB0IGNvZGUuXG4yLiBUaGUgY3VzdG9tICR7YX0gaXMgZGVmaW5lZCBpbiBKYXZhU2NyaXB0LCBidXQgaXMgbm90IHJlZ2lzdGVyZWQgcHJvcGVybHkgd2l0aCB0Zi5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoKS5gKTtyZXR1cm4gaX1lbHNle2xldCBzPWU7aWYocy5jbGFzc05hbWU9PW51bGx8fHMuY29uZmlnPT1udWxsKXRocm93IG5ldyBWKGAke2F9OiBJbXByb3BlciBjb25maWcgZm9ybWF0OiAke0pTT04uc3RyaW5naWZ5KHMpfS5cbidjbGFzc05hbWUnIGFuZCAnY29uZmlnJyBtdXN0IHNldC5gKTtsZXQgaT1zLmNsYXNzTmFtZSxvLGw7aWYoaSBpbiBuP1tvLGxdPW5baV06aSBpbiBTYT9bbyxsXT1TYS5jbGFzc05hbWU6aSBpbiB0JiYoW28sbF09dFtpXSksbz09bnVsbCl0aHJvdyBuZXcgVihgVW5rbm93biAke2F9OiAke2l9LiBUaGlzIG1heSBiZSBkdWUgdG8gb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcbjEuIFRoZSAke2F9IGlzIGRlZmluZWQgaW4gUHl0aG9uLCBpbiB3aGljaCBjYXNlIGl0IG5lZWRzIHRvIGJlIHBvcnRlZCB0byBUZW5zb3JGbG93LmpzIG9yIHlvdXIgSmF2YVNjcmlwdCBjb2RlLlxuMi4gVGhlIGN1c3RvbSAke2F9IGlzIGRlZmluZWQgaW4gSmF2YVNjcmlwdCwgYnV0IGlzIG5vdCByZWdpc3RlcmVkIHByb3Blcmx5IHdpdGggdGYuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKCkuYCk7aWYobCE9bnVsbCl7bGV0IHU9e307Zm9yKGxldCBoIG9mIE9iamVjdC5rZXlzKFNhKSl1W2hdPVNhW2hdO2ZvcihsZXQgaCBvZiBPYmplY3Qua2V5cyhuKSl1W2hdPW5baF07bGV0IHA9cy5jb25maWc7cC5jdXN0b21PYmplY3RzPXU7bGV0IGQ9T2JqZWN0LmFzc2lnbih7fSxTYSk7Zm9yKGxldCBoIG9mIE9iamVjdC5rZXlzKG4pKVNhW2hdPW5baF07engocy5jb25maWcpO2xldCBjPWwobyxzLmNvbmZpZyxuLHIpO3JldHVybiBTYT1PYmplY3QuYXNzaWduKHt9LGQpLGN9ZWxzZXtsZXQgdT1PYmplY3QuYXNzaWduKHt9LFNhKTtmb3IobGV0IGQgb2YgT2JqZWN0LmtleXMobikpU2FbZF09bltkXTtsZXQgcD1uZXcgbyhzLmNvbmZpZyk7cmV0dXJuIFNhPU9iamVjdC5hc3NpZ24oe30sdSkscH19fWZ1bmN0aW9uIGZHKGUsdCl7cmV0dXJuIGU8dD8tMTplPnQ/MTowfWZ1bmN0aW9uIHdoKGUsdCl7cmV0dXJuLTEqZkcoZSx0KX1mdW5jdGlvbiBhcyhlKXtpZihlPT1udWxsKXJldHVybiBlO2xldCB0PVtdO2ZvcihsZXQgbiBvZiBlKXQuaW5kZXhPZihuKT09PS0xJiZ0LnB1c2gobik7cmV0dXJuIHR9ZnVuY3Rpb24gZ0coZSl7aWYoZT09bnVsbCl0aHJvdyBuZXcgVihgSW52YWxpZCB2YWx1ZSBpbiBvYmo6ICR7SlNPTi5zdHJpbmdpZnkoZSl9YCk7Zm9yKGxldCB0IGluIGUpaWYoZS5oYXNPd25Qcm9wZXJ0eSh0KSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBLbyhlLHQsbil7aWYobiE9bnVsbCYmZS5pbmRleE9mKG4pPDApdGhyb3cgbmV3IFYoYCR7bn0gaXMgbm90IGEgdmFsaWQgJHt0fS4gIFZhbGlkIHZhbHVlcyBhcmUgJHtlfSBvciBudWxsL3VuZGVmaW5lZC5gKX1mdW5jdGlvbiBlMChlLHQsbj0wLGE9MS8wKXtyZXR1cm4gdHIobj49MCksdHIoYT49biksQXJyYXkuaXNBcnJheShlKSYmZS5sZW5ndGg+PW4mJmUubGVuZ3RoPD1hJiZlLmV2ZXJ5KHI9PnR5cGVvZiByPT09dCl9ZnVuY3Rpb24gdG4oZSx0KXtBcnJheS5pc0FycmF5KGUpPyh3LmFzc2VydChlLmxlbmd0aD4wLCgpPT5gJHt0fSBpcyB1bmV4cGVjdGVkbHkgYW4gZW1wdHkgYXJyYXkuYCksZS5mb3JFYWNoKChuLGEpPT50bihuLGBlbGVtZW50ICR7YSsxfSBvZiAke3R9YCkpKTp3LmFzc2VydChOdW1iZXIuaXNJbnRlZ2VyKGUpJiZlPjAsKCk9PmBFeHBlY3RlZCAke3R9IHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGdvdCAke2gyKGUpfS5gKX1mdW5jdGlvbiBoMihlKXtyZXR1cm4gZT09PW51bGw/XCJudWxsXCI6QXJyYXkuaXNBcnJheShlKT9cIltcIitlLm1hcCh0PT5oMih0KSkuam9pbihcIixcIikrXCJdXCI6dHlwZW9mIGU9PVwic3RyaW5nXCI/YFwiJHtlfVwiYDpgJHtlfWB9ZnVuY3Rpb24gYkcoZSx0LG4pe2xldCBhPW4hPW51bGw/bigpOncubm93KCkscjtyZXR1cm4oLi4ucyk9PntsZXQgaT1uIT1udWxsP24oKTp3Lm5vdygpO3JldHVybiBpLWE8dHx8KGE9aSxyPWUoLi4ucykpLHJ9fWZ1bmN0aW9uIG0yKGUpe3JldHVybiBlPT09XCJyZWx1XCI/XCJyZWx1XCI6ZT09PVwibGluZWFyXCI/XCJsaW5lYXJcIjplPT09XCJlbHVcIj9cImVsdVwiOm51bGx9dmFyIHlHPTA7ZnVuY3Rpb24gZjIoKXtyZXR1cm4geUcrK312YXIga2g9e307ZnVuY3Rpb24gZ2YoZT1cIlwiKXtyZXR1cm4gZSBpbiBraHx8KGtoW2VdPTApLGtoW2VdKz0xLGUra2hbZV0udG9TdHJpbmcoKX12YXIgeEc9W1wiY2hhbm5lbHNGaXJzdFwiLFwiY2hhbm5lbHNMYXN0XCJdLHZHPVtcIm5lYXJlc3RcIixcImJpbGluZWFyXCJdLHdHPVtcInZhbGlkXCIsXCJzYW1lXCIsXCJjYXVzYWxcIl0sa0c9W1wibWF4XCIsXCJhdmdcIl0sSUc9W1wic3VtXCIsXCJtdWxcIixcImNvbmNhdFwiLFwiYXZlXCJdLGtsPW5ldyBNYXA7ZnVuY3Rpb24gUnQoZSl7S28oeEcsXCJEYXRhRm9ybWF0XCIsZSl9ZnVuY3Rpb24gU0coZSl7S28odkcsXCJJbnRlcnBvbGF0aW9uRm9ybWF0XCIsZSl9ZnVuY3Rpb24gdmEoZSl7S28od0csXCJQYWRkaW5nTW9kZVwiLGUpfWZ1bmN0aW9uIGcyKGUpe0tvKGtHLFwiUG9vbE1vZGVcIixlKX12YXIgcGM9W10sZ0k9XCIvXCI7ZnVuY3Rpb24gcmkoZSx0KXtwYy5wdXNoKGUpO3RyeXtsZXQgbj10KCk7cmV0dXJuIHBjLnBvcCgpLG59Y2F0Y2gobil7dGhyb3cgcGMucG9wKCksbn19ZnVuY3Rpb24gTkcoKXtyZXR1cm4gcGMubGVuZ3RoPT09MD9cIlwiOnBjLmpvaW4oZ0kpK2dJfWZ1bmN0aW9uIGIyKGUpe2lmKCF4MihlKSl0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSB2YWxpZCB0ZW5zb3IgbmFtZTogJ1wiK2UrXCInXCIpO3JldHVybiBORygpK2V9ZnVuY3Rpb24geTIoZSl7aWYoIXgyKGUpKXRocm93IG5ldyBFcnJvcihcIk5vdCBhIHZhbGlkIHRlbnNvciBuYW1lOiAnXCIrZStcIidcIik7a2wuaGFzKGUpfHxrbC5zZXQoZSwwKTtsZXQgdD1rbC5nZXQoZSk7aWYoa2wuc2V0KGUsa2wuZ2V0KGUpKzEpLHQ+MCl7bGV0IG49YCR7ZX1fJHt0fWA7cmV0dXJuIGtsLnNldChuLDEpLG59ZWxzZSByZXR1cm4gZX12YXIgVEc9bmV3IFJlZ0V4cCgvXltBLVphLXowLTldWy1BLVphLXowLTlcXC5fXFwvXSokLyk7ZnVuY3Rpb24geDIoZSl7cmV0dXJuISFlLm1hdGNoKFRHKX1mdW5jdGlvbiBDRyhlKXtyZXR1cm4gZT09PXBhcnNlSW50KGUudG9TdHJpbmcoKSwxMCl9ZnVuY3Rpb24gcnMoZSx0LG4pe3Q9PW51bGwmJih0PTApLG49PW51bGwmJihuPWUubGVuZ3RoKTtsZXQgYT0xO2ZvcihsZXQgcj10O3I8bjsrK3IpYSo9ZVtyXTtyZXR1cm4gYX1mdW5jdGlvbiBVbChlKXtpZihlLmxlbmd0aD09PTApcmV0dXJuIE51bWJlci5OYU47bGV0IHQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXtsZXQgYT1lW25dO2E8dCYmKHQ9YSl9cmV0dXJuIHR9ZnVuY3Rpb24gaHMoZSl7aWYoZS5sZW5ndGg9PT0wKXJldHVybiBOdW1iZXIuTmFOO2xldCB0PU51bWJlci5ORUdBVElWRV9JTkZJTklUWTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyl7bGV0IGE9ZVtuXTthPnQmJih0PWEpfXJldHVybiB0fWZ1bmN0aW9uIFVhKGUsdCl7aWYodDxlKXRocm93IG5ldyBWKGBlbmQgKCR7dH0pIDwgYmVnaW4gKCR7ZX0pIGlzIGZvcmJpZGRlbi5gKTtsZXQgbj1bXTtmb3IobGV0IGE9ZTthPHQ7KythKW4ucHVzaChhKTtyZXR1cm4gbn12YXIgcHg7ZnVuY3Rpb24gcXQoKXtyZXR1cm4gcHg9PW51bGwmJihweD1EdigpLmVwc2lsb24oKSkscHh9ZnVuY3Rpb24gR2EoKXtyZXR1cm5cImNoYW5uZWxzTGFzdFwifWZ1bmN0aW9uIGlyKGUsdCl7cmV0dXJuIHJlKGUsdCl9ZnVuY3Rpb24gd2QoZSx0PS0xKXtsZXQgbj1lLnNoYXBlLnNsaWNlKCk7cmV0dXJuIHQ8MCYmKHQ9bi5sZW5ndGgrdCsxKSxuLnNwbGljZSh0LDAsMSksVyhlLG4pfWZ1bmN0aW9uIEVHKGUsdCl7cmV0dXJuIE8oKCk9PntpZihlLnNoYXBlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IFYoYHJlcGVhdCgpIGV4cGVjdHMgYSByYW5rLTIgdGVuc29yLCBidXQgcmVjZWl2ZWQgYSByYW5rLSR7ZS5zaGFwZS5sZW5ndGh9IHRlbnNvci5gKTtsZXQgbj13ZChlLDEpO3JldHVybiBXeChuLFsxLHQsMV0pfSl9ZnVuY3Rpb24gX0coZSl7bGV0IHQ9W3JzKGUuc2hhcGUpXTtyZXR1cm4gVyhlLHQpfWZ1bmN0aW9uIEFHKGUpe2lmKGUucmFuazw9MSl0aHJvdyBuZXcgVihgYmF0Y2hGbGF0dGVuIHJlcXVpcmVzIGEgbWluaW11bSByYW5rIG9mIDIuIEdvdCByYW5rOiAke2UucmFua30uYCk7bGV0IHQ9W2Uuc2hhcGVbMF0scnMoZS5zaGFwZSwxKV07cmV0dXJuIFcoZSx0KX1mdW5jdGlvbiBzaShlLHQsbil7cmV0dXJuIE8oKCk9Pntzd2l0Y2goZS5yYW5rKXtjYXNlIDE6cmV0dXJuIGdkKGUsdCxuKTtjYXNlIDI6cmV0dXJuIG5mKGUsW3QsMF0sW24sZS5zaGFwZVsxXV0pO2Nhc2UgMzpyZXR1cm4gSG8oZSxbdCwwLDBdLFtuLGUuc2hhcGVbMV0sZS5zaGFwZVsyXV0pO2Nhc2UgNDpyZXR1cm4gV2woZSxbdCwwLDAsMF0sW24sZS5zaGFwZVsxXSxlLnNoYXBlWzJdLGUuc2hhcGVbM11dKTtjYXNlIDU6cmV0dXJuIFZlKGUsW3QsMCwwLDAsMF0sW24sZS5zaGFwZVsxXSxlLnNoYXBlWzJdLGUuc2hhcGVbM10sZS5zaGFwZVs0XV0pO2Nhc2UgNjpyZXR1cm4gVmUoZSxbdCwwLDAsMCwwLDBdLFtuLGUuc2hhcGVbMV0sZS5zaGFwZVsyXSxlLnNoYXBlWzNdLGUuc2hhcGVbNF0sZS5zaGFwZVs1XV0pO2RlZmF1bHQ6dGhyb3cgbmV3IFYoYHNsaWNlQWxvbmdGaXJzdEF4aXMoKSByZWNlaXZlZCBhbiB1bnN1cHBvcnRlZCB0ZW5zb3IgcmFuazogJHtlLnJhbmt9YCl9fSl9ZnVuY3Rpb24gY3goZSx0LG4pe3JldHVybiBPKCgpPT57c3dpdGNoKGUucmFuayl7Y2FzZSAxOnJldHVybiBnZChlLHQsbik7Y2FzZSAyOnJldHVybiBuZihlLFswLHRdLFtlLnNoYXBlWzBdLG5dKTtjYXNlIDM6cmV0dXJuIEhvKGUsWzAsMCx0XSxbZS5zaGFwZVswXSxlLnNoYXBlWzFdLG5dKTtjYXNlIDQ6cmV0dXJuIFdsKGUsWzAsMCwwLHRdLFtlLnNoYXBlWzBdLGUuc2hhcGVbMV0sZS5zaGFwZVsyXSxuXSk7ZGVmYXVsdDp0aHJvdyBuZXcgVihgc2xpY2VBbG9uZ0xhc3RBeGlzKCkgcmVjZWl2ZWQgYW4gdW5zdXBwb3J0ZWQgdGVuc29yIHJhbms6ICR7ZS5yYW5rfWApfX0pfWZ1bmN0aW9uIEloKGUsdCxuLGEpe3JldHVybiBPKCgpPT57c3dpdGNoKGUucmFuayl7Y2FzZSAxOnJldHVybiBnZChlLHQsbik7Y2FzZSAyOnN3aXRjaChhKXtjYXNlIDE6cmV0dXJuIHNpKGUsdCxuKTtjYXNlIDI6cmV0dXJuIGN4KGUsdCxuKTtkZWZhdWx0OnRocm93IG5ldyBWKGBUaGUgYXhpcyBpcyBub3Qgd2l0aGluIHRoZSByYW5rIG9mIHRoZSB0ZW5zb3IgJHthfWApfWNhc2UgMzpzd2l0Y2goYSl7Y2FzZSAxOnJldHVybiBzaShlLHQsbik7Y2FzZSAyOnJldHVybiBIbyhlLFswLHQsMF0sW2Uuc2hhcGVbMF0sbixlLnNoYXBlWzJdXSk7Y2FzZSAzOnJldHVybiBjeChlLHQsbik7ZGVmYXVsdDp0aHJvdyBuZXcgVihgVGhlIGF4aXMgaXMgbm90IHdpdGhpbiB0aGUgcmFuayBvZiB0aGUgdGVuc29yICR7YX1gKX1jYXNlIDQ6c3dpdGNoKGEpe2Nhc2UgMTpyZXR1cm4gc2koZSx0LG4pO2Nhc2UgMjpyZXR1cm4gV2woZSxbMCx0LDAsMF0sW2Uuc2hhcGVbMF0sbixlLnNoYXBlWzJdLGUuc2hhcGVbM11dKTtjYXNlIDM6cmV0dXJuIFdsKGUsWzAsMCx0LDBdLFtlLnNoYXBlWzBdLGUuc2hhcGVbMV0sbixlLnNoYXBlWzNdXSk7Y2FzZSA0OnJldHVybiBjeChlLHQsbik7ZGVmYXVsdDp0aHJvdyBuZXcgVihgVGhlIGF4aXMgaXMgbm90IHdpdGhpbiB0aGUgcmFuayBvZiB0aGUgdGVuc29yICR7YX1gKX1kZWZhdWx0OnRocm93IG5ldyBWKGBzbGljZUFsb25nTGFzdEF4aXMoKSByZWNlaXZlZCBhbiB1bnN1cHBvcnRlZCB0ZW5zb3IgcmFuazogJHtlLnJhbmt9YCl9fSl9ZnVuY3Rpb24gdDAoZSx0PS0xKXtsZXQgbjtyZXR1cm4gdDwwJiYobj1lWzBdLnJhbmssbiE9PTA/dD1uOnQ9MCksdD09PWVbMF0ucmFuayYmKHQ9LTEpLGV0KGUsdCl9ZnVuY3Rpb24gYkkoZSx0KXtzd2l0Y2goZS5yYW5rKXtjYXNlIDE6cmV0dXJuIEp2KFtlLHRdKTtjYXNlIDI6cmV0dXJuIFF2KFtlLHRdLDApO2Nhc2UgMzpyZXR1cm4gZXcoW2UsdF0sMCk7Y2FzZSA0OnJldHVybiB0dyhbZSx0XSwwKTtkZWZhdWx0OnRocm93IG5ldyBWKGBjb25jYXRBbG9uZ0ZpcnN0QXhpcygpIHJlY2VpdmVkIGFuIHVuc3VwcG9ydGVkIHRlbnNvciByYW5rOiAke2UucmFua31gKX19ZnVuY3Rpb24gV3goZSx0KXtpZihBcnJheS5pc0FycmF5KHQpfHwodD1bdF0pLGUucmFuayE9PXQubGVuZ3RoKXRocm93IG5ldyBWKGBUaGUgbGVuZ3RoIG9mIGlucHV0IG4gKCR7dC5sZW5ndGh9KSBkb2VzIG5vdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGRpbWVuc2lvbnMgaW4gaW5wdXQgeCAoJHtlLnJhbmt9KWApO3JldHVybiBPbihlLHQpfWZ1bmN0aW9uIGJmKGUsdD0wLG49MSxhLHIpe3JldHVybiBYbShlLHQsbixhLHIpfWZ1bmN0aW9uIG9yKGUsdCxuLGEpe2lmKGUucmFuazwyfHx0LnJhbms8Mil0aHJvdyBuZXcgemUoYGRvdCByZXF1aXJlcyBib3RoIGlucHV0cyB0byBiZSByYW5rID49IDIgYnV0IGdvdCB4IHNoYXBlID0gJHtlLnNoYXBlfSBhbmQgeSBzaGFwZSA9ICR7dC5zaGFwZX1gKTtpZih0LnJhbms+PTMpe2xldCByPWUuc2hhcGUuc2xpY2UoLTEpWzBdLHM9dC5zaGFwZS5zbGljZSgtMilbMF07aWYociE9PXMpdGhyb3cgbmV3IHplKGBJZiByYW5rIHkgPj0gMywgdGhlbiB0aGUgc2Vjb25kIGxhc3QgZGltIG9mIHkgbXVzdCBlcXVhbCB0aGUgbGFzdCBkaW0gb2YgeCBidXQgZ290IHggc2hhcGUgPSAke2Uuc2hhcGV9IGFuZCAgeSBzaGFwZSA9ICR7dC5zaGFwZX1gKX1pZihlLnJhbms9PT0yJiZ0LnJhbms9PT0yKXJldHVybiBWbC5tYXRNdWwoe2E6ZSxiOnQsdHJhbnNwb3NlQTohMSx0cmFuc3Bvc2VCOiExLGJpYXM6YT9CeChlLnJhbmssYSxHYSgpKTpudWxsLGFjdGl2YXRpb246bn0pO3tsZXQgcj1lLnNoYXBlLnNsaWNlKCkscz1yLnBvcCgpO2U9VyhlLFstMSxzXSk7bGV0IGk9dC5zaGFwZS5zbGljZSgpLG89aS5wb3AoKSxsPWkucG9wKCksdT1bLi4uaSxvXSxwPUFycmF5LmZyb20oe2xlbmd0aDp0LnJhbmt9LChjLGgpPT5oPT09MD90LnJhbmstMjpoPD10LnJhbmstMj9oLTE6aCk7dD1XKERlKHQscCksW2wsLTFdKTtsZXQgZD1bLi4uciwuLi51XTtyZXR1cm4gVyhWbC5tYXRNdWwoe2E6ZSxiOnQsdHJhbnNwb3NlQTohMSx0cmFuc3Bvc2VCOiExLGJpYXM6YT9CeChlLnJhbmssYSxHYSgpKTpudWxsLGFjdGl2YXRpb246bn0pLGQpfX1mdW5jdGlvbiB2MihlLHQsbil7cmV0dXJuIE8oKCk9PihBcnJheS5pc0FycmF5KHQpP3Q9amUodCxcImludDMyXCIpOnQ9cmUodCxcImludDMyXCIpLG5wKGUsdCxuKSkpfWZ1bmN0aW9uIGtkKGUpe3JldHVybiB6KGUsZSl9ZnVuY3Rpb24gQngoZSx0LG4pe2xldCBhPXQuc2hhcGU7aWYodC5yYW5rIT09MSYmdC5yYW5rIT09ZSl0aHJvdyBuZXcgVihgVW5leHBlY3RlZCBiaWFzIGRpbWVuc2lvbnM6ICR7dC5yYW5rfTsgZXhwZWN0ZWQgaXQgdG8gYmUgMSBvciAke2V9YCk7aWYoZT09PTUpe2lmKG49PT1cImNoYW5uZWxzRmlyc3RcIilyZXR1cm4gYS5sZW5ndGg9PT0xP1codCxbMSxhWzBdLDEsMSwxXSk6Vyh0LFsxLGFbM10sYVswXSxhWzFdLGFbMl1dKTtpZihuPT09XCJjaGFubmVsc0xhc3RcIilyZXR1cm4gYS5sZW5ndGg9PT0xP1codCxbMSwxLDEsMSxhWzBdXSk6Vyh0LFsxXS5jb25jYXQoYSkpfWVsc2UgaWYoZT09PTQpe2lmKG49PT1cImNoYW5uZWxzRmlyc3RcIilyZXR1cm4gYS5sZW5ndGg9PT0xP1codCxbMSxhWzBdLDEsMV0pOlcodCxbMSxhWzJdLGFbMF0sYVsxXV0pO2lmKG49PT1cImNoYW5uZWxzTGFzdFwiKXJldHVybiBhLmxlbmd0aD09PTE/Vyh0LFsxLDEsMSxhWzBdXSk6Vyh0LFsxXS5jb25jYXQoYSkpfWVsc2UgaWYoZT09PTMpe2lmKG49PT1cImNoYW5uZWxzRmlyc3RcIilyZXR1cm4gYS5sZW5ndGg9PT0xP1codCxbMSxhWzBdLDFdKTpXKHQsWzEsYVsxXSxhWzBdXSk7aWYobj09PVwiY2hhbm5lbHNMYXN0XCIpcmV0dXJuIGEubGVuZ3RoPT09MT9XKHQsWzEsMSxhWzBdXSk6Vyh0LFsxXS5jb25jYXQoYSkpfWVsc2UgaWYoZTwzKXJldHVybiB0O3Rocm93IG5ldyBWKGBVbnN1cHBvcnRlZCBpbnB1dCByYW5rIGJ5IGJpYXNBZGQ6ICR7dC5yYW5rfWApfWZ1bmN0aW9uIEthKGUsdCxuKXtyZXR1cm4gTygoKT0+KG49PW51bGwmJihuPUdhKCkpLFJ0KG4pLFgoZSxCeChlLnJhbmssdCxuKSkpKX1mdW5jdGlvbiBGRyhlLHQ9MSl7aWYodCE9PTEpdGhyb3cgbmV3IHplKGBTdXBwb3J0IGZvciBhbHBoYSB2YWx1ZXMgb3RoZXIgdGhhbiAxICgke3R9KSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LmApO3JldHVybiBRdShlKX1mdW5jdGlvbiAkRyhlKXtyZXR1cm4gTygoKT0+aGUoZSxYKEx0KGUpLDEpKSl9ZnVuY3Rpb24gdzIoZSx0LG4sYSl7cmV0dXJuIE8oKCk9PlB3KGUsdCxuLGEpKX1mdW5jdGlvbiBERyhlKXtyZXR1cm4gTygoKT0+e2xldCB0PVgoLjUseiguMixlKSk7cmV0dXJuIGFuKHQsMCwxKX0pfWZ1bmN0aW9uIElkKGUsdCxuPSExKXtyZXR1cm4gbj9lKCk6dCgpfXZhciBSRz1bXCJmYW5JblwiLFwiZmFuT3V0XCIsXCJmYW5BdmdcIl0sTUc9W1wibm9ybWFsXCIsXCJ1bmlmb3JtXCIsXCJ0cnVuY2F0ZWROb3JtYWxcIl07ZnVuY3Rpb24gT0coZSl7S28oUkcsXCJGYW5Nb2RlXCIsZSl9ZnVuY3Rpb24gUEcoZSl7S28oTUcsXCJEaXN0cmlidXRpb25cIixlKX12YXIgJGE9Y2xhc3MgZXh0ZW5kcyBuZS5TZXJpYWxpemFibGV7ZnJvbUNvbmZpZ1VzZXNDdXN0b21PYmplY3RzKCl7cmV0dXJuITF9Z2V0Q29uZmlnKCl7cmV0dXJue319fSxuMD1jbGFzcyBleHRlbmRzICRhe2FwcGx5KGUsdCl7cmV0dXJuIEl0KGUsdCl9fTtuMC5jbGFzc05hbWU9XCJaZXJvc1wiO25lLnJlZ2lzdGVyQ2xhc3MobjApO3ZhciB5Zj1jbGFzcyBleHRlbmRzICRhe2FwcGx5KGUsdCl7cmV0dXJuIFBuKGUsdCl9fTt5Zi5jbGFzc05hbWU9XCJPbmVzXCI7bmUucmVnaXN0ZXJDbGFzcyh5Zik7dmFyIGEwPWNsYXNzIGV4dGVuZHMgJGF7Y29uc3RydWN0b3IoZSl7aWYoc3VwZXIoKSx0eXBlb2YgZSE9XCJvYmplY3RcIil0aHJvdyBuZXcgVihgRXhwZWN0ZWQgYXJndW1lbnQgb2YgdHlwZSBDb25zdGFudENvbmZpZyBidXQgZ290ICR7ZX1gKTtpZihlLnZhbHVlPT09dm9pZCAwKXRocm93IG5ldyBWKGBjb25maWcgbXVzdCBoYXZlIHZhbHVlIHNldCBidXQgZ290ICR7ZX1gKTt0aGlzLnZhbHVlPWUudmFsdWV9YXBwbHkoZSx0KXtyZXR1cm4gTygoKT0+eih4ZSh0aGlzLnZhbHVlKSxQbihlLHQpKSl9Z2V0Q29uZmlnKCl7cmV0dXJue3ZhbHVlOnRoaXMudmFsdWV9fX07YTAuY2xhc3NOYW1lPVwiQ29uc3RhbnRcIjtuZS5yZWdpc3RlckNsYXNzKGEwKTt2YXIgcjA9Y2xhc3MgZXh0ZW5kcyAkYXtjb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMuREVGQVVMVF9NSU5WQUw9LS4wNSx0aGlzLkRFRkFVTFRfTUFYVkFMPS4wNSx0aGlzLm1pbnZhbD1lLm1pbnZhbHx8dGhpcy5ERUZBVUxUX01JTlZBTCx0aGlzLm1heHZhbD1lLm1heHZhbHx8dGhpcy5ERUZBVUxUX01BWFZBTCx0aGlzLnNlZWQ9ZS5zZWVkfWFwcGx5KGUsdCl7cmV0dXJuIEVzKGUsdGhpcy5taW52YWwsdGhpcy5tYXh2YWwsdCx0aGlzLnNlZWQpfWdldENvbmZpZygpe3JldHVybnttaW52YWw6dGhpcy5taW52YWwsbWF4dmFsOnRoaXMubWF4dmFsLHNlZWQ6dGhpcy5zZWVkfX19O3IwLmNsYXNzTmFtZT1cIlJhbmRvbVVuaWZvcm1cIjtuZS5yZWdpc3RlckNsYXNzKHIwKTt2YXIgczA9Y2xhc3MgZXh0ZW5kcyAkYXtjb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMuREVGQVVMVF9NRUFOPTAsdGhpcy5ERUZBVUxUX1NURERFVj0uMDUsdGhpcy5tZWFuPWUubWVhbnx8dGhpcy5ERUZBVUxUX01FQU4sdGhpcy5zdGRkZXY9ZS5zdGRkZXZ8fHRoaXMuREVGQVVMVF9TVERERVYsdGhpcy5zZWVkPWUuc2VlZH1hcHBseShlLHQpe2lmKHQ9dHx8XCJmbG9hdDMyXCIsdCE9PVwiZmxvYXQzMlwiJiZ0IT09XCJpbnQzMlwiKXRocm93IG5ldyB6ZShgcmFuZG9tTm9ybWFsIGRvZXMgbm90IHN1cHBvcnQgZFR5cGUgJHt0fS5gKTtyZXR1cm4gYmYoZSx0aGlzLm1lYW4sdGhpcy5zdGRkZXYsdCx0aGlzLnNlZWQpfWdldENvbmZpZygpe3JldHVybnttZWFuOnRoaXMubWVhbixzdGRkZXY6dGhpcy5zdGRkZXYsc2VlZDp0aGlzLnNlZWR9fX07czAuY2xhc3NOYW1lPVwiUmFuZG9tTm9ybWFsXCI7bmUucmVnaXN0ZXJDbGFzcyhzMCk7dmFyIGkwPWNsYXNzIGV4dGVuZHMgJGF7Y29uc3RydWN0b3IoZSl7c3VwZXIoKSx0aGlzLkRFRkFVTFRfTUVBTj0wLHRoaXMuREVGQVVMVF9TVERERVY9LjA1LHRoaXMubWVhbj1lLm1lYW58fHRoaXMuREVGQVVMVF9NRUFOLHRoaXMuc3RkZGV2PWUuc3RkZGV2fHx0aGlzLkRFRkFVTFRfU1REREVWLHRoaXMuc2VlZD1lLnNlZWR9YXBwbHkoZSx0KXtpZih0PXR8fFwiZmxvYXQzMlwiLHQhPT1cImZsb2F0MzJcIiYmdCE9PVwiaW50MzJcIil0aHJvdyBuZXcgemUoYHRydW5jYXRlZE5vcm1hbCBkb2VzIG5vdCBzdXBwb3J0IGRUeXBlICR7dH0uYCk7cmV0dXJuIGxmKGUsdGhpcy5tZWFuLHRoaXMuc3RkZGV2LHQsdGhpcy5zZWVkKX1nZXRDb25maWcoKXtyZXR1cm57bWVhbjp0aGlzLm1lYW4sc3RkZGV2OnRoaXMuc3RkZGV2LHNlZWQ6dGhpcy5zZWVkfX19O2kwLmNsYXNzTmFtZT1cIlRydW5jYXRlZE5vcm1hbFwiO25lLnJlZ2lzdGVyQ2xhc3MoaTApO3ZhciBvMD1jbGFzcyBleHRlbmRzICRhe2NvbnN0cnVjdG9yKGUpe3N1cGVyKCksdGhpcy5nYWluPWUuZ2FpbiE9bnVsbD9lLmdhaW46MX1hcHBseShlLHQpe3JldHVybiBPKCgpPT57aWYoZS5sZW5ndGghPT0yfHxlWzBdIT09ZVsxXSl0aHJvdyBuZXcgVihcIklkZW50aXR5IG1hdHJpeCBpbml0aWFsaXplciBjYW4gb25seSBiZSB1c2VkIGZvciAyRCBzcXVhcmUgbWF0cmljZXMuXCIpO3JldHVybiB6KHRoaXMuZ2FpbixHbShlWzBdKSl9KX1nZXRDb25maWcoKXtyZXR1cm57Z2Fpbjp0aGlzLmdhaW59fX07bzAuY2xhc3NOYW1lPVwiSWRlbnRpdHlcIjtuZS5yZWdpc3RlckNsYXNzKG8wKTtmdW5jdGlvbiBMRyhlLHQ9XCJjaGFubmVsc0xhc3RcIil7bGV0IG4sYTtpZihSdCh0KSxlLmxlbmd0aD09PTIpbj1lWzBdLGE9ZVsxXTtlbHNlIGlmKFszLDQsNV0uaW5kZXhPZihlLmxlbmd0aCkhPT0tMSl7aWYodD09PVwiY2hhbm5lbHNGaXJzdFwiKXtsZXQgcj1ycyhlLDIpO249ZVsxXSpyLGE9ZVswXSpyfWVsc2UgaWYodD09PVwiY2hhbm5lbHNMYXN0XCIpe2xldCByPXJzKGUsMCxlLmxlbmd0aC0yKTtuPWVbZS5sZW5ndGgtMl0qcixhPWVbZS5sZW5ndGgtMV0qcn19ZWxzZXtsZXQgcj1ycyhlKTtuPU1hdGguc3FydChyKSxhPU1hdGguc3FydChyKX1yZXR1cm5bbixhXX12YXIgQm49Y2xhc3MgZXh0ZW5kcyAkYXtjb25zdHJ1Y3RvcihlKXtpZihzdXBlcigpLGUuc2NhbGU8MCl0aHJvdyBuZXcgVihgc2NhbGUgbXVzdCBiZSBhIHBvc2l0aXZlIGZsb2F0LiBHb3Q6ICR7ZS5zY2FsZX1gKTt0aGlzLnNjYWxlPWUuc2NhbGU9PW51bGw/MTplLnNjYWxlLHRoaXMubW9kZT1lLm1vZGU9PW51bGw/XCJmYW5JblwiOmUubW9kZSxPRyh0aGlzLm1vZGUpLHRoaXMuZGlzdHJpYnV0aW9uPWUuZGlzdHJpYnV0aW9uPT1udWxsP1wibm9ybWFsXCI6ZS5kaXN0cmlidXRpb24sUEcodGhpcy5kaXN0cmlidXRpb24pLHRoaXMuc2VlZD1lLnNlZWR9YXBwbHkoZSx0KXtsZXQgbj1MRyhlKSxhPW5bMF0scj1uWzFdLHM9dGhpcy5zY2FsZTtpZih0aGlzLm1vZGU9PT1cImZhbkluXCI/cy89TWF0aC5tYXgoMSxhKTp0aGlzLm1vZGU9PT1cImZhbk91dFwiP3MvPU1hdGgubWF4KDEscik6cy89TWF0aC5tYXgoMSwoYStyKS8yKSx0aGlzLmRpc3RyaWJ1dGlvbj09PVwibm9ybWFsXCIpe2xldCBpPU1hdGguc3FydChzKTtpZih0PXR8fFwiZmxvYXQzMlwiLHQhPT1cImZsb2F0MzJcIiYmdCE9PVwiaW50MzJcIil0aHJvdyBuZXcgemUoYCR7dGhpcy5nZXRDbGFzc05hbWUoKX0gZG9lcyBub3Qgc3VwcG9ydCBkVHlwZSAke3R9LmApO3JldHVybiBsZihlLDAsaSx0LHRoaXMuc2VlZCl9ZWxzZXtsZXQgaT1NYXRoLnNxcnQoMypzKTtyZXR1cm4gRXMoZSwtaSxpLHQsdGhpcy5zZWVkKX19Z2V0Q29uZmlnKCl7cmV0dXJue3NjYWxlOnRoaXMuc2NhbGUsbW9kZTp0aGlzLm1vZGUsZGlzdHJpYnV0aW9uOnRoaXMuZGlzdHJpYnV0aW9uLHNlZWQ6dGhpcy5zZWVkfX19O0JuLmNsYXNzTmFtZT1cIlZhcmlhbmNlU2NhbGluZ1wiO25lLnJlZ2lzdGVyQ2xhc3MoQm4pO3ZhciB4Zj1jbGFzcyBleHRlbmRzIEJue2NvbnN0cnVjdG9yKGUpe3N1cGVyKHtzY2FsZToxLG1vZGU6XCJmYW5BdmdcIixkaXN0cmlidXRpb246XCJ1bmlmb3JtXCIsc2VlZDplPT1udWxsP251bGw6ZS5zZWVkfSl9Z2V0Q2xhc3NOYW1lKCl7cmV0dXJuIEJuLmNsYXNzTmFtZX19O3hmLmNsYXNzTmFtZT1cIkdsb3JvdFVuaWZvcm1cIjtuZS5yZWdpc3RlckNsYXNzKHhmKTt2YXIgdmY9Y2xhc3MgZXh0ZW5kcyBCbntjb25zdHJ1Y3RvcihlKXtzdXBlcih7c2NhbGU6MSxtb2RlOlwiZmFuQXZnXCIsZGlzdHJpYnV0aW9uOlwibm9ybWFsXCIsc2VlZDplPT1udWxsP251bGw6ZS5zZWVkfSl9Z2V0Q2xhc3NOYW1lKCl7cmV0dXJuIEJuLmNsYXNzTmFtZX19O3ZmLmNsYXNzTmFtZT1cIkdsb3JvdE5vcm1hbFwiO25lLnJlZ2lzdGVyQ2xhc3ModmYpO3ZhciB3Zj1jbGFzcyBleHRlbmRzIEJue2NvbnN0cnVjdG9yKGUpe3N1cGVyKHtzY2FsZToyLG1vZGU6XCJmYW5JblwiLGRpc3RyaWJ1dGlvbjpcIm5vcm1hbFwiLHNlZWQ6ZT09bnVsbD9udWxsOmUuc2VlZH0pfWdldENsYXNzTmFtZSgpe3JldHVybiBCbi5jbGFzc05hbWV9fTt3Zi5jbGFzc05hbWU9XCJIZU5vcm1hbFwiO25lLnJlZ2lzdGVyQ2xhc3Mod2YpO3ZhciBrZj1jbGFzcyBleHRlbmRzIEJue2NvbnN0cnVjdG9yKGUpe3N1cGVyKHtzY2FsZToyLG1vZGU6XCJmYW5JblwiLGRpc3RyaWJ1dGlvbjpcInVuaWZvcm1cIixzZWVkOmU9PW51bGw/bnVsbDplLnNlZWR9KX1nZXRDbGFzc05hbWUoKXtyZXR1cm4gQm4uY2xhc3NOYW1lfX07a2YuY2xhc3NOYW1lPVwiSGVVbmlmb3JtXCI7bmUucmVnaXN0ZXJDbGFzcyhrZik7dmFyIElmPWNsYXNzIGV4dGVuZHMgQm57Y29uc3RydWN0b3IoZSl7c3VwZXIoe3NjYWxlOjEsbW9kZTpcImZhbkluXCIsZGlzdHJpYnV0aW9uOlwibm9ybWFsXCIsc2VlZDplPT1udWxsP251bGw6ZS5zZWVkfSl9Z2V0Q2xhc3NOYW1lKCl7cmV0dXJuIEJuLmNsYXNzTmFtZX19O0lmLmNsYXNzTmFtZT1cIkxlQ3VuTm9ybWFsXCI7bmUucmVnaXN0ZXJDbGFzcyhJZik7dmFyIFNmPWNsYXNzIGV4dGVuZHMgQm57Y29uc3RydWN0b3IoZSl7c3VwZXIoe3NjYWxlOjEsbW9kZTpcImZhbkluXCIsZGlzdHJpYnV0aW9uOlwidW5pZm9ybVwiLHNlZWQ6ZT09bnVsbD9udWxsOmUuc2VlZH0pfWdldENsYXNzTmFtZSgpe3JldHVybiBCbi5jbGFzc05hbWV9fTtTZi5jbGFzc05hbWU9XCJMZUN1blVuaWZvcm1cIjtuZS5yZWdpc3RlckNsYXNzKFNmKTt2YXIgbDA9Y2xhc3MgZXh0ZW5kcyAkYXtjb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMuREVGQVVMVF9HQUlOPTEsdGhpcy5FTEVNRU5UU19XQVJOX1NMT1c9MmUzLHRoaXMuZ2Fpbj1lLmdhaW49PW51bGw/dGhpcy5ERUZBVUxUX0dBSU46ZS5nYWluLHRoaXMuc2VlZD1lLnNlZWR9YXBwbHkoZSx0KXtyZXR1cm4gTygoKT0+e2lmKGUubGVuZ3RoPDIpdGhyb3cgbmV3IHplKFwiU2hhcGUgbXVzdCBiZSBhdCBsZWFzdCAyRC5cIik7aWYodCE9PVwiaW50MzJcIiYmdCE9PVwiZmxvYXQzMlwiJiZ0IT09dm9pZCAwKXRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZSAke3R9LmApO3Q9dDtsZXQgbj13LnNpemVGcm9tU2hhcGUoZS5zbGljZSgwLC0xKSksYT1lW2UubGVuZ3RoLTFdLHI9biphO3I+dGhpcy5FTEVNRU5UU19XQVJOX1NMT1cmJmNvbnNvbGUud2FybihgT3J0aG9nb25hbCBpbml0aWFsaXplciBpcyBiZWluZyBjYWxsZWQgb24gYSBtYXRyaXggd2l0aCBtb3JlIHRoYW4gJHt0aGlzLkVMRU1FTlRTX1dBUk5fU0xPV30gKCR7cn0pIGVsZW1lbnRzOiBTbG93bmVzcyBtYXkgcmVzdWx0LmApO2xldCBzPVtNYXRoLm1heChhLG4pLE1hdGgubWluKGEsbildLGk9YmYocywwLDEsdCx0aGlzLnNlZWQpLG89QncucXIoaSwhMSksbD1vWzBdLHU9b1sxXS5mbGF0dGVuKCkuc3RyaWRlZFNsaWNlKFswXSxbTWF0aC5taW4oYSxuKSpNYXRoLm1pbihhLG4pXSxbTWF0aC5taW4oYSxuKSsxXSk7cmV0dXJuIGw9eihsLHUuc2lnbigpKSxuPGEmJihsPWwudHJhbnNwb3NlKCkpLHooeGUodGhpcy5nYWluKSxsLnJlc2hhcGUoZSkpfSl9Z2V0Q29uZmlnKCl7cmV0dXJue2dhaW46dGhpcy5nYWluLHNlZWQ6dGhpcy5zZWVkfX19O2wwLmNsYXNzTmFtZT1cIk9ydGhvZ29uYWxcIjtuZS5yZWdpc3RlckNsYXNzKGwwKTt2YXIgeUk9e2NvbnN0YW50OlwiQ29uc3RhbnRcIixnbG9yb3ROb3JtYWw6XCJHbG9yb3ROb3JtYWxcIixnbG9yb3RVbmlmb3JtOlwiR2xvcm90VW5pZm9ybVwiLGhlTm9ybWFsOlwiSGVOb3JtYWxcIixoZVVuaWZvcm06XCJIZVVuaWZvcm1cIixpZGVudGl0eTpcIklkZW50aXR5XCIsbGVDdW5Ob3JtYWw6XCJMZUN1bk5vcm1hbFwiLGxlQ3VuVW5pZm9ybTpcIkxlQ3VuVW5pZm9ybVwiLG9uZXM6XCJPbmVzXCIsb3J0aG9nb25hbDpcIk9ydGhvZ29uYWxcIixyYW5kb21Ob3JtYWw6XCJSYW5kb21Ob3JtYWxcIixyYW5kb21Vbmlmb3JtOlwiUmFuZG9tVW5pZm9ybVwiLHRydW5jYXRlZE5vcm1hbDpcIlRydW5jYXRlZE5vcm1hbFwiLHZhcmlhbmNlU2NhbGluZzpcIlZhcmlhbmNlU2NhbGluZ1wiLHplcm9zOlwiWmVyb3NcIn07ZnVuY3Rpb24geEkoZSx0PXt9KXtyZXR1cm4gdmQoZSxuZS5TZXJpYWxpemF0aW9uTWFwLmdldE1hcCgpLmNsYXNzTmFtZU1hcCx0LFwiaW5pdGlhbGl6ZXJcIil9ZnVuY3Rpb24gRXQoZSl7cmV0dXJuIFF3KGUpfWZ1bmN0aW9uIFN0KGUpe2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiKXtsZXQgdD1lIGluIHlJP3lJW2VdOmU7aWYodD09PVwiR2xvcm90Tm9ybWFsXCIpcmV0dXJuIG5ldyB2ZjtpZih0PT09XCJHbG9yb3RVbmlmb3JtXCIpcmV0dXJuIG5ldyB4ZjtpZih0PT09XCJIZU5vcm1hbFwiKXJldHVybiBuZXcgd2Y7aWYodD09PVwiSGVVbmlmb3JtXCIpcmV0dXJuIG5ldyBrZjtpZih0PT09XCJMZUN1bk5vcm1hbFwiKXJldHVybiBuZXcgSWY7aWYodD09PVwiTGVDdW5Vbmlmb3JtXCIpcmV0dXJuIG5ldyBTZjt7bGV0IG49e307cmV0dXJuIG4uY2xhc3NOYW1lPXQsbi5jb25maWc9e30seEkobil9fWVsc2UgcmV0dXJuIGUgaW5zdGFuY2VvZiAkYT9lOnhJKGUpfWZ1bmN0aW9uIFZ4KGUpe3JldHVybiBBcnJheS5pc0FycmF5KGUpJiZBcnJheS5pc0FycmF5KGVbMF0pfWZ1bmN0aW9uIFpoKGUpe3JldHVybiBlLmxlbmd0aD09PTA/W106QXJyYXkuaXNBcnJheShlWzBdKT9lOltlXX1mdW5jdGlvbiBUZShlKXtsZXQgdDtpZihBcnJheS5pc0FycmF5KGUpKXtpZihlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IFYoYEV4cGVjdGVkIFRlbnNvciBsZW5ndGggdG8gYmUgMTsgZ290ICR7ZS5sZW5ndGh9YCk7dD1lWzBdfWVsc2UgdD1lO3JldHVybiB0fWZ1bmN0aW9uIEplKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkmJkFycmF5LmlzQXJyYXkoZVswXSkpe2lmKGUubGVuZ3RoPT09MSlyZXR1cm4gZT1lLGVbMF07dGhyb3cgbmV3IFYoYEV4cGVjdGVkIGV4YWN0bHkgMSBTaGFwZTsgZ290ICR7ZS5sZW5ndGh9YCl9ZWxzZSByZXR1cm4gZX1mdW5jdGlvbiBKaChlKXtsZXQgdD0wO2ZvcihsZXQgbiBvZiBlKW4uc2hhcGUubGVuZ3RoPT09MD90Kz0xOnQrPW4uc2hhcGUucmVkdWNlKChhLHIpPT5hKnIpO3JldHVybiB0fXZhciB2ST1cIlZhcmlhYmxlXCIsazI9Y2xhc3N7Y29uc3RydWN0b3IoZSx0PVwiZmxvYXQzMlwiLG49dkksYT0hMCxyPW51bGwpe3RoaXMuZHR5cGU9dD09bnVsbD9cImZsb2F0MzJcIjp0LHRoaXMuc2hhcGU9ZS5zaGFwZSx0aGlzLmlkPWYyKCksbj1uPT1udWxsP3ZJOm4sdGhpcy5vcmlnaW5hbE5hbWU9YjIobiksdGhpcy5uYW1lPXkyKHRoaXMub3JpZ2luYWxOYW1lKSx0aGlzLnRyYWluYWJsZV89YSx0aGlzLmNvbnN0cmFpbnQ9cix0aGlzLnZhbD1NdyhlLHRoaXMudHJhaW5hYmxlXyx0aGlzLm5hbWUsdGhpcy5kdHlwZSl9cmVhZCgpe3JldHVybiB0aGlzLmFzc2VydE5vdERpc3Bvc2VkKCksdGhpcy52YWx9d3JpdGUoZSl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90RGlzcG9zZWQoKSx6Ryh0aGlzLnZhbCxlKSx0aGlzLnZhbC5pZCE9PWUuaWQmJih0aGlzLnZhbC5hc3NpZ24oZSksdGhpcy5jb25zdHJhaW50IT1udWxsJiZ0aGlzLnZhbC5hc3NpZ24odGhpcy5jb25zdHJhaW50LmFwcGx5KHRoaXMudmFsKSkpLHRoaXN9ZGlzcG9zZSgpe3RoaXMuYXNzZXJ0Tm90RGlzcG9zZWQoKSx0aGlzLnZhbC5kaXNwb3NlKCl9YXNzZXJ0Tm90RGlzcG9zZWQoKXtpZih0aGlzLnZhbC5pc0Rpc3Bvc2VkKXRocm93IG5ldyBFcnJvcihgTGF5ZXJzVmFyaWFibGUgJHt0aGlzLm5hbWV9IGlzIGFscmVhZHkgZGlzcG9zZWQuYCl9Z2V0IHRyYWluYWJsZSgpe3JldHVybiB0aGlzLnRyYWluYWJsZV99c2V0IHRyYWluYWJsZShlKXt0aGlzLnRyYWluYWJsZV89ZSx0aGlzLnZhbC50cmFpbmFibGU9ZX19O2Z1bmN0aW9uIHpHKGUsdCl7aWYoZS5zaGFwZS50b1N0cmluZygpIT09dC5zaGFwZS50b1N0cmluZygpKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIG1pc21hdGNoOiBcIitKU09OLnN0cmluZ2lmeShlLnNoYXBlKStcIiB2cy4gXCIrSlNPTi5zdHJpbmdpZnkodC5zaGFwZSkpfWZ1bmN0aW9uIFV4KGUpe3JldHVybiBlLm1hcCh0PT50LnJlYWQoKSl9ZnVuY3Rpb24gdTAoZSl7ZS5mb3JFYWNoKHQ9Pnt0WzBdLndyaXRlKHRbMV0pfSl9dmFyIHp0PWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuZHR5cGU9ZS5kdHlwZSx0aGlzLnNoYXBlPWUuc2hhcGUsZS5zaGFwZSE9bnVsbD90aGlzLm5kaW09ZS5zaGFwZS5sZW5ndGg6dGhpcy5uZGltPWUubmRpbSx0aGlzLm1heE5EaW09ZS5tYXhORGltLHRoaXMubWluTkRpbT1lLm1pbk5EaW0sdGhpcy5heGVzPWUuYXhlc3x8e319fSxIYT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixhLHIscyxpKXt0aGlzLmR0eXBlPWUsdGhpcy5zaGFwZT10LHRoaXMuc291cmNlTGF5ZXI9bix0aGlzLmlucHV0cz1hLHRoaXMuY2FsbEFyZ3M9cix0aGlzLm91dHB1dFRlbnNvckluZGV4PWksdGhpcy5pZD1mMigpLHMhPW51bGwmJih0aGlzLm9yaWdpbmFsTmFtZT1iMihzKSx0aGlzLm5hbWU9eTIodGhpcy5vcmlnaW5hbE5hbWUpKSx0aGlzLnJhbms9dC5sZW5ndGh9fSxXRz0wLE5mPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5jYWxsQXJncz10LHRoaXMuaWQ9V0crKyx0aGlzLm91dGJvdW5kTGF5ZXI9ZS5vdXRib3VuZExheWVyLHRoaXMuaW5ib3VuZExheWVycz1lLmluYm91bmRMYXllcnMsdGhpcy5ub2RlSW5kaWNlcz1lLm5vZGVJbmRpY2VzLHRoaXMudGVuc29ySW5kaWNlcz1lLnRlbnNvckluZGljZXMsdGhpcy5pbnB1dFRlbnNvcnM9ZS5pbnB1dFRlbnNvcnMsdGhpcy5vdXRwdXRUZW5zb3JzPWUub3V0cHV0VGVuc29ycyx0aGlzLmlucHV0TWFza3M9ZS5pbnB1dE1hc2tzLHRoaXMub3V0cHV0TWFza3M9ZS5vdXRwdXRNYXNrcyx0aGlzLmlucHV0U2hhcGVzPWUuaW5wdXRTaGFwZXMsdGhpcy5vdXRwdXRTaGFwZXM9ZS5vdXRwdXRTaGFwZXM7Zm9yKGxldCBuIG9mIGUuaW5ib3VuZExheWVycyluIT1udWxsJiZuLm91dGJvdW5kTm9kZXMucHVzaCh0aGlzKTtlLm91dGJvdW5kTGF5ZXIuaW5ib3VuZE5vZGVzLnB1c2godGhpcyl9Z2V0Q29uZmlnKCl7bGV0IGU9W107Zm9yKGxldCB0IG9mIHRoaXMuaW5ib3VuZExheWVycyl0IT1udWxsP2UucHVzaCh0Lm5hbWUpOmUucHVzaChudWxsKTtyZXR1cm57b3V0Ym91bmRMYXllcjp0aGlzLm91dGJvdW5kTGF5ZXI/dGhpcy5vdXRib3VuZExheWVyLm5hbWU6bnVsbCxpbmJvdW5kTGF5ZXJzOmUsbm9kZUluZGljZXM6dGhpcy5ub2RlSW5kaWNlcyx0ZW5zb3JJbmRpY2VzOnRoaXMudGVuc29ySW5kaWNlc319fSxCRz0wLFdlPWNsYXNzIGV4dGVuZHMgbmUuU2VyaWFsaXphYmxle2NvbnN0cnVjdG9yKGU9e30pe3N1cGVyKCksdGhpcy5fY2FsbEhvb2s9bnVsbCx0aGlzLl9hZGRlZFdlaWdodE5hbWVzPVtdLHRoaXMuX3N0YXRlZnVsPSExLHRoaXMuaWQ9QkcrKyx0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXI9bnVsbCx0aGlzLmlucHV0U3BlYz1udWxsLHRoaXMuc3VwcG9ydHNNYXNraW5nPSExLHRoaXMuX3RyYWluYWJsZVdlaWdodHM9W10sdGhpcy5fbm9uVHJhaW5hYmxlV2VpZ2h0cz1bXSx0aGlzLl9sb3NzZXM9W10sdGhpcy5fdXBkYXRlcz1bXSx0aGlzLl9idWlsdD0hMSx0aGlzLmluYm91bmROb2Rlcz1bXSx0aGlzLm91dGJvdW5kTm9kZXM9W107bGV0IHQ9ZS5uYW1lO2lmKCF0KXtsZXQgbj10aGlzLmdldENsYXNzTmFtZSgpO3Q9SXIobikrXCJfXCIrZ2Yobil9aWYodGhpcy5uYW1lPXQsdGhpcy50cmFpbmFibGVfPWUudHJhaW5hYmxlPT1udWxsPyEwOmUudHJhaW5hYmxlLGUuaW5wdXRTaGFwZSE9bnVsbHx8ZS5iYXRjaElucHV0U2hhcGUhPW51bGwpe2xldCBuO2lmKGUuYmF0Y2hJbnB1dFNoYXBlIT1udWxsKW49ZS5iYXRjaElucHV0U2hhcGU7ZWxzZSBpZihlLmlucHV0U2hhcGUhPW51bGwpe2xldCByPW51bGw7ZS5iYXRjaFNpemUhPW51bGwmJihyPWUuYmF0Y2hTaXplKSxuPVtyXS5jb25jYXQoZS5pbnB1dFNoYXBlKX10aGlzLmJhdGNoSW5wdXRTaGFwZT1uO2xldCBhPWUuZHR5cGU7YT09bnVsbCYmKGE9ZS5pbnB1dERUeXBlKSxhPT1udWxsJiYoYT1cImZsb2F0MzJcIiksdGhpcy5kdHlwZT1hfWUud2VpZ2h0cyE9bnVsbD90aGlzLmluaXRpYWxXZWlnaHRzPWUud2VpZ2h0czp0aGlzLmluaXRpYWxXZWlnaHRzPW51bGwsdGhpcy5fcmVmQ291bnQ9bnVsbCx0aGlzLmZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQ9ITF9c3RhdGljIG5vZGVLZXkoZSx0KXtyZXR1cm4gZS5uYW1lK1wiX2liLVwiK3QudG9TdHJpbmcoKX1nZXROb2RlQXRJbmRleChlLHQpe2lmKHRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aD09PTApdGhyb3cgbmV3IGFyKGBUaGUgbGF5ZXIgaGFzIG5ldmVyIGJlZW4gY2FsbGVkIGFuZCB0aHVzIGhhcyBubyBkZWZpbmVkICR7dH0uYCk7aWYodGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoPD1lKXRocm93IG5ldyBWKGBBc2tlZCB0byBnZXQgJHt0fSBhdCBub2RlICR7ZX0sIGJ1dCB0aGUgbGF5ZXIgaGFzIG9ubHkgJHt0aGlzLmluYm91bmROb2Rlcy5sZW5ndGh9IGluYm91bmQgbm9kZXMuYCk7cmV0dXJuIHRoaXMuaW5ib3VuZE5vZGVzW2VdfWdldElucHV0QXQoZSl7cmV0dXJuIE1uKHRoaXMuZ2V0Tm9kZUF0SW5kZXgoZSxcImlucHV0XCIpLmlucHV0VGVuc29ycyl9Z2V0T3V0cHV0QXQoZSl7cmV0dXJuIE1uKHRoaXMuZ2V0Tm9kZUF0SW5kZXgoZSxcIm91dHB1dFwiKS5vdXRwdXRUZW5zb3JzKX1nZXQgaW5wdXQoKXtpZih0aGlzLmluYm91bmROb2Rlcy5sZW5ndGg+MSl0aHJvdyBuZXcgWHIoYExheWVyICR7dGhpcy5uYW1lfSBoYXMgbXVsdGlwbGUgaW5ib3VuZCBub2RlcywgaGVuY2UgdGhlIG5vdGlvbiBvZiBcImxheWVyIGlucHV0XCIgaXMgaWxsLWRlZmluZWQuIFVzZSBcXGBnZXRJbnB1dEF0KG5vZGVJbmRleClcXGAgaW5zdGVhZC5gKTtpZih0aGlzLmluYm91bmROb2Rlcy5sZW5ndGg9PT0wKXRocm93IG5ldyBYcihgTGF5ZXIgJHt0aGlzLm5hbWV9IGlzIG5vdCBjb25uZWN0ZWQsIG5vIGlucHV0IHRvIHJldHVybi5gKTtyZXR1cm4gTW4odGhpcy5nZXROb2RlQXRJbmRleCgwLFwiaW5wdXRcIikuaW5wdXRUZW5zb3JzKX1nZXQgb3V0cHV0KCl7aWYodGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoPT09MCl0aHJvdyBuZXcgWHIoYExheWVyICR7dGhpcy5uYW1lfSBoYXMgbm8gaW5ib3VuZCBub2Rlcy5gKTtpZih0aGlzLmluYm91bmROb2Rlcy5sZW5ndGg+MSl0aHJvdyBuZXcgWHIoYExheWVyICR7dGhpcy5uYW1lfSBoYXMgbXVsdGlwbGUgaW5ib3VuZCBub2RlcywgaGVuY2UgdGhlIG5vdGlvbiBvZiBcImxheWVyIG91dHB1dFwiIGlzIGlsbC1kZWZpbmVkLiBVc2UgXFxgZ2V0T3V0cHV0QXQobm9kZUluZGV4KVxcYCBpbnN0ZWFkLmApO3JldHVybiBNbih0aGlzLmdldE5vZGVBdEluZGV4KDAsXCJvdXRwdXRcIikub3V0cHV0VGVuc29ycyl9Z2V0IGxvc3Nlcygpe3JldHVybiB0aGlzLl9sb3NzZXN9Y2FsY3VsYXRlTG9zc2VzKCl7cmV0dXJuIHRoaXMubG9zc2VzLm1hcChlPT5lKCkpfWdldCB1cGRhdGVzKCl7cmV0dXJuIHRoaXMuX3VwZGF0ZXN9Z2V0IGJ1aWx0KCl7cmV0dXJuIHRoaXMuX2J1aWx0fXNldCBidWlsdChlKXt0aGlzLl9idWlsdD1lfWdldCB0cmFpbmFibGUoKXtyZXR1cm4gdGhpcy50cmFpbmFibGVffXNldCB0cmFpbmFibGUoZSl7dGhpcy5fdHJhaW5hYmxlV2VpZ2h0cy5mb3JFYWNoKHQ9PnQudHJhaW5hYmxlPWUpLHRoaXMudHJhaW5hYmxlXz1lfWdldCB0cmFpbmFibGVXZWlnaHRzKCl7cmV0dXJuIHRoaXMudHJhaW5hYmxlXz90aGlzLl90cmFpbmFibGVXZWlnaHRzLmZpbHRlcihlPT5lLnRyYWluYWJsZSk6W119c2V0IHRyYWluYWJsZVdlaWdodHMoZSl7dGhpcy5fdHJhaW5hYmxlV2VpZ2h0cz1lfWdldCBub25UcmFpbmFibGVXZWlnaHRzKCl7cmV0dXJuIHRoaXMudHJhaW5hYmxlP3RoaXMuX3RyYWluYWJsZVdlaWdodHMuZmlsdGVyKGU9PiFlLnRyYWluYWJsZSkuY29uY2F0KHRoaXMuX25vblRyYWluYWJsZVdlaWdodHMpOnRoaXMuX3RyYWluYWJsZVdlaWdodHMuY29uY2F0KHRoaXMuX25vblRyYWluYWJsZVdlaWdodHMpfXNldCBub25UcmFpbmFibGVXZWlnaHRzKGUpe3RoaXMuX25vblRyYWluYWJsZVdlaWdodHM9ZX1nZXQgd2VpZ2h0cygpe3JldHVybiB0aGlzLnRyYWluYWJsZVdlaWdodHMuY29uY2F0KHRoaXMubm9uVHJhaW5hYmxlV2VpZ2h0cyl9Z2V0IHN0YXRlZnVsKCl7cmV0dXJuIHRoaXMuX3N0YXRlZnVsfXJlc2V0U3RhdGVzKCl7aWYoIXRoaXMuc3RhdGVmdWwpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgdGhlIHJlc2V0U3RhdGVzKCkgbWV0aG9kIG9mIGEgbm9uLXN0YXRlZnVsIExheWVyIG9iamVjdC5cIil9YXNzZXJ0SW5wdXRDb21wYXRpYmlsaXR5KGUpe2xldCB0PWl0KGUpO2lmKHRoaXMuaW5wdXRTcGVjPT1udWxsfHx0aGlzLmlucHV0U3BlYy5sZW5ndGg9PT0wKXJldHVybjtsZXQgbj1pdCh0aGlzLmlucHV0U3BlYyk7aWYodC5sZW5ndGghPT1uLmxlbmd0aCl0aHJvdyBuZXcgVihgTGF5ZXIgJHt0aGlzLm5hbWV9IGV4cGVjdHMgJHtuLmxlbmd0aH0gaW5wdXRzLCBidXQgaXQgcmVjZWl2ZWQgJHt0Lmxlbmd0aH0gaW5wdXQgdGVuc29ycy4gSW5wdXQgcmVjZWl2ZWQ6ICR7ZX1gKTtmb3IobGV0IGE9MDthPHQubGVuZ3RoO2ErKyl7bGV0IHI9dFthXSxzPW5bYV07aWYocz09bnVsbCljb250aW51ZTtsZXQgaT1yLnJhbms7aWYocy5uZGltIT1udWxsJiZpIT09cy5uZGltKXRocm93IG5ldyBWKGBJbnB1dCAke2F9IGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyICR7dGhpcy5uYW1lfTogZXhwZWN0ZWQgbmRpbT0ke3MubmRpbX0sIGZvdW5kIG5kaW09JHtpfWApO2lmKHMubWF4TkRpbSE9bnVsbCYmaT5zLm1heE5EaW0pdGhyb3cgbmV3IFYoYElucHV0ICR7YX0gaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgJHt0aGlzLm5hbWV9OiBleHBlY3RlZCBtYXhfbmRpbT0ke3MubWF4TkRpbX0sIGZvdW5kIG5kaW09JHtpfWApO2lmKHMubWluTkRpbSE9bnVsbCYmaTxzLm1pbk5EaW0pdGhyb3cgbmV3IFYoYElucHV0ICR7YX0gaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgJHt0aGlzLm5hbWV9OiBleHBlY3RlZCBtaW5fbmRpbT0ke3MubWluTkRpbX0sIGZvdW5kIG5kaW09JHtpfS5gKTtpZihzLmR0eXBlIT1udWxsJiZyLmR0eXBlIT09cy5kdHlwZSl0aHJvdyBuZXcgVihgSW5wdXQgJHthfSBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciAke3RoaXMubmFtZX0gOiBleHBlY3RlZCBkdHlwZT0ke3MuZHR5cGV9LCBmb3VuZCBkdHlwZT0ke3IuZHR5cGV9LmApO2lmKHMuYXhlcyl7bGV0IG89ci5zaGFwZTtmb3IobGV0IGwgaW4gcy5heGVzKXtsZXQgdT1OdW1iZXIobCkscD1zLmF4ZXNbbF0sZD11Pj0wP29bdV06b1tvLmxlbmd0aCt1XTtpZihwIT1udWxsJiZbcCxudWxsXS5pbmRleE9mKGQpPT09LTEpdGhyb3cgbmV3IFYoYElucHV0ICR7YX0gaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgJHt0aGlzLm5hbWV9OiBleHBlY3RlZCBheGlzICR7dX0gb2YgaW5wdXQgc2hhcGUgdG8gaGF2ZSB2YWx1ZSAke3B9IGJ1dCBnb3Qgc2hhcGUgJHtvfS5gKX19aWYocy5zaGFwZSE9bnVsbClmb3IobGV0IG89MDtvPHMuc2hhcGUubGVuZ3RoOysrbyl7bGV0IGw9cy5zaGFwZVtvXSx1PXIuc2hhcGVbb107aWYobCE9bnVsbCYmdSE9bnVsbCYmbCE9PXUpdGhyb3cgbmV3IFYoYElucHV0ICR7YX0gaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgJHt0aGlzLm5hbWV9OiBleHBlY3RlZCBzaGFwZT0ke3Muc2hhcGV9LCBmb3VuZCBzaGFwZT0ke3Iuc2hhcGV9LmApfX19Y2FsbChlLHQpe3JldHVybiBlfWludm9rZUNhbGxIb29rKGUsdCl7dGhpcy5fY2FsbEhvb2shPW51bGwmJnRoaXMuX2NhbGxIb29rKGUsdCl9c2V0Q2FsbEhvb2soZSl7dGhpcy5fY2FsbEhvb2s9ZX1jbGVhckNhbGxIb29rKCl7dGhpcy5fY2FsbEhvb2s9bnVsbH1hcHBseShlLHQpe3Q9dHx8e30sdGhpcy5hc3NlcnROb3REaXNwb3NlZCgpO2xldCBuPWl0KGUpLGE9R0coZSkscj1IRyhlKTtpZihhPT09cil0aHJvdyBuZXcgVihcIkFyZ3VtZW50cyB0byBhcHBseSgpIG11c3QgYmUgYWxsIFN5bWJvbGljVGVuc29ycyBvciBhbGwgVGVuc29yc1wiKTtyZXR1cm4gcmkodGhpcy5uYW1lLCgpPT57aWYoIXRoaXMuYnVpbHQpe3RoaXMuYXNzZXJ0SW5wdXRDb21wYXRpYmlsaXR5KGUpO2xldCBzPVtdO2ZvcihsZXQgaSBvZiBpdChlKSlzLnB1c2goaS5zaGFwZSk7dGhpcy5idWlsZChNbihzKSksdGhpcy5idWlsdD0hMCx0aGlzLmluaXRpYWxXZWlnaHRzJiZ0aGlzLnNldFdlaWdodHModGhpcy5pbml0aWFsV2VpZ2h0cyksdGhpcy5fcmVmQ291bnQ9PT1udWxsJiZyJiYodGhpcy5fcmVmQ291bnQ9MSl9aWYodGhpcy5hc3NlcnRJbnB1dENvbXBhdGliaWxpdHkoZSkscil7bGV0IHM9dGhpcy5jYWxsKGUsdCk7dGhpcy5zdXBwb3J0c01hc2tpbmcmJnRoaXMuc2V0TWFza01ldGFkYXRhKGUscyk7bGV0IGk9aXQocyksbz1bXTtmb3IobGV0IGwgb2YgaSluLmluZGV4T2YobCkhPT0tMSYmKGw9bC5jbG9uZSgpKSxvLnB1c2gobCk7aWYocz1NbihvKSx0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIhPW51bGwpdGhyb3cgbmV3IHplKFwiTGF5ZXIgaW52b2NhdGlvbiBpbiB0aGUgcHJlc2VuY2Ugb2YgYWN0aXZpdHkgcmVndWxhcml6ZXIocykgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO3JldHVybiBzfWVsc2V7bGV0IHM9VkcoZSksaT10aGlzLmNvbXB1dGVPdXRwdXRTaGFwZShzKSxvLGw9VUcoZSk7aWYodGhpcy53YXJuT25JbmNvbXBhdGlibGVJbnB1dFNoYXBlKEFycmF5LmlzQXJyYXkoZSk/c1swXTpzKSxpIT1udWxsJiZpLmxlbmd0aD4wJiZBcnJheS5pc0FycmF5KGlbMF0pP289aS5tYXAoKHUscCk9Pm5ldyBIYShsLHUsdGhpcyxpdChlKSx0LHRoaXMubmFtZSxwKSk6bz1uZXcgSGEobCxpLHRoaXMsaXQoZSksdCx0aGlzLm5hbWUpLHRoaXMuYWRkSW5ib3VuZE5vZGUoZSxvLG51bGwsbnVsbCxzLGksdCksdGhpcy5fcmVmQ291bnQrKyx0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIhPW51bGwpdGhyb3cgbmV3IHplKFwiTGF5ZXIgaW52b2NhdGlvbiBpbiB0aGUgcHJlc2VuY2Ugb2YgYWN0aXZpdHkgcmVndWxhcml6ZXIocykgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO3JldHVybiBvfX0pfXdhcm5PbkluY29tcGF0aWJsZUlucHV0U2hhcGUoZSl7aWYodGhpcy5iYXRjaElucHV0U2hhcGUhPW51bGwpaWYoZS5sZW5ndGghPT10aGlzLmJhdGNoSW5wdXRTaGFwZS5sZW5ndGgpY29uc29sZS53YXJuKGBUaGUgcmFuayBvZiB0aGUgaW5wdXQgdGVuc29yIHByb3ZpZGVkIChzaGFwZTogJHtKU09OLnN0cmluZ2lmeShlKX0pIGRvZXMgbm90IG1hdGNoIHRoYXQgb2YgdGhlIGJhdGNoSW5wdXRTaGFwZSAoJHtKU09OLnN0cmluZ2lmeSh0aGlzLmJhdGNoSW5wdXRTaGFwZSl9KSBvZiB0aGUgbGF5ZXIgJHt0aGlzLm5hbWV9YCk7ZWxzZXtsZXQgdD0hMTt0aGlzLmJhdGNoSW5wdXRTaGFwZS5mb3JFYWNoKChuLGEpPT57biE9bnVsbCYmZVthXSE9bnVsbCYmZVthXSE9PW4mJih0PSEwKX0pLHQmJmNvbnNvbGUud2FybihgVGhlIHNoYXBlIG9mIHRoZSBpbnB1dCB0ZW5zb3IgKCR7SlNPTi5zdHJpbmdpZnkoZSl9KSBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0YXRpb24gb2YgbGF5ZXIgJHt0aGlzLm5hbWV9OiAke0pTT04uc3RyaW5naWZ5KHRoaXMuYmF0Y2hJbnB1dFNoYXBlKX1gKX19Z2V0IG91dHB1dFNoYXBlKCl7aWYodGhpcy5pbmJvdW5kTm9kZXM9PW51bGx8fHRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aD09PTApdGhyb3cgbmV3IFhyKGBUaGUgbGF5ZXIgJHt0aGlzLm5hbWV9IGhhcyBuZXZlciBiZWVuIGNhbGxlZCBhbmQgdGh1cyBoYXMgbm8gZGVmaW5lZCBvdXRwdXQgc2hhcGUuYCk7bGV0IGU9W107Zm9yKGxldCB0IG9mIHRoaXMuaW5ib3VuZE5vZGVzKXtsZXQgbj1KU09OLnN0cmluZ2lmeSh0Lm91dHB1dFNoYXBlcyk7ZS5pbmRleE9mKG4pPT09LTEmJmUucHVzaChuKX1pZihlLmxlbmd0aD09PTEpe2xldCB0PXRoaXMuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFNoYXBlcztyZXR1cm4gQXJyYXkuaXNBcnJheSh0KSYmQXJyYXkuaXNBcnJheSh0WzBdKSYmdC5sZW5ndGg9PT0xP3RbMF06dH1lbHNlIHRocm93IG5ldyBYcihgVGhlIGxheWVyICR7dGhpcy5uYW1lfSBoYXMgbXVsdGlwbGUgaW5ib3VuZCBub2RlcyB3aXRoIGRpZmZlcmVudCBvdXRwdXQgc2hhcGVzLiBIZW5jZSB0aGUgbm90aW9uIG9mIFwib3V0cHV0IHNoYXBlXCIgaXMgaWxsLWRlZmluZWQgZm9yIHRoZSBsYXllci5gKX1jb3VudFBhcmFtcygpe2lmKCF0aGlzLmJ1aWx0KXRocm93IG5ldyBhcihgWW91IHRyaWVkIHRvIGNhbGwgY291bnRQYXJhbXMoKSBvbiAke3RoaXMubmFtZX0sIGJ1dCB0aGUgbGF5ZXIgaXMgbm90IGJ1aWx0IHlldC4gQnVpbGQgaXQgZmlyc3QgYnkgY2FsbGluZyBidWlsZChiYXRjaElucHV0U2hhcGUpLmApO3JldHVybiBKaCh0aGlzLndlaWdodHMpfWJ1aWxkKGUpe3RoaXMuYnVpbHQ9ITB9Z2V0V2VpZ2h0cyhlPSExKXtyZXR1cm4gVXgoZT90aGlzLnRyYWluYWJsZVdlaWdodHM6dGhpcy53ZWlnaHRzKX1zZXRXZWlnaHRzKGUpe08oKCk9PntsZXQgdD10aGlzLndlaWdodHM7aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgVihgWW91IGNhbGxlZCBzZXRXZWlnaHRzKHdlaWdodHMpIG9uIGxheWVyIFwiJHt0aGlzLm5hbWV9XCIgd2l0aCBhIHdlaWdodCBsaXN0IG9mIGxlbmd0aCAke2UubGVuZ3RofSwgYnV0IHRoZSBsYXllciB3YXMgZXhwZWN0aW5nICR7dC5sZW5ndGh9IHdlaWdodHMuIFByb3ZpZGVkIHdlaWdodHM6ICR7ZX0uLi5gKTtpZih0Lmxlbmd0aD09PTApcmV0dXJuO2xldCBuPVtdLGE9VXgodCk7Zm9yKGxldCByPTA7cjxhLmxlbmd0aDsrK3Ipe2xldCBzPWFbcl0saT10W3JdLG89ZVtyXTtpZighdy5hcnJheXNFcXVhbChzLnNoYXBlLG8uc2hhcGUpKXRocm93IG5ldyBWKGBMYXllciB3ZWlnaHQgc2hhcGUgJHtzLnNoYXBlfSBub3QgY29tcGF0aWJsZSB3aXRoIHByb3ZpZGVkIHdlaWdodCBzaGFwZSAke28uc2hhcGV9YCk7bi5wdXNoKFtpLG9dKX11MChuKX0pfWFkZFdlaWdodChlLHQsbixhLHIscyxpLG8pe2lmKHRoaXMuX2FkZGVkV2VpZ2h0TmFtZXMuaW5kZXhPZihlKSE9PS0xKXRocm93IG5ldyBWKGBEdXBsaWNhdGUgd2VpZ2h0IG5hbWUgJHtlfSBmb3IgbGF5ZXIgJHt0aGlzLm5hbWV9YCk7dGhpcy5fYWRkZWRXZWlnaHROYW1lcy5wdXNoKGUpLG49PW51bGwmJihuPVwiZmxvYXQzMlwiKSx0aGlzLmZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQmJihhPW8hPW51bGw/bygpOlN0KFwiemVyb3NcIikpO2xldCBsPWEuYXBwbHkodCxuKSx1PW5ldyBrMihsLG4sZSxzLGkpO3JldHVybiBsLmRpc3Bvc2UoKSxyIT1udWxsJiZ0aGlzLmFkZExvc3MoKCk9PnIuYXBwbHkodS5yZWFkKCkpKSxzPT1udWxsJiYocz0hMCkscz90aGlzLl90cmFpbmFibGVXZWlnaHRzLnB1c2godSk6dGhpcy5fbm9uVHJhaW5hYmxlV2VpZ2h0cy5wdXNoKHUpLHV9c2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZChlKXt0aGlzLmZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQ9ZX1hZGRMb3NzKGUpe2U9PW51bGx8fEFycmF5LmlzQXJyYXkoZSkmJmUubGVuZ3RoPT09MHx8KGU9aXQoZSksdGhpcy5fbG9zc2VzIT09dm9pZCAwJiZ0aGlzLl9sb3NzZXMhPT1udWxsJiZ0aGlzLmxvc3Nlcy5wdXNoKC4uLmUpKX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7cmV0dXJuIGV9Y29tcHV0ZU1hc2soZSx0KXtpZighdGhpcy5zdXBwb3J0c01hc2tpbmcpe2lmKHQhPW51bGwpaWYoQXJyYXkuaXNBcnJheSh0KSl0LmZvckVhY2gobj0+e2lmKG4hPW51bGwpdGhyb3cgbmV3IFR5cGVFcnJvcihgTGF5ZXIgJHt0aGlzLm5hbWV9IGRvZXMgbm90IHN1cHBvcnQgbWFza2luZywgYnV0IHdhcyBwYXNzZWQgYW4gaW5wdXRNYXNrLmApfSk7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKGBMYXllciAke3RoaXMubmFtZX0gZG9lcyBub3Qgc3VwcG9ydCBtYXNraW5nLCBidXQgd2FzIHBhc3NlZCBhbiBpbnB1dE1hc2suYCk7cmV0dXJuIG51bGx9cmV0dXJuIHR9c2V0TWFza01ldGFkYXRhKGUsdCxuKXtpZighdGhpcy5zdXBwb3J0c01hc2tpbmcpcmV0dXJuO2xldCBhPXRoaXMuY29tcHV0ZU1hc2soZSxuKSxyPWl0KHQpLHM9aXQoYSk7aWYoci5sZW5ndGghPT1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5uYW1lfSBvdXRwdXRzICR7ci5sZW5ndGh9IHRlbnNvcnMgYnV0ICR7ci5sZW5ndGh9IG1hc2tzIGZvciB0aG9zZSB0ZW5zb3JzYCk7Zm9yKGxldCBpPTA7aTxyLmxlbmd0aDtpKyspcltpXS5rZXJhc01hc2s9c1tpXX1hZGRJbmJvdW5kTm9kZShlLHQsbixhLHIscyxpPW51bGwpe2xldCBvPWl0KGUpO3Q9aXQodCksbj1pdChuKSxhPWl0KGEpLHI9Wmgocikscz1aaChzKTtsZXQgbD1bXSx1PVtdLHA9W107Zm9yKGxldCBkIG9mIG8pbC5wdXNoKGQuc291cmNlTGF5ZXIpLHUucHVzaChkLm5vZGVJbmRleCkscC5wdXNoKGQudGVuc29ySW5kZXgpO25ldyBOZih7b3V0Ym91bmRMYXllcjp0aGlzLGluYm91bmRMYXllcnM6bCxub2RlSW5kaWNlczp1LHRlbnNvckluZGljZXM6cCxpbnB1dFRlbnNvcnM6byxvdXRwdXRUZW5zb3JzOnQsaW5wdXRNYXNrczpuLG91dHB1dE1hc2tzOmEsaW5wdXRTaGFwZXM6cixvdXRwdXRTaGFwZXM6c30saSk7Zm9yKGxldCBkPTA7ZDx0Lmxlbmd0aDtkKyspdFtkXS5zb3VyY2VMYXllcj10aGlzLHRbZF0ubm9kZUluZGV4PXRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aC0xLHRbZF0udGVuc29ySW5kZXg9ZH1nZXRDb25maWcoKXtsZXQgZT17bmFtZTp0aGlzLm5hbWUsdHJhaW5hYmxlOnRoaXMudHJhaW5hYmxlfTtyZXR1cm4gdGhpcy5iYXRjaElucHV0U2hhcGUhPW51bGwmJihlLmJhdGNoSW5wdXRTaGFwZT10aGlzLmJhdGNoSW5wdXRTaGFwZSksdGhpcy5kdHlwZSE9bnVsbCYmKGUuZHR5cGU9dGhpcy5kdHlwZSksZX1kaXNwb3NlV2VpZ2h0cygpe3JldHVybiB0aGlzLndlaWdodHMuZm9yRWFjaChlPT5lLmRpc3Bvc2UoKSksdGhpcy53ZWlnaHRzLmxlbmd0aH1hc3NlcnROb3REaXNwb3NlZCgpe2lmKHRoaXMuX3JlZkNvdW50PT09MCl0aHJvdyBuZXcgRXJyb3IoYExheWVyICcke3RoaXMubmFtZX0nIGlzIGFscmVhZHkgZGlzcG9zZWQuYCl9ZGlzcG9zZSgpe2lmKCF0aGlzLmJ1aWx0KXRocm93IG5ldyBFcnJvcihgQ2Fubm90IGRpc3Bvc2UgTGF5ZXIgJHt0aGlzLm5hbWV9IGJlY2F1c2UgaXQgaGFzIG5vdCBiZWVuIGJ1aWx0IHlldC5gKTtpZih0aGlzLl9yZWZDb3VudD09PW51bGwpdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZGlzcG9zZSBMYXllciAke3RoaXMubmFtZX0gYmVjYXVzZSBpdCBoYXMgbm90IGJlZW4gdXNlZCB5ZXQuYCk7dGhpcy5hc3NlcnROb3REaXNwb3NlZCgpO2xldCBlPTA7cmV0dXJuLS10aGlzLl9yZWZDb3VudD09PTAmJihlPXRoaXMuZGlzcG9zZVdlaWdodHMoKSkse3JlZkNvdW50QWZ0ZXJEaXNwb3NlOnRoaXMuX3JlZkNvdW50LG51bURpc3Bvc2VkVmFyaWFibGVzOmV9fX07ZnVuY3Rpb24gVkcoZSl7ZT1pdChlKTtsZXQgdD1bXTtmb3IobGV0IG4gb2YgZSl0LnB1c2gobi5zaGFwZSk7cmV0dXJuIE1uKHQpfWZ1bmN0aW9uIFVHKGUpe3JldHVyblwiZmxvYXQzMlwifWZ1bmN0aW9uIEkyKGUsdCxuKXtpZigodD09bnVsbHx8biE9bnVsbCYmbj4wKSYmKHQ9ZS5zb3VyY2VMYXllcixuPWUubm9kZUluZGV4KSx0LmluYm91bmROb2Rlcy5sZW5ndGg9PT0wKXJldHVybltlXTt7bGV0IGE9dC5pbmJvdW5kTm9kZXNbbl07aWYoYS5pbmJvdW5kTGF5ZXJzLmxlbmd0aD09PTApcmV0dXJuIGEuaW5wdXRUZW5zb3JzO3tsZXQgcj1bXTtmb3IobGV0IHM9MDtzPGEuaW5ib3VuZExheWVycy5sZW5ndGg7cysrKXtsZXQgaT1hLmlucHV0VGVuc29yc1tzXSxvPWEuaW5ib3VuZExheWVyc1tzXSxsPWEubm9kZUluZGljZXNbc10sdT1JMihpLG8sbCk7Zm9yKGxldCBwIG9mIHUpci5pbmRleE9mKHApPT09LTEmJnIucHVzaChwKX1yZXR1cm4gcn19fWZ1bmN0aW9uIEdHKGUpe2xldCB0PSEwO2ZvcihsZXQgbiBvZiBpdChlKSlpZighKG4gaW5zdGFuY2VvZiBIYSkpe3Q9ITE7YnJlYWt9cmV0dXJuIHR9ZnVuY3Rpb24gSEcoZSl7bGV0IHQ9ITA7Zm9yKGxldCBuIG9mIGl0KGUpKWlmKG4gaW5zdGFuY2VvZiBIYSl7dD0hMTticmVha31yZXR1cm4gdH12YXIgcnA9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtpZihzdXBlcih7ZHR5cGU6ZS5kdHlwZSxuYW1lOmUubmFtZSE9bnVsbD9lLm5hbWU6Z2YoXCJpbnB1dFwiKS50b1N0cmluZygpfSksZS5iYXRjaFNpemU9PW51bGwmJihlLmJhdGNoU2l6ZT1udWxsKSxlLnNwYXJzZT09bnVsbCYmKGUuc3BhcnNlPSExKSx0aGlzLnRyYWluYWJsZT0hMSx0aGlzLmJ1aWx0PSEwLHRoaXMuc3BhcnNlPWUuc3BhcnNlLGUuaW5wdXRTaGFwZSE9bnVsbCYmZS5iYXRjaElucHV0U2hhcGUhPW51bGwpdGhyb3cgbmV3IFYoXCJPbmx5IHByb3ZpZGUgdGhlIGlucHV0U2hhcGUgT1IgYmF0Y2hJbnB1dFNoYXBlIGFyZ3VtZW50IHRvIGlucHV0TGF5ZXIsIG5vdCBib3RoIGF0IHRoZSBzYW1lIHRpbWUuXCIpO2xldCB0PWUuYmF0Y2hJbnB1dFNoYXBlO2lmKHQ9PW51bGwpe2lmKGUuaW5wdXRTaGFwZT09bnVsbCl0aHJvdyBuZXcgVihcIkFuIElucHV0TGF5ZXIgc2hvdWxkIGJlIHBhc3NlZCBlaXRoZXIgYSBgYmF0Y2hJbnB1dFNoYXBlYCBvciBhbiBgaW5wdXRTaGFwZWAuXCIpO3Q9W2UuYmF0Y2hTaXplXS5jb25jYXQoZS5pbnB1dFNoYXBlKX1lbHNlIGlmKGUuYmF0Y2hTaXplIT1udWxsKXRocm93IG5ldyBWKFwiQ2Fubm90IHNwZWNpZnkgYmF0Y2hTaXplIGlmIGJhdGNoSW5wdXRTaGFwZSBpcyBzcGVjaWZpZWQgd2hlbiBjcmVhdGluZyBhbiBJbnB1dExheWVyLlwiKTtsZXQgbj1lLmR0eXBlfHxcImZsb2F0MzJcIjt0aGlzLmJhdGNoSW5wdXRTaGFwZT10LHRoaXMuZHR5cGU9bix0aGlzLmlucHV0U3BlYz1be3NoYXBlOnR9XTtsZXQgYT1uZXcgSGEodGhpcy5kdHlwZSx0aGlzLmJhdGNoSW5wdXRTaGFwZSx0aGlzLFtdLHt9LHRoaXMubmFtZSk7YS5ub2RlSW5kZXg9MCxhLnRlbnNvckluZGV4PTAsbmV3IE5mKHtvdXRib3VuZExheWVyOnRoaXMsaW5ib3VuZExheWVyczpbXSxub2RlSW5kaWNlczpbXSx0ZW5zb3JJbmRpY2VzOltdLGlucHV0VGVuc29yczpbYV0sb3V0cHV0VGVuc29yczpbYV0saW5wdXRNYXNrczpbbnVsbF0sb3V0cHV0TWFza3M6W251bGxdLGlucHV0U2hhcGVzOlt0XSxvdXRwdXRTaGFwZXM6W3RdfSl9YXBwbHkoZSx0KXt0aHJvdyBuZXcgVihgQ2Fubm90IHBhc3MgYW55IGlucHV0IHRvIGFuIElucHV0TGF5ZXIncyBhcHBseSgpIG1ldGhvZC4gSW5wdXRMYXllciBuYW1lOiAke3RoaXMubmFtZX1gKX1kaXNwb3NlKCl7cmV0dXJue3JlZkNvdW50QWZ0ZXJEaXNwb3NlOnRoaXMuX3JlZkNvdW50LG51bURpc3Bvc2VkVmFyaWFibGVzOjB9fWdldENvbmZpZygpe3JldHVybntiYXRjaElucHV0U2hhcGU6dGhpcy5iYXRjaElucHV0U2hhcGUsZHR5cGU6dGhpcy5kdHlwZSxzcGFyc2U6dGhpcy5zcGFyc2UsbmFtZTp0aGlzLm5hbWV9fX07cnAuY2xhc3NOYW1lPVwiSW5wdXRMYXllclwiO25lLnJlZ2lzdGVyQ2xhc3MocnApO2Z1bmN0aW9uIFMyKGUpe2lmKGUuYmF0Y2hTaGFwZT09bnVsbCYmZS5zaGFwZT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSB0byBJbnB1dCBlaXRoZXIgYSBgc2hhcGVgIG9yIGEgYGJhdGNoU2hhcGVgIGFyZ3VtZW50LiBOb3RlIHRoYXQgYHNoYXBlYCBkb2VzIG5vdCBpbmNsdWRlIHRoZSBiYXRjaCBkaW1lbnNpb24uXCIpO2lmKGUuYmF0Y2hTaGFwZSE9bnVsbCYmZS5zaGFwZSE9bnVsbCl0aHJvdyBuZXcgVihcIlBsZWFzZSBwcm92aWRlIGVpdGhlciBhIGBzaGFwZWAgb3IgYGJhdGNoU2hhcGVgIGFyZ3VtZW50IHRvIElucHV0LCBidXQgbm90IGJvdGguXCIpO2xldCB0PWUuYmF0Y2hTaGFwZTtlLnNoYXBlIT1udWxsJiZ0PT1udWxsJiYodD1bbnVsbF0uY29uY2F0KGUuc2hhcGUpKTtsZXQgbj1lLmR0eXBlO3JldHVybiBuPT1udWxsJiYobj1cImZsb2F0MzJcIiksbmV3IHJwKHtiYXRjaElucHV0U2hhcGU6dCxuYW1lOmUubmFtZSxkdHlwZTpuLHNwYXJzZTplLnNwYXJzZX0pLmluYm91bmROb2Rlc1swXS5vdXRwdXRUZW5zb3JzWzBdfWZ1bmN0aW9uIGpHKGUsdCl7aWYoZS5kdHlwZT09bnVsbHx8ZS5kdHlwZT09PXQuZHR5cGUpcmV0dXJuIHQ7dHJ5e3JldHVybiByZSh0LGUuZHR5cGUpfWNhdGNoKG4pe3Rocm93IG5ldyBWKGBUaGUgZHR5cGUgb2YgdGhlIGZlZWQgKCR7dC5kdHlwZX0pIGNhbiBub3QgYmUgY2FzdCB0byB0aGUgZHR5cGUgb2YgdGhlIGtleSAnJHtlLm5hbWV9JyAoJHtlLmR0eXBlfSkuYCl9fXZhciBDbD1jbGFzcyBOMntjb25zdHJ1Y3Rvcih0KXtpZih0aGlzLmlkMlZhbHVlPXt9LHRoaXMuaWQyTWFzaz17fSx0aGlzLm5hbWUySWQ9e30sdCBpbnN0YW5jZW9mIE4yKWZvcihsZXQgbiBpbiB0LmlkMlZhbHVlKXRoaXMuaWQyVmFsdWVbbl09dC5pZDJWYWx1ZVtuXSxuIGluIHQuaWQyTWFzayYmKHRoaXMuaWQyTWFza1tuXT10LmlkMk1hc2tbbl0pO2Vsc2V7aWYodD09bnVsbClyZXR1cm47Zm9yKGxldCBuIG9mIHQpdGhpcy5hZGQobi5rZXksbi52YWx1ZSl9fWFkZCh0LG4sYSl7aWYodGhpcy5pZDJWYWx1ZVt0LmlkXT09bnVsbCl0aGlzLmlkMlZhbHVlW3QuaWRdPWpHKHQsbiksdGhpcy5uYW1lMklkW3QubmFtZV09dC5pZCxhIT1udWxsJiYodGhpcy5pZDJNYXNrW3QuaWRdPWEpO2Vsc2UgdGhyb3cgbmV3IFYoYER1cGxpY2F0ZSBrZXk6IG5hbWU9JHt0Lm5hbWV9LCBpZD0ke3QuaWR9YCk7cmV0dXJuIHRoaXN9YWRkRmVlZCh0KXt0aGlzLmFkZCh0LmtleSx0LnZhbHVlKX1oYXNLZXkodCl7cmV0dXJuIHRoaXMuaWQyVmFsdWVbdC5pZF0hPW51bGx9bmFtZXMoKXtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5uYW1lMklkKX1nZXRWYWx1ZSh0KXtpZih0IGluc3RhbmNlb2YgSGEpe2lmKHRoaXMuaWQyVmFsdWVbdC5pZF09PW51bGwpdGhyb3cgbmV3IFYoYE5vbmV4aXN0ZW50IGtleTogJHt0Lm5hbWV9YCk7cmV0dXJuIHRoaXMuaWQyVmFsdWVbdC5pZF19ZWxzZXtsZXQgbj10aGlzLm5hbWUySWRbdF07aWYobj09bnVsbCl0aHJvdyBuZXcgVihgRmVlZCBkaWN0IGhhcyBubyBTeW1ib2xpY1RlbnNvciBuYW1lOiAke3R9YCk7cmV0dXJuIHRoaXMuaWQyVmFsdWVbbl19fWdldE1hc2sodCl7aWYodCBpbnN0YW5jZW9mIEhhKXtpZih0aGlzLmlkMlZhbHVlW3QuaWRdPT1udWxsKXRocm93IG5ldyBWKGBOb25leGlzdGVudCBrZXk6ICR7dC5uYW1lfWApO3JldHVybiB0aGlzLmlkMk1hc2tbdC5pZF19ZWxzZXtsZXQgbj10aGlzLm5hbWUySWRbdF07aWYobj09bnVsbCl0aHJvdyBuZXcgVihgRmVlZCBkaWN0IGhhcyBubyBTeW1ib2xpY1RlbnNvciBuYW1lOiAke3R9YCk7cmV0dXJuIHRoaXMuaWQyTWFza1tuXX19ZGlzcG9zZU1hc2tzKCl7dGhpcy5pZDJNYXNrIT1udWxsJiZFZSh0aGlzLmlkMk1hc2spfX0sUWg9bmV3IGQyLGVtPW5ldyBkMjtmdW5jdGlvbiBxRyhlKXtRaCE9bnVsbCYmUWguc2V0TWF4RW50cmllcyhlKSxlbSE9bnVsbCYmZW0uc2V0TWF4RW50cmllcyhlKX1mdW5jdGlvbiB0YyhlLHQsbixhKXtsZXQgcj1uPT1udWxsPyExOm4udHJhaW5pbmcscz1BcnJheS5pc0FycmF5KGUpLGk9cz9lOltlXSxvPWkubWFwKG09Pm0ubmFtZSksbD1bXSx1PXQubmFtZXMoKTtmb3IobGV0IG0gb2Ygbyl1LmluZGV4T2YobSkhPT0tMT9sLnB1c2godC5nZXRWYWx1ZShtKSk6bC5wdXNoKG51bGwpO2EhPW51bGwmJihhLm1heE51bVRlbnNvcnM9LTEvMCxhLm1pbk51bVRlbnNvcnM9MS8wKTtsZXQgcD1vLmpvaW4oXCIsXCIpK1wifFwiK3QubmFtZXMoKS5zb3J0KCkuam9pbihcIixcIiksZD1RaC5nZXQocCksYztpZihkPT1udWxsKXtsZXQgbT1LRyhpLHQpO2Q9bS5zb3J0ZWQsYz1tLnJlY2lwaWVudENvdW50cyxRaC5wdXQocCxkKSxlbS5wdXQocCxjKX1jPXt9LHJ8fE9iamVjdC5hc3NpZ24oYyxlbS5nZXQocCkpO2xldCBoPW5ldyBDbCh0KTtmb3IobGV0IG09MDttPGQubGVuZ3RoOysrbSl7aWYoYSE9bnVsbCl7bGV0IEY9S2goKS5udW1UZW5zb3JzO0Y+YS5tYXhOdW1UZW5zb3JzJiYoYS5tYXhOdW1UZW5zb3JzPUYpLEY8YS5taW5OdW1UZW5zb3JzJiYoYS5taW5OdW1UZW5zb3JzPUYpfWxldCBmPWRbbV0sZz1mLnNvdXJjZUxheWVyO2lmKGcgaW5zdGFuY2VvZiBycCljb250aW51ZTtsZXQgYj1bXSx5PVtdLHg9W10sdj0hMTtmb3IobGV0IEYgb2YgZi5pbnB1dHMpe2xldCBEPWguZ2V0VmFsdWUoRiksJD1oLmdldE1hc2soRik7Yi5wdXNoKEQpLHkucHVzaCgkKSwkIT1udWxsJiYodj0hMCkscnx8KGNbRi5uYW1lXS0tLGNbRi5uYW1lXT09PTAmJiF0Lmhhc0tleShGKSYmby5pbmRleE9mKEYubmFtZSk9PT0tMSYmIUQuaXNEaXNwb3NlZCYmRi5zb3VyY2VMYXllci5zdGF0ZWZ1bCE9PSEwJiZ4LnB1c2goRCkpfXYmJihuPW58fHt9LG4ubWFzaz15WzBdKTtsZXQgST1pdChnLmFwcGx5KGIsbikpLE49bnVsbDtnLnN1cHBvcnRzTWFza2luZyYmKE49Zy5jb21wdXRlTWFzayhiLHkpKTtsZXQgQz1ZRyhmKSxfPUFycmF5LmlzQXJyYXkoQyk/QzpbQ107Zm9yKGxldCBGPTA7RjxfLmxlbmd0aDsrK0Ype2guaGFzS2V5KF9bRl0pfHxoLmFkZChfW0ZdLElbRl0sQXJyYXkuaXNBcnJheShOKT9OWzBdOk4pO2xldCBEPW8uaW5kZXhPZihfW0ZdLm5hbWUpO0QhPT0tMSYmKGxbRF09SVtGXSl9cnx8RWUoeCl9cmV0dXJuIGguZGlzcG9zZU1hc2tzKCkscz9sOmxbMF19ZnVuY3Rpb24gS0coZSx0KXt3LmFzc2VydChlIT1udWxsJiZlLmxlbmd0aD4wLCgpPT5cIkV4cGVjdGVkIGF0IGxlYXN0IG9uZSBmZXRjaCwgZ290IG5vbmVcIik7bGV0IG49W10sYT17fTtpZihlLmxlbmd0aD09PTEpe2xldCByPXdJKGVbMF0sdCk7bj1yLnNvcnRlZCxhPXIucmVjaXBpZW50TWFwfWVsc2V7bGV0IHI9bmV3IFNldDtmb3IobGV0IHMgb2YgZSl7bGV0e3NvcnRlZDppLHJlY2lwaWVudE1hcDpvfT13SShzLHQpO2ZvcihsZXQgbCBvZiBpKXIuaGFzKGwubmFtZSl8fChuLnB1c2gobCksci5hZGQobC5uYW1lKSk7Zm9yKGxldCBsIGluIG8pYVtsXT09bnVsbCYmKGFbbF09bmV3IFNldCksb1tsXS5mb3JFYWNoKHU9PmFbbF0uYWRkKHUpKX19cmV0dXJue3NvcnRlZDpuLHJlY2lwaWVudENvdW50czpYRyhhKX19ZnVuY3Rpb24gWEcoZSl7bGV0IHQ9e307Zm9yKGxldCBuIGluIGUpdFtuXT1lW25dLnNpemU7cmV0dXJuIHR9ZnVuY3Rpb24gd0koZSx0KXtsZXQgbj1uZXcgU2V0LGE9W10scj17fTtmb3IobGV0IG8gb2YgdC5uYW1lcygpKW4uYWRkKG8pO2xldCBzPVtdLGk9W107Zm9yKHMucHVzaChlKTtzLmxlbmd0aD4wOyl7bGV0IG89c1tzLmxlbmd0aC0xXTtpZihuLmhhcyhvLm5hbWUpKXtzLnBvcCgpO2NvbnRpbnVlfWxldCBsPWlbaS5sZW5ndGgtMV09PT1zLmxlbmd0aC0xO2lmKG8uaW5wdXRzLmxlbmd0aD09PTB8fGwpcy5wb3AoKSxhLnB1c2gobyksbi5hZGQoby5uYW1lKSxsJiZpLnBvcCgpO2Vsc2V7aS5wdXNoKHMubGVuZ3RoLTEpO2ZvcihsZXQgdSBvZiBvLmlucHV0cylyW3UubmFtZV09PW51bGwmJihyW3UubmFtZV09bmV3IFNldCksclt1Lm5hbWVdLmFkZChvLm5hbWUpLCFuLmhhcyh1Lm5hbWUpJiZzLnB1c2godSl9fXJldHVybntzb3J0ZWQ6YSxyZWNpcGllbnRNYXA6cn19ZnVuY3Rpb24gWUcoZSl7bGV0IHQ7aWYoZS5zb3VyY2VMYXllci5pbmJvdW5kTm9kZXMubGVuZ3RoPT09MSl0PWUuc291cmNlTGF5ZXIub3V0cHV0O2Vsc2V7bGV0IG49bnVsbDtmb3IobGV0IGE9MDthPGUuc291cmNlTGF5ZXIuaW5ib3VuZE5vZGVzLmxlbmd0aDsrK2EpZm9yKGxldCByIG9mIGUuc291cmNlTGF5ZXIuaW5ib3VuZE5vZGVzW2FdLm91dHB1dFRlbnNvcnMpaWYoci5pZD09PWUuaWQpe249YTticmVha310PWUuc291cmNlTGF5ZXIuZ2V0T3V0cHV0QXQobil9cmV0dXJuIHR9dmFyIFpHPUcoKTtaRy5yZWdpc3RlckZsYWcoXCJUT1BPTE9HSUNBTF9TT1JUX0NBQ0hFX01BWF9FTlRSSUVTXCIsKCk9PjEwMCxxRyk7dmFyIFQyPXt9O19lKFQyLHttYXhOb3JtOigpPT5KRyxtaW5NYXhOb3JtOigpPT50SCxub25OZWc6KCk9PmVILHVuaXROb3JtOigpPT5RR30pO2Z1bmN0aW9uIHAwKGUsdCl7cmV0dXJuIE8oKCk9PnJuKGZlKHooZSxlKSx0LCEwKSkpfXZhciBTZD1jbGFzcyBleHRlbmRzIG5lLlNlcmlhbGl6YWJsZXtnZXRDb25maWcoKXtyZXR1cm57fX19LGMwPWNsYXNzIGV4dGVuZHMgU2R7Y29uc3RydWN0b3IoZSl7c3VwZXIoKSx0aGlzLmRlZmF1bHRNYXhWYWx1ZT0yLHRoaXMuZGVmYXVsdEF4aXM9MCx0aGlzLm1heFZhbHVlPWUubWF4VmFsdWUhPW51bGw/ZS5tYXhWYWx1ZTp0aGlzLmRlZmF1bHRNYXhWYWx1ZSx0aGlzLmF4aXM9ZS5heGlzIT1udWxsP2UuYXhpczp0aGlzLmRlZmF1bHRBeGlzfWFwcGx5KGUpe3JldHVybiBPKCgpPT57bGV0IHQ9cDAoZSx0aGlzLmF4aXMpLG49YW4odCwwLHRoaXMubWF4VmFsdWUpO3JldHVybiB6KGUsaGUobixYKHF0KCksdCkpKX0pfWdldENvbmZpZygpe3JldHVybnttYXhWYWx1ZTp0aGlzLm1heFZhbHVlLGF4aXM6dGhpcy5heGlzfX19O2MwLmNsYXNzTmFtZT1cIk1heE5vcm1cIjtuZS5yZWdpc3RlckNsYXNzKGMwKTt2YXIgZDA9Y2xhc3MgZXh0ZW5kcyBTZHtjb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMuZGVmYXVsdEF4aXM9MCx0aGlzLmF4aXM9ZS5heGlzIT1udWxsP2UuYXhpczp0aGlzLmRlZmF1bHRBeGlzfWFwcGx5KGUpe3JldHVybiBPKCgpPT5oZShlLFgocXQoKSxwMChlLHRoaXMuYXhpcykpKSl9Z2V0Q29uZmlnKCl7cmV0dXJue2F4aXM6dGhpcy5heGlzfX19O2QwLmNsYXNzTmFtZT1cIlVuaXROb3JtXCI7bmUucmVnaXN0ZXJDbGFzcyhkMCk7dmFyIGgwPWNsYXNzIGV4dGVuZHMgU2R7YXBwbHkoZSl7cmV0dXJuIEtlKGUpfX07aDAuY2xhc3NOYW1lPVwiTm9uTmVnXCI7bmUucmVnaXN0ZXJDbGFzcyhoMCk7dmFyIG0wPWNsYXNzIGV4dGVuZHMgU2R7Y29uc3RydWN0b3IoZSl7c3VwZXIoKSx0aGlzLmRlZmF1bHRNaW5WYWx1ZT0wLHRoaXMuZGVmYXVsdE1heFZhbHVlPTEsdGhpcy5kZWZhdWx0UmF0ZT0xLHRoaXMuZGVmYXVsdEF4aXM9MCx0aGlzLm1pblZhbHVlPWUubWluVmFsdWUhPW51bGw/ZS5taW5WYWx1ZTp0aGlzLmRlZmF1bHRNaW5WYWx1ZSx0aGlzLm1heFZhbHVlPWUubWF4VmFsdWUhPW51bGw/ZS5tYXhWYWx1ZTp0aGlzLmRlZmF1bHRNYXhWYWx1ZSx0aGlzLnJhdGU9ZS5yYXRlIT1udWxsP2UucmF0ZTp0aGlzLmRlZmF1bHRSYXRlLHRoaXMuYXhpcz1lLmF4aXMhPW51bGw/ZS5heGlzOnRoaXMuZGVmYXVsdEF4aXN9YXBwbHkoZSl7cmV0dXJuIE8oKCk9PntsZXQgdD1wMChlLHRoaXMuYXhpcyksbj1YKHoodGhpcy5yYXRlLGFuKHQsdGhpcy5taW5WYWx1ZSx0aGlzLm1heFZhbHVlKSkseigxLXRoaXMucmF0ZSx0KSk7cmV0dXJuIHooZSxoZShuLFgocXQoKSx0KSkpfSl9Z2V0Q29uZmlnKCl7cmV0dXJue21pblZhbHVlOnRoaXMubWluVmFsdWUsbWF4VmFsdWU6dGhpcy5tYXhWYWx1ZSxyYXRlOnRoaXMucmF0ZSxheGlzOnRoaXMuYXhpc319fTttMC5jbGFzc05hbWU9XCJNaW5NYXhOb3JtXCI7bmUucmVnaXN0ZXJDbGFzcyhtMCk7dmFyIGtJPXttYXhOb3JtOlwiTWF4Tm9ybVwiLG1pbk1heE5vcm06XCJNaW5NYXhOb3JtXCIsbm9uTmVnOlwiTm9uTmVnXCIsdW5pdE5vcm06XCJVbml0Tm9ybVwifTtmdW5jdGlvbiBYdChlKXtyZXR1cm4gUXcoZSl9ZnVuY3Rpb24gSUkoZSx0PXt9KXtyZXR1cm4gdmQoZSxuZS5TZXJpYWxpemF0aW9uTWFwLmdldE1hcCgpLmNsYXNzTmFtZU1hcCx0LFwiY29uc3RyYWludFwiKX1mdW5jdGlvbiBZdChlKXtpZihlPT1udWxsKXJldHVybiBudWxsO2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiKXtsZXQgdD17Y2xhc3NOYW1lOmUgaW4ga0k/a0lbZV06ZSxjb25maWc6e319O3JldHVybiBJSSh0KX1lbHNlIHJldHVybiBlIGluc3RhbmNlb2YgU2Q/ZTpJSShlKX1mdW5jdGlvbiBKRyhlKXtyZXR1cm4gbmV3IGMwKGUpfWZ1bmN0aW9uIFFHKGUpe3JldHVybiBuZXcgZDAoZSl9ZnVuY3Rpb24gZUgoKXtyZXR1cm4gbmV3IGgwfWZ1bmN0aW9uIHRIKGUpe3JldHVybiBuZXcgbTAoZSl9dmFyIEMyPXt9O19lKEMyLHtjb25zdGFudDooKT0+ckgsZ2xvcm90Tm9ybWFsOigpPT5jSCxnbG9yb3RVbmlmb3JtOigpPT5wSCxoZU5vcm1hbDooKT0+ZEgsaGVVbmlmb3JtOigpPT5oSCxpZGVudGl0eTooKT0+bEgsbGVDdW5Ob3JtYWw6KCk9Pm1ILGxlQ3VuVW5pZm9ybTooKT0+Zkgsb25lczooKT0+YUgsb3J0aG9nb25hbDooKT0+Z0gscmFuZG9tTm9ybWFsOigpPT5pSCxyYW5kb21Vbmlmb3JtOigpPT5zSCx0cnVuY2F0ZWROb3JtYWw6KCk9Pm9ILHZhcmlhbmNlU2NhbGluZzooKT0+dUgsemVyb3M6KCk9Pm5IfSk7ZnVuY3Rpb24gbkgoKXtyZXR1cm4gbmV3IG4wfWZ1bmN0aW9uIGFIKCl7cmV0dXJuIG5ldyB5Zn1mdW5jdGlvbiBySChlKXtyZXR1cm4gbmV3IGEwKGUpfWZ1bmN0aW9uIHNIKGUpe3JldHVybiBuZXcgcjAoZSl9ZnVuY3Rpb24gaUgoZSl7cmV0dXJuIG5ldyBzMChlKX1mdW5jdGlvbiBvSChlKXtyZXR1cm4gbmV3IGkwKGUpfWZ1bmN0aW9uIGxIKGUpe3JldHVybiBuZXcgbzAoZSl9ZnVuY3Rpb24gdUgoZSl7cmV0dXJuIG5ldyBCbihlKX1mdW5jdGlvbiBwSChlKXtyZXR1cm4gbmV3IHhmKGUpfWZ1bmN0aW9uIGNIKGUpe3JldHVybiBuZXcgdmYoZSl9ZnVuY3Rpb24gZEgoZSl7cmV0dXJuIG5ldyB3ZihlKX1mdW5jdGlvbiBoSChlKXtyZXR1cm4gbmV3IGtmKGUpfWZ1bmN0aW9uIG1IKGUpe3JldHVybiBuZXcgSWYoZSl9ZnVuY3Rpb24gZkgoZSl7cmV0dXJuIG5ldyBTZihlKX1mdW5jdGlvbiBnSChlKXtyZXR1cm4gbmV3IGwwKGUpfXZhciBFMj17fTtfZShFMix7TGF5ZXI6KCk9PldlLFJOTjooKT0+TXIsUk5OQ2VsbDooKT0+VGQsYWN0aXZhdGlvbjooKT0+cWosYWRkOigpPT5uNixhbHBoYURyb3BvdXQ6KCk9Pno2LGF2ZXJhZ2U6KCk9PmE2LGF2ZXJhZ2VQb29saW5nMWQ6KCk9PlQxLGF2ZXJhZ2VQb29saW5nMmQ6KCk9PkMxLGF2ZXJhZ2VQb29saW5nM2Q6KCk9PkUxLGF2Z1Bvb2wxZDooKT0+ZDYsYXZnUG9vbDJkOigpPT5tNixhdmdQb29sM2Q6KCk9Pmc2LGF2Z1Bvb2xpbmcxZDooKT0+aDYsYXZnUG9vbGluZzJkOigpPT5mNixhdmdQb29saW5nM2Q6KCk9PmI2LGJhdGNoTm9ybWFsaXphdGlvbjooKT0+dTYsYmlkaXJlY3Rpb25hbDooKT0+RjYsY2F0ZWdvcnlFbmNvZGluZzooKT0+RzYsY2VudGVyQ3JvcDooKT0+VjYsY29uY2F0ZW5hdGU6KCk9PnI2LGNvbnYxZDooKT0+TGosY29udjJkOigpPT56aixjb252MmRUcmFuc3Bvc2U6KCk9PldqLGNvbnYzZDooKT0+QmosY29udjNkVHJhbnNwb3NlOigpPT5Waixjb252THN0bTJkOigpPT5DNixjb252THN0bTJkQ2VsbDooKT0+RTYsY3JvcHBpbmcyRDooKT0+R2osZGVuc2U6KCk9PktqLGRlcHRod2lzZUNvbnYyZDooKT0+amosZG90OigpPT5sNixkcm9wb3V0OigpPT5YaixlbHU6KCk9PiRqLGVtYmVkZGluZzooKT0+dDYsZmxhdHRlbjooKT0+WmosZ2F1c3NpYW5Ecm9wb3V0OigpPT5MNixnYXVzc2lhbk5vaXNlOigpPT5QNixnbG9iYWxBdmVyYWdlUG9vbGluZzFkOigpPT55NixnbG9iYWxBdmVyYWdlUG9vbGluZzJkOigpPT54NixnbG9iYWxNYXhQb29sMWQ6KCk9PkQ2LGdsb2JhbE1heFBvb2wyZDooKT0+UjYsZ2xvYmFsTWF4UG9vbGluZzFkOigpPT5BQyxnbG9iYWxNYXhQb29saW5nMmQ6KCk9PkZDLGdydTooKT0+dzYsZ3J1Q2VsbDooKT0+azYsaW5wdXQ6KCk9PmoyLGlucHV0TGF5ZXI6KCk9PkZqLGxheWVyTm9ybWFsaXphdGlvbjooKT0+cDYsbGVha3lSZUxVOigpPT5Saixsc3RtOigpPT5JNixsc3RtQ2VsbDooKT0+UzYsbWFza2luZzooKT0+VzYsbWF4UG9vbDFkOigpPT5NNixtYXhQb29sMmQ6KCk9Pk82LG1heFBvb2xpbmcxZDooKT0+JEMsbWF4UG9vbGluZzJkOigpPT5EQyxtYXhQb29saW5nM2Q6KCk9PnY2LG1heGltdW06KCk9PnM2LG1pbmltdW06KCk9Pmk2LG11bHRpcGx5OigpPT5vNixwZXJtdXRlOigpPT5lNixwcmVsdTooKT0+TWoscmFuZG9tV2lkdGg6KCk9Pkg2LHJlTFU6KCk9PkRqLHJlcGVhdFZlY3RvcjooKT0+SmoscmVzY2FsaW5nOigpPT5CNixyZXNoYXBlOigpPT5RaixyZXNpemluZzooKT0+VTYscm5uOigpPT5fNixzZXBhcmFibGVDb252MmQ6KCk9PlVqLHNpbXBsZVJOTjooKT0+TjYsc2ltcGxlUk5OQ2VsbDooKT0+VDYsc29mdG1heDooKT0+T2osc3BhdGlhbERyb3BvdXQxZDooKT0+WWosc3RhY2tlZFJOTkNlbGxzOigpPT5BNix0aHJlc2hvbGRlZFJlTFU6KCk9PlBqLHRpbWVEaXN0cmlidXRlZDooKT0+JDYsdXBTYW1wbGluZzJkOigpPT5Iaix6ZXJvUGFkZGluZzJkOigpPT5jNn0pO2FzeW5jIGZ1bmN0aW9uIEtyKGUpe2lmKGU9PW51bGwpcmV0dXJuO2xldCB0PVtdLG49W10sYT1bXTtmb3IobGV0IHIgaW4gZSl7bGV0IHM9ZVtyXTtpZih0eXBlb2YgcyE9XCJudW1iZXJcIil7bGV0IGk9czt0LnB1c2goaS5kYXRhKCkpLG4ucHVzaChyKSxhLnB1c2goaSl9fWlmKHQubGVuZ3RoPjApe2xldCByPWF3YWl0IFByb21pc2UuYWxsKHQpO2ZvcihsZXQgcz0wO3M8ci5sZW5ndGg7KytzKWVbbltzXV09cltzXVswXTtFZShhKX19ZnVuY3Rpb24gXzIoZSl7aWYoZSE9bnVsbClmb3IobGV0IHQgaW4gZSl7bGV0IG49ZVt0XTt0eXBlb2YgbiE9XCJudW1iZXJcIiYmbi5kaXNwb3NlKCl9fXZhciBTSTsoZnVuY3Rpb24oZSl7ZVtlLlNJTEVOVD0wXT1cIlNJTEVOVFwiLGVbZS5WRVJCT1NFPTFdPVwiVkVSQk9TRVwifSkoU0l8fChTST17fSkpO3ZhciBiSD0xMjUsR2w9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLnZhbGlkYXRpb25EYXRhPW51bGx9c2V0UGFyYW1zKGUpe3RoaXMucGFyYW1zPWV9YXN5bmMgb25FcG9jaEJlZ2luKGUsdCl7fWFzeW5jIG9uRXBvY2hFbmQoZSx0KXt9YXN5bmMgb25CYXRjaEJlZ2luKGUsdCl7fWFzeW5jIG9uQmF0Y2hFbmQoZSx0KXt9YXN5bmMgb25UcmFpbkJlZ2luKGUpe31hc3luYyBvblRyYWluRW5kKGUpe31zZXRNb2RlbChlKXt9fSxBMj1jbGFzc3tjb25zdHJ1Y3RvcihlLHQ9MTApe2U9PW51bGwmJihlPVtdKSx0aGlzLmNhbGxiYWNrcz1lLHRoaXMucXVldWVMZW5ndGg9dH1hcHBlbmQoZSl7dGhpcy5jYWxsYmFja3MucHVzaChlKX1zZXRQYXJhbXMoZSl7Zm9yKGxldCB0IG9mIHRoaXMuY2FsbGJhY2tzKXQuc2V0UGFyYW1zKGUpfXNldE1vZGVsKGUpe2ZvcihsZXQgdCBvZiB0aGlzLmNhbGxiYWNrcyl0LnNldE1vZGVsKGUpfWFzeW5jIG9uRXBvY2hCZWdpbihlLHQpe3Q9PW51bGwmJih0PXt9KTtmb3IobGV0IG4gb2YgdGhpcy5jYWxsYmFja3MpYXdhaXQgbi5vbkVwb2NoQmVnaW4oZSx0KX1hc3luYyBvbkVwb2NoRW5kKGUsdCl7dD09bnVsbCYmKHQ9e30pO2ZvcihsZXQgbiBvZiB0aGlzLmNhbGxiYWNrcylhd2FpdCBuLm9uRXBvY2hFbmQoZSx0KX1hc3luYyBvbkJhdGNoQmVnaW4oZSx0KXt0PT1udWxsJiYodD17fSk7Zm9yKGxldCBuIG9mIHRoaXMuY2FsbGJhY2tzKWF3YWl0IG4ub25CYXRjaEJlZ2luKGUsdCl9YXN5bmMgb25CYXRjaEVuZChlLHQpe3Q9PW51bGwmJih0PXt9KTtmb3IobGV0IG4gb2YgdGhpcy5jYWxsYmFja3MpYXdhaXQgbi5vbkJhdGNoRW5kKGUsdCl9YXN5bmMgb25UcmFpbkJlZ2luKGUpe2U9PW51bGwmJihlPXt9KTtmb3IobGV0IHQgb2YgdGhpcy5jYWxsYmFja3MpYXdhaXQgdC5vblRyYWluQmVnaW4oZSl9YXN5bmMgb25UcmFpbkVuZChlKXtlPT1udWxsJiYoZT17fSk7Zm9yKGxldCB0IG9mIHRoaXMuY2FsbGJhY2tzKWF3YWl0IHQub25UcmFpbkVuZChlKX19LHlIPWNsYXNzIGV4dGVuZHMgR2x7Y29uc3RydWN0b3IoKXtzdXBlcigpfWFzeW5jIG9uRXBvY2hCZWdpbihlKXt0aGlzLnNlZW49MCx0aGlzLnRvdGFscz17fX1hc3luYyBvbkJhdGNoRW5kKGUsdCl7dD09bnVsbCYmKHQ9e30pO2xldCBuPXQuc2l6ZT09bnVsbD8wOnQuc2l6ZTt0aGlzLnNlZW4rPW47Zm9yKGxldCBhIGluIHQpe2xldCByPXRbYV07aWYodHlwZW9mIHI9PVwibnVtYmVyXCIpdGhpcy50b3RhbHMuaGFzT3duUHJvcGVydHkoYSl8fCh0aGlzLnRvdGFsc1thXT0wKSx0aGlzLnRvdGFsc1thXT10aGlzLnRvdGFsc1thXStyKm47ZWxzZXtsZXQgczthIGluIHRoaXMudG90YWxzP3M9dGhpcy50b3RhbHNbYV06dGhpcy50b3RhbHNbYV09MDtsZXQgaT1PKCgpPT5YKHRoaXMudG90YWxzW2FdLHoocixuKSkpO3RoaXMudG90YWxzW2FdPWkscyE9bnVsbCYmcy5kaXNwb3NlKCl9fX1hc3luYyBvbkVwb2NoRW5kKGUsdCl7aWYodCE9bnVsbClmb3IobGV0IG4gb2YgdGhpcy5wYXJhbXMubWV0cmljcyl0aGlzLnRvdGFsc1tuXSE9bnVsbCYmKHR5cGVvZiB0aGlzLnRvdGFsc1tuXT09XCJudW1iZXJcIj90W25dPXRoaXMudG90YWxzW25dL3RoaXMuc2VlbjpPKCgpPT57bGV0IGE9eihoZSgxLHRoaXMuc2VlbiksdGhpcy50b3RhbHNbbl0pO3Rbbl09YSx0aGlzLnRvdGFsc1tuXS5kaXNwb3NlKCksSHQodFtuXSl9KSl9fSxGMj1jbGFzcyBleHRlbmRzIEdse2FzeW5jIG9uVHJhaW5CZWdpbihlKXt0aGlzLmVwb2NoPVtdLHRoaXMuaGlzdG9yeT17fX1hc3luYyBvbkVwb2NoRW5kKGUsdCl7dD09bnVsbCYmKHQ9e30pLHRoaXMuZXBvY2gucHVzaChlKTtmb3IobGV0IG4gaW4gdCl0aGlzLmhpc3Rvcnlbbl09PW51bGwmJih0aGlzLmhpc3Rvcnlbbl09W10pLHRoaXMuaGlzdG9yeVtuXS5wdXNoKHRbbl0pfWFzeW5jIHN5bmNEYXRhKCl7bGV0IGU9W10sdD1bXSxuPVtdO2ZvcihsZXQgciBpbiB0aGlzLmhpc3Rvcnkpe2xldCBzPXRoaXMuaGlzdG9yeVtyXTtmb3IobGV0IGk9MDtpPHMubGVuZ3RoOysraSlpZih0eXBlb2Ygc1tpXSE9XCJudW1iZXJcIil7bGV0IG89c1tpXTtlLnB1c2goby5kYXRhKCkpLHQucHVzaChyKSxuLnB1c2goaSl9fWxldCBhPWF3YWl0IFByb21pc2UuYWxsKGUpO2ZvcihsZXQgcj0wO3I8YS5sZW5ndGg7KytyKXRoaXMuaGlzdG9yeVt0W3JdXVtuW3JdXS5kaXNwb3NlKCksdGhpcy5oaXN0b3J5W3Rbcl1dW25bcl1dPWFbcl1bMF19fSwkMj1jbGFzcyBleHRlbmRzIEdse2NvbnN0cnVjdG9yKGUsdCl7aWYoc3VwZXIoKSx0aGlzLmN1cnJlbnRFcG9jaD0wLHRoaXMubm93RnVuYz1lLm5vd0Z1bmMsdGhpcy5uZXh0RnJhbWVGdW5jPWUubmV4dEZyYW1lRnVuY3x8WncsdGhpcy55aWVsZEV2ZXJ5PXR8fFwiYXV0b1wiLHRoaXMueWllbGRFdmVyeT09PVwiYXV0b1wiJiYodGhpcy55aWVsZEV2ZXJ5PWJIKSx0aGlzLnlpZWxkRXZlcnk9PT1cIm5ldmVyXCImJmUub25ZaWVsZCE9bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJ5aWVsZEV2ZXJ5IGlzIGBuZXZlcmAgYnV0IHlvdSBwcm92aWRlZCBhbiBgb25ZaWVsZGAgY2FsbGJhY2suIEVpdGhlciBjaGFuZ2UgYHlpZWxkRXZlcnlgIG9yIHJlbW92ZSB0aGUgY2FsbGJhY2tcIik7dy5pc051bWJlcih0aGlzLnlpZWxkRXZlcnkpJiYodGhpcy5tYXliZVdhaXQ9YkcodGhpcy5tYXliZVdhaXQuYmluZCh0aGlzKSx0aGlzLnlpZWxkRXZlcnksdGhpcy5ub3dGdW5jKSksdGhpcy50cmFpbkJlZ2luPWUub25UcmFpbkJlZ2luLHRoaXMudHJhaW5FbmQ9ZS5vblRyYWluRW5kLHRoaXMuZXBvY2hCZWdpbj1lLm9uRXBvY2hCZWdpbix0aGlzLmVwb2NoRW5kPWUub25FcG9jaEVuZCx0aGlzLmJhdGNoQmVnaW49ZS5vbkJhdGNoQmVnaW4sdGhpcy5iYXRjaEVuZD1lLm9uQmF0Y2hFbmQsdGhpcy55aWVsZD1lLm9uWWllbGR9YXN5bmMgbWF5YmVXYWl0KGUsdCxuKXtsZXQgYT1bXTt0aGlzLnlpZWxkIT1udWxsJiYoYXdhaXQgS3IobiksYS5wdXNoKHRoaXMueWllbGQoZSx0LG4pKSksYS5wdXNoKHRoaXMubmV4dEZyYW1lRnVuYygpKSxhd2FpdCBQcm9taXNlLmFsbChhKX1hc3luYyBvbkVwb2NoQmVnaW4oZSx0KXt0aGlzLmN1cnJlbnRFcG9jaD1lLHRoaXMuZXBvY2hCZWdpbiE9bnVsbCYmKGF3YWl0IEtyKHQpLGF3YWl0IHRoaXMuZXBvY2hCZWdpbihlLHQpKX1hc3luYyBvbkVwb2NoRW5kKGUsdCl7bGV0IG49W107dGhpcy5lcG9jaEVuZCE9bnVsbCYmKGF3YWl0IEtyKHQpLG4ucHVzaCh0aGlzLmVwb2NoRW5kKGUsdCkpKSx0aGlzLnlpZWxkRXZlcnk9PT1cImVwb2NoXCImJm4ucHVzaCh0aGlzLm5leHRGcmFtZUZ1bmMoKSksYXdhaXQgUHJvbWlzZS5hbGwobil9YXN5bmMgb25CYXRjaEJlZ2luKGUsdCl7dGhpcy5iYXRjaEJlZ2luIT1udWxsJiYoYXdhaXQgS3IodCksYXdhaXQgdGhpcy5iYXRjaEJlZ2luKGUsdCkpfWFzeW5jIG9uQmF0Y2hFbmQoZSx0KXtsZXQgbj1bXTt0aGlzLmJhdGNoRW5kIT1udWxsJiYoYXdhaXQgS3IodCksbi5wdXNoKHRoaXMuYmF0Y2hFbmQoZSx0KSkpLHRoaXMueWllbGRFdmVyeT09PVwiYmF0Y2hcIj9uLnB1c2godGhpcy5uZXh0RnJhbWVGdW5jKCkpOncuaXNOdW1iZXIodGhpcy55aWVsZEV2ZXJ5KSYmbi5wdXNoKHRoaXMubWF5YmVXYWl0KHRoaXMuY3VycmVudEVwb2NoLGUsdCkpLGF3YWl0IFByb21pc2UuYWxsKG4pfWFzeW5jIG9uVHJhaW5CZWdpbihlKXt0aGlzLnRyYWluQmVnaW4hPW51bGwmJihhd2FpdCBLcihlKSxhd2FpdCB0aGlzLnRyYWluQmVnaW4oZSkpfWFzeW5jIG9uVHJhaW5FbmQoZSl7dGhpcy50cmFpbkVuZCE9bnVsbCYmKGF3YWl0IEtyKGUpLGF3YWl0IHRoaXMudHJhaW5FbmQoZSkpfX07ZnVuY3Rpb24gRDIoZSx0KXtyZXR1cm4gZT09bnVsbCYmKGU9e30pLGUgaW5zdGFuY2VvZiBHbD9bZV06QXJyYXkuaXNBcnJheShlKSYmZVswXWluc3RhbmNlb2YgR2w/ZTppdChlKS5tYXAobj0+bmV3ICQyKG4sdCkpfXZhciBmMD1jbGFzcyBKYXtjb25zdHJ1Y3Rvcigpe31zdGF0aWMgcmVnaXN0ZXJDYWxsYmFja0NvbnN0cnVjdG9yKHQsbil7dy5hc3NlcnQodD49MCYmTnVtYmVyLmlzSW50ZWdlcih0KSwoKT0+YFZlcmJvc2l0eSBsZXZlbCBpcyBleHBlY3RlZCB0byBiZSBhbiBpbnRlZ2VyID49IDAsIGJ1dCBnb3QgJHt0fWApLEphLmNoZWNrRm9yRHVwbGljYXRlKG4pLEphLmNvbnN0cnVjdG9yc1t0XT09bnVsbCYmKEphLmNvbnN0cnVjdG9yc1t0XT1bXSksSmEuY29uc3RydWN0b3JzW3RdLnB1c2gobil9c3RhdGljIGNoZWNrRm9yRHVwbGljYXRlKHQpe2ZvcihsZXQgbiBpbiBKYS5jb25zdHJ1Y3RvcnMpSmEuY29uc3RydWN0b3JzWytuXS5mb3JFYWNoKGE9PntpZihhPT09dCl0aHJvdyBuZXcgVihcIkR1cGxpY2F0ZSBjYWxsYmFjayBjb25zdHJ1Y3Rvci5cIil9KX1zdGF0aWMgY2xlYXIoKXtKYS5jb25zdHJ1Y3RvcnM9e319c3RhdGljIGNyZWF0ZUNhbGxiYWNrcyh0KXtsZXQgbj1bXTtmb3IobGV0IGEgaW4gSmEuY29uc3RydWN0b3JzKXtsZXQgcj0rYTt0Pj1yJiZuLnB1c2goLi4uSmEuY29uc3RydWN0b3JzW3JdKX1yZXR1cm4gbi5tYXAoYT0+bmV3IGEpfX07ZjAuY29uc3RydWN0b3JzPXt9O2Z1bmN0aW9uIFIyKGUsdCxuLGEscixzLGksbyxsKXtsZXQgdT1uZXcgRjIscD1bbmV3IHlILC4uLmYwLmNyZWF0ZUNhbGxiYWNrcyh0KV07ZSE9bnVsbCYmcC5wdXNoKC4uLmUpLHAucHVzaCh1KTtsZXQgZD1uZXcgQTIocCk7cmV0dXJuIGQuc2V0UGFyYW1zKHtlcG9jaHM6bixpbml0aWFsRXBvY2g6YSxzYW1wbGVzOnIsc3RlcHM6cyxiYXRjaFNpemU6aSx2ZXJib3NlOnQsZG9WYWxpZGF0aW9uOm8sbWV0cmljczpsfSkse2NhbGxiYWNrTGlzdDpkLGhpc3Rvcnk6dX19ZnVuY3Rpb24gQmEoZSx0PXt9LG49ITEpe3JldHVybiB2ZChlLG5lLlNlcmlhbGl6YXRpb25NYXAuZ2V0TWFwKCkuY2xhc3NOYW1lTWFwLHQsXCJsYXllclwiLG4pfWZ1bmN0aW9uIHRtKGUsdCl7cmV0dXJuIE8oKCk9PntlLmR0eXBlIT09XCJmbG9hdDMyXCImJihlPXJlKGUsXCJmbG9hdDMyXCIpKTtsZXQgbj1mZShrZChlKSx0LCEwKSxhPXluKG4uc2hhcGUscXQoKSkscj1ybihocihuLGEpKTtyZXR1cm4gaGUoZSxyKX0pfWZ1bmN0aW9uIFhvKGUsdCl7cmV0dXJuIE8oKCk9PkN0KGtkKHBlKHQsZSkpLC0xKSl9ZnVuY3Rpb24gVGYoZSx0KXtyZXR1cm4gTygoKT0+Q3QoTHQocGUodCxlKSksLTEpKX1mdW5jdGlvbiBzcChlLHQpe3JldHVybiBPKCgpPT57bGV0IG49cGUoZSx0KSxhPWFuKEx0KGUpLHF0KCksTnVtYmVyLk1BWF9WQUxVRSkscj1MdChoZShuLGEpKTtyZXR1cm4geigxMDAsQ3QociwtMSkpfSl9ZnVuY3Rpb24geEgoZSx0KXtyZXR1cm4gTygoKT0+e2xldCBuPWFuKHQscXQoKSxOdW1iZXIuTUFYX1ZBTFVFKSxhPVFuKFgoMSxuKSkscj1hbihlLHF0KCksTnVtYmVyLk1BWF9WQUxVRSkscz1RbihYKDEscikpO3JldHVybiBDdChrZChwZShhLHMpKSwtMSl9KX1mdW5jdGlvbiB2SChlLHQpe3JldHVybiBPKCgpPT57bGV0IG49aHIoMCxwZSgxLHooZSx0KSkpO3JldHVybiBDdChrZChuKSwtMSl9KX1mdW5jdGlvbiB3SChlLHQpe3JldHVybiBPKCgpPT57bGV0IG49aHIoMCxwZSgxLHooZSx0KSkpO3JldHVybiBDdChuLC0xKX0pfWZ1bmN0aW9uIGtIKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbj1mZSh6KGUsdCksLTEpLGE9bWEoeihwZSgxLGUpLHQpLC0xKTtyZXR1cm4gaHIoMCxYKDEscGUoYSxuKSkpfSl9ZnVuY3Rpb24gSUgoZSx0KXtyZXR1cm4gTygoKT0+e2xldCBuPU1hdGgubG9nKDIpLGE9cGUodCxlKSxyPXBlKFgoYSxHbyh6KC0yLGEpKSksbik7cmV0dXJuIEN0KHIsLTEpfSl9ZnVuY3Rpb24ga2MoZSx0LG49ITEpe3JldHVybiBPKCgpPT57aWYobil0PXFhKHQpO2Vsc2V7bGV0IGE9ZmUodCx0LnNoYXBlLmxlbmd0aC0xLCEwKTt0PWhlKHQsYSl9cmV0dXJuIHQ9YW4odCxxdCgpLDEtcXQoKSkseXQoZmUoeihyZShlLFwiZmxvYXQzMlwiKSxRbih0KSksdC5zaGFwZS5sZW5ndGgtMSkpfSl9ZnVuY3Rpb24gbm0oZSx0LG49ITEpe3JldHVybiBPKCgpPT57bGV0IGE9cmUodHAoX0coZSkpLFwiaW50MzJcIik7dD1hbih0LHF0KCksMS1xdCgpKTtsZXQgcj10LnNoYXBlLHM9VyhMbChhLHJbci5sZW5ndGgtMV0pLHIpO3JldHVybiBrYyhzLHQsbil9KX1mdW5jdGlvbiBTSChlLHQpe2lmKCF3LmFycmF5c0VxdWFsKGUuc2hhcGUsdC5zaGFwZSkpdGhyb3cgbmV3IFYoYGxvZ2l0cyBhbmQgbGFiZWxzIG11c3QgaGF2ZSB0aGUgc2FtZSBzaGFwZSwgYnV0IGdvdCBzaGFwZXMgJHtKU09OLnN0cmluZ2lmeShlLnNoYXBlKX0gYW5kICR7SlNPTi5zdHJpbmdpZnkodC5zaGFwZSl9YCk7cmV0dXJuIE8oKCk9PntsZXQgbj1LZSh0KSxhPXl0KEx0KHQpKTtyZXR1cm4gWChwZShuLHoodCxlKSkscGQoZG4oYSkpKX0pfWZ1bmN0aW9uIENmKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbjtyZXR1cm4gbj1hbih0LHF0KCksMS1xdCgpKSxuPVFuKGhlKG4scGUoMSxuKSkpLEN0KFNIKGUsbiksLTEpfSl9ZnVuY3Rpb24gTkgoZSx0KXtyZXR1cm4gTygoKT0+e2xldCBuPWFuKGUscXQoKSwxKSxhPWFuKHQscXQoKSwxKTtyZXR1cm4gZmUoeihlLFFuKGhlKG4sYSkpKSwtMSl9KX1mdW5jdGlvbiBUSChlLHQpe3JldHVybiBPKCgpPT57bGV0IG49UW4oWChxdCgpLHQpKTtyZXR1cm4gQ3QocGUodCx6KGUsbikpLC0xKX0pfWZ1bmN0aW9uIGcwKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbj10bShlLC0xKSxhPXRtKHQsLTEpLHI9eihuLGEpO3JldHVybiB5dChmZShyLC0xKSl9KX12YXIgYW09e21lYW5TcXVhcmVkRXJyb3I6WG8sbWVhbkFic29sdXRlRXJyb3I6VGYsbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yOnNwLG1lYW5TcXVhcmVkTG9nYXJpdGhtaWNFcnJvcjp4SCxzcXVhcmVkSGluZ2U6dkgsaGluZ2U6d0gsY2F0ZWdvcmljYWxIaW5nZTprSCxsb2djb3NoOklILGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5OmtjLHNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5Om5tLGJpbmFyeUNyb3NzZW50cm9weTpDZixrdWxsYmFja0xlaWJsZXJEaXZlcmdlbmNlOk5ILHBvaXNzb246VEgsY29zaW5lUHJveGltaXR5OmcwfTtmdW5jdGlvbiBkeChlKXtpZih0eXBlb2YgZT09XCJzdHJpbmdcIil7aWYoZSBpbiBhbSlyZXR1cm4gYW1bZV07bGV0IHQ9YFVua25vd24gbG9zcyAke2V9YDt0aHJvdyBlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJzb2Z0bWF4Y3Jvc3NlbnRyb3B5XCIpJiYodD1gVW5rbm93biBsb3NzICR7ZX0uIFVzZSBcImNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5XCIgYXMgdGhlIHN0cmluZyBuYW1lIGZvciB0Zi5sb3NzZXMuc29mdG1heENyb3NzRW50cm9weWApLG5ldyBWKHQpfWVsc2UgcmV0dXJuIGV9ZnVuY3Rpb24gYjAoZSx0KXtyZXR1cm4gTygoKT0+e2xldCBuPXooLjUsZWEodCkpLGE9aXIoQ24odCxuKSxlLmR0eXBlKTtyZXR1cm4gQ3QoSm4oZSxhKSwtMSl9KX1mdW5jdGlvbiB5MChlLHQpe3JldHVybiBPKCgpPT5pcihKbihkaShlLC0xKSxkaSh0LC0xKSksXCJmbG9hdDMyXCIpKX1mdW5jdGlvbiBNMihlLHQpe3JldHVybiBPKCgpPT5yZShmZShfYShKbihlLDEpLEpuKHQsMSkpKSxcImZsb2F0MzJcIikpfWZ1bmN0aW9uIENIKGUsdCl7cmV0dXJuIE8oKCk9PnJlKGZlKF9hKEpuKGUsMSksSm4odCwwKSkpLFwiZmxvYXQzMlwiKSl9ZnVuY3Rpb24gRUgoZSx0KXtyZXR1cm4gTygoKT0+cmUoZmUoX2EoSm4oZSwwKSxKbih0LDEpKSksXCJmbG9hdDMyXCIpKX1mdW5jdGlvbiBPMihlLHQpe3JldHVybiBPKCgpPT57bGV0IG49TTIoZSx0KSxhPUVIKGUsdCkscj1YKG4sYSk7cmV0dXJuIHJlKG5uKENuKHIsMCksaGUobixyKSwwKSxcImZsb2F0MzJcIil9KX1mdW5jdGlvbiBfSChlLHQpe3JldHVybiBPKCgpPT57bGV0IG49TTIoZSx0KSxhPUNIKGUsdCkscj1YKG4sYSk7cmV0dXJuIHJlKG5uKENuKHIsMCksaGUobixyKSwwKSxcImZsb2F0MzJcIil9KX1mdW5jdGlvbiBQMihlLHQpe3JldHVybiBDZihlLHQpfWZ1bmN0aW9uIEwyKGUsdCl7cmV0dXJuIGUucmFuaz09PXQucmFuayYmKGU9QXMoZSxbZS5yYW5rLTFdKSksdD1kaSh0LC0xKSx0LmR0eXBlIT09ZS5kdHlwZSYmKHQ9cmUodCxlLmR0eXBlKSkscmUoSm4oZSx0KSxcImZsb2F0MzJcIil9ZnVuY3Rpb24gQUgoZSx0KXtyZXR1cm4gTygoKT0+e2xldCBuPWUuc3ViKHQpLnNxdWFyZSgpLnN1bSgpLGE9ZS5zdWIoZS5tZWFuKCkpLnNxdWFyZSgpLnN1bSgpO3JldHVybiB4ZSgxKS5zdWIobi5kaXYoYSkpfSl9dmFyIEZIPVhvLCRIPVhvLERIPVRmLFJIPVRmLE1IPXNwLE9IPXNwLHgwPWtjLFBIPWcwLHoyPW5tLHJtPXtiaW5hcnlBY2N1cmFjeTpiMCxjYXRlZ29yaWNhbEFjY3VyYWN5OnkwLHByZWNpc2lvbjpPMixjYXRlZ29yaWNhbENyb3NzZW50cm9weTp4MCxzcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weTp6Mixtc2U6RkgsTVNFOiRILG1hZTpESCxNQUU6UkgsbWFwZTpNSCxNQVBFOk9ILGNvc2luZTpQSH07ZnVuY3Rpb24gTEgoZSl7aWYodHlwZW9mIGU9PVwic3RyaW5nXCImJmUgaW4gcm0pcmV0dXJuIHJtW2VdO2lmKHR5cGVvZiBlIT1cInN0cmluZ1wiJiZlIT1udWxsKXJldHVybiBlO3Rocm93IG5ldyBWKGBVbmtub3duIG1ldHJpYyAke2V9YCl9ZnVuY3Rpb24gU2goZSl7aWYodHIoZSE9PW51bGwsYFVua25vd24gTG9zc09yTWV0cmljRm4gJHtlfWApLHR5cGVvZiBlPT1cInN0cmluZ1wiKXJldHVybiBlO3tsZXQgdDtmb3IobGV0IG4gb2YgT2JqZWN0LmtleXMoYW0pKWlmKGFtW25dPT09ZSl7dD1uO2JyZWFrfWlmKHQhPT12b2lkIDApcmV0dXJuIHQ7Zm9yKGxldCBuIG9mIE9iamVjdC5rZXlzKHJtKSlpZihybVtuXT09PWUpe3Q9bjticmVha31yZXR1cm4gdCE9PXZvaWQgMD90OmUubmFtZX19ZnVuY3Rpb24gekgoZSl7bGV0IHQ9e0FkYWdyYWQ6KCk9PlhzLmFkYWdyYWQoLjAxKSxBZGFkZWx0YTooKT0+WHMuYWRhZGVsdGEoMSwuOTUscXQoKSksQWRhbTooKT0+WHMuYWRhbSguMDAxLC45LC45OTkscXQoKSksQWRhbWF4OigpPT5Ycy5hZGFtYXgoLjAwMiwuOSwuOTk5LHF0KCksMCksUk1TUHJvcDooKT0+WHMucm1zcHJvcCguMDAxLC45LDAscXQoKSksU0dEOigpPT5Ycy5zZ2QoLjAxKX07aWYodC5hZGFncmFkPXQuQWRhZ3JhZCx0LmFkYWRlbHRhPXQuQWRhZGVsdGEsdC5hZGFtPXQuQWRhbSx0LmFkYW1heD10LkFkYW1heCx0LnJtc3Byb3A9dC5STVNQcm9wLHQuc2dkPXQuU0dELGUgaW4gdClyZXR1cm4gdFtlXSgpO3Rocm93IG5ldyBWKGBVbmtub3duIE9wdGltaXplciAke2V9YCl9ZnVuY3Rpb24gTkkoZSx0LG49ITEpe2lmKGU9PW51bGx8fHR5cGVvZiBlIT1cIm9iamVjdFwifHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkhPT1PYmplY3QucHJvdG90eXBlfHwhR3goZSkpdGhyb3cgbmV3IEVycm9yKFwiVXNlci1kZWZpbmVkIG1ldGFkYXRhIGlzIGV4cGVjdGVkIHRvIGJlIGEgSlNPTiBvYmplY3QsIGJ1dCBpcyBub3QuXCIpO2lmKG4pe2xldCBhPUpTT04uc3RyaW5naWZ5KGUpO2EubGVuZ3RoPjEwNDg1NzYmJmNvbnNvbGUud2FybihgVXNlci1kZWZpbmVkIG1ldGFkYXRhIG9mIG1vZGVsIFwiJHt0fVwiIGlzIHRvbyBsYXJnZSBpbiBzaXplIChsZW5ndGg9JHthLmxlbmd0aH0gd2hlbiBzZXJpYWxpemVkKS4gSXQgaXMgbm90IHJlY29tbWVuZGVkIHRvIHN0b3JlIHN1Y2ggbGFyZ2Ugb2JqZWN0cyBpbiB1c2VyLWRlZmluZWQgbWV0YWRhdGEuIFBsZWFzZSBtYWtlIHN1cmUgaXRzIHNlcmlhbGl6ZWQgbGVuZ3RoIGlzIDw9IDEwNDg1NzYuYCl9fWZ1bmN0aW9uIEd4KGUpe2lmKGU9PT1udWxsKXJldHVybiEwO2lmKHR5cGVvZiBlPT1cIm9iamVjdFwiKWlmKE9iamVjdC5nZXRQcm90b3R5cGVPZihlKT09PU9iamVjdC5wcm90b3R5cGUpe2xldCB0PU9iamVjdC5rZXlzKGUpO2ZvcihsZXQgbiBvZiB0KWlmKHR5cGVvZiBuIT1cInN0cmluZ1wifHwhR3goZVtuXSkpcmV0dXJuITE7cmV0dXJuITB9ZWxzZSBpZihBcnJheS5pc0FycmF5KGUpKXtmb3IobGV0IHQgb2YgZSlpZighR3godCkpcmV0dXJuITE7cmV0dXJuITB9ZWxzZSByZXR1cm4hMTtlbHNle2xldCB0PXR5cGVvZiBlO3JldHVybiB0PT09XCJzdHJpbmdcInx8dD09PVwibnVtYmVyXCJ8fHQ9PT1cImJvb2xlYW5cIn19ZnVuY3Rpb24gV0goZSx0LG4sYT1jb25zb2xlLmxvZyl7bGV0IHI9VkgoZSkscz1bXCJMYXllciAodHlwZSlcIixcIklucHV0IFNoYXBlXCIsXCJPdXRwdXQgc2hhcGVcIixcIlBhcmFtICNcIl07cj8odD10fHw5MCxuPW58fFsuMzIsLjYxLC44OSwxXSk6KHQ9dHx8MTE1LG49bnx8Wy4yNCwuNDgsLjcsLjgsMV0pLG5bbi5sZW5ndGgtMV08PTEmJihuPW4ubWFwKHA9Pk1hdGguZmxvb3IodCpwKSkpO2xldCBpO2lmKCFyKXtzLnB1c2goXCJSZWNlaXZlcyBpbnB1dHNcIiksaT1bXTtmb3IobGV0IHAgaW4gZS5ub2Rlc0J5RGVwdGgpaS5wdXNoKC4uLmUubm9kZXNCeURlcHRoW3BdKX1hKFwiX1wiLnJlcGVhdCh0KSksc20ocyxuLGEpLGEoXCI9XCIucmVwZWF0KHQpKTtsZXQgbz1lLmxheWVycztmb3IobGV0IHA9MDtwPG8ubGVuZ3RoOysrcClyP1VIKG9bcF0sbixhKTpHSChvW3BdLG4saSxhKSxhKChwPT09by5sZW5ndGgtMT9cIj1cIjpcIl9cIikucmVwZWF0KHQpKTtlLmNoZWNrVHJhaW5hYmxlV2VpZ2h0c0NvbnNpc3RlbmN5KCk7bGV0IGw9QkgoZSksdT1KaChlLm5vblRyYWluYWJsZVdlaWdodHMpO2EoYFRvdGFsIHBhcmFtczogJHtsK3V9YCksYShgVHJhaW5hYmxlIHBhcmFtczogJHtsfWApLGEoYE5vbi10cmFpbmFibGUgcGFyYW1zOiAke3V9YCksYShcIl9cIi5yZXBlYXQodCkpfWZ1bmN0aW9uIEJIKGUpe2xldCB0O3JldHVybiBlLmNvbGxlY3RlZFRyYWluYWJsZVdlaWdodHMhPW51bGw/dD1KaChlLmNvbGxlY3RlZFRyYWluYWJsZVdlaWdodHMpOnQ9SmgoZS50cmFpbmFibGVXZWlnaHRzKSx0fWZ1bmN0aW9uIFZIKGUpe2xldCB0PSEwLG49W10sYT1bXTtmb3IobGV0IHIgaW4gZS5ub2Rlc0J5RGVwdGgpbi5wdXNoKGUubm9kZXNCeURlcHRoW3JdKTtmb3IobGV0IHIgb2Ygbil7aWYoci5sZW5ndGg+MXx8ci5sZW5ndGg9PT0xJiZyWzBdLmluYm91bmRMYXllcnMubGVuZ3RoPjEpe3Q9ITE7YnJlYWt9YS5wdXNoKC4uLnIpfWlmKHQpZm9yKGxldCByIG9mIGUubGF5ZXJzKXtsZXQgcz0hMTtmb3IobGV0IGkgb2Ygci5pbmJvdW5kTm9kZXMpaWYoYS5pbmRleE9mKGkpIT09LTEpaWYocyl7dD0hMTticmVha31lbHNlIHM9ITA7aWYoIXQpYnJlYWt9cmV0dXJuIHR9ZnVuY3Rpb24gc20oZSx0LG49Y29uc29sZS5sb2cpe2xldCBhPVwiXCI7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDsrK3Ipcj4wJiYoYT1hLnNsaWNlKDAsYS5sZW5ndGgtMSkrXCIgXCIpLGErPWVbcl0sYT1hLnNsaWNlKDAsdFtyXSksYSs9XCIgXCIucmVwZWF0KHRbcl0tYS5sZW5ndGgpO24oYSl9ZnVuY3Rpb24gVUgoZSx0LG4pe2xldCBhLHI7dHJ5e3I9ZS5pbmJvdW5kTm9kZXMubWFwKGw9PkpTT04uc3RyaW5naWZ5KGwuaW5wdXRTaGFwZXMpKS5qb2luKFwiLFwiKX1jYXRjaChsKXtyPVwibXVsdGlwbGVcIn10cnl7YT1KU09OLnN0cmluZ2lmeShlLm91dHB1dFNoYXBlKX1jYXRjaChsKXthPVwibXVsdGlwbGVcIn1sZXQgcz1lLm5hbWUsaT1lLmdldENsYXNzTmFtZSgpLG89W2Ake3N9ICgke2l9KWAscixhLGUuY291bnRQYXJhbXMoKS50b1N0cmluZygpXTtzbShvLHQsbil9ZnVuY3Rpb24gR0goZSx0LG4sYSl7bGV0IHIsczt0cnl7cz1lLmluYm91bmROb2Rlcy5tYXAoZD0+SlNPTi5zdHJpbmdpZnkoZC5pbnB1dFNoYXBlcykpLmpvaW4oXCIsXCIpfWNhdGNoKGQpe3M9XCJtdWx0aXBsZVwifXRyeXtyPUpTT04uc3RyaW5naWZ5KGUub3V0cHV0U2hhcGUpfWNhdGNoKGQpe3I9XCJtdWx0aXBsZVwifWxldCBpPVtdO2ZvcihsZXQgZCBvZiBlLmluYm91bmROb2RlcylpZighKG4hPW51bGwmJm4ubGVuZ3RoPjAmJm4uaW5kZXhPZihkKT09PS0xKSlmb3IobGV0IGM9MDtjPGQuaW5ib3VuZExheWVycy5sZW5ndGg7KytjKXtsZXQgaD1kLmluYm91bmRMYXllcnNbY10ubmFtZSxtPWQubm9kZUluZGljZXNbY10sZj1kLnRlbnNvckluZGljZXNbY107aS5wdXNoKGAke2h9WyR7bX1dWyR7Zn1dYCl9bGV0IG89ZS5uYW1lLGw9ZS5nZXRDbGFzc05hbWUoKSx1PWkubGVuZ3RoPT09MD9cIlwiOmlbMF0scD1bYCR7b30gKCR7bH0pYCxzLHIsZS5jb3VudFBhcmFtcygpLnRvU3RyaW5nKCksdV07c20ocCx0LGEpO2ZvcihsZXQgZD0xO2Q8aS5sZW5ndGg7KytkKXNtKFtcIlwiLFwiXCIsXCJcIixcIlwiLGlbZF1dLHQsYSl9ZnVuY3Rpb24gVzIoZSx0LG4pe3JldHVybihlPT09XCJpbmJvdW5kTm9kZXNcInx8ZT09PVwib3V0cHV0TGF5ZXJzXCJ8fGU9PT1cImlucHV0TGF5ZXJzXCIpJiZ0PT09MCYmdHlwZW9mIG49PVwic3RyaW5nXCJ9ZnVuY3Rpb24gSWMoZSx0KXtpZihlPT09bnVsbClyZXR1cm4gbnVsbDtpZih0eXBlb2YgZT09XCJzdHJpbmdcIilyZXR1cm4gSnMoZSk7aWYodHlwZW9mIGU9PVwibnVtYmVyXCJ8fHR5cGVvZiBlPT1cImJvb2xlYW5cIilyZXR1cm4gZTtpZihlIGluc3RhbmNlb2YgQXJyYXkpe2xldCBuPVtdLGE9ZS5sZW5ndGg7Zm9yKGxldCByPTA7cjxhOysrcil7bGV0IHM9ZVtyXTtXMih0LHIscyk/bi5wdXNoKHMpOm4ucHVzaChJYyhzLHQpKX1yZXR1cm4gbn1lbHNle2xldCBuPXt9O2ZvcihsZXQgYSBvZiBPYmplY3Qua2V5cyhlKSl7bGV0IHI9ZVthXTtpZihhPT09XCJuYW1lXCImJnR5cGVvZiByPT1cInN0cmluZ1wiKW5bYV09cjtlbHNle2xldCBzPUpzKGEpO25bc109SWMocixzKX19cmV0dXJuIG59fWZ1bmN0aW9uIEh4KGUsdCl7aWYoZT09bnVsbClyZXR1cm4gbnVsbDtpZih0eXBlb2YgZT09XCJzdHJpbmdcIilyZXR1cm4gSXIoZSk7aWYodHlwZW9mIGU9PVwibnVtYmVyXCJ8fHR5cGVvZiBlPT1cImJvb2xlYW5cIilyZXR1cm4gZTtpZihlIGluc3RhbmNlb2YgQXJyYXkpe2xldCBuPVtdLGE9ZS5sZW5ndGg7Zm9yKGxldCByPTA7cjxhOysrcil7bGV0IHM9ZVtyXTtXMih0LHIscyk/bi5wdXNoKHMpOm4ucHVzaChIeChzLHQpKX1yZXR1cm4gbn1lbHNle2xldCBuPXt9O2ZvcihsZXQgYSBvZiBPYmplY3Qua2V5cyhlKSl7bGV0IHI9ZVthXSxzPUlyKGEpOyhhPT09XCJuYW1lXCJ8fGE9PT1cImNsYXNzTmFtZVwiKSYmdHlwZW9mIHI9PVwic3RyaW5nXCI/bltzXT1yOm5bc109SHgocixhKX1yZXR1cm4gbn19dmFyIHYwPVwiNC4yMi4wXCIsSEg9ZT0+e2xldCB0PU9iamVjdC5rZXlzKGUpO2lmKHQubGVuZ3RoPT09MClyZXR1cm4hMTtsZXQgbj10WzBdLnNwbGl0KFwiL1wiKTtyZXR1cm4haXNOYU4ocGFyc2VJbnQobltuLmxlbmd0aC0xXSwxMCkpfSxqSD1jbGFzcyBRYSBleHRlbmRzIFdle2NvbnN0cnVjdG9yKHQpe2lmKHN1cGVyKHt9KSx0aGlzLmNvbnRhaW5lck5vZGVzPW5ldyBTZXQsdGhpcy5uYW1lPXQubmFtZSx0aGlzLm5hbWU9PW51bGwpe2xldCB5PXRoaXMuZ2V0Q2xhc3NOYW1lKCkudG9Mb3dlckNhc2UoKTt0aGlzLm5hbWU9Z2YoeSl9aWYodGhpcy5zdXBwb3J0c01hc2tpbmc9ITEsdGhpcy50cmFpbmFibGVfPSEwLEFycmF5LmlzQXJyYXkodC5pbnB1dHMpP3RoaXMuaW5wdXRzPXQuaW5wdXRzLnNsaWNlKCk6dGhpcy5pbnB1dHM9W3QuaW5wdXRzXSxBcnJheS5pc0FycmF5KHQub3V0cHV0cyk/dGhpcy5vdXRwdXRzPXQub3V0cHV0cy5zbGljZSgpOnRoaXMub3V0cHV0cz1bdC5vdXRwdXRzXSxhcyh0aGlzLmlucHV0cykubGVuZ3RoIT09dGhpcy5pbnB1dHMubGVuZ3RoKXRocm93IG5ldyBWKGBUaGUgbGlzdCBvZiBpbnB1dHMgcGFzc2VkIHRvIHRoZSBtb2RlbCBpcyByZWR1bmRhbnQuIEFsbCBpbnB1dHMgc2hvdWxkIG9ubHkgYXBwZWFyIG9uY2UuIEZvdW5kOiAke3RoaXMuaW5wdXRzLm1hcCh5PT55Lm5hbWUpfWApO2FzKHRoaXMub3V0cHV0cykubGVuZ3RoIT09dGhpcy5vdXRwdXRzLmxlbmd0aCYmY29uc29sZS53YXJuKGBUaGUgbGlzdCBvZiBvdXRwdXRzIHBhc3NlZCB0byB0aGUgbW9kZWwgaXMgcmVkdW5kYW50LiBBbGwgb3V0cHV0cyBzaG91bGQgb25seSBhcHBlYXIgb25jZS4gRm91bmQ6ICR7dGhpcy5vdXRwdXRzLm1hcCh5PT55Lm5hbWUpfWApLHRoaXMuaW5wdXRMYXllcnM9W10sdGhpcy5pbnB1dExheWVyc05vZGVJbmRpY2VzPVtdLHRoaXMuaW5wdXRMYXllcnNUZW5zb3JJbmRpY2VzPVtdLHRoaXMub3V0cHV0TGF5ZXJzPVtdLHRoaXMub3V0cHV0TGF5ZXJzTm9kZUluZGljZXM9W10sdGhpcy5vdXRwdXRMYXllcnNUZW5zb3JJbmRpY2VzPVtdLHRoaXMubGF5ZXJzPVtdLHRoaXMuaW50ZXJuYWxDb250YWluZXJSZWZzPVtdO2ZvcihsZXQgeSBvZiB0aGlzLm91dHB1dHMpe2xldCB4PXkuc291cmNlTGF5ZXIsdj15Lm5vZGVJbmRleCxJPXkudGVuc29ySW5kZXg7dGhpcy5vdXRwdXRMYXllcnMucHVzaCh4KSx0aGlzLm91dHB1dExheWVyc05vZGVJbmRpY2VzLnB1c2godiksdGhpcy5vdXRwdXRMYXllcnNUZW5zb3JJbmRpY2VzLnB1c2goSSl9Zm9yKGxldCB5IG9mIHRoaXMuaW5wdXRzKXtsZXQgeD15LnNvdXJjZUxheWVyLHY9eS5ub2RlSW5kZXgsST15LnRlbnNvckluZGV4O3RyKHY9PT0wLFwiaW5wdXQgbGF5ZXIgaGFzID4xIG5vZGVzXCIpLHRyKEk9PT0wLFwiaW5wdXQgbGF5ZXIgaGFzID4xIHRlbnNvcnNcIiksdGhpcy5pbnB1dExheWVycy5wdXNoKHgpLHRoaXMuaW5wdXRMYXllcnNOb2RlSW5kaWNlcy5wdXNoKHYpLHRoaXMuaW5wdXRMYXllcnNUZW5zb3JJbmRpY2VzLnB1c2goSSl9dGhpcy5pbnB1dE5hbWVzPVtdLHRoaXMub3V0cHV0TmFtZXM9W10sdGhpcy5mZWVkSW5wdXRTaGFwZXM9W10sdGhpcy5mZWVkSW5wdXROYW1lcz1bXSx0aGlzLmZlZWRPdXRwdXROYW1lcz1bXTtmb3IobGV0IHk9MDt5PHRoaXMuaW5wdXRMYXllcnMubGVuZ3RoO3krKyl7bGV0IHg9dGhpcy5pbnB1dExheWVyc1t5XTtpZighKHggaW5zdGFuY2VvZiBycCkpdGhyb3cgbmV3IFR5cGVFcnJvcihgSW5wdXQgbGF5ZXJzIHRvIGEgTGF5ZXJzTW9kZWwgbXVzdCBiZSBJbnB1dExheWVyIG9iamVjdHMuIFJlY2VpdmVkIGlucHV0czogJHt0LmlucHV0c30uIElucHV0ICR7eX0gKDAtYmFzZWQpIG9yaWdpbmF0ZXMgZnJvbSBsYXllciB0eXBlICR7eC5nZXRDbGFzc05hbWUoKX0uYCk7dGhpcy5pbnB1dE5hbWVzLnB1c2goeC5uYW1lKSx0aGlzLmZlZWRJbnB1dFNoYXBlcy5wdXNoKHguYmF0Y2hJbnB1dFNoYXBlKSx0aGlzLmZlZWRJbnB1dE5hbWVzLnB1c2goeC5uYW1lKX1mb3IobGV0IHkgb2YgdGhpcy5vdXRwdXRMYXllcnMpdGhpcy5vdXRwdXROYW1lcy5wdXNoKHkubmFtZSk7dGhpcy5pbnRlcm5hbElucHV0U2hhcGVzPXRoaXMuaW5wdXRzLm1hcCh5PT55LnNoYXBlKSx0aGlzLmludGVybmFsT3V0cHV0U2hhcGVzPXRoaXMub3V0cHV0cy5tYXAoeT0+eS5zaGFwZSk7bGV0IG49e30sYT17fSxyPXt9LHM9e30saT17fSxvPVtdLGw9KHkseCx2LEksTixDKT0+eyhJPT1udWxsfHxOPT1udWxsfHxDPT1udWxsKSYmKEk9eS5zb3VyY2VMYXllcixOPXkubm9kZUluZGV4LEM9eS50ZW5zb3JJbmRleCk7bGV0IF89SS5pbmJvdW5kTm9kZXNbTl07aWYodi5pbmRleE9mKF8pIT09LTEpdGhyb3cgbmV3IGFyKGBUaGUgdGVuc29yICR7eS5uYW1lfSBhdCBsYXllciBcIiR7SS5uYW1lfVwiIGlzIHBhcnQgb2YgYSBjeWNsZS5gKTtpZih4LmluZGV4T2YoXykhPT0tMSlyZXR1cm47dGhpcy5jb250YWluZXJOb2Rlcy5hZGQoUWEubm9kZUtleShJLE4pKSxJLmlkIGluIGl8fChpW0kuaWRdPU9iamVjdC5rZXlzKGkpLmxlbmd0aCksdi5pbmRleE9mKF8pPT09LTEmJnYucHVzaChfKTtsZXQgRj1fLmluYm91bmRMYXllcnMubGVuZ3RoO2ZvcihsZXQgRD0wO0Q8RjtEKyspe2xldCAkPV8uaW5wdXRUZW5zb3JzW0RdLFM9Xy5pbmJvdW5kTGF5ZXJzW0RdLE09Xy5ub2RlSW5kaWNlc1tEXSxCPV8udGVuc29ySW5kaWNlc1tEXTtsKCQseCx2LFMsTSxCKX1mb3IoeC5wdXNoKF8pO3YuaW5kZXhPZihfKT49MDspdi5zcGxpY2Uodi5pbmRleE9mKF8pLDEpO28ucHVzaChfKX0sdT1bXSxwPVtdO2ZvcihsZXQgeSBvZiB0aGlzLm91dHB1dHMpbCh5LHUscCk7bGV0IGQ9by5zbGljZSgpLnJldmVyc2UoKTtmb3IobGV0IHkgb2YgZCl7YVt5LmlkXT15LHkuaWQgaW4gbnx8KG5beS5pZF09MCk7bGV0IHg9blt5LmlkXSx2PXJbeS5vdXRib3VuZExheWVyLmlkXT09bnVsbD8wOnJbeS5vdXRib3VuZExheWVyLmlkXTt4PU1hdGgubWF4KHgsdiksclt5Lm91dGJvdW5kTGF5ZXIuaWRdPXgsc1t5Lm91dGJvdW5kTGF5ZXIuaWRdPXkub3V0Ym91bmRMYXllcixuW3kuaWRdPXg7Zm9yKGxldCBJPTA7STx5LmluYm91bmRMYXllcnMubGVuZ3RoO0krKyl7bGV0IE49eS5pbmJvdW5kTGF5ZXJzW0ldLEM9eS5ub2RlSW5kaWNlc1tJXSxfPU4uaW5ib3VuZE5vZGVzW0NdLEY9bltfLmlkXT09bnVsbD8wOm5bXy5pZF07bltfLmlkXT1NYXRoLm1heCh4KzEsRiksYVtfLmlkXT1ffX1sZXQgYz17fTtmb3IobGV0IHkgaW4gbil7bGV0IHg9blt5XTt4IGluIGN8fChjW3hdPVtdKSxjW3hdLnB1c2goYVt5XSl9bGV0IGg9e307Zm9yKGxldCB5IGluIHIpe2xldCB4PXJbeV07eCBpbiBofHwoaFt4XT1bXSksaFt4XS5wdXNoKHNbeV0pfWxldCBtPU9iamVjdC5rZXlzKGgpLm1hcCh5PT5wYXJzZUludCh5LDEwKSkuc29ydCh3aCk7dGhpcy5sYXllcnM9W107Zm9yKGxldCB5IG9mIG0pe2xldCB4PWhbeV07eC5zb3J0KCh2LEkpPT57bGV0IE49aVt2LmlkXSxDPWlbSS5pZF07cmV0dXJuIE48Qz8tMTpOPkM/MTowfSk7Zm9yKGxldCB2IG9mIHgpdiBpbnN0YW5jZW9mIFFhJiZ0aGlzLmludGVybmFsQ29udGFpbmVyUmVmcy5wdXNoKHYpLHRoaXMubGF5ZXJzLnB1c2godil9dGhpcy5sYXllcnNCeURlcHRoPWgsbT1PYmplY3Qua2V5cyhjKS5tYXAoeT0+cGFyc2VJbnQoeSwxMCkpLnNvcnQod2gpO2xldCBmPXRoaXMuaW5wdXRzLnNsaWNlKCksZz1bXTtmb3IobGV0IHkgb2YgbSlmb3IobGV0IHggb2YgY1t5XSl7bGV0IHY9eC5vdXRib3VuZExheWVyO2lmKHYhPW51bGwpe2ZvcihsZXQgSSBvZiB4LmlucHV0VGVuc29ycylpZihmLmluZGV4T2YoSSk9PT0tMSl0aHJvdyBuZXcgYXIoYEdyYXBoIGRpc2Nvbm5lY3RlZDogY2Fubm90IG9idGFpbiB2YWx1ZSBmb3IgdGVuc29yICR7SX0gYXQgbGF5ZXIgXCIke3YubmFtZX1cIi4gVGhlIGZvbGxvd2luZyBwcmV2aW91cyBsYXllcnMgd2VyZSBhY2Nlc3NlZCB3aXRob3V0IGlzc3VlOiAke2d9YCk7Zm9yKGxldCBJIG9mIHgub3V0cHV0VGVuc29ycylmLnB1c2goSSk7Zy5wdXNoKHYubmFtZSl9fXRoaXMubm9kZXNCeURlcHRoPWM7bGV0IGI9dGhpcy5sYXllcnMubWFwKHk9PnkubmFtZSk7Zm9yKGxldCB5IG9mIGIpe2xldCB4PWIuZmlsdGVyKHY9PnY9PT15KS5sZW5ndGg7aWYoeCE9PTEpdGhyb3cgbmV3IGFyKGBUaGUgbmFtZSBcIiR7eX1cIiBpcyB1c2VkICR7eH0gdGltZXMgaW4gdGhlIG1vZGVsLiBBbGwgbGF5ZXIgbmFtZXMgc2hvdWxkIGJlIHVuaXF1ZS4gTGF5ZXIgbmFtZXM6IGArSlNPTi5zdHJpbmdpZnkoYikpfXRoaXMub3V0Ym91bmROb2Rlcz1bXSx0aGlzLmluYm91bmROb2Rlcz1bXSxuZXcgTmYoe291dGJvdW5kTGF5ZXI6dGhpcyxpbmJvdW5kTGF5ZXJzOltdLG5vZGVJbmRpY2VzOltdLHRlbnNvckluZGljZXM6W10saW5wdXRUZW5zb3JzOnRoaXMuaW5wdXRzLG91dHB1dFRlbnNvcnM6dGhpcy5vdXRwdXRzLGlucHV0TWFza3M6dGhpcy5pbnB1dHMubWFwKHk9Pm51bGwpLG91dHB1dE1hc2tzOnRoaXMub3V0cHV0cy5tYXAoeT0+bnVsbCksaW5wdXRTaGFwZXM6dGhpcy5pbnB1dHMubWFwKHk9Pnkuc2hhcGUpLG91dHB1dFNoYXBlczp0aGlzLm91dHB1dHMubWFwKHk9Pnkuc2hhcGUpfSksdGhpcy5idWlsdD0hMCx0aGlzLl9yZWZDb3VudD0xfWFzc2VydE5vdERpc3Bvc2VkKCl7aWYodGhpcy5fcmVmQ291bnQ9PT0wKXRocm93IG5ldyBFcnJvcihgQ29udGFpbmVyICcke3RoaXMubmFtZX0nIGlzIGFscmVhZHkgZGlzcG9zZWQuYCl9ZGlzcG9zZSgpe3RoaXMuYXNzZXJ0Tm90RGlzcG9zZWQoKTtsZXQgdD17cmVmQ291bnRBZnRlckRpc3Bvc2U6bnVsbCxudW1EaXNwb3NlZFZhcmlhYmxlczowfTtpZigtLXRoaXMuX3JlZkNvdW50PT09MCl7Zm9yKGxldCBuIG9mIHRoaXMubGF5ZXJzKXQubnVtRGlzcG9zZWRWYXJpYWJsZXMrPW4uZGlzcG9zZSgpLm51bURpc3Bvc2VkVmFyaWFibGVzO2ZvcihsZXQgbiBvZiB0aGlzLmludGVybmFsQ29udGFpbmVyUmVmcyl0Lm51bURpc3Bvc2VkVmFyaWFibGVzKz1uLmRpc3Bvc2UoKS5udW1EaXNwb3NlZFZhcmlhYmxlc31yZXR1cm4gdC5yZWZDb3VudEFmdGVyRGlzcG9zZT10aGlzLl9yZWZDb3VudCx0fWdldCB0cmFpbmFibGUoKXtyZXR1cm4gdGhpcy50cmFpbmFibGVffXNldCB0cmFpbmFibGUodCl7dGhpcy5sYXllcnMuZm9yRWFjaChuPT57bi5fdHJhaW5hYmxlV2VpZ2h0cy5mb3JFYWNoKGE9PmEudHJhaW5hYmxlPXQpfSksdGhpcy50cmFpbmFibGVfPXR9Z2V0IHRyYWluYWJsZVdlaWdodHMoKXtpZih0aGlzLl90cmFpbmFibGVXZWlnaHRzLmxlbmd0aD4wKXRocm93IG5ldyBWKFwiQ29udGFpbmVyIGluc3RhbmNlIHVuZXhwZWN0ZWRseSBjb250YWlucyBfdHJhaW5hYmxlV2VpZ2h0cy5UaGUgdHJhaW5hYmxlIHdlaWdodHMgb2YgYSBDb250YWluZXIgYXJlIGEgdW5pb24gb2YgdGhlIHRyYWluYWJsZSB3ZWlnaHRzIG9mIGl0cyBjb25zaXR1ZW50IExheWVycy4gSXRzIG93biBfdHJhaW5hYmxlV2VpZ2h0cyBtdXN0IHJlbWFpbiBhbiBlbXB0eSBBcnJheS5cIik7aWYoIXRoaXMudHJhaW5hYmxlKXJldHVybltdO2xldCB0PVtdO2ZvcihsZXQgbiBvZiB0aGlzLmxheWVycyl0PXQuY29uY2F0KG4udHJhaW5hYmxlV2VpZ2h0cyk7cmV0dXJuIHR9Z2V0IG5vblRyYWluYWJsZVdlaWdodHMoKXtsZXQgdD1bXTtmb3IobGV0IG4gb2YgdGhpcy5sYXllcnMpdC5wdXNoKC4uLm4ubm9uVHJhaW5hYmxlV2VpZ2h0cyk7aWYoIXRoaXMudHJhaW5hYmxlKXtsZXQgbj1bXTtmb3IobGV0IGEgb2YgdGhpcy5sYXllcnMpbi5wdXNoKC4uLmEudHJhaW5hYmxlV2VpZ2h0cyk7cmV0dXJuIG4uY29uY2F0KHQpfXJldHVybiB0fWdldCB3ZWlnaHRzKCl7cmV0dXJuIHRoaXMudHJhaW5hYmxlV2VpZ2h0cy5jb25jYXQodGhpcy5ub25UcmFpbmFibGVXZWlnaHRzKX1sb2FkV2VpZ2h0cyh0LG49ITApe2xldCBhPXt9LHI9MCxzPUhIKHQpO3MmJnRoaXMucGFyc2VXZWlnaHRzKHQpO2ZvcihsZXQgbyBvZiB0aGlzLmxheWVycylmb3IobGV0W2wsdV1vZiBvLndlaWdodHMuZW50cmllcygpKXtsZXQgcD1zP2Ake3UubmFtZS5zcGxpdChcIi9cIikuc2xpY2UoMCwtMSkuam9pbihcIi9cIikrXCIvXCJ9JHtsfWA6dS5vcmlnaW5hbE5hbWU7aWYoYVtwXSE9bnVsbCl0aHJvdyBuZXcgVihgRHVwbGljYXRlIHdlaWdodCBuYW1lOiAke3B9YCk7YVtwXT11LHIrK31sZXQgaT1bXTtmb3IobGV0IG8gaW4gdCl7bGV0IGw9bztpZihhW29dPT1udWxsKXtsZXQgdT1vLnNwbGl0KFwiL1wiKTtsPXUuc2xpY2UoMCwtMikuY29uY2F0KFt1W3UubGVuZ3RoLTFdXSkuam9pbihcIi9cIil9aWYoYVtsXSE9bnVsbClpLnB1c2goW2FbbF0sdFtvXV0pO2Vsc2UgaWYobil0aHJvdyBuZXcgVihgUHJvdmlkZWQgd2VpZ2h0IGRhdGEgaGFzIG5vIHRhcmdldCB2YXJpYWJsZTogJHtvfWApO2RlbGV0ZSBhW2xdfWlmKG4pe2xldCBvPVtdO2ZvcihsZXQgbCBpbiBhKW8ucHVzaChsKTtpZihvLmxlbmd0aD4wKXRocm93IG5ldyBWKGAke28ubGVuZ3RofSBvZiAke3J9IHdlaWdodHMgYXJlIG5vdCBzZXQ6ICR7b31gKX11MChpKX1wYXJzZVdlaWdodHModCl7Zm9yKGxldCBuIGluIE9iamVjdC5rZXlzKHQpKXtsZXQgYT1uLnNwbGl0KFwiL1wiKSxyPVtcInZhcnNcIixcImxheWVyX2NoZWNrcG9pbnRfZGVwZW5kZW5jaWVzXCJdLHM9YS5tYXAoaT0+aS5zdGFydHNXaXRoKFwiX1wiKT9pLnNsaWNlKDEpOmkpLmZpbHRlcihpPT4hci5pbmNsdWRlcyhpKSkuam9pbihcIi9cIik7cyE9PW4mJih0W3NdPXRbbl0sZGVsZXRlIHRbbl0pfX11cGRhdGVkQ29uZmlnKCl7bGV0IHQ9dGhpcy5nZXRDb25maWcoKSxuPXt9O3JldHVybiBuLmNsYXNzTmFtZT10aGlzLmdldENsYXNzTmFtZSgpLG4uY29uZmlnPXQsbi5rZXJhc1ZlcnNpb249YHRmanMtbGF5ZXJzICR7djB9YCxuLmJhY2tlbmQ9XCJUZW5zb3JGbG93LmpzXCIsbn10b0pTT04odCxuPSEwKXtsZXQgYT1IeCh0aGlzLnVwZGF0ZWRDb25maWcoKSk7cmV0dXJuIG4/SlNPTi5zdHJpbmdpZnkoYSk6YX1jYWxsKHQsbil7cmV0dXJuIE8oKCk9Pnt0PWl0KHQpO2xldCBhPW5ldyBDbDtmb3IobGV0IHI9MDtyPHRoaXMuaW5wdXRzLmxlbmd0aDsrK3IpYS5hZGQodGhpcy5pbnB1dHNbcl0sdFtyXSk7cmV0dXJuIHRjKHRoaXMub3V0cHV0cyxhLG4pfSl9Y29tcHV0ZU1hc2sodCxuKXtyZXR1cm4gTygoKT0+e3Q9aXQodCk7bGV0IGE7cmV0dXJuIG49PW51bGw/YT1iaShudWxsLHQubGVuZ3RoKTphPWl0KG4pLHRoaXMucnVuSW50ZXJuYWxHcmFwaCh0LGEpWzFdfSl9Y29tcHV0ZU91dHB1dFNoYXBlKHQpe2xldCBuPVpoKHQpO2lmKG4ubGVuZ3RoIT09dGhpcy5pbnB1dExheWVycy5sZW5ndGgpdGhyb3cgbmV3IFYoYEludmFsaWQgaW5wdXRTaGFwZSBhcmd1bWVudCAke3R9OiBtb2RlbCBoYXMgJHt0aGlzLmlucHV0TGF5ZXJzLmxlbmd0aH0gdGVuc29yIGlucHV0cy5gKTtsZXQgYT17fTtmb3IobGV0IG89MDtvPG4ubGVuZ3RoO28rKyl7bGV0IGw9dGhpcy5pbnB1dExheWVyc1tvXSx1PW5bb10scD1sLm5hbWUrXCJfMF8wXCI7YVtwXT11fWxldCByPU9iamVjdC5rZXlzKHRoaXMubm9kZXNCeURlcHRoKS5tYXAobz0+cGFyc2VJbnQobywxMCkpLnNvcnQod2gpO2lmKHIubGVuZ3RoPjEpZm9yKGxldCBvIG9mIHIpe2xldCBsPXRoaXMubm9kZXNCeURlcHRoW29dO2ZvcihsZXQgdSBvZiBsKXtsZXQgcD11Lm91dGJvdW5kTGF5ZXI7aWYodGhpcy5pbnB1dExheWVycy5tYXAoZj0+Zi5pZCkuaW5kZXhPZihwLmlkKSE9PS0xKWNvbnRpbnVlO2xldCBkPVtdO2ZvcihsZXQgZj0wO2Y8dS5pbmJvdW5kTGF5ZXJzLmxlbmd0aDtmKyspe2xldCBnPXUuaW5ib3VuZExheWVyc1tmXSxiPXUubm9kZUluZGljZXNbZl0seT11LnRlbnNvckluZGljZXNbZl0seD1gJHtnLm5hbWV9XyR7Yn1fJHt5fWAsdj1hW3hdO2QucHVzaCh2KX1sZXQgYz1wLmNvbXB1dGVPdXRwdXRTaGFwZShNbihkKSksaD1aaChjKSxtPXAuaW5ib3VuZE5vZGVzLmluZGV4T2YodSk7Zm9yKGxldCBmPTA7ZjxoLmxlbmd0aDtmKyspe2xldCBnPWAke3AubmFtZX1fJHttfV8ke2Z9YDthW2ddPWhbZl19fX1sZXQgcz1bXSxpPVtdO2ZvcihsZXQgbz0wO288dGhpcy5vdXRwdXRMYXllcnMubGVuZ3RoO28rKyl7bGV0IGw9dGhpcy5vdXRwdXRMYXllcnNbb10sdT10aGlzLm91dHB1dExheWVyc05vZGVJbmRpY2VzW29dLHA9dGhpcy5vdXRwdXRMYXllcnNUZW5zb3JJbmRpY2VzW29dLGQ9YCR7bC5uYW1lfV8ke3V9XyR7cH1gO2kucHVzaChkKX1mb3IobGV0IG89MDtvPGkubGVuZ3RoO28rKyl7bGV0IGw9aVtvXTt0cihsIGluIGEpLHMucHVzaChhW2xdKX1yZXR1cm4gTW4ocyl9cnVuSW50ZXJuYWxHcmFwaCh0LG4pe249PW51bGwmJihuPWJpKG51bGwsdC5sZW5ndGgpKTtsZXQgYT17fTtmb3IobGV0IGw9MDtsPHRoaXMuaW5wdXRzLmxlbmd0aDsrK2wpe2xldCB1PXRoaXMuaW5wdXRzW2xdLHA9dFtsXSxkPW5bbF07YVt1LmlkXT1bcCxkXX1sZXQgcj1PYmplY3Qua2V5cyh0aGlzLm5vZGVzQnlEZXB0aCkubWFwKGw9PnBhcnNlSW50KGwsMTApKS5zb3J0KHdoKTtmb3IobGV0IGwgb2Ygcil7bGV0IHU9dGhpcy5ub2Rlc0J5RGVwdGhbbF07Zm9yKGxldCBwIG9mIHUpe2xldCBkPXAub3V0Ym91bmRMYXllcixjPXAuaW5wdXRUZW5zb3JzLGg9cC5vdXRwdXRUZW5zb3JzLG09bmV3IEFycmF5O2ZvcihsZXQgZiBvZiBjKWYuaWQgaW4gYSYmbS5wdXNoKGFbZi5pZF0pO2lmKG0ubGVuZ3RoPT09Yy5sZW5ndGgpe2xldCBmPXt9LGcsYix5LHg7aWYocC5jYWxsQXJncyE9bnVsbCYmKGY9cC5jYWxsQXJncyksbS5sZW5ndGg9PT0xKXtsZXRbdixJXT1tWzBdO2YubWFzaz09bnVsbCYmKGYubWFzaz1JKSx5PWl0KGQuY2FsbCh2LGYpKSx4PWl0KGQuY29tcHV0ZU1hc2sodixJKSksZz1bdl0sYj1bSV19ZWxzZSBnPW0ubWFwKHY9PnZbMF0pLGI9bS5tYXAodj0+dlsxXSksZi5tYXNrPT1udWxsJiYoZi5tYXNrPWIpLHk9aXQoZC5jYWxsKGcsZikpLHg9aXQoZC5jb21wdXRlTWFzayhnLGIpKTtpZihkLmFjdGl2aXR5UmVndWxhcml6ZXIpdGhyb3cgbmV3IHplKFwiTGF5ZXJzTW9kZWwgaW52b2NhdGlvbiB3aXRoIGNvbmNyZXRlIFRlbnNvciB2YWx1ZShzKSBpbiB0aGUgcHJlc2VuY2Ugb2YgYWN0aXZpdHkgcmVndWxhcml6ZXIocykgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO2ZvcihsZXQgdj0wO3Y8aC5sZW5ndGg7Kyt2KXtsZXQgST1oW3ZdLE49eVt2XSxDPXhbdl07YVtJLmlkXT1bTixDXX19fX1sZXQgcz1bXSxpPVtdLG89W107Zm9yKGxldCBsIG9mIHRoaXMub3V0cHV0cyl7dHIobC5pZCBpbiBhLGBDb3VsZCBub3QgY29tcHV0ZSBvdXRwdXQgJHtsLm5hbWV9IDogJHtsLmlkfWApO2xldFt1LHBdPWFbbC5pZF07by5wdXNoKHUuc2hhcGUpLHMucHVzaCh1KSxpLnB1c2gocCl9cmV0dXJuW3MsaSxvXX1idWlsZE5vZGVDb252ZXJzaW9uTWFwKHQpe2xldCBuPXt9LGE7Zm9yKGxldCByIG9mIHRoaXMubGF5ZXJzKXthPXIgaW5zdGFuY2VvZiBRYT8xOjA7Zm9yKGxldCBzPTA7czxyLmluYm91bmROb2Rlcy5sZW5ndGg7cysrKXtsZXQgaT1RYS5ub2RlS2V5KHIscyk7dGhpcy5jb250YWluZXJOb2Rlcy5oYXMoaSkmJihuW2ldPWEsYSs9MSl9fXJldHVybiBufWdldExheWVyKHQsbil7aWYobiE9bnVsbClyZXR1cm4gdGhpcy5maW5kTGF5ZXIobik7aWYodD09bnVsbCl0aHJvdyBuZXcgVihcIlByb3ZpZGUgZWl0aGVyIGEgbGF5ZXIgbmFtZSBvciBsYXllciBpbmRleFwiKTtpZih0eXBlb2YgdD09XCJudW1iZXJcIilyZXR1cm4gdGhpcy5maW5kTGF5ZXIodCk7Zm9yKGxldCBhIG9mIHRoaXMubGF5ZXJzKWlmKGEubmFtZT09PXQpcmV0dXJuIGE7dGhyb3cgbmV3IFYoYE5vIHN1Y2ggbGF5ZXI6ICR7dH1gKX1maW5kTGF5ZXIodCl7aWYodGhpcy5sYXllcnMubGVuZ3RoPD10KXRocm93IG5ldyBWKGBXYXMgYXNrZWQgdG8gcmV0cmlldmUgbGF5ZXIgYXQgaW5kZXggJHt0fSwgYnV0IG1vZGVsIG9ubHkgaGFzICR7dGhpcy5sYXllcnMubGVuZ3RofSBsYXllcihzKS5gKTtyZXR1cm4gdGhpcy5sYXllcnNbdF19Y2FsY3VsYXRlTG9zc2VzKCl7cmV0dXJuIE8oKCk9PntsZXQgdD1bXTtmb3IobGV0IG4gb2YgdGhpcy5sYXllcnMpZm9yKGxldCBhPTA7YTxuLmluYm91bmROb2Rlcy5sZW5ndGg7KythKXtsZXQgcj1RYS5ub2RlS2V5KG4sYSk7dGhpcy5jb250YWluZXJOb2Rlcy5oYXMocikmJnQucHVzaCguLi5uLmNhbGN1bGF0ZUxvc3NlcygpKX1yZXR1cm4gdH0pfWdldENvbmZpZygpe2xldCB0PXtuYW1lOnRoaXMubmFtZX0sbj10aGlzLmJ1aWxkTm9kZUNvbnZlcnNpb25NYXAodGhpcy5sYXllcnMpLGE9W107Zm9yKGxldCBpIG9mIHRoaXMubGF5ZXJzKXtsZXQgbz1pLmdldENsYXNzTmFtZSgpLGw9aS5nZXRDb25maWcoKSx1PVtdO2ZvcihsZXQgZD0wO2Q8aS5pbmJvdW5kTm9kZXMubGVuZ3RoO2QrKyl7bGV0IGM9aS5pbmJvdW5kTm9kZXNbZF0saD1RYS5ub2RlS2V5KGksZCksbT17fTtpZih0aGlzLmNvbnRhaW5lck5vZGVzLmhhcyhoKSl7aWYoYy5jYWxsQXJncyl0cnl7SlNPTi5zdHJpbmdpZnkoYy5jYWxsQXJncyksbT1jLmNhbGxBcmdzfWNhdGNoKGYpe2NvbnNvbGUud2FybihgTGF5ZXIgJHtpLm5hbWV9IHdhcyBwYXNzZWQgbm9uLXNlcmlhbGl6YWJsZSBrZXl3b3JkIGFyZ3VtZW50czogJHtjLmNhbGxBcmdzfS4gVGhleSB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgc2VyaWFsaXplZCBtb2RlbCAoYW5kIHRodXMgd2lsbCBiZSBtaXNzaW5nIGF0IGRlc2VyaWFsaXphdGlvbiB0aW1lKS5gKSxtPXt9fWlmKGMuaW5ib3VuZExheWVycy5sZW5ndGg+MCl7bGV0IGY9W107Zm9yKGxldCBnPTA7ZzxjLmluYm91bmRMYXllcnMubGVuZ3RoO2crKyl7bGV0IGI9Yy5pbmJvdW5kTGF5ZXJzW2ddLHk9Yy5ub2RlSW5kaWNlc1tnXSx4PWMudGVuc29ySW5kaWNlc1tnXSx2PVFhLm5vZGVLZXkoYix5KSxJPW5bdl07ST09bnVsbCYmKEk9MCksZi5wdXNoKFtiLm5hbWUsSSx4LG1dKX11LnB1c2goZil9fX1sZXQgcD17fTtwLm5hbWU9aS5uYW1lLHAuY2xhc3NOYW1lPW8scC5jb25maWc9bCxwLmluYm91bmROb2Rlcz11LGEucHVzaChwKX10LmxheWVycz1hO2xldCByPVtdO2ZvcihsZXQgaT0wO2k8dGhpcy5pbnB1dExheWVycy5sZW5ndGg7aSsrKXtsZXQgbz10aGlzLmlucHV0TGF5ZXJzW2ldLGw9dGhpcy5pbnB1dExheWVyc05vZGVJbmRpY2VzW2ldLHU9UWEubm9kZUtleShvLGwpO2lmKCF0aGlzLmNvbnRhaW5lck5vZGVzLmhhcyh1KSljb250aW51ZTtsZXQgcD1uW3VdO3A9PW51bGwmJihwPTApO2xldCBkPXRoaXMuaW5wdXRMYXllcnNUZW5zb3JJbmRpY2VzW2ldO3IucHVzaChbby5uYW1lLHAsZF0pfXQuaW5wdXRMYXllcnM9cjtsZXQgcz1bXTtmb3IobGV0IGk9MDtpPHRoaXMub3V0cHV0TGF5ZXJzLmxlbmd0aDtpKyspe2xldCBvPXRoaXMub3V0cHV0TGF5ZXJzW2ldLGw9dGhpcy5vdXRwdXRMYXllcnNOb2RlSW5kaWNlc1tpXSx1PVFhLm5vZGVLZXkobyxsKTtpZighdGhpcy5jb250YWluZXJOb2Rlcy5oYXModSkpY29udGludWU7bGV0IHA9blt1XTtwPT1udWxsJiYocD0wKTtsZXQgZD10aGlzLm91dHB1dExheWVyc1RlbnNvckluZGljZXNbaV07cy5wdXNoKFtvLm5hbWUscCxkXSl9cmV0dXJuIHQub3V0cHV0TGF5ZXJzPXMsdH1zdGF0aWMgZnJvbUNvbmZpZyh0LG4sYT17fSxyPSExKXtsZXQgcz17fSxpPXt9O2Z1bmN0aW9uIG8oZyxiKXtnLm5hbWUgaW4gaT9pW2cubmFtZV0ucHVzaChiKTppW2cubmFtZV09W2JdfWZ1bmN0aW9uIGwoZyxiKXtsZXQgeT1bXSx4O2ZvcihsZXQgdiBvZiBiKXtsZXQgST12WzBdLE49dlsxXSxDPXZbMl07aWYoeD12WzNdPT1udWxsP3t9OnZbM10sIShJIGluIHMpKXtvKGcsYik7cmV0dXJufWxldCBfPXNbSV07aWYoXy5pbmJvdW5kTm9kZXMubGVuZ3RoPD1OKXtvKGcsYik7cmV0dXJufWxldCBGPV8uaW5ib3VuZE5vZGVzW05dO3kucHVzaChGLm91dHB1dFRlbnNvcnNbQ10pfXkubGVuZ3RoPjAmJmcuYXBwbHkoTW4oeSkseCl9ZnVuY3Rpb24gdShnKXtsZXQgYj1nLm5hbWUseT1CYShnLG4uY3VzdG9tT2JqZWN0cyE9bnVsbD9uLmN1c3RvbU9iamVjdHM6e30pO3kuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZChyKSxzW2JdPXksZy5pbmJvdW5kTm9kZXMuZm9yRWFjaCh4PT57aWYoISh4IGluc3RhbmNlb2YgQXJyYXkpKXRocm93IG5ldyBWKGBDb3JydXB0ZWQgY29uZmlndXJhdGlvbiwgZXhwZWN0ZWQgYXJyYXkgZm9yIG5vZGVEYXRhOiAke3h9YCk7byh5LHgpfSl9bGV0IHA9bi5uYW1lLGQ9bi5sYXllcnM7Zm9yKGxldCBnIG9mIGQpdShnKTtmb3IoOyFnRyhpKTspZm9yKGxldCBnIG9mIGQpe2xldCBiPXNbZy5uYW1lXTtpZihiLm5hbWUgaW4gaSl7bGV0IHk9aVtiLm5hbWVdO2RlbGV0ZSBpW2IubmFtZV07Zm9yKGxldCB4IG9mIHkpbChiLHgpfX1sZXQgYz1bXSxoPVtdLG09bi5pbnB1dExheWVycztmb3IobGV0IGcgb2YgbSl7bGV0IGI9Z1swXSx5PWdbMV0seD1nWzJdO3RyKGIgaW4gcyk7bGV0IHY9c1tiXS5pbmJvdW5kTm9kZXNbeV0ub3V0cHV0VGVuc29ycztjLnB1c2godlt4XSl9bGV0IGY9bi5vdXRwdXRMYXllcnM7Zm9yKGxldCBnIG9mIGYpe2xldCBiPWdbMF0seT1nWzFdLHg9Z1syXTt0cihiIGluIHMpO2xldCB2PXNbYl0uaW5ib3VuZE5vZGVzW3ldLm91dHB1dFRlbnNvcnM7aC5wdXNoKHZbeF0pfXJldHVybiBuZXcgdCh7aW5wdXRzOmMsb3V0cHV0czpoLG5hbWU6cH0pfWdldCBzdGF0ZWZ1bCgpe2lmKHRoaXMuX3N0YXRlZnVsKXRocm93IG5ldyBWKFwiQ29udGFpbmVyIGluc3RhbmNlIHVuZXhwZWN0ZWRseSBoYXMgX3N0YXRlZnVsID0gdHJ1ZS4gVGhlIHN0YXRlZnVsbmVzcyBvZiBhIENvbnRhaW5lciBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBMYXllcnMgaXQgY29udGFpbnMuIEl0cyBfc3RhdGVmdWwgcHJvcGVydHkgbXVzdCByZW1haW4gdGhlIGRlZmF1bHQgZmFsc2UuXCIpO2ZvcihsZXQgdCBvZiB0aGlzLmxheWVycylpZih0LnN0YXRlZnVsKXJldHVybiEwO3JldHVybiExfXJlc2V0U3RhdGVzKCl7TygoKT0+e3RoaXMubGF5ZXJzLmZvckVhY2godD0+e3Quc3RhdGVmdWwmJnQucmVzZXRTdGF0ZXMoKX0pfSl9fTtmdW5jdGlvbiBxSChlLHQsbil7bGV0IGE9dC5sZW5ndGg7aWYoZT09bnVsbHx8QXJyYXkuaXNBcnJheShlKSYmZS5sZW5ndGg9PT0wKXJldHVybiB0Lm1hcChyPT5udWxsKTtpZihhPT09MSlyZXR1cm4gQXJyYXkuaXNBcnJheShlKSYmZS5sZW5ndGg9PT0xP2U6dHlwZW9mIGU9PVwib2JqZWN0XCImJnRbMF1pbiBlP1tlW3RbMF1dXTpbZV07aWYoQXJyYXkuaXNBcnJheShlKSl7aWYoZS5sZW5ndGghPT1hKXRocm93IG5ldyBFcnJvcihgUHJvdmlkZWQgJHtufSBpcyBhbiBhcnJheSBvZiAke2UubGVuZ3RofSBlbGVtZW50KHMpLCBidXQgdGhlIG1vZGVsIGhhcyAke2F9IG91dHB1dHMuIE1ha2Ugc3VyZSBhIHNldCBvZiB3ZWlnaHRzIGlzIHByb3ZpZGVkIGZvciBlYWNoIG1vZGVsIG91dHB1dC5gKTtyZXR1cm4gZX1lbHNlIGlmKHR5cGVvZiBlPT1cIm9iamVjdFwiJiZPYmplY3Qua2V5cyhlKS5sZW5ndGg+MCYmdHlwZW9mIGVbT2JqZWN0LmtleXMoZSlbMF1dPT1cIm9iamVjdFwiKXtsZXQgcj1bXTtyZXR1cm4gdC5mb3JFYWNoKHM9PntzIGluIGU/ci5wdXNoKGVbc10pOnIucHVzaChudWxsKX0pLHJ9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFRoZSBtb2RlbCBoYXMgbXVsdGlwbGUgKCR7YX0pIG91dHB1dHMsIHNvICR7bn0gbXVzdCBiZSBlaXRoZXIgYW4gYXJyYXkgd2l0aCAke2F9IGVsZW1lbnRzIG9yIGFuIG9iamVjdCB3aXRoICR7dH0ga2V5cy4gUHJvdmlkZWQgJHtufSBub3QgdW5kZXJzdG9vZDogJHtKU09OLnN0cmluZ2lmeShlKX1gKX1mdW5jdGlvbiBCMihlLHQpe3JldHVybiBxSChlLHQsXCJjbGFzc1dlaWdodFwiKX1hc3luYyBmdW5jdGlvbiBWMihlLHQsbixhKXtpZih0IT1udWxsfHxhIT1udWxsKXRocm93IG5ldyBFcnJvcihcIlN1cHBvcnQgc2FtcGxlV2VpZ2h0IGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7aWYobiE9bnVsbCl7bGV0IHI9TygoKT0+e2lmKGUuc2hhcGUubGVuZ3RoPT09MSlyZXR1cm4gc3IoZSk7aWYoZS5zaGFwZS5sZW5ndGg9PT0yKXtpZihlLnNoYXBlWzFdPjEpcmV0dXJuIGRpKGUsMSk7aWYoZS5zaGFwZVsxXT09PTEpcmV0dXJuIFcoZSxbZS5zaGFwZVswXV0pO3Rocm93IG5ldyBFcnJvcihgRW5jb3VudGVyZWQgdW5leHBlY3RlZCBsYXN0LWRpbWVuc2lvbiBzaXplICgke2Uuc2hhcGVbMV19KSBkdXJpbmcgaGFuZGxpbmcgb2YgY2xhc3Mgd2VpZ2h0cy4gVGhlIHNpemUgaXMgZXhwZWN0ZWQgdG8gYmUgPj0gMS5gKX1lbHNlIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCByYW5rIG9mIHRhcmdldCAoeSkgdGVuc29yICgke2UucmFua30pIGR1cmluZyBoYW5kbGluZyBvZiBjbGFzcyB3ZWlnaHRzLiBUaGUgcmFuayBpcyBleHBlY3RlZCB0byBiZSAxIG9yIDIuYCl9KSxzPUFycmF5LmZyb20oYXdhaXQgci5kYXRhKCkpO0VlKHIpO2xldCBpPVtdO3JldHVybiBzLmZvckVhY2gobz0+e2lmKG5bb109PW51bGwpdGhyb3cgbmV3IEVycm9yKGBjbGFzc1dlaWdodCBtdXN0IGNvbnRhaW4gYWxsIGNsYXNzZXMgaW4gdGhlIHRyYWluaW5nIGRhdGEuIFRoZSBjbGFzcyAke299IGV4aXN0cyBpbiB0aGUgZGF0YSBidXQgbm90IGluIGNsYXNzV2VpZ2h0YCk7aS5wdXNoKG5bb10pfSksamUoaSxcImZsb2F0MzJcIil9ZWxzZSByZXR1cm4gbnVsbH1mdW5jdGlvbiBLSChlLHQpe3JldHVybiB6KGUsdCl9dmFyIFhIPTMyO2Z1bmN0aW9uIFUyKGUsdCl7bGV0IG4sYSxyPXQ7bj1yLnhzLGE9ci55cyx3LmFzc2VydChuIT1udWxsJiZhIT1udWxsLCgpPT5gQSBEYXRhc2V0IGl0ZXJhdG9yIGZvciBmaXREYXRhc2V0KCkgaXMgZXhwZWN0ZWQgdG8gZ2VuZXJhdGUgb2JqZWN0cyBvZiB0aGUgZm9ybSBcXGB7eHM6IHhWYWwsIHlzOiB5VmFsfVxcYCwgd2hlcmUgdGhlIHR3byB2YWx1ZXMgbWF5IGJlIFxcYHRmLlRlbnNvclxcYCwgYW4gYXJyYXkgb2YgVGVuc29ycywgb3IgYSBtYXAgb2Ygc3RyaW5nIHRvIFRlbnNvci4gIFRoZSBwcm92aWRlZCBEYXRhc2V0IGluc3RlYWQgZ2VuZXJhdGVzICR7dH1gKTtsZXQgcz1USShcImlucHV0XCIsZS5pbnB1dE5hbWVzLG4pLGk9VEkoXCJvdXRwdXRcIixlLm91dHB1dE5hbWVzLGEpLG89c1swXS5zaGFwZVswXTt3LmFzc2VydChzLmxlbmd0aD09PWUuaW5wdXRzLmxlbmd0aCwoKT0+YExheWVyc01vZGVsIGhhcyAke2UuaW5wdXRzLmxlbmd0aH0gaW5wdXRzLCBidXQgdGhlIGRhdGFzZXQgcHJvdmlkZXMgJHtzLmxlbmd0aH0gaW5wdXRzLiAgKEV4cGVjdGVkIGlucHV0IGtleXM6ICR7SlNPTi5zdHJpbmdpZnkoZS5pbnB1dE5hbWVzKX0pYCksdy5hc3NlcnQoaS5sZW5ndGg9PT1lLm91dHB1dHMubGVuZ3RoLCgpPT5gTGF5ZXJzTW9kZWwgaGFzICR7ZS5vdXRwdXRzLmxlbmd0aH0gb3V0cHV0cywgYnV0IHRoZSBkYXRhc2V0IHByb3ZpZGVzICR7aS5sZW5ndGh9IG91dHB1dHMuICAoRXhwZWN0ZWQgb3V0cHV0IGtleXM6ICR7SlNPTi5zdHJpbmdpZnkoZS5vdXRwdXROYW1lcyl9KWApO2ZvcihsZXQgbD0wO2w8cy5sZW5ndGg7bCsrKXcuYXNzZXJ0KHNbbF0uc2hhcGVbMF09PT1vLCgpPT5gQmF0Y2ggc2l6ZSBtaXNtYXRjaDogaW5wdXQgJHtlLmlucHV0TmFtZXNbbF19IGhhcyAke3NbbF0uc2hhcGVbMF19OyBleHBlY3RlZCAgJHtvfSBiYXNlZCBvbiBpbnB1dCAke2UuaW5wdXROYW1lc1swXX0uYCk7Zm9yKGxldCBsPTA7bDxpLmxlbmd0aDtsKyspdy5hc3NlcnQoaVtsXS5zaGFwZVswXT09PW8sKCk9PmBCYXRjaCBzaXplIG1pc21hdGNoOiBvdXRwdXQgJHtlLm91dHB1dE5hbWVzW2xdfSBoYXMgJHtpW2xdLnNoYXBlWzBdfTsgZXhwZWN0ZWQgICR7b30gYmFzZWQgb24gaW5wdXQgJHtlLmlucHV0TmFtZXNbMF19LmApO3JldHVybnt4czpzLHlzOml9fWZ1bmN0aW9uIFRJKGUsdCxuKXtpZihuIGluc3RhbmNlb2YgQ2UpcmV0dXJuW25dO2lmKEFycmF5LmlzQXJyYXkobikpcmV0dXJuIHcuYXNzZXJ0KG4ubGVuZ3RoPT09dC5sZW5ndGgsKCk9PmBSZWNlaXZlZCBhbiBhcnJheSBvZiAke24ubGVuZ3RofSBUZW5zb3JzLCBidXQgZXhwZWN0ZWQgJHt0Lmxlbmd0aH0gdG8gbWF0Y2ggdGhlICR7ZX0ga2V5cyAke3R9LmApLG47e2xldCBhPVtdO2ZvcihsZXQgciBvZiB0KXtpZihuW3JdPT1udWxsKXRocm93IG5ldyBWKGBUaGUgZmVhdHVyZSBkYXRhIGdlbmVyYXRlZCBieSB0aGUgZGF0YXNldCBsYWNrcyB0aGUgcmVxdWlyZWQgJHtlfSBrZXkgJyR7cn0nLmApO2EucHVzaChuW3JdKX1yZXR1cm4gYX19ZnVuY3Rpb24gWUgoZSl7aWYoZS5sZW5ndGg9PT0zKXRocm93IG5ldyB6ZShcIlZhbGlkYXRpb24gd2l0aCBzYW1wbGUgd2VpZ2h0cyBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtyZXR1cm57eHM6ZVswXSx5czplWzFdfX1hc3luYyBmdW5jdGlvbiBaSChlLHQsbil7bGV0IGE9bi5iYXRjaGVzUGVyRXBvY2ghPW51bGw7aWYody5hc3NlcnQoZS5vcHRpbWl6ZXIhPW51bGwsKCk9PlwiWW91IG11c3QgY29tcGlsZSBhIG1vZGVsIGJlZm9yZSB0cmFpbmluZy90ZXN0aW5nLiBVc2UgTGF5ZXJzTW9kZWwuY29tcGlsZShtb2RlbENvbXBpbGVDb25maWcpLlwiKSx3LmFzc2VydChuIT1udWxsLCgpPT5cIkZvciBmaXREYXRhc2V0KCksIHRoZSAybmQgYXJndW1lbnQgKGNvbmZpZykgaXMgcmVxdWlyZWQsIGJ1dCBpdCBpcyBub3QgcHJvdmlkZWQgaW4gdGhpcyBjYWxsLlwiKSx3LmFzc2VydChuLmVwb2NocyE9bnVsbCYmbi5lcG9jaHM+MCYmTnVtYmVyLmlzSW50ZWdlcihuLmVwb2NocyksKCk9PmBGb3IgZml0RGF0YXNldCgpLCBjb25maWcuZXBvY2hzIGlzIGV4cGVjdGVkIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGdvdCAke24uZXBvY2hzfWApLHcuYXNzZXJ0KCFhfHxuLmJhdGNoZXNQZXJFcG9jaD4wJiZOdW1iZXIuaXNJbnRlZ2VyKG4uYmF0Y2hlc1BlckVwb2NoKSwoKT0+YEZvciBmaXREYXRhc2V0KCksIGNvbmZpZy5iYXRjaGVzUGVyRXBvY2ggaXMgZXhwZWN0ZWQgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGlmIHNwZWNpZmllZCwgYnV0IGdvdCAke24uYmF0Y2hlc1BlckVwb2NofWApLHcuYXNzZXJ0KG4udmFsaWRhdGlvblNwbGl0PT1udWxsLCgpPT5cImB2YWxpZGF0aW9uU3BsaXRgIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYGZpdERhdGFzZXQoKWAuIFVzZSB2YWxpZGF0aW9uRGF0YSBpbnN0ZWFkLlwiKSxlLmlzVHJhaW5pbmcpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHN0YXJ0IHRyYWluaW5nIGJlY2F1c2UgYW5vdGhlciBmaXQoKSBjYWxsIGlzIG9uZ29pbmcuXCIpO2UuaXNUcmFpbmluZz0hMDt0cnl7bGV0IHI9bi52YWxpZGF0aW9uRGF0YSE9bnVsbCxzLGk7aWYocilpZihDSShuLnZhbGlkYXRpb25EYXRhKSl3LmFzc2VydChuLnZhbGlkYXRpb25CYXRjaGVzPT1udWxsfHxuLnZhbGlkYXRpb25CYXRjaGVzPjAmJk51bWJlci5pc0ludGVnZXIobi52YWxpZGF0aW9uQmF0Y2hlcyksKCk9PmBGb3IgZml0RGF0YXNldCgpIHdpdGggZGF0YXNldC1iYXNlZCB2YWxpZGF0aW9uLCBjb25maWcudmFsaWRhdGlvbkJhdGNoZXMgaXMgZXhwZWN0ZWQgbm90IHRvIGJlIHByb3ZpZGVkLCBvciB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGJ1dCBnb3QgJHtuLnZhbGlkYXRpb25CYXRjaGVzfWApO2Vsc2V7bGV0IGc9WUgobi52YWxpZGF0aW9uRGF0YSk7cz1nLnhzLGk9Zy55c31sZXQgbz1lLm1ha2VUcmFpbkZ1bmN0aW9uKCksbD1lLmdldERlZHVwZWRNZXRyaWNzTmFtZXMoKSx1O3I/dT1sLnNsaWNlKCkuY29uY2F0KGwubWFwKGc9PlwidmFsX1wiK2cpKTp1PWwuc2xpY2UoKTtsZXQgcD1EMihuLmNhbGxiYWNrcyxuLnlpZWxkRXZlcnkpLGQ9bi52ZXJib3NlPT1udWxsPzE6bi52ZXJib3NlLHtjYWxsYmFja0xpc3Q6YyxoaXN0b3J5Omh9PVIyKHAsZCxuLmVwb2NocyxudWxsLG51bGwsSkgodCxuKSxudWxsLHIsdSk7Yy5zZXRNb2RlbChlKSxlLmhpc3Rvcnk9aCxhd2FpdCBjLm9uVHJhaW5CZWdpbigpLGUuc3RvcFRyYWluaW5nXz0hMTtsZXQgbT1uLmluaXRpYWxFcG9jaD09bnVsbD8wOm4uaW5pdGlhbEVwb2NoLGY9YXdhaXQgdC5pdGVyYXRvcigpO2Zvcig7bTxuLmVwb2Noczspe2xldCBnPXt9O2F3YWl0IGMub25FcG9jaEJlZ2luKG0pO2xldCBiPTAseT0wO2ZvcihhfHwoZj1hd2FpdCB0Lml0ZXJhdG9yKCkpOyFhfHxiPG4uYmF0Y2hlc1BlckVwb2NoOyl7bGV0IHg9YXdhaXQgZi5uZXh0KCk7aWYoYSYmeC5kb25lKXtjb25zb2xlLndhcm4oYFlvdSBwcm92aWRlZCBcXGBiYXRjaGVzUGVyRXBvY2hcXGAgYXMgJHtuLmJhdGNoZXNQZXJFcG9jaH0sIGJ1dCB5b3VyIGRhdGFzZXQgaXRlcmF0b3IgcmFuIG91dCBvZiBkYXRhIGFmdGVyICR7Yn0gYmF0Y2hlczsgaW50ZXJydXB0aW5nIHRyYWluaW5nLiBNYWtlIHN1cmUgdGhhdCB5b3VyIGRhdGFzZXQgY2FuIGdlbmVyYXRlIGF0IGxlYXN0IFxcYGJhdGNoZXNQZXJFcG9jaCAqIGVwb2Noc1xcYCBiYXRjaGVzIChpbiB0aGlzIGNhc2UsICR7bi5iYXRjaGVzUGVyRXBvY2gqbi5lcG9jaHN9IGJhdGNoZXMpLiBZb3UgbWF5IG5lZWQgdG8gdXNlIHRoZSByZXBlYXQoKSBmdW5jdGlvbiB3aGVuIGJ1aWxkaW5nIHlvdXIgZGF0YXNldC5gKTticmVha31pZih4LnZhbHVlIT1udWxsKXtsZXR7eHM6dix5czpJfT1VMihlLHgudmFsdWUpLE49e307Ti5iYXRjaD15LE4uc2l6ZT12WzBdLnNoYXBlWzBdLGF3YWl0IGMub25CYXRjaEJlZ2luKHksTik7bGV0IEM9W107aWYobi5jbGFzc1dlaWdodCE9bnVsbCl7bGV0IEQ9QjIobi5jbGFzc1dlaWdodCxlLm91dHB1dE5hbWVzKTtmb3IobGV0ICQ9MDskPEQubGVuZ3RoOysrJClDLnB1c2goYXdhaXQgVjIoSVskXSxudWxsLERbJF0pKX1sZXQgXz12LmNvbmNhdChJKS5jb25jYXQoQyksRj1vKF8pO0VlKF8pO2ZvcihsZXQgRD0wO0Q8bC5sZW5ndGg7KytEKXtsZXQgJD1sW0RdLFM9RltEXTtOWyRdPVMsSHQoUyl9YXdhaXQgYy5vbkJhdGNoRW5kKHksTiksXzIoTikseSsrLGIrK31pZihhP2I+PW4uYmF0Y2hlc1BlckVwb2NoOnguZG9uZSl7aWYocil7bGV0IHY7Q0kobi52YWxpZGF0aW9uRGF0YSk/dj1pdChhd2FpdCBlLmV2YWx1YXRlRGF0YXNldChuLnZhbGlkYXRpb25EYXRhLHtiYXRjaGVzOm4udmFsaWRhdGlvbkJhdGNoZXN9KSk6dj1pdChlLmV2YWx1YXRlKHMsaSx7YmF0Y2hTaXplOm4udmFsaWRhdGlvbkJhdGNoU2l6ZT09bnVsbD9YSDpuLnZhbGlkYXRpb25CYXRjaFNpemUsdmVyYm9zZTowfSkpO2ZvcihsZXQgST0wO0k8ZS5tZXRyaWNzTmFtZXMubGVuZ3RoOysrSSlnW2B2YWxfJHtlLm1ldHJpY3NOYW1lc1tJXX1gXT12W0ldfWJyZWFrfWlmKGUuc3RvcFRyYWluaW5nXylicmVha31pZihhd2FpdCBjLm9uRXBvY2hFbmQobSxnKSxtKyssZS5zdG9wVHJhaW5pbmdfKWJyZWFrfXJldHVybiBhd2FpdCBjLm9uVHJhaW5FbmQoKSxhd2FpdCBlLmhpc3Rvcnkuc3luY0RhdGEoKSxlLmhpc3Rvcnl9ZmluYWxseXtlLmlzVHJhaW5pbmc9ITF9fWZ1bmN0aW9uIEpIKGUsdCl7bGV0IG49bnVsbDtyZXR1cm4gdC5iYXRjaGVzUGVyRXBvY2ghPW51bGw/bj10LmJhdGNoZXNQZXJFcG9jaDpOdW1iZXIuaXNGaW5pdGUoZS5zaXplKSYmKG49ZS5zaXplKSxufWZ1bmN0aW9uIENJKGUpe3JldHVybiB0eXBlb2YgZS5pdGVyYXRvcj09XCJmdW5jdGlvblwifWZ1bmN0aW9uIFFIKGUpe3JldHVybiB0eXBlb2YgZS5uZXh0PT1cImZ1bmN0aW9uXCJ9YXN5bmMgZnVuY3Rpb24gZWooZSx0LG4pe249bnx8e307bGV0IGE9bi5iYXRjaGVzIT1udWxsLHI9ZS50ZXN0RnVuY3Rpb24scz1bXTtpZihuLnZlcmJvc2U+MCl0aHJvdyBuZXcgemUoXCJWZXJib3NlIG1vZGUgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7dy5hc3NlcnQoIWF8fG4uYmF0Y2hlcz4wJiZOdW1iZXIuaXNJbnRlZ2VyKG4uYmF0Y2hlcyksKCk9PmBUZXN0IGxvb3AgZXhwZWN0cyBcXGBiYXRjaGVzXFxgIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkobi5iYXRjaGVzKX1gKTtsZXQgaT1RSCh0KT90OmF3YWl0IHQuaXRlcmF0b3IoKSxvPTAsbD0wO2Zvcig7IWF8fGw8bi5iYXRjaGVzOyl7bGV0IHU9YXdhaXQgaS5uZXh0KCk7aWYocz1PKCgpPT57aWYodS52YWx1ZSl7bGV0e3hzOnAseXM6ZH09VTIoZSx1LnZhbHVlKSxjPXAuY29uY2F0KGQpLGg9TygoKT0+cihjKSk7aWYoRWUoYyksbD09PTApZm9yKGxldCBmPTA7ZjxoLmxlbmd0aDsrK2Ypcy5wdXNoKHhlKDApKTtsZXQgbT1jWzBdLnNoYXBlWzBdO2ZvcihsZXQgZj0wO2Y8aC5sZW5ndGg7KytmKXtsZXQgZz1oW2ZdLGI9c1tmXTtzW2ZdPU8oKCk9Plgoc1tmXSx6KG0sZykpKSxsPjAmJkVlKGIpfUVlKGgpLG8rPW0sKytsfXJldHVybiBzfSksdS5kb25lKXthJiZjb25zb2xlLndhcm4oYFlvdXIgZGF0YXNldCBpdGVyYXRvciByYW4gb3V0IG9mIGRhdGEgZHVyaW5nIGV2YWx1YXRlRGF0YXNldCgpLiBJbnRlcnJ1cHRpbmcgZXZhbHV0aW9uLiBNYWtlIHN1cmUgdGhhdCB5b3VyIGRhdGFzZXQgY2FuIGdlbmVyYXRlIGF0IGxlYXN0IFxcYGJhdGNoZXNcXGAgYmF0Y2hlcyAoaW4gdGhpcyBjYXNlLCAke24uYmF0Y2hlc30gYmF0Y2hlcykuIFlvdSBtYXkgbmVlZCB0byB1c2UgdGhlIHJlcGVhdCgpIGZ1bmN0aW9uIHdoZW4gYnVpbGRpbmcgeW91ciBkYXRhc2V0LmApO2JyZWFrfX1mb3IobGV0IHU9MDt1PHMubGVuZ3RoOysrdSl7bGV0IHA9c1t1XTtzW3VdPWhlKHNbdV0sbyksRWUocCl9cmV0dXJuIE1uKHMpfWZ1bmN0aW9uIGh4KGUpe3cuYXNzZXJ0KGU+MCYmTnVtYmVyLmlzSW50ZWdlcihlKSwoKT0+YGJhdGNoU2l6ZSBpcyByZXF1aXJlZCB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGJ1dCBnb3QgJHtlfWApfWZ1bmN0aW9uIFhwKGUsdCxuKXtyZXR1cm4gZT09bnVsbD9bbnVsbF06QXJyYXkuaXNBcnJheShlKT9lLm1hcChhPT5zaShhLHQsbi10KSk6c2koZSx0LG4tdCl9ZnVuY3Rpb24gangoZSx0KXtyZXR1cm4gTygoKT0+ZT09bnVsbD9udWxsOkFycmF5LmlzQXJyYXkoZSk/ZS5tYXAobj0+angobix0KSk6djIoZSx0LmR0eXBlPT09XCJpbnQzMlwiP3Q6cmUodCxcImludDMyXCIpKSl9ZnVuY3Rpb24gbXgoZSx0KXtsZXQgbj1bXSxhPTAscj1udWxsO2Zvcig7YTxlOylyPWErdCxyPj1lJiYocj1lKSxuLnB1c2goW2Escl0pLGE9cjtyZXR1cm4gbn1mdW5jdGlvbiBHMihlKXtsZXQgdD1bXTtlIGluc3RhbmNlb2YgQ2UmJihlPVtlXSk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDsrK24pe2xldCBhPWVbbl07aWYoYS5yYW5rPT09MSl0LnB1c2god2QoYSwxKSk7ZWxzZXtpZihhLnJhbms9PT0wKXRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHRlbnNvciB0byBiZSBhdCBsZWFzdCAxRCwgYnV0IHJlY2VpdmVkIGEgMEQgdGVuc29yIChzY2FsYXIpLlwiKTt0LnB1c2goYSl9fXJldHVybiB0fWZ1bmN0aW9uIFBhKGUsdCl7aWYoZT09bnVsbClyZXR1cm47bGV0IG49W107aWYodCBpbnN0YW5jZW9mIENlKW4ucHVzaCh0LmlkKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkodCkpdC5mb3JFYWNoKHI9Pm4ucHVzaChyLmlkKSk7ZWxzZSBpZih0IT1udWxsKWZvcihsZXQgciBpbiB0KXtsZXQgcz10W3JdO24ucHVzaChzLmlkKX1sZXQgYT1bXTtpZihlIGluc3RhbmNlb2YgQ2Upbi5pbmRleE9mKGUuaWQpPT09LTEmJmEucHVzaChlKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkoZSkpZS5mb3JFYWNoKHI9PntuLmluZGV4T2Yoci5pZCk9PT0tMSYmYS5wdXNoKHIpfSk7ZWxzZSBpZihlIT1udWxsKWZvcihsZXQgciBpbiBlKXtsZXQgcz1lW3JdO24uaW5kZXhPZihzLmlkKT09PS0xJiZhLnB1c2gocyl9YS5mb3JFYWNoKHI9PntyLmlzRGlzcG9zZWR8fHIuZGlzcG9zZSgpfSl9ZnVuY3Rpb24gdGooZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBDZX1mdW5jdGlvbiBxeChlKXtyZXR1cm4gQXJyYXkuaXNBcnJheShlKX1mdW5jdGlvbiBFSShlKXtyZXR1cm4hdGooZSkmJiFxeChlKX1mdW5jdGlvbiBfSShlLHQsbixhPSEwLHI9XCJcIil7aWYodD09bnVsbHx8dC5sZW5ndGg9PT0wKXtpZihlIT1udWxsKXtsZXQgaT0hMTtpZihxeChlKSYmZS5sZW5ndGg+MClpPSEwO2Vsc2UgaWYoRUkoZSkpe2ZvcihsZXQgbyBpbiBlKWlmKGUuaGFzT3duUHJvcGVydHkobykpe2k9ITA7YnJlYWt9fWVsc2UgaT0hMDtpZihpKXRocm93IG5ldyBWKGBFcnJvciB3aGVuIGNoZWNraW5nIG1vZGVsICR7cn0gZXhwZWN0ZWQgbm8gZGF0YSwgYnV0IGdvdCAke2V9YCl9cmV0dXJuW119aWYoZT09bnVsbClyZXR1cm4gdC5tYXAoaT0+bnVsbCk7bGV0IHM7aWYoRUkoZSkpe2U9ZSxzPVtdO2ZvcihsZXQgaSBvZiB0KXtpZihlW2ldPT1udWxsKXRocm93IG5ldyBWKGBObyBkYXRhIHByb3ZpZGVkIGZvciBcIiR7aX1cIi4gTmVlZCBkYXRhIGZvciBlYWNoIGtleSBpbjogJHt0fWApO3MucHVzaChlW2ldKX19ZWxzZSBpZihxeChlKSl7aWYoZT1lLGUubGVuZ3RoIT09dC5sZW5ndGgpdGhyb3cgbmV3IFYoYEVycm9yIHdoZW4gY2hlY2tpbmcgbW9kZWwgJHtyfTogdGhlIEFycmF5IG9mIFRlbnNvcnMgdGhhdCB5b3UgYXJlIHBhc3NpbmcgdG8geW91ciBtb2RlbCBpcyBub3QgdGhlIHNpemUgdGhlIG1vZGVsIGV4cGVjdGVkLiBFeHBlY3RlZCB0byBzZWUgJHt0Lmxlbmd0aH0gVGVuc29yKHMpLCBidXQgaW5zdGVhZCBnb3QgdGhlIGZvbGxvd2luZyBsaXN0IG9mIFRlbnNvcihzKTogJHtlfWApO3M9ZX1lbHNle2lmKGU9ZSx0Lmxlbmd0aD4xKXRocm93IG5ldyBWKGBUaGUgbW9kZWwgJHtyfSBleHBlY3RzICR7dC5sZW5ndGh9IFRlbnNvcihzKSwgYnV0IG9ubHkgcmVjZWl2ZWQgb25lIFRlbnNvci4gRm91bmQ6IFRlbnNvciB3aXRoIHNoYXBlICR7ZS5zaGFwZX1gKTtzPVtlXX1pZihzPUcyKHMpLG4hPW51bGwpZm9yKGxldCBpPTA7aTx0Lmxlbmd0aDsrK2kpe2lmKG5baV09PW51bGwpY29udGludWU7bGV0IG89c1tpXTtpZihvLnNoYXBlLmxlbmd0aCE9PW5baV0ubGVuZ3RoKXRocm93IG5ldyBWKGBFcnJvciB3aGVuIGNoZWNraW5nICR7cn06IGV4cGVjdGVkICR7dFtpXX0gdG8gaGF2ZSAke25baV0ubGVuZ3RofSBkaW1lbnNpb24ocykuIGJ1dCBnb3QgYXJyYXkgd2l0aCBzaGFwZSAke28uc2hhcGV9YCk7Zm9yKGxldCBsPTA7bDxuW2ldLmxlbmd0aDsrK2wpe2lmKGw9PT0wJiYhYSljb250aW51ZTtsZXQgdT1vLnNoYXBlW2xdLHA9bltpXVtsXTtpZihwIT1udWxsJiZwPj0wJiZ1IT09cCl0aHJvdyBuZXcgVihgJHtyfSBleHBlY3RlZCBhIGJhdGNoIG9mIGVsZW1lbnRzIHdoZXJlIGVhY2ggZXhhbXBsZSBoYXMgc2hhcGUgWyR7bltpXS5zbGljZSgxLG5baV0ubGVuZ3RoKX1dIChpLmUuLHRlbnNvciBzaGFwZSBbKiwke25baV0uc2xpY2UoMSxuW2ldLmxlbmd0aCl9XSkgYnV0IHRoZSAke3J9IHJlY2VpdmVkIGFuIGlucHV0IHdpdGggJHtvLnNoYXBlWzBdfSBleGFtcGxlcywgZWFjaCB3aXRoIHNoYXBlIFske28uc2hhcGUuc2xpY2UoMSxvLnNoYXBlLmxlbmd0aCl9XSAodGVuc29yIHNoYXBlIFske28uc2hhcGV9XSlgKX19cmV0dXJuIHN9ZnVuY3Rpb24gbmooZSx0LG4pe2xldCBhPWFzKGUubWFwKHM9PnMuc2hhcGVbMF0pKTthLnNvcnQoKTtsZXQgcj1hcyh0Lm1hcChzPT5zLnNoYXBlWzBdKSk7aWYoci5zb3J0KCksYS5sZW5ndGg+MSl0aHJvdyBuZXcgVihgQWxsIGlucHV0IFRlbnNvcnMgKHgpIHNob3VsZCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBzYW1wbGVzLiBHb3QgYXJyYXkgc2hhcGVzOiAke0pTT04uc3RyaW5naWZ5KGUubWFwKHM9PnMuc2hhcGUpKX1gKTtpZihyLmxlbmd0aD4xKXRocm93IG5ldyBWKGBBbGwgdGFyZ2V0IFRlbnNvcnMgKHkpIHNob3VsZCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBzYW1wbGVzLiBHb3QgYXJyYXkgc2hhcGVzOiAke0pTT04uc3RyaW5naWZ5KHQubWFwKHM9PnMuc2hhcGUpKX1gKTtpZihhLmxlbmd0aD4wJiZyLmxlbmd0aD4wJiYhdy5hcnJheXNFcXVhbChhLHIpKXRocm93IG5ldyBWKGBJbnB1dCBUZW5zb3JzIHNob3VsZCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBzYW1wbGVzIGFzIHRhcmdldCBUZW5zb3JzLiBGb3VuZCAke2FbMF19IGlucHV0IHNhbXBsZShzKSBhbmQgJHtyWzBdfSB0YXJnZXQgc2FtcGxlKHMpLmApfWZ1bmN0aW9uIGFqKGUsdCxuKXtsZXQgYT1bWG8sQ2Ysa2NdO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7KytyKXtsZXQgcz1lW3JdLGk9dFtyXSxvPW5bcl07aWYoaSE9bnVsbCl7aWYoaT09PWtjJiZzLnNoYXBlW3Muc2hhcGUubGVuZ3RoLTFdPT09MSl0aHJvdyBuZXcgVihgWW91IGFyZSBwYXNzaW5nIGEgdGFyZ2V0IGFycmF5IG9mIHNoYXBlICR7cy5zaGFwZX0gd2hpbGUgdXNpbmcgYSBsb3NzICdjYXRlZ29yaWNhbF9jcm9zc2VudHJvcHknLiAnY2F0ZWdvcmljYWxfY3Jvc3NlbnRyb3B5J2V4cGVjdHMgdGFyZ2V0cyB0byBiZSBiaW5hcnkgbWF0cmljZXMgKDFzIGFuZCAwcykgb2Ygc2hhcGUgW3NhbXBsZXMsIGNsYXNzZXNdLmApO2lmKGEuaW5kZXhPZihpKSE9PS0xKXtsZXQgbD1zLnNoYXBlLnNsaWNlKDEpLHU9by5zbGljZSgxKTtmb3IobGV0IHA9MDtwPGwubGVuZ3RoOysrcCl7bGV0IGQ9bFtwXSxjPXVbcF07aWYoYyE9bnVsbCYmZCE9PWMpdGhyb3cgbmV3IFYoYEEgdGFyZ2V0IFRlbnNvciB3aXRoIHNoYXBlICR7cy5zaGFwZX0gd2FzIHBhc3NlZCBmb3IgYW4gb3V0cHV0IG9mIHNoYXBlICR7b30sIHdoaWxlIHVzaW5nIGEgbG9zcyBmdW5jdGlvbiB0aGF0IGV4cGVjdHMgdGFyZ2V0cyB0byBoYXZlIHRoZSBzYW1lIHNoYXBlIGFzIHRoZSBvdXRwdXQuYCl9fX19fWZ1bmN0aW9uIEFJKGUsdCxuLGE9ITAscj1cIlwiKXtsZXQgcztpZihBcnJheS5pc0FycmF5KGUpKXtpZihlLmxlbmd0aCE9PXQubGVuZ3RoKXRocm93IG5ldyBWKGBFcnJvciB3aGVuIGNoZWNraW5nIG1vZGVsICR7cn06IHRoZSBBcnJheSBvZiBUZW5zb3JzIHRoYXQgeW91IGFyZSBwYXNzaW5nIHRvIHlvdXIgbW9kZWwgaXMgbm90IHRoZSBzaXplIHRoZSB0aGUgbW9kZWwgZXhwZWN0ZWQuIEV4cGVjdGVkIHRvIHNlZSAke3QubGVuZ3RofSBUZW5zb3IocyksIGJ1dCBpbnN0ZWFkIGdvdCAke2UubGVuZ3RofSBUZW5zb3JzKHMpLmApO3M9ZX1lbHNle2lmKHQubGVuZ3RoPjEpdGhyb3cgbmV3IFYoYFRoZSBtb2RlbCBleHBlY3RzICR7dC5sZW5ndGh9ICR7cn0gVGVuc29ycywgYnV0IG9ubHkgcmVjZWl2ZWQgb25lIFRlbnNvci4gRm91bmQ6IGFycmF5IHdpdGggc2hhcGUgJHtKU09OLnN0cmluZ2lmeShlLnNoYXBlKX0uYCk7cz1bZV19aWYobiE9bnVsbClmb3IobGV0IGk9MDtpPHQubGVuZ3RoOysraSl7aWYobltpXT09bnVsbCljb250aW51ZTtsZXQgbz1zW2ldO2lmKG8uc2hhcGUubGVuZ3RoIT09bltpXS5sZW5ndGgpdGhyb3cgbmV3IFYoYEVycm9yIHdoZW4gY2hlY2tpbmcgJHtyfTogZXhwZWN0ZWQgJHt0W2ldfSB0byBoYXZlICR7bltpXS5sZW5ndGh9IGRpbWVuc2lvbihzKSwgYnV0IGdvdCBhcnJheSB3aXRoIHNoYXBlICR7SlNPTi5zdHJpbmdpZnkoby5zaGFwZSl9YCk7Zm9yKGxldCBsPTA7bDxuW2ldLmxlbmd0aDsrK2wpe2lmKGw9PT0wJiYhYSljb250aW51ZTtsZXQgdT1vLnNoYXBlW2xdLHA9bltpXVtsXTtpZihwIT1udWxsJiZwIT09dSl0aHJvdyBuZXcgVihgRXJyb3Igd2hlbiBjaGVja2luZyAke3J9OiBleHBlY3RlZCAke3RbaV19IHRvIGhhdmUgc2hhcGUgJHtKU09OLnN0cmluZ2lmeShuW2ldKX0gYnV0IGdvdCBhcnJheSB3aXRoIHNoYXBlICR7SlNPTi5zdHJpbmdpZnkoby5zaGFwZSl9LmApfX19ZnVuY3Rpb24gcmooZSx0KXtpZihlPT1udWxsfHxBcnJheS5pc0FycmF5KGUpJiZlLmxlbmd0aD09PTApcmV0dXJuIHQubWFwKGE9PltdKTtsZXQgbjtpZih0eXBlb2YgZT09XCJzdHJpbmdcInx8dHlwZW9mIGU9PVwiZnVuY3Rpb25cIiluPVtlXTtlbHNlIGlmKEFycmF5LmlzQXJyYXkoZSl8fHR5cGVvZiBlPT1cIm9iamVjdFwiKW49ZTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoYFR5cGUgb2YgbWV0cmljcyBhcmd1bWVudCBub3QgdW5kZXJzdG9vZC4gRXhwZWN0ZWQgYW4gc3RyaW5nLGZ1bmN0aW9uLCBBcnJheSwgb3IgT2JqZWN0LCBmb3VuZDogJHtlfWApO2lmKEFycmF5LmlzQXJyYXkobikpcmV0dXJuIHQubWFwKGE9Pm4pO3tsZXQgYT1bXTtmb3IobGV0IHIgb2YgdCl7bGV0IHM9bi5oYXNPd25Qcm9wZXJ0eShyKT9uW3JdOltdO0FycmF5LmlzQXJyYXkocyl8fChzPVtzXSksYS5wdXNoKHMpfXJldHVybiBhfX12YXIgc2o9XCJsYXllcnMtbW9kZWxcIixFcj1jbGFzcyBleHRlbmRzIGpIe2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLHRoaXMuaXNUcmFpbmluZz0hMX1zdW1tYXJ5KGUsdCxuPWNvbnNvbGUubG9nKXtpZighdGhpcy5idWlsdCl0aHJvdyBuZXcgVihcIlRoaXMgbW9kZWwgaGFzIG5ldmVyIGJlZW4gY2FsbGVkLCB0aHVzIGl0cyB3ZWlnaHRzIGhhdmUgbm90IGJlZW4gY3JlYXRlZCB5ZXQuIFNvIG5vIHN1bW1hcnkgY2FuIGJlIGRpc3BsYXllZC4gQnVpbGQgdGhlIG1vZGVsIGZpcnN0IChlLmcuLCBieSBjYWxsaW5nIGl0IG9uIHNvbWUgdGVzdCBkYXRhKS5cIik7V0godGhpcyxlLHQsbil9Y29tcGlsZShlKXtpZihlLmxvc3M9PW51bGwmJihlLmxvc3M9W10pLHRoaXMubG9zcz1lLmxvc3MsdHlwZW9mIGUub3B0aW1pemVyPT1cInN0cmluZ1wiKXRoaXMub3B0aW1pemVyXz16SChlLm9wdGltaXplciksdGhpcy5pc09wdGltaXplck93bmVkPSEwO2Vsc2V7aWYoIShlLm9wdGltaXplciBpbnN0YW5jZW9mIFJyKSl0aHJvdyBuZXcgVihcIlVzZXItZGVmaW5lZCBvcHRpbWl6ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiB0Zi5PcHRpbWl6ZXIuXCIpO3RoaXMub3B0aW1pemVyXz1lLm9wdGltaXplcix0aGlzLmlzT3B0aW1pemVyT3duZWQ9ITF9bGV0IHQ9W107aWYoIUFycmF5LmlzQXJyYXkoZS5sb3NzKSYmdHlwZW9mIGUubG9zcyE9XCJzdHJpbmdcIiYmdHlwZW9mIGUubG9zcyE9XCJmdW5jdGlvblwiKXtlLmxvc3M9ZS5sb3NzO2ZvcihsZXQgcyBpbiBlLmxvc3MpaWYodGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKHMpPT09LTEpdGhyb3cgbmV3IFYoYFVua25vd24gZW50cnkgaW4gbG9zcyBkaWN0aW9uYXJ5OiBcIiR7c31cIi4gT25seSBleHBlY3RlZCB0aGUgZm9sbG93aW5nIGtleXM6ICR7dGhpcy5vdXRwdXROYW1lc31gKTtmb3IobGV0IHMgb2YgdGhpcy5vdXRwdXROYW1lcyllLmxvc3Nbc109PW51bGwmJmNvbnNvbGUud2FybihgT3V0cHV0IFwiJHtzfVwiIGlzIG1pc3NpbmcgZnJvbSBsb3NzIGRpY3Rpb25hcnkuIFdlIGFzc3VtZSB0aGlzIHdhcyBkb25lIG9uIHB1cnBvc2UsIGFuZCB3ZSB3aWxsIG5vdCBiZSBleHBlY3RpbmcgZGF0YSB0byBiZSBwYXNzZWQgdG8gJHtzfSBkdXJpbmcgdHJhaW5pbmdgKSx0LnB1c2goZHgoZS5sb3NzW3NdKSl9ZWxzZSBpZihBcnJheS5pc0FycmF5KGUubG9zcykpe2lmKGUubG9zcy5sZW5ndGghPT10aGlzLm91dHB1dHMubGVuZ3RoKXRocm93IG5ldyBWKGBXaGVuIHBhc3NpbmcgYW4gQXJyYXkgYXMgbG9zcywgaXQgc2hvdWxkIGhhdmUgb25lIGVudHJ5IHBlciBtb2RlbCBvdXRwdXQuIFRoZSBtb2RlbCBoYXMgJHt0aGlzLm91dHB1dHMubGVuZ3RofSBvdXRwdXQocyksIGJ1dCB5b3UgcGFzc2VkIGxvc3M9JHtlLmxvc3N9LmApO3Q9ZS5sb3NzLm1hcChzPT5keChzKSl9ZWxzZXtsZXQgcz1keChlLmxvc3MpO3RoaXMub3V0cHV0cy5mb3JFYWNoKGk9Pnt0LnB1c2gocyl9KX10aGlzLmxvc3NGdW5jdGlvbnM9dCx0aGlzLmZlZWRPdXRwdXROYW1lcz1bXSx0aGlzLmZlZWRPdXRwdXRTaGFwZXM9W10sdGhpcy5mZWVkTG9zc0Zucz1bXTtmb3IobGV0IHM9MDtzPHRoaXMub3V0cHV0cy5sZW5ndGg7KytzKXtsZXQgaT10aGlzLmludGVybmFsT3V0cHV0U2hhcGVzW3NdLG89dGhpcy5vdXRwdXROYW1lc1tzXTt0aGlzLmZlZWRPdXRwdXROYW1lcy5wdXNoKG8pLHRoaXMuZmVlZE91dHB1dFNoYXBlcy5wdXNoKGkpLHRoaXMuZmVlZExvc3NGbnMucHVzaCh0aGlzLmxvc3NGdW5jdGlvbnNbc10pfWxldCBuPVtdO3RoaXMubWV0cmljcz1lLm1ldHJpY3MsdGhpcy5tZXRyaWNzTmFtZXM9W1wibG9zc1wiXSx0aGlzLm1ldHJpY3NUZW5zb3JzPVtdLHJpKFwibG9zc1wiLCgpPT57Zm9yKGxldCBzPTA7czx0aGlzLm91dHB1dHMubGVuZ3RoOysrcyl7aWYobi5pbmRleE9mKHMpIT09LTEpY29udGludWU7bGV0IGk9dGhpcy5sb3NzRnVuY3Rpb25zW3NdO3RoaXMub3V0cHV0cy5sZW5ndGg+MSYmKHRoaXMubWV0cmljc1RlbnNvcnMucHVzaChbaSxzXSksdGhpcy5tZXRyaWNzTmFtZXMucHVzaCh0aGlzLm91dHB1dE5hbWVzW3NdK1wiX2xvc3NcIikpfX0pO2xldCBhPXJqKGUubWV0cmljcyx0aGlzLm91dHB1dE5hbWVzKSxyPShzLGksbyk9Pnt0aGlzLm91dHB1dE5hbWVzLmxlbmd0aD4xJiYoaT10aGlzLm91dHB1dE5hbWVzW3NdK1wiX1wiK2kpLHRoaXMubWV0cmljc05hbWVzLnB1c2goaSksdGhpcy5tZXRyaWNzVGVuc29ycy5wdXNoKFtvLHNdKX07cmkoXCJtZXRyaWNcIiwoKT0+e2ZvcihsZXQgcz0wO3M8dGhpcy5vdXRwdXRzLmxlbmd0aDsrK3Mpe2lmKG4uaW5kZXhPZihzKSE9PS0xKWNvbnRpbnVlO2xldCBpPWFbc107KG89PntsZXQgbD1cIlwiLHUscCxkO2ZvcihsZXQgYyBvZiBvKXtpZih0eXBlb2YgYz09XCJzdHJpbmdcIiYmW1wiYWNjdXJhY3lcIixcImFjY1wiLFwiY3Jvc3NlbnRyb3B5XCIsXCJjZVwiXS5pbmRleE9mKGMpIT09LTEpe2xldCBtPXRoaXMuaW50ZXJuYWxPdXRwdXRTaGFwZXNbc107bVttLmxlbmd0aC0xXT09PTF8fHRoaXMubG9zc0Z1bmN0aW9uc1tzXT09PUNmP1tcImFjY3VyYWN5XCIsXCJhY2NcIl0uaW5kZXhPZihjKSE9PS0xP3A9YjA6W1wiY3Jvc3NlbnRyb3B5XCIsXCJjZVwiXS5pbmRleE9mKGMpIT09LTEmJihwPVAyKTp0aGlzLmxvc3NGdW5jdGlvbnNbc109PT1ubT9bXCJhY2N1cmFjeVwiLFwiYWNjXCJdLmluZGV4T2YoYykhPT0tMT9wPUwyOltcImNyb3NzZW50cm9weVwiLFwiY2VcIl0uaW5kZXhPZihjKSE9PS0xJiYocD16Mik6W1wiYWNjdXJhY3lcIixcImFjY1wiXS5pbmRleE9mKGMpIT09LTE/cD15MDpbXCJjcm9zc2VudHJvcHlcIixcImNlXCJdLmluZGV4T2YoYykhPT0tMSYmKHA9eDApO2xldCBmO1tcImFjY3VyYWN5XCIsXCJhY2NcIl0uaW5kZXhPZihjKSE9PS0xP2Y9XCJhY2NcIjpbXCJjcm9zc2VudHJvcHlcIixcImNlXCJdLmluZGV4T2YoYykhPT0tMSYmKGY9XCJjZVwiKSxkPXAsdT1sK2Z9ZWxzZSBkPUxIKGMpLHU9bCtTaChjKTtsZXQgaDtyaSh1LCgpPT57aD1kfSkscihzLHUsaCl9fSkoaSl9fSksdGhpcy5jb2xsZWN0ZWRUcmFpbmFibGVXZWlnaHRzPXRoaXMudHJhaW5hYmxlV2VpZ2h0c31jaGVja1RyYWluYWJsZVdlaWdodHNDb25zaXN0ZW5jeSgpe3RoaXMuY29sbGVjdGVkVHJhaW5hYmxlV2VpZ2h0cyE9bnVsbCYmdGhpcy50cmFpbmFibGVXZWlnaHRzLmxlbmd0aCE9PXRoaXMuY29sbGVjdGVkVHJhaW5hYmxlV2VpZ2h0cy5sZW5ndGgmJmNvbnNvbGUud2FybihcIkRpc2NyZXBhbmN5IGJldHdlZW4gdHJhaW5hYmxld2VpZ2h0cyBhbmQgY29sbGVjdGVkIHRyYWluYWJsZSB3ZWlnaHRzLiBEaWQgeW91IHNldCBgbW9kZWwudHJhaW5hYmxlYCB3aXRob3V0IGNhbGxpbmcgYG1vZGVsLmNvbXBpbGUoKWAgYWZ0ZXJ3YXJkcz9cIil9ZXZhbHVhdGUoZSx0LG49e30pe2xldCBhPW4uYmF0Y2hTaXplPT1udWxsPzMyOm4uYmF0Y2hTaXplO2h4KGEpO2xldCByPXRoaXMuc3RhbmRhcmRpemVVc2VyRGF0YVhZKGUsdCwhMCxhKTt0cnl7bGV0IHM9clswXS5jb25jYXQoclsxXSk7dGhpcy5tYWtlVGVzdEZ1bmN0aW9uKCk7bGV0IGk9dGhpcy50ZXN0RnVuY3Rpb24sbz10aGlzLnRlc3RMb29wKGkscyxhLG4udmVyYm9zZSxuLnN0ZXBzKTtyZXR1cm4gTW4obyl9ZmluYWxseXtQYShyWzBdLGUpLFBhKHJbMV0sdCl9fWFzeW5jIGV2YWx1YXRlRGF0YXNldChlLHQpe3JldHVybiB0aGlzLm1ha2VUZXN0RnVuY3Rpb24oKSxlaih0aGlzLGUsdCl9Y2hlY2tOdW1TYW1wbGVzKGUsdCxuLGE9XCJzdGVwc1wiKXtsZXQgcjtpZihuIT1udWxsKXtpZihyPW51bGwsdCE9bnVsbCl0aHJvdyBuZXcgVihgSWYgJHthfSBpcyBzZXQsIGJhdGNoU2l6ZSBtdXN0IGJlIG51bGwgb3IgdW5kZWZpbmVkLkdvdCBiYXRjaFNpemUgPSAke3R9YCl9ZWxzZSBpZihlIT1udWxsKUFycmF5LmlzQXJyYXkoZSk/cj1lWzBdLnNoYXBlWzBdOnI9ZS5zaGFwZVswXTtlbHNlIHRocm93IG5ldyBWKGBFaXRoZXIgdGhlIGlucHV0IGRhdGEgc2hvdWxkIGhhdmUgYSBkZWZpbmVkIHNoYXBlLCBvciAke2F9IHNob3VkIGJlIHNwZWNpZmllZC5gKTtyZXR1cm4gcn1leGVjdXRlKGUsdCl7aWYoQXJyYXkuaXNBcnJheSh0KSYmdC5sZW5ndGg9PT0wKXRocm93IG5ldyBWKFwiYG91dHB1dHNgIGlzIGFuIGVtcHR5IEFycmF5LCB3aGljaCBpcyBub3QgYWxsb3dlZC5cIik7bGV0IG49QXJyYXkuaXNBcnJheSh0KSxhPW4/dDpbdF0scj10aGlzLnJldHJpZXZlU3ltYm9saWNUZW5zb3JzKGEpLHM9bmV3IENsO2lmKGUgaW5zdGFuY2VvZiBDZSYmKGU9W2VdKSxBcnJheS5pc0FycmF5KGUpKXtpZihlLmxlbmd0aCE9PXRoaXMuaW5wdXRzLmxlbmd0aCl0aHJvdyBuZXcgVihgVGhlIG51bWJlciBvZiBpbnB1dHMgcHJvdmlkZWQgKCR7ZS5sZW5ndGh9KSBkb2VzIG5vdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGlucHV0cyBvZiB0aGlzIG1vZGVsICgke3RoaXMuaW5wdXRzLmxlbmd0aH0pLmApO2ZvcihsZXQgbz0wO288dGhpcy5pbnB1dHMubGVuZ3RoOysrbylzLmFkZCh0aGlzLmlucHV0c1tvXSxlW29dKX1lbHNlIGZvcihsZXQgbyBvZiB0aGlzLmlucHV0cyl7bGV0IGw9ZVtvLm5hbWVdO2lmKGw9PW51bGwpdGhyb3cgbmV3IFYoYE5vIHZhbHVlIGlzIHByb3ZpZGVkIGZvciB0aGUgbW9kZWwncyBpbnB1dCAke28ubmFtZX1gKTtzLmFkZChvLGwpfWxldCBpPXRjKHIscyk7cmV0dXJuIG4/aTppWzBdfXJldHJpZXZlU3ltYm9saWNUZW5zb3JzKGUpe2xldCB0PWJpKG51bGwsZS5sZW5ndGgpLG49ZS5sZW5ndGg7Zm9yKGxldCBhIG9mIHRoaXMubGF5ZXJzKXtsZXQgcj1BcnJheS5pc0FycmF5KGEub3V0cHV0KT9hLm91dHB1dDpbYS5vdXRwdXRdLHM9ci5tYXAoaT0+aS5uYW1lKTtmb3IobGV0IGk9MDtpPGUubGVuZ3RoOysraSl7bGV0IG89cy5pbmRleE9mKGVbaV0pO2lmKG8hPT0tMSYmKHRbaV09cltvXSxuLS0pLG49PT0wKWJyZWFrfWlmKG49PT0wKWJyZWFrfWlmKG4+MCl7bGV0IGE9W107dGhyb3cgdC5mb3JFYWNoKChyLHMpPT57cj09bnVsbCYmYS5wdXNoKGVbc10pfSksbmV3IFYoYENhbm5vdCBmaW5kIFN5bWJvbGljVGVuc29ycyBmb3Igb3V0cHV0IG5hbWUocyk6ICR7SlNPTi5zdHJpbmdpZnkoYSl9YCl9cmV0dXJuIHR9cHJlZGljdExvb3AoZSx0PTMyLG49ITEpe3JldHVybiBPKCgpPT57bGV0IGE9dGhpcy5jaGVja051bVNhbXBsZXMoZSk7aWYobil0aHJvdyBuZXcgemUoXCJWZXJib3NlIHByZWRpY3RMb29wKCkgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7bGV0IHI9bXgoYSx0KSxzPXRoaXMub3V0cHV0cy5tYXAoaT0+W10pO2ZvcihsZXQgaT0wO2k8ci5sZW5ndGg7KytpKU8oKCk9PntsZXQgbz1yW2ldWzBdLGw9cltpXVsxXSx1PVhwKGUsbyxsKSxwPVtdO2lmKEFycmF5LmlzQXJyYXkodSkpZm9yKGxldCBjPTA7Yzx1Lmxlbmd0aDsrK2MpcC5wdXNoKHtrZXk6dGhpcy5pbnB1dHNbY10sdmFsdWU6dVtjXX0pO2Vsc2UgcC5wdXNoKHtrZXk6dGhpcy5pbnB1dHNbMF0sdmFsdWU6dX0pO2xldCBkPW5ldyBDbChwKTtyZXR1cm4gdGModGhpcy5vdXRwdXRzLGQpfSkuZm9yRWFjaCgobyxsKT0+c1tsXS5wdXNoKG8pKTtyZXR1cm4gTW4ocy5tYXAoaT0+ZXQoaSwwKSkpfSl9cHJlZGljdChlLHQ9e30pe2xldCBuPUcyKGUpO0FJKG4sdGhpcy5pbnB1dE5hbWVzLHRoaXMuZmVlZElucHV0U2hhcGVzLCExKTt0cnl7bGV0IGE9dC5iYXRjaFNpemU9PW51bGw/MzI6dC5iYXRjaFNpemU7cmV0dXJuIGh4KGEpLHRoaXMucHJlZGljdExvb3AobixhKX1maW5hbGx5e1BhKG4sZSl9fXByZWRpY3RPbkJhdGNoKGUpe0FJKGUsdGhpcy5pbnB1dE5hbWVzLHRoaXMuZmVlZElucHV0U2hhcGVzLCEwKTtsZXQgdD0oQXJyYXkuaXNBcnJheShlKT9lWzBdOmUpLnNoYXBlWzBdO3JldHVybiB0aGlzLnByZWRpY3RMb29wKGUsdCl9c3RhbmRhcmRpemVVc2VyRGF0YVhZKGUsdCxuPSEwLGEpe2lmKHRoaXMub3B0aW1pemVyXz09bnVsbCl0aHJvdyBuZXcgYXIoXCJZb3UgbXVzdCBjb21waWxlIGEgbW9kZWwgYmVmb3JlIHRyYWluaW5nL3Rlc3RpbmcuIFVzZSBMYXllcnNNb2RlbC5jb21waWxlKG1vZGVsQ29tcGlsZUFyZ3MpLlwiKTtsZXQgcj1bXTtmb3IobGV0IHM9MDtzPHRoaXMuZmVlZE91dHB1dFNoYXBlcy5sZW5ndGg7KytzKXtsZXQgaT10aGlzLmZlZWRPdXRwdXRTaGFwZXNbc107dGhpcy5mZWVkTG9zc0Zuc1tzXT09PW5tP3IucHVzaChpLnNsaWNlKDAsaS5sZW5ndGgtMSkuY29uY2F0KFsxXSkpOnIucHVzaChpKX1pZihlPV9JKGUsdGhpcy5mZWVkSW5wdXROYW1lcyx0aGlzLmZlZWRJbnB1dFNoYXBlcywhMSxcImlucHV0XCIpLHQ9X0kodCx0aGlzLmZlZWRPdXRwdXROYW1lcyxyLCExLFwidGFyZ2V0XCIpLG5qKGUsdCxudWxsKSxhaih0LHRoaXMuZmVlZExvc3NGbnMsdGhpcy5mZWVkT3V0cHV0U2hhcGVzKSx0aGlzLnN0YXRlZnVsJiZhIT1udWxsJiZhPjAmJmVbMF0uc2hhcGVbMF0lYSE9PTApdGhyb3cgbmV3IFYoYEluIGEgc3RhdGVmdWwgbmV0d29yaywgeW91IHNob3VsZCBvbmx5IHBhc3MgaW5wdXRzIHdpdGggYSBudW1iZXIgb2Ygc2FtcGxlcyB0aGF0IGlzIGRpdmlzaWJsZSBieSB0aGUgYmF0Y2ggc2l6ZSAke2F9LiBGb3VuZDogJHtlWzBdLnNoYXBlWzBdfSBzYW1wbGUocykuYCk7cmV0dXJuW2UsdF19YXN5bmMgc3RhbmRhcmRpemVVc2VyRGF0YShlLHQsbixhLHI9ITAscyl7bGV0W2ksb109dGhpcy5zdGFuZGFyZGl6ZVVzZXJEYXRhWFkoZSx0LHIscyk7aWYobiE9bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJzYW1wbGUgd2VpZ2h0IGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtsZXQgbD1udWxsO2lmKGEhPW51bGwpe2xldCB1PUIyKGEsdGhpcy5vdXRwdXROYW1lcyk7bD1bXTtmb3IobGV0IHA9MDtwPHUubGVuZ3RoOysrcClsLnB1c2goYXdhaXQgVjIob1twXSxudWxsLHVbcF0pKX1yZXR1cm5baSxvLGxdfXRlc3RMb29wKGUsdCxuLGE9MCxyKXtyZXR1cm4gTygoKT0+e2xldCBzPXRoaXMuY2hlY2tOdW1TYW1wbGVzKHQsbixyLFwic3RlcHNcIiksaT1bXTtpZihhPjApdGhyb3cgbmV3IHplKFwiVmVyYm9zZSBtb2RlIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO2lmKHIhPW51bGwpdGhyb3cgbmV3IHplKFwic3RlcHMgbW9kZSBpbiB0ZXN0TG9vcCgpIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7e2xldCBvPW14KHMsbiksbD1qZShVYSgwLHMpKTtmb3IobGV0IHU9MDt1PG8ubGVuZ3RoOysrdSl7bGV0IHA9b1t1XVswXSxkPW9bdV1bMV0sYz1zaShsLHAsZC1wKSxoPWp4KHQsYyksbT1lKGgpO2lmKHU9PT0wKWZvcihsZXQgZj0wO2Y8bS5sZW5ndGg7KytmKWkucHVzaCh4ZSgwKSk7Zm9yKGxldCBmPTA7ZjxtLmxlbmd0aDsrK2Ype2xldCBnPW1bZl07aVtmXT1YKGlbZl0seihkLXAsZykpfX1mb3IobGV0IHU9MDt1PGkubGVuZ3RoOysrdSlpW3VdPWhlKGlbdV0scyl9cmV0dXJuIGl9KX1nZXREZWR1cGVkTWV0cmljc05hbWVzKCl7bGV0IGU9dGhpcy5tZXRyaWNzTmFtZXMsdD1bXTtmb3IobGV0IG49MDtuPGUubGVuZ3RoOysrbil7bGV0IGE9ZVtuXSxyPWE7aWYoZkkoZSxhKT4xKXtsZXQgcz1mSShlLnNsaWNlKDAsbiksYSk7cis9YF8ke3N9YH10LnB1c2gocil9cmV0dXJuIHR9bWFrZVRyYWluRnVuY3Rpb24oKXtyZXR1cm4gZT0+e2xldCB0PVtdLG49ZS5zbGljZSgwLHRoaXMuaW5wdXRzLmxlbmd0aCksYT1lLnNsaWNlKHRoaXMuaW5wdXRzLmxlbmd0aCx0aGlzLmlucHV0cy5sZW5ndGgrdGhpcy5vdXRwdXRzLmxlbmd0aCkscj1lLnNsaWNlKHRoaXMuaW5wdXRzLmxlbmd0aCt0aGlzLm91dHB1dHMubGVuZ3RoLHRoaXMuaW5wdXRzLmxlbmd0aCt0aGlzLm91dHB1dHMubGVuZ3RoKjIpLHM9W10saT0oKT0+e2xldCBsPVtdO2ZvcihsZXQgYz0wO2M8dGhpcy5pbnB1dHMubGVuZ3RoOysrYylsLnB1c2goe2tleTp0aGlzLmlucHV0c1tjXSx2YWx1ZTpuW2NdfSk7bGV0IHU9bmV3IENsKGwpLHA9dGModGhpcy5vdXRwdXRzLHUse3RyYWluaW5nOiEwfSksZDtmb3IobGV0IGM9MDtjPHRoaXMubG9zc0Z1bmN0aW9ucy5sZW5ndGg7KytjKXtsZXQgaD10aGlzLmxvc3NGdW5jdGlvbnNbY10sbT1oKGFbY10scFtjXSk7cltjXSE9bnVsbCYmKG09S0gobSxyW2NdKSk7bGV0IGY9Q3QobSk7dC5wdXNoKGYpLGM9PT0wP2Q9bTpkPVgoZCxtKX1mb3IobGV0IGM9MDtjPHRoaXMubWV0cmljc1RlbnNvcnMubGVuZ3RoOysrYyl7bGV0IGg7aWYodGhpcy5vdXRwdXRzLmxlbmd0aD4xJiZjPHRoaXMub3V0cHV0cy5sZW5ndGgpaD10W2NdO2Vsc2V7bGV0IG09dGhpcy5tZXRyaWNzVGVuc29yc1tjXVswXSxmPXRoaXMubWV0cmljc1RlbnNvcnNbY11bMV07aD1DdChtKGFbZl0scFtmXSkpfUh0KGgpLHMucHVzaChoKX1yZXR1cm4gZD1DdChkKSx0aGlzLmNhbGN1bGF0ZUxvc3NlcygpLmZvckVhY2goYz0+e2Q9WChkLGMpfSksZH0sbz10aGlzLmNvbGxlY3RlZFRyYWluYWJsZVdlaWdodHMubWFwKGw9PmwucmVhZCgpKTtyZXR1cm5bdGhpcy5vcHRpbWl6ZXJfLm1pbmltaXplKGksITAsbyldLmNvbmNhdChzKX19bWFrZVRlc3RGdW5jdGlvbigpe3RoaXMudGVzdEZ1bmN0aW9uPWU9Pk8oKCk9PntsZXQgdD1bXSxuLGE9ZS5zbGljZSgwLHRoaXMuaW5wdXRzLmxlbmd0aCkscj1lLnNsaWNlKHRoaXMuaW5wdXRzLmxlbmd0aCx0aGlzLmlucHV0cy5sZW5ndGgrdGhpcy5vdXRwdXRzLmxlbmd0aCkscz1bXTtmb3IobGV0IGw9MDtsPHRoaXMuaW5wdXRzLmxlbmd0aDsrK2wpcy5wdXNoKHtrZXk6dGhpcy5pbnB1dHNbbF0sdmFsdWU6YVtsXX0pO2xldCBpPW5ldyBDbChzKSxvPXRjKHRoaXMub3V0cHV0cyxpKTtmb3IobGV0IGw9MDtsPHRoaXMubG9zc0Z1bmN0aW9ucy5sZW5ndGg7KytsKXtsZXQgdT10aGlzLmxvc3NGdW5jdGlvbnNbbF0scD1DdCh1KHJbbF0sb1tsXSkpO2w9PT0wP249cDpuPVgobixwKSx0LnB1c2gobil9Zm9yKGxldCBsPTA7bDx0aGlzLm1ldHJpY3NUZW5zb3JzLmxlbmd0aDsrK2wpe2xldCB1PXRoaXMubWV0cmljc1RlbnNvcnNbbF1bMF0scD10aGlzLm1ldHJpY3NUZW5zb3JzW2xdWzFdLGQ9Q3QodShyW3BdLG9bcF0pKTt0LnB1c2goZCl9cmV0dXJuIHR9KX1hc3luYyBmaXQoZSx0LG49e30pe2lmKHRoaXMuaXNUcmFpbmluZyl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3RhcnQgdHJhaW5pbmcgYmVjYXVzZSBhbm90aGVyIGZpdCgpIGNhbGwgaXMgb25nb2luZy5cIik7dGhpcy5pc1RyYWluaW5nPSEwO2xldCBhLHIscyxpLG8sbCx1LHAsZDt0cnl7bGV0IGM9bi5iYXRjaFNpemU9PW51bGw/MzI6bi5iYXRjaFNpemU7aHgoYyk7bGV0IGg9YXdhaXQgdGhpcy5zdGFuZGFyZGl6ZVVzZXJEYXRhKGUsdCxuLnNhbXBsZVdlaWdodCxuLmNsYXNzV2VpZ2h0LCExLGMpO2E9aFswXSxyPWhbMV0sZD1oWzJdO2xldCBtPSExLGY7aWYobi52YWxpZGF0aW9uRGF0YSE9bnVsbCYmbi52YWxpZGF0aW9uRGF0YS5sZW5ndGg+MCl7aWYobT0hMCxuLnZhbGlkYXRpb25EYXRhLmxlbmd0aD09PTIpbz1uLnZhbGlkYXRpb25EYXRhWzBdLGw9bi52YWxpZGF0aW9uRGF0YVsxXTtlbHNlIHRocm93IG4udmFsaWRhdGlvbkRhdGEubGVuZ3RoPT09Mz9uZXcgemUoXCJ2YWxpZGF0aW9uRGF0YSBpbmNsdWRpbmcgc2FtcGxlIHdlaWdodHMgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXCIpOm5ldyBWKGBXaGVuIHBhc3NpbmcgdmFsaWRhdGlvbiBkYXRhLCBpdCBtdXN0IGNvbnRhaW4gMiAodmFsWCwgdmFsWSkgb3IgMyAodmFsWCwgdmFsWSwgdmFsU2FtcGxlV2VpZ2h0KSBpdGVtczsgJHtuLnZhbGlkYXRpb25EYXRhfSBpcyBpbnZhbGlkLmApO2xldCBOPWF3YWl0IHRoaXMuc3RhbmRhcmRpemVVc2VyRGF0YShvLGwsbnVsbCxudWxsLCEwLGMpO3U9TlswXSxwPU5bMV0sZj11LmNvbmNhdChwKX1lbHNlIGlmKG4udmFsaWRhdGlvblNwbGl0IT1udWxsJiZuLnZhbGlkYXRpb25TcGxpdD4wJiZuLnZhbGlkYXRpb25TcGxpdDwxKXttPSEwO2xldCBOPU1hdGguZmxvb3IoYVswXS5zaGFwZVswXSooMS1uLnZhbGlkYXRpb25TcGxpdCkpLEM9YVswXS5zaGFwZVswXTt1PVhwKGEsTixDKSxzPWEsYT1YcChhLDAsTikscD1YcChyLE4sQyksaT1yLHI9WHAociwwLE4pLGY9dS5jb25jYXQocCl9ZWxzZSBuLnZhbGlkYXRpb25TdGVwcyE9bnVsbCYmKG09ITApO2xldCBnPWEuY29uY2F0KHIpLmNvbmNhdChkKTt0aGlzLmNoZWNrVHJhaW5hYmxlV2VpZ2h0c0NvbnNpc3RlbmN5KCk7bGV0IGI9dGhpcy5tYWtlVHJhaW5GdW5jdGlvbigpLHk9dGhpcy5nZXREZWR1cGVkTWV0cmljc05hbWVzKCkseCx2O20/KHRoaXMubWFrZVRlc3RGdW5jdGlvbigpLHg9dGhpcy50ZXN0RnVuY3Rpb24sdj15LnNsaWNlKCkuY29uY2F0KHkubWFwKE49PlwidmFsX1wiK04pKSk6KHg9bnVsbCxmPVtdLHY9eS5zbGljZSgpKTtsZXQgST1EMihuLmNhbGxiYWNrcyxuLnlpZWxkRXZlcnkpO3JldHVybiBhd2FpdCB0aGlzLmZpdExvb3AoYixnLHksYyxuLmVwb2NocyxuLnZlcmJvc2UsSSx4LGYsbi5zaHVmZmxlLHYsbi5pbml0aWFsRXBvY2gsbnVsbCxudWxsKX1maW5hbGx5e3RoaXMuaXNUcmFpbmluZz0hMSxQYShhLGUpLFBhKHIsdCksUGEocyxlKSxQYShpLHQpLFBhKHUsbyksUGEocCxsKSxkIT1udWxsJiZFZShkKX19YXN5bmMgZml0TG9vcChlLHQsbixhLHIscyxpLG8sbCx1LHAsZCxjLGgpe2E9PW51bGwmJihhPTMyKSxyPT1udWxsJiYocj0xKSx1PT1udWxsJiYodT0hMCksZD09bnVsbCYmKGQ9MCk7bGV0IG09ITE7aWYobyE9bnVsbCYmbCE9bnVsbCYmKG09ITApLGghPW51bGwmJihtPSEwLGM9PW51bGwpKXRocm93IG5ldyBWKFwiQ2FuIG9ubHkgdXNlIGB2YWxpZGF0aW9uU3RlcHNgIHdoZW4gZG9pbmcgc3RlcC13aXNlIHRyYWluaW5nLCBpLmUuLCBgc3RlcHNQZXJFcG9jaGAgbXVzdCBiZSBzZXQuXCIpO2xldCBmPXRoaXMuY2hlY2tOdW1TYW1wbGVzKHQsYSxjLFwic3RlcHNfcGVyX2Vwb2NoXCIpLGc7ZiE9bnVsbCYmKGc9VWEoMCxmKSkscz09bnVsbCYmKHM9MSk7bGV0e2NhbGxiYWNrTGlzdDpiLGhpc3Rvcnk6eX09UjIoaSxzLHIsZCxmLGMsYSxtLHApO2Iuc2V0TW9kZWwodGhpcyksdGhpcy5oaXN0b3J5PXksYXdhaXQgYi5vblRyYWluQmVnaW4oKSx0aGlzLnN0b3BUcmFpbmluZ189ITE7Zm9yKGxldCB4PWQ7eDxyOysreCl7YXdhaXQgYi5vbkVwb2NoQmVnaW4oeCk7bGV0IHY9e307aWYoYyE9bnVsbCl0aHJvdyBuZXcgemUoXCJzdGVwc1BlckVwb2NoIG1vZGUgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7e2lmKHU9PT1cImJhdGNoXCIpdGhyb3cgbmV3IHplKFwiYmF0Y2ggc2h1ZmZsaW5nIGlzIG5vdCBpbXBsZW1uZXRlZCB5ZXRcIik7dSYmdy5zaHVmZmxlKGcpO2xldCBJPWplKGcpLE49bXgoZixhKTtmb3IobGV0IEM9MDtDPE4ubGVuZ3RoOysrQyl7bGV0IF89e307aWYoYXdhaXQgYi5vbkJhdGNoQmVnaW4oQyxfKSxPKCgpPT57bGV0IEY9TltDXVswXSxEPU5bQ11bMV0sJD1zaShJLEYsRC1GKTtfLmJhdGNoPUMsXy5zaXplPUQtRjtsZXQgUz1qeCh0LCQpLE09ZShTKTtmb3IobGV0IEI9MDtCPG4ubGVuZ3RoOysrQil7bGV0IFU9bltCXSxIPU1bQl07X1tVXT1ILEh0KEgpfWlmKEM9PT1OLmxlbmd0aC0xJiZtKXtsZXQgQj10aGlzLnRlc3RMb29wKG8sbCxhKTtmb3IobGV0IFU9MDtVPG4ubGVuZ3RoOysrVSl7bGV0IEg9bltVXSxxPUJbVV07SHQocSksdltcInZhbF9cIitIXT1xfX19KSxhd2FpdCBiLm9uQmF0Y2hFbmQoQyxfKSxfMihfKSx0aGlzLnN0b3BUcmFpbmluZ18pYnJlYWt9SS5kaXNwb3NlKCl9aWYoYXdhaXQgYi5vbkVwb2NoRW5kKHgsdiksdGhpcy5zdG9wVHJhaW5pbmdfKWJyZWFrfXJldHVybiBhd2FpdCBiLm9uVHJhaW5FbmQoKSxhd2FpdCB0aGlzLmhpc3Rvcnkuc3luY0RhdGEoKSx0aGlzLmhpc3Rvcnl9YXN5bmMgZml0RGF0YXNldChlLHQpe3JldHVybiBaSCh0aGlzLGUsdCl9YXN5bmMgdHJhaW5PbkJhdGNoKGUsdCl7bGV0IG49YXdhaXQgdGhpcy5zdGFuZGFyZGl6ZVVzZXJEYXRhKGUsdCksYT1uWzBdLHI9blsxXSxzPXRoaXMubWFrZVRyYWluRnVuY3Rpb24oKShhLmNvbmNhdChyKSksaT1bXTtmb3IobGV0IG8gb2Ygcyl7bGV0IGw9YXdhaXQgby5kYXRhKCk7aS5wdXNoKGxbMF0pfXJldHVybiBFZShzKSxQYShuWzBdLGUpLFBhKG5bMV0sdCksTW4oaSl9Z2V0TmFtZWRXZWlnaHRzKGUpe2xldCB0PVtdLG49ZSE9bnVsbCYmZS50cmFpbmFibGVPbmx5LGE9bj90aGlzLnRyYWluYWJsZVdlaWdodHM6dGhpcy53ZWlnaHRzLHI9dGhpcy5nZXRXZWlnaHRzKG4pO2ZvcihsZXQgcz0wO3M8YS5sZW5ndGg7KytzKW4mJiFhW3NdLnRyYWluYWJsZXx8dC5wdXNoKHtuYW1lOmFbc10ub3JpZ2luYWxOYW1lLHRlbnNvcjpyW3NdfSk7cmV0dXJuIHR9c2V0IHN0b3BUcmFpbmluZyhlKXt0aGlzLnN0b3BUcmFpbmluZ189ZX1nZXQgc3RvcFRyYWluaW5nKCl7cmV0dXJuIHRoaXMuc3RvcFRyYWluaW5nX31nZXQgb3B0aW1pemVyKCl7cmV0dXJuIHRoaXMub3B0aW1pemVyX31zZXQgb3B0aW1pemVyKGUpe3RoaXMub3B0aW1pemVyXyE9PWUmJih0aGlzLm9wdGltaXplcl89ZSx0aGlzLmlzT3B0aW1pemVyT3duZWQ9ITEpfWRpc3Bvc2UoKXtsZXQgZT1zdXBlci5kaXNwb3NlKCk7aWYoZS5yZWZDb3VudEFmdGVyRGlzcG9zZT09PTAmJnRoaXMub3B0aW1pemVyIT1udWxsJiZ0aGlzLmlzT3B0aW1pemVyT3duZWQpe2xldCB0PUtoKCkubnVtVGVuc29yczt0aGlzLm9wdGltaXplcl8uZGlzcG9zZSgpLGUubnVtRGlzcG9zZWRWYXJpYWJsZXMrPXQtS2goKS5udW1UZW5zb3JzfXJldHVybiBlfWdldExvc3NJZGVudGlmaWVycygpe2xldCBlO2lmKHR5cGVvZiB0aGlzLmxvc3M9PVwic3RyaW5nXCIpZT1Jcih0aGlzLmxvc3MpO2Vsc2UgaWYoQXJyYXkuaXNBcnJheSh0aGlzLmxvc3MpKXtmb3IobGV0IHQgb2YgdGhpcy5sb3NzKWlmKHR5cGVvZiB0IT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihcIlNlcmlhbGl6YXRpb24gb2Ygbm9uLXN0cmluZyBsb3NzIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO2U9dGhpcy5sb3NzLm1hcCh0PT5Jcih0KSl9ZWxzZXtsZXQgdD1PYmplY3Qua2V5cyh0aGlzLmxvc3MpO2U9e307bGV0IG49dGhpcy5sb3NzO2ZvcihsZXQgYSBvZiB0KWlmKHR5cGVvZiBuW2FdPT1cInN0cmluZ1wiKWVbYV09SXIoblthXSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJTZXJpYWxpemF0aW9uIG9mIG5vbi1zdHJpbmcgbG9zcyBpcyBub3Qgc3VwcG9ydGVkLlwiKX1yZXR1cm4gZX1nZXRNZXRyaWNJZGVudGlmaWVycygpe2lmKHR5cGVvZiB0aGlzLm1ldHJpY3M9PVwic3RyaW5nXCJ8fHR5cGVvZiB0aGlzLm1ldHJpY3M9PVwiZnVuY3Rpb25cIilyZXR1cm5bSXIoU2godGhpcy5tZXRyaWNzKSldO2lmKEFycmF5LmlzQXJyYXkodGhpcy5tZXRyaWNzKSlyZXR1cm4gdGhpcy5tZXRyaWNzLm1hcChlPT5JcihTaChlKSkpO3tsZXQgZT17fTtmb3IobGV0IHQgaW4gdGhpcy5tZXRyaWNzKWVbdF09SXIoU2godGhpcy5tZXRyaWNzW3RdKSk7cmV0dXJuIGV9fWdldFRyYWluaW5nQ29uZmlnKCl7cmV0dXJue2xvc3M6dGhpcy5nZXRMb3NzSWRlbnRpZmllcnMoKSxtZXRyaWNzOnRoaXMuZ2V0TWV0cmljSWRlbnRpZmllcnMoKSxvcHRpbWl6ZXJfY29uZmlnOntjbGFzc19uYW1lOnRoaXMub3B0aW1pemVyLmdldENsYXNzTmFtZSgpLGNvbmZpZzp0aGlzLm9wdGltaXplci5nZXRDb25maWcoKX19fWxvYWRUcmFpbmluZ0NvbmZpZyhlKXtpZihlLndlaWdodGVkX21ldHJpY3MhPW51bGwpdGhyb3cgbmV3IEVycm9yKFwiTG9hZGluZyB3ZWlnaHRfbWV0cmljcyBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik7aWYoZS5sb3NzX3dlaWdodHMhPW51bGwpdGhyb3cgbmV3IEVycm9yKFwiTG9hZGluZyBsb3NzX3dlaWdodHMgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO2lmKGUuc2FtcGxlX3dlaWdodF9tb2RlIT1udWxsKXRocm93IG5ldyBFcnJvcihcIkxvYWRpbmcgc2FtcGxlX3dlaWdodF9tb2RlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtsZXQgdD1JYyhlLm9wdGltaXplcl9jb25maWcpLG49QmEodCksYTtpZih0eXBlb2YgZS5sb3NzPT1cInN0cmluZ1wiKWE9SnMoZS5sb3NzKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkoZS5sb3NzKSlhPWUubG9zcy5tYXAocz0+SnMocykpO2Vsc2UgaWYoZS5sb3NzIT1udWxsKXthPXt9O2ZvcihsZXQgcyBpbiBlLmxvc3MpYVtzXT1KcyhlLmxvc3Nbc10pfWxldCByO2lmKEFycmF5LmlzQXJyYXkoZS5tZXRyaWNzKSlyPWUubWV0cmljcy5tYXAocz0+SnMocykpO2Vsc2UgaWYoZS5tZXRyaWNzIT1udWxsKXtyPXt9O2ZvcihsZXQgcyBpbiBlLm1ldHJpY3MpcltzXT1KcyhlLm1ldHJpY3Nbc10pfXRoaXMuY29tcGlsZSh7bG9zczphLG1ldHJpY3M6cixvcHRpbWl6ZXI6bn0pfWFzeW5jIHNhdmUoZSx0KXtpZih0eXBlb2YgZT09XCJzdHJpbmdcIil7bGV0IHI9anQuZ2V0U2F2ZUhhbmRsZXJzKGUpO2lmKHIubGVuZ3RoPT09MCl0aHJvdyBuZXcgVihgQ2Fubm90IGZpbmQgYW55IHNhdmUgaGFuZGxlcnMgZm9yIFVSTCAnJHtlfSdgKTtpZihyLmxlbmd0aD4xKXRocm93IG5ldyBWKGBGb3VuZCBtb3JlIHRoYW4gb25lICgke3IubGVuZ3RofSkgc2F2ZSBoYW5kbGVycyBmb3IgVVJMICcke2V9J2ApO2U9clswXX1pZihlLnNhdmU9PW51bGwpdGhyb3cgbmV3IFYoXCJMYXllcnNNb2RlbC5zYXZlKCkgY2Fubm90IHByb2NlZWQgYmVjYXVzZSB0aGUgSU9IYW5kbGVyIHByb3ZpZGVkIGRvZXMgbm90IGhhdmUgdGhlIGBzYXZlYCBhdHRyaWJ1dGUgZGVmaW5lZC5cIik7bGV0IG49YXdhaXQganQuZW5jb2RlV2VpZ2h0cyh0aGlzLmdldE5hbWVkV2VpZ2h0cyh0KSksYT17bW9kZWxUb3BvbG9neTp0aGlzLnRvSlNPTihudWxsLCExKSxmb3JtYXQ6c2osZ2VuZXJhdGVkQnk6YFRlbnNvckZsb3cuanMgdGZqcy1sYXllcnMgdiR7djB9YCxjb252ZXJ0ZWRCeTpudWxsfTtpZih0IT1udWxsJiZ0LmluY2x1ZGVPcHRpbWl6ZXImJnRoaXMub3B0aW1pemVyIT1udWxsKXthLnRyYWluaW5nQ29uZmlnPXRoaXMuZ2V0VHJhaW5pbmdDb25maWcoKTtsZXQgcj1cIm9wdGltaXplclwiLHtkYXRhOnMsc3BlY3M6aX09YXdhaXQganQuZW5jb2RlV2VpZ2h0cyhhd2FpdCB0aGlzLm9wdGltaXplci5nZXRXZWlnaHRzKCkscik7bi5zcGVjcy5wdXNoKC4uLmkpLG4uZGF0YT1qdC5jb25jYXRlbmF0ZUFycmF5QnVmZmVycyhbbi5kYXRhLHNdKX1yZXR1cm4gdGhpcy51c2VyRGVmaW5lZE1ldGFkYXRhIT1udWxsJiYoTkkodGhpcy51c2VyRGVmaW5lZE1ldGFkYXRhLHRoaXMubmFtZSwhMCksYS51c2VyRGVmaW5lZE1ldGFkYXRhPXRoaXMudXNlckRlZmluZWRNZXRhZGF0YSksYS53ZWlnaHREYXRhPW4uZGF0YSxhLndlaWdodFNwZWNzPW4uc3BlY3MsZS5zYXZlKGEpfXNldFVzZXJEZWZpbmVkTWV0YWRhdGEoZSl7TkkoZSx0aGlzLm5hbWUpLHRoaXMudXNlckRlZmluZWRNZXRhZGF0YT1lfWdldFVzZXJEZWZpbmVkTWV0YWRhdGEoKXtyZXR1cm4gdGhpcy51c2VyRGVmaW5lZE1ldGFkYXRhfX07RXIuY2xhc3NOYW1lPVwiTW9kZWxcIjtuZS5yZWdpc3RlckNsYXNzKEVyKTt2YXIgSDI9Y2xhc3MgZXh0ZW5kcyBFcnt9O0gyLmNsYXNzTmFtZT1cIkZ1bmN0aW9uYWxcIjtuZS5yZWdpc3RlckNsYXNzKEgyKTthc3luYyBmdW5jdGlvbiBpaihlLHQpe1wibW9kZWxUb3BvbG9neVwiaW4gZXx8KGU9e21vZGVsVG9wb2xvZ3k6ZX0pLGU9ZTtsZXQgbj1lLm1vZGVsVG9wb2xvZ3k7bi5tb2RlbF9jb25maWchPW51bGwmJihuPW4ubW9kZWxfY29uZmlnKTtsZXQgYT1JYyhuKSxyPUJhKGEsdCk7aWYoZS53ZWlnaHRzTWFuaWZlc3QhPW51bGwpe2xldCBzPWF3YWl0IGp0LmxvYWRXZWlnaHRzKGUud2VpZ2h0c01hbmlmZXN0LGUucGF0aFByZWZpeCxyLndlaWdodHMubWFwKG89Pm8ub3JpZ2luYWxOYW1lKSksaT17fTtmb3IobGV0IG8gb2Ygci53ZWlnaHRzKWlbby5vcmlnaW5hbE5hbWVdPXNbby5vcmlnaW5hbE5hbWVdO3IubG9hZFdlaWdodHMoaSksRWUocyl9cmV0dXJuIHJ9YXN5bmMgZnVuY3Rpb24gb2ooZSx0KXtpZih0PT1udWxsJiYodD17fSksdHlwZW9mIGU9PVwic3RyaW5nXCIpe2xldCBuPWp0LmdldExvYWRIYW5kbGVycyhlLHQpO2lmKG4ubGVuZ3RoPT09MCluLnB1c2goanQuYnJvd3NlckhUVFBSZXF1ZXN0KGUsdCkpO2Vsc2UgaWYobi5sZW5ndGg+MSl0aHJvdyBuZXcgVihgRm91bmQgbW9yZSB0aGFuIG9uZSAoJHtuLmxlbmd0aH0pIGxvYWQgaGFuZGxlcnMgZm9yIFVSTCAnJHtlfSdgKTtlPW5bMF19cmV0dXJuIGxqKGUsdm9pZCAwLHQpfWFzeW5jIGZ1bmN0aW9uIGxqKGUsdCxuKXtpZihuPT1udWxsJiYobj17fSksZS5sb2FkPT1udWxsKXRocm93IG5ldyBWKFwiQ2Fubm90IHByb2NlZWQgd2l0aCBtb2RlbCBsb2FkaW5nIGJlY2F1c2UgdGhlIElPSGFuZGxlciBwcm92aWRlZCBkb2VzIG5vdCBoYXZlIHRoZSBgbG9hZGAgbWV0aG9kIGltcGxlbWVudGVkLlwiKTtsZXQgYT1hd2FpdCBlLmxvYWQoKSxyPWEubW9kZWxUb3BvbG9neTtyLm1vZGVsX2NvbmZpZyE9bnVsbCYmKHI9ci5tb2RlbF9jb25maWcpO2xldCBzPW4uc3RyaWN0PT1udWxsPyEwOm4uc3RyaWN0LGk9YS53ZWlnaHREYXRhIT1udWxsJiZhLndlaWdodFNwZWNzIT1udWxsJiZzLG89QmEoSWMociksdCxpKSxsPWEudHJhaW5pbmdDb25maWc7aWYobCE9bnVsbCYmby5sb2FkVHJhaW5pbmdDb25maWcobCksYS51c2VyRGVmaW5lZE1ldGFkYXRhIT1udWxsJiZvLnNldFVzZXJEZWZpbmVkTWV0YWRhdGEoYS51c2VyRGVmaW5lZE1ldGFkYXRhKSxhLndlaWdodERhdGEhPW51bGwpe2lmKGEud2VpZ2h0U3BlY3M9PW51bGwpdGhyb3cgbmV3IFYoXCJMYXllcnNNb2RlbCBhcnRpZmFjdHMgY29udGFpbnMgd2VpZ2h0IGRhdGEsIGJ1dCBub3Qgd2VpZ2h0IHNwZWNzLiBUaGVyZWZvcmUgbG9hZGluZyBvZiB3ZWlnaHRzIGNhbm5vdCBwcm9jZWVkLlwiKTtsZXR7bW9kZWxXZWlnaHRzOnUsb3B0aW1pemVyV2VpZ2h0czpwfT11aihhLndlaWdodERhdGEsYS53ZWlnaHRTcGVjcyk7by5sb2FkV2VpZ2h0cyh1LHMpLG8ub3B0aW1pemVyIT1udWxsJiZwLmxlbmd0aD4wJiZhd2FpdCBvLm9wdGltaXplci5zZXRXZWlnaHRzKHApLEVlKHUpLEVlKHAubWFwKGQ9PmQudGVuc29yKSl9cmV0dXJuIG99ZnVuY3Rpb24gdWooZSx0KXtsZXQgbj1qdC5kZWNvZGVXZWlnaHRzKGUsdCksYT17fSxyPVtdO3JldHVybiB0LmZvckVhY2gocz0+e3MuZ3JvdXA9PT1cIm9wdGltaXplclwiP3IucHVzaCh7bmFtZTpzLm5hbWUsdGVuc29yOm5bcy5uYW1lXX0pOmFbcy5uYW1lXT1uW3MubmFtZV19KSx7bW9kZWxXZWlnaHRzOmEsb3B0aW1pemVyV2VpZ2h0czpyfX12YXIgRWY9Y2xhc3MgS3ggZXh0ZW5kcyBFcntjb25zdHJ1Y3Rvcih0KXtpZihzdXBlcih7aW5wdXRzOltdLG91dHB1dHM6W119KSx0PXR8fHt9LHRoaXMudHJhaW5hYmxlPSEwLHRoaXMuYnVpbHQ9ITEsdGhpcy5uYW1lPXQubmFtZSE9bnVsbD90Lm5hbWU6Z2YoXCJzZXF1ZW50aWFsX1wiKSx0LmxheWVycyE9bnVsbClmb3IobGV0IG4gb2YgdC5sYXllcnMpdGhpcy5hZGQobil9Y2hlY2tTaGFwZSh0KXtpZih0LmluYm91bmROb2Rlc1swXS5vdXRwdXRUZW5zb3JzWzBdLnNoYXBlLnNvbWUobj0+bjwwKSl0aHJvdyBuZXcgVihgTmVnYXRpdmUgZGltZW5zaW9uIHNpemUgY2F1c2VkIGJ5IGFkZGluZyBsYXllciAke3QubmFtZX0gd2l0aCBpbnB1dCBzaGFwZSBbJHt0LmluYm91bmROb2Rlc1swXS5pbnB1dFRlbnNvcnNbMF0uc2hhcGV9XWApfWFkZCh0KXtsZXQgbj10IGluc3RhbmNlb2YgS3h8fHQgaW5zdGFuY2VvZiBFcixhO2lmKG4pe2lmKGE9dCxhLm91dHB1dHMubGVuZ3RoIT09MSl0aHJvdyBuZXcgVihcIkFsbCBsYXllcnMgaW4gYSBTZXF1ZW50aWFsIG1vZGVsIHNob3VsZCBoYXZlIGEgc2luZ2xlIG91dHB1dCB0ZW5zb3IuIEZvciBtdWx0aS1vdXRwdXQgbGF5ZXJzLCB1c2UgdGhlIGZ1bmN0aW9uYWwgQVBJLlwiKTtpZihhLmlucHV0cy5sZW5ndGghPT0xKXRocm93IG5ldyBWKFwiQWxsIGxheWVycyBpbiBhIFNlcXVlbnRpYWwgbW9kZWwgc2hvdWxkIGhhdmUgYSBzaW5nbGUgaW5wdXQgdGVuc29yLiBGb3IgbXVsdGktaW5wdXQgbGF5ZXJzLCB1c2UgdGhlIGZ1bmN0aW9uYWwgQVBJLlwiKX1pZih0aGlzLm91dHB1dHMubGVuZ3RoPT09MCl7aWYodC5pbmJvdW5kTm9kZXMubGVuZ3RoPT09MCl7aWYodC5iYXRjaElucHV0U2hhcGU9PW51bGwpdGhyb3cgbmV3IFYoXCJUaGUgZmlyc3QgbGF5ZXIgaW4gYSBTZXF1ZW50aWFsIG1vZGVsIG11c3QgZ2V0IGFuIGBpbnB1dFNoYXBlYCBvciBgYmF0Y2hJbnB1dFNoYXBlYCBhcmd1bWVudC5cIik7bGV0IHI9UzIoe2JhdGNoU2hhcGU6dC5iYXRjaElucHV0U2hhcGUsZHR5cGU6dC5kdHlwZSxuYW1lOnQubmFtZStcIl9pbnB1dFwifSk7dC5hcHBseShyKX1pZihuKXRoaXMub3V0cHV0cz1hLm91dHB1dHMsdGhpcy5pbnB1dHM9YS5pbnB1dHM7ZWxzZXtpZih0LmluYm91bmROb2Rlcy5sZW5ndGghPT0xKXRocm93IG5ldyBWKGBBIGxheWVyIGFkZGVkIHRvIGEgU2VxdWVudGlhbCBtb2RlbCBtdXN0IG5vdCBhbHJlYWR5IGJlIGNvbm5lY3RlZCBzb21ld2hlcmUgZWxzZS4gTGF5ZXJzTW9kZWwgcmVjZWl2ZWQgbGF5ZXIgJHt0Lm5hbWV9IHdoaWNoIGhhcyAke3QuaW5ib3VuZE5vZGVzLmxlbmd0aH0gcHJlLWV4aXN0aW5nIGluYm91bmQgY29ubmVjdGlvbnMuYCk7aWYodC5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0VGVuc29ycy5sZW5ndGghPT0xKXRocm93IG5ldyBWKFwiQWxsIGxheWVycyBpbiBhIFNlcXVlbnRpYWwgbW9kZWwgc2hvdWxkIGhhdmUgYSBzaW5nbGUgb3V0cHV0IHRlbnNvci4gRm9yIG11bHRpLW91dHB1dCBsYXllcnMsIHVzZSB0aGUgZnVuY3Rpb25hbCBBUEkuXCIpO3RoaXMuY2hlY2tTaGFwZSh0KSx0aGlzLm91dHB1dHM9W3QuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFRlbnNvcnNbMF1dLHRoaXMuaW5wdXRzPUkyKHRoaXMub3V0cHV0c1swXSl9dGhpcy5pbmJvdW5kTm9kZXM9W10sbmV3IE5mKHtvdXRib3VuZExheWVyOnRoaXMsaW5ib3VuZExheWVyczpbXSxub2RlSW5kaWNlczpbXSx0ZW5zb3JJbmRpY2VzOltdLGlucHV0VGVuc29yczp0aGlzLmlucHV0cyxvdXRwdXRUZW5zb3JzOnRoaXMub3V0cHV0cyxpbnB1dE1hc2tzOmJpKG51bGwsdGhpcy5pbnB1dHMubGVuZ3RoKSxvdXRwdXRNYXNrczpbbnVsbF0saW5wdXRTaGFwZXM6dGhpcy5pbnB1dHMubWFwKHI9PnIuc2hhcGUpLG91dHB1dFNoYXBlczp0aGlzLm91dHB1dHNbMF0uc2hhcGV9KX1lbHNle2xldCByPXQuYXBwbHkodGhpcy5vdXRwdXRzWzBdKTtpZihBcnJheS5pc0FycmF5KHIpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBbGwgbGF5ZXJzIGluIGEgU2VxdWVudGlhbCBtb2RlbCBzaG91bGQgaGF2ZSBhIHNpbmdsZSBvdXRwdXQgdGVuc29yLiBGb3IgbXVsdGktb3V0cHV0IGxheWVycywgdXNlIHRoZSBmdW5jdGlvbmFsIEFQSS5cIik7dGhpcy5jaGVja1NoYXBlKHQpLHRoaXMub3V0cHV0cz1bcl0sdGhpcy5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0VGVuc29ycz10aGlzLm91dHB1dHMsdGhpcy5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0U2hhcGVzPVt0aGlzLm91dHB1dHNbMF0uc2hhcGVdfXRoaXMubGF5ZXJzLnB1c2godCksdGhpcy5idWlsdD0hMX1wb3AoKXtpZih0aGlzLmxheWVycy5sZW5ndGg9PT0wKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGVyZSBhcmUgbm8gbGF5ZXJzIGluIHRoZSBtb2RlbC5cIik7aWYodGhpcy5sYXllcnMucG9wKCksdGhpcy5sYXllcnMubGVuZ3RoPT09MCl0aGlzLm91dHB1dHM9W10sdGhpcy5pbmJvdW5kTm9kZXM9W10sdGhpcy5vdXRib3VuZE5vZGVzPVtdO2Vsc2V7bGV0IHQ9dGhpcy5sYXllcnMubGVuZ3RoLTE7dGhpcy5sYXllcnNbdF0ub3V0Ym91bmROb2Rlcz1bXSx0aGlzLm91dHB1dHM9W3RoaXMubGF5ZXJzW3RdLm91dHB1dF0sdGhpcy5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0VGVuc29ycz10aGlzLm91dHB1dHMsdGhpcy5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0U2hhcGVzPVt0aGlzLm91dHB1dHNbMF0uc2hhcGVdfX1jYWxsKHQsbil7cmV0dXJuIHRoaXMubW9kZWw9PW51bGwmJnRoaXMuYnVpbGQoKSx0aGlzLm1vZGVsLmNhbGwodCxuKX1idWlsZCh0KXtpZihKZSh0KSx0aGlzLmlucHV0cy5sZW5ndGg9PT0wfHx0aGlzLm91dHB1dHMubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU2VxdWVudGlhbCBtb2RlbCBjYW5ub3QgYmUgYnVpbHQ6IG1vZGVsIGlzIGVtcHR5LiBBZGQgc29tZSBsYXllcnMgZmlyc3QuXCIpO3RoaXMubW9kZWw9bmV3IEVyKHtpbnB1dHM6dGhpcy5pbnB1dHMsb3V0cHV0czp0aGlzLm91dHB1dHNbMF0sbmFtZTp0aGlzLm5hbWUrXCJfbW9kZWxcIn0pLHRoaXMubW9kZWwudHJhaW5hYmxlPXRoaXMudHJhaW5hYmxlLHRoaXMuc3VwcG9ydHNNYXNraW5nPXRoaXMubW9kZWwuc3VwcG9ydHNNYXNraW5nLHRoaXMuaW5wdXRMYXllcnM9dGhpcy5tb2RlbC5pbnB1dExheWVycyx0aGlzLmlucHV0TGF5ZXJzTm9kZUluZGljZXM9dGhpcy5tb2RlbC5pbnB1dExheWVyc05vZGVJbmRpY2VzLHRoaXMuaW5wdXRMYXllcnNUZW5zb3JJbmRpY2VzPXRoaXMubW9kZWwuaW5wdXRMYXllcnNUZW5zb3JJbmRpY2VzLHRoaXMub3V0cHV0TGF5ZXJzPXRoaXMubW9kZWwub3V0cHV0TGF5ZXJzLHRoaXMub3V0cHV0TGF5ZXJzTm9kZUluZGljZXM9dGhpcy5tb2RlbC5vdXRwdXRMYXllcnNOb2RlSW5kaWNlcyx0aGlzLm91dHB1dExheWVyc1RlbnNvckluZGljZXM9dGhpcy5tb2RlbC5vdXRwdXRMYXllcnNUZW5zb3JJbmRpY2VzLHRoaXMubm9kZXNCeURlcHRoPXRoaXMubW9kZWwubm9kZXNCeURlcHRoLHRoaXMuY29udGFpbmVyTm9kZXM9dGhpcy5tb2RlbC5jb250YWluZXJOb2Rlcyx0aGlzLm91dHB1dE5hbWVzPXRoaXMubW9kZWwub3V0cHV0TmFtZXMsdGhpcy5pbnB1dE5hbWVzPXRoaXMubW9kZWwuaW5wdXROYW1lcyx0aGlzLmJ1aWx0PSEwfWNvdW50UGFyYW1zKCl7cmV0dXJuIHRoaXMuYnVpbHR8fHRoaXMuYnVpbGQoKSxzdXBlci5jb3VudFBhcmFtcygpfXN1bW1hcnkodCxuLGE9Y29uc29sZS5sb2cpe3RoaXMuYnVpbHR8fHRoaXMuYnVpbGQoKSxzdXBlci5zdW1tYXJ5KHQsbixhKX1zZXRXZWlnaHRzKHQpe3RoaXMubW9kZWw9PW51bGwmJnRoaXMuYnVpbGQoKSx0aGlzLm1vZGVsLnNldFdlaWdodHModCl9ZXZhbHVhdGUodCxuLGE9e30pe2lmKCF0aGlzLmJ1aWx0KXRocm93IG5ldyBhcihcIlRoZSBtb2RlbCBuZWVkcyB0byBiZSBjb21waWxlZCBiZWZvcmUgYmVpbmcgdXNlZC5cIik7cmV0dXJuIHRoaXMubW9kZWwuZXZhbHVhdGUodCxuLGEpfWFzeW5jIGV2YWx1YXRlRGF0YXNldCh0LG4pe2lmKCF0aGlzLmJ1aWx0KXRocm93IG5ldyBhcihcIlRoZSBtb2RlbCBuZWVkcyB0byBiZSBjb21waWxlZCBiZWZvcmUgYmVpbmcgdXNlZC5cIik7cmV0dXJuIHRoaXMubW9kZWwuZXZhbHVhdGVEYXRhc2V0KHQsbil9cHJlZGljdCh0LG49e30pe3JldHVybiB0aGlzLm1vZGVsPT1udWxsJiZ0aGlzLmJ1aWxkKCksdGhpcy5tb2RlbC5wcmVkaWN0KHQsbil9cHJlZGljdE9uQmF0Y2godCl7cmV0dXJuIHRoaXMubW9kZWw9PW51bGwmJnRoaXMuYnVpbGQoKSx0aGlzLm1vZGVsLnByZWRpY3RPbkJhdGNoKHQpfWNvbXBpbGUodCl7dGhpcy5idWlsZCgpLHRoaXMubW9kZWwuY29tcGlsZSh0KSx0aGlzLm9wdGltaXplcl89dGhpcy5tb2RlbC5vcHRpbWl6ZXIsdGhpcy5pc09wdGltaXplck93bmVkPXRoaXMubW9kZWwuaXNPcHRpbWl6ZXJPd25lZCx0aGlzLmxvc3M9dGhpcy5tb2RlbC5sb3NzLHRoaXMubWV0cmljcz10aGlzLm1vZGVsLm1ldHJpY3MsdGhpcy5tZXRyaWNzVGVuc29ycz10aGlzLm1vZGVsLm1ldHJpY3NUZW5zb3JzLHRoaXMubWV0cmljc05hbWVzPXRoaXMubW9kZWwubWV0cmljc05hbWVzfWdldCBvcHRpbWl6ZXIoKXtyZXR1cm4gdGhpcy5tb2RlbD09bnVsbD92b2lkIDA6dGhpcy5tb2RlbC5vcHRpbWl6ZXJ9c2V0IG9wdGltaXplcih0KXt0aGlzLm1vZGVsLm9wdGltaXplcj10fWFzeW5jIGZpdCh0LG4sYT17fSl7aWYoIXRoaXMuYnVpbHQpdGhyb3cgbmV3IGFyKFwiVGhlIG1vZGVsIG5lZWRzIHRvIGJlIGNvbXBpbGVkIGJlZm9yZSBiZWluZyB1c2VkLlwiKTtyZXR1cm4gdGhpcy5tb2RlbC5maXQodCxuLGEpfWFzeW5jIGZpdERhdGFzZXQodCxuKXtpZighdGhpcy5idWlsdCl0aHJvdyBuZXcgYXIoXCJUaGUgbW9kZWwgbmVlZHMgdG8gYmUgY29tcGlsZWQgYmVmb3JlIGJlaW5nIHVzZWQuXCIpO3JldHVybiB0aGlzLm1vZGVsLmZpdERhdGFzZXQodCxuKX1hc3luYyB0cmFpbk9uQmF0Y2godCxuKXtyZXR1cm4gdGhpcy5tb2RlbC50cmFpbk9uQmF0Y2godCxuKX1zdGF0aWMgZnJvbUNvbmZpZyh0LG4sYT17fSxyPSExKXtsZXQgcyxpPXt9O2lmKG4gaW5zdGFuY2VvZiBBcnJheSl7aWYoblswXS5jbGFzc05hbWU9PW51bGx8fG5bMF0uY2xhc3NOYW1lPT09XCJNZXJnZVwiKXRocm93IG5ldyBWKFwiTGVnYWN5IHNlcmlhbGl6YXRpb24gZm9ybWF0IG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtzPW59ZWxzZSB3LmFzc2VydChuLmxheWVycyE9bnVsbCwoKT0+XCJXaGVuIHRoZSBjb25maWcgZGF0YSBmb3IgYSBTZXF1ZW50aWFsIG1vZGVsIGlzIG5vdCBhbiBBcnJheSwgaXQgbXVzdCBiZSBhbiBPYmplY3QgdGhhdCBjb250YWlucyB0aGUgJ2xheWVycycgZmllbGQuXCIpLHM9bi5sYXllcnMsZGVsZXRlIG4ubGF5ZXJzLGk9bjtsZXQgbz1uZXcgdChpKTtpZighKG8gaW5zdGFuY2VvZiBLeCkpdGhyb3cgbmV3IHplKGBTZXF1ZW50aWFsLmZyb21Db25maWcgY2FsbGVkIG9uIG5vbi1TZXF1ZW50aWFsIGlucHV0OiAke299YCk7Zm9yKGxldCBsIG9mIHMpe2xldCB1PUJhKGwsdm9pZCAwLHIpO3ImJnUuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZCghMCksby5hZGQodSl9cmV0dXJuIG99c2V0IHN0b3BUcmFpbmluZyh0KXtpZih0aGlzLm1vZGVsPT1udWxsKXRocm93IG5ldyBWKFwiQ2Fubm90IHNldCB0aGUgc3RvcFRyYWluaW5nIHByb3BlcnR5IG9mIGEgc2VxdWVudGlhbCBtb2RlbCBiZWZvcmUgaXQgaXMgY29tcGlsZWQuXCIpO3RoaXMubW9kZWwuc3RvcFRyYWluaW5nPXR9Z2V0IHN0b3BUcmFpbmluZygpe2lmKHRoaXMubW9kZWw9PW51bGwpdGhyb3cgbmV3IFYoXCJDYW5ub3QgZ2V0IHRoZSBzdG9wVHJhaW5pbmcgcHJvcGVydHkgb2YgYSBzZXF1ZW50aWFsIG1vZGVsIGJlZm9yZSBpdCBpcyBjb21waWxlZC5cIik7cmV0dXJuIHRoaXMubW9kZWwuc3RvcFRyYWluaW5nfWdldENvbmZpZygpe2xldCB0PVtdO2ZvcihsZXQgbiBvZiB0aGlzLmxheWVycyl7bGV0IGE9e307YS5jbGFzc05hbWU9bi5nZXRDbGFzc05hbWUoKSxhLmNvbmZpZz1uLmdldENvbmZpZygpLHQucHVzaChhKX1yZXR1cm57bmFtZTp0aGlzLm5hbWUsbGF5ZXJzOnR9fX07RWYuY2xhc3NOYW1lPVwiU2VxdWVudGlhbFwiO25lLnJlZ2lzdGVyQ2xhc3MoRWYpO2Z1bmN0aW9uIHBqKGUpe3JldHVybiBuZXcgRXIoZSl9ZnVuY3Rpb24gY2ooZSl7cmV0dXJuIG5ldyBFZihlKX1mdW5jdGlvbiBqMihlKXtyZXR1cm4gUzIoZSl9ZnVuY3Rpb24gZGooZSx0KXtmMC5yZWdpc3RlckNhbGxiYWNrQ29uc3RydWN0b3IoZSx0KX12YXIgeG49Y2xhc3MgZXh0ZW5kcyBuZS5TZXJpYWxpemFibGV7Z2V0Q29uZmlnKCl7cmV0dXJue319fSxxMj1jbGFzcyBleHRlbmRzIHhue2FwcGx5KGUsdD0xKXtyZXR1cm4gRkcoZSx0KX19O3EyLmNsYXNzTmFtZT1cImVsdVwiO25lLnJlZ2lzdGVyQ2xhc3MocTIpO3ZhciBLMj1jbGFzcyBleHRlbmRzIHhue2FwcGx5KGUpe3JldHVybiBRbShlKX19O0syLmNsYXNzTmFtZT1cInNlbHVcIjtuZS5yZWdpc3RlckNsYXNzKEsyKTt2YXIgWDI9Y2xhc3MgZXh0ZW5kcyB4bnthcHBseShlKXtyZXR1cm4gS2UoZSl9fTtYMi5jbGFzc05hbWU9XCJyZWx1XCI7bmUucmVnaXN0ZXJDbGFzcyhYMik7dmFyIFkyPWNsYXNzIGV4dGVuZHMgeG57YXBwbHkoZSl7cmV0dXJuIE8oKCk9PmRzKDYsS2UoZSkpKX19O1kyLmNsYXNzTmFtZT1cInJlbHU2XCI7bmUucmVnaXN0ZXJDbGFzcyhZMik7dmFyIFoyPWNsYXNzIGV4dGVuZHMgeG57YXBwbHkoZSl7cmV0dXJuIGV9fTtaMi5jbGFzc05hbWU9XCJsaW5lYXJcIjtuZS5yZWdpc3RlckNsYXNzKFoyKTt2YXIgSjI9Y2xhc3MgZXh0ZW5kcyB4bnthcHBseShlKXtyZXR1cm4gaGEoZSl9fTtKMi5jbGFzc05hbWU9XCJzaWdtb2lkXCI7bmUucmVnaXN0ZXJDbGFzcyhKMik7dmFyIFEyPWNsYXNzIGV4dGVuZHMgeG57YXBwbHkoZSl7cmV0dXJuIERHKGUpfX07UTIuY2xhc3NOYW1lPVwiaGFyZFNpZ21vaWRcIjtuZS5yZWdpc3RlckNsYXNzKFEyKTt2YXIgZUM9Y2xhc3MgZXh0ZW5kcyB4bnthcHBseShlKXtyZXR1cm4gR28oZSl9fTtlQy5jbGFzc05hbWU9XCJzb2Z0cGx1c1wiO25lLnJlZ2lzdGVyQ2xhc3MoZUMpO3ZhciB0Qz1jbGFzcyBleHRlbmRzIHhue2FwcGx5KGUpe3JldHVybiAkRyhlKX19O3RDLmNsYXNzTmFtZT1cInNvZnRzaWduXCI7bmUucmVnaXN0ZXJDbGFzcyh0Qyk7dmFyIG5DPWNsYXNzIGV4dGVuZHMgeG57YXBwbHkoZSl7cmV0dXJuIGNzKGUpfX07bkMuY2xhc3NOYW1lPVwidGFuaFwiO25lLnJlZ2lzdGVyQ2xhc3MobkMpO3ZhciB3MD1jbGFzcyBleHRlbmRzIHhue2FwcGx5KGUsdD0tMSl7cmV0dXJuIHFhKGUsdCl9fTt3MC5jbGFzc05hbWU9XCJzb2Z0bWF4XCI7bmUucmVnaXN0ZXJDbGFzcyh3MCk7dmFyIGFDPWNsYXNzIGV4dGVuZHMgeG57YXBwbHkoZSx0PS0xKXtyZXR1cm4gam0oZSx0KX19O2FDLmNsYXNzTmFtZT1cImxvZ1NvZnRtYXhcIjtuZS5yZWdpc3RlckNsYXNzKGFDKTt2YXIgckM9Y2xhc3MgZXh0ZW5kcyB4bnthcHBseShlKXtyZXR1cm4gTygoKT0+TygoKT0+e2xldCB0PU1hdGguc3FydCgyKSxuPXooLjUsWCgxLFVtKGhlKGUsdCkpKSk7cmV0dXJuIHooZSxuKX0pKX19O3JDLmNsYXNzTmFtZT1cImdlbHVcIjtuZS5yZWdpc3RlckNsYXNzKHJDKTt2YXIgc0M9Y2xhc3MgZXh0ZW5kcyB4bnthcHBseShlKXtyZXR1cm4gTygoKT0+eiguNSx6KGUsWCgxLGNzKHoocm4oaGUoMixNYXRoLlBJKSksWChlLHooLjA0NDcxNSx1cihlLDMpKSkpKSkpKSl9fTtzQy5jbGFzc05hbWU9XCJnZWx1X25ld1wiO25lLnJlZ2lzdGVyQ2xhc3Moc0MpO3ZhciBpQz1jbGFzcyBleHRlbmRzIHhue2FwcGx5KGUpe3JldHVybiBPKCgpPT56KGUsY3MoR28oZSkpKSl9fTtpQy5jbGFzc05hbWU9XCJtaXNoXCI7bmUucmVnaXN0ZXJDbGFzcyhpQyk7dmFyIG9DPWNsYXNzIGV4dGVuZHMgeG57YXBwbHkoZSx0PTEpe3JldHVybiBPKCgpPT56KGhhKHooZSx0KSksZSkpfX07b0MuY2xhc3NOYW1lPVwic3dpc2hcIjtuZS5yZWdpc3RlckNsYXNzKG9DKTtmdW5jdGlvbiBtcyhlKXtyZXR1cm4gZS5nZXRDbGFzc05hbWUoKX1mdW5jdGlvbiBmeChlLHQ9e30pe3JldHVybiB2ZChlLG5lLlNlcmlhbGl6YXRpb25NYXAuZ2V0TWFwKCkuY2xhc3NOYW1lTWFwLHQsXCJhY3RpdmF0aW9uXCIpfWZ1bmN0aW9uIGZzKGUpe2lmKGU9PW51bGwpe2xldCB0PXt9O3JldHVybiB0LmNsYXNzTmFtZT1cImxpbmVhclwiLHQuY29uZmlnPXt9LGZ4KHQpfWlmKHR5cGVvZiBlPT1cInN0cmluZ1wiKXtsZXQgdD17fTtyZXR1cm4gdC5jbGFzc05hbWU9ZSx0LmNvbmZpZz17fSxmeCh0KX1lbHNlIHJldHVybiBlIGluc3RhbmNlb2YgeG4/ZTpmeChlKX1mdW5jdGlvbiBrMChlKXtpZihlIT1udWxsJiZ0eXBlb2YgZSE9XCJvYmplY3RcIil0aHJvdyBuZXcgRXJyb3IoYEFyZ3VtZW50IHRvIEwxTDIgcmVndWxhcml6ZXIncyBjb25zdHJ1Y3RvciBpcyBleHBlY3RlZCB0byBiZSBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtlfWApfXZhciBsQz1jbGFzcyBleHRlbmRzIG5lLlNlcmlhbGl6YWJsZXt9LE5kPWNsYXNzIGV4dGVuZHMgbEN7Y29uc3RydWN0b3IoZSl7c3VwZXIoKSxrMChlKSx0aGlzLmwxPWU9PW51bGx8fGUubDE9PW51bGw/LjAxOmUubDEsdGhpcy5sMj1lPT1udWxsfHxlLmwyPT1udWxsPy4wMTplLmwyLHRoaXMuaGFzTDE9dGhpcy5sMSE9PTAsdGhpcy5oYXNMMj10aGlzLmwyIT09MH1hcHBseShlKXtyZXR1cm4gTygoKT0+e2xldCB0PUl0KFsxXSk7cmV0dXJuIHRoaXMuaGFzTDEmJih0PVgodCxmZSh6KHRoaXMubDEsTHQoZSkpKSkpLHRoaXMuaGFzTDImJih0PVgodCxmZSh6KHRoaXMubDIsa2QoZSkpKSkpLFcodCxbXSl9KX1nZXRDb25maWcoKXtyZXR1cm57bDE6dGhpcy5sMSxsMjp0aGlzLmwyfX1zdGF0aWMgZnJvbUNvbmZpZyhlLHQpe3JldHVybiBuZXcgZSh7bDE6dC5sMSxsMjp0LmwyfSl9fTtOZC5jbGFzc05hbWU9XCJMMUwyXCI7bmUucmVnaXN0ZXJDbGFzcyhOZCk7ZnVuY3Rpb24gaGooZSl7cmV0dXJuIGswKGUpLG5ldyBOZCh7bDE6ZSE9bnVsbD9lLmwxOm51bGwsbDI6MH0pfWZ1bmN0aW9uIG1qKGUpe3JldHVybiBrMChlKSxuZXcgTmQoe2wyOmUhPW51bGw/ZS5sMjpudWxsLGwxOjB9KX12YXIgRkk9e2wxbDI6XCJMMUwyXCJ9O2Z1bmN0aW9uIGZ0KGUpe3JldHVybiBRdyhlKX1mdW5jdGlvbiAkSShlLHQ9e30pe3JldHVybiB2ZChlLG5lLlNlcmlhbGl6YXRpb25NYXAuZ2V0TWFwKCkuY2xhc3NOYW1lTWFwLHQsXCJyZWd1bGFyaXplclwiKX1mdW5jdGlvbiBOdChlKXtpZihlPT1udWxsKXJldHVybiBudWxsO2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiKXtsZXQgdD17Y2xhc3NOYW1lOmUgaW4gRkk/RklbZV06ZSxjb25maWc6e319O3JldHVybiAkSSh0KX1lbHNlIHJldHVybiBlIGluc3RhbmNlb2YgbEM/ZTokSShlKX12YXIgSTA9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtzdXBlcihlPT1udWxsP3t9OmUpLHRoaXMuc3VwcG9ydHNNYXNraW5nPSEwLGUhPW51bGwmJih0aGlzLm1heFZhbHVlPWUubWF4VmFsdWUpfWNhbGwoZSx0KXtlPVRlKGUpO2xldCBuPUtlKGUpO3JldHVybiB0aGlzLm1heFZhbHVlIT1udWxsJiYobj1hbihuLDAsdGhpcy5tYXhWYWx1ZSkpLG59Y29tcHV0ZU91dHB1dFNoYXBlKGUpe3JldHVybiBlfWdldENvbmZpZygpe2xldCBlPXttYXhWYWx1ZTp0aGlzLm1heFZhbHVlfSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX19O0kwLmNsYXNzTmFtZT1cIlJlTFVcIjtuZS5yZWdpc3RlckNsYXNzKEkwKTt2YXIgUzA9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtzdXBlcihlPT1udWxsP3t9OmUpLHRoaXMuREVGQVVMVF9BTFBIQT0uMyxlPT1udWxsJiYoZT17fSksdGhpcy5hbHBoYT1lLmFscGhhPT1udWxsP3RoaXMuREVGQVVMVF9BTFBIQTplLmFscGhhfWNhbGwoZSx0KXtsZXQgbj1UZShlKTtyZXR1cm4gdWQobix0aGlzLmFscGhhKX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7cmV0dXJuIGV9Z2V0Q29uZmlnKCl7bGV0IGU9e2FscGhhOnRoaXMuYWxwaGF9LHQ9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfX07UzAuY2xhc3NOYW1lPVwiTGVha3lSZUxVXCI7bmUucmVnaXN0ZXJDbGFzcyhTMCk7dmFyIE4wPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7aWYoc3VwZXIoZT09bnVsbD97fTplKSx0aGlzLkRFRkFVTFRfQUxQSEFfSU5JVElBTElaRVI9XCJ6ZXJvc1wiLGU9PW51bGwmJihlPXt9KSx0aGlzLnN1cHBvcnRzTWFza2luZz0hMCx0aGlzLmFscGhhSW5pdGlhbGl6ZXI9U3QoZS5hbHBoYUluaXRpYWxpemVyfHx0aGlzLkRFRkFVTFRfQUxQSEFfSU5JVElBTElaRVIpLHRoaXMuYWxwaGFSZWd1bGFyaXplcj1OdChlLmFscGhhUmVndWxhcml6ZXIpLHRoaXMuYWxwaGFDb25zdHJhaW50PVl0KGUuYWxwaGFDb25zdHJhaW50KSxlLnNoYXJlZEF4ZXM9PW51bGwpdGhpcy5zaGFyZWRBeGVzPW51bGw7ZWxzZSBpZihBcnJheS5pc0FycmF5KGUuc2hhcmVkQXhlcykpdGhpcy5zaGFyZWRBeGVzPWUuc2hhcmVkQXhlcztlbHNlIGlmKHR5cGVvZiBlLnNoYXJlZEF4ZXM9PVwibnVtYmVyXCIpdGhpcy5zaGFyZWRBeGVzPVtlLnNoYXJlZEF4ZXNdO2Vsc2UgdGhyb3cgbmV3IFYoYEV4cGVjdGVkIHNoYXJlZEF4ZXMgdG8gYmUgYSBudW1iZXIgb3IgYW4gYXJyYXkgb2YgbnVtYmVycywgYnV0IGdvdCAke2Uuc2hhcmVkQXhlc31gKX1idWlsZChlKXtlPUplKGUpO2xldCB0PWUuc2xpY2UoMSk7aWYodGhpcy5zaGFyZWRBeGVzIT1udWxsKWZvcihsZXQgYSBvZiB0aGlzLnNoYXJlZEF4ZXMpdFthLTFdPTE7dGhpcy5hbHBoYT10aGlzLmFkZFdlaWdodChcImFscGhhXCIsdCxcImZsb2F0MzJcIix0aGlzLmFscGhhSW5pdGlhbGl6ZXIsdGhpcy5hbHBoYVJlZ3VsYXJpemVyLCEwLHRoaXMuYWxwaGFDb25zdHJhaW50KTtsZXQgbj17fTtpZih0aGlzLnNoYXJlZEF4ZXMhPW51bGwpZm9yKGxldCBhPTE7YTxlLmxlbmd0aDsrK2EpblthXT1lW2FdO3RoaXMuaW5wdXRTcGVjPVtuZXcgenQoe25kaW06ZS5sZW5ndGgsYXhlczpufSldLHRoaXMuYnVpbHQ9ITB9Y2FsbChlLHQpe3JldHVybiBlPVRlKGUpLGZkKGUsdGhpcy5hbHBoYS5yZWFkKCkpfWdldENvbmZpZygpe2xldCBlPXthbHBoYUluaXRpYWxpemVyOkV0KHRoaXMuYWxwaGFJbml0aWFsaXplciksYWxwaGFSZWd1bGFyaXplcjpmdCh0aGlzLmFscGhhUmVndWxhcml6ZXIpLGFscGhhQ29uc3RyYWludDpYdCh0aGlzLmFscGhhQ29uc3RyYWludCksc2hhcmVkQXhlczp0aGlzLnNoYXJlZEF4ZXN9LHQ9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfX07TjAuY2xhc3NOYW1lPVwiUFJlTFVcIjtuZS5yZWdpc3RlckNsYXNzKE4wKTt2YXIgVDA9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtpZihzdXBlcihlPT1udWxsP3t9OmUpLHRoaXMuREVGQVVMVF9BTFBIQT0xLGU9PW51bGwmJihlPXt9KSxlLmFscGhhIT1udWxsJiZlLmFscGhhIT09dGhpcy5ERUZBVUxUX0FMUEhBKXRocm93IG5ldyB6ZShgTm9uLWRlZmF1bHQgYWxwaGEgdmFsdWUgKCR7ZS5hbHBoYX0pIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIEVMVSBsYXllciB5ZXQuYCk7dGhpcy5hbHBoYT1lLmFscGhhPT1udWxsP3RoaXMuREVGQVVMVF9BTFBIQTplLmFscGhhfWNhbGwoZSx0KXtsZXQgbj1UZShlKTtyZXR1cm4gUXUobil9Y29tcHV0ZU91dHB1dFNoYXBlKGUpe3JldHVybiBlfWdldENvbmZpZygpe2xldCBlPXthbHBoYTp0aGlzLmFscGhhfSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX19O1QwLmNsYXNzTmFtZT1cIkVMVVwiO25lLnJlZ2lzdGVyQ2xhc3MoVDApO3ZhciBDMD1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe3N1cGVyKGU9PW51bGw/e306ZSksdGhpcy5ERUZBVUxUX1RIRVRBPTEsZT09bnVsbCYmKGU9e30pLHRoaXMudGhldGE9ZS50aGV0YT09bnVsbD90aGlzLkRFRkFVTFRfVEhFVEE6ZS50aGV0YX1jYWxsKGUsdCl7bGV0IG49VGUoZSk7cmV0dXJuIHoobixyZShDbihuLHRoaXMudGhldGEpLFwiZmxvYXQzMlwiKSl9Y29tcHV0ZU91dHB1dFNoYXBlKGUpe3JldHVybiBlfWdldENvbmZpZygpe2xldCBlPXt0aGV0YTp0aGlzLnRoZXRhfSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX19O0MwLmNsYXNzTmFtZT1cIlRocmVzaG9sZGVkUmVMVVwiO25lLnJlZ2lzdGVyQ2xhc3MoQzApO3ZhciBFMD1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe3N1cGVyKGU9PW51bGw/e306ZSksdGhpcy5ERUZBVUxUX0FYSVM9MSxlPT1udWxsJiYoZT17fSksdGhpcy5zb2Z0bWF4PW5ldyB3MCgpLmFwcGx5LHRoaXMuYXhpcz1lLmF4aXM9PW51bGw/dGhpcy5ERUZBVUxUX0FYSVM6ZS5heGlzfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e2xldCBuPVRlKGUpLGE9dC5tYXNrO2lmKGEhPW51bGwpe2xldCByPXoocGUoUG4obi5zaGFwZSkscmUoYSxuLmR0eXBlKSkseGUoLTFlOSkpO249WChuLHIpfXJldHVybiB0aGlzLmF4aXMgaW5zdGFuY2VvZiBBcnJheT90aGlzLmF4aXMubGVuZ3RoPjE/ZG4ocGUobixjZChuLHRoaXMuYXhpcywhMCkpKTp0aGlzLnNvZnRtYXgobix0aGlzLmF4aXNbMF0pOnRoaXMuc29mdG1heChuLHRoaXMuYXhpcyl9KX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7cmV0dXJuIGV9Z2V0Q29uZmlnKCl7bGV0IGU9e2F4aXM6dGhpcy5heGlzfSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX19O0UwLmNsYXNzTmFtZT1cIlNvZnRtYXhcIjtuZS5yZWdpc3RlckNsYXNzKEUwKTtmdW5jdGlvbiBGbChlLHQsbil7aWYodHlwZW9mIGU9PVwibnVtYmVyXCIpcmV0dXJuIGJpKGUsdCk7aWYoZS5sZW5ndGghPT10KXRocm93IG5ldyBWKGBUaGUgJHtufSBhcmd1bWVudCBtdXN0IGJlIGFuIGludGVnZXIgb3IgdHVwbGUgb2YgJHt0fSBpbnRlZ2Vycy4gUmVjZWl2ZWQ6ICR7ZS5sZW5ndGh9IGVsZW1lbnRzLmApO2ZvcihsZXQgYT0wO2E8dDsrK2Epe2xldCByPWVbYV07aWYoIUNHKHIpKXRocm93IG5ldyBWKGBUaGUgJHtufSBhcmd1bWVudCBtdXN0IGJlIGFuIGludGVnZXIgb3IgdHVwbGUgb2YgJHt0fSBpbnRlZ2Vycy4gUmVjZWl2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoZSl9IGluY2x1ZGluZyBhIG5vbi1pbnRlZ2VyIG51bWJlciAke3J9YCl9cmV0dXJuIGV9ZnVuY3Rpb24gVmEoZSx0LG4sYSxyPTEpe2lmKGU9PW51bGwpcmV0dXJuIGU7bGV0IHM9dCsodC0xKSooci0xKSxpO3JldHVybiBuPT09XCJzYW1lXCI/aT1lOmk9ZS1zKzEsTWF0aC5mbG9vcigoaSthLTEpL2EpfWZ1bmN0aW9uIG5yKGUsdCxuLGEpe2lmKGU9PW51bGwpcmV0dXJuIG51bGw7aWYoYT09PVwidmFsaWRcIillPWUqdCtocyhbbi10LDBdKTtlbHNlIGlmKGE9PT1cInNhbWVcIillPWUqdDtlbHNlIHRocm93IG5ldyBWKGBVbnN1cHBvcnQgcGFkZGluZyBtb2RlOiAke2F9LmApO3JldHVybiBlfWZ1bmN0aW9uIF8wKGUsdCl7cmV0dXJuIE8oKCk9PihSdCh0KSx0PT09XCJjaGFubmVsc0ZpcnN0XCI/RGUoZSxbMCwyLDMsMV0pOmUpKX1mdW5jdGlvbiB1QyhlLHQpe3JldHVybiBPKCgpPT4oUnQodCksdD09PVwiY2hhbm5lbHNGaXJzdFwiP0RlKGUsWzAsMiwzLDQsMV0pOmUpKX1mdW5jdGlvbiBmaihlLHQsbixhPTEscj1cInZhbGlkXCIscyxpPTEpe3JldHVybiBPKCgpPT57aWYocz09bnVsbCYmKHM9R2EoKSksUnQocyksZS5zaGFwZS5sZW5ndGghPT0zKXRocm93IG5ldyBWKGBUaGUgaW5wdXQgb2YgYSBjb252MWRXaXRoQmlhcyBvcGVyYXRpb24gc2hvdWxkIGJlIDMsIGJ1dCBpcyAke2Uuc2hhcGUubGVuZ3RofSBpbnN0ZWFkLmApO2lmKHQuc2hhcGUubGVuZ3RoIT09Myl0aHJvdyBuZXcgVihgVGhlIGtlcm5lbCBmb3IgYSBjb252MWRXaXRoQmlhcyBvcGVyYXRpb24gc2hvdWxkIGJlIDMsIGJ1dCBpcyAke3Quc2hhcGUubGVuZ3RofSBpbnN0ZWFkYCk7aWYobiE9bnVsbCYmbi5zaGFwZS5sZW5ndGghPT0xKXRocm93IG5ldyBWKGBUaGUgYmlhcyBmb3IgYSBjb252MWRXaXRoQmlhcyBvcGVyYXRpb24gc2hvdWxkIGJlIDEsIGJ1dCBpcyAke24uc2hhcGUubGVuZ3RofSBpbnN0ZWFkYCk7aWYocz09PVwiY2hhbm5lbHNGaXJzdFwiJiYoZT1EZShlLFswLDIsMV0pKSxyPT09XCJjYXVzYWxcIil0aHJvdyBuZXcgemUoXCJUaGUgc3VwcG9ydCBmb3IgQ0FVU0FMIHBhZGRpbmcgbW9kZSBpbiBjb252MWRXaXRoQmlhcyBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtsZXQgbz16bShlLHQsYSxyPT09XCJzYW1lXCI/XCJzYW1lXCI6XCJ2YWxpZFwiLFwiTldDXCIsaSk7cmV0dXJuIG4hPW51bGwmJihvPUthKG8sbikpLG99KX1mdW5jdGlvbiBESShlLHQsbixhPVsxLDFdLHI9XCJ2YWxpZFwiLHMsaSxvPW51bGwpe3JldHVybiBPKCgpPT57aWYocz09bnVsbCYmKHM9R2EoKSksUnQocyksZS5yYW5rIT09MyYmZS5yYW5rIT09NCl0aHJvdyBuZXcgVihgY29udjJkV2l0aEJpYXNBY3RpdmF0aW9uIGV4cGVjdHMgaW5wdXQgdG8gYmUgb2YgcmFuayAzIG9yIDQsIGJ1dCByZWNlaXZlZCAke2UucmFua30uYCk7aWYodC5yYW5rIT09MyYmdC5yYW5rIT09NCl0aHJvdyBuZXcgVihgY29udjJkV2l0aEJpYXNBY3RpdmF0aW9uIGV4cGVjdHMga2VybmVsIHRvIGJlIG9mIHJhbmsgMyBvciA0LCBidXQgcmVjZWl2ZWQgJHtlLnJhbmt9LmApO2xldCBsPV8wKGUscyk7aWYocj09PVwiY2F1c2FsXCIpdGhyb3cgbmV3IHplKFwiVGhlIHN1cHBvcnQgZm9yIENBVVNBTCBwYWRkaW5nIG1vZGUgaW4gY29udjFkV2l0aEJpYXMgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7cmV0dXJuIGw9VmwuY29udjJkKHt4OmwsZmlsdGVyOnQsc3RyaWRlczphLHBhZDpyPT09XCJzYW1lXCI/XCJzYW1lXCI6XCJ2YWxpZFwiLGRpbGF0aW9uczppLGRhdGFGb3JtYXQ6XCJOSFdDXCIsYmlhczpuLGFjdGl2YXRpb246b30pLHM9PT1cImNoYW5uZWxzRmlyc3RcIiYmKGw9RGUobCxbMCwzLDEsMl0pKSxsfSl9ZnVuY3Rpb24gZ2ooZSx0LG4sYT1bMSwxLDFdLHI9XCJ2YWxpZFwiLHMsaSl7cmV0dXJuIE8oKCk9PntpZihzPT1udWxsJiYocz1HYSgpKSxSdChzKSxlLnJhbmshPT00JiZlLnJhbmshPT01KXRocm93IG5ldyBWKGBjb252M2RXaXRoQmlhcyBleHBlY3RzIGlucHV0IHRvIGJlIG9mIHJhbmsgNCBvciA1LCBidXQgcmVjZWl2ZWQgJHtlLnJhbmt9LmApO2lmKHQucmFuayE9PTQmJnQucmFuayE9PTUpdGhyb3cgbmV3IFYoYGNvbnYzZFdpdGhCaWFzIGV4cGVjdHMga2VybmVsIHRvIGJlIG9mIHJhbmsgNCBvciA1LCBidXQgcmVjZWl2ZWQgJHtlLnJhbmt9LmApO2xldCBvPXVDKGUscyk7aWYocj09PVwiY2F1c2FsXCIpdGhyb3cgbmV3IHplKFwiVGhlIHN1cHBvcnQgZm9yIENBVVNBTCBwYWRkaW5nIG1vZGUgaW4gY29udjNkV2l0aEJpYXMgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7cmV0dXJuIG89YXcobyx0LGEscj09PVwic2FtZVwiP1wic2FtZVwiOlwidmFsaWRcIixcIk5ESFdDXCIsaSksbiE9bnVsbCYmKG89S2EobyxuKSkscz09PVwiY2hhbm5lbHNGaXJzdFwiJiYobz1EZShvLFswLDQsMSwyLDNdKSksb30pfXZhciBwQz1jbGFzcyBjQyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKHQsbil7aWYoc3VwZXIobiksdGhpcy5iaWFzPW51bGwsdGhpcy5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUj1cImdsb3JvdE5vcm1hbFwiLHRoaXMuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSPVwiemVyb3NcIixjQy52ZXJpZnlBcmdzKG4pLHRoaXMucmFuaz10LHRuKHRoaXMucmFuayxcInJhbmtcIiksdGhpcy5yYW5rIT09MSYmdGhpcy5yYW5rIT09MiYmdGhpcy5yYW5rIT09Myl0aHJvdyBuZXcgemUoYENvbnZvbHV0aW9uIGxheWVyIGZvciByYW5rIG90aGVyIHRoYW4gMSwgMiwgb3IgMyAoJHt0aGlzLnJhbmt9KSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LmApO2lmKHRoaXMua2VybmVsU2l6ZT1GbChuLmtlcm5lbFNpemUsdCxcImtlcm5lbFNpemVcIiksdGhpcy5zdHJpZGVzPUZsKG4uc3RyaWRlcz09bnVsbD8xOm4uc3RyaWRlcyx0LFwic3RyaWRlc1wiKSx0aGlzLnBhZGRpbmc9bi5wYWRkaW5nPT1udWxsP1widmFsaWRcIjpuLnBhZGRpbmcsdmEodGhpcy5wYWRkaW5nKSx0aGlzLmRhdGFGb3JtYXQ9bi5kYXRhRm9ybWF0PT1udWxsP1wiY2hhbm5lbHNMYXN0XCI6bi5kYXRhRm9ybWF0LFJ0KHRoaXMuZGF0YUZvcm1hdCksdGhpcy5hY3RpdmF0aW9uPWZzKG4uYWN0aXZhdGlvbiksdGhpcy51c2VCaWFzPW4udXNlQmlhcz09bnVsbD8hMDpuLnVzZUJpYXMsdGhpcy5iaWFzSW5pdGlhbGl6ZXI9U3Qobi5iaWFzSW5pdGlhbGl6ZXJ8fHRoaXMuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSKSx0aGlzLmJpYXNDb25zdHJhaW50PVl0KG4uYmlhc0NvbnN0cmFpbnQpLHRoaXMuYmlhc1JlZ3VsYXJpemVyPU50KG4uYmlhc1JlZ3VsYXJpemVyKSx0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXI9TnQobi5hY3Rpdml0eVJlZ3VsYXJpemVyKSx0aGlzLmRpbGF0aW9uUmF0ZT1GbChuLmRpbGF0aW9uUmF0ZT09bnVsbD8xOm4uZGlsYXRpb25SYXRlLHQsXCJkaWxhdGlvblJhdGVcIiksdGhpcy5yYW5rPT09MSYmQXJyYXkuaXNBcnJheSh0aGlzLmRpbGF0aW9uUmF0ZSkmJnRoaXMuZGlsYXRpb25SYXRlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IFYoYGRpbGF0aW9uUmF0ZSBtdXN0IGJlIGEgbnVtYmVyIG9yIGFuIGFycmF5IG9mIGEgc2luZ2xlIG51bWJlciBmb3IgMUQgY29udm9sdXRpb24sIGJ1dCByZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KHRoaXMuZGlsYXRpb25SYXRlKX1gKTtpZih0aGlzLnJhbms9PT0yKXtpZih0eXBlb2YgdGhpcy5kaWxhdGlvblJhdGU9PVwibnVtYmVyXCIpdGhpcy5kaWxhdGlvblJhdGU9W3RoaXMuZGlsYXRpb25SYXRlLHRoaXMuZGlsYXRpb25SYXRlXTtlbHNlIGlmKHRoaXMuZGlsYXRpb25SYXRlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IFYoYGRpbGF0aW9uUmF0ZSBtdXN0IGJlIGEgbnVtYmVyIG9yIGFycmF5IG9mIHR3byBudW1iZXJzIGZvciAyRCBjb252b2x1dGlvbiwgYnV0IHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkodGhpcy5kaWxhdGlvblJhdGUpfWApfWVsc2UgaWYodGhpcy5yYW5rPT09Myl7aWYodHlwZW9mIHRoaXMuZGlsYXRpb25SYXRlPT1cIm51bWJlclwiKXRoaXMuZGlsYXRpb25SYXRlPVt0aGlzLmRpbGF0aW9uUmF0ZSx0aGlzLmRpbGF0aW9uUmF0ZSx0aGlzLmRpbGF0aW9uUmF0ZV07ZWxzZSBpZih0aGlzLmRpbGF0aW9uUmF0ZS5sZW5ndGghPT0zKXRocm93IG5ldyBWKGBkaWxhdGlvblJhdGUgbXVzdCBiZSBhIG51bWJlciBvciBhcnJheSBvZiB0aHJlZSBudW1iZXJzIGZvciAzRCBjb252b2x1dGlvbiwgYnV0IHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkodGhpcy5kaWxhdGlvblJhdGUpfWApfX1zdGF0aWMgdmVyaWZ5QXJncyh0KXtpZih0cihcImtlcm5lbFNpemVcImluIHQsXCJyZXF1aXJlZCBrZXkgJ2tlcm5lbFNpemUnIG5vdCBpbiBjb25maWdcIiksdHlwZW9mIHQua2VybmVsU2l6ZSE9XCJudW1iZXJcIiYmIWUwKHQua2VybmVsU2l6ZSxcIm51bWJlclwiLDEsMykpdGhyb3cgbmV3IFYoYEJhc2VDb252IGV4cGVjdHMgY29uZmlnLmtlcm5lbFNpemUgdG8gYmUgbnVtYmVyIG9yIG51bWJlcltdIHdpdGggbGVuZ3RoIDEsIDIsIG9yIDMsIGJ1dCByZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KHQua2VybmVsU2l6ZSl9LmApfWdldENvbmZpZygpe2xldCB0PXtrZXJuZWxTaXplOnRoaXMua2VybmVsU2l6ZSxzdHJpZGVzOnRoaXMuc3RyaWRlcyxwYWRkaW5nOnRoaXMucGFkZGluZyxkYXRhRm9ybWF0OnRoaXMuZGF0YUZvcm1hdCxkaWxhdGlvblJhdGU6dGhpcy5kaWxhdGlvblJhdGUsYWN0aXZhdGlvbjptcyh0aGlzLmFjdGl2YXRpb24pLHVzZUJpYXM6dGhpcy51c2VCaWFzLGJpYXNJbml0aWFsaXplcjpFdCh0aGlzLmJpYXNJbml0aWFsaXplciksYmlhc1JlZ3VsYXJpemVyOmZ0KHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOmZ0KHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksYmlhc0NvbnN0cmFpbnQ6WHQodGhpcy5iaWFzQ29uc3RyYWludCl9LG49c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fX0sX2Y9Y2xhc3MgZEMgZXh0ZW5kcyBwQ3tjb25zdHJ1Y3Rvcih0LG4pe3N1cGVyKHQsbiksdGhpcy5rZXJuZWw9bnVsbCxkQy52ZXJpZnlBcmdzKG4pLHRoaXMuZmlsdGVycz1uLmZpbHRlcnMsdG4odGhpcy5maWx0ZXJzLFwiZmlsdGVyc1wiKSx0aGlzLmtlcm5lbEluaXRpYWxpemVyPVN0KG4ua2VybmVsSW5pdGlhbGl6ZXJ8fHRoaXMuREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIpLHRoaXMua2VybmVsQ29uc3RyYWludD1ZdChuLmtlcm5lbENvbnN0cmFpbnQpLHRoaXMua2VybmVsUmVndWxhcml6ZXI9TnQobi5rZXJuZWxSZWd1bGFyaXplcil9YnVpbGQodCl7dD1KZSh0KTtsZXQgbj10aGlzLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzRmlyc3RcIj8xOnQubGVuZ3RoLTE7aWYodFtuXT09bnVsbCl0aHJvdyBuZXcgVihgVGhlIGNoYW5uZWwgZGltZW5zaW9uIG9mIHRoZSBpbnB1dCBzaG91bGQgYmUgZGVmaW5lZC4gRm91bmQgJHt0W25dfWApO2xldCBhPXRbbl0scj10aGlzLmtlcm5lbFNpemUuY29uY2F0KFthLHRoaXMuZmlsdGVyc10pO3RoaXMua2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwia2VybmVsXCIscixudWxsLHRoaXMua2VybmVsSW5pdGlhbGl6ZXIsdGhpcy5rZXJuZWxSZWd1bGFyaXplciwhMCx0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHRoaXMudXNlQmlhcyYmKHRoaXMuYmlhcz10aGlzLmFkZFdlaWdodChcImJpYXNcIixbdGhpcy5maWx0ZXJzXSxudWxsLHRoaXMuYmlhc0luaXRpYWxpemVyLHRoaXMuYmlhc1JlZ3VsYXJpemVyLCEwLHRoaXMuYmlhc0NvbnN0cmFpbnQpKSx0aGlzLmlucHV0U3BlYz1be25kaW06dGhpcy5yYW5rKzIsYXhlczp7W25dOmF9fV0sdGhpcy5idWlsdD0hMH1jYWxsKHQsbil7cmV0dXJuIE8oKCk9Pnt0PVRlKHQpO2xldCBhLHI9dGhpcy5iaWFzPT1udWxsP251bGw6dGhpcy5iaWFzLnJlYWQoKSxzPW0yKHRoaXMuYWN0aXZhdGlvbi5nZXRDbGFzc05hbWUoKSk7aWYocyE9bnVsbCYmdGhpcy5yYW5rPT09MilhPURJKHQsdGhpcy5rZXJuZWwucmVhZCgpLHIsdGhpcy5zdHJpZGVzLHRoaXMucGFkZGluZyx0aGlzLmRhdGFGb3JtYXQsdGhpcy5kaWxhdGlvblJhdGUscyk7ZWxzZXtpZih0aGlzLnJhbms9PT0xKWE9ZmoodCx0aGlzLmtlcm5lbC5yZWFkKCkscix0aGlzLnN0cmlkZXNbMF0sdGhpcy5wYWRkaW5nLHRoaXMuZGF0YUZvcm1hdCx0aGlzLmRpbGF0aW9uUmF0ZVswXSk7ZWxzZSBpZih0aGlzLnJhbms9PT0yKWE9REkodCx0aGlzLmtlcm5lbC5yZWFkKCkscix0aGlzLnN0cmlkZXMsdGhpcy5wYWRkaW5nLHRoaXMuZGF0YUZvcm1hdCx0aGlzLmRpbGF0aW9uUmF0ZSk7ZWxzZSBpZih0aGlzLnJhbms9PT0zKWE9Z2oodCx0aGlzLmtlcm5lbC5yZWFkKCkscix0aGlzLnN0cmlkZXMsdGhpcy5wYWRkaW5nLHRoaXMuZGF0YUZvcm1hdCx0aGlzLmRpbGF0aW9uUmF0ZSk7ZWxzZSB0aHJvdyBuZXcgemUoXCJjb252b2x1dGlvbnMgZ3JlYXRlciB0aGFuIDNEIGFyZSBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTt0aGlzLmFjdGl2YXRpb24hPW51bGwmJihhPXRoaXMuYWN0aXZhdGlvbi5hcHBseShhKSl9cmV0dXJuIGF9KX1jb21wdXRlT3V0cHV0U2hhcGUodCl7dD1KZSh0KTtsZXQgbj1bXSxhPXRoaXMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNMYXN0XCI/dC5zbGljZSgxLHQubGVuZ3RoLTEpOnQuc2xpY2UoMik7Zm9yKGxldCBzPTA7czxhLmxlbmd0aDsrK3Mpe2xldCBpPVZhKGFbc10sdGhpcy5rZXJuZWxTaXplW3NdLHRoaXMucGFkZGluZyx0aGlzLnN0cmlkZXNbc10sdHlwZW9mIHRoaXMuZGlsYXRpb25SYXRlPT1cIm51bWJlclwiP3RoaXMuZGlsYXRpb25SYXRlOnRoaXMuZGlsYXRpb25SYXRlW3NdKTtuLnB1c2goaSl9bGV0IHI9W3RbMF1dO3JldHVybiB0aGlzLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzTGFzdFwiPyhyPXIuY29uY2F0KG4pLHIucHVzaCh0aGlzLmZpbHRlcnMpKTooci5wdXNoKHRoaXMuZmlsdGVycykscj1yLmNvbmNhdChuKSkscn1nZXRDb25maWcoKXtsZXQgdD17ZmlsdGVyczp0aGlzLmZpbHRlcnMsa2VybmVsSW5pdGlhbGl6ZXI6RXQodGhpcy5rZXJuZWxJbml0aWFsaXplciksa2VybmVsUmVndWxhcml6ZXI6ZnQodGhpcy5rZXJuZWxSZWd1bGFyaXplciksa2VybmVsQ29uc3RyYWludDpYdCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpfSxuPXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKHQsbiksdH1zdGF0aWMgdmVyaWZ5QXJncyh0KXtpZighKFwiZmlsdGVyc1wiaW4gdCl8fHR5cGVvZiB0LmZpbHRlcnMhPVwibnVtYmVyXCJ8fHQuZmlsdGVyczwxKXRocm93IG5ldyBWKGBDb252b2x1dGlvbiBsYXllciBleHBlY3RlZCBjb25maWcuZmlsdGVycyB0byBiZSBhICdudW1iZXInID4gMCBidXQgZ290ICR7SlNPTi5zdHJpbmdpZnkodC5maWx0ZXJzKX1gKX19LEFmPWNsYXNzIGhDIGV4dGVuZHMgX2Z7Y29uc3RydWN0b3IodCl7c3VwZXIoMix0KSxoQy52ZXJpZnlBcmdzKHQpfWdldENvbmZpZygpe2xldCB0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBkZWxldGUgdC5yYW5rLHR9c3RhdGljIHZlcmlmeUFyZ3ModCl7aWYodHlwZW9mIHQua2VybmVsU2l6ZSE9XCJudW1iZXJcIiYmIWUwKHQua2VybmVsU2l6ZSxcIm51bWJlclwiLDEsMikpdGhyb3cgbmV3IFYoYENvbnYyRCBleHBlY3RzIGNvbmZpZy5rZXJuZWxTaXplIHRvIGJlIG51bWJlciBvciBudW1iZXJbXSB3aXRoIGxlbmd0aCAxIG9yIDIsIGJ1dCByZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KHQua2VybmVsU2l6ZSl9LmApfX07QWYuY2xhc3NOYW1lPVwiQ29udjJEXCI7bmUucmVnaXN0ZXJDbGFzcyhBZik7dmFyIEZmPWNsYXNzIG1DIGV4dGVuZHMgX2Z7Y29uc3RydWN0b3IodCl7c3VwZXIoMyx0KSxtQy52ZXJpZnlBcmdzKHQpfWdldENvbmZpZygpe2xldCB0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBkZWxldGUgdC5yYW5rLHR9c3RhdGljIHZlcmlmeUFyZ3ModCl7aWYodHlwZW9mIHQua2VybmVsU2l6ZSE9XCJudW1iZXJcIiYmIShBcnJheS5pc0FycmF5KHQua2VybmVsU2l6ZSkmJih0Lmtlcm5lbFNpemUubGVuZ3RoPT09MXx8dC5rZXJuZWxTaXplLmxlbmd0aD09PTMpKSl0aHJvdyBuZXcgVihgQ29udjNEIGV4cGVjdHMgY29uZmlnLmtlcm5lbFNpemUgdG8gYmUgbnVtYmVyIG9yIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgYnV0IHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkodC5rZXJuZWxTaXplKX0uYCl9fTtGZi5jbGFzc05hbWU9XCJDb252M0RcIjtuZS5yZWdpc3RlckNsYXNzKEZmKTt2YXIgQTA9Y2xhc3MgZXh0ZW5kcyBBZntjb25zdHJ1Y3RvcihlKXtpZihzdXBlcihlKSx0aGlzLmlucHV0U3BlYz1bbmV3IHp0KHtuZGltOjR9KV0sdGhpcy5wYWRkaW5nIT09XCJzYW1lXCImJnRoaXMucGFkZGluZyE9PVwidmFsaWRcIil0aHJvdyBuZXcgVihgQ29udjJEVHJhbnNwb3NlIGN1cnJlbnRseSBzdXBwb3J0cyBvbmx5IHBhZGRpbmcgbW9kZXMgJ3NhbWUnIGFuZCAndmFsaWQnLCBidXQgcmVjZWl2ZWQgcGFkZGluZyBtb2RlICR7dGhpcy5wYWRkaW5nfWApfWJ1aWxkKGUpe2lmKGU9SmUoZSksZS5sZW5ndGghPT00KXRocm93IG5ldyBWKFwiSW5wdXQgc2hvdWxkIGhhdmUgcmFuayA0OyBSZWNlaXZlZCBpbnB1dCBzaGFwZTogXCIrSlNPTi5zdHJpbmdpZnkoZSkpO2xldCB0PXRoaXMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNGaXJzdFwiPzE6ZS5sZW5ndGgtMTtpZihlW3RdPT1udWxsKXRocm93IG5ldyBWKFwiVGhlIGNoYW5uZWwgZGltZW5zaW9uIG9mIHRoZSBpbnB1dHMgc2hvdWxkIGJlIGRlZmluZWQuIEZvdW5kIGBOb25lYC5cIik7bGV0IG49ZVt0XSxhPXRoaXMua2VybmVsU2l6ZS5jb25jYXQoW3RoaXMuZmlsdGVycyxuXSk7dGhpcy5rZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJrZXJuZWxcIixhLFwiZmxvYXQzMlwiLHRoaXMua2VybmVsSW5pdGlhbGl6ZXIsdGhpcy5rZXJuZWxSZWd1bGFyaXplciwhMCx0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHRoaXMudXNlQmlhcyYmKHRoaXMuYmlhcz10aGlzLmFkZFdlaWdodChcImJpYXNcIixbdGhpcy5maWx0ZXJzXSxcImZsb2F0MzJcIix0aGlzLmJpYXNJbml0aWFsaXplcix0aGlzLmJpYXNSZWd1bGFyaXplciwhMCx0aGlzLmJpYXNDb25zdHJhaW50KSksdGhpcy5pbnB1dFNwZWM9W25ldyB6dCh7bmRpbTo0LGF4ZXM6e1t0XTpufX0pXSx0aGlzLmJ1aWx0PSEwfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e2xldCBuPVRlKGUpO2lmKG4uc2hhcGUubGVuZ3RoIT09NCl0aHJvdyBuZXcgVihgQ29udjJEVHJhbnNwb3NlLmNhbGwoKSBleHBlY3RzIGlucHV0IHRlbnNvciB0byBiZSByYW5rLTQsIGJ1dCByZWNlaXZlZCBhIHRlbnNvciBvZiByYW5rLSR7bi5zaGFwZS5sZW5ndGh9YCk7bGV0IGE9bi5zaGFwZSxyPWFbMF0scyxpO3RoaXMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNGaXJzdFwiPyhzPTIsaT0zKToocz0xLGk9Mik7bGV0IG89YVtzXSxsPWFbaV0sdT10aGlzLmtlcm5lbFNpemVbMF0scD10aGlzLmtlcm5lbFNpemVbMV0sZD10aGlzLnN0cmlkZXNbMF0sYz10aGlzLnN0cmlkZXNbMV0saD1ucihvLGQsdSx0aGlzLnBhZGRpbmcpLG09bnIobCxjLHAsdGhpcy5wYWRkaW5nKSxmPVtyLGgsbSx0aGlzLmZpbHRlcnNdO3RoaXMuZGF0YUZvcm1hdCE9PVwiY2hhbm5lbHNMYXN0XCImJihuPURlKG4sWzAsMiwzLDFdKSk7bGV0IGc9V20obix0aGlzLmtlcm5lbC5yZWFkKCksZix0aGlzLnN0cmlkZXMsdGhpcy5wYWRkaW5nKTtyZXR1cm4gdGhpcy5kYXRhRm9ybWF0IT09XCJjaGFubmVsc0xhc3RcIiYmKGc9RGUoZyxbMCwzLDEsMl0pKSx0aGlzLmJpYXMhPW51bGwmJihnPUthKGcsdGhpcy5iaWFzLnJlYWQoKSx0aGlzLmRhdGFGb3JtYXQpKSx0aGlzLmFjdGl2YXRpb24hPW51bGwmJihnPXRoaXMuYWN0aXZhdGlvbi5hcHBseShnKSksZ30pfWNvbXB1dGVPdXRwdXRTaGFwZShlKXtlPUplKGUpO2xldCB0PWUuc2xpY2UoKSxuLGEscjt0aGlzLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzRmlyc3RcIj8obj0xLGE9MixyPTMpOihuPTMsYT0xLHI9Mik7bGV0IHM9dGhpcy5rZXJuZWxTaXplWzBdLGk9dGhpcy5rZXJuZWxTaXplWzFdLG89dGhpcy5zdHJpZGVzWzBdLGw9dGhpcy5zdHJpZGVzWzFdO3JldHVybiB0W25dPXRoaXMuZmlsdGVycyx0W2FdPW5yKHRbYV0sbyxzLHRoaXMucGFkZGluZyksdFtyXT1ucih0W3JdLGwsaSx0aGlzLnBhZGRpbmcpLHR9Z2V0Q29uZmlnKCl7bGV0IGU9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIGRlbGV0ZSBlLmRpbGF0aW9uUmF0ZSxlfX07QTAuY2xhc3NOYW1lPVwiQ29udjJEVHJhbnNwb3NlXCI7bmUucmVnaXN0ZXJDbGFzcyhBMCk7dmFyIEYwPWNsYXNzIGV4dGVuZHMgRmZ7Y29uc3RydWN0b3IoZSl7aWYoc3VwZXIoZSksdGhpcy5pbnB1dFNwZWM9W25ldyB6dCh7bmRpbTo1fSldLHRoaXMucGFkZGluZyE9PVwic2FtZVwiJiZ0aGlzLnBhZGRpbmchPT1cInZhbGlkXCIpdGhyb3cgbmV3IFYoYENvbnYzRFRyYW5zcG9zZSBjdXJyZW50bHkgc3VwcG9ydHMgb25seSBwYWRkaW5nIG1vZGVzICdzYW1lJyBhbmQgJ3ZhbGlkJywgYnV0IHJlY2VpdmVkIHBhZGRpbmcgbW9kZSAke3RoaXMucGFkZGluZ31gKX1idWlsZChlKXtpZihlPUplKGUpLGUubGVuZ3RoIT09NSl0aHJvdyBuZXcgVihcIklucHV0IHNob3VsZCBoYXZlIHJhbmsgNTsgUmVjZWl2ZWQgaW5wdXQgc2hhcGU6IFwiK0pTT04uc3RyaW5naWZ5KGUpKTtsZXQgdD10aGlzLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzRmlyc3RcIj8xOmUubGVuZ3RoLTE7aWYoZVt0XT09bnVsbCl0aHJvdyBuZXcgVihcIlRoZSBjaGFubmVsIGRpbWVuc2lvbiBvZiB0aGUgaW5wdXRzIHNob3VsZCBiZSBkZWZpbmVkLiBGb3VuZCBgTm9uZWAuXCIpO2xldCBuPWVbdF0sYT10aGlzLmtlcm5lbFNpemUuY29uY2F0KFt0aGlzLmZpbHRlcnMsbl0pO3RoaXMua2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwia2VybmVsXCIsYSxcImZsb2F0MzJcIix0aGlzLmtlcm5lbEluaXRpYWxpemVyLHRoaXMua2VybmVsUmVndWxhcml6ZXIsITAsdGhpcy5rZXJuZWxDb25zdHJhaW50KSx0aGlzLnVzZUJpYXMmJih0aGlzLmJpYXM9dGhpcy5hZGRXZWlnaHQoXCJiaWFzXCIsW3RoaXMuZmlsdGVyc10sXCJmbG9hdDMyXCIsdGhpcy5iaWFzSW5pdGlhbGl6ZXIsdGhpcy5iaWFzUmVndWxhcml6ZXIsITAsdGhpcy5iaWFzQ29uc3RyYWludCkpLHRoaXMuaW5wdXRTcGVjPVtuZXcgenQoe25kaW06NSxheGVzOntbdF06bn19KV0sdGhpcy5idWlsdD0hMH1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbj1UZShlKTtpZihuLnNoYXBlLmxlbmd0aCE9PTUpdGhyb3cgbmV3IFYoYENvbnYzRFRyYW5zcG9zZS5jYWxsKCkgZXhwZWN0cyBpbnB1dCB0ZW5zb3IgdG8gYmUgcmFuay00LCBidXQgcmVjZWl2ZWQgYSB0ZW5zb3Igb2YgcmFuay0ke24uc2hhcGUubGVuZ3RofWApO2xldCBhPW4uc2hhcGUscj1hWzBdLHMsaSxvO3RoaXMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNGaXJzdFwiPyhvPTIscz0zLGk9NCk6KG89MSxzPTIsaT0zKTtsZXQgbD1hW29dLHU9YVtzXSxwPWFbaV0sZD10aGlzLmtlcm5lbFNpemVbMF0sYz10aGlzLmtlcm5lbFNpemVbMV0saD10aGlzLmtlcm5lbFNpemVbMl0sbT10aGlzLnN0cmlkZXNbMF0sZj10aGlzLnN0cmlkZXNbMV0sZz10aGlzLnN0cmlkZXNbMl0sYj1ucihsLG0sZCx0aGlzLnBhZGRpbmcpLHk9bnIodSxmLGMsdGhpcy5wYWRkaW5nKSx4PW5yKHAsZyxoLHRoaXMucGFkZGluZyksdj1bcixiLHkseCx0aGlzLmZpbHRlcnNdO3RoaXMuZGF0YUZvcm1hdCE9PVwiY2hhbm5lbHNMYXN0XCImJihuPURlKG4sWzAsMiwzLDQsMV0pKTtsZXQgST1ydyhuLHRoaXMua2VybmVsLnJlYWQoKSx2LHRoaXMuc3RyaWRlcyx0aGlzLnBhZGRpbmcpO3JldHVybiB0aGlzLmRhdGFGb3JtYXQhPT1cImNoYW5uZWxzTGFzdFwiJiYoST1EZShJLFswLDQsMSwyLDNdKSksdGhpcy5iaWFzIT09bnVsbCYmKEk9S2EoSSx0aGlzLmJpYXMucmVhZCgpLHRoaXMuZGF0YUZvcm1hdCkpLHRoaXMuYWN0aXZhdGlvbiE9PW51bGwmJihJPXRoaXMuYWN0aXZhdGlvbi5hcHBseShJKSksSX0pfWNvbXB1dGVPdXRwdXRTaGFwZShlKXtlPUplKGUpO2xldCB0PWUuc2xpY2UoKSxuLGEscixzO3RoaXMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNGaXJzdFwiPyhuPTEsYT0yLHI9MyxzPTQpOihuPTQsYT0xLHI9MixzPTMpO2xldCBpPXRoaXMua2VybmVsU2l6ZVswXSxvPXRoaXMua2VybmVsU2l6ZVsxXSxsPXRoaXMua2VybmVsU2l6ZVsyXSx1PXRoaXMuc3RyaWRlc1swXSxwPXRoaXMuc3RyaWRlc1sxXSxkPXRoaXMuc3RyaWRlc1syXTtyZXR1cm4gdFtuXT10aGlzLmZpbHRlcnMsdFthXT1ucih0W2FdLHUsaSx0aGlzLnBhZGRpbmcpLHRbcl09bnIodFtyXSxwLG8sdGhpcy5wYWRkaW5nKSx0W3NdPW5yKHRbc10sZCxsLHRoaXMucGFkZGluZyksdH1nZXRDb25maWcoKXtsZXQgZT1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gZGVsZXRlIGUuZGlsYXRpb25SYXRlLGV9fTtGMC5jbGFzc05hbWU9XCJDb252M0RUcmFuc3Bvc2VcIjtuZS5yZWdpc3RlckNsYXNzKEYwKTt2YXIgZkM9Y2xhc3MgZXh0ZW5kcyBfZntjb25zdHJ1Y3RvcihlLHQpe2lmKHN1cGVyKGUsdCksdGhpcy5ERUZBVUxUX0RFUFRIV0lTRV9JTklUSUFMSVpFUj1cImdsb3JvdFVuaWZvcm1cIix0aGlzLkRFRkFVTFRfUE9JTlRXSVNFX0lOSVRJQUxJWkVSPVwiZ2xvcm90VW5pZm9ybVwiLHRoaXMuZGVwdGh3aXNlS2VybmVsPW51bGwsdGhpcy5wb2ludHdpc2VLZXJuZWw9bnVsbCx0LmZpbHRlcnM9PW51bGwpdGhyb3cgbmV3IFYoXCJUaGUgYGZpbHRlcnNgIGNvbmZpZ3VyYXRpb24gZmllbGQgaXMgcmVxdWlyZWQgYnkgU2VwYXJhYmxlQ29udiwgYnV0IGlzIHVuc3BlY2lmaWVkLlwiKTtpZih0Lmtlcm5lbEluaXRpYWxpemVyIT1udWxsfHx0Lmtlcm5lbFJlZ3VsYXJpemVyIT1udWxsfHx0Lmtlcm5lbENvbnN0cmFpbnQhPW51bGwpdGhyb3cgbmV3IFYoXCJGaWVsZHMga2VybmVsSW5pdGlhbGl6ZXIsIGtlcm5lbFJlZ3VsYXJpemVyIGFuZCBrZXJuZWxDb25zdHJhaW50IGFyZSBpbnZhbGlkIGZvciBTZXBhcmFibGVDb252MkQuIFVzZSBkZXB0aHdpc2VJbml0aWFsaXplciwgZGVwdGh3aXNlUmVndWxhcml6ZXIsIGRlcHRod2lzZUNvbnN0cmFpbnQsIHBvaW50d2lzZUluaXRpYWxpemVyLCBwb2ludHdpc2VSZWd1bGFyaXplciBhbmQgcG9pbnR3aXNlQ29uc3RyYWludCBpbnN0ZWFkLlwiKTtpZih0LnBhZGRpbmchPW51bGwmJnQucGFkZGluZyE9PVwic2FtZVwiJiZ0LnBhZGRpbmchPT1cInZhbGlkXCIpdGhyb3cgbmV3IFYoYFNlcGFyYWJsZUNvbnYke3RoaXMucmFua31EIHN1cHBvcnRzIG9ubHkgcGFkZGluZyBtb2RlczogJ3NhbWUnIGFuZCAndmFsaWQnLCBidXQgcmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeSh0LnBhZGRpbmcpfWApO3RoaXMuZGVwdGhNdWx0aXBsaWVyPXQuZGVwdGhNdWx0aXBsaWVyPT1udWxsPzE6dC5kZXB0aE11bHRpcGxpZXIsdGhpcy5kZXB0aHdpc2VJbml0aWFsaXplcj1TdCh0LmRlcHRod2lzZUluaXRpYWxpemVyfHx0aGlzLkRFRkFVTFRfREVQVEhXSVNFX0lOSVRJQUxJWkVSKSx0aGlzLmRlcHRod2lzZVJlZ3VsYXJpemVyPU50KHQuZGVwdGh3aXNlUmVndWxhcml6ZXIpLHRoaXMuZGVwdGh3aXNlQ29uc3RyYWludD1ZdCh0LmRlcHRod2lzZUNvbnN0cmFpbnQpLHRoaXMucG9pbnR3aXNlSW5pdGlhbGl6ZXI9U3QodC5kZXB0aHdpc2VJbml0aWFsaXplcnx8dGhpcy5ERUZBVUxUX1BPSU5UV0lTRV9JTklUSUFMSVpFUiksdGhpcy5wb2ludHdpc2VSZWd1bGFyaXplcj1OdCh0LnBvaW50d2lzZVJlZ3VsYXJpemVyKSx0aGlzLnBvaW50d2lzZUNvbnN0cmFpbnQ9WXQodC5wb2ludHdpc2VDb25zdHJhaW50KX1idWlsZChlKXtpZihlPUplKGUpLGUubGVuZ3RoPHRoaXMucmFuaysyKXRocm93IG5ldyBWKGBJbnB1dHMgdG8gU2VwYXJhYmxlQ29udiR7dGhpcy5yYW5rfUQgc2hvdWxkIGhhdmUgcmFuayAke3RoaXMucmFuaysyfSwgYnV0IHJlY2VpdmVkIGlucHV0IHNoYXBlOiAke0pTT04uc3RyaW5naWZ5KGUpfWApO2xldCB0PXRoaXMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNGaXJzdFwiPzE6ZS5sZW5ndGgtMTtpZihlW3RdPT1udWxsfHxlW3RdPDApdGhyb3cgbmV3IFYoYFRoZSBjaGFubmVsIGRpbWVuc2lvbiBvZiB0aGUgaW5wdXRzIHNob3VsZCBiZSBkZWZpbmVkLCBidXQgZm91bmQgJHtKU09OLnN0cmluZ2lmeShlW3RdKX1gKTtsZXQgbj1lW3RdLGE9dGhpcy5rZXJuZWxTaXplLmNvbmNhdChbbix0aGlzLmRlcHRoTXVsdGlwbGllcl0pLHI9W107Zm9yKGxldCBpPTA7aTx0aGlzLnJhbms7KytpKXIucHVzaCgxKTtyLnB1c2gobip0aGlzLmRlcHRoTXVsdGlwbGllcix0aGlzLmZpbHRlcnMpO2xldCBzPSEwO3RoaXMuZGVwdGh3aXNlS2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwiZGVwdGh3aXNlX2tlcm5lbFwiLGEsXCJmbG9hdDMyXCIsdGhpcy5kZXB0aHdpc2VJbml0aWFsaXplcix0aGlzLmRlcHRod2lzZVJlZ3VsYXJpemVyLHMsdGhpcy5kZXB0aHdpc2VDb25zdHJhaW50KSx0aGlzLnBvaW50d2lzZUtlcm5lbD10aGlzLmFkZFdlaWdodChcInBvaW50d2lzZV9rZXJuZWxcIixyLFwiZmxvYXQzMlwiLHRoaXMucG9pbnR3aXNlSW5pdGlhbGl6ZXIsdGhpcy5wb2ludHdpc2VSZWd1bGFyaXplcixzLHRoaXMucG9pbnR3aXNlQ29uc3RyYWludCksdGhpcy51c2VCaWFzP3RoaXMuYmlhcz10aGlzLmFkZFdlaWdodChcImJpYXNcIixbdGhpcy5maWx0ZXJzXSxcImZsb2F0MzJcIix0aGlzLmJpYXNJbml0aWFsaXplcix0aGlzLmJpYXNSZWd1bGFyaXplcixzLHRoaXMuYmlhc0NvbnN0cmFpbnQpOnRoaXMuYmlhcz1udWxsLHRoaXMuaW5wdXRTcGVjPVtuZXcgenQoe25kaW06dGhpcy5yYW5rKzIsYXhlczp7W3RdOm59fSldLHRoaXMuYnVpbHQ9ITB9Y2FsbChlLHQpe3JldHVybiBPKCgpPT57ZT1UZShlKTtsZXQgbjtpZih0aGlzLnJhbms9PT0xKXRocm93IG5ldyB6ZShcIjFEIHNlcGFyYWJsZSBjb252b2x1dGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtyZXR1cm4gdGhpcy5yYW5rPT09MiYmKHRoaXMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNGaXJzdFwiJiYoZT1EZShlLFswLDIsMywxXSkpLG49X3MoZSx0aGlzLmRlcHRod2lzZUtlcm5lbC5yZWFkKCksdGhpcy5wb2ludHdpc2VLZXJuZWwucmVhZCgpLHRoaXMuc3RyaWRlcyx0aGlzLnBhZGRpbmcsdGhpcy5kaWxhdGlvblJhdGUsXCJOSFdDXCIpKSx0aGlzLnVzZUJpYXMmJihuPUthKG4sdGhpcy5iaWFzLnJlYWQoKSx0aGlzLmRhdGFGb3JtYXQpKSx0aGlzLmFjdGl2YXRpb24hPW51bGwmJihuPXRoaXMuYWN0aXZhdGlvbi5hcHBseShuKSksdGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCImJihuPURlKG4sWzAsMywxLDJdKSksbn0pfWdldENvbmZpZygpe2xldCBlPXN1cGVyLmdldENvbmZpZygpO3JldHVybiBkZWxldGUgZS5yYW5rLGRlbGV0ZSBlLmtlcm5lbEluaXRpYWxpemVyLGRlbGV0ZSBlLmtlcm5lbFJlZ3VsYXJpemVyLGRlbGV0ZSBlLmtlcm5lbENvbnN0cmFpbnQsZS5kZXB0aHdpc2VJbml0aWFsaXplcj1FdCh0aGlzLmRlcHRod2lzZUluaXRpYWxpemVyKSxlLnBvaW50d2lzZUluaXRpYWxpemVyPUV0KHRoaXMucG9pbnR3aXNlSW5pdGlhbGl6ZXIpLGUuZGVwdGh3aXNlUmVndWxhcml6ZXI9ZnQodGhpcy5kZXB0aHdpc2VSZWd1bGFyaXplciksZS5wb2ludHdpc2VSZWd1bGFyaXplcj1mdCh0aGlzLnBvaW50d2lzZVJlZ3VsYXJpemVyKSxlLmRlcHRod2lzZUNvbnN0cmFpbnQ9WHQodGhpcy5kZXB0aHdpc2VDb25zdHJhaW50KSxlLnBvaW50d2lzZUNvbnN0cmFpbnQ9WHQodGhpcy5wb2ludHdpc2VDb25zdHJhaW50KSxlfX07ZkMuY2xhc3NOYW1lPVwiU2VwYXJhYmxlQ29udlwiO3ZhciAkMD1jbGFzcyBleHRlbmRzIGZDe2NvbnN0cnVjdG9yKGUpe3N1cGVyKDIsZSl9fTskMC5jbGFzc05hbWU9XCJTZXBhcmFibGVDb252MkRcIjtuZS5yZWdpc3RlckNsYXNzKCQwKTt2YXIgRDA9Y2xhc3MgZ0MgZXh0ZW5kcyBfZntjb25zdHJ1Y3Rvcih0KXtzdXBlcigxLHQpLGdDLnZlcmlmeUFyZ3ModCksdGhpcy5pbnB1dFNwZWM9W3tuZGltOjN9XX1nZXRDb25maWcoKXtsZXQgdD1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gZGVsZXRlIHQucmFuayxkZWxldGUgdC5kYXRhRm9ybWF0LHR9c3RhdGljIHZlcmlmeUFyZ3ModCl7aWYodHlwZW9mIHQua2VybmVsU2l6ZSE9XCJudW1iZXJcIiYmIWUwKHQua2VybmVsU2l6ZSxcIm51bWJlclwiLDEsMSkpdGhyb3cgbmV3IFYoYENvbnYxRCBleHBlY3RzIGNvbmZpZy5rZXJuZWxTaXplIHRvIGJlIG51bWJlciBvciBudW1iZXJbXSB3aXRoIGxlbmd0aCAxLCBidXQgcmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeSh0Lmtlcm5lbFNpemUpfS5gKX19O0QwLmNsYXNzTmFtZT1cIkNvbnYxRFwiO25lLnJlZ2lzdGVyQ2xhc3MoRDApO3ZhciBSMD1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLHR5cGVvZiBlLmNyb3BwaW5nPT1cIm51bWJlclwiP3RoaXMuY3JvcHBpbmc9W1tlLmNyb3BwaW5nLGUuY3JvcHBpbmddLFtlLmNyb3BwaW5nLGUuY3JvcHBpbmddXTp0eXBlb2YgZS5jcm9wcGluZ1swXT09XCJudW1iZXJcIj90aGlzLmNyb3BwaW5nPVtbZS5jcm9wcGluZ1swXSxlLmNyb3BwaW5nWzBdXSxbZS5jcm9wcGluZ1sxXSxlLmNyb3BwaW5nWzFdXV06dGhpcy5jcm9wcGluZz1lLmNyb3BwaW5nLHRoaXMuZGF0YUZvcm1hdD1lLmRhdGFGb3JtYXQ9PT12b2lkIDA/XCJjaGFubmVsc0xhc3RcIjplLmRhdGFGb3JtYXQsdGhpcy5pbnB1dFNwZWM9W3tuZGltOjR9XX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7cmV0dXJuIHRoaXMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNGaXJzdFwiP1tlWzBdLGVbMV0sZVsyXS10aGlzLmNyb3BwaW5nWzBdWzBdLXRoaXMuY3JvcHBpbmdbMF1bMV0sZVszXS10aGlzLmNyb3BwaW5nWzFdWzBdLXRoaXMuY3JvcHBpbmdbMV1bMV1dOltlWzBdLGVbMV0tdGhpcy5jcm9wcGluZ1swXVswXS10aGlzLmNyb3BwaW5nWzBdWzFdLGVbMl0tdGhpcy5jcm9wcGluZ1sxXVswXS10aGlzLmNyb3BwaW5nWzFdWzFdLGVbM11dfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e2lmKGU9VGUoZSksdGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0xhc3RcIil7bGV0IG49SWgoZSx0aGlzLmNyb3BwaW5nWzBdWzBdLGUuc2hhcGVbMV0tdGhpcy5jcm9wcGluZ1swXVswXS10aGlzLmNyb3BwaW5nWzBdWzFdLDIpO3JldHVybiBJaChuLHRoaXMuY3JvcHBpbmdbMV1bMF0sZS5zaGFwZVsyXS10aGlzLmNyb3BwaW5nWzFdWzFdLXRoaXMuY3JvcHBpbmdbMV1bMF0sMyl9ZWxzZXtsZXQgbj1JaChlLHRoaXMuY3JvcHBpbmdbMF1bMF0sZS5zaGFwZVsyXS10aGlzLmNyb3BwaW5nWzBdWzBdLXRoaXMuY3JvcHBpbmdbMF1bMV0sMyk7cmV0dXJuIEloKG4sdGhpcy5jcm9wcGluZ1sxXVswXSxlLnNoYXBlWzNdLXRoaXMuY3JvcHBpbmdbMV1bMV0tdGhpcy5jcm9wcGluZ1sxXVswXSw0KX19KX1nZXRDb25maWcoKXtsZXQgZT17Y3JvcHBpbmc6dGhpcy5jcm9wcGluZyxkYXRhRm9ybWF0OnRoaXMuZGF0YUZvcm1hdH0sdD1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9fTtSMC5jbGFzc05hbWU9XCJDcm9wcGluZzJEXCI7bmUucmVnaXN0ZXJDbGFzcyhSMCk7dmFyIE0wPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksdGhpcy5ERUZBVUxUX1NJWkU9WzIsMl0sdGhpcy5pbnB1dFNwZWM9W3tuZGltOjR9XSx0aGlzLnNpemU9ZS5zaXplPT1udWxsP3RoaXMuREVGQVVMVF9TSVpFOmUuc2l6ZSx0aGlzLmRhdGFGb3JtYXQ9ZS5kYXRhRm9ybWF0PT1udWxsP1wiY2hhbm5lbHNMYXN0XCI6ZS5kYXRhRm9ybWF0LFJ0KHRoaXMuZGF0YUZvcm1hdCksdGhpcy5pbnRlcnBvbGF0aW9uPWUuaW50ZXJwb2xhdGlvbj09bnVsbD9cIm5lYXJlc3RcIjplLmludGVycG9sYXRpb24sU0codGhpcy5pbnRlcnBvbGF0aW9uKX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7aWYodGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCIpe2xldCB0PWVbMl09PW51bGw/bnVsbDp0aGlzLnNpemVbMF0qZVsyXSxuPWVbM109PW51bGw/bnVsbDp0aGlzLnNpemVbMV0qZVszXTtyZXR1cm5bZVswXSxlWzFdLHQsbl19ZWxzZXtsZXQgdD1lWzFdPT1udWxsP251bGw6dGhpcy5zaXplWzBdKmVbMV0sbj1lWzJdPT1udWxsP251bGw6dGhpcy5zaXplWzFdKmVbMl07cmV0dXJuW2VbMF0sdCxuLGVbM11dfX1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbj1UZShlKSxhPW4uc2hhcGU7aWYodGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCIpe249RGUobixbMCwyLDMsMV0pO2xldCByPXRoaXMuc2l6ZVswXSphWzJdLHM9dGhpcy5zaXplWzFdKmFbM10saT10aGlzLmludGVycG9sYXRpb249PT1cIm5lYXJlc3RcIj9abi5yZXNpemVOZWFyZXN0TmVpZ2hib3IobixbcixzXSk6Wm4ucmVzaXplQmlsaW5lYXIobixbcixzXSk7cmV0dXJuIERlKGksWzAsMywxLDJdKX1lbHNle2xldCByPXRoaXMuc2l6ZVswXSphWzFdLHM9dGhpcy5zaXplWzFdKmFbMl07cmV0dXJuIHRoaXMuaW50ZXJwb2xhdGlvbj09PVwibmVhcmVzdFwiP1puLnJlc2l6ZU5lYXJlc3ROZWlnaGJvcihuLFtyLHNdKTpabi5yZXNpemVCaWxpbmVhcihuLFtyLHNdKX19KX1nZXRDb25maWcoKXtsZXQgZT17c2l6ZTp0aGlzLnNpemUsZGF0YUZvcm1hdDp0aGlzLmRhdGFGb3JtYXQsaW50ZXJwb2xhdGlvbjp0aGlzLmludGVycG9sYXRpb259LHQ9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfX07TTAuY2xhc3NOYW1lPVwiVXBTYW1wbGluZzJEXCI7bmUucmVnaXN0ZXJDbGFzcyhNMCk7ZnVuY3Rpb24gYmooZSx0LG49WzEsMV0sYT1cInZhbGlkXCIscixzKXtyZXR1cm4gTygoKT0+e3I9PW51bGwmJihyPUdhKCkpLFJ0KHIpO2xldCBpPV8wKGUscik7aWYoZS5yYW5rIT09NCl0aHJvdyBuZXcgVihgSW5wdXQgZm9yIGRlcHRod2lzZUNvbnYyZCBpcyByZXF1aXJlZCB0byBiZSA0LUQsIGJ1dCBpcyBpbnN0ZWFkICR7ZS5yYW5rfS1EYCk7aWYodC5yYW5rIT09NCl0aHJvdyBuZXcgVihgZGVwdGh3aXNlS2VybmVsIGlzIHJlcXVpcmVkIHRvIGJlIDQtRCwgYnV0IGlzIGluc3RlYWQgJHt0LnJhbmt9LURgKTtyZXR1cm4gaT1UcyhpLHQsbixhPT09XCJzYW1lXCI/XCJzYW1lXCI6XCJ2YWxpZFwiLFwiTkhXQ1wiLHMpLHI9PT1cImNoYW5uZWxzRmlyc3RcIiYmKGk9RGUoaSxbMCwzLDEsMl0pKSxpfSl9dmFyIE8wPWNsYXNzIGV4dGVuZHMgcEN7Y29uc3RydWN0b3IoZSl7c3VwZXIoMixlKSx0aGlzLmRlcHRod2lzZUtlcm5lbD1udWxsLHRoaXMuZGVwdGhNdWx0aXBsaWVyPWUuZGVwdGhNdWx0aXBsaWVyPT1udWxsPzE6ZS5kZXB0aE11bHRpcGxpZXIsdGhpcy5kZXB0aHdpc2VJbml0aWFsaXplcj1TdChlLmRlcHRod2lzZUluaXRpYWxpemVyfHx0aGlzLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSKSx0aGlzLmRlcHRod2lzZUNvbnN0cmFpbnQ9WXQoZS5kZXB0aHdpc2VDb25zdHJhaW50KSx0aGlzLmRlcHRod2lzZVJlZ3VsYXJpemVyPU50KGUuZGVwdGh3aXNlUmVndWxhcml6ZXIpfWJ1aWxkKGUpe2lmKGU9SmUoZSksZS5sZW5ndGg8NCl0aHJvdyBuZXcgVihgSW5wdXRzIHRvIERlcHRod2lzZUNvbnYyRCBzaG91bGQgaGF2ZSByYW5rIDQuIFJlY2VpdmVkIGlucHV0IHNoYXBlOiAke0pTT04uc3RyaW5naWZ5KGUpfS5gKTtsZXQgdD10aGlzLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzRmlyc3RcIj8xOjM7aWYoZVt0XT09bnVsbHx8ZVt0XTwwKXRocm93IG5ldyBWKGBUaGUgY2hhbm5lbCBkaW1lbnNpb24gb2YgdGhlIGlucHV0cyB0byBEZXB0aHdpc2VDb252MkQgc2hvdWxkIGJlIGRlZmluZWQsIGJ1dCBpcyBub3QgKCR7ZVt0XX0pLmApO2xldCBuPWVbdF0sYT1bdGhpcy5rZXJuZWxTaXplWzBdLHRoaXMua2VybmVsU2l6ZVsxXSxuLHRoaXMuZGVwdGhNdWx0aXBsaWVyXTt0aGlzLmRlcHRod2lzZUtlcm5lbD10aGlzLmFkZFdlaWdodChcImRlcHRod2lzZV9rZXJuZWxcIixhLG51bGwsdGhpcy5kZXB0aHdpc2VJbml0aWFsaXplcix0aGlzLmRlcHRod2lzZVJlZ3VsYXJpemVyLCEwLHRoaXMuZGVwdGh3aXNlQ29uc3RyYWludCksdGhpcy51c2VCaWFzP3RoaXMuYmlhcz10aGlzLmFkZFdlaWdodChcImJpYXNcIixbbip0aGlzLmRlcHRoTXVsdGlwbGllcl0sbnVsbCx0aGlzLmJpYXNJbml0aWFsaXplcix0aGlzLmJpYXNSZWd1bGFyaXplciwhMCx0aGlzLmJpYXNDb25zdHJhaW50KTp0aGlzLmJpYXM9bnVsbCx0aGlzLmJ1aWx0PSEwfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e2U9VGUoZSk7bGV0IG49YmooZSx0aGlzLmRlcHRod2lzZUtlcm5lbC5yZWFkKCksdGhpcy5zdHJpZGVzLHRoaXMucGFkZGluZyx0aGlzLmRhdGFGb3JtYXQsbnVsbCk7cmV0dXJuIHRoaXMudXNlQmlhcyYmKG49S2Eobix0aGlzLmJpYXMucmVhZCgpLHRoaXMuZGF0YUZvcm1hdCkpLHRoaXMuYWN0aXZhdGlvbiE9bnVsbCYmKG49dGhpcy5hY3RpdmF0aW9uLmFwcGx5KG4pKSxufSl9Y29tcHV0ZU91dHB1dFNoYXBlKGUpe2U9SmUoZSk7bGV0IHQ9dGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCI/ZVsyXTplWzFdLG49dGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCI/ZVszXTplWzJdLGE9dGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCI/ZVsxXSp0aGlzLmRlcHRoTXVsdGlwbGllcjplWzNdKnRoaXMuZGVwdGhNdWx0aXBsaWVyLHI9VmEodCx0aGlzLmtlcm5lbFNpemVbMF0sdGhpcy5wYWRkaW5nLHRoaXMuc3RyaWRlc1swXSkscz1WYShuLHRoaXMua2VybmVsU2l6ZVsxXSx0aGlzLnBhZGRpbmcsdGhpcy5zdHJpZGVzWzFdKTtyZXR1cm4gdGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCI/W2VbMF0sYSxyLHNdOltlWzBdLHIscyxhXX1nZXRDb25maWcoKXtsZXQgZT1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gZS5kZXB0aE11bHRpcGxpZXI9dGhpcy5kZXB0aE11bHRpcGxpZXIsZS5kZXB0aHdpc2VJbml0aWFsaXplcj1FdCh0aGlzLmRlcHRod2lzZUluaXRpYWxpemVyKSxlLmRlcHRod2lzZVJlZ3VsYXJpemVyPWZ0KHRoaXMuZGVwdGh3aXNlUmVndWxhcml6ZXIpLGUuZGVwdGh3aXNlQ29uc3RyYWludD1YdCh0aGlzLmRlcHRod2lzZVJlZ3VsYXJpemVyKSxlfX07TzAuY2xhc3NOYW1lPVwiRGVwdGh3aXNlQ29udjJEXCI7bmUucmVnaXN0ZXJDbGFzcyhPMCk7ZnVuY3Rpb24gYkMoZSx0LG4sYSl7aWYoQXJyYXkuaXNBcnJheShlKSl7aWYodCE9bnVsbHx8biE9bnVsbCl0aHJvdyBuZXcgVihcIldoZW4gaW5wdXRzIGlzIGFuIGFycmF5LCBuZWl0aGVyIGluaXRpYWxTdGF0ZSBvciBjb25zdGFudHMgc2hvdWxkIGJlIHByb3ZpZGVkXCIpO2EhPW51bGwmJihuPWUuc2xpY2UoZS5sZW5ndGgtYSxlLmxlbmd0aCksZT1lLnNsaWNlKDAsZS5sZW5ndGgtYSkpLGUubGVuZ3RoPjEmJih0PWUuc2xpY2UoMSxlLmxlbmd0aCkpLGU9ZVswXX1mdW5jdGlvbiByKHMpe3JldHVybiBzPT1udWxsfHxBcnJheS5pc0FycmF5KHMpP3M6W3NdfXJldHVybiB0PXIodCksbj1yKG4pLHtpbnB1dHM6ZSxpbml0aWFsU3RhdGU6dCxjb25zdGFudHM6bn19ZnVuY3Rpb24geUMoZSx0LG4sYT0hMSxyLHMsaT0hMSxvPSExKXtyZXR1cm4gTygoKT0+e2xldCBsPXQuc2hhcGUubGVuZ3RoO2lmKGw8Myl0aHJvdyBuZXcgVihgSW5wdXQgc2hvdWxkIGJlIGF0IGxlYXN0IDNELCBidXQgaXMgJHtsfUQuYCk7bGV0IHU9WzEsMF0uY29uY2F0KFVhKDIsbCkpO2lmKHQ9RGUodCx1KSxzIT1udWxsKXRocm93IG5ldyB6ZShcIlRoZSBybm4oKSBmdW5jdG9pbiBvZiB0aGUgZGVlcGxlYXJuLmpzIGJhY2tlbmQgZG9lcyBub3Qgc3VwcG9ydCBjb25zdGFudHMgeWV0LlwiKTtpJiZjb25zb2xlLndhcm4oXCJCYWNrZW5kIHJubigpOiB0aGUgdW5yb2xsID0gdHJ1ZSBvcHRpb24gaXMgbm90IGFwcGxpY2FibGUgdG8gdGhlIGltcGVyYXRpdmUgZGVlcGxlYXJuLmpzIGJhY2tlbmQuXCIpLHIhPW51bGwmJihyPXJlKHJlKHIsXCJib29sXCIpLFwiZmxvYXQzMlwiKSxyLnJhbms9PT1sLTEmJihyPUd0KHIsLTEpKSxyPURlKHIsdSkpLGEmJih0PWJhKHQsMCksciE9bnVsbCYmKHI9YmEociwwKSkpO2xldCBwPVtdLGQsYz1uLGg9dC5zaGFwZVswXSxtPWR0KHQpLGY7ciE9bnVsbCYmKGY9ZHQocikpO2ZvcihsZXQgYj0wO2I8aDsrK2Ipe2xldCB5PW1bYl0seD1PKCgpPT5lKHksYykpO2lmKHI9PW51bGwpZD14WzBdLGM9eFsxXTtlbHNle2xldCB2PU8oKCk9PntsZXQgST1mW2JdLE49cGUoZWEoSSksSSksQz1YKHooeFswXSxJKSx6KGNbMF0sTikpLF89Yy5tYXAoKEYsRCk9Plgoeih4WzFdW0RdLEkpLHooRixOKSkpO3JldHVybntvdXRwdXQ6QyxuZXdTdGF0ZXM6X319KTtkPXYub3V0cHV0LGM9di5uZXdTdGF0ZXN9byYmcC5wdXNoKGQpfWxldCBnO3JldHVybiBvJiYoZz1BdChwLDEpKSxbZCxnLGNdfSl9dmFyIE1yPWNsYXNzIHhDIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IodCl7c3VwZXIodCk7bGV0IG47aWYodC5jZWxsPT1udWxsKXRocm93IG5ldyBWKFwiY2VsbCBwcm9wZXJ0eSBpcyBtaXNzaW5nIGZvciB0aGUgY29uc3RydWN0b3Igb2YgUk5OLlwiKTtpZihBcnJheS5pc0FycmF5KHQuY2VsbCk/bj1uZXcgUmYoe2NlbGxzOnQuY2VsbH0pOm49dC5jZWxsLG4uc3RhdGVTaXplPT1udWxsKXRocm93IG5ldyBWKFwiVGhlIFJOTiBjZWxsIHNob3VsZCBoYXZlIGFuIGF0dHJpYnV0ZSBgc3RhdGVTaXplYCAodHVwbGUgb2YgaW50ZWdlcnMsIG9uZSBpbnRlZ2VyIHBlciBSTk4gc3RhdGUpLlwiKTt0aGlzLmNlbGw9bix0aGlzLnJldHVyblNlcXVlbmNlcz10LnJldHVyblNlcXVlbmNlcz09bnVsbD8hMTp0LnJldHVyblNlcXVlbmNlcyx0aGlzLnJldHVyblN0YXRlPXQucmV0dXJuU3RhdGU9PW51bGw/ITE6dC5yZXR1cm5TdGF0ZSx0aGlzLmdvQmFja3dhcmRzPXQuZ29CYWNrd2FyZHM9PW51bGw/ITE6dC5nb0JhY2t3YXJkcyx0aGlzLl9zdGF0ZWZ1bD10LnN0YXRlZnVsPT1udWxsPyExOnQuc3RhdGVmdWwsdGhpcy51bnJvbGw9dC51bnJvbGw9PW51bGw/ITE6dC51bnJvbGwsdGhpcy5zdXBwb3J0c01hc2tpbmc9ITAsdGhpcy5pbnB1dFNwZWM9W25ldyB6dCh7bmRpbTozfSldLHRoaXMuc3RhdGVTcGVjPW51bGwsdGhpcy5zdGF0ZXNfPW51bGwsdGhpcy5udW1Db25zdGFudHM9bnVsbCx0aGlzLmtlcHRTdGF0ZXM9W119Z2V0U3RhdGVzKCl7aWYodGhpcy5zdGF0ZXNfPT1udWxsKXtsZXQgdD1BcnJheS5pc0FycmF5KHRoaXMuY2VsbC5zdGF0ZVNpemUpP3RoaXMuY2VsbC5zdGF0ZVNpemUubGVuZ3RoOjE7cmV0dXJuIFVhKDAsdCkubWFwKG49Pm51bGwpfWVsc2UgcmV0dXJuIHRoaXMuc3RhdGVzX31zZXRTdGF0ZXModCl7dGhpcy5zdGF0ZXNfPXR9Y29tcHV0ZU91dHB1dFNoYXBlKHQpe1Z4KHQpJiYodD10WzBdKSx0PXQ7bGV0IG49dGhpcy5jZWxsLnN0YXRlU2l6ZTtBcnJheS5pc0FycmF5KG4pfHwobj1bbl0pO2xldCBhPW5bMF0scjtpZih0aGlzLnJldHVyblNlcXVlbmNlcz9yPVt0WzBdLHRbMV0sYV06cj1bdFswXSxhXSx0aGlzLnJldHVyblN0YXRlKXtsZXQgcz1bXTtmb3IobGV0IGkgb2YgbilzLnB1c2goW3RbMF0saV0pO3JldHVybltyXS5jb25jYXQocyl9ZWxzZSByZXR1cm4gcn1jb21wdXRlTWFzayh0LG4pe3JldHVybiBPKCgpPT57QXJyYXkuaXNBcnJheShuKSYmKG49blswXSk7bGV0IGE9dGhpcy5yZXR1cm5TZXF1ZW5jZXM/bjpudWxsO2lmKHRoaXMucmV0dXJuU3RhdGUpe2xldCByPXRoaXMuc3RhdGVzLm1hcChzPT5udWxsKTtyZXR1cm5bYV0uY29uY2F0KHIpfWVsc2UgcmV0dXJuIGF9KX1nZXQgc3RhdGVzKCl7aWYodGhpcy5zdGF0ZXNfPT1udWxsKXtsZXQgdD1BcnJheS5pc0FycmF5KHRoaXMuY2VsbC5zdGF0ZVNpemUpP3RoaXMuY2VsbC5zdGF0ZVNpemUubGVuZ3RoOjEsbj1bXTtmb3IobGV0IGE9MDthPHQ7KythKW4ucHVzaChudWxsKTtyZXR1cm4gbn1lbHNlIHJldHVybiB0aGlzLnN0YXRlc199c2V0IHN0YXRlcyh0KXt0aGlzLnN0YXRlc189dH1idWlsZCh0KXtpZih0aGlzLm51bUNvbnN0YW50cyE9bnVsbCl0aHJvdyBuZXcgemUoXCJDb25zdGFudHMgc3VwcG9ydCBpcyBub3QgaW1wbGVtZW50ZWQgaW4gUk5OIHlldC5cIik7VngodCkmJih0PXRbMF0pLHQ9dDtsZXQgbj10aGlzLnN0YXRlZnVsP3RbMF06bnVsbCxhPXQuc2xpY2UoMik7dGhpcy5pbnB1dFNwZWNbMF09bmV3IHp0KHtzaGFwZTpbbixudWxsLC4uLmFdfSk7bGV0IHI9W3RbMF1dLmNvbmNhdCh0LnNsaWNlKDIpKTt0aGlzLmNlbGwuYnVpbGQocik7bGV0IHM7aWYoQXJyYXkuaXNBcnJheSh0aGlzLmNlbGwuc3RhdGVTaXplKT9zPXRoaXMuY2VsbC5zdGF0ZVNpemU6cz1bdGhpcy5jZWxsLnN0YXRlU2l6ZV0sdGhpcy5zdGF0ZVNwZWMhPW51bGwpe2lmKCF3LmFycmF5c0VxdWFsKHRoaXMuc3RhdGVTcGVjLm1hcChpPT5pLnNoYXBlW2kuc2hhcGUubGVuZ3RoLTFdKSxzKSl0aHJvdyBuZXcgVihgQW4gaW5pdGlhbFN0YXRlIHdhcyBwYXNzZWQgdGhhdCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGNlbGwuc3RhdGVTaXplLiBSZWNlaXZlZCBzdGF0ZVNwZWM9JHt0aGlzLnN0YXRlU3BlY307IEhvd2V2ZXIgY2VsbC5zdGF0ZVNpemUgaXMgJHt0aGlzLmNlbGwuc3RhdGVTaXplfWApfWVsc2UgdGhpcy5zdGF0ZVNwZWM9cy5tYXAoaT0+bmV3IHp0KHtzaGFwZTpbbnVsbCxpXX0pKTt0aGlzLnN0YXRlZnVsJiZ0aGlzLnJlc2V0U3RhdGVzKCl9cmVzZXRTdGF0ZXModCxuPSExKXtPKCgpPT57aWYoIXRoaXMuc3RhdGVmdWwpdGhyb3cgbmV3IFhyKFwiQ2Fubm90IGNhbGwgcmVzZXRTdGF0ZXMoKSBvbiBhbiBSTk4gTGF5ZXIgdGhhdCBpcyBub3Qgc3RhdGVmdWwuXCIpO2xldCBhPXRoaXMuaW5wdXRTcGVjWzBdLnNoYXBlWzBdO2lmKGE9PW51bGwpdGhyb3cgbmV3IFYoXCJJZiBhbiBSTk4gaXMgc3RhdGVmdWwsIGl0IG5lZWRzIHRvIGtub3cgaXRzIGJhdGNoIHNpemUuIFNwZWNpZnkgdGhlIGJhdGNoIHNpemUgb2YgeW91ciBpbnB1dCB0ZW5zb3JzOiBcXG4tIElmIHVzaW5nIGEgU2VxdWVudGlhbCBtb2RlbCwgc3BlY2lmeSB0aGUgYmF0Y2ggc2l6ZSBieSBwYXNzaW5nIGEgYGJhdGNoSW5wdXRTaGFwZWAgb3B0aW9uIHRvIHlvdXIgZmlyc3QgbGF5ZXIuXFxuLSBJZiB1c2luZyB0aGUgZnVuY3Rpb25hbCBBUEksIHNwZWNpZnkgdGhlIGJhdGNoIHNpemUgYnkgcGFzc2luZyBhIGBiYXRjaFNoYXBlYCBvcHRpb24gdG8geW91ciBJbnB1dCBsYXllci5cIik7aWYodGhpcy5zdGF0ZXNfPT1udWxsKUFycmF5LmlzQXJyYXkodGhpcy5jZWxsLnN0YXRlU2l6ZSk/dGhpcy5zdGF0ZXNfPXRoaXMuY2VsbC5zdGF0ZVNpemUubWFwKHI9Pkl0KFthLHJdKSk6dGhpcy5zdGF0ZXNfPVtJdChbYSx0aGlzLmNlbGwuc3RhdGVTaXplXSldO2Vsc2UgaWYodD09bnVsbClFZSh0aGlzLnN0YXRlc18pLHRoaXMua2VwdFN0YXRlcyE9bnVsbCYmKEVlKHRoaXMua2VwdFN0YXRlcyksdGhpcy5rZXB0U3RhdGVzPVtdKSxBcnJheS5pc0FycmF5KHRoaXMuY2VsbC5zdGF0ZVNpemUpP3RoaXMuc3RhdGVzXz10aGlzLmNlbGwuc3RhdGVTaXplLm1hcChyPT5JdChbYSxyXSkpOnRoaXMuc3RhdGVzX1swXT1JdChbYSx0aGlzLmNlbGwuc3RhdGVTaXplXSk7ZWxzZXtpZihBcnJheS5pc0FycmF5KHQpfHwodD1bdF0pLHQubGVuZ3RoIT09dGhpcy5zdGF0ZXNfLmxlbmd0aCl0aHJvdyBuZXcgVihgTGF5ZXIgJHt0aGlzLm5hbWV9IGV4cGVjdHMgJHt0aGlzLnN0YXRlc18ubGVuZ3RofSBzdGF0ZShzKSwgYnV0IGl0IHJlY2VpdmVkICR7dC5sZW5ndGh9IHN0YXRlIHZhbHVlKHMpLiBJbnB1dCByZWNlaXZlZDogJHt0fWApO249PT0hMD90aGlzLmtlcHRTdGF0ZXMucHVzaCh0aGlzLnN0YXRlc18uc2xpY2UoKSk6RWUodGhpcy5zdGF0ZXNfKTtmb3IobGV0IHI9MDtyPHRoaXMuc3RhdGVzXy5sZW5ndGg7KytyKXtsZXQgcz10W3JdLGk9QXJyYXkuaXNBcnJheSh0aGlzLmNlbGwuc3RhdGVTaXplKT90aGlzLmNlbGwuc3RhdGVTaXplW3JdOnRoaXMuY2VsbC5zdGF0ZVNpemUsbz1bYSxpXTtpZighdy5hcnJheXNFcXVhbChzLnNoYXBlLG8pKXRocm93IG5ldyBWKGBTdGF0ZSAke3J9IGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyICR7dGhpcy5uYW1lfTogZXhwZWN0ZWQgc2hhcGU9JHtvfSwgcmVjZWl2ZWQgc2hhcGU9JHtzLnNoYXBlfWApO3RoaXMuc3RhdGVzX1tyXT1zfX10aGlzLnN0YXRlc189dGhpcy5zdGF0ZXNfLm1hcChyPT5IdChyLmNsb25lKCkpKX0pfWFwcGx5KHQsbil7bGV0IGE9bj09bnVsbD9udWxsOm4uaW5pdGlhbFN0YXRlLHI9bj09bnVsbD9udWxsOm4uY29uc3RhbnRzO249PW51bGwmJihuPXt9KTtsZXQgcz1iQyh0LGEscix0aGlzLm51bUNvbnN0YW50cyk7dD1zLmlucHV0cyxhPXMuaW5pdGlhbFN0YXRlLHI9cy5jb25zdGFudHM7bGV0IGk9W10sbz1bXTtpZihhIT1udWxsKXtuLmluaXRpYWxTdGF0ZT1hLGk9aS5jb25jYXQoYSksdGhpcy5zdGF0ZVNwZWM9W107Zm9yKGxldCBsIG9mIGEpdGhpcy5zdGF0ZVNwZWMucHVzaChuZXcgenQoe3NoYXBlOmwuc2hhcGV9KSk7bz1vLmNvbmNhdCh0aGlzLnN0YXRlU3BlYyl9aWYociE9bnVsbCYmKG4uY29uc3RhbnRzPXIsaT1pLmNvbmNhdChyKSx0aGlzLm51bUNvbnN0YW50cz1yLmxlbmd0aCksaVswXWluc3RhbmNlb2YgSGEpe2xldCBsPVt0XS5jb25jYXQoaSksdT10aGlzLmlucHV0U3BlYy5jb25jYXQobykscD10aGlzLmlucHV0U3BlYzt0aGlzLmlucHV0U3BlYz11O2xldCBkPXN1cGVyLmFwcGx5KGwsbik7cmV0dXJuIHRoaXMuaW5wdXRTcGVjPXAsZH1lbHNlIHJldHVybiBzdXBlci5hcHBseSh0LG4pfWNhbGwodCxuKXtyZXR1cm4gTygoKT0+e2xldCBhPW49PW51bGw/bnVsbDpuLm1hc2sscj1uPT1udWxsP251bGw6bi50cmFpbmluZyxzPW49PW51bGw/bnVsbDpuLmluaXRpYWxTdGF0ZTt0PVRlKHQpLHM9PW51bGwmJih0aGlzLnN0YXRlZnVsP3M9dGhpcy5zdGF0ZXNfOnM9dGhpcy5nZXRJbml0aWFsU3RhdGUodCkpO2xldCBpPUFycmF5LmlzQXJyYXkodGhpcy5jZWxsLnN0YXRlU2l6ZSk/dGhpcy5jZWxsLnN0YXRlU2l6ZS5sZW5ndGg6MTtpZihzLmxlbmd0aCE9PWkpdGhyb3cgbmV3IFYoYFJOTiBMYXllciBoYXMgJHtpfSBzdGF0ZShzKSBidXQgd2FzIHBhc3NlZCAke3MubGVuZ3RofSBpbml0aWFsIHN0YXRlKHMpLmApO3RoaXMudW5yb2xsJiZjb25zb2xlLndhcm4oXCJJZ25vcmluZyB1bnJvbGwgPSB0cnVlIGZvciBSTk4gbGF5ZXIsIGR1ZSB0byBpbXBlcmF0aXZlIGJhY2tlbmQuXCIpO2xldCBvPXt0cmFpbmluZzpyfSxsPXlDKChoLG0pPT57bGV0IGY9dGhpcy5jZWxsLmNhbGwoW2hdLmNvbmNhdChtKSxvKTtyZXR1cm5bZlswXSxmLnNsaWNlKDEpXX0sdCxzLHRoaXMuZ29CYWNrd2FyZHMsYSxudWxsLHRoaXMudW5yb2xsLHRoaXMucmV0dXJuU2VxdWVuY2VzKSx1PWxbMF0scD1sWzFdLGQ9bFsyXTt0aGlzLnN0YXRlZnVsJiZ0aGlzLnJlc2V0U3RhdGVzKGQscik7bGV0IGM9dGhpcy5yZXR1cm5TZXF1ZW5jZXM/cDp1O3JldHVybiB0aGlzLnJldHVyblN0YXRlP1tjXS5jb25jYXQoZCk6Y30pfWdldEluaXRpYWxTdGF0ZSh0KXtyZXR1cm4gTygoKT0+e2xldCBuPUl0KHQuc2hhcGUpO3JldHVybiBuPWZlKG4sWzEsMl0pLG49d2QobiksQXJyYXkuaXNBcnJheSh0aGlzLmNlbGwuc3RhdGVTaXplKT90aGlzLmNlbGwuc3RhdGVTaXplLm1hcChhPT5hPjE/V3gobixbMSxhXSk6bik6dGhpcy5jZWxsLnN0YXRlU2l6ZT4xP1tXeChuLFsxLHRoaXMuY2VsbC5zdGF0ZVNpemVdKV06W25dfSl9Z2V0IHRyYWluYWJsZVdlaWdodHMoKXtyZXR1cm4gdGhpcy50cmFpbmFibGU/dGhpcy5jZWxsLnRyYWluYWJsZVdlaWdodHM6W119Z2V0IG5vblRyYWluYWJsZVdlaWdodHMoKXtyZXR1cm4gdGhpcy50cmFpbmFibGU/dGhpcy5jZWxsLm5vblRyYWluYWJsZVdlaWdodHM6dGhpcy5jZWxsLndlaWdodHN9c2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZCh0KXtzdXBlci5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkKHQpLHRoaXMuY2VsbCE9bnVsbCYmdGhpcy5jZWxsLnNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQodCl9Z2V0Q29uZmlnKCl7bGV0IHQ9c3VwZXIuZ2V0Q29uZmlnKCksbj17cmV0dXJuU2VxdWVuY2VzOnRoaXMucmV0dXJuU2VxdWVuY2VzLHJldHVyblN0YXRlOnRoaXMucmV0dXJuU3RhdGUsZ29CYWNrd2FyZHM6dGhpcy5nb0JhY2t3YXJkcyxzdGF0ZWZ1bDp0aGlzLnN0YXRlZnVsLHVucm9sbDp0aGlzLnVucm9sbH07dGhpcy5udW1Db25zdGFudHMhPW51bGwmJihuLm51bUNvbnN0YW50cz10aGlzLm51bUNvbnN0YW50cyk7bGV0IGE9dGhpcy5jZWxsLmdldENvbmZpZygpO3JldHVybiB0aGlzLmdldENsYXNzTmFtZSgpPT09eEMuY2xhc3NOYW1lJiYobi5jZWxsPXtjbGFzc05hbWU6dGhpcy5jZWxsLmdldENsYXNzTmFtZSgpLGNvbmZpZzphfSksT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSksdCksbil9c3RhdGljIGZyb21Db25maWcodCxuLGE9e30pe2xldCByPW4uY2VsbCxzPUJhKHIsYSk7cmV0dXJuIG5ldyB0KE9iamVjdC5hc3NpZ24obix7Y2VsbDpzfSkpfX07TXIuY2xhc3NOYW1lPVwiUk5OXCI7bmUucmVnaXN0ZXJDbGFzcyhNcik7dmFyIFRkPWNsYXNzIGV4dGVuZHMgV2V7fSwkZj1jbGFzcyBleHRlbmRzIFRke2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLHRoaXMuREVGQVVMVF9BQ1RJVkFUSU9OPVwidGFuaFwiLHRoaXMuREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVI9XCJnbG9yb3ROb3JtYWxcIix0aGlzLkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSPVwib3J0aG9nb25hbFwiLHRoaXMuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSPVwiemVyb3NcIix0aGlzLnVuaXRzPWUudW5pdHMsdG4odGhpcy51bml0cyxcInVuaXRzXCIpLHRoaXMuYWN0aXZhdGlvbj1mcyhlLmFjdGl2YXRpb249PW51bGw/dGhpcy5ERUZBVUxUX0FDVElWQVRJT046ZS5hY3RpdmF0aW9uKSx0aGlzLnVzZUJpYXM9ZS51c2VCaWFzPT1udWxsPyEwOmUudXNlQmlhcyx0aGlzLmtlcm5lbEluaXRpYWxpemVyPVN0KGUua2VybmVsSW5pdGlhbGl6ZXJ8fHRoaXMuREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIpLHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXI9U3QoZS5yZWN1cnJlbnRJbml0aWFsaXplcnx8dGhpcy5ERUZBVUxUX1JFQ1VSUkVOVF9JTklUSUFMSVpFUiksdGhpcy5iaWFzSW5pdGlhbGl6ZXI9U3QoZS5iaWFzSW5pdGlhbGl6ZXJ8fHRoaXMuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSKSx0aGlzLmtlcm5lbFJlZ3VsYXJpemVyPU50KGUua2VybmVsUmVndWxhcml6ZXIpLHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXI9TnQoZS5yZWN1cnJlbnRSZWd1bGFyaXplciksdGhpcy5iaWFzUmVndWxhcml6ZXI9TnQoZS5iaWFzUmVndWxhcml6ZXIpLHRoaXMua2VybmVsQ29uc3RyYWludD1ZdChlLmtlcm5lbENvbnN0cmFpbnQpLHRoaXMucmVjdXJyZW50Q29uc3RyYWludD1ZdChlLnJlY3VycmVudENvbnN0cmFpbnQpLHRoaXMuYmlhc0NvbnN0cmFpbnQ9WXQoZS5iaWFzQ29uc3RyYWludCksdGhpcy5kcm9wb3V0PVVsKFsxLGhzKFswLGUuZHJvcG91dD09bnVsbD8wOmUuZHJvcG91dF0pXSksdGhpcy5yZWN1cnJlbnREcm9wb3V0PVVsKFsxLGhzKFswLGUucmVjdXJyZW50RHJvcG91dD09bnVsbD8wOmUucmVjdXJyZW50RHJvcG91dF0pXSksdGhpcy5kcm9wb3V0RnVuYz1lLmRyb3BvdXRGdW5jLHRoaXMuc3RhdGVTaXplPXRoaXMudW5pdHMsdGhpcy5kcm9wb3V0TWFzaz1udWxsLHRoaXMucmVjdXJyZW50RHJvcG91dE1hc2s9bnVsbH1idWlsZChlKXtlPUplKGUpLHRoaXMua2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwia2VybmVsXCIsW2VbZS5sZW5ndGgtMV0sdGhpcy51bml0c10sbnVsbCx0aGlzLmtlcm5lbEluaXRpYWxpemVyLHRoaXMua2VybmVsUmVndWxhcml6ZXIsITAsdGhpcy5rZXJuZWxDb25zdHJhaW50KSx0aGlzLnJlY3VycmVudEtlcm5lbD10aGlzLmFkZFdlaWdodChcInJlY3VycmVudF9rZXJuZWxcIixbdGhpcy51bml0cyx0aGlzLnVuaXRzXSxudWxsLHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIsdGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciwhMCx0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLHRoaXMudXNlQmlhcz90aGlzLmJpYXM9dGhpcy5hZGRXZWlnaHQoXCJiaWFzXCIsW3RoaXMudW5pdHNdLG51bGwsdGhpcy5iaWFzSW5pdGlhbGl6ZXIsdGhpcy5iaWFzUmVndWxhcml6ZXIsITAsdGhpcy5iaWFzQ29uc3RyYWludCk6dGhpcy5iaWFzPW51bGwsdGhpcy5idWlsdD0hMH1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9PntpZihlPWUsZS5sZW5ndGghPT0yKXRocm93IG5ldyBWKGBTaW1wbGVSTk5DZWxsIGV4cGVjdHMgMiBpbnB1dCBUZW5zb3JzLCBnb3QgJHtlLmxlbmd0aH0uYCk7bGV0IG49ZVsxXTtlPWVbMF07bGV0IGE9dC50cmFpbmluZz09bnVsbD8hMTp0LnRyYWluaW5nOzA8dGhpcy5kcm9wb3V0JiZ0aGlzLmRyb3BvdXQ8MSYmdGhpcy5kcm9wb3V0TWFzaz09bnVsbCYmKHRoaXMuZHJvcG91dE1hc2s9Z3Moe29uZXM6KCk9PmVhKGUpLHJhdGU6dGhpcy5kcm9wb3V0LHRyYWluaW5nOmEsZHJvcG91dEZ1bmM6dGhpcy5kcm9wb3V0RnVuY30pKSwwPHRoaXMucmVjdXJyZW50RHJvcG91dCYmdGhpcy5yZWN1cnJlbnREcm9wb3V0PDEmJnRoaXMucmVjdXJyZW50RHJvcG91dE1hc2s9PW51bGwmJih0aGlzLnJlY3VycmVudERyb3BvdXRNYXNrPWdzKHtvbmVzOigpPT5lYShuKSxyYXRlOnRoaXMucmVjdXJyZW50RHJvcG91dCx0cmFpbmluZzphLGRyb3BvdXRGdW5jOnRoaXMuZHJvcG91dEZ1bmN9KSk7bGV0IHIscz10aGlzLmRyb3BvdXRNYXNrLGk9dGhpcy5yZWN1cnJlbnREcm9wb3V0TWFzaztzIT1udWxsP3I9b3IoeihlLHMpLHRoaXMua2VybmVsLnJlYWQoKSk6cj1vcihlLHRoaXMua2VybmVsLnJlYWQoKSksdGhpcy5iaWFzIT1udWxsJiYocj1LYShyLHRoaXMuYmlhcy5yZWFkKCkpKSxpIT1udWxsJiYobj16KG4saSkpO2xldCBvPVgocixvcihuLHRoaXMucmVjdXJyZW50S2VybmVsLnJlYWQoKSkpO3JldHVybiB0aGlzLmFjdGl2YXRpb24hPW51bGwmJihvPXRoaXMuYWN0aXZhdGlvbi5hcHBseShvKSksW28sb119KX1nZXRDb25maWcoKXtsZXQgZT1zdXBlci5nZXRDb25maWcoKSx0PXt1bml0czp0aGlzLnVuaXRzLGFjdGl2YXRpb246bXModGhpcy5hY3RpdmF0aW9uKSx1c2VCaWFzOnRoaXMudXNlQmlhcyxrZXJuZWxJbml0aWFsaXplcjpFdCh0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxyZWN1cnJlbnRJbml0aWFsaXplcjpFdCh0aGlzLnJlY3VycmVudEluaXRpYWxpemVyKSxiaWFzSW5pdGlhbGl6ZXI6RXQodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLGtlcm5lbFJlZ3VsYXJpemVyOmZ0KHRoaXMua2VybmVsUmVndWxhcml6ZXIpLHJlY3VycmVudFJlZ3VsYXJpemVyOmZ0KHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIpLGJpYXNSZWd1bGFyaXplcjpmdCh0aGlzLmJpYXNSZWd1bGFyaXplciksYWN0aXZpdHlSZWd1bGFyaXplcjpmdCh0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLGtlcm5lbENvbnN0cmFpbnQ6WHQodGhpcy5rZXJuZWxDb25zdHJhaW50KSxyZWN1cnJlbnRDb25zdHJhaW50Olh0KHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksYmlhc0NvbnN0cmFpbnQ6WHQodGhpcy5iaWFzQ29uc3RyYWludCksZHJvcG91dDp0aGlzLmRyb3BvdXQscmVjdXJyZW50RHJvcG91dDp0aGlzLnJlY3VycmVudERyb3BvdXR9O3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSksdCl9fTskZi5jbGFzc05hbWU9XCJTaW1wbGVSTk5DZWxsXCI7bmUucmVnaXN0ZXJDbGFzcygkZik7dmFyIFAwPWNsYXNzIGV4dGVuZHMgTXJ7Y29uc3RydWN0b3IoZSl7ZS5jZWxsPW5ldyAkZihlKSxzdXBlcihlKX1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9Pnt0aGlzLmNlbGwuZHJvcG91dE1hc2shPW51bGwmJihFZSh0aGlzLmNlbGwuZHJvcG91dE1hc2spLHRoaXMuY2VsbC5kcm9wb3V0TWFzaz1udWxsKSx0aGlzLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2shPW51bGwmJihFZSh0aGlzLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2spLHRoaXMuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzaz1udWxsKTtsZXQgbj10PT1udWxsP251bGw6dC5tYXNrLGE9dD09bnVsbD9udWxsOnQudHJhaW5pbmcscj10PT1udWxsP251bGw6dC5pbml0aWFsU3RhdGU7cmV0dXJuIHN1cGVyLmNhbGwoZSx7bWFzazpuLHRyYWluaW5nOmEsaW5pdGlhbFN0YXRlOnJ9KX0pfXN0YXRpYyBmcm9tQ29uZmlnKGUsdCl7cmV0dXJuIG5ldyBlKHQpfX07UDAuY2xhc3NOYW1lPVwiU2ltcGxlUk5OXCI7bmUucmVnaXN0ZXJDbGFzcyhQMCk7dmFyIERmPWNsYXNzIGV4dGVuZHMgVGR7Y29uc3RydWN0b3IoZSl7aWYoc3VwZXIoZSksdGhpcy5ERUZBVUxUX0FDVElWQVRJT049XCJ0YW5oXCIsdGhpcy5ERUZBVUxUX1JFQ1VSUkVOVF9BQ1RJVkFUSU9OPVwiaGFyZFNpZ21vaWRcIix0aGlzLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSPVwiZ2xvcm90Tm9ybWFsXCIsdGhpcy5ERUZBVUxUX1JFQ1VSUkVOVF9JTklUSUFMSVpFUj1cIm9ydGhvZ29uYWxcIix0aGlzLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUj1cInplcm9zXCIsZS5yZXNldEFmdGVyKXRocm93IG5ldyBWKFwiR1JVQ2VsbCBkb2VzIG5vdCBzdXBwb3J0IHJlc2V0X2FmdGVyIHBhcmFtZXRlciBzZXQgdG8gdHJ1ZS5cIik7dGhpcy51bml0cz1lLnVuaXRzLHRuKHRoaXMudW5pdHMsXCJ1bml0c1wiKSx0aGlzLmFjdGl2YXRpb249ZnMoZS5hY3RpdmF0aW9uPT09dm9pZCAwP3RoaXMuREVGQVVMVF9BQ1RJVkFUSU9OOmUuYWN0aXZhdGlvbiksdGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uPWZzKGUucmVjdXJyZW50QWN0aXZhdGlvbj09PXZvaWQgMD90aGlzLkRFRkFVTFRfUkVDVVJSRU5UX0FDVElWQVRJT046ZS5yZWN1cnJlbnRBY3RpdmF0aW9uKSx0aGlzLnVzZUJpYXM9ZS51c2VCaWFzPT1udWxsPyEwOmUudXNlQmlhcyx0aGlzLmtlcm5lbEluaXRpYWxpemVyPVN0KGUua2VybmVsSW5pdGlhbGl6ZXJ8fHRoaXMuREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIpLHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXI9U3QoZS5yZWN1cnJlbnRJbml0aWFsaXplcnx8dGhpcy5ERUZBVUxUX1JFQ1VSUkVOVF9JTklUSUFMSVpFUiksdGhpcy5iaWFzSW5pdGlhbGl6ZXI9U3QoZS5iaWFzSW5pdGlhbGl6ZXJ8fHRoaXMuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSKSx0aGlzLmtlcm5lbFJlZ3VsYXJpemVyPU50KGUua2VybmVsUmVndWxhcml6ZXIpLHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXI9TnQoZS5yZWN1cnJlbnRSZWd1bGFyaXplciksdGhpcy5iaWFzUmVndWxhcml6ZXI9TnQoZS5iaWFzUmVndWxhcml6ZXIpLHRoaXMua2VybmVsQ29uc3RyYWludD1ZdChlLmtlcm5lbENvbnN0cmFpbnQpLHRoaXMucmVjdXJyZW50Q29uc3RyYWludD1ZdChlLnJlY3VycmVudENvbnN0cmFpbnQpLHRoaXMuYmlhc0NvbnN0cmFpbnQ9WXQoZS5iaWFzQ29uc3RyYWludCksdGhpcy5kcm9wb3V0PVVsKFsxLGhzKFswLGUuZHJvcG91dD09bnVsbD8wOmUuZHJvcG91dF0pXSksdGhpcy5yZWN1cnJlbnREcm9wb3V0PVVsKFsxLGhzKFswLGUucmVjdXJyZW50RHJvcG91dD09bnVsbD8wOmUucmVjdXJyZW50RHJvcG91dF0pXSksdGhpcy5kcm9wb3V0RnVuYz1lLmRyb3BvdXRGdW5jLHRoaXMuaW1wbGVtZW50YXRpb249ZS5pbXBsZW1lbnRhdGlvbix0aGlzLnN0YXRlU2l6ZT10aGlzLnVuaXRzLHRoaXMuZHJvcG91dE1hc2s9bnVsbCx0aGlzLnJlY3VycmVudERyb3BvdXRNYXNrPW51bGx9YnVpbGQoZSl7ZT1KZShlKTtsZXQgdD1lW2UubGVuZ3RoLTFdO3RoaXMua2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwia2VybmVsXCIsW3QsdGhpcy51bml0cyozXSxudWxsLHRoaXMua2VybmVsSW5pdGlhbGl6ZXIsdGhpcy5rZXJuZWxSZWd1bGFyaXplciwhMCx0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHRoaXMucmVjdXJyZW50S2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwicmVjdXJyZW50X2tlcm5lbFwiLFt0aGlzLnVuaXRzLHRoaXMudW5pdHMqM10sbnVsbCx0aGlzLnJlY3VycmVudEluaXRpYWxpemVyLHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIsITAsdGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KSx0aGlzLnVzZUJpYXM/dGhpcy5iaWFzPXRoaXMuYWRkV2VpZ2h0KFwiYmlhc1wiLFt0aGlzLnVuaXRzKjNdLG51bGwsdGhpcy5iaWFzSW5pdGlhbGl6ZXIsdGhpcy5iaWFzUmVndWxhcml6ZXIsITAsdGhpcy5iaWFzQ29uc3RyYWludCk6dGhpcy5iaWFzPW51bGwsdGhpcy5idWlsdD0hMH1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9PntpZihlPWUsZS5sZW5ndGghPT0yKXRocm93IG5ldyBWKGBHUlVDZWxsIGV4cGVjdHMgMiBpbnB1dCBUZW5zb3JzIChpbnB1dHMsIGgsIGMpLCBnb3QgJHtlLmxlbmd0aH0uYCk7bGV0IG49dC50cmFpbmluZz09bnVsbD8hMTp0LnRyYWluaW5nLGE9ZVsxXTtlPWVbMF0sMDx0aGlzLmRyb3BvdXQmJnRoaXMuZHJvcG91dDwxJiZ0aGlzLmRyb3BvdXRNYXNrPT1udWxsJiYodGhpcy5kcm9wb3V0TWFzaz1ncyh7b25lczooKT0+ZWEoZSkscmF0ZTp0aGlzLmRyb3BvdXQsdHJhaW5pbmc6bixjb3VudDozLGRyb3BvdXRGdW5jOnRoaXMuZHJvcG91dEZ1bmN9KSksMDx0aGlzLnJlY3VycmVudERyb3BvdXQmJnRoaXMucmVjdXJyZW50RHJvcG91dDwxJiZ0aGlzLnJlY3VycmVudERyb3BvdXRNYXNrPT1udWxsJiYodGhpcy5yZWN1cnJlbnREcm9wb3V0TWFzaz1ncyh7b25lczooKT0+ZWEoYSkscmF0ZTp0aGlzLnJlY3VycmVudERyb3BvdXQsdHJhaW5pbmc6bixjb3VudDozLGRyb3BvdXRGdW5jOnRoaXMuZHJvcG91dEZ1bmN9KSk7bGV0IHI9dGhpcy5kcm9wb3V0TWFzayxzPXRoaXMucmVjdXJyZW50RHJvcG91dE1hc2ssaSxvLGw7MDx0aGlzLmRyb3BvdXQmJnRoaXMuZHJvcG91dDwxJiYoZT16KGUsclswXSkpO2xldCB1PW9yKGUsdGhpcy5rZXJuZWwucmVhZCgpKTt0aGlzLnVzZUJpYXMmJih1PUthKHUsdGhpcy5iaWFzLnJlYWQoKSkpLDA8dGhpcy5yZWN1cnJlbnREcm9wb3V0JiZ0aGlzLnJlY3VycmVudERyb3BvdXQ8MSYmKGE9eihhLHNbMF0pKTtsZXQgcD10aGlzLnJlY3VycmVudEtlcm5lbC5yZWFkKCksW2QsY109TG4ocCxbMip0aGlzLnVuaXRzLHRoaXMudW5pdHNdLHAucmFuay0xKSxoPW9yKGEsZCksW20sZixnXT1Mbih1LDMsdS5yYW5rLTEpLFtiLHldPUxuKGgsMixoLnJhbmstMSk7aT10aGlzLnJlY3VycmVudEFjdGl2YXRpb24uYXBwbHkoWChtLGIpKSxvPXRoaXMucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseShYKGYseSkpO2xldCB4PW9yKHoobyxhKSxjKTtsPXRoaXMuYWN0aXZhdGlvbi5hcHBseShYKGcseCkpO2xldCB2PVgoeihpLGEpLHooWCgxLHl0KGkpKSxsKSk7cmV0dXJuW3Ysdl19KX1nZXRDb25maWcoKXtsZXQgZT1zdXBlci5nZXRDb25maWcoKSx0PXt1bml0czp0aGlzLnVuaXRzLGFjdGl2YXRpb246bXModGhpcy5hY3RpdmF0aW9uKSxyZWN1cnJlbnRBY3RpdmF0aW9uOm1zKHRoaXMucmVjdXJyZW50QWN0aXZhdGlvbiksdXNlQmlhczp0aGlzLnVzZUJpYXMsa2VybmVsSW5pdGlhbGl6ZXI6RXQodGhpcy5rZXJuZWxJbml0aWFsaXplcikscmVjdXJyZW50SW5pdGlhbGl6ZXI6RXQodGhpcy5yZWN1cnJlbnRJbml0aWFsaXplciksYmlhc0luaXRpYWxpemVyOkV0KHRoaXMuYmlhc0luaXRpYWxpemVyKSxrZXJuZWxSZWd1bGFyaXplcjpmdCh0aGlzLmtlcm5lbFJlZ3VsYXJpemVyKSxyZWN1cnJlbnRSZWd1bGFyaXplcjpmdCh0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyKSxiaWFzUmVndWxhcml6ZXI6ZnQodGhpcy5iaWFzUmVndWxhcml6ZXIpLGFjdGl2aXR5UmVndWxhcml6ZXI6ZnQodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxrZXJuZWxDb25zdHJhaW50Olh0KHRoaXMua2VybmVsQ29uc3RyYWludCkscmVjdXJyZW50Q29uc3RyYWludDpYdCh0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLGJpYXNDb25zdHJhaW50Olh0KHRoaXMuYmlhc0NvbnN0cmFpbnQpLGRyb3BvdXQ6dGhpcy5kcm9wb3V0LHJlY3VycmVudERyb3BvdXQ6dGhpcy5yZWN1cnJlbnREcm9wb3V0LGltcGxlbWVudGF0aW9uOnRoaXMuaW1wbGVtZW50YXRpb24scmVzZXRBZnRlcjohMX07cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx0KX19O0RmLmNsYXNzTmFtZT1cIkdSVUNlbGxcIjtuZS5yZWdpc3RlckNsYXNzKERmKTt2YXIgTDA9Y2xhc3MgZXh0ZW5kcyBNcntjb25zdHJ1Y3RvcihlKXtlLmltcGxlbWVudGF0aW9uPT09MCYmY29uc29sZS53YXJuKFwiYGltcGxlbWVudGF0aW9uPTBgIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIGFuZCBub3cgZGVmYXVsdHMgdG8gYGltcGxlbWVudGF0aW9uPTFgLiBQbGVhc2UgdXBkYXRlIHlvdXIgbGF5ZXIgY2FsbC5cIiksZS5jZWxsPW5ldyBEZihlKSxzdXBlcihlKX1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9Pnt0aGlzLmNlbGwuZHJvcG91dE1hc2shPW51bGwmJihFZSh0aGlzLmNlbGwuZHJvcG91dE1hc2spLHRoaXMuY2VsbC5kcm9wb3V0TWFzaz1udWxsKSx0aGlzLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2shPW51bGwmJihFZSh0aGlzLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2spLHRoaXMuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzaz1udWxsKTtsZXQgbj10PT1udWxsP251bGw6dC5tYXNrLGE9dD09bnVsbD9udWxsOnQudHJhaW5pbmcscj10PT1udWxsP251bGw6dC5pbml0aWFsU3RhdGU7cmV0dXJuIHN1cGVyLmNhbGwoZSx7bWFzazpuLHRyYWluaW5nOmEsaW5pdGlhbFN0YXRlOnJ9KX0pfXN0YXRpYyBmcm9tQ29uZmlnKGUsdCl7cmV0dXJuIHQuaW1wbG1lbnRhdGlvbj09PTAmJih0LmltcGxlbWVudGF0aW9uPTEpLG5ldyBlKHQpfX07TDAuY2xhc3NOYW1lPVwiR1JVXCI7bmUucmVnaXN0ZXJDbGFzcyhMMCk7dmFyIENkPWNsYXNzIGV4dGVuZHMgVGR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksdGhpcy5ERUZBVUxUX0FDVElWQVRJT049XCJ0YW5oXCIsdGhpcy5ERUZBVUxUX1JFQ1VSUkVOVF9BQ1RJVkFUSU9OPVwiaGFyZFNpZ21vaWRcIix0aGlzLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSPVwiZ2xvcm90Tm9ybWFsXCIsdGhpcy5ERUZBVUxUX1JFQ1VSUkVOVF9JTklUSUFMSVpFUj1cIm9ydGhvZ29uYWxcIix0aGlzLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUj1cInplcm9zXCIsdGhpcy51bml0cz1lLnVuaXRzLHRuKHRoaXMudW5pdHMsXCJ1bml0c1wiKSx0aGlzLmFjdGl2YXRpb249ZnMoZS5hY3RpdmF0aW9uPT09dm9pZCAwP3RoaXMuREVGQVVMVF9BQ1RJVkFUSU9OOmUuYWN0aXZhdGlvbiksdGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uPWZzKGUucmVjdXJyZW50QWN0aXZhdGlvbj09PXZvaWQgMD90aGlzLkRFRkFVTFRfUkVDVVJSRU5UX0FDVElWQVRJT046ZS5yZWN1cnJlbnRBY3RpdmF0aW9uKSx0aGlzLnVzZUJpYXM9ZS51c2VCaWFzPT1udWxsPyEwOmUudXNlQmlhcyx0aGlzLmtlcm5lbEluaXRpYWxpemVyPVN0KGUua2VybmVsSW5pdGlhbGl6ZXJ8fHRoaXMuREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIpLHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXI9U3QoZS5yZWN1cnJlbnRJbml0aWFsaXplcnx8dGhpcy5ERUZBVUxUX1JFQ1VSUkVOVF9JTklUSUFMSVpFUiksdGhpcy5iaWFzSW5pdGlhbGl6ZXI9U3QoZS5iaWFzSW5pdGlhbGl6ZXJ8fHRoaXMuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSKSx0aGlzLnVuaXRGb3JnZXRCaWFzPWUudW5pdEZvcmdldEJpYXMsdGhpcy5rZXJuZWxSZWd1bGFyaXplcj1OdChlLmtlcm5lbFJlZ3VsYXJpemVyKSx0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyPU50KGUucmVjdXJyZW50UmVndWxhcml6ZXIpLHRoaXMuYmlhc1JlZ3VsYXJpemVyPU50KGUuYmlhc1JlZ3VsYXJpemVyKSx0aGlzLmtlcm5lbENvbnN0cmFpbnQ9WXQoZS5rZXJuZWxDb25zdHJhaW50KSx0aGlzLnJlY3VycmVudENvbnN0cmFpbnQ9WXQoZS5yZWN1cnJlbnRDb25zdHJhaW50KSx0aGlzLmJpYXNDb25zdHJhaW50PVl0KGUuYmlhc0NvbnN0cmFpbnQpLHRoaXMuZHJvcG91dD1VbChbMSxocyhbMCxlLmRyb3BvdXQ9PW51bGw/MDplLmRyb3BvdXRdKV0pLHRoaXMucmVjdXJyZW50RHJvcG91dD1VbChbMSxocyhbMCxlLnJlY3VycmVudERyb3BvdXQ9PW51bGw/MDplLnJlY3VycmVudERyb3BvdXRdKV0pLHRoaXMuZHJvcG91dEZ1bmM9ZS5kcm9wb3V0RnVuYyx0aGlzLmltcGxlbWVudGF0aW9uPWUuaW1wbGVtZW50YXRpb24sdGhpcy5zdGF0ZVNpemU9W3RoaXMudW5pdHMsdGhpcy51bml0c10sdGhpcy5kcm9wb3V0TWFzaz1udWxsLHRoaXMucmVjdXJyZW50RHJvcG91dE1hc2s9bnVsbH1idWlsZChlKXt2YXIgdDtlPUplKGUpO2xldCBuPWVbZS5sZW5ndGgtMV07dGhpcy5rZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJrZXJuZWxcIixbbix0aGlzLnVuaXRzKjRdLG51bGwsdGhpcy5rZXJuZWxJbml0aWFsaXplcix0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCEwLHRoaXMua2VybmVsQ29uc3RyYWludCksdGhpcy5yZWN1cnJlbnRLZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJyZWN1cnJlbnRfa2VybmVsXCIsW3RoaXMudW5pdHMsdGhpcy51bml0cyo0XSxudWxsLHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIsdGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciwhMCx0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpO2xldCBhO2lmKHRoaXMudXNlQmlhcyl7aWYodGhpcy51bml0Rm9yZ2V0Qmlhcyl7bGV0IHI9dGhpcy5iaWFzSW5pdGlhbGl6ZXIscz10aGlzLnVuaXRzO2E9bmV3KHQ9Y2xhc3MgZXh0ZW5kcyAkYXthcHBseShpLG8pe2xldCBsPXIuYXBwbHkoW3NdKSx1PW5ldyB5ZigpLmFwcGx5KFtzXSkscD1yLmFwcGx5KFtzKjJdKTtyZXR1cm4gYkkoYkkobCx1KSxwKX19LHQuY2xhc3NOYW1lPVwiQ3VzdG9tSW5pdFwiLHQpfWVsc2UgYT10aGlzLmJpYXNJbml0aWFsaXplcjt0aGlzLmJpYXM9dGhpcy5hZGRXZWlnaHQoXCJiaWFzXCIsW3RoaXMudW5pdHMqNF0sbnVsbCxhLHRoaXMuYmlhc1JlZ3VsYXJpemVyLCEwLHRoaXMuYmlhc0NvbnN0cmFpbnQpfWVsc2UgdGhpcy5iaWFzPW51bGw7dGhpcy5idWlsdD0hMH1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbj10LnRyYWluaW5nPT1udWxsPyExOnQudHJhaW5pbmc7aWYoZT1lLGUubGVuZ3RoIT09Myl0aHJvdyBuZXcgVihgTFNUTUNlbGwgZXhwZWN0cyAzIGlucHV0IFRlbnNvcnMgKGlucHV0cywgaCwgYyksIGdvdCAke2UubGVuZ3RofS5gKTtsZXQgYT1lWzFdLHI9ZVsyXTtlPWVbMF0sMDx0aGlzLmRyb3BvdXQmJnRoaXMuZHJvcG91dDwxJiZ0aGlzLmRyb3BvdXRNYXNrPT1udWxsJiYodGhpcy5kcm9wb3V0TWFzaz1ncyh7b25lczooKT0+ZWEoZSkscmF0ZTp0aGlzLmRyb3BvdXQsdHJhaW5pbmc6bixjb3VudDo0LGRyb3BvdXRGdW5jOnRoaXMuZHJvcG91dEZ1bmN9KSksMDx0aGlzLnJlY3VycmVudERyb3BvdXQmJnRoaXMucmVjdXJyZW50RHJvcG91dDwxJiZ0aGlzLnJlY3VycmVudERyb3BvdXRNYXNrPT1udWxsJiYodGhpcy5yZWN1cnJlbnREcm9wb3V0TWFzaz1ncyh7b25lczooKT0+ZWEoYSkscmF0ZTp0aGlzLnJlY3VycmVudERyb3BvdXQsdHJhaW5pbmc6bixjb3VudDo0LGRyb3BvdXRGdW5jOnRoaXMuZHJvcG91dEZ1bmN9KSk7bGV0IHM9dGhpcy5kcm9wb3V0TWFzayxpPXRoaXMucmVjdXJyZW50RHJvcG91dE1hc2ssbyxsLHUscDswPHRoaXMuZHJvcG91dCYmdGhpcy5kcm9wb3V0PDEmJihlPXooZSxzWzBdKSk7bGV0IGQ9b3IoZSx0aGlzLmtlcm5lbC5yZWFkKCkpOzA8dGhpcy5yZWN1cnJlbnREcm9wb3V0JiZ0aGlzLnJlY3VycmVudERyb3BvdXQ8MSYmKGE9eihhLGlbMF0pKSxkPVgoZCxvcihhLHRoaXMucmVjdXJyZW50S2VybmVsLnJlYWQoKSkpLHRoaXMudXNlQmlhcyYmKGQ9S2EoZCx0aGlzLmJpYXMucmVhZCgpKSk7bGV0W2MsaCxtLGZdPUxuKGQsNCxkLnJhbmstMSk7bz10aGlzLnJlY3VycmVudEFjdGl2YXRpb24uYXBwbHkoYyksbD10aGlzLnJlY3VycmVudEFjdGl2YXRpb24uYXBwbHkoaCksdT1YKHoobCxyKSx6KG8sdGhpcy5hY3RpdmF0aW9uLmFwcGx5KG0pKSkscD10aGlzLnJlY3VycmVudEFjdGl2YXRpb24uYXBwbHkoZik7bGV0IGc9eihwLHRoaXMuYWN0aXZhdGlvbi5hcHBseSh1KSk7cmV0dXJuW2csZyx1XX0pfWdldENvbmZpZygpe2xldCBlPXN1cGVyLmdldENvbmZpZygpLHQ9e3VuaXRzOnRoaXMudW5pdHMsYWN0aXZhdGlvbjptcyh0aGlzLmFjdGl2YXRpb24pLHJlY3VycmVudEFjdGl2YXRpb246bXModGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uKSx1c2VCaWFzOnRoaXMudXNlQmlhcyxrZXJuZWxJbml0aWFsaXplcjpFdCh0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxyZWN1cnJlbnRJbml0aWFsaXplcjpFdCh0aGlzLnJlY3VycmVudEluaXRpYWxpemVyKSxiaWFzSW5pdGlhbGl6ZXI6RXQodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLHVuaXRGb3JnZXRCaWFzOnRoaXMudW5pdEZvcmdldEJpYXMsa2VybmVsUmVndWxhcml6ZXI6ZnQodGhpcy5rZXJuZWxSZWd1bGFyaXplcikscmVjdXJyZW50UmVndWxhcml6ZXI6ZnQodGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciksYmlhc1JlZ3VsYXJpemVyOmZ0KHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOmZ0KHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksa2VybmVsQ29uc3RyYWludDpYdCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHJlY3VycmVudENvbnN0cmFpbnQ6WHQodGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KSxiaWFzQ29uc3RyYWludDpYdCh0aGlzLmJpYXNDb25zdHJhaW50KSxkcm9wb3V0OnRoaXMuZHJvcG91dCxyZWN1cnJlbnREcm9wb3V0OnRoaXMucmVjdXJyZW50RHJvcG91dCxpbXBsZW1lbnRhdGlvbjp0aGlzLmltcGxlbWVudGF0aW9ufTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHQpfX07Q2QuY2xhc3NOYW1lPVwiTFNUTUNlbGxcIjtuZS5yZWdpc3RlckNsYXNzKENkKTt2YXIgejA9Y2xhc3MgZXh0ZW5kcyBNcntjb25zdHJ1Y3RvcihlKXtlLmltcGxlbWVudGF0aW9uPT09MCYmY29uc29sZS53YXJuKFwiYGltcGxlbWVudGF0aW9uPTBgIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIGFuZCBub3cgZGVmYXVsdHMgdG8gYGltcGxlbWVudGF0aW9uPTFgLiBQbGVhc2UgdXBkYXRlIHlvdXIgbGF5ZXIgY2FsbC5cIiksZS5jZWxsPW5ldyBDZChlKSxzdXBlcihlKX1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9Pnt0aGlzLmNlbGwuZHJvcG91dE1hc2shPW51bGwmJihFZSh0aGlzLmNlbGwuZHJvcG91dE1hc2spLHRoaXMuY2VsbC5kcm9wb3V0TWFzaz1udWxsKSx0aGlzLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2shPW51bGwmJihFZSh0aGlzLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2spLHRoaXMuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzaz1udWxsKTtsZXQgbj10PT1udWxsP251bGw6dC5tYXNrLGE9dD09bnVsbD9udWxsOnQudHJhaW5pbmcscj10PT1udWxsP251bGw6dC5pbml0aWFsU3RhdGU7cmV0dXJuIHN1cGVyLmNhbGwoZSx7bWFzazpuLHRyYWluaW5nOmEsaW5pdGlhbFN0YXRlOnJ9KX0pfXN0YXRpYyBmcm9tQ29uZmlnKGUsdCl7cmV0dXJuIHQuaW1wbG1lbnRhdGlvbj09PTAmJih0LmltcGxlbWVudGF0aW9uPTEpLG5ldyBlKHQpfX07ejAuY2xhc3NOYW1lPVwiTFNUTVwiO25lLnJlZ2lzdGVyQ2xhc3MoejApO3ZhciBSZj1jbGFzcyBleHRlbmRzIFRke2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLHRoaXMuY2VsbHM9ZS5jZWxsc31nZXQgc3RhdGVTaXplKCl7bGV0IGU9W107Zm9yKGxldCB0IG9mIHRoaXMuY2VsbHMuc2xpY2UoKS5yZXZlcnNlKCkpQXJyYXkuaXNBcnJheSh0LnN0YXRlU2l6ZSk/ZS5wdXNoKC4uLnQuc3RhdGVTaXplKTplLnB1c2godC5zdGF0ZVNpemUpO3JldHVybiBlfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e2U9ZTtsZXQgbj1lLnNsaWNlKDEpLGE9W107Zm9yKGxldCBpIG9mIHRoaXMuY2VsbHMuc2xpY2UoKS5yZXZlcnNlKCkpQXJyYXkuaXNBcnJheShpLnN0YXRlU2l6ZSk/YS5wdXNoKG4uc3BsaWNlKDAsaS5zdGF0ZVNpemUubGVuZ3RoKSk6YS5wdXNoKG4uc3BsaWNlKDAsMSkpO2EucmV2ZXJzZSgpO2xldCByPVtdLHM7Zm9yKGxldCBpPTA7aTx0aGlzLmNlbGxzLmxlbmd0aDsrK2kpe2xldCBvPXRoaXMuY2VsbHNbaV07bj1hW2ldLGk9PT0wP3M9W2VbMF1dLmNvbmNhdChuKTpzPVtzWzBdXS5jb25jYXQobikscz1vLmNhbGwocyx0KSxyLnB1c2gocy5zbGljZSgxKSl9bj1bXTtmb3IobGV0IGkgb2Ygci5zbGljZSgpLnJldmVyc2UoKSluLnB1c2goLi4uaSk7cmV0dXJuW3NbMF1dLmNvbmNhdChuKX0pfWJ1aWxkKGUpe1Z4KGUpJiYoZT1lWzBdKSxlPWU7bGV0IHQ7dGhpcy5jZWxscy5mb3JFYWNoKChuLGEpPT57cmkoYFJOTkNlbGxfJHthfWAsKCk9PntuLmJ1aWxkKGUpLEFycmF5LmlzQXJyYXkobi5zdGF0ZVNpemUpP3Q9bi5zdGF0ZVNpemVbMF06dD1uLnN0YXRlU2l6ZSxlPVtlWzBdLHRdfSl9KSx0aGlzLmJ1aWx0PSEwfWdldENvbmZpZygpe2xldCBlPXN1cGVyLmdldENvbmZpZygpLHQ9YT0+KHtjbGFzc05hbWU6YS5nZXRDbGFzc05hbWUoKSxjb25maWc6YS5nZXRDb25maWcoKX0pLG49e2NlbGxzOnRoaXMuY2VsbHMubWFwKHQpfTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLG4pfXN0YXRpYyBmcm9tQ29uZmlnKGUsdCxuPXt9KXtsZXQgYT1bXTtmb3IobGV0IHIgb2YgdC5jZWxscylhLnB1c2goQmEocixuKSk7cmV0dXJuIG5ldyBlKHtjZWxsczphfSl9Z2V0IHRyYWluYWJsZVdlaWdodHMoKXtpZighdGhpcy50cmFpbmFibGUpcmV0dXJuW107bGV0IGU9W107Zm9yKGxldCB0IG9mIHRoaXMuY2VsbHMpZS5wdXNoKC4uLnQudHJhaW5hYmxlV2VpZ2h0cyk7cmV0dXJuIGV9Z2V0IG5vblRyYWluYWJsZVdlaWdodHMoKXtsZXQgZT1bXTtmb3IobGV0IHQgb2YgdGhpcy5jZWxscyllLnB1c2goLi4udC5ub25UcmFpbmFibGVXZWlnaHRzKTtpZighdGhpcy50cmFpbmFibGUpe2xldCB0PVtdO2ZvcihsZXQgbiBvZiB0aGlzLmNlbGxzKXQucHVzaCguLi5uLnRyYWluYWJsZVdlaWdodHMpO3JldHVybiB0LmNvbmNhdChlKX1yZXR1cm4gZX1nZXRXZWlnaHRzKCl7bGV0IGU9W107Zm9yKGxldCB0IG9mIHRoaXMuY2VsbHMpZS5wdXNoKC4uLnQud2VpZ2h0cyk7cmV0dXJuIFV4KGUpfXNldFdlaWdodHMoZSl7bGV0IHQ9W107Zm9yKGxldCBuIG9mIHRoaXMuY2VsbHMpe2xldCBhPW4ud2VpZ2h0cy5sZW5ndGgscj1lLnNwbGljZShhKTtmb3IobGV0IHM9MDtzPG4ud2VpZ2h0cy5sZW5ndGg7KytzKXQucHVzaChbbi53ZWlnaHRzW3NdLHJbc11dKX11MCh0KX19O1JmLmNsYXNzTmFtZT1cIlN0YWNrZWRSTk5DZWxsc1wiO25lLnJlZ2lzdGVyQ2xhc3MoUmYpO2Z1bmN0aW9uIGdzKGUpe2xldHtvbmVzOnQscmF0ZTpuLHRyYWluaW5nOmE9ITEsY291bnQ6cj0xLGRyb3BvdXRGdW5jOnN9PWUsaT0oKT0+cyE9bnVsbD9zKHQoKSxuKTp3Mih0KCksbiksbz0oKT0+SWQoaSx0LGEpO3JldHVybiFyfHxyPD0xP0h0KG8oKS5jbG9uZSgpKTpBcnJheShyKS5maWxsKHZvaWQgMCkubWFwKG8pLm1hcChsPT5IdChsLmNsb25lKCkpKX12YXIgeWo9ZnVuY3Rpb24oZSx0KXt2YXIgbj17fTtmb3IodmFyIGEgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxhKSYmdC5pbmRleE9mKGEpPDAmJihuW2FdPWVbYV0pO2lmKGUhPW51bGwmJnR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzPT1cImZ1bmN0aW9uXCIpZm9yKHZhciByPTAsYT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO3I8YS5sZW5ndGg7cisrKXQuaW5kZXhPZihhW3JdKTwwJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZSxhW3JdKSYmKG5bYVtyXV09ZVthW3JdXSk7cmV0dXJuIG59LHZDPWNsYXNzIGV4dGVuZHMgTXJ7Y29uc3RydWN0b3IoZSl7aWYoZS51bnJvbGwpdGhyb3cgbmV3IHplKFwiVW5yb2xsaW5nIGlzIG5vdCBwb3NzaWJsZSB3aXRoIGNvbnZvbHV0aW9uYWwgUk5Ocy5cIik7aWYoQXJyYXkuaXNBcnJheShlLmNlbGwpKXRocm93IG5ldyB6ZShcIkl0IGlzIG5vdCBwb3NzaWJsZSBhdCB0aGUgbW9tZW50IHRvIHN0YWNrIGNvbnZvbHV0aW9uYWwgY2VsbHMuXCIpO3N1cGVyKGUpLHRoaXMuaW5wdXRTcGVjPVtuZXcgenQoe25kaW06NX0pXX1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9PntpZih0aGlzLmNlbGwuZHJvcG91dE1hc2shPW51bGwmJihFZSh0aGlzLmNlbGwuZHJvcG91dE1hc2spLHRoaXMuY2VsbC5kcm9wb3V0TWFzaz1udWxsKSx0aGlzLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2shPW51bGwmJihFZSh0aGlzLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2spLHRoaXMuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzaz1udWxsKSx0JiZ0LmNvbnN0YW50cyl0aHJvdyBuZXcgVihcIkNvbnZSTk4yRCBjZWxsIGRvZXMgbm90IHN1cHBvcnQgY29uc3RhbnRzXCIpO2xldCBuPXQ9PW51bGw/bnVsbDp0Lm1hc2ssYT10PT1udWxsP251bGw6dC50cmFpbmluZyxyPXQ9PW51bGw/bnVsbDp0LmluaXRpYWxTdGF0ZTtyZXR1cm4gc3VwZXIuY2FsbChlLHttYXNrOm4sdHJhaW5pbmc6YSxpbml0aWFsU3RhdGU6cn0pfSl9Y29tcHV0ZU91dHB1dFNoYXBlKGUpe2xldCB0PXRoaXMuY29tcHV0ZVNpbmdsZU91dHB1dFNoYXBlKGUpO3JldHVybiB0aGlzLnJldHVyblNlcXVlbmNlc3x8KHQ9W3RbMF0sLi4udC5zbGljZSgyKV0pLHRoaXMucmV0dXJuU3RhdGUmJih0PVt0LC4uLkFycmF5KDIpLmZpbGwoW2VbMF0sLi4udC5zbGljZSgtMyldKV0pLHR9Z2V0SW5pdGlhbFN0YXRlKGUpe3JldHVybiBPKCgpPT57bGV0e3N0YXRlU2l6ZTp0fT10aGlzLmNlbGwsbj1lLnNoYXBlLGE9dGhpcy5jb21wdXRlU2luZ2xlT3V0cHV0U2hhcGUobikscj1bYVswXSwuLi5hLnNsaWNlKDIpXSxzPUl0KHIpO3JldHVybiBBcnJheS5pc0FycmF5KHQpP0FycmF5KHQubGVuZ3RoKS5maWxsKHMpOltzXX0pfXJlc2V0U3RhdGVzKGUsdD0hMSl7TygoKT0+e2lmKCF0aGlzLnN0YXRlZnVsKXRocm93IG5ldyBYcihcIkNhbm5vdCBjYWxsIHJlc2V0U3RhdGVzKCkgb24gYW4gUk5OIExheWVyIHRoYXQgaXMgbm90IHN0YXRlZnVsLlwiKTtsZXQgbj10aGlzLmlucHV0U3BlY1swXS5zaGFwZSxhPXRoaXMuY29tcHV0ZVNpbmdsZU91dHB1dFNoYXBlKG4pLHI9W2FbMF0sLi4uYS5zbGljZSgyKV07aWYoblswXT09bnVsbCl0aHJvdyBuZXcgVihcIklmIGFuIFJOTiBpcyBzdGF0ZWZ1bCwgaXQgbmVlZHMgdG8ga25vdyBpdHMgYmF0Y2ggc2l6ZS4gU3BlY2lmeSB0aGUgYmF0Y2ggc2l6ZSBvZiB5b3VyIGlucHV0IHRlbnNvcnM6IFxcbi0gSWYgdXNpbmcgYSBTZXF1ZW50aWFsIG1vZGVsLCBzcGVjaWZ5IHRoZSBiYXRjaCBzaXplIGJ5IHBhc3NpbmcgYSBgYmF0Y2hJbnB1dFNoYXBlYCBvcHRpb24gdG8geW91ciBmaXJzdCBsYXllci5cXG4tIElmIHVzaW5nIHRoZSBmdW5jdGlvbmFsIEFQSSwgc3BlY2lmeSB0aGUgYmF0Y2ggc2l6ZSBieSBwYXNzaW5nIGEgYGJhdGNoU2hhcGVgIG9wdGlvbiB0byB5b3VyIElucHV0IGxheWVyLlwiKTtpZih0aGlzLmdldFN0YXRlcygpPT1udWxsKUFycmF5LmlzQXJyYXkodGhpcy5jZWxsLnN0YXRlU2l6ZSk/dGhpcy5zdGF0ZXNfPXRoaXMuY2VsbC5zdGF0ZVNpemUubWFwKCgpPT5JdChyKSk6dGhpcy5zdGF0ZXNfPVtJdChyKV07ZWxzZSBpZihlPT1udWxsKUVlKHRoaXMuc3RhdGVzXyksdGhpcy5rZXB0U3RhdGVzIT1udWxsJiYoRWUodGhpcy5rZXB0U3RhdGVzKSx0aGlzLmtlcHRTdGF0ZXM9W10pLEFycmF5LmlzQXJyYXkodGhpcy5jZWxsLnN0YXRlU2l6ZSk/dGhpcy5zdGF0ZXNfPXRoaXMuY2VsbC5zdGF0ZVNpemUubWFwKCgpPT5JdChyKSk6dGhpcy5zdGF0ZXNfWzBdPUl0KHIpO2Vsc2V7aWYoQXJyYXkuaXNBcnJheShlKXx8KGU9W2VdKSxlLmxlbmd0aCE9PXRoaXMuc3RhdGVzXy5sZW5ndGgpdGhyb3cgbmV3IFYoYExheWVyICR7dGhpcy5uYW1lfSBleHBlY3RzICR7dGhpcy5zdGF0ZXNfLmxlbmd0aH0gc3RhdGUocyksIGJ1dCBpdCByZWNlaXZlZCAke2UubGVuZ3RofSBzdGF0ZSB2YWx1ZShzKS4gSW5wdXQgcmVjZWl2ZWQ6ICR7ZX1gKTt0P3RoaXMua2VwdFN0YXRlcy5wdXNoKHRoaXMuc3RhdGVzXy5zbGljZSgpKTpFZSh0aGlzLnN0YXRlc18pO2ZvcihsZXQgcz0wO3M8dGhpcy5zdGF0ZXNfLmxlbmd0aDsrK3Mpe2xldCBpPWVbc10sbz1yO2lmKCF3LmFycmF5c0VxdWFsKGkuc2hhcGUsbykpdGhyb3cgbmV3IFYoYFN0YXRlICR7c30gaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgJHt0aGlzLm5hbWV9OiBleHBlY3RlZCBzaGFwZT0ke299LCByZWNlaXZlZCBzaGFwZT0ke2kuc2hhcGV9YCk7dGhpcy5zdGF0ZXNfW3NdPWl9fXRoaXMuc3RhdGVzXz10aGlzLnN0YXRlc18ubWFwKHM9Pkh0KHMuY2xvbmUoKSkpfSl9Y29tcHV0ZVNpbmdsZU91dHB1dFNoYXBlKGUpe2xldHtkYXRhRm9ybWF0OnQsZmlsdGVyczpuLGtlcm5lbFNpemU6YSxwYWRkaW5nOnIsc3RyaWRlczpzLGRpbGF0aW9uUmF0ZTppfT10aGlzLmNlbGwsbz10PT09XCJjaGFubmVsc0ZpcnN0XCIsbD1lW28/MzoyXSx1PWVbbz80OjNdLHA9VmEobCxhWzBdLHIsc1swXSxpWzBdKSxkPVZhKHUsYVsxXSxyLHNbMV0saVsxXSk7cmV0dXJuWy4uLmUuc2xpY2UoMCwyKSwuLi5vP1tuLHAsZF06W3AsZCxuXV19fTt2Qy5jbGFzc05hbWU9XCJDb252Uk5OMkRcIjt2YXIgTWY9Y2xhc3MgZXh0ZW5kcyBDZHtjb25zdHJ1Y3RvcihlKXtsZXR7ZmlsdGVyczp0LGtlcm5lbFNpemU6bixzdHJpZGVzOmEscGFkZGluZzpyLGRhdGFGb3JtYXQ6cyxkaWxhdGlvblJhdGU6aX09ZTtzdXBlcihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse3VuaXRzOnR9KSksdGhpcy5maWx0ZXJzPXQsdG4odGhpcy5maWx0ZXJzLFwiZmlsdGVyc1wiKSx0aGlzLmtlcm5lbFNpemU9RmwobiwyLFwia2VybmVsU2l6ZVwiKSx0aGlzLmtlcm5lbFNpemUuZm9yRWFjaChvPT50bihvLFwia2VybmVsU2l6ZVwiKSksdGhpcy5zdHJpZGVzPUZsKGF8fDEsMixcInN0cmlkZXNcIiksdGhpcy5zdHJpZGVzLmZvckVhY2gobz0+dG4obyxcInN0cmlkZXNcIikpLHRoaXMucGFkZGluZz1yfHxcInZhbGlkXCIsdmEodGhpcy5wYWRkaW5nKSx0aGlzLmRhdGFGb3JtYXQ9c3x8XCJjaGFubmVsc0xhc3RcIixSdCh0aGlzLmRhdGFGb3JtYXQpLHRoaXMuZGlsYXRpb25SYXRlPUZsKGl8fDEsMixcImRpbGF0aW9uUmF0ZVwiKSx0aGlzLmRpbGF0aW9uUmF0ZS5mb3JFYWNoKG89PnRuKG8sXCJkaWxhdGlvblJhdGVcIikpfWJ1aWxkKGUpe3ZhciB0O2U9SmUoZSk7bGV0IG49dGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCI/MTplLmxlbmd0aC0xO2lmKGVbbl09PW51bGwpdGhyb3cgbmV3IFYoYFRoZSBjaGFubmVsIGRpbWVuc2lvbiBvZiB0aGUgaW5wdXQgc2hvdWxkIGJlIGRlZmluZWQuIEZvdW5kICR7ZVtuXX1gKTtsZXQgYT1lW25dLHI9NCxzPXRoaXMua2VybmVsU2l6ZS5jb25jYXQoW2EsdGhpcy5maWx0ZXJzKnJdKTt0aGlzLmtlcm5lbD10aGlzLmFkZFdlaWdodChcImtlcm5lbFwiLHMsbnVsbCx0aGlzLmtlcm5lbEluaXRpYWxpemVyLHRoaXMua2VybmVsUmVndWxhcml6ZXIsITAsdGhpcy5rZXJuZWxDb25zdHJhaW50KTtsZXQgaT10aGlzLmtlcm5lbFNpemUuY29uY2F0KFt0aGlzLmZpbHRlcnMsdGhpcy5maWx0ZXJzKnJdKTtpZih0aGlzLnJlY3VycmVudEtlcm5lbD10aGlzLmFkZFdlaWdodChcInJlY3VycmVudF9rZXJuZWxcIixpLG51bGwsdGhpcy5yZWN1cnJlbnRJbml0aWFsaXplcix0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyLCEwLHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksdGhpcy51c2VCaWFzKXtsZXQgbztpZih0aGlzLnVuaXRGb3JnZXRCaWFzKXtsZXQgbD10aGlzLmJpYXNJbml0aWFsaXplcix1PXRoaXMuZmlsdGVycztvPW5ldyh0PWNsYXNzIGV4dGVuZHMgJGF7YXBwbHkocCxkKXtsZXQgYz1sLmFwcGx5KFt1XSksaD1QbihbdV0pLG09bC5hcHBseShbdSoyXSk7cmV0dXJuIHQwKFtjLGgsbV0pfX0sdC5jbGFzc05hbWU9XCJDdXN0b21Jbml0XCIsdCl9ZWxzZSBvPXRoaXMuYmlhc0luaXRpYWxpemVyO3RoaXMuYmlhcz10aGlzLmFkZFdlaWdodChcImJpYXNcIixbdGhpcy5maWx0ZXJzKnJdLG51bGwsbyx0aGlzLmJpYXNSZWd1bGFyaXplciwhMCx0aGlzLmJpYXNDb25zdHJhaW50KX10aGlzLmJ1aWx0PSEwfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e2lmKGUubGVuZ3RoIT09Myl0aHJvdyBuZXcgVihgQ29udkxTVE0yRENlbGwgZXhwZWN0cyAzIGlucHV0IFRlbnNvcnMgKGlucHV0cywgaCwgYyksIGdvdCAke2UubGVuZ3RofS5gKTtsZXQgbj10LnRyYWluaW5nfHwhMSxhPWVbMF0scj1lWzFdLHM9ZVsyXSxpPTQ7MDx0aGlzLmRyb3BvdXQmJnRoaXMuZHJvcG91dDwxJiZ0aGlzLmRyb3BvdXRNYXNrPT1udWxsJiYodGhpcy5kcm9wb3V0TWFzaz1ncyh7b25lczooKT0+ZWEoYSkscmF0ZTp0aGlzLmRyb3BvdXQsdHJhaW5pbmc6bixjb3VudDppLGRyb3BvdXRGdW5jOnRoaXMuZHJvcG91dEZ1bmN9KSk7bGV0IG89dGhpcy5kcm9wb3V0TWFzayxsPShaLEosZWUpPT4hSnx8IUpbZWVdP1o6eihKW2VlXSxaKSx1PWwoYSxvLDApLHA9bChhLG8sMSksZD1sKGEsbywyKSxjPWwoYSxvLDMpOzA8dGhpcy5yZWN1cnJlbnREcm9wb3V0JiZ0aGlzLnJlY3VycmVudERyb3BvdXQ8MSYmdGhpcy5yZWN1cnJlbnREcm9wb3V0TWFzaz09bnVsbCYmKHRoaXMucmVjdXJyZW50RHJvcG91dE1hc2s9Z3Moe29uZXM6KCk9PmVhKHIpLHJhdGU6dGhpcy5yZWN1cnJlbnREcm9wb3V0LHRyYWluaW5nOm4sY291bnQ6aSxkcm9wb3V0RnVuYzp0aGlzLmRyb3BvdXRGdW5jfSkpO2xldCBoPXRoaXMucmVjdXJyZW50RHJvcG91dE1hc2ssbT1sKHIsaCwwKSxmPWwocixoLDEpLGc9bChyLGgsMiksYj1sKHIsaCwzKSx5PTMsW3gsdixJLE5dPUxuKHRoaXMua2VybmVsLnJlYWQoKSxpLHkpLFtDLF8sRixEXT10aGlzLnVzZUJpYXM/TG4odGhpcy5iaWFzLnJlYWQoKSxpKTpbbnVsbCxudWxsLG51bGwsbnVsbF07dT10aGlzLmlucHV0Q29udih1LHgsQyx0aGlzLnBhZGRpbmcpLHA9dGhpcy5pbnB1dENvbnYocCx2LF8sdGhpcy5wYWRkaW5nKSxkPXRoaXMuaW5wdXRDb252KGQsSSxGLHRoaXMucGFkZGluZyksYz10aGlzLmlucHV0Q29udihjLE4sRCx0aGlzLnBhZGRpbmcpO2xldFskLFMsTSxCXT1Mbih0aGlzLnJlY3VycmVudEtlcm5lbC5yZWFkKCksaSx5KTttPXRoaXMucmVjdXJyZW50Q29udihtLCQpLGY9dGhpcy5yZWN1cnJlbnRDb252KGYsUyksZz10aGlzLnJlY3VycmVudENvbnYoZyxNKSxiPXRoaXMucmVjdXJyZW50Q29udihiLEIpO2xldCBVPXRoaXMucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseShYKHUsbSkpLEg9dGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KFgocCxmKSkscT1YKHooSCxzKSx6KFUsdGhpcy5hY3RpdmF0aW9uLmFwcGx5KFgoZCxnKSkpKSxLPXoodGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KFgoYyxiKSksdGhpcy5hY3RpdmF0aW9uLmFwcGx5KHEpKTtyZXR1cm5bSyxLLHFdfSl9Z2V0Q29uZmlnKCl7bGV0IGU9c3VwZXIuZ2V0Q29uZmlnKCkse3VuaXRzOnR9PWUsbj15aihlLFtcInVuaXRzXCJdKSxhPXtmaWx0ZXJzOnRoaXMuZmlsdGVycyxrZXJuZWxTaXplOnRoaXMua2VybmVsU2l6ZSxwYWRkaW5nOnRoaXMucGFkZGluZyxkYXRhRm9ybWF0OnRoaXMuZGF0YUZvcm1hdCxkaWxhdGlvblJhdGU6dGhpcy5kaWxhdGlvblJhdGUsc3RyaWRlczp0aGlzLnN0cmlkZXN9O3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbiksYSl9aW5wdXRDb252KGUsdCxuLGEpe2xldCByPSR0KGUsdCx0aGlzLnN0cmlkZXMsYXx8XCJ2YWxpZFwiLHRoaXMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNGaXJzdFwiP1wiTkNIV1wiOlwiTkhXQ1wiLHRoaXMuZGlsYXRpb25SYXRlKTtyZXR1cm4gbj9LYShyLG4sdGhpcy5kYXRhRm9ybWF0KTpyfXJlY3VycmVudENvbnYoZSx0KXtyZXR1cm4gJHQoZSx0LDEsXCJzYW1lXCIsdGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCI/XCJOQ0hXXCI6XCJOSFdDXCIpfX07TWYuY2xhc3NOYW1lPVwiQ29udkxTVE0yRENlbGxcIjtuZS5yZWdpc3RlckNsYXNzKE1mKTt2YXIgVzA9Y2xhc3MgZXh0ZW5kcyB2Q3tjb25zdHJ1Y3RvcihlKXtsZXQgdD1uZXcgTWYoZSk7c3VwZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtjZWxsOnR9KSl9c3RhdGljIGZyb21Db25maWcoZSx0KXtyZXR1cm4gbmV3IGUodCl9fTtXMC5jbGFzc05hbWU9XCJDb252TFNUTTJEXCI7bmUucmVnaXN0ZXJDbGFzcyhXMCk7dmFyIE9mPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksdGhpcy5yYXRlPU1hdGgubWF4KE1hdGgubWluKGUucmF0ZSwxKSwwKSx0aGlzLm5vaXNlU2hhcGU9ZS5ub2lzZVNoYXBlLHRoaXMuc2VlZD1lLnNlZWQsdGhpcy5zdXBwb3J0c01hc2tpbmc9ITB9Z2V0Tm9pc2VTaGFwZShlKXtpZih0aGlzLm5vaXNlU2hhcGU9PW51bGwpcmV0dXJuIHRoaXMubm9pc2VTaGFwZTtsZXQgdD1lLnNoYXBlLG49W107Zm9yKGxldCBhPTA7YTx0aGlzLm5vaXNlU2hhcGUubGVuZ3RoOysrYSluLnB1c2godGhpcy5ub2lzZVNoYXBlW2FdPT1udWxsP3RbYV06dGhpcy5ub2lzZVNoYXBlW2FdKTtyZXR1cm4gbn1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9Pnt0aGlzLmludm9rZUNhbGxIb29rKGUsdCk7bGV0IG49VGUoZSk7aWYoMDx0aGlzLnJhdGUmJnRoaXMucmF0ZTwxKXtsZXQgYT10LnRyYWluaW5nPT1udWxsPyExOnQudHJhaW5pbmcscj10aGlzLmdldE5vaXNlU2hhcGUobik7cmV0dXJuIElkKCgpPT53MihuLHRoaXMucmF0ZSxyLHRoaXMuc2VlZCksKCk9Pm4sYSl9cmV0dXJuIGV9KX1nZXRDb25maWcoKXtsZXQgZT17cmF0ZTp0aGlzLnJhdGUsbm9pc2VTaGFwZTp0aGlzLm5vaXNlU2hhcGUsc2VlZDp0aGlzLnNlZWR9LHQ9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfWRpc3Bvc2UoKXtyZXR1cm4gc3VwZXIuZGlzcG9zZSgpfX07T2YuY2xhc3NOYW1lPVwiRHJvcG91dFwiO25lLnJlZ2lzdGVyQ2xhc3MoT2YpO3ZhciBCMD1jbGFzcyBleHRlbmRzIE9me2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLHRoaXMuaW5wdXRTcGVjPVt7bmRpbTozfV19Z2V0Tm9pc2VTaGFwZShlKXtsZXQgdD1lLnNoYXBlO3JldHVyblt0WzBdLDEsdFsyXV19fTtCMC5jbGFzc05hbWU9XCJTcGF0aWFsRHJvcG91dDFEXCI7bmUucmVnaXN0ZXJDbGFzcyhCMCk7dmFyIFYwPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7aWYoc3VwZXIoZSksdGhpcy5hY3RpdmF0aW9uPW51bGwsdGhpcy51c2VCaWFzPSEwLHRoaXMua2VybmVsPW51bGwsdGhpcy5iaWFzPW51bGwsdGhpcy5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUj1cImdsb3JvdE5vcm1hbFwiLHRoaXMuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSPVwiemVyb3NcIixlLmJhdGNoSW5wdXRTaGFwZT09bnVsbCYmZS5pbnB1dFNoYXBlPT1udWxsJiZlLmlucHV0RGltIT1udWxsKXtsZXQgdD1udWxsO2UuYmF0Y2hTaXplIT1udWxsJiYodD1lLmJhdGNoU2l6ZSksdGhpcy5iYXRjaElucHV0U2hhcGU9W3QsZS5pbnB1dERpbV19dGhpcy51bml0cz1lLnVuaXRzLHRuKHRoaXMudW5pdHMsXCJ1bml0c1wiKSx0aGlzLmFjdGl2YXRpb249ZnMoZS5hY3RpdmF0aW9uKSxlLnVzZUJpYXMhPW51bGwmJih0aGlzLnVzZUJpYXM9ZS51c2VCaWFzKSx0aGlzLmtlcm5lbEluaXRpYWxpemVyPVN0KGUua2VybmVsSW5pdGlhbGl6ZXJ8fHRoaXMuREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIpLHRoaXMuYmlhc0luaXRpYWxpemVyPVN0KGUuYmlhc0luaXRpYWxpemVyfHx0aGlzLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUiksdGhpcy5rZXJuZWxDb25zdHJhaW50PVl0KGUua2VybmVsQ29uc3RyYWludCksdGhpcy5iaWFzQ29uc3RyYWludD1ZdChlLmJpYXNDb25zdHJhaW50KSx0aGlzLmtlcm5lbFJlZ3VsYXJpemVyPU50KGUua2VybmVsUmVndWxhcml6ZXIpLHRoaXMuYmlhc1JlZ3VsYXJpemVyPU50KGUuYmlhc1JlZ3VsYXJpemVyKSx0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXI9TnQoZS5hY3Rpdml0eVJlZ3VsYXJpemVyKSx0aGlzLnN1cHBvcnRzTWFza2luZz0hMCx0aGlzLmlucHV0U3BlYz1be21pbk5EaW06Mn1dfWJ1aWxkKGUpe2U9SmUoZSk7bGV0IHQ9ZVtlLmxlbmd0aC0xXTt0aGlzLmtlcm5lbD09bnVsbCYmKHRoaXMua2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwia2VybmVsXCIsW3QsdGhpcy51bml0c10sbnVsbCx0aGlzLmtlcm5lbEluaXRpYWxpemVyLHRoaXMua2VybmVsUmVndWxhcml6ZXIsITAsdGhpcy5rZXJuZWxDb25zdHJhaW50KSx0aGlzLnVzZUJpYXMmJih0aGlzLmJpYXM9dGhpcy5hZGRXZWlnaHQoXCJiaWFzXCIsW3RoaXMudW5pdHNdLG51bGwsdGhpcy5iaWFzSW5pdGlhbGl6ZXIsdGhpcy5iaWFzUmVndWxhcml6ZXIsITAsdGhpcy5iaWFzQ29uc3RyYWludCkpKSx0aGlzLmlucHV0U3BlYz1be21pbk5EaW06MixheGVzOntbLTFdOnR9fV0sdGhpcy5idWlsdD0hMH1jb21wdXRlT3V0cHV0U2hhcGUoZSl7ZT1KZShlKTtsZXQgdD1lLnNsaWNlKCk7cmV0dXJuIHRbdC5sZW5ndGgtMV09dGhpcy51bml0cyx0fWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e3RoaXMuaW52b2tlQ2FsbEhvb2soZSx0KTtsZXQgbj1UZShlKSxhPW0yKHRoaXMuYWN0aXZhdGlvbi5nZXRDbGFzc05hbWUoKSkscjtyZXR1cm4gYSE9bnVsbD9yPW9yKG4sdGhpcy5rZXJuZWwucmVhZCgpLGEsdGhpcy5iaWFzP3RoaXMuYmlhcy5yZWFkKCk6bnVsbCk6KHI9b3Iobix0aGlzLmtlcm5lbC5yZWFkKCkpLHRoaXMuYmlhcyE9bnVsbCYmKHI9S2Eocix0aGlzLmJpYXMucmVhZCgpKSksdGhpcy5hY3RpdmF0aW9uIT1udWxsJiYocj10aGlzLmFjdGl2YXRpb24uYXBwbHkocikpKSxyfSl9Z2V0Q29uZmlnKCl7bGV0IGU9e3VuaXRzOnRoaXMudW5pdHMsYWN0aXZhdGlvbjptcyh0aGlzLmFjdGl2YXRpb24pLHVzZUJpYXM6dGhpcy51c2VCaWFzLGtlcm5lbEluaXRpYWxpemVyOkV0KHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLGJpYXNJbml0aWFsaXplcjpFdCh0aGlzLmJpYXNJbml0aWFsaXplciksa2VybmVsUmVndWxhcml6ZXI6ZnQodGhpcy5rZXJuZWxSZWd1bGFyaXplciksYmlhc1JlZ3VsYXJpemVyOmZ0KHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOmZ0KHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksa2VybmVsQ29uc3RyYWludDpYdCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpLGJpYXNDb25zdHJhaW50Olh0KHRoaXMuYmlhc0NvbnN0cmFpbnQpfSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX19O1YwLmNsYXNzTmFtZT1cIkRlbnNlXCI7bmUucmVnaXN0ZXJDbGFzcyhWMCk7dmFyIFUwPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7ZT1lfHx7fSxzdXBlcihlKSx0aGlzLmlucHV0U3BlYz1be21pbk5EaW06M31dLHRoaXMuZGF0YUZvcm1hdD1lLmRhdGFGb3JtYXR9Y29tcHV0ZU91dHB1dFNoYXBlKGUpe2U9SmUoZSk7Zm9yKGxldCB0IG9mIGUuc2xpY2UoMSkpaWYodD09bnVsbCl0aHJvdyBuZXcgVihgVGhlIHNoYXBlIG9mIHRoZSBpbnB1dCB0byBcIkZsYXR0ZW5cIiBpcyBub3QgZnVsbHkgZGVmaW5lZCAoZ290ICR7ZS5zbGljZSgxKX0pLiBNYWtlIHN1cmUgdG8gcGFzcyBhIGNvbXBsZXRlIFwiaW5wdXRfc2hhcGVcIiBvciBcImJhdGNoX2lucHV0X3NoYXBlXCIgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGxheWVyIGluIHlvdXIgbW9kZWwuYCk7cmV0dXJuW2VbMF0scnMoZSwxKV19Y2FsbChlLHQpe3JldHVybiBPKCgpPT57dGhpcy5pbnZva2VDYWxsSG9vayhlLHQpO2xldCBuPVRlKGUpO2lmKHRoaXMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNGaXJzdFwiJiZuLnJhbms+MSl7bGV0IGE9WzBdO2ZvcihsZXQgcj0yO3I8bi5yYW5rOysrcilhLnB1c2gocik7YS5wdXNoKDEpLG49RGUobixhKX1yZXR1cm4gQUcobil9KX1nZXRDb25maWcoKXtsZXQgZT17fTt0aGlzLmRhdGFGb3JtYXQhPW51bGwmJihlLmRhdGFGb3JtYXQ9dGhpcy5kYXRhRm9ybWF0KTtsZXQgdD1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9fTtVMC5jbGFzc05hbWU9XCJGbGF0dGVuXCI7bmUucmVnaXN0ZXJDbGFzcyhVMCk7dmFyIEcwPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksdGhpcy5zdXBwb3J0c01hc2tpbmc9ITAsdGhpcy5hY3RpdmF0aW9uPWZzKGUuYWN0aXZhdGlvbil9Y2FsbChlLHQpe3JldHVybiBPKCgpPT57dGhpcy5pbnZva2VDYWxsSG9vayhlLHQpO2xldCBuPVRlKGUpO3JldHVybiB0aGlzLmFjdGl2YXRpb24uYXBwbHkobil9KX1nZXRDb25maWcoKXtsZXQgZT17YWN0aXZhdGlvbjptcyh0aGlzLmFjdGl2YXRpb24pfSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX19O0cwLmNsYXNzTmFtZT1cIkFjdGl2YXRpb25cIjtuZS5yZWdpc3RlckNsYXNzKEcwKTt2YXIgSDA9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLm49ZS5uLHRoaXMuaW5wdXRTcGVjPVt7bmRpbToyfV19Y29tcHV0ZU91dHB1dFNoYXBlKGUpe3JldHVybltlWzBdLHRoaXMubixlWzFdXX1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9PihlPVRlKGUpLEVHKGUsdGhpcy5uKSkpfWdldENvbmZpZygpe2xldCBlPXtuOnRoaXMubn0sdD1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9fTtIMC5jbGFzc05hbWU9XCJSZXBlYXRWZWN0b3JcIjtuZS5yZWdpc3RlckNsYXNzKEgwKTt2YXIgajA9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLnRhcmdldFNoYXBlPWUudGFyZ2V0U2hhcGU7Zm9yKGxldCB0PTA7dDx0aGlzLnRhcmdldFNoYXBlLmxlbmd0aDsrK3QpdGhpcy5pc1Vua25vd24odGhpcy50YXJnZXRTaGFwZVt0XSkmJih0aGlzLnRhcmdldFNoYXBlW3RdPW51bGwpfWlzVW5rbm93bihlKXtyZXR1cm4gZTwwfHxlPT1udWxsfWZpeFVua25vd25EaW1lbnNpb24oZSx0KXtsZXQgbj1cIlRvdGFsIHNpemUgb2YgbmV3IGFycmF5IG11c3QgYmUgdW5jaGFuZ2VkLlwiLGE9dC5zbGljZSgpLHI9MSxzPW51bGw7Zm9yKGxldCBvPTA7bzxhLmxlbmd0aDsrK28pe2xldCBsPWFbb107aWYodGhpcy5pc1Vua25vd24obCkpaWYocz09PW51bGwpcz1vO2Vsc2UgdGhyb3cgbmV3IFYoXCJDYW4gb25seSBzcGVjaWZpeSBvbmUgdW5rbm93biBkaW1lbnNpb24uXCIpO2Vsc2Ugcio9bH1sZXQgaT1ycyhlKTtpZihzIT09bnVsbCl7aWYocj09PTB8fGklciE9PTApdGhyb3cgbmV3IFYobik7YVtzXT1pL3J9ZWxzZSBpZihpIT09cil0aHJvdyBuZXcgVihuKTtyZXR1cm4gYX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7bGV0IHQ9ITE7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDsrK24paWYodGhpcy5pc1Vua25vd24oZVtuXSkpe3Q9ITA7YnJlYWt9cmV0dXJuIHQ/ZS5zbGljZSgwLDEpLmNvbmNhdCh0aGlzLnRhcmdldFNoYXBlKTplLnNsaWNlKDAsMSkuY29uY2F0KHRoaXMuZml4VW5rbm93bkRpbWVuc2lvbihlLnNsaWNlKDEpLHRoaXMudGFyZ2V0U2hhcGUpKX1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9Pnt0aGlzLmludm9rZUNhbGxIb29rKGUsdCk7bGV0IG49VGUoZSksYT1uLnNoYXBlLHI9YS5zbGljZSgwLDEpLmNvbmNhdCh0aGlzLmZpeFVua25vd25EaW1lbnNpb24oYS5zbGljZSgxKSx0aGlzLnRhcmdldFNoYXBlKSk7cmV0dXJuIFcobixyKX0pfWdldENvbmZpZygpe2xldCBlPXt0YXJnZXRTaGFwZTp0aGlzLnRhcmdldFNoYXBlfSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX19O2owLmNsYXNzTmFtZT1cIlJlc2hhcGVcIjtuZS5yZWdpc3RlckNsYXNzKGowKTt2YXIgcTA9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtpZihzdXBlcihlKSxlLmRpbXM9PW51bGwpdGhyb3cgbmV3IEVycm9yKFwiUmVxdWlyZWQgY29uZmlndXJhdGlvbiBmaWVsZCBgZGltc2AgaXMgbWlzc2luZyBkdXJpbmcgUGVybXV0ZSBjb25zdHJ1Y3RvciBjYWxsLlwiKTtpZighQXJyYXkuaXNBcnJheShlLmRpbXMpKXRocm93IG5ldyBFcnJvcihgUGVybXV0ZSBjb25zdHJ1Y3RvciByZXF1aXJlcyBcXGBkaW1zXFxgIHRvIGJlIGFuIEFycmF5LCBidXQgcmVjZWl2ZWQgJHtlLmRpbXN9IGluc3RlYWQuYCk7bGV0IHQ9VWEoMSxlLmRpbXMubGVuZ3RoKzEpO2lmKCF3LmFycmF5c0VxdWFsKGUuZGltcy5zbGljZSgpLnNvcnQoKSx0KSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBlcm11dGF0aW9uIGBkaW1zYDogXCIrSlNPTi5zdHJpbmdpZnkoZS5kaW1zKStcIiBgZGltc2AgbXVzdCBjb250YWluIGNvbnNlY3V0aXZlIGludGVnZXJzIHN0YXJ0aW5nIGZyb20gMS5cIik7dGhpcy5kaW1zPWUuZGltcyx0aGlzLmRpbXNJbmNsdWRpbmdCYXRjaD1bMF0uY29uY2F0KHRoaXMuZGltcyksdGhpcy5pbnB1dFNwZWM9W25ldyB6dCh7bmRpbTp0aGlzLmRpbXMubGVuZ3RoKzF9KV19Y29tcHV0ZU91dHB1dFNoYXBlKGUpe2U9SmUoZSk7bGV0IHQ9ZS5zbGljZSgpO3JldHVybiB0aGlzLmRpbXMuZm9yRWFjaCgobixhKT0+e3RbYSsxXT1lW25dfSksdH1jYWxsKGUsdCl7cmV0dXJuIERlKFRlKGUpLHRoaXMuZGltc0luY2x1ZGluZ0JhdGNoKX1nZXRDb25maWcoKXtsZXQgZT17ZGltczp0aGlzLmRpbXN9LHQ9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfX07cTAuY2xhc3NOYW1lPVwiUGVybXV0ZVwiO25lLnJlZ2lzdGVyQ2xhc3MocTApO3ZhciBLMD1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe3N1cGVyKGU9PW51bGw/e306ZSksdGhpcy5zdXBwb3J0c01hc2tpbmc9ITAsZSE9bnVsbD90aGlzLm1hc2tWYWx1ZT1lLm1hc2tWYWx1ZT09bnVsbD8wOmUubWFza1ZhbHVlOnRoaXMubWFza1ZhbHVlPTB9Y29tcHV0ZU91dHB1dFNoYXBlKGUpe3JldHVybiBlfWdldENvbmZpZygpe2xldCBlPXN1cGVyLmdldENvbmZpZygpLHQ9e21hc2tWYWx1ZTp0aGlzLm1hc2tWYWx1ZX07cmV0dXJuIE9iamVjdC5hc3NpZ24odCxlKSx0fWNvbXB1dGVNYXNrKGUsdCl7bGV0IG49VGUoZSk7cmV0dXJuIHljKGZpKG4sdGhpcy5tYXNrVmFsdWUpLC0xKX1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9Pnt0aGlzLmludm9rZUNhbGxIb29rKGUsdCk7bGV0IG49VGUoZSksYT15YyhmaShuLHRoaXMubWFza1ZhbHVlKSwtMSwhMCk7cmV0dXJuIHoobixyZShhLG4uZHR5cGUpKX0pfX07SzAuY2xhc3NOYW1lPVwiTWFza2luZ1wiO25lLnJlZ2lzdGVyQ2xhc3MoSzApO3ZhciBYMD1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe2lmKHN1cGVyKGUpLHRoaXMuZW1iZWRkaW5ncz1udWxsLHRoaXMuREVGQVVMVF9FTUJFRERJTkdTX0lOSVRJQUxJWkVSPVwicmFuZG9tVW5pZm9ybVwiLGUuYmF0Y2hJbnB1dFNoYXBlPT1udWxsJiZlLmlucHV0U2hhcGU9PW51bGwpe2xldCB0PW51bGw7ZS5iYXRjaFNpemUhPW51bGwmJih0PWUuYmF0Y2hTaXplKSxlLmlucHV0TGVuZ3RoPT1udWxsP3RoaXMuYmF0Y2hJbnB1dFNoYXBlPVt0LG51bGxdOnRoaXMuYmF0Y2hJbnB1dFNoYXBlPVt0XS5jb25jYXQoaXQoZS5pbnB1dExlbmd0aCkpfXRoaXMuaW5wdXREaW09ZS5pbnB1dERpbSx0bih0aGlzLmlucHV0RGltLFwiaW5wdXREaW1cIiksdGhpcy5vdXRwdXREaW09ZS5vdXRwdXREaW0sdG4odGhpcy5vdXRwdXREaW0sXCJvdXRwdXREaW1cIiksdGhpcy5lbWJlZGRpbmdzSW5pdGlhbGl6ZXI9U3QoZS5lbWJlZGRpbmdzSW5pdGlhbGl6ZXJ8fHRoaXMuREVGQVVMVF9FTUJFRERJTkdTX0lOSVRJQUxJWkVSKSx0aGlzLmVtYmVkZGluZ3NSZWd1bGFyaXplcj1OdChlLmVtYmVkZGluZ3NSZWd1bGFyaXplciksdGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyPU50KGUuYWN0aXZpdHlSZWd1bGFyaXplciksdGhpcy5lbWJlZGRpbmdzQ29uc3RyYWludD1ZdChlLmVtYmVkZGluZ3NDb25zdHJhaW50KSx0aGlzLm1hc2taZXJvPWUubWFza1plcm8sdGhpcy5zdXBwb3J0c01hc2tpbmc9ZS5tYXNrWmVybyx0aGlzLmlucHV0TGVuZ3RoPWUuaW5wdXRMZW5ndGh9YnVpbGQoZSl7dGhpcy5lbWJlZGRpbmdzPXRoaXMuYWRkV2VpZ2h0KFwiZW1iZWRkaW5nc1wiLFt0aGlzLmlucHV0RGltLHRoaXMub3V0cHV0RGltXSx0aGlzLmR0eXBlLHRoaXMuZW1iZWRkaW5nc0luaXRpYWxpemVyLHRoaXMuZW1iZWRkaW5nc1JlZ3VsYXJpemVyLCEwLHRoaXMuZW1iZWRkaW5nc0NvbnN0cmFpbnQpLHRoaXMuYnVpbHQ9ITB9d2Fybk9uSW5jb21wYXRpYmxlSW5wdXRTaGFwZShlKXt9Y29tcHV0ZU1hc2soZSx0KXtyZXR1cm4gTygoKT0+dGhpcy5tYXNrWmVybz8oZT1UZShlKSxmaShlLHFlKGUpKSk6bnVsbCl9Y29tcHV0ZU91dHB1dFNoYXBlKGUpe2lmKGU9SmUoZSksdGhpcy5pbnB1dExlbmd0aD09bnVsbClyZXR1cm5bLi4uZSx0aGlzLm91dHB1dERpbV07bGV0IHQ9aXQodGhpcy5pbnB1dExlbmd0aCk7aWYodC5sZW5ndGghPT1lLmxlbmd0aC0xKXRocm93IG5ldyBWKGBcImlucHV0TGVuZ3RoXCIgaXMgJHt0aGlzLmlucHV0TGVuZ3RofSwgYnV0IHJlY2VpdmVkIGlucHV0IHNoYXBlIGhhcyBzaGFwZSAke2V9YCk7e2xldCBuPTA7Zm9yKGxldCBhPTA7YTx0Lmxlbmd0aDsrK2Epe2xldCByPXRbYV0scz1lW2ErMV07aWYociE9bnVsbCYmcyE9bnVsbCYmciE9PXMpdGhyb3cgbmV3IFYoYFwiaW5wdXRMZW5ndGhcIiBpcyAke3RoaXMuaW5wdXRMZW5ndGh9LCBidXQgcmVjZWl2ZWQgaW5wdXQgc2hhcGUgaGFzIHNoYXBlICR7ZX1gKTtyPT1udWxsJiYodFtuXT1zKSxuKyt9fXJldHVybltlWzBdLC4uLnQsdGhpcy5vdXRwdXREaW1dfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e3RoaXMuaW52b2tlQ2FsbEhvb2soZSx0KTtsZXQgbj1UZShlKTtuLmR0eXBlIT09XCJpbnQzMlwiJiYobj1pcihuLFwiaW50MzJcIikpO2xldCBhPXYyKHRoaXMuZW1iZWRkaW5ncy5yZWFkKCksVyhuLFtuLnNpemVdKSk7cmV0dXJuIFcoYSxKZSh0aGlzLmNvbXB1dGVPdXRwdXRTaGFwZShuLnNoYXBlKSkpfSl9Z2V0Q29uZmlnKCl7bGV0IGU9e2lucHV0RGltOnRoaXMuaW5wdXREaW0sb3V0cHV0RGltOnRoaXMub3V0cHV0RGltLGVtYmVkZGluZ3NJbml0aWFsaXplcjpFdCh0aGlzLmVtYmVkZGluZ3NJbml0aWFsaXplciksZW1iZWRkaW5nc1JlZ3VsYXJpemVyOmZ0KHRoaXMuZW1iZWRkaW5nc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOmZ0KHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksZW1iZWRkaW5nc0NvbnN0cmFpbnQ6WHQodGhpcy5lbWJlZGRpbmdzQ29uc3RyYWludCksbWFza1plcm86dGhpcy5tYXNrWmVybyxpbnB1dExlbmd0aDp0aGlzLmlucHV0TGVuZ3RofSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX19O1gwLmNsYXNzTmFtZT1cIkVtYmVkZGluZ1wiO25lLnJlZ2lzdGVyQ2xhc3MoWDApO3ZhciBZbz1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe3N1cGVyKGV8fHt9KSx0aGlzLnN1cHBvcnRzTWFza2luZz0hMH1tZXJnZUZ1bmN0aW9uKGUpe3Rocm93IG5ldyB6ZX1jb21wdXRlRWxlbWVudHdpc2VPcE91dHB1dFNoYXBlKGUsdCl7aWYoZT09bnVsbHx8dD09bnVsbClyZXR1cm4gbnVsbDtpZihlLmxlbmd0aDx0Lmxlbmd0aClyZXR1cm4gdGhpcy5jb21wdXRlRWxlbWVudHdpc2VPcE91dHB1dFNoYXBlKHQsZSk7aWYodC5sZW5ndGg9PT0wKXJldHVybiBlO2xldCBuPWUuc2xpY2UoMCxlLmxlbmd0aC10Lmxlbmd0aCk7Zm9yKGxldCBhPTA7YTx0Lmxlbmd0aDsrK2Epe2xldCByPWVbZS5sZW5ndGgtdC5sZW5ndGgrYV0scz10W2FdO2lmKHI9PW51bGx8fHM9PW51bGx8fHI8MHx8czwwKW4ucHVzaChudWxsKTtlbHNlIGlmKHI9PT0xKW4ucHVzaChzKTtlbHNlIGlmKHM9PT0xKW4ucHVzaChyKTtlbHNle2lmKHIhPT1zKXRocm93IG5ldyBWKFwiT3BlcmFuZHMgY291bGQgbm90IGJlIGJyb2FkY2FzdCB0b2dldGhlciB3aXRoIHNoYXBlcyBcIitKU09OLnN0cmluZ2lmeShlKStcIiBcIitKU09OLnN0cmluZ2lmeSh0KSk7bi5wdXNoKHIpfX1yZXR1cm4gbn1idWlsZChlKXtpZihBcnJheS5pc0FycmF5KGUpJiYhQXJyYXkuaXNBcnJheShlWzBdKSYmKGU9W0plKGUpXSksZT1lLGUubGVuZ3RoPDIpdGhyb3cgbmV3IFYoYEEgbWVyZ2UgbGF5ZXIgc2hvdWxkIGJlIGNhbGxlZCBvbiBhbiBBcnJheSBvZiBhdCBsZWFzdCAyIGlucHV0cy4gR290ICR7ZS5sZW5ndGh9IGlucHV0KHMpLmApO2xldCB0PVtdO2ZvcihsZXQgciBvZiBlKXIhPW51bGwmJnJbMF0hPT1udWxsJiZ0LnB1c2goclswXSk7aWYodD1hcyh0KSx0Lmxlbmd0aD4xKXRocm93IG5ldyBWKGBDYW4gbm90IG1lcmdlIHRlbnNvcnMgd2l0aCBkaWZmZXJlbnQgYmF0Y2ggc2l6ZXMuIEdvdCB0ZW5zb3JzIHdpdGggc2hhcGVzOiAke0pTT04uc3RyaW5naWZ5KGUpfS5gKTtsZXQgbj1lWzBdPT1udWxsP251bGw6ZVswXS5zbGljZSgxKTtmb3IobGV0IHI9MTtyPGUubGVuZ3RoOysrcil7bGV0IHM9ZVtyXT09bnVsbD9udWxsOmVbcl0uc2xpY2UoMSk7bj10aGlzLmNvbXB1dGVFbGVtZW50d2lzZU9wT3V0cHV0U2hhcGUobixzKX1sZXQgYT1lLm1hcChyPT5yLmxlbmd0aCk7ZS5pbmRleE9mKG51bGwpPT09LTEmJmFzKGEpLmxlbmd0aD09PTE/dGhpcy5yZXNoYXBlUmVxdWlyZWQ9ITE6dGhpcy5yZXNoYXBlUmVxdWlyZWQ9ITB9Y2FsbChlLHQpe3JldHVybiBPKCgpPT57aWYoZT1lLHRoaXMucmVzaGFwZVJlcXVpcmVkKXtsZXQgbj1bXSxhPWUubWFwKHI9PnIucmFuayk7aWYoYS5pbmRleE9mKG51bGwpPT09LTEpe2xldCByPWhzKGEpO2ZvcihsZXQgcyBvZiBlKXtsZXQgaT1zLnJhbms7Zm9yKGxldCBvPTA7bzxyLWk7KytvKXM9d2QocywxKTtuLnB1c2gocyl9cmV0dXJuIHRoaXMubWVyZ2VGdW5jdGlvbihuKX1lbHNle2xldCByPSExO2ZvcihsZXQgbyBvZiBlKXtsZXQgbD1vLnJhbms7aWYobD09bnVsbCl7bGV0IHU9by5zaGFwZSxwPXVbMF0sZD11LnNsaWNlKDEpLmNvbmNhdChbcF0pLGM9VyhvLFtwXS5jb25jYXQocnModS5zbGljZSgxKSkpKTtjPURlKGMsWzEsMF0pLGM9VyhjLGQpLG4ucHVzaChjKSxyPSEwfWVsc2UgaWYobD4xKXtsZXQgdT1VYSgxLGwpLmNvbmNhdChbMF0pO24ucHVzaChEZShvLHUpKSxyPSEwfWVsc2Ugbi5wdXNoKG8pfWxldCBzPXRoaXMubWVyZ2VGdW5jdGlvbihuKSxpPXMucmFuaztpZihyKXtpZihpPT1udWxsKXtsZXQgbz1zLnNoYXBlLGw9by5sZW5ndGgsdT1vW2wtMV0scD1bdV0uY29uY2F0KG8uc2xpY2UoMCxvLmxlbmd0aC0xKSk7cz1XKERlKFcocyxbLTEsdV0pLFsxLDBdKSxwKX1lbHNlIGlmKGk+MSl7bGV0IG89W2ktMV0uY29uY2F0KFVhKDAsaS0xKSk7cz1EZShzLG8pfX1yZXR1cm4gc319ZWxzZSByZXR1cm4gdGhpcy5tZXJnZUZ1bmN0aW9uKGUpfSl9Y29tcHV0ZU91dHB1dFNoYXBlKGUpe2U9ZTtsZXQgdDtlWzBdPT1udWxsP3Q9bnVsbDp0PWVbMF0uc2xpY2UoMSk7Zm9yKGxldCBhPTE7YTxlLmxlbmd0aDsrK2Epe2xldCByPWVbYV09PW51bGw/bnVsbDplW2FdLnNsaWNlKDEpO3Q9dGhpcy5jb21wdXRlRWxlbWVudHdpc2VPcE91dHB1dFNoYXBlKHQscil9bGV0IG49W107Zm9yKGxldCBhIG9mIGUpYSE9bnVsbCYmYVswXSE9PW51bGwmJm4ucHVzaChhWzBdKTtyZXR1cm4gbj1hcyhuKSxuLmxlbmd0aD09PTE/dD1uLmNvbmNhdCh0KTp0PVtudWxsXS5jb25jYXQodCksdH1jb21wdXRlTWFzayhlLHQpe3JldHVybiBPKCgpPT57aWYodD09bnVsbClyZXR1cm4gbnVsbDtpZighQXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgVihcImBtYXNrYCBzaG91bGQgYmUgYW4gQXJyYXlcIik7aWYoIUFycmF5LmlzQXJyYXkoZSkpdGhyb3cgbmV3IFYoXCJgaW5wdXRzYCBzaG91bGQgYmUgYW4gQXJyYXlcIik7aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgVihgVGhlIEFycmF5ICdpbnB1dHMnIGFuZCAnbWFzaycgYXJlIGV4cGVjdGVkIHRvIGhhdmUgdGhlIHNhbWUgbGVuZ3RoLCBidXQgaGF2ZSBkaWZmZXJlbnQgbGVuZ3RocyAoJHtlLmxlbmd0aH0gdnMgJHt0Lmxlbmd0aH0pYCk7aWYodC5ldmVyeShhPT5hPT1udWxsKSlyZXR1cm4gbnVsbDt0PXQubWFwKGE9PmE9PW51bGw/YTpHdChhLDApKTtsZXQgbj10WzBdO2ZvcihsZXQgYT0xO2E8dC5sZW5ndGgtMTsrK2Epbj1fYShuLHRbYV0pO3JldHVybiBufSl9fSxZMD1jbGFzcyBleHRlbmRzIFlve2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpfW1lcmdlRnVuY3Rpb24oZSl7cmV0dXJuIE8oKCk9PntsZXQgdD1lWzBdLmNsb25lKCk7Zm9yKGxldCBuPTE7bjxlLmxlbmd0aDsrK24pdD1YKHQsZVtuXSk7cmV0dXJuIHR9KX19O1kwLmNsYXNzTmFtZT1cIkFkZFwiO25lLnJlZ2lzdGVyQ2xhc3MoWTApO3ZhciBaMD1jbGFzcyBleHRlbmRzIFlve2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpfW1lcmdlRnVuY3Rpb24oZSl7cmV0dXJuIE8oKCk9PntsZXQgdD1lWzBdLmNsb25lKCk7Zm9yKGxldCBuPTE7bjxlLmxlbmd0aDsrK24pdD16KHQsZVtuXSk7cmV0dXJuIHR9KX19O1owLmNsYXNzTmFtZT1cIk11bHRpcGx5XCI7bmUucmVnaXN0ZXJDbGFzcyhaMCk7dmFyIEowPWNsYXNzIGV4dGVuZHMgWW97Y29uc3RydWN0b3IoZSl7c3VwZXIoZSl9bWVyZ2VGdW5jdGlvbihlKXtyZXR1cm4gTygoKT0+e2xldCB0PWVbMF0uY2xvbmUoKTtmb3IobGV0IG49MTtuPGUubGVuZ3RoOysrbil0PVgodCxlW25dKTtyZXR1cm4geigxL2UubGVuZ3RoLHQpfSl9fTtKMC5jbGFzc05hbWU9XCJBdmVyYWdlXCI7bmUucmVnaXN0ZXJDbGFzcyhKMCk7dmFyIFEwPWNsYXNzIGV4dGVuZHMgWW97Y29uc3RydWN0b3IoZSl7c3VwZXIoZSl9bWVyZ2VGdW5jdGlvbihlKXtyZXR1cm4gTygoKT0+e2xldCB0PWVbMF07Zm9yKGxldCBuPTE7bjxlLmxlbmd0aDsrK24pdD1ocih0LGVbbl0pO3JldHVybiB0fSl9fTtRMC5jbGFzc05hbWU9XCJNYXhpbXVtXCI7bmUucmVnaXN0ZXJDbGFzcyhRMCk7dmFyIGUxPWNsYXNzIGV4dGVuZHMgWW97Y29uc3RydWN0b3IoZSl7c3VwZXIoZSl9bWVyZ2VGdW5jdGlvbihlKXtyZXR1cm4gTygoKT0+e2xldCB0PWVbMF07Zm9yKGxldCBuPTE7bjxlLmxlbmd0aDsrK24pdD1kcyh0LGVbbl0pO3JldHVybiB0fSl9fTtlMS5jbGFzc05hbWU9XCJNaW5pbXVtXCI7bmUucmVnaXN0ZXJDbGFzcyhlMSk7dmFyIHQxPWNsYXNzIGV4dGVuZHMgWW97Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksdGhpcy5ERUZBVUxUX0FYSVM9LTEsZT09bnVsbCYmKGU9e30pLHRoaXMuYXhpcz1lLmF4aXM9PW51bGw/dGhpcy5ERUZBVUxUX0FYSVM6ZS5heGlzLHRoaXMuc3VwcG9ydHNNYXNraW5nPSEwLHRoaXMucmVzaGFwZVJlcXVpcmVkPSExfWJ1aWxkKGUpe2lmKCEoQXJyYXkuaXNBcnJheShlKSYmQXJyYXkuaXNBcnJheShlWzBdKSl8fGUubGVuZ3RoPT09MSl0aHJvdyBuZXcgVihcIkEgYENvbmNhdGVuYXRlYCBsYXllciBzaG91bGQgYmUgY2FsbGVkIG9uIGEgbGlzdCBvZiBhdCBsZWFzdCAyIGlucHV0c1wiKTtlPWU7bGV0IHQ9ITA7Zm9yKGxldCBhIG9mIGUpaWYoYSE9bnVsbCl7dD0hMTticmVha31pZih0KXJldHVybjtsZXQgbj1bXTtmb3IobGV0IGE9MDthPGUubGVuZ3RoOysrYSl7bGV0IHI9ZVthXS5zbGljZSgpO3Iuc3BsaWNlKHRoaXMuYXhpcywxKTtsZXQgcz0hMTtmb3IobGV0IGkgb2YgbilpZih3LmFycmF5c0VxdWFsKGkscikpe3M9ITA7YnJlYWt9c3x8bi5wdXNoKHIpfWlmKG4ubGVuZ3RoPjEpdGhyb3cgbmV3IFYoXCJBIGBDb25jYXRlbmF0ZWAgbGF5ZXIgcmVxdWlyZXMgaW5wdXRzIHdpdGggbWF0Y2hpbmcgc2hhcGVzIGV4Y2VwdCBmb3IgdGhlIGNvbmNhdCBheGlzLiBHb3QgaW5wdXQgc2hhcGVzOiBcIitKU09OLnN0cmluZ2lmeShlKSl9bWVyZ2VGdW5jdGlvbihlKXtyZXR1cm4gTygoKT0+dDAoZSx0aGlzLmF4aXMpKX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7aWYoIShBcnJheS5pc0FycmF5KGUpJiZBcnJheS5pc0FycmF5KGVbMF0pKSl0aHJvdyBuZXcgVihcIkEgYENvbmNhdGVuYXRlYCBsYXllciBzaG91bGQgYmUgY2FsbGVkIG9uIGEgbGlzdCBvZiBpbnB1dHMuXCIpO2xldCB0PWUsbj10WzBdLnNsaWNlKCksYT10aGlzLmF4aXM8MD9uLmxlbmd0aCt0aGlzLmF4aXM6dGhpcy5heGlzO2ZvcihsZXQgciBvZiB0LnNsaWNlKDEpKXtpZihuW2FdPT1udWxsfHxyW2FdPT1udWxsKXtuW2FdPW51bGw7YnJlYWt9blthXSs9clthXX1yZXR1cm4gbn1jb21wdXRlTWFzayhlLHQpe2lmKHQ9PW51bGwpcmV0dXJuIG51bGw7aWYoIUFycmF5LmlzQXJyYXkodCkpdGhyb3cgbmV3IFYoXCJgbWFza2Agc2hvdWxkIGJlIGFuIGFycmF5IGZvciBDb25jYXRlbmF0ZVwiKTtpZighQXJyYXkuaXNBcnJheShlKSl0aHJvdyBuZXcgVihcImBpbnB1dHNgIHNob3VsZCBiZSBhbiBhcnJheSBmb3IgQ29uY2F0ZW5hdGVcIik7aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgVihgTWlzbWF0Y2ggaW4gdGhlIGxlbmd0aCBvZiBtYXNrICgke3QubGVuZ3RofSkgYW5kIHRoZSBsZWdudGggb2YgaW5wdXRzICgke2UubGVuZ3RofSlgKTtyZXR1cm4gTygoKT0+e2xldCBuPSEwO2lmKHQuZm9yRWFjaChzPT57aWYocyE9bnVsbCl7bj0hMTtyZXR1cm59fSksbilyZXR1cm4gbnVsbDtsZXQgYT1bXTtmb3IobGV0IHM9MDtzPGUubGVuZ3RoOysrcyl0W3NdPT1udWxsP2EucHVzaChyZShlYShlW3NdKSxcImJvb2xcIikpOnRbc10ucmFuazxlW3NdLnJhbms/YS5wdXNoKEd0KHRbc10sLTEpKTphLnB1c2godFtzXSk7bGV0IHI9ZXQoYSx0aGlzLmF4aXMpO3JldHVybiBMbShyLC0xLCExKX0pfWdldENvbmZpZygpe2xldCBlPXtheGlzOnRoaXMuYXhpc30sdD1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9fTt0MS5jbGFzc05hbWU9XCJDb25jYXRlbmF0ZVwiO25lLnJlZ2lzdGVyQ2xhc3ModDEpO2Z1bmN0aW9uIFlwKGUsdCl7Zm9yKDtlPDA7KWUrPXQ7cmV0dXJuIGV9ZnVuY3Rpb24geGooZSx0LG4pe2lmKGUuc2hhcGUubGVuZ3RoPjN8fHQuc2hhcGUubGVuZ3RoPjMpdGhyb3cgbmV3IHplKFwiYmF0Y2hEb3QgaXMgbm90IGltcGxlbWVudGVkIGZvciB0ZW5zb3JzIG9mIDREIG9yIGhpZ2hlciByYW5rIHlldFwiKTtpZih3LmFzc2VydChlLnNoYXBlLmxlbmd0aD49MiwoKT0+YGJhdGNoRG90IHJlcXVpcmVzIHRoZSByYW5rIG9mIHggdG8gYmUgPj0gMiwgYnV0IGdvdCAke2Uuc2hhcGUubGVuZ3RofWApLHcuYXNzZXJ0KGUuc2hhcGUubGVuZ3RoPj0yLCgpPT5gYmF0Y2hEb3QgcmVxdWlyZXMgdGhlIHJhbmsgb2YgeSB0byBiZSA+PSAyLCBidXQgZ290ICR7dC5zaGFwZS5sZW5ndGh9YCksdHlwZW9mIG49PVwibnVtYmVyXCImJihuPVtuLG5dKSxlLmR0eXBlPT09XCJjb21wbGV4NjRcInx8dC5kdHlwZT09PVwiY29tcGxleDY0XCIpdGhyb3cgbmV3IHplKFwiYmF0Y2hEb3QgaXMgbm90IGltcGxlbWVudGVkIGZvciBjb21wbGV4NjQtdHlwZSBUZW5zb3JzIHlldC5cIik7bGV0IGE9ZS5zaGFwZS5sZW5ndGgscj10LnNoYXBlLmxlbmd0aDtuPT1udWxsJiYobj1bYS0xLHItMl0pO2xldCBzPW47cmV0dXJuIE8oKCk9PntsZXQgaTtpZihhPnIpe2k9YS1yO2xldCBsPVtdO2ZvcihsZXQgdT0wO3U8aTsrK3UpbC5wdXNoKDEpO3Q9Vyh0LHQuc2hhcGUuY29uY2F0KGwpKX1lbHNlIGlmKHI+YSl7aT1yLWE7bGV0IGw9W107Zm9yKGxldCB1PTA7dTxpOysrdSlsLnB1c2goMSk7ZT1XKGUsZS5zaGFwZS5jb25jYXQobCkpfWVsc2UgaT0wO2xldCBvO2lmKGUuc2hhcGUubGVuZ3RoPT09MiYmdC5zaGFwZS5sZW5ndGg9PT0yKXNbMF09PT1zWzFdP289ZmUoeihlLHQpLHNbMF0pOm89ZmUoeihEZShlLFsxLDBdKSx0KSxzWzFdKTtlbHNle2xldCBsPXNbMF0hPT1lLnNoYXBlLmxlbmd0aC0xLHU9c1sxXT09PXQuc2hhcGUubGVuZ3RoLTE7bz0kZShlLHQsbCx1KX1pZihpPjApe2xldCBsO2E+cj9sPWErci0zOmw9YS0xO2xldCB1PVtdO2ZvcihsZXQgcD1sO3A8bCtpOysrcCl1LnB1c2gocCk7bz1BcyhvLHUpfXJldHVybiBvLnNoYXBlLmxlbmd0aD09PTEmJihvPUd0KG8sMSkpLG99KX12YXIgbjE9Y2xhc3MgZXh0ZW5kcyBZb3tjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLmF4ZXM9ZS5heGVzLHRoaXMubm9ybWFsaXplPWUubm9ybWFsaXplPT1udWxsPyExOmUubm9ybWFsaXplLHRoaXMuc3VwcG9ydHNNYXNraW5nPSEwLHRoaXMucmVzaGFwZVJlcXVpcmVkPSExfWJ1aWxkKGUpe3cuYXNzZXJ0KEFycmF5LmlzQXJyYXkoZSkmJmUubGVuZ3RoPT09MiYmQXJyYXkuaXNBcnJheShlWzBdKSYmQXJyYXkuaXNBcnJheShlWzFdKSwoKT0+XCJBIGBEb3RgIGxheWVyIHNob3VsZCBiZSBjYWxsZWQgb24gYSBsaXN0IG9mIGV4YWN0bHkgMiBpbnB1dHMuXCIpO2xldCB0PWVbMF0sbj1lWzFdO2lmKHQubGVuZ3RoPjN8fG4ubGVuZ3RoPjMpdGhyb3cgbmV3IHplKFwiRG90IGxheWVyIGRvZXMgbm90IHN1cHBvcnQgdGVuc29ycyBvZiA0RCBvciBoaWdoZXIgcmFuayB5ZXQuXCIpO2xldCBhPXRoaXMuaW50ZXJwcmV0QXhlcyh0LG4pO2lmKHRbYVswXV0hPT1uW2FbMV1dKXRocm93IG5ldyBWKGBEaW1lbnNpb24gaW5jb21wYXRpYmlsaXR5OiAke3RbYVswXV19ICE9PSAke25bYVsxXV19YCl9bWVyZ2VGdW5jdGlvbihlKXtpZihlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IFYoYEEgXFxgRG90XFxgIGxheWVyIG11c3QgYmUgY2FsbGVkIG9uIGV4YWN0bHkgMiBpbnB1dHMsIGJ1dCByZWNlaXZlZCAke2UubGVuZ3RofSBpbnB1dChzKS5gKTtsZXQgdD1lWzBdLG49ZVsxXSxhO3JldHVybiBBcnJheS5pc0FycmF5KHRoaXMuYXhlcyk/YT10aGlzLmF4ZXMubWFwKChyLHMpPT5ZcChyLGVbc10uc2hhcGUubGVuZ3RoKSk6YT1bWXAodGhpcy5heGVzLHQuc2hhcGUubGVuZ3RoKSxZcCh0aGlzLmF4ZXMsbi5zaGFwZS5sZW5ndGgpXSx0aGlzLm5vcm1hbGl6ZSYmKHQ9dG0odCxhWzBdKSxuPXRtKG4sYVsxXSkpLHhqKHQsbixhKX1pbnRlcnByZXRBeGVzKGUsdCl7bGV0IG47cmV0dXJuIEFycmF5LmlzQXJyYXkodGhpcy5heGVzKT9uPXRoaXMuYXhlczpuPVtZcCh0aGlzLmF4ZXMsZS5sZW5ndGgpLFlwKHRoaXMuYXhlcyx0Lmxlbmd0aCldLG59Y29tcHV0ZU91dHB1dFNoYXBlKGUpe3cuYXNzZXJ0KEFycmF5LmlzQXJyYXkoZSkmJmUubGVuZ3RoPT09MiYmQXJyYXkuaXNBcnJheShlWzBdKSYmQXJyYXkuaXNBcnJheShlWzFdKSwoKT0+XCJBIGBEb3RgIGxheWVyIHNob3VsZCBiZSBjYWxsZWQgb24gYSBsaXN0IG9mIGV4YWN0bHkgMiBpbnB1dHMuXCIpO2xldCB0PWVbMF0uc2xpY2UoKSxuPWVbMV0uc2xpY2UoKTtpZih0Lmxlbmd0aD4zfHxuLmxlbmd0aD4zKXRocm93IG5ldyB6ZShcIkRvdCBsYXllciBkb2VzIG5vdCBzdXBwb3J0IHRlbnNvcnMgb2YgNEQgb3IgaGlnaGVyIHJhbmsgeWV0LlwiKTtsZXQgYT10aGlzLmludGVycHJldEF4ZXModCxuKTt0LnNwbGljZShhWzBdLDEpLG4uc3BsaWNlKGFbMV0sMSksbi5zcGxpY2UoMCwxKTtsZXQgcj10LmNvbmNhdChuKTtyZXR1cm4gci5sZW5ndGg9PT0xJiZyLnB1c2goMSkscn1jb21wdXRlTWFzayhlLHQpe3JldHVybiBudWxsfWdldENvbmZpZygpe2xldCBlPXtheGVzOnRoaXMuYXhlcyxub3JtYWxpemU6dGhpcy5ub3JtYWxpemV9LHQ9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfX07bjEuY2xhc3NOYW1lPVwiRG90XCI7bmUucmVnaXN0ZXJDbGFzcyhuMSk7dmFyIGExPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksdGhpcy5zdXBwb3J0c01hc2tpbmc9ITAsdGhpcy5zdGRkZXY9ZS5zdGRkZXZ9Y29tcHV0ZU91dHB1dFNoYXBlKGUpe3JldHVybiBlfWdldENvbmZpZygpe2xldCBlPXN1cGVyLmdldENvbmZpZygpLHQ9e3N0ZGRldjp0aGlzLnN0ZGRldn07cmV0dXJuIE9iamVjdC5hc3NpZ24odCxlKSx0fWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e3RoaXMuaW52b2tlQ2FsbEhvb2soZSx0KTtsZXQgbj1UZShlKTtyZXR1cm4gSWQoKCk9PlgoYmYobi5zaGFwZSwwLHRoaXMuc3RkZGV2KSxuKSwoKT0+bix0LnRyYWluaW5nfHwhMSl9KX19O2ExLmNsYXNzTmFtZT1cIkdhdXNzaWFuTm9pc2VcIjtuZS5yZWdpc3RlckNsYXNzKGExKTt2YXIgcjE9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLnN1cHBvcnRzTWFza2luZz0hMCx0aGlzLnJhdGU9ZS5yYXRlfWNvbXB1dGVPdXRwdXRTaGFwZShlKXtyZXR1cm4gZX1nZXRDb25maWcoKXtsZXQgZT1zdXBlci5nZXRDb25maWcoKSx0PXtyYXRlOnRoaXMucmF0ZX07cmV0dXJuIE9iamVjdC5hc3NpZ24odCxlKSx0fWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e3RoaXMuaW52b2tlQ2FsbEhvb2soZSx0KTtsZXQgbj1UZShlKTtyZXR1cm4gdGhpcy5yYXRlPjAmJnRoaXMucmF0ZTwxP0lkKCgpPT57bGV0IGE9TWF0aC5zcXJ0KHRoaXMucmF0ZS8oMS10aGlzLnJhdGUpKTtyZXR1cm4geihuLGJmKG4uc2hhcGUsMSxhKSl9LCgpPT5uLHQudHJhaW5pbmd8fCExKTpufSl9fTtyMS5jbGFzc05hbWU9XCJHYXVzc2lhbkRyb3BvdXRcIjtuZS5yZWdpc3RlckNsYXNzKHIxKTt2YXIgczE9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLnN1cHBvcnRzTWFza2luZz0hMCx0aGlzLnJhdGU9ZS5yYXRlLHRoaXMubm9pc2VTaGFwZT1lLm5vaXNlU2hhcGV9X2dldE5vaXNlU2hhcGUoZSl7cmV0dXJuIHRoaXMubm9pc2VTaGFwZXx8VGUoZSkuc2hhcGV9Y29tcHV0ZU91dHB1dFNoYXBlKGUpe3JldHVybiBlfWdldENvbmZpZygpe2xldCBlPXN1cGVyLmdldENvbmZpZygpLHQ9e3JhdGU6dGhpcy5yYXRlfTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LGUpLHR9Y2FsbChlLHQpe3JldHVybiBPKCgpPT57aWYodGhpcy5yYXRlPDEmJnRoaXMucmF0ZT4wKXtsZXQgbj10aGlzLl9nZXROb2lzZVNoYXBlKGUpO3JldHVybiBJZCgoKT0+e2xldCBhPVRlKGUpLHI9LTEuNjczMjYzMjQyMzU0Mzc3MioxLjA1MDcwMDk4NzM1NTQ4MDUscz0kcihFcyhuKSx0aGlzLnJhdGUpO3M9aXIocyxcImZsb2F0MzJcIik7bGV0IGk9KCgxLXRoaXMucmF0ZSkqKDErdGhpcy5yYXRlKnIqKjIpKSoqLS41LG89LWkqcip0aGlzLnJhdGUsbD1YKHooYSxzKSx6KFgocywtMSkscikpO3JldHVybiBYKHoobCxpKSxvKX0sKCk9PlRlKGUpLHQudHJhaW5pbmd8fCExKX1yZXR1cm4gZX0pfX07czEuY2xhc3NOYW1lPVwiQWxwaGFEcm9wb3V0XCI7bmUucmVnaXN0ZXJDbGFzcyhzMSk7ZnVuY3Rpb24gU2MoZSx0LG4sYSxyLHM9LjAwMSl7bGV0IGk7aWYoZS5yYW5rPT09MilpPXF2KGUsdCxuLGEscixzKTtlbHNlIGlmKGUucmFuaz09PTMpaT1LdihlLHQsbixhLHIscyk7ZWxzZSBpZihlLnJhbms9PT00KWk9WHYoZSx0LG4sYSxyLHMpO2Vsc2UgdGhyb3cgbmV3IHplKGBiYXRjaE5vcm1hbGl6YXRpb24gaXMgbm90IGltcGxlbWVudGVkIGZvciBhcnJheSBvZiByYW5rICR7ZS5yYW5rfSB5ZXRgKTtyZXR1cm4gaX1mdW5jdGlvbiB2aihlLHQsbixhLHI9LjAwMSl7cmV0dXJuIE8oKCk9PntsZXQgcz1oZChlLGEpLGk9cy5tZWFuLG89cy52YXJpYW5jZTtyZXR1cm5bU2MoZSxpLG8sbix0LHIpLGksb119KX1mdW5jdGlvbiB3aihlLHQsbixhLHI9LjAwMSl7cmV0dXJuIE8oKCk9PntsZXQgcz1oZChlLGEpLGk9cy5tZWFuLG89cy52YXJpYW5jZSxsPVtdO2ZvcihsZXQgaCBvZiBVYSgwLGUucmFuaykpYS5pbmRleE9mKGgpIT09LTE/bC5wdXNoKDEpOmwucHVzaChlLnNoYXBlW2hdKTtsZXQgdT1XKGksbCkscD1XKG8sbCksZD10PT1udWxsP251bGw6Vyh0LGwpLGM9bj09bnVsbD9udWxsOlcobixsKTtyZXR1cm5bU2MoZSx1LHAsYyxkLHIpLGksb119KX1mdW5jdGlvbiBraihlLHQsbixhLHI9LjAwMSl7cmV0dXJuIHcuYXJyYXlzRXF1YWwoYS5zbGljZSgpLnNvcnQoKSxVYSgwLGUucmFuay0xKSk/dmooZSx0LG4sYSxyKTp3aihlLHQsbixhLHIpfXZhciBpMT1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe2U9PW51bGwmJihlPXt9KSxzdXBlcihlKSx0aGlzLnN1cHBvcnRzTWFza2luZz0hMCx0aGlzLmF4aXM9ZS5heGlzPT1udWxsPy0xOmUuYXhpcyx0aGlzLm1vbWVudHVtPWUubW9tZW50dW09PW51bGw/Ljk5OmUubW9tZW50dW0sdGhpcy5lcHNpbG9uPWUuZXBzaWxvbj09bnVsbD8uMDAxOmUuZXBzaWxvbix0aGlzLmNlbnRlcj1lLmNlbnRlcj09bnVsbD8hMDplLmNlbnRlcix0aGlzLnNjYWxlPWUuc2NhbGU9PW51bGw/ITA6ZS5zY2FsZSx0aGlzLmJldGFJbml0aWFsaXplcj1TdChlLmJldGFJbml0aWFsaXplcnx8XCJ6ZXJvc1wiKSx0aGlzLmdhbW1hSW5pdGlhbGl6ZXI9U3QoZS5nYW1tYUluaXRpYWxpemVyfHxcIm9uZXNcIiksdGhpcy5tb3ZpbmdNZWFuSW5pdGlhbGl6ZXI9U3QoZS5tb3ZpbmdNZWFuSW5pdGlhbGl6ZXJ8fFwiemVyb3NcIiksdGhpcy5tb3ZpbmdWYXJpYW5jZUluaXRpYWxpemVyPVN0KGUubW92aW5nVmFyaWFuY2VJbml0aWFsaXplcnx8XCJvbmVzXCIpLHRoaXMuYmV0YUNvbnN0cmFpbnQ9WXQoZS5iZXRhQ29uc3RyYWludCksdGhpcy5nYW1tYUNvbnN0cmFpbnQ9WXQoZS5nYW1tYUNvbnN0cmFpbnQpLHRoaXMuYmV0YVJlZ3VsYXJpemVyPU50KGUuYmV0YVJlZ3VsYXJpemVyKSx0aGlzLmdhbW1hUmVndWxhcml6ZXI9TnQoZS5nYW1tYVJlZ3VsYXJpemVyKX1idWlsZChlKXtlPUplKGUpO2xldCB0PXRoaXMuYXhpcz49MD90aGlzLmF4aXM6dGhpcy5heGlzK2UubGVuZ3RoLG49ZVt0XTtpZihuPT1udWxsKXRocm93IG5ldyBWKGBBeGlzICR7dH0gb2YgaW5wdXQgdGVuc29yIHNob3VsZCBoYXZlIGEgZGVmaW5lZCBkaW1lbnNpb24gYnV0IHRoZSBsYXllciByZWNlaXZlZCBhbiBpbnB1dCB3aXRoIHNoYXBlICR7SlNPTi5zdHJpbmdpZnkoZSl9LmApO3RoaXMuaW5wdXRTcGVjPVtuZXcgenQoe25kaW06ZS5sZW5ndGgsYXhlczp7W3RdOm59fSldO2xldCBhPVtuXTt0aGlzLnNjYWxlJiYodGhpcy5nYW1tYT10aGlzLmFkZFdlaWdodChcImdhbW1hXCIsYSxudWxsLHRoaXMuZ2FtbWFJbml0aWFsaXplcix0aGlzLmdhbW1hUmVndWxhcml6ZXIsITAsdGhpcy5nYW1tYUNvbnN0cmFpbnQpKSx0aGlzLmNlbnRlciYmKHRoaXMuYmV0YT10aGlzLmFkZFdlaWdodChcImJldGFcIixhLG51bGwsdGhpcy5iZXRhSW5pdGlhbGl6ZXIsdGhpcy5iZXRhUmVndWxhcml6ZXIsITAsdGhpcy5iZXRhQ29uc3RyYWludCkpLHRoaXMubW92aW5nTWVhbj10aGlzLmFkZFdlaWdodChcIm1vdmluZ19tZWFuXCIsYSxudWxsLHRoaXMubW92aW5nTWVhbkluaXRpYWxpemVyLG51bGwsITEpLHRoaXMubW92aW5nVmFyaWFuY2U9dGhpcy5hZGRXZWlnaHQoXCJtb3ZpbmdfdmFyaWFuY2VcIixhLG51bGwsdGhpcy5tb3ZpbmdWYXJpYW5jZUluaXRpYWxpemVyLG51bGwsITEpLHRoaXMuYnVpbHQ9ITB9Y2FsbChlLHQpe3JldHVybiBPKCgpPT57bGV0IG49dC50cmFpbmluZz09bnVsbD8hMTp0LnRyYWluaW5nLGE9VGUoZSkscj1hLnNoYXBlLHM9ci5sZW5ndGgsaT1VYSgwLHMpLG89dGhpcy5heGlzPj0wP3RoaXMuYXhpczp0aGlzLmF4aXMrcztpLnNwbGljZShvLDEpO2xldCBsPWJpKDEscyk7bFtvXT1yW29dO2xldCB1PWkuc2xpY2UoKTt1LnNvcnQoKTtsZXQgcD0hdy5hcnJheXNFcXVhbCh1LFVhKDAscykuc2xpY2UoMCxzLTEpKSxkPSgpPT57aWYocCl7bGV0IGc9Vyh0aGlzLm1vdmluZ01lYW4ucmVhZCgpLGwpLGI9Vyh0aGlzLm1vdmluZ1ZhcmlhbmNlLnJlYWQoKSxsKSx5PXRoaXMuY2VudGVyP1codGhpcy5iZXRhLnJlYWQoKSxsKTpudWxsLHg9dGhpcy5zY2FsZT9XKHRoaXMuZ2FtbWEucmVhZCgpLGwpOm51bGw7cmV0dXJuIFNjKGEsZyxiLHkseCx0aGlzLmVwc2lsb24pfWVsc2UgcmV0dXJuIFNjKGEsdGhpcy5tb3ZpbmdNZWFuLnJlYWQoKSx0aGlzLm1vdmluZ1ZhcmlhbmNlLnJlYWQoKSx0aGlzLmJldGE9PW51bGw/bnVsbDp0aGlzLmJldGEucmVhZCgpLHRoaXMuZ2FtbWE9PW51bGw/bnVsbDp0aGlzLmdhbW1hLnJlYWQoKSx0aGlzLmVwc2lsb24pfTtpZighbilyZXR1cm4gZCgpO2xldFtjLGgsbV09a2ooYSx0aGlzLmdhbW1hLnJlYWQoKSx0aGlzLmJldGEucmVhZCgpLGksdGhpcy5lcHNpbG9uKSxmPShnLGIseSk9PntPKCgpPT57bGV0IHg9MS15LHY9Zy5yZWFkKCksST16KHBlKHYsYikseCk7Zy53cml0ZShwZSh2LEkpKX0pfTtyZXR1cm4gZih0aGlzLm1vdmluZ01lYW4saCx0aGlzLm1vbWVudHVtKSxmKHRoaXMubW92aW5nVmFyaWFuY2UsbSx0aGlzLm1vbWVudHVtKSxjfSl9Z2V0Q29uZmlnKCl7bGV0IGU9e2F4aXM6dGhpcy5heGlzLG1vbWVudHVtOnRoaXMubW9tZW50dW0sZXBzaWxvbjp0aGlzLmVwc2lsb24sY2VudGVyOnRoaXMuY2VudGVyLHNjYWxlOnRoaXMuc2NhbGUsYmV0YUluaXRpYWxpemVyOkV0KHRoaXMuYmV0YUluaXRpYWxpemVyKSxnYW1tYUluaXRpYWxpemVyOkV0KHRoaXMuZ2FtbWFJbml0aWFsaXplciksbW92aW5nTWVhbkluaXRpYWxpemVyOkV0KHRoaXMubW92aW5nTWVhbkluaXRpYWxpemVyKSxtb3ZpbmdWYXJpYW5jZUluaXRpYWxpemVyOkV0KHRoaXMubW92aW5nVmFyaWFuY2VJbml0aWFsaXplciksYmV0YVJlZ3VsYXJpemVyOmZ0KHRoaXMuYmV0YVJlZ3VsYXJpemVyKSxnYW1tYVJlZ3VsYXJpemVyOmZ0KHRoaXMuZ2FtbWFSZWd1bGFyaXplciksYmV0YUNvbnN0cmFpbnQ6WHQodGhpcy5iZXRhQ29uc3RyYWludCksZ2FtbWFDb25zdHJhaW50Olh0KHRoaXMuZ2FtbWFDb25zdHJhaW50KX0sdD1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9fTtpMS5jbGFzc05hbWU9XCJCYXRjaE5vcm1hbGl6YXRpb25cIjtuZS5yZWdpc3RlckNsYXNzKGkxKTt2YXIgbzE9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtpZihlPT1udWxsJiYoZT17fSksc3VwZXIoZSksdGhpcy5heGlzPWUuYXhpcz09bnVsbD8tMTplLmF4aXMsdHlwZW9mIHRoaXMuYXhpcz09XCJudW1iZXJcIil7aWYoIU51bWJlci5pc0ludGVnZXIodGhpcy5heGlzKSl0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGF4aXMgdG8gYmUgYW4gaW50ZWdlciwgYnV0IHJlY2VpdmVkICR7dGhpcy5heGlzfWApfWVsc2UgaWYoQXJyYXkuaXNBcnJheSh0aGlzLmF4aXMpKXtmb3IobGV0IHQgb2YgdGhpcy5heGlzKWlmKCFOdW1iZXIuaXNJbnRlZ2VyKHQpKXRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYXhpcyB0byBiZSBhbiBhcnJheSBvZiBpbnRlZ2VycywgYnV0IHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkodGhpcy5heGlzKX1gKX1lbHNlIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYXhpcyB0byBiZSBhbiBpbnRlZ2VyIG9yIGFuIGFycmF5IG9mIGludGVnZXJzLCBidXQgcmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeSh0aGlzLmF4aXMpfWApO3RoaXMuZXBzaWxvbj1lLmVwc2lsb249PW51bGw/LjAwMTplLmVwc2lsb24sdGhpcy5jZW50ZXI9ZS5jZW50ZXI9PW51bGw/ITA6ZS5jZW50ZXIsdGhpcy5zY2FsZT1lLnNjYWxlPT1udWxsPyEwOmUuc2NhbGUsdGhpcy5iZXRhSW5pdGlhbGl6ZXI9U3QoZS5iZXRhSW5pdGlhbGl6ZXJ8fFwiemVyb3NcIiksdGhpcy5nYW1tYUluaXRpYWxpemVyPVN0KGUuZ2FtbWFJbml0aWFsaXplcnx8XCJvbmVzXCIpLHRoaXMuYmV0YVJlZ3VsYXJpemVyPU50KGUuYmV0YVJlZ3VsYXJpemVyKSx0aGlzLmdhbW1hUmVndWxhcml6ZXI9TnQoZS5nYW1tYVJlZ3VsYXJpemVyKSx0aGlzLnN1cHBvcnRzTWFza2luZz0hMH1idWlsZChlKXtlPUplKGUpO2xldCB0PWUubGVuZ3RoO3R5cGVvZiB0aGlzLmF4aXM9PVwibnVtYmVyXCImJih0aGlzLmF4aXM9W3RoaXMuYXhpc10pO2ZvcihsZXQgcj0wO3I8dGhpcy5heGlzLmxlbmd0aDsrK3IpdGhpcy5heGlzW3JdPDAmJih0aGlzLmF4aXNbcl0rPXQpO2ZvcihsZXQgciBvZiB0aGlzLmF4aXMpaWYocjwwfHxyPj10KXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBheGlzOiAke3J9YCk7aWYodGhpcy5heGlzLmxlbmd0aCE9PWFzKHRoaXMuYXhpcykubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgRm91bmQgZHVwbGljYXRlIGF4ZXMgaW46ICR7dGhpcy5heGlzfWApO2xldCBuPXRoaXMuYXhpcy5tYXAocj0+ZVtyXSksYT0hMDt0aGlzLnNjYWxlP3RoaXMuZ2FtbWE9dGhpcy5hZGRXZWlnaHQoXCJnYW1tYVwiLG4sXCJmbG9hdDMyXCIsdGhpcy5nYW1tYUluaXRpYWxpemVyLHRoaXMuZ2FtbWFSZWd1bGFyaXplcixhKTp0aGlzLmdhbW1hPW51bGwsdGhpcy5jZW50ZXI/dGhpcy5iZXRhPXRoaXMuYWRkV2VpZ2h0KFwiYmV0YVwiLG4sXCJmbG9hdDMyXCIsdGhpcy5iZXRhSW5pdGlhbGl6ZXIsdGhpcy5iZXRhUmVndWxhcml6ZXIsYSk6dGhpcy5iZXRhPW51bGwsdGhpcy5idWlsdD0hMH1jYWxsKGUsdCl7bGV0IG49VGUoZSksYT1uLnNoYXBlLHI9YS5sZW5ndGg7cmV0dXJuIE8oKCk9PntsZXR7bWVhbjpzLHZhcmlhbmNlOml9PWhkKG4sdGhpcy5heGlzLCEwKSxvPWJpKDEscik7Zm9yKGxldCBoIG9mIHRoaXMuYXhpcylvW2hdPWFbaF07bGV0IGw9aD0+aCE9bnVsbCYmaC5zaGFwZS5sZW5ndGghPT1yP1coaCxvKTpoLHU9dGhpcy5zY2FsZT9sKHRoaXMuZ2FtbWEucmVhZCgpKTpudWxsLHA9dGhpcy5jZW50ZXI/bCh0aGlzLmJldGEucmVhZCgpKTpudWxsLGQ9W10sYz1bXTtmb3IobGV0IGg9MDtoPHI7KytoKXRoaXMuYXhpcy5pbmRleE9mKGgpIT09LTE/KGQucHVzaChhW2hdKSxjLnB1c2goMSkpOihkLnB1c2goMSksYy5wdXNoKGFbaF0pKTtyZXR1cm4gcz1PbihzLGQpLGk9T24oaSxkKSx1IT1udWxsJiYodT1Pbih1LGMpKSxwIT1udWxsJiYocD1PbihwLGMpKSxTYyhuLHMsaSxwLHUsdGhpcy5lcHNpbG9uKX0pfWdldENvbmZpZygpe2xldCBlPXtheGlzOnRoaXMuYXhpcyxlcHNpbG9uOnRoaXMuZXBzaWxvbixjZW50ZXI6dGhpcy5jZW50ZXIsc2NhbGU6dGhpcy5zY2FsZSxiZXRhSW5pdGlhbGl6ZXI6RXQodGhpcy5iZXRhSW5pdGlhbGl6ZXIpLGdhbW1hSW5pdGlhbGl6ZXI6RXQodGhpcy5nYW1tYUluaXRpYWxpemVyKSxiZXRhUmVndWxhcml6ZXI6ZnQodGhpcy5iZXRhUmVndWxhcml6ZXIpLGdhbW1hUmVndWxhcml6ZXI6ZnQodGhpcy5nYW1tYVJlZ3VsYXJpemVyKX0sdD1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9fTtvMS5jbGFzc05hbWU9XCJMYXllck5vcm1hbGl6YXRpb25cIjtuZS5yZWdpc3RlckNsYXNzKG8xKTtmdW5jdGlvbiBJaihlLHQsbil7cmV0dXJuIE8oKCk9PntpZihlLnJhbmshPT00KXRocm93IG5ldyBWKGB0ZW1wb3JhbFBhZGRpbmcgZXhwZWN0cyBpbnB1dCB0ZW5zb3IgdG8gYmUgNC1ELCBidXQgcmVjZWl2ZWQgYSAke2UucmFua30tRCB0ZW5zb3IuYCk7aWYodD09bnVsbCYmKHQ9W1sxLDFdLFsxLDFdXSksdC5sZW5ndGghPT0yfHx0WzBdLmxlbmd0aCE9PTJ8fHRbMV0ubGVuZ3RoIT09Mil0aHJvdyBuZXcgVihcInNwYXRpYWwyZFBhZGRpbmcgZXhwZWN0cyBgcGFkZGluZ2AgdG8gYmUgYW4gQXJyYXkgb2YgdHdvIEFycmF5cywgZWFjaCBvZiB3aGljaCBpcyBhbiBBcnJheSBvZiB0d28gaW50ZWdlcnMuXCIpO2lmKG49PW51bGwmJihuPUdhKCkpLG4hPT1cImNoYW5uZWxzTGFzdFwiJiZuIT09XCJjaGFubmVsc0ZpcnN0XCIpdGhyb3cgbmV3IFYoYFVua25vd24gZGF0YSBmb3JtYXQ6ICR7bn0uIFN1cHBvcnRlZCBkYXRhIGZvcm1hdHMgYXJlICdjaGFubmVsc0xhc3QnIGFuZCAnY2hhbm5lbHNGaXJzdC5gKTtsZXQgYTtyZXR1cm4gbj09PVwiY2hhbm5lbHNGaXJzdFwiP2E9W1swLDBdLFswLDBdLHRbMF0sdFsxXV06YT1bWzAsMF0sdFswXSx0WzFdLFswLDBdXSx4YShlLGEpfSl9dmFyIGwxPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7aWYoZT09bnVsbCYmKGU9e30pLHN1cGVyKGUpLHRoaXMuZGF0YUZvcm1hdD1lLmRhdGFGb3JtYXQ9PW51bGw/R2EoKTplLmRhdGFGb3JtYXQsZS5wYWRkaW5nPT1udWxsKXRoaXMucGFkZGluZz1bWzEsMV0sWzEsMV1dO2Vsc2UgaWYodHlwZW9mIGUucGFkZGluZz09XCJudW1iZXJcIil0aGlzLnBhZGRpbmc9W1tlLnBhZGRpbmcsZS5wYWRkaW5nXSxbZS5wYWRkaW5nLGUucGFkZGluZ11dO2Vsc2V7aWYoZS5wYWRkaW5nPWUucGFkZGluZyxlLnBhZGRpbmcubGVuZ3RoIT09Mil0aHJvdyBuZXcgVihgWmVyb1BhZGRpbmcyRCBleHBlY3RzIHBhZGRpbmcgdG8gYmUgYSBsZW5ndGgtMiBhcnJheSwgYnV0IHJlY2VpdmVkIGEgbGVuZ3RoLSR7ZS5wYWRkaW5nLmxlbmd0aH0gYXJyYXkuYCk7bGV0IHQsbjtpZih0eXBlb2YgZS5wYWRkaW5nWzBdPT1cIm51bWJlclwiKXQ9W2UucGFkZGluZ1swXSxlLnBhZGRpbmdbMF1dLG49W2UucGFkZGluZ1sxXSxlLnBhZGRpbmdbMV1dO2Vsc2V7aWYoZS5wYWRkaW5nPWUucGFkZGluZyxlLnBhZGRpbmdbMF0ubGVuZ3RoIT09Mil0aHJvdyBuZXcgVihgWmVyb1BhZGRpbmcyRCBleHBlY3RzIGhlaWdodCBwYWRkaW5nIHRvIGJlIGEgbGVuZ3RoLTIgYXJyYXksIGJ1dCByZWNlaXZlZCBhIGxlbmd0aC0ke2UucGFkZGluZ1swXS5sZW5ndGh9IGFycmF5LmApO2lmKHQ9ZS5wYWRkaW5nWzBdLGUucGFkZGluZ1sxXS5sZW5ndGghPT0yKXRocm93IG5ldyBWKGBaZXJvUGFkZGluZzJEIGV4cGVjdHMgd2lkdGggcGFkZGluZyB0byBiZSBhIGxlbmd0aC0yIGFycmF5LCBidXQgcmVjZWl2ZWQgYSBsZW5ndGgtJHtlLnBhZGRpbmdbMV0ubGVuZ3RofSBhcnJheS5gKTtuPWUucGFkZGluZ1sxXX10aGlzLnBhZGRpbmc9W3Qsbl19dGhpcy5pbnB1dFNwZWM9W25ldyB6dCh7bmRpbTo0fSldfWNvbXB1dGVPdXRwdXRTaGFwZShlKXtlPUplKGUpO2xldCB0LG47cmV0dXJuIHRoaXMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNGaXJzdFwiPyhlWzJdIT1udWxsJiZlWzJdPj0wP3Q9ZVsyXSt0aGlzLnBhZGRpbmdbMF1bMF0rdGhpcy5wYWRkaW5nWzBdWzFdOnQ9bnVsbCxlWzNdIT1udWxsJiZlWzNdPj0wP249ZVszXSt0aGlzLnBhZGRpbmdbMV1bMF0rdGhpcy5wYWRkaW5nWzFdWzFdOm49bnVsbCxbZVswXSxlWzFdLHQsbl0pOihlWzFdIT1udWxsJiZlWzFdPj0wP3Q9ZVsxXSt0aGlzLnBhZGRpbmdbMF1bMF0rdGhpcy5wYWRkaW5nWzBdWzFdOnQ9bnVsbCxlWzJdIT1udWxsJiZlWzJdPj0wP249ZVsyXSt0aGlzLnBhZGRpbmdbMV1bMF0rdGhpcy5wYWRkaW5nWzFdWzFdOm49bnVsbCxbZVswXSx0LG4sZVszXV0pfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+SWooVGUoZSksdGhpcy5wYWRkaW5nLHRoaXMuZGF0YUZvcm1hdCkpfWdldENvbmZpZygpe2xldCBlPXtwYWRkaW5nOnRoaXMucGFkZGluZyxkYXRhRm9ybWF0OnRoaXMuZGF0YUZvcm1hdH0sdD1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9fTtsMS5jbGFzc05hbWU9XCJaZXJvUGFkZGluZzJEXCI7bmUucmVnaXN0ZXJDbGFzcyhsMSk7ZnVuY3Rpb24gUGYoZSx0LG4sYSxyLHMpe3JldHVybiBPKCgpPT57UnQociksZzIocyksdmEoYSksbj09bnVsbCYmKG49WzEsMV0pLGE9PW51bGwmJihhPVwidmFsaWRcIikscj09bnVsbCYmKHI9R2EoKSkscz09bnVsbCYmKHM9XCJtYXhcIiksZT1fMChlLHIpO2xldCBpLG89YT09PVwic2FtZVwiP1wic2FtZVwiOlwidmFsaWRcIjtyZXR1cm4gcz09PVwibWF4XCI/aT1EdChlLHQsbixvKTppPXlhKGUsdCxuLG8pLHI9PT1cImNoYW5uZWxzRmlyc3RcIiYmKGk9RGUoaSxbMCwzLDEsMl0pKSxpfSl9ZnVuY3Rpb24gd0MoZSx0LG4sYSxyLHMpe3JldHVybiBPKCgpPT57UnQociksZzIocyksdmEoYSksbj09bnVsbCYmKG49WzEsMSwxXSksYT09bnVsbCYmKGE9XCJ2YWxpZFwiKSxyPT1udWxsJiYocj1HYSgpKSxzPT1udWxsJiYocz1cIm1heFwiKSxlPXVDKGUscik7bGV0IGksbz1hPT09XCJzYW1lXCI/XCJzYW1lXCI6XCJ2YWxpZFwiO3JldHVybiBzPT09XCJtYXhcIj9pPXh3KGUsdCxuLG8pOmk9anYoZSx0LG4sbykscj09PVwiY2hhbm5lbHNGaXJzdFwiJiYoaT1EZShpLFswLDQsMSwyLDNdKSksaX0pfXZhciBrQz1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe2lmKGUucG9vbFNpemU9PW51bGwmJihlLnBvb2xTaXplPTIpLHN1cGVyKGUpLHR5cGVvZiBlLnBvb2xTaXplPT1cIm51bWJlclwiKXRoaXMucG9vbFNpemU9W2UucG9vbFNpemVdO2Vsc2UgaWYoQXJyYXkuaXNBcnJheShlLnBvb2xTaXplKSYmZS5wb29sU2l6ZS5sZW5ndGg9PT0xJiZ0eXBlb2YgZS5wb29sU2l6ZVswXT09XCJudW1iZXJcIil0aGlzLnBvb2xTaXplPWUucG9vbFNpemU7ZWxzZSB0aHJvdyBuZXcgVihgcG9vbFNpemUgZm9yIDFEIGNvbnZvbHV0aW9uYWwgbGF5ZXIgbXVzdCBiZSBhIG51bWJlciBvciBhbiBBcnJheSBvZiBhIHNpbmdsZSBudW1iZXIsIGJ1dCByZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KGUucG9vbFNpemUpfWApO2lmKHRuKHRoaXMucG9vbFNpemUsXCJwb29sU2l6ZVwiKSxlLnN0cmlkZXM9PW51bGwpdGhpcy5zdHJpZGVzPXRoaXMucG9vbFNpemU7ZWxzZSBpZih0eXBlb2YgZS5zdHJpZGVzPT1cIm51bWJlclwiKXRoaXMuc3RyaWRlcz1bZS5zdHJpZGVzXTtlbHNlIGlmKEFycmF5LmlzQXJyYXkoZS5zdHJpZGVzKSYmZS5zdHJpZGVzLmxlbmd0aD09PTEmJnR5cGVvZiBlLnN0cmlkZXNbMF09PVwibnVtYmVyXCIpdGhpcy5zdHJpZGVzPWUuc3RyaWRlcztlbHNlIHRocm93IG5ldyBWKGBzdHJpZGVzIGZvciAxRCBjb252b2x1dGlvbmFsIGxheWVyIG11c3QgYmUgYSBudW1iZXIgb3IgYW4gQXJyYXkgb2YgYSBzaW5nbGUgbnVtYmVyLCBidXQgcmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShlLnN0cmlkZXMpfWApO3RuKHRoaXMuc3RyaWRlcyxcInN0cmlkZXNcIiksdGhpcy5wYWRkaW5nPWUucGFkZGluZz09bnVsbD9cInZhbGlkXCI6ZS5wYWRkaW5nLHZhKHRoaXMucGFkZGluZyksdGhpcy5pbnB1dFNwZWM9W25ldyB6dCh7bmRpbTozfSldfWNvbXB1dGVPdXRwdXRTaGFwZShlKXtlPUplKGUpO2xldCB0PVZhKGVbMV0sdGhpcy5wb29sU2l6ZVswXSx0aGlzLnBhZGRpbmcsdGhpcy5zdHJpZGVzWzBdKTtyZXR1cm5bZVswXSx0LGVbMl1dfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e3RoaXMuaW52b2tlQ2FsbEhvb2soZSx0KSxlPXdkKFRlKGUpLDIpO2xldCBuPXRoaXMucG9vbGluZ0Z1bmN0aW9uKFRlKGUpLFt0aGlzLnBvb2xTaXplWzBdLDFdLFt0aGlzLnN0cmlkZXNbMF0sMV0sdGhpcy5wYWRkaW5nLFwiY2hhbm5lbHNMYXN0XCIpO3JldHVybiBBcyhuLFsyXSl9KX1nZXRDb25maWcoKXtsZXQgZT17cG9vbFNpemU6dGhpcy5wb29sU2l6ZSxwYWRkaW5nOnRoaXMucGFkZGluZyxzdHJpZGVzOnRoaXMuc3RyaWRlc30sdD1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9fSx1MT1jbGFzcyBleHRlbmRzIGtDe2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpfXBvb2xpbmdGdW5jdGlvbihlLHQsbixhLHIpe3JldHVybiBSdChyKSx2YShhKSxQZihlLHQsbixhLHIsXCJtYXhcIil9fTt1MS5jbGFzc05hbWU9XCJNYXhQb29saW5nMURcIjtuZS5yZWdpc3RlckNsYXNzKHUxKTt2YXIgcDE9Y2xhc3MgZXh0ZW5kcyBrQ3tjb25zdHJ1Y3RvcihlKXtzdXBlcihlKX1wb29saW5nRnVuY3Rpb24oZSx0LG4sYSxyKXtyZXR1cm4gUnQociksdmEoYSksUGYoZSx0LG4sYSxyLFwiYXZnXCIpfX07cDEuY2xhc3NOYW1lPVwiQXZlcmFnZVBvb2xpbmcxRFwiO25lLnJlZ2lzdGVyQ2xhc3MocDEpO3ZhciBJQz1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe2lmKGUucG9vbFNpemU9PW51bGwmJihlLnBvb2xTaXplPVsyLDJdKSxzdXBlcihlKSx0aGlzLnBvb2xTaXplPUFycmF5LmlzQXJyYXkoZS5wb29sU2l6ZSk/ZS5wb29sU2l6ZTpbZS5wb29sU2l6ZSxlLnBvb2xTaXplXSxlLnN0cmlkZXM9PW51bGwpdGhpcy5zdHJpZGVzPXRoaXMucG9vbFNpemU7ZWxzZSBpZihBcnJheS5pc0FycmF5KGUuc3RyaWRlcykpe2lmKGUuc3RyaWRlcy5sZW5ndGghPT0yKXRocm93IG5ldyBWKGBJZiB0aGUgc3RyaWRlcyBwcm9wZXJ0eSBvZiBhIDJEIHBvb2xpbmcgbGF5ZXIgaXMgYW4gQXJyYXksIGl0IGlzIGV4cGVjdGVkIHRvIGhhdmUgYSBsZW5ndGggb2YgMiwgYnV0IHJlY2VpdmVkIGxlbmd0aCAke2Uuc3RyaWRlcy5sZW5ndGh9LmApO3RoaXMuc3RyaWRlcz1lLnN0cmlkZXN9ZWxzZSB0aGlzLnN0cmlkZXM9W2Uuc3RyaWRlcyxlLnN0cmlkZXNdO3RuKHRoaXMucG9vbFNpemUsXCJwb29sU2l6ZVwiKSx0bih0aGlzLnN0cmlkZXMsXCJzdHJpZGVzXCIpLHRoaXMucGFkZGluZz1lLnBhZGRpbmc9PW51bGw/XCJ2YWxpZFwiOmUucGFkZGluZyx0aGlzLmRhdGFGb3JtYXQ9ZS5kYXRhRm9ybWF0PT1udWxsP1wiY2hhbm5lbHNMYXN0XCI6ZS5kYXRhRm9ybWF0LFJ0KHRoaXMuZGF0YUZvcm1hdCksdmEodGhpcy5wYWRkaW5nKSx0aGlzLmlucHV0U3BlYz1bbmV3IHp0KHtuZGltOjR9KV19Y29tcHV0ZU91dHB1dFNoYXBlKGUpe2U9SmUoZSk7bGV0IHQ9dGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCI/ZVsyXTplWzFdLG49dGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCI/ZVszXTplWzJdO3JldHVybiB0PVZhKHQsdGhpcy5wb29sU2l6ZVswXSx0aGlzLnBhZGRpbmcsdGhpcy5zdHJpZGVzWzBdKSxuPVZhKG4sdGhpcy5wb29sU2l6ZVsxXSx0aGlzLnBhZGRpbmcsdGhpcy5zdHJpZGVzWzFdKSx0aGlzLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzRmlyc3RcIj9bZVswXSxlWzFdLHQsbl06W2VbMF0sdCxuLGVbM11dfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+KHRoaXMuaW52b2tlQ2FsbEhvb2soZSx0KSx0aGlzLnBvb2xpbmdGdW5jdGlvbihUZShlKSx0aGlzLnBvb2xTaXplLHRoaXMuc3RyaWRlcyx0aGlzLnBhZGRpbmcsdGhpcy5kYXRhRm9ybWF0KSkpfWdldENvbmZpZygpe2xldCBlPXtwb29sU2l6ZTp0aGlzLnBvb2xTaXplLHBhZGRpbmc6dGhpcy5wYWRkaW5nLHN0cmlkZXM6dGhpcy5zdHJpZGVzLGRhdGFGb3JtYXQ6dGhpcy5kYXRhRm9ybWF0fSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX19LGMxPWNsYXNzIGV4dGVuZHMgSUN7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSl9cG9vbGluZ0Z1bmN0aW9uKGUsdCxuLGEscil7cmV0dXJuIFJ0KHIpLHZhKGEpLFBmKGUsdCxuLGEscixcIm1heFwiKX19O2MxLmNsYXNzTmFtZT1cIk1heFBvb2xpbmcyRFwiO25lLnJlZ2lzdGVyQ2xhc3MoYzEpO3ZhciBkMT1jbGFzcyBleHRlbmRzIElDe2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpfXBvb2xpbmdGdW5jdGlvbihlLHQsbixhLHIpe3JldHVybiBSdChyKSx2YShhKSxQZihlLHQsbixhLHIsXCJhdmdcIil9fTtkMS5jbGFzc05hbWU9XCJBdmVyYWdlUG9vbGluZzJEXCI7bmUucmVnaXN0ZXJDbGFzcyhkMSk7dmFyIFNDPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7aWYoZS5wb29sU2l6ZT09bnVsbCYmKGUucG9vbFNpemU9WzIsMiwyXSksc3VwZXIoZSksdGhpcy5wb29sU2l6ZT1BcnJheS5pc0FycmF5KGUucG9vbFNpemUpP2UucG9vbFNpemU6W2UucG9vbFNpemUsZS5wb29sU2l6ZSxlLnBvb2xTaXplXSxlLnN0cmlkZXM9PW51bGwpdGhpcy5zdHJpZGVzPXRoaXMucG9vbFNpemU7ZWxzZSBpZihBcnJheS5pc0FycmF5KGUuc3RyaWRlcykpe2lmKGUuc3RyaWRlcy5sZW5ndGghPT0zKXRocm93IG5ldyBWKGBJZiB0aGUgc3RyaWRlcyBwcm9wZXJ0eSBvZiBhIDNEIHBvb2xpbmcgbGF5ZXIgaXMgYW4gQXJyYXksIGl0IGlzIGV4cGVjdGVkIHRvIGhhdmUgYSBsZW5ndGggb2YgMywgYnV0IHJlY2VpdmVkIGxlbmd0aCAke2Uuc3RyaWRlcy5sZW5ndGh9LmApO3RoaXMuc3RyaWRlcz1lLnN0cmlkZXN9ZWxzZSB0aGlzLnN0cmlkZXM9W2Uuc3RyaWRlcyxlLnN0cmlkZXMsZS5zdHJpZGVzXTt0bih0aGlzLnBvb2xTaXplLFwicG9vbFNpemVcIiksdG4odGhpcy5zdHJpZGVzLFwic3RyaWRlc1wiKSx0aGlzLnBhZGRpbmc9ZS5wYWRkaW5nPT1udWxsP1widmFsaWRcIjplLnBhZGRpbmcsdGhpcy5kYXRhRm9ybWF0PWUuZGF0YUZvcm1hdD09bnVsbD9cImNoYW5uZWxzTGFzdFwiOmUuZGF0YUZvcm1hdCxSdCh0aGlzLmRhdGFGb3JtYXQpLHZhKHRoaXMucGFkZGluZyksdGhpcy5pbnB1dFNwZWM9W25ldyB6dCh7bmRpbTo1fSldfWNvbXB1dGVPdXRwdXRTaGFwZShlKXtlPUplKGUpO2xldCB0PXRoaXMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNGaXJzdFwiP2VbMl06ZVsxXSxuPXRoaXMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNGaXJzdFwiP2VbM106ZVsyXSxhPXRoaXMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNGaXJzdFwiP2VbNF06ZVszXTtyZXR1cm4gdD1WYSh0LHRoaXMucG9vbFNpemVbMF0sdGhpcy5wYWRkaW5nLHRoaXMuc3RyaWRlc1swXSksbj1WYShuLHRoaXMucG9vbFNpemVbMV0sdGhpcy5wYWRkaW5nLHRoaXMuc3RyaWRlc1sxXSksYT1WYShhLHRoaXMucG9vbFNpemVbMl0sdGhpcy5wYWRkaW5nLHRoaXMuc3RyaWRlc1syXSksdGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCI/W2VbMF0sZVsxXSx0LG4sYV06W2VbMF0sdCxuLGEsZVs0XV19Y2FsbChlLHQpe3JldHVybiBPKCgpPT4odGhpcy5pbnZva2VDYWxsSG9vayhlLHQpLHRoaXMucG9vbGluZ0Z1bmN0aW9uKFRlKGUpLHRoaXMucG9vbFNpemUsdGhpcy5zdHJpZGVzLHRoaXMucGFkZGluZyx0aGlzLmRhdGFGb3JtYXQpKSl9Z2V0Q29uZmlnKCl7bGV0IGU9e3Bvb2xTaXplOnRoaXMucG9vbFNpemUscGFkZGluZzp0aGlzLnBhZGRpbmcsc3RyaWRlczp0aGlzLnN0cmlkZXMsZGF0YUZvcm1hdDp0aGlzLmRhdGFGb3JtYXR9LHQ9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfX0saDE9Y2xhc3MgZXh0ZW5kcyBTQ3tjb25zdHJ1Y3RvcihlKXtzdXBlcihlKX1wb29saW5nRnVuY3Rpb24oZSx0LG4sYSxyKXtyZXR1cm4gUnQociksdmEoYSksd0MoZSx0LG4sYSxyLFwibWF4XCIpfX07aDEuY2xhc3NOYW1lPVwiTWF4UG9vbGluZzNEXCI7bmUucmVnaXN0ZXJDbGFzcyhoMSk7dmFyIG0xPWNsYXNzIGV4dGVuZHMgU0N7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSl9cG9vbGluZ0Z1bmN0aW9uKGUsdCxuLGEscil7cmV0dXJuIFJ0KHIpLHZhKGEpLHdDKGUsdCxuLGEscixcImF2Z1wiKX19O20xLmNsYXNzTmFtZT1cIkF2ZXJhZ2VQb29saW5nM0RcIjtuZS5yZWdpc3RlckNsYXNzKG0xKTt2YXIgTkM9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLmlucHV0U3BlYz1bbmV3IHp0KHtuZGltOjN9KV19Y29tcHV0ZU91dHB1dFNoYXBlKGUpe3JldHVybltlWzBdLGVbMl1dfWNhbGwoZSx0KXt0aHJvdyBuZXcgemV9fSxmMT1jbGFzcyBleHRlbmRzIE5De2NvbnN0cnVjdG9yKGUpe3N1cGVyKGV8fHt9KX1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbj1UZShlKTtyZXR1cm4gQ3QobiwxKX0pfX07ZjEuY2xhc3NOYW1lPVwiR2xvYmFsQXZlcmFnZVBvb2xpbmcxRFwiO25lLnJlZ2lzdGVyQ2xhc3MoZjEpO3ZhciBnMT1jbGFzcyBleHRlbmRzIE5De2NvbnN0cnVjdG9yKGUpe3N1cGVyKGV8fHt9KX1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbj1UZShlKTtyZXR1cm4gbWEobiwxKX0pfX07ZzEuY2xhc3NOYW1lPVwiR2xvYmFsTWF4UG9vbGluZzFEXCI7bmUucmVnaXN0ZXJDbGFzcyhnMSk7dmFyIFRDPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksdGhpcy5kYXRhRm9ybWF0PWUuZGF0YUZvcm1hdD09bnVsbD9cImNoYW5uZWxzTGFzdFwiOmUuZGF0YUZvcm1hdCxSdCh0aGlzLmRhdGFGb3JtYXQpLHRoaXMuaW5wdXRTcGVjPVtuZXcgenQoe25kaW06NH0pXX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7cmV0dXJuIGU9ZSx0aGlzLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzTGFzdFwiP1tlWzBdLGVbM11dOltlWzBdLGVbMV1dfWNhbGwoZSx0KXt0aHJvdyBuZXcgemV9Z2V0Q29uZmlnKCl7bGV0IGU9e2RhdGFGb3JtYXQ6dGhpcy5kYXRhRm9ybWF0fSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX19LGIxPWNsYXNzIGV4dGVuZHMgVEN7Y2FsbChlLHQpe3JldHVybiBPKCgpPT57bGV0IG49VGUoZSk7cmV0dXJuIHRoaXMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNMYXN0XCI/Q3QobixbMSwyXSk6Q3QobixbMiwzXSl9KX19O2IxLmNsYXNzTmFtZT1cIkdsb2JhbEF2ZXJhZ2VQb29saW5nMkRcIjtuZS5yZWdpc3RlckNsYXNzKGIxKTt2YXIgeTE9Y2xhc3MgZXh0ZW5kcyBUQ3tjYWxsKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbj1UZShlKTtyZXR1cm4gdGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0xhc3RcIj9tYShuLFsxLDJdKTptYShuLFsyLDNdKX0pfX07eTEuY2xhc3NOYW1lPVwiR2xvYmFsTWF4UG9vbGluZzJEXCI7bmUucmVnaXN0ZXJDbGFzcyh5MSk7dmFyIENDPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksdGhpcy5sYXllcj1lLmxheWVyfWJ1aWxkKGUpe3RoaXMuYnVpbHQ9ITB9Z2V0IHRyYWluYWJsZSgpe3JldHVybiB0aGlzLmxheWVyIT1udWxsP3RoaXMubGF5ZXIudHJhaW5hYmxlOiExfXNldCB0cmFpbmFibGUoZSl7dGhpcy5sYXllciE9bnVsbCYmKHRoaXMubGF5ZXIudHJhaW5hYmxlPWUpfWdldCB0cmFpbmFibGVXZWlnaHRzKCl7cmV0dXJuIHRoaXMubGF5ZXIudHJhaW5hYmxlV2VpZ2h0c31nZXQgbm9uVHJhaW5hYmxlV2VpZ2h0cygpe3JldHVybiB0aGlzLmxheWVyLm5vblRyYWluYWJsZVdlaWdodHN9Z2V0IHVwZGF0ZXMoKXtyZXR1cm4gdGhpcy5sYXllci5fdXBkYXRlc31nZXQgbG9zc2VzKCl7cmV0dXJuIHRoaXMubGF5ZXIubG9zc2VzfWdldFdlaWdodHMoKXtyZXR1cm4gdGhpcy5sYXllci5nZXRXZWlnaHRzKCl9c2V0V2VpZ2h0cyhlKXt0aGlzLmxheWVyLnNldFdlaWdodHMoZSl9Z2V0Q29uZmlnKCl7bGV0IGU9e2xheWVyOntjbGFzc05hbWU6dGhpcy5sYXllci5nZXRDbGFzc05hbWUoKSxjb25maWc6dGhpcy5sYXllci5nZXRDb25maWcoKX19LHQ9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfXNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQoZSl7c3VwZXIuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZChlKSx0aGlzLmxheWVyIT1udWxsJiZ0aGlzLmxheWVyLnNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQoZSl9c3RhdGljIGZyb21Db25maWcoZSx0LG49e30pe2xldCBhPXQubGF5ZXIscj1CYShhLG4pO2RlbGV0ZSB0LmxheWVyO2xldCBzPXtsYXllcjpyfTtyZXR1cm4gT2JqZWN0LmFzc2lnbihzLHQpLG5ldyBlKHMpfX0seDE9Y2xhc3MgZXh0ZW5kcyBDQ3tjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLnN1cHBvcnRzTWFza2luZz0hMH1idWlsZChlKXtpZihlPUplKGUpLGUubGVuZ3RoPDMpdGhyb3cgbmV3IFYoYFRpbWVEaXN0cmlidXRlZCBsYXllciBleHBlY3RzIGFuIGlucHV0IHNoYXBlID49IDNELCBidXQgcmVjZWl2ZWQgaW5wdXQgc2hhcGUgJHtKU09OLnN0cmluZ2lmeShlKX1gKTt0aGlzLmlucHV0U3BlYz1be3NoYXBlOmV9XTtsZXQgdD1bZVswXV0uY29uY2F0KGUuc2xpY2UoMikpO3RoaXMubGF5ZXIuYnVpbHR8fCh0aGlzLmxheWVyLmJ1aWxkKHQpLHRoaXMubGF5ZXIuYnVpbHQ9ITApLHN1cGVyLmJ1aWxkKGUpfWNvbXB1dGVPdXRwdXRTaGFwZShlKXtlPUplKGUpO2xldCB0PVtlWzBdXS5jb25jYXQoZS5zbGljZSgyKSksbj10aGlzLmxheWVyLmNvbXB1dGVPdXRwdXRTaGFwZSh0KSxhPWVbMV07cmV0dXJuW25bMF0sYV0uY29uY2F0KG4uc2xpY2UoMSkpfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+KGU9VGUoZSkseUMoKG4sYSk9PltUZSh0aGlzLmxheWVyLmNhbGwobix0KSksW11dLGUsW10sITEsbnVsbCxudWxsLCExLCEwKVsxXSkpfX07eDEuY2xhc3NOYW1lPVwiVGltZURpc3RyaWJ1dGVkXCI7bmUucmVnaXN0ZXJDbGFzcyh4MSk7ZnVuY3Rpb24gU2ooZSl7S28oSUcsXCJCaWRpcmVjdGlvbmFsTWVyZ2VNb2RlXCIsZSl9dmFyIE5qPVwiY29uY2F0XCIsdjE9Y2xhc3MgZXh0ZW5kcyBDQ3tjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTtsZXQgdD1lLmxheWVyLmdldENvbmZpZygpLG49e307bi5jbGFzc05hbWU9ZS5sYXllci5nZXRDbGFzc05hbWUoKSxuLmNvbmZpZz10LHRoaXMuZm9yd2FyZExheWVyPUJhKG4pLHQuZ29CYWNrd2FyZHM9dC5nb0JhY2t3YXJkcyE9PSEwO2xldCBhPXt9O2lmKGEuY2xhc3NOYW1lPWUubGF5ZXIuZ2V0Q2xhc3NOYW1lKCksYS5jb25maWc9dCx0aGlzLmJhY2t3YXJkTGF5ZXI9QmEoYSksdGhpcy5mb3J3YXJkTGF5ZXIubmFtZT1cImZvcndhcmRfXCIrdGhpcy5mb3J3YXJkTGF5ZXIubmFtZSx0aGlzLmJhY2t3YXJkTGF5ZXIubmFtZT1cImJhY2t3YXJkX1wiK3RoaXMuYmFja3dhcmRMYXllci5uYW1lLHRoaXMubWVyZ2VNb2RlPWUubWVyZ2VNb2RlPT09dm9pZCAwP05qOmUubWVyZ2VNb2RlLFNqKHRoaXMubWVyZ2VNb2RlKSxlLndlaWdodHMpdGhyb3cgbmV3IHplKFwid2VpZ2h0cyBzdXBwb3J0IGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgQmlkaXJlY3Rpb25hbCBsYXllciB5ZXQuXCIpO3RoaXMuX3N0YXRlZnVsPWUubGF5ZXIuc3RhdGVmdWwsdGhpcy5yZXR1cm5TZXF1ZW5jZXM9ZS5sYXllci5yZXR1cm5TZXF1ZW5jZXMsdGhpcy5yZXR1cm5TdGF0ZT1lLmxheWVyLnJldHVyblN0YXRlLHRoaXMuc3VwcG9ydHNNYXNraW5nPSEwLHRoaXMuX3RyYWluYWJsZT0hMCx0aGlzLmlucHV0U3BlYz1lLmxheWVyLmlucHV0U3BlYyx0aGlzLm51bUNvbnN0YW50cz1udWxsfWdldCB0cmFpbmFibGUoKXtyZXR1cm4gdGhpcy5fdHJhaW5hYmxlfXNldCB0cmFpbmFibGUoZSl7dGhpcy5fdHJhaW5hYmxlPWUsdGhpcy5mb3J3YXJkTGF5ZXIhPW51bGwmJih0aGlzLmZvcndhcmRMYXllci50cmFpbmFibGU9ZSksdGhpcy5iYWNrd2FyZExheWVyIT1udWxsJiYodGhpcy5iYWNrd2FyZExheWVyLnRyYWluYWJsZT1lKX1nZXRXZWlnaHRzKCl7cmV0dXJuIHRoaXMuZm9yd2FyZExheWVyLmdldFdlaWdodHMoKS5jb25jYXQodGhpcy5iYWNrd2FyZExheWVyLmdldFdlaWdodHMoKSl9c2V0V2VpZ2h0cyhlKXtsZXQgdD1lLmxlbmd0aCxuPU1hdGguZmxvb3IodC8yKTt0aGlzLmZvcndhcmRMYXllci5zZXRXZWlnaHRzKGUuc2xpY2UoMCxuKSksdGhpcy5iYWNrd2FyZExheWVyLnNldFdlaWdodHMoZS5zbGljZShuKSl9Y29tcHV0ZU91dHB1dFNoYXBlKGUpe2xldCB0PXRoaXMuZm9yd2FyZExheWVyLmNvbXB1dGVPdXRwdXRTaGFwZShlKTtBcnJheS5pc0FycmF5KHQpJiZBcnJheS5pc0FycmF5KHRbMF0pfHwodD1bdF0pLHQ9dDtsZXQgbixhLHI7cmV0dXJuIHRoaXMucmV0dXJuU3RhdGUmJihyPXQuc2xpY2UoMSkpLG49dFswXSxuPW4sdGhpcy5tZXJnZU1vZGU9PT1cImNvbmNhdFwiPyhuW24ubGVuZ3RoLTFdKj0yLGE9W25dKTp0aGlzLm1lcmdlTW9kZT09bnVsbD9hPVtuLG4uc2xpY2UoKV06YT1bbl0sdGhpcy5yZXR1cm5TdGF0ZT90aGlzLm1lcmdlTW9kZT09bnVsbD9hLmNvbmNhdChyKS5jb25jYXQoci5zbGljZSgpKTpbbl0uY29uY2F0KHIpLmNvbmNhdChyLnNsaWNlKCkpOk1uKGEpfWFwcGx5KGUsdCl7bGV0IG49dD09bnVsbD9udWxsOnQuaW5pdGlhbFN0YXRlLGE9dD09bnVsbD9udWxsOnQuY29uc3RhbnRzO3Q9PW51bGwmJih0PXt9KTtsZXQgcj1iQyhlLG4sYSx0aGlzLm51bUNvbnN0YW50cyk7aWYoZT1yLmlucHV0cyxuPXIuaW5pdGlhbFN0YXRlLGE9ci5jb25zdGFudHMsQXJyYXkuaXNBcnJheShlKSYmKG49ZS5zbGljZSgxKSxlPWVbMF0pLChuPT1udWxsfHxuLmxlbmd0aD09PTApJiZhPT1udWxsKXJldHVybiBzdXBlci5hcHBseShlLHQpO2xldCBzPVtdLGk9W107aWYobiE9bnVsbCl7bGV0IGw9bi5sZW5ndGg7aWYobCUyPjApdGhyb3cgbmV3IFYoXCJXaGVuIHBhc3NpbmcgYGluaXRpYWxTdGF0ZWAgdG8gYSBCaWRyZWN0aW9uYWwgUk5OLCB0aGUgc3RhdGUgc2hvdWxkIGJlIGFuIEFycmF5IGNvbnRhaW5pbmcgdGhlIHN0YXRlcyBvZiB0aGUgdW5kZXJseWluZyBSTk5zLlwiKTt0LmluaXRpYWxTdGF0ZT1uLHMucHVzaCguLi5uKTtsZXQgdT1uLm1hcChwPT5uZXcgenQoe3NoYXBlOnAuc2hhcGV9KSk7dGhpcy5mb3J3YXJkTGF5ZXIuc3RhdGVTcGVjPXUuc2xpY2UoMCxsLzIpLHRoaXMuYmFja3dhcmRMYXllci5zdGF0ZVNwZWM9dS5zbGljZShsLzIpLGkucHVzaCguLi51KX1pZihhIT1udWxsKXRocm93IG5ldyB6ZShcIlN1cHBvcnQgZm9yIGNvbnN0YW50cyBpbiBCaWRpcmVjdGlvbmFsIGxheWVycyBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtsZXQgbz1zWzBdaW5zdGFuY2VvZiBIYTtmb3IobGV0IGwgb2YgcylpZihsIGluc3RhbmNlb2YgSGEhPT1vKXRocm93IG5ldyBWKFwiVGhlIGluaXRpYWwgc3RhdGUgb2YgYSBCaWRpcmVjdGlvbmFsIGxheWVyIGNhbm5vdCBiZSBzcGVjaWZpZWQgYXMgYSBtaXggb2Ygc3ltYm9saWMgYW5kIG5vbi1zeW1ib2xpYyB0ZW5zb3JzXCIpO2lmKG8pe2xldCBsPVtlXS5jb25jYXQocyksdT10aGlzLmlucHV0U3BlYy5jb25jYXQoaSkscD10aGlzLmlucHV0U3BlYzt0aGlzLmlucHV0U3BlYz11O2xldCBkPXN1cGVyLmFwcGx5KGwsdCk7cmV0dXJuIHRoaXMuaW5wdXRTcGVjPXAsZH1lbHNlIHJldHVybiBzdXBlci5hcHBseShlLHQpfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e2xldCBuPXQuaW5pdGlhbFN0YXRlLGEscjtpZihuPT1udWxsKWE9dGhpcy5mb3J3YXJkTGF5ZXIuY2FsbChlLHQpLHI9dGhpcy5iYWNrd2FyZExheWVyLmNhbGwoZSx0KTtlbHNle2xldCBvPW4uc2xpY2UoMCxuLmxlbmd0aC8yKSxsPW4uc2xpY2Uobi5sZW5ndGgvMik7YT10aGlzLmZvcndhcmRMYXllci5jYWxsKGUsT2JqZWN0LmFzc2lnbih0LHtpbml0aWFsU3RhdGU6b30pKSxyPXRoaXMuYmFja3dhcmRMYXllci5jYWxsKGUsT2JqZWN0LmFzc2lnbih0LHtpbml0aWFsU3RhdGU6bH0pKX1sZXQgczt0aGlzLnJldHVyblN0YXRlJiYoQXJyYXkuaXNBcnJheShhKSYmKHM9YS5zbGljZSgxKS5jb25jYXQoci5zbGljZSgxKSkpLGE9YVswXSxyPXJbMF0pLHRoaXMucmV0dXJuU2VxdWVuY2VzJiYocj1iYShyLDEpKTtsZXQgaTtyZXR1cm4gdGhpcy5tZXJnZU1vZGU9PT1cImNvbmNhdFwiP2k9dDAoW2Escl0pOnRoaXMubWVyZ2VNb2RlPT09XCJzdW1cIj9pPVgoYSxyKTp0aGlzLm1lcmdlTW9kZT09PVwiYXZlXCI/aT16KC41LFgoYSxyKSk6dGhpcy5tZXJnZU1vZGU9PT1cIm11bFwiP2k9eihhLHIpOnRoaXMubWVyZ2VNb2RlPT1udWxsJiYoaT1bYSxyXSksdGhpcy5yZXR1cm5TdGF0ZT90aGlzLm1lcmdlTW9kZT09bnVsbD9pLmNvbmNhdChzKTpbaV0uY29uY2F0KHMpOml9KX1yZXNldFN0YXRlcyhlKXt0aGlzLmZvcndhcmRMYXllci5yZXNldFN0YXRlcygpLHRoaXMuYmFja3dhcmRMYXllci5yZXNldFN0YXRlcygpfWJ1aWxkKGUpe3JpKHRoaXMuZm9yd2FyZExheWVyLm5hbWUsKCk9Pnt0aGlzLmZvcndhcmRMYXllci5idWlsZChlKX0pLHJpKHRoaXMuYmFja3dhcmRMYXllci5uYW1lLCgpPT57dGhpcy5iYWNrd2FyZExheWVyLmJ1aWxkKGUpfSksdGhpcy5idWlsdD0hMH1jb21wdXRlTWFzayhlLHQpe0FycmF5LmlzQXJyYXkodCkmJih0PXRbMF0pO2xldCBuO2lmKHRoaXMucmV0dXJuU2VxdWVuY2VzP3RoaXMubWVyZ2VNb2RlPT1udWxsP249W3QsdF06bj10OnRoaXMubWVyZ2VNb2RlPT1udWxsP249W251bGwsbnVsbF06bj1udWxsLHRoaXMucmV0dXJuU3RhdGUpe2xldCBhPXRoaXMuZm9yd2FyZExheWVyLnN0YXRlcy5tYXAocj0+bnVsbCk7cmV0dXJuIEFycmF5LmlzQXJyYXkobik/bi5jb25jYXQoYSkuY29uY2F0KGEpOltuXS5jb25jYXQoYSkuY29uY2F0KGEpfWVsc2UgcmV0dXJuIG59Z2V0IHRyYWluYWJsZVdlaWdodHMoKXtyZXR1cm4gdGhpcy5mb3J3YXJkTGF5ZXIudHJhaW5hYmxlV2VpZ2h0cy5jb25jYXQodGhpcy5iYWNrd2FyZExheWVyLnRyYWluYWJsZVdlaWdodHMpfWdldCBub25UcmFpbmFibGVXZWlnaHRzKCl7cmV0dXJuIHRoaXMuZm9yd2FyZExheWVyLm5vblRyYWluYWJsZVdlaWdodHMuY29uY2F0KHRoaXMuYmFja3dhcmRMYXllci5ub25UcmFpbmFibGVXZWlnaHRzKX1zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkKGUpe3N1cGVyLnNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQoZSksdGhpcy5mb3J3YXJkTGF5ZXIhPW51bGwmJnRoaXMuZm9yd2FyZExheWVyLnNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQoZSksdGhpcy5iYWNrd2FyZExheWVyIT1udWxsJiZ0aGlzLmJhY2t3YXJkTGF5ZXIuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZChlKX1nZXRDb25maWcoKXtsZXQgZT17bWVyZ2VNb2RlOnRoaXMubWVyZ2VNb2RlfSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX1zdGF0aWMgZnJvbUNvbmZpZyhlLHQpe2xldCBuPUJhKHQubGF5ZXIpO2lmKGRlbGV0ZSB0LmxheWVyLHQubnVtQ29uc3RhbnRzIT1udWxsKXRocm93IG5ldyB6ZShcIkRlc2VyaWFsaXphdGlvbiBvZiBhIEJpZGlyZWN0aW9uYWwgbGF5ZXIgd2l0aCBudW1Db25zdGFudHMgcHJlc2VudCBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik7bGV0IGE9dDtyZXR1cm4gYS5sYXllcj1uLG5ldyBlKGEpfX07djEuY2xhc3NOYW1lPVwiQmlkaXJlY3Rpb25hbFwiO25lLnJlZ2lzdGVyQ2xhc3ModjEpO3ZhciB3MT1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLHRoaXMuc2NhbGU9ZS5zY2FsZSxlLm9mZnNldD90aGlzLm9mZnNldD1lLm9mZnNldDp0aGlzLm9mZnNldD0wfWdldENvbmZpZygpe2xldCBlPXtzY2FsZTp0aGlzLnNjYWxlLG9mZnNldDp0aGlzLm9mZnNldH0sdD1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9Y2FsbChlLHQpe3JldHVybiBPKCgpPT4oZT1UZShlKSxlLmR0eXBlIT09XCJmbG9hdDMyXCImJihlPWlyKGUsXCJmbG9hdDMyXCIpKSxYKHooZSx0aGlzLnNjYWxlKSx0aGlzLm9mZnNldCkpKX19O3cxLmNsYXNzTmFtZT1cIlJlc2NhbGluZ1wiO25lLnJlZ2lzdGVyQ2xhc3ModzEpO3ZhcntyZXNpemVCaWxpbmVhcjpUaixjcm9wQW5kUmVzaXplOkNqfT1abixrMT1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLHRoaXMuaGVpZ2h0PWUuaGVpZ2h0LHRoaXMud2lkdGg9ZS53aWR0aH1jZW50ZXJDcm9wKGUsdCxuLGEscixzLGksbyl7cmV0dXJuIE8oKCk9PntsZXQgbCx1PSExLHA9dC9zLGQ9bi9pLGM9KGErdCkvcyxoPShyK24pL2ksbT1bcCxkLGMsaF0sZj1bXTtlLnJhbms9PT0zPyh1PSEwLGw9QXQoW2VdKSk6bD1lO2ZvcihsZXQgeD0wO3g8bC5zaGFwZVswXTt4KyspZi5wdXNoKG0pO2xldCBnPWJuKGYsW2YubGVuZ3RoLDRdKSxiPWdpKDAsZi5sZW5ndGgsMSxcImludDMyXCIpLHk9Q2oobCxnLGIsW2Escl0sXCJuZWFyZXN0XCIpO3JldHVybiBpcih1P1RlKGR0KHkpKTp5LG8pfSl9dXBzaXplKGUsdCxuLGEpe3JldHVybiBPKCgpPT57bGV0IHI9VGooZSxbdCxuXSk7cmV0dXJuIGlyKHIsYSl9KX1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbj1UZShlKSxhPW4uZHR5cGUscj1uLnNoYXBlLHM9cltyLmxlbmd0aC0zXSxpPXJbci5sZW5ndGgtMl0sbz0wO3MhPT10aGlzLmhlaWdodCYmKG89TWF0aC5mbG9vcigocy10aGlzLmhlaWdodCkvMikpO2xldCBsPTA7cmV0dXJuIGkhPT10aGlzLndpZHRoJiYobD1NYXRoLmZsb29yKChpLXRoaXMud2lkdGgpLzIpLGw9PT0wJiYobD0xKSksbz49MCYmbD49MD90aGlzLmNlbnRlckNyb3AobixvLGwsdGhpcy5oZWlnaHQsdGhpcy53aWR0aCxzLGksYSk6dGhpcy51cHNpemUoZSx0aGlzLmhlaWdodCx0aGlzLndpZHRoLGEpfSl9Z2V0Q29uZmlnKCl7bGV0IGU9e2hlaWdodDp0aGlzLmhlaWdodCx3aWR0aDp0aGlzLndpZHRofSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7ZT1KZShlKTtsZXQgdD1lLmxlbmd0aC0zLG49ZS5sZW5ndGgtMjtyZXR1cm4gZVt0XT10aGlzLmhlaWdodCxlW25dPXRoaXMud2lkdGgsZX19O2sxLmNsYXNzTmFtZT1cIkNlbnRlckNyb3BcIjtuZS5yZWdpc3RlckNsYXNzKGsxKTtmdW5jdGlvbiBFaihlLHQsbixhKXtsZXQgcj1UZShlKTtpZihyLmR0eXBlIT09XCJpbnQzMlwiJiYocj1pcihyLFwiaW50MzJcIikpLHQ9PT1cImludFwiKXJldHVybiByO2xldCBzPXIuc2hhcGU7aWYoci5yYW5rPT09MCYmKHI9R3QociwtMSkpLHQ9PT1cIm9uZUhvdFwiJiZyLnNoYXBlW3Iuc2hhcGUubGVuZ3RoLTFdIT09MSYmKHI9R3QociwtMSkpLHIucmFuaz4yKXRocm93IG5ldyBWKGBXaGVuIG91dHB1dE1vZGUgaXMgbm90IGludCwgbWF4aW11bSBvdXRwdXQgcmFuayBpcyAyIFJlY2VpdmVkIG91dHB1dE1vZGUgJHt0fSBhbmQgaW5wdXQgc2hhcGUgJHtzfSB3aGljaCB3b3VsZCByZXN1bHQgaW4gb3V0cHV0IHJhbmsgJHtyLnJhbmt9LmApO2xldCBpPVtcIm11bHRpSG90XCIsXCJvbmVIb3RcIl0uaW5jbHVkZXModCksbz1yLGw7aWYodHlwZW9mIGEhPVwidW5kZWZpbmVkXCImJnQ9PT1cImNvdW50XCI/bD1YaChvLGEsbixpKTpsPVhoKG8sW10sbixpKSx0IT09XCJ0ZklkZlwiKXJldHVybiBsO2lmKGEpcmV0dXJuIHoobCxhKTt0aHJvdyBuZXcgVihcIldoZW4gb3V0cHV0TW9kZSBpcyAndGZJZGYnLCB3ZWlnaHRzIG11c3QgYmUgcHJvdmlkZWQuXCIpfXZhciBJMT1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLHRoaXMubnVtVG9rZW5zPWUubnVtVG9rZW5zLGUub3V0cHV0TW9kZT90aGlzLm91dHB1dE1vZGU9ZS5vdXRwdXRNb2RlOnRoaXMub3V0cHV0TW9kZT1cIm11bHRpSG90XCJ9Z2V0Q29uZmlnKCl7bGV0IGU9e251bVRva2Vuczp0aGlzLm51bVRva2VucyxvdXRwdXRNb2RlOnRoaXMub3V0cHV0TW9kZX0sdD1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9Y29tcHV0ZU91dHB1dFNoYXBlKGUpe3JldHVybiBlPUplKGUpLGU9PW51bGw/W3RoaXMubnVtVG9rZW5zXTp0aGlzLm91dHB1dE1vZGU9PT1cIm9uZUhvdFwiJiZlW2UubGVuZ3RoLTFdIT09MT8oZS5wdXNoKHRoaXMubnVtVG9rZW5zKSxlKTooZVtlLmxlbmd0aC0xXT10aGlzLm51bVRva2VucyxlKX1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9PntlPVRlKGUpLGUuZHR5cGUhPT1cImludDMyXCImJihlPWlyKGUsXCJpbnQzMlwiKSk7bGV0IG47aWYodHlwZW9mIHQuY291bnRXZWlnaHRzIT1cInVuZGVmaW5lZFwiKXtpZih0aGlzLm91dHB1dE1vZGUhPT1cImNvdW50XCIpdGhyb3cgbmV3IFYoYGNvdW50V2VpZ2h0cyBpcyBub3QgdXNlZCB3aGVuIG91dHB1dE1vZGUgIT09IGNvdW50LlxuICAgICAgICAgICAgICBSZWNlaXZlZCBjb3VudFdlaWdodHM9JHt0LmNvdW50V2VpZ2h0c31gKTtuPVRlKHQuY291bnRXZWlnaHRzKX1sZXQgYT1tYShlKSxyPU9sKGUpLHM9Q24odGhpcy5udW1Ub2tlbnMsYSkuYnVmZmVyU3luYygpLmdldCgwKSxpPSRyKHIsMCkuYnVmZmVyU3luYygpLmdldCgwKTtpZighKHMmJmkpKXRocm93IG5ldyBWKGBJbnB1dCB2YWx1ZXMgbXVzdCBiZSBiZXR3ZWVuIDAgPCB2YWx1ZXMgPD0gbnVtVG9rZW5zIHdpdGggbnVtVG9rZW5zPSR7dGhpcy5udW1Ub2tlbnN9YCk7cmV0dXJuIEVqKGUsdGhpcy5vdXRwdXRNb2RlLHRoaXMubnVtVG9rZW5zLG4pfSl9fTtJMS5jbGFzc05hbWU9XCJDYXRlZ29yeUVuY29kaW5nXCI7bmUucmVnaXN0ZXJDbGFzcyhJMSk7dmFyIF9qPVtcImJpbGluZWFyXCIsXCJuZWFyZXN0XCJdLFJJPW5ldyBTZXQoX2opLFMxPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7aWYoc3VwZXIoZSksdGhpcy5oZWlnaHQ9ZS5oZWlnaHQsdGhpcy53aWR0aD1lLndpZHRoLGUuaW50ZXJwb2xhdGlvbilpZihSSS5oYXMoZS5pbnRlcnBvbGF0aW9uKSl0aGlzLmludGVycG9sYXRpb249ZS5pbnRlcnBvbGF0aW9uO2Vsc2UgdGhyb3cgbmV3IFYoYEludmFsaWQgaW50ZXJwb2xhdGlvbiBwYXJhbWV0ZXI6ICR7ZS5pbnRlcnBvbGF0aW9ufSBpcyBub3QgaW1wbGVtZW50ZWRgKTtlbHNlIHRoaXMuaW50ZXJwb2xhdGlvbj1cImJpbGluZWFyXCI7dGhpcy5jcm9wVG9Bc3BlY3RSYXRpbz0hIWUuY3JvcFRvQXNwZWN0UmF0aW99Y29tcHV0ZU91dHB1dFNoYXBlKGUpe2U9SmUoZSk7bGV0IHQ9ZVsyXTtyZXR1cm5bdGhpcy5oZWlnaHQsdGhpcy53aWR0aCx0XX1nZXRDb25maWcoKXtsZXQgZT17aGVpZ2h0OnRoaXMuaGVpZ2h0LHdpZHRoOnRoaXMud2lkdGgsaW50ZXJwb2xhdGlvbjp0aGlzLmludGVycG9sYXRpb24sY3JvcFRvQXNwZWN0UmF0aW86dGhpcy5jcm9wVG9Bc3BlY3RSYXRpb30sdD1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9Y2FsbChlLHQpe3JldHVybiBPKCgpPT57bGV0IG49W3RoaXMuaGVpZ2h0LHRoaXMud2lkdGhdO2lmKHRoaXMuaW50ZXJwb2xhdGlvbj09PVwiYmlsaW5lYXJcIilyZXR1cm4gWm4ucmVzaXplQmlsaW5lYXIoZSxuLCF0aGlzLmNyb3BUb0FzcGVjdFJhdGlvKTtpZih0aGlzLmludGVycG9sYXRpb249PT1cIm5lYXJlc3RcIilyZXR1cm4gWm4ucmVzaXplTmVhcmVzdE5laWdoYm9yKGUsbiwhdGhpcy5jcm9wVG9Bc3BlY3RSYXRpbyk7dGhyb3cgbmV3IEVycm9yKGBJbnRlcnBvbGF0aW9uIGlzICR7dGhpcy5pbnRlcnBvbGF0aW9ufSBidXQgb25seSAke1suLi5SSV19IGFyZSBzdXBwb3J0ZWRgKX0pfX07UzEuY2xhc3NOYW1lPVwiUmVzaXppbmdcIjtuZS5yZWdpc3RlckNsYXNzKFMxKTt2YXIgRUM9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5zZWVkPWV9bmV4dCgpe2lmKHRoaXMuc2VlZCE9PXZvaWQgMClyZXR1cm4gdGhpcy5zZWVkKyt9fTtFQy5jbGFzc05hbWU9XCJSYW5kb21TZWVkXCI7dmFyIF9DPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksdGhpcy5yYW5kb21HZW5lcmF0b3I9bmV3IEVDKGUuc2VlZCl9Z2V0Q29uZmlnKCl7bGV0IGU9e3NlZWQ6dGhpcy5yYW5kb21HZW5lcmF0b3Iuc2VlZH0sdD1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9fTtfQy5jbGFzc05hbWU9XCJCYXNlUmFuZG9tTGF5ZXJcIjt2YXIgQWo9W1wiYmlsaW5lYXJcIixcIm5lYXJlc3RcIl0sTUk9bmV3IFNldChBaiksTjE9Y2xhc3MgZXh0ZW5kcyBfQ3tjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTtsZXR7ZmFjdG9yOnQsaW50ZXJwb2xhdGlvbjpuPVwiYmlsaW5lYXJcIn09ZTtpZih0aGlzLmZhY3Rvcj10LEFycmF5LmlzQXJyYXkodGhpcy5mYWN0b3IpJiZ0aGlzLmZhY3Rvci5sZW5ndGg9PT0yKXRoaXMud2lkdGhMb3dlcj10aGlzLmZhY3RvclswXSx0aGlzLndpZHRoVXBwZXI9dGhpcy5mYWN0b3JbMV07ZWxzZSBpZighQXJyYXkuaXNBcnJheSh0aGlzLmZhY3RvcikmJnRoaXMuZmFjdG9yPjApdGhpcy53aWR0aExvd2VyPS10aGlzLmZhY3Rvcix0aGlzLndpZHRoVXBwZXI9dGhpcy5mYWN0b3I7ZWxzZSB0aHJvdyBuZXcgVihgSW52YWxpZCBmYWN0b3I6ICR7dGhpcy5mYWN0b3J9LiBNdXN0IGJlIHBvc2l0aXZlIG51bWJlciBvciB0dXBsZSBvZiAyIG51bWJlcnNgKTtpZih0aGlzLndpZHRoTG93ZXI8LTF8fHRoaXMud2lkdGhVcHBlcjwtMSl0aHJvdyBuZXcgVihgZmFjdG9yIG11c3QgaGF2ZSB2YWx1ZXMgbGFyZ2VyIHRoYW4gLTEuIEdvdDogJHt0aGlzLmZhY3Rvcn1gKTtpZih0aGlzLndpZHRoVXBwZXI8dGhpcy53aWR0aExvd2VyKXRocm93IG5ldyBWKGBmYWN0b3IgY2Fubm90IGhhdmUgdXBwZXIgYm91bmQgbGVzcyB0aGFuIGxvd2VyIGJvdW5kLlxuICAgICAgICBHb3QgdXBwZXIgYm91bmQ6ICR7dGhpcy53aWR0aFVwcGVyfS5cbiAgICAgICAgR290IGxvd2VyIGJvdW5kOiAke3RoaXMud2lkdGhMb3dlcn1cbiAgICAgIGApO2lmKG4paWYoTUkuaGFzKG4pKXRoaXMuaW50ZXJwb2xhdGlvbj1uO2Vsc2UgdGhyb3cgbmV3IFYoYEludmFsaWQgaW50ZXJwb2xhdGlvbiBwYXJhbWV0ZXI6ICR7bn0gaXMgbm90IGltcGxlbWVudGVkYCl9Z2V0Q29uZmlnKCl7bGV0IGU9e2ZhY3Rvcjp0aGlzLmZhY3RvcixpbnRlcnBvbGF0aW9uOnRoaXMuaW50ZXJwb2xhdGlvbn0sdD1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9Y29tcHV0ZU91dHB1dFNoYXBlKGUpe2U9SmUoZSk7bGV0IHQ9ZVsyXTtyZXR1cm5bdGhpcy5pbWdIZWlnaHQsLTEsdF19Y2FsbChlLHQpe3JldHVybiBPKCgpPT57bGV0IG49VGUoZSk7dGhpcy5pbWdIZWlnaHQ9bi5zaGFwZVtuLnNoYXBlLmxlbmd0aC0zXTtsZXQgYT1uLnNoYXBlW24uc2hhcGUubGVuZ3RoLTJdO3RoaXMud2lkdGhGYWN0b3I9RXMoWzFdLDErdGhpcy53aWR0aExvd2VyLDErdGhpcy53aWR0aFVwcGVyLFwiZmxvYXQzMlwiLHRoaXMucmFuZG9tR2VuZXJhdG9yLm5leHQoKSk7bGV0IHI9dGhpcy53aWR0aEZhY3Rvci5kYXRhU3luYygpWzBdKmE7cj1NYXRoLnJvdW5kKHIpO2xldCBzPVt0aGlzLmltZ0hlaWdodCxyXTtzd2l0Y2godGhpcy5pbnRlcnBvbGF0aW9uKXtjYXNlXCJiaWxpbmVhclwiOnJldHVybiBabi5yZXNpemVCaWxpbmVhcihlLHMpO2Nhc2VcIm5lYXJlc3RcIjpyZXR1cm4gWm4ucmVzaXplTmVhcmVzdE5laWdoYm9yKGUscyk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYEludGVycG9sYXRpb24gaXMgJHt0aGlzLmludGVycG9sYXRpb259XG4gICAgICAgICAgYnV0IG9ubHkgJHtbLi4uTUldfSBhcmUgc3VwcG9ydGVkYCl9fSl9fTtOMS5jbGFzc05hbWU9XCJSYW5kb21XaWR0aFwiO25lLnJlZ2lzdGVyQ2xhc3MoTjEpO2Z1bmN0aW9uIEZqKGUpe3JldHVybiBuZXcgcnAoZSl9ZnVuY3Rpb24gJGooZSl7cmV0dXJuIG5ldyBUMChlKX1mdW5jdGlvbiBEaihlKXtyZXR1cm4gbmV3IEkwKGUpfWZ1bmN0aW9uIFJqKGUpe3JldHVybiBuZXcgUzAoZSl9ZnVuY3Rpb24gTWooZSl7cmV0dXJuIG5ldyBOMChlKX1mdW5jdGlvbiBPaihlKXtyZXR1cm4gbmV3IEUwKGUpfWZ1bmN0aW9uIFBqKGUpe3JldHVybiBuZXcgQzAoZSl9ZnVuY3Rpb24gTGooZSl7cmV0dXJuIG5ldyBEMChlKX1mdW5jdGlvbiB6aihlKXtyZXR1cm4gbmV3IEFmKGUpfWZ1bmN0aW9uIFdqKGUpe3JldHVybiBuZXcgQTAoZSl9ZnVuY3Rpb24gQmooZSl7cmV0dXJuIG5ldyBGZihlKX1mdW5jdGlvbiBWaihlKXtyZXR1cm4gbmV3IEYwKGUpfWZ1bmN0aW9uIFVqKGUpe3JldHVybiBuZXcgJDAoZSl9ZnVuY3Rpb24gR2ooZSl7cmV0dXJuIG5ldyBSMChlKX1mdW5jdGlvbiBIaihlKXtyZXR1cm4gbmV3IE0wKGUpfWZ1bmN0aW9uIGpqKGUpe3JldHVybiBuZXcgTzAoZSl9ZnVuY3Rpb24gcWooZSl7cmV0dXJuIG5ldyBHMChlKX1mdW5jdGlvbiBLaihlKXtyZXR1cm4gbmV3IFYwKGUpfWZ1bmN0aW9uIFhqKGUpe3JldHVybiBuZXcgT2YoZSl9ZnVuY3Rpb24gWWooZSl7cmV0dXJuIG5ldyBCMChlKX1mdW5jdGlvbiBaaihlKXtyZXR1cm4gbmV3IFUwKGUpfWZ1bmN0aW9uIEpqKGUpe3JldHVybiBuZXcgSDAoZSl9ZnVuY3Rpb24gUWooZSl7cmV0dXJuIG5ldyBqMChlKX1mdW5jdGlvbiBlNihlKXtyZXR1cm4gbmV3IHEwKGUpfWZ1bmN0aW9uIHQ2KGUpe3JldHVybiBuZXcgWDAoZSl9ZnVuY3Rpb24gbjYoZSl7cmV0dXJuIG5ldyBZMChlKX1mdW5jdGlvbiBhNihlKXtyZXR1cm4gbmV3IEowKGUpfWZ1bmN0aW9uIHI2KGUpe3JldHVybiBuZXcgdDEoZSl9ZnVuY3Rpb24gczYoZSl7cmV0dXJuIG5ldyBRMChlKX1mdW5jdGlvbiBpNihlKXtyZXR1cm4gbmV3IGUxKGUpfWZ1bmN0aW9uIG82KGUpe3JldHVybiBuZXcgWjAoZSl9ZnVuY3Rpb24gbDYoZSl7cmV0dXJuIG5ldyBuMShlKX1mdW5jdGlvbiB1NihlKXtyZXR1cm4gbmV3IGkxKGUpfWZ1bmN0aW9uIHA2KGUpe3JldHVybiBuZXcgbzEoZSl9ZnVuY3Rpb24gYzYoZSl7cmV0dXJuIG5ldyBsMShlKX1mdW5jdGlvbiBUMShlKXtyZXR1cm4gbmV3IHAxKGUpfWZ1bmN0aW9uIGQ2KGUpe3JldHVybiBUMShlKX1mdW5jdGlvbiBoNihlKXtyZXR1cm4gVDEoZSl9ZnVuY3Rpb24gQzEoZSl7cmV0dXJuIG5ldyBkMShlKX1mdW5jdGlvbiBtNihlKXtyZXR1cm4gQzEoZSl9ZnVuY3Rpb24gZjYoZSl7cmV0dXJuIEMxKGUpfWZ1bmN0aW9uIEUxKGUpe3JldHVybiBuZXcgbTEoZSl9ZnVuY3Rpb24gZzYoZSl7cmV0dXJuIEUxKGUpfWZ1bmN0aW9uIGI2KGUpe3JldHVybiBFMShlKX1mdW5jdGlvbiB5NihlKXtyZXR1cm4gbmV3IGYxKGUpfWZ1bmN0aW9uIHg2KGUpe3JldHVybiBuZXcgYjEoZSl9ZnVuY3Rpb24gQUMoZSl7cmV0dXJuIG5ldyBnMShlKX1mdW5jdGlvbiBGQyhlKXtyZXR1cm4gbmV3IHkxKGUpfWZ1bmN0aW9uICRDKGUpe3JldHVybiBuZXcgdTEoZSl9ZnVuY3Rpb24gREMoZSl7cmV0dXJuIG5ldyBjMShlKX1mdW5jdGlvbiB2NihlKXtyZXR1cm4gbmV3IGgxKGUpfWZ1bmN0aW9uIHc2KGUpe3JldHVybiBuZXcgTDAoZSl9ZnVuY3Rpb24gazYoZSl7cmV0dXJuIG5ldyBEZihlKX1mdW5jdGlvbiBJNihlKXtyZXR1cm4gbmV3IHowKGUpfWZ1bmN0aW9uIFM2KGUpe3JldHVybiBuZXcgQ2QoZSl9ZnVuY3Rpb24gTjYoZSl7cmV0dXJuIG5ldyBQMChlKX1mdW5jdGlvbiBUNihlKXtyZXR1cm4gbmV3ICRmKGUpfWZ1bmN0aW9uIEM2KGUpe3JldHVybiBuZXcgVzAoZSl9ZnVuY3Rpb24gRTYoZSl7cmV0dXJuIG5ldyBNZihlKX1mdW5jdGlvbiBfNihlKXtyZXR1cm4gbmV3IE1yKGUpfWZ1bmN0aW9uIEE2KGUpe3JldHVybiBuZXcgUmYoZSl9ZnVuY3Rpb24gRjYoZSl7cmV0dXJuIG5ldyB2MShlKX1mdW5jdGlvbiAkNihlKXtyZXR1cm4gbmV3IHgxKGUpfXZhciBENj1BQyxSNj1GQyxNNj0kQyxPNj1EQztmdW5jdGlvbiBQNihlKXtyZXR1cm4gbmV3IGExKGUpfWZ1bmN0aW9uIEw2KGUpe3JldHVybiBuZXcgcjEoZSl9ZnVuY3Rpb24gejYoZSl7cmV0dXJuIG5ldyBzMShlKX1mdW5jdGlvbiBXNihlKXtyZXR1cm4gbmV3IEswKGUpfWZ1bmN0aW9uIEI2KGUpe3JldHVybiBuZXcgdzEoZSl9ZnVuY3Rpb24gVjYoZSl7cmV0dXJuIG5ldyBrMShlKX1mdW5jdGlvbiBVNihlKXtyZXR1cm4gbmV3IFMxKGUpfWZ1bmN0aW9uIEc2KGUpe3JldHVybiBuZXcgSTEoZSl9ZnVuY3Rpb24gSDYoZSl7cmV0dXJuIG5ldyBOMShlKX12YXIgUkM9e307X2UoUkMse01BUEU6KCk9Pm5xLE1TRTooKT0+c3EsYmluYXJ5QWNjdXJhY3k6KCk9Pmo2LGJpbmFyeUNyb3NzZW50cm9weTooKT0+cTYsY2F0ZWdvcmljYWxBY2N1cmFjeTooKT0+WDYsY2F0ZWdvcmljYWxDcm9zc2VudHJvcHk6KCk9Plk2LGNvc2luZVByb3hpbWl0eTooKT0+UTYsbWFwZTooKT0+YXEsbWVhbkFic29sdXRlRXJyb3I6KCk9PmVxLG1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcjooKT0+dHEsbWVhblNxdWFyZWRFcnJvcjooKT0+cnEsbXNlOigpPT5pcSxwcmVjaXNpb246KCk9Plo2LHIyU2NvcmU6KCk9Pm9xLHJlY2FsbDooKT0+SjYsc3BhcnNlQ2F0ZWdvcmljYWxBY2N1cmFjeTooKT0+SzZ9KTtmdW5jdGlvbiBqNihlLHQpe3JldHVybiBiMChlLHQpfWZ1bmN0aW9uIHE2KGUsdCl7cmV0dXJuIFAyKGUsdCl9ZnVuY3Rpb24gSzYoZSx0KXtyZXR1cm4gTDIoZSx0KX1mdW5jdGlvbiBYNihlLHQpe3JldHVybiB5MChlLHQpfWZ1bmN0aW9uIFk2KGUsdCl7cmV0dXJuIHgwKGUsdCl9ZnVuY3Rpb24gWjYoZSx0KXtyZXR1cm4gTzIoZSx0KX1mdW5jdGlvbiBKNihlLHQpe3JldHVybiBfSChlLHQpfWZ1bmN0aW9uIFE2KGUsdCl7cmV0dXJuIGcwKGUsdCl9ZnVuY3Rpb24gZXEoZSx0KXtyZXR1cm4gVGYoZSx0KX1mdW5jdGlvbiB0cShlLHQpe3JldHVybiBzcChlLHQpfWZ1bmN0aW9uIG5xKGUsdCl7cmV0dXJuIHNwKGUsdCl9ZnVuY3Rpb24gYXEoZSx0KXtyZXR1cm4gc3AoZSx0KX1mdW5jdGlvbiBycShlLHQpe3JldHVybiBYbyhlLHQpfWZ1bmN0aW9uIHNxKGUsdCl7cmV0dXJuIFhvKGUsdCl9ZnVuY3Rpb24gaXEoZSx0KXtyZXR1cm4gWG8oZSx0KX1mdW5jdGlvbiBvcShlLHQpe3JldHVybiBBSChlLHQpfXZhciBNQz17fTtfZShNQyx7bW9kZWxGcm9tSlNPTjooKT0+aWp9KTt2YXIgT0M9e307X2UoT0Mse2wxOigpPT51cSxsMWwyOigpPT5scSxsMjooKT0+cHF9KTtmdW5jdGlvbiBscShlKXtyZXR1cm4gbmV3IE5kKGUpfWZ1bmN0aW9uIHVxKGUpe3JldHVybiBoaihlKX1mdW5jdGlvbiBwcShlKXtyZXR1cm4gbWooZSl9dmFyIFBDPWNsYXNzIGV4dGVuZHMgR2x7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMubW9kZWw9bnVsbH1zZXRNb2RlbChlKXtpZighKGUgaW5zdGFuY2VvZiBFcikpdGhyb3cgbmV3IEVycm9yKFwibW9kZWwgbXVzdCBiZSBhIExheWVyc01vZGVsLCBub3Qgc29tZSBvdGhlciBDb250YWluZXJcIik7dGhpcy5tb2RlbD1lfX07ZnVuY3Rpb24gTmgoZSx0KXtyZXR1cm4gZTx0fWZ1bmN0aW9uIE9JKGUsdCl7cmV0dXJuIGU+dH12YXIgTEM9Y2xhc3MgZXh0ZW5kcyBQQ3tjb25zdHJ1Y3RvcihlKXtpZihzdXBlcigpLGU9PW51bGwmJihlPXt9KSxlLnJlc3RvcmVCZXN0V2VpZ2h0cyl0aHJvdyBuZXcgemUoXCJyZXN0b3JlQmVzdFdlaWdodHMgPSBUcnVlIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBFYXJseVN0b3BwaW5nIHlldC5cIik7dGhpcy5tb25pdG9yPWUubW9uaXRvcnx8XCJ2YWxfbG9zc1wiLHRoaXMubWluRGVsdGE9TWF0aC5hYnMoZS5taW5EZWx0YXx8MCksdGhpcy5wYXRpZW5jZT1lLnBhdGllbmNlfHwwLHRoaXMudmVyYm9zZT1lLnZlcmJvc2V8fDAsdGhpcy5tb2RlPWUubW9kZXx8XCJhdXRvXCIsdGhpcy5iYXNlbGluZT1lLmJhc2VsaW5lLFtcImF1dG9cIixcIm1pblwiLFwibWF4XCJdLmluZGV4T2YodGhpcy5tb2RlKT09PS0xJiYoY29uc29sZS53YXJuKGBFYXJseVN0b3BwaW5nIG1vZGUgJyR7dGhpcy5tb2RlfScgaXMgaW52YWxpZC4gRmFsbGluZyBiYWNrIHRvIG1vZGUgJ2F1dG8nLmApLHRoaXMubW9kZT1cImF1dG9cIiksdGhpcy5tb2RlPT09XCJtaW5cIj90aGlzLm1vbml0b3JGdW5jPU5oOnRoaXMubW9kZT09PVwibWF4XCI/dGhpcy5tb25pdG9yRnVuYz1PSTp0aGlzLm1vbml0b3IuaW5kZXhPZihcImFjY1wiKSE9PS0xP3RoaXMubW9uaXRvckZ1bmM9T0k6dGhpcy5tb25pdG9yRnVuYz1OaCx0aGlzLm1vbml0b3JGdW5jPT09TmgmJih0aGlzLm1pbkRlbHRhKj0tMSl9YXN5bmMgb25UcmFpbkJlZ2luKGUpe3RoaXMud2FpdD0wLHRoaXMuc3RvcHBlZEVwb2NoPTAsdGhpcy5iYXNlbGluZSE9bnVsbD90aGlzLmJlc3Q9dGhpcy5iYXNlbGluZTp0aGlzLmJlc3Q9dGhpcy5tb25pdG9yRnVuYz09PU5oPzEvMDotMS8wfWFzeW5jIG9uRXBvY2hFbmQoZSx0KXthd2FpdCBLcih0KTtsZXQgbj10aGlzLmdldE1vbml0b3JWYWx1ZSh0KTtuIT1udWxsJiYodGhpcy5tb25pdG9yRnVuYyhuLXRoaXMubWluRGVsdGEsdGhpcy5iZXN0KT8odGhpcy5iZXN0PW4sdGhpcy53YWl0PTApOih0aGlzLndhaXQrKyx0aGlzLndhaXQ+PXRoaXMucGF0aWVuY2UmJih0aGlzLnN0b3BwZWRFcG9jaD1lLHRoaXMubW9kZWwuc3RvcFRyYWluaW5nPSEwKSkpfWFzeW5jIG9uVHJhaW5FbmQoZSl7dGhpcy5zdG9wcGVkRXBvY2g+MCYmdGhpcy52ZXJib3NlJiZjb25zb2xlLmxvZyhgRXBvY2ggJHt0aGlzLnN0b3BwZWRFcG9jaH06IGVhcmx5IHN0b3BwaW5nLmApfWdldE1vbml0b3JWYWx1ZShlKXtlPT1udWxsJiYoZT17fSk7bGV0IHQ9ZVt0aGlzLm1vbml0b3JdO3JldHVybiB0PT1udWxsJiZjb25zb2xlLndhcm4oYE1ldHJpYyBmb3IgRWFybHlTdG9wcGluZyAke3RoaXMubW9uaXRvcn0gaXMgbm90IGF2YWlsYWJsZS4gQXZhaWxhYmxlIG1ldHJpY3MgYXJlOiAke09iamVjdC5rZXlzKGUpfWApLHR9fTtmdW5jdGlvbiBjcShlKXtyZXR1cm4gbmV3IExDKGUpfXZhciBkcT17ZWFybHlTdG9wcGluZzpjcX0saHE9RygpO2hxLnJlZ2lzdGVyRmxhZyhcIktFRVBfSU5URVJNRURJQVRFX1RFTlNPUlNcIiwoKT0+ITEsZT0+e2UmJmNvbnNvbGUud2FybihcIktlZXAgaW50ZXJtZWRpYXRlIHRlbnNvcnMgaXMgT04uIFRoaXMgd2lsbCBwcmludCB0aGUgdmFsdWVzIG9mIGFsbCBpbnRlcm1lZGlhdGUgdGVuc29ycyBkdXJpbmcgbW9kZWwgaW5mZXJlbmNlLiBOb3QgYWxsIG1vZGVscyBzdXBwb3J0IHRoaXMgbW9kZS4gRm9yIGRldGFpbHMsIGNoZWNrIGUyZS9iZW5jaG1hcmtzLyBtb2RlbF9jb25maWcuanMuIFRoaXMgc2lnbmlmaWNhbnRseSBpbXBhY3RzIHBlcmZvcm1hbmNlLlwiKX0pO3ZhciBxbjsoZnVuY3Rpb24oZSl7ZVtlLkRUX0lOVkFMSUQ9MF09XCJEVF9JTlZBTElEXCIsZVtlLkRUX0ZMT0FUPTFdPVwiRFRfRkxPQVRcIixlW2UuRFRfRE9VQkxFPTJdPVwiRFRfRE9VQkxFXCIsZVtlLkRUX0lOVDMyPTNdPVwiRFRfSU5UMzJcIixlW2UuRFRfVUlOVDg9NF09XCJEVF9VSU5UOFwiLGVbZS5EVF9JTlQxNj01XT1cIkRUX0lOVDE2XCIsZVtlLkRUX0lOVDg9Nl09XCJEVF9JTlQ4XCIsZVtlLkRUX1NUUklORz03XT1cIkRUX1NUUklOR1wiLGVbZS5EVF9DT01QTEVYNjQ9OF09XCJEVF9DT01QTEVYNjRcIixlW2UuRFRfSU5UNjQ9OV09XCJEVF9JTlQ2NFwiLGVbZS5EVF9CT09MPTEwXT1cIkRUX0JPT0xcIixlW2UuRFRfUUlOVDg9MTFdPVwiRFRfUUlOVDhcIixlW2UuRFRfUVVJTlQ4PTEyXT1cIkRUX1FVSU5UOFwiLGVbZS5EVF9RSU5UMzI9MTNdPVwiRFRfUUlOVDMyXCIsZVtlLkRUX0JGTE9BVDE2PTE0XT1cIkRUX0JGTE9BVDE2XCIsZVtlLkRUX1FJTlQxNj0xNV09XCJEVF9RSU5UMTZcIixlW2UuRFRfUVVJTlQxNj0xNl09XCJEVF9RVUlOVDE2XCIsZVtlLkRUX1VJTlQxNj0xN109XCJEVF9VSU5UMTZcIixlW2UuRFRfQ09NUExFWDEyOD0xOF09XCJEVF9DT01QTEVYMTI4XCIsZVtlLkRUX0hBTEY9MTldPVwiRFRfSEFMRlwiLGVbZS5EVF9SRVNPVVJDRT0yMF09XCJEVF9SRVNPVVJDRVwiLGVbZS5EVF9WQVJJQU5UPTIxXT1cIkRUX1ZBUklBTlRcIixlW2UuRFRfVUlOVDMyPTIyXT1cIkRUX1VJTlQzMlwiLGVbZS5EVF9VSU5UNjQ9MjNdPVwiRFRfVUlOVDY0XCIsZVtlLkRUX0ZMT0FUX1JFRj0xMDFdPVwiRFRfRkxPQVRfUkVGXCIsZVtlLkRUX0RPVUJMRV9SRUY9MTAyXT1cIkRUX0RPVUJMRV9SRUZcIixlW2UuRFRfSU5UMzJfUkVGPTEwM109XCJEVF9JTlQzMl9SRUZcIixlW2UuRFRfVUlOVDhfUkVGPTEwNF09XCJEVF9VSU5UOF9SRUZcIixlW2UuRFRfSU5UMTZfUkVGPTEwNV09XCJEVF9JTlQxNl9SRUZcIixlW2UuRFRfSU5UOF9SRUY9MTA2XT1cIkRUX0lOVDhfUkVGXCIsZVtlLkRUX1NUUklOR19SRUY9MTA3XT1cIkRUX1NUUklOR19SRUZcIixlW2UuRFRfQ09NUExFWDY0X1JFRj0xMDhdPVwiRFRfQ09NUExFWDY0X1JFRlwiLGVbZS5EVF9JTlQ2NF9SRUY9MTA5XT1cIkRUX0lOVDY0X1JFRlwiLGVbZS5EVF9CT09MX1JFRj0xMTBdPVwiRFRfQk9PTF9SRUZcIixlW2UuRFRfUUlOVDhfUkVGPTExMV09XCJEVF9RSU5UOF9SRUZcIixlW2UuRFRfUVVJTlQ4X1JFRj0xMTJdPVwiRFRfUVVJTlQ4X1JFRlwiLGVbZS5EVF9RSU5UMzJfUkVGPTExM109XCJEVF9RSU5UMzJfUkVGXCIsZVtlLkRUX0JGTE9BVDE2X1JFRj0xMTRdPVwiRFRfQkZMT0FUMTZfUkVGXCIsZVtlLkRUX1FJTlQxNl9SRUY9MTE1XT1cIkRUX1FJTlQxNl9SRUZcIixlW2UuRFRfUVVJTlQxNl9SRUY9MTE2XT1cIkRUX1FVSU5UMTZfUkVGXCIsZVtlLkRUX1VJTlQxNl9SRUY9MTE3XT1cIkRUX1VJTlQxNl9SRUZcIixlW2UuRFRfQ09NUExFWDEyOF9SRUY9MTE4XT1cIkRUX0NPTVBMRVgxMjhfUkVGXCIsZVtlLkRUX0hBTEZfUkVGPTExOV09XCJEVF9IQUxGX1JFRlwiLGVbZS5EVF9SRVNPVVJDRV9SRUY9MTIwXT1cIkRUX1JFU09VUkNFX1JFRlwiLGVbZS5EVF9WQVJJQU5UX1JFRj0xMjFdPVwiRFRfVkFSSUFOVF9SRUZcIixlW2UuRFRfVUlOVDMyX1JFRj0xMjJdPVwiRFRfVUlOVDMyX1JFRlwiLGVbZS5EVF9VSU5UNjRfUkVGPTEyM109XCJEVF9VSU5UNjRfUkVGXCJ9KShxbnx8KHFuPXt9KSk7dmFyIFBJOyhmdW5jdGlvbihlKXtsZXQgdDsoZnVuY3Rpb24obil7bltuLkxFR0FDWT0wXT1cIkxFR0FDWVwiLG5bbi5WMT0xXT1cIlYxXCIsbltuLlYyPTJdPVwiVjJcIn0pKHQ9ZS5DaGVja3BvaW50Rm9ybWF0VmVyc2lvbnx8KGUuQ2hlY2twb2ludEZvcm1hdFZlcnNpb249e30pKX0pKFBJfHwoUEk9e30pKTt2YXIgXzE9e307ZnVuY3Rpb24gbXEoZSx0KXtsZXQgbj17dGZPcE5hbWU6ZSxjYXRlZ29yeTpcImN1c3RvbVwiLGlucHV0czpbXSxhdHRyczpbXSxjdXN0b21FeGVjdXRvcjp0fTtfMVtlXT1ufWZ1bmN0aW9uIHpDKGUpe3JldHVybiBfMVtlXX1mdW5jdGlvbiBmcShlKXtkZWxldGUgXzFbZV19ZnVuY3Rpb24gayhlLHQsbixhLHIpe2xldCBzPXQuaW5wdXRQYXJhbXNbZV07aWYocyYmcy5pbnB1dEluZGV4U3RhcnQhPT12b2lkIDApe2xldCBvPXMuaW5wdXRJbmRleFN0YXJ0LGw9cy5pbnB1dEluZGV4RW5kPT09MD92b2lkIDA6cy5pbnB1dEluZGV4RW5kPT09dm9pZCAwP28rMTpzLmlucHV0SW5kZXhFbmQsdT1vPDA/dC5pbnB1dE5hbWVzLmxlbmd0aCtvOm87aWYocy50eXBlPT09XCJ0ZW5zb3JcIilyZXR1cm4gcG4odC5pbnB1dE5hbWVzW3VdLG4sYSxyKTtpZihzLnR5cGU9PT1cInRlbnNvcnNcIil7bGV0IGM9dC5pbnB1dHMuc2xpY2UobyxsKTtyZXR1cm4gdC5pbnB1dE5hbWVzLnNsaWNlKG8sbCkuZmlsdGVyKChoLG0pPT57dmFyIGY7cmV0dXJuKChmPWNbbV0pPT09bnVsbHx8Zj09PXZvaWQgMD92b2lkIDA6Zi5vcCkhPT1cIk5vT3BcIn0pLm1hcChoPT5wbihoLG4sYSxyKSl9bGV0IHA9cG4odC5pbnB1dE5hbWVzW3VdLG4sYSxyKSxkPXAuZGF0YVN5bmMoKTtyZXR1cm4gcy50eXBlPT09XCJudW1iZXJcIj9kWzBdOncudG9OZXN0ZWRBcnJheShwLnNoYXBlLGQpfWxldCBpPXQuYXR0clBhcmFtc1tlXTtyZXR1cm4gaSYmaS52YWx1ZX1mdW5jdGlvbiBwbihlLHQsbixhKXtsZXRbcixzXT1YbihlLG4pO2lmKGEhPW51bGwpe2xldCBvPWEuZ2V0SGFzaFRhYmxlSGFuZGxlQnlOYW1lKHIpO2lmKG8hPW51bGwpcmV0dXJuIG99bGV0IGk9bi5jdXJyZW50Q29udGV4dElkcy5maW5kKG89PiEhdFtpbShyLG8pXSk7cmV0dXJuIGkhPT12b2lkIDA/dFtpbShyLGkpXVtzXTp2b2lkIDB9ZnVuY3Rpb24gTEkoZSx0LG4pe3JldHVybiB0W2ltKGUsbi5jdXJyZW50Q29udGV4dElkKV19ZnVuY3Rpb24gU3IoZSx0KXtsZXRbbixhLHJdPVhuKGUsdCk7cmV0dXJuW2ltKG4sdCYmdC5jdXJyZW50Q29udGV4dElkKSxhLHJdfWZ1bmN0aW9uIGltKGUsdCl7cmV0dXJuIHQ/YCR7ZX0tJHt0fWA6ZX1mdW5jdGlvbiBYbihlLHQpe2lmKGU9PT1cIlwiKXJldHVybltcIlwiLDAsdm9pZCAwXTtsZXQgbj10IT1udWxsJiZ0LnBhcnNlTm9kZU5hbWVDYWNoZSE9bnVsbDtpZihuKXtsZXQgcz10LnBhcnNlTm9kZU5hbWVDYWNoZS5nZXQoZSk7aWYocyE9bnVsbClyZXR1cm4gc31sZXQgYT1lLnNwbGl0KFwiOlwiKSxyO2lmKGEubGVuZ3RoPT09MSlyPVtlLDAsdm9pZCAwXTtlbHNle2xldCBzPWFbMF0saT1hLmxlbmd0aD09PTM/YVsxXTp2b2lkIDAsbz1OdW1iZXIoYVthLmxlbmd0aC0xXSk7cj1bcyxvLGldfXJldHVybiBuJiZ0LnBhcnNlTm9kZU5hbWVDYWNoZS5zZXQoZSxyKSxyfWZ1bmN0aW9uIE1oKGUsdCxuKXtsZXQgYT1rKFwicGFkXCIsZSx0LG4pO2lmKGE9PT1cImV4cGxpY2l0XCIpe2E9ayhcImV4cGxpY2l0UGFkZGluZ3NcIixlLHQsbik7bGV0IHI9W1swLDBdLFswLDBdLFswLDBdLFswLDBdXTtmb3IobGV0IHM9MDtzPDQ7cysrKXJbc11bMF09YVtzKjJdLHJbc11bMV09YVtzKjIrMV07cmV0dXJuIHJ9cmV0dXJuIGF9ZnVuY3Rpb24gTnIoZSl7cmV0dXJuIGUua2VwdD9lOnNyKGUpfXZhciBXQz17fTtfZShXQyx7anNvbjooKT0+Z3F9KTt2YXIgZ3E9W3t0Zk9wTmFtZTpcIkFkZFwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkFkZFYyXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQWRkTlwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsZW5kOjAsbmFtZTpcInRlbnNvcnNcIix0eXBlOlwidGVuc29yc1wifV19LHt0Zk9wTmFtZTpcIkJpYXNBZGRcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlN1YlwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJlYWxEaXZcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJEaXZcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJEaXZOb05hblwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkZsb29yRGl2XCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTXVsXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTWF4aW11bVwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk1pbmltdW1cIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJQb3dcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTcXVhcmVkRGlmZmVyZW5jZVwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk1vZFwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkZsb29yTW9kXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX1dLEJDPXt9O19lKEJDLHtqc29uOigpPT5icX0pO3ZhciBicT1be3RmT3BOYW1lOlwiQWJzXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBY29zXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBc2luXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBdGFuXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBdGFuMlwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJ5XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkNlaWxcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkNsaXBCeVZhbHVlXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImNsaXBWYWx1ZU1pblwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjIsbmFtZTpcImNsaXBWYWx1ZU1heFwiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJDb21wbGV4XCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwicmVhbFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImltYWdcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQ29tcGxleEFic1wiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQ29zXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJDb3NoXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJFbHVcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkV4cFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRmxvb3JcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxvZ1wiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiSW1hZ1wiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJUb3V0XCIsbmFtZTpcIm91dHB1dFR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTmVnXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSZWFsXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcIlRvdXRcIixuYW1lOlwib3V0cHV0VHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJQcmVsdVwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJhbHBoYVwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSZWx1XCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSZWx1NlwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU2VsdVwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU2lnbW9pZFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU2luXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTaW5oXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTcXJ0XCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSc3FydFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU3F1YXJlXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJUYW5cIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlRhbmhcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNpZ25cIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJvdW5kXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJFeHBtMVwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTG9nMXBcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJlY2lwcm9jYWxcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNvZnRwbHVzXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBc2luaFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQWNvc2hcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkF0YW5oXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJFcmZcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxlYWt5UmVsdVwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImFscGhhXCIsbmFtZTpcImFscGhhXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTouMn0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiSXNOYW5cIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIklzRmluaXRlXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJJc0luZlwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX1dLFZDPXt9O19lKFZDLHtqc29uOigpPT55cX0pO3ZhciB5cT1be3RmT3BOYW1lOlwiRW1wdHlUZW5zb3JMaXN0XCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiZWxlbWVudFNoYXBlXCIsdHlwZTpcInNoYXBlXCJ9LHtzdGFydDoxLG5hbWU6XCJtYXhOdW1FbGVtZW50c1wiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZWxlbWVudF9kdHlwZVwiLG5hbWU6XCJlbGVtZW50RFR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJMb29wQ29uZFwiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInByZWRcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiU3dpdGNoXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiZGF0YVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInByZWRcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiTWVyZ2VcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLGVuZDowLG5hbWU6XCJ0ZW5zb3JzXCIsdHlwZTpcInRlbnNvcnNcIn1dfSx7dGZPcE5hbWU6XCJFbnRlclwiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcImZyYW1lX25hbWVcIixuYW1lOlwiZnJhbWVOYW1lXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiaXNfY29uc3RhbnRcIixuYW1lOlwiaXNDb25zdGFudFwiLHR5cGU6XCJib29sXCJ9XX0se3RmT3BOYW1lOlwiRXhpdFwiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJOZXh0SXRlcmF0aW9uXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlRlbnNvckFycmF5VjNcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzaXplXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJkdHlwZVwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifSx7dGZOYW1lOlwiZWxlbWVudF9zaGFwZVwiLG5hbWU6XCJlbGVtZW50U2hhcGVcIix0eXBlOlwic2hhcGVcIn0se3RmTmFtZTpcImR5bmFtaWNfc2l6ZVwiLG5hbWU6XCJkeW5hbWljU2l6ZVwiLHR5cGU6XCJib29sXCJ9LHt0Zk5hbWU6XCJjbGVhcl9hZnRlcl9yZWFkXCIsbmFtZTpcImNsZWFyQWZ0ZXJSZWFkXCIsdHlwZTpcImJvb2xcIn0se3RmTmFtZTpcImlkZW50aWNhbF9lbGVtZW50X3NoYXBlc1wiLG5hbWU6XCJpZGVudGljYWxFbGVtZW50U2hhcGVzXCIsdHlwZTpcImJvb2xcIn0se3RmTmFtZTpcInRlbnNvcl9hcnJheV9uYW1lXCIsbmFtZTpcIm5hbWVcIix0eXBlOlwic3RyaW5nXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlXcml0ZVYzXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yQXJyYXlJZFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImluZGV4XCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MixuYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MyxuYW1lOlwiZmxvd0luXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlRlbnNvckFycmF5UmVhZFYzXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yQXJyYXlJZFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImluZGV4XCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MixuYW1lOlwiZmxvd0luXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJkdHlwZVwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheUdhdGhlclYzXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yQXJyYXlJZFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImluZGljZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjIsbmFtZTpcImZsb3dJblwiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZHR5cGVcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn0se3RmTmFtZTpcImVsZW1lbnRfc2hhcGVcIixuYW1lOlwiZWxlbWVudFNoYXBlXCIsdHlwZTpcInNoYXBlXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlTY2F0dGVyVjNcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JBcnJheUlkXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MixuYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MyxuYW1lOlwiZmxvd0luXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlDb25jYXRWM1wiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvckFycmF5SWRcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJmbG93SW5cIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcImR0eXBlXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9LHt0Zk5hbWU6XCJlbGVtZW50X3NoYXBlX2V4Y2VwdDBcIixuYW1lOlwiZWxlbWVudFNoYXBlRXhjZXB0MFwiLHR5cGU6XCJzaGFwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheVNwbGl0VjNcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JBcnJheUlkXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwibGVuZ3Roc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MyxuYW1lOlwiZmxvd0luXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlTaXplVjNcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JBcnJheUlkXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZmxvd0luXCIsdHlwZTpcIm51bWJlclwifV19LHt0Zk9wTmFtZTpcIlRlbnNvckFycmF5Q2xvc2VWM1wiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvckFycmF5SWRcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiU3RhdGVsZXNzSWZcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJjb25kXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxlbmQ6MCxuYW1lOlwiYXJnc1wiLHR5cGU6XCJ0ZW5zb3JzXCJ9XSxhdHRyczpbe3RmTmFtZTpcInRoZW5fYnJhbmNoXCIsbmFtZTpcInRoZW5CcmFuY2hcIix0eXBlOlwiZnVuY1wifSx7dGZOYW1lOlwiZWxzZV9icmFuY2hcIixuYW1lOlwiZWxzZUJyYW5jaFwiLHR5cGU6XCJmdW5jXCJ9XX0se3RmT3BOYW1lOlwiSWZcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJjb25kXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxlbmQ6MCxuYW1lOlwiYXJnc1wiLHR5cGU6XCJ0ZW5zb3JzXCJ9XSxhdHRyczpbe3RmTmFtZTpcInRoZW5fYnJhbmNoXCIsbmFtZTpcInRoZW5CcmFuY2hcIix0eXBlOlwiZnVuY1wifSx7dGZOYW1lOlwiZWxzZV9icmFuY2hcIixuYW1lOlwiZWxzZUJyYW5jaFwiLHR5cGU6XCJmdW5jXCJ9XX0se3RmT3BOYW1lOlwiU3RhdGVsZXNzV2hpbGVcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLGVuZDowLG5hbWU6XCJhcmdzXCIsdHlwZTpcInRlbnNvcnNcIn1dLGF0dHJzOlt7dGZOYW1lOlwiY29uZFwiLG5hbWU6XCJjb25kXCIsdHlwZTpcImZ1bmNcIn0se3RmTmFtZTpcImJvZHlcIixuYW1lOlwiYm9keVwiLHR5cGU6XCJmdW5jXCJ9XX0se3RmT3BOYW1lOlwiV2hpbGVcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLGVuZDowLG5hbWU6XCJhcmdzXCIsdHlwZTpcInRlbnNvcnNcIn1dLGF0dHJzOlt7dGZOYW1lOlwiY29uZFwiLG5hbWU6XCJjb25kXCIsdHlwZTpcImZ1bmNcIn0se3RmTmFtZTpcImJvZHlcIixuYW1lOlwiYm9keVwiLHR5cGU6XCJmdW5jXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yTGlzdFNjYXR0ZXJcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJpbmRpY2VzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJlbGVtZW50U2hhcGVcIix0eXBlOlwic2hhcGVcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZWxlbWVudF9kdHlwZVwiLG5hbWU6XCJlbGVtZW50RFR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JMaXN0U2NhdHRlclYyXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MixuYW1lOlwiZWxlbWVudFNoYXBlXCIsdHlwZTpcInNoYXBlXCJ9LHtzdGFydDozLG5hbWU6XCJudW1FbGVtZW50c1wiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZWxlbWVudF9kdHlwZVwiLG5hbWU6XCJlbGVtZW50RFR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JMaXN0R2F0aGVyXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yTGlzdElkXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MixuYW1lOlwiZWxlbWVudFNoYXBlXCIsdHlwZTpcInNoYXBlXCJ9XSxhdHRyczpbe3RmTmFtZTpcImVsZW1lbnRfZHR5cGVcIixuYW1lOlwiZWxlbWVudERUeXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yTGlzdEdldEl0ZW1cIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JMaXN0SWRcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJpbmRleFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjIsbmFtZTpcImVsZW1lbnRTaGFwZVwiLHR5cGU6XCJzaGFwZVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJlbGVtZW50X2R0eXBlXCIsbmFtZTpcImVsZW1lbnREVHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIlRlbnNvckxpc3RTZXRJdGVtXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yTGlzdElkXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiaW5kZXhcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoyLG5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImVsZW1lbnRfZHR5cGVcIixuYW1lOlwiZWxlbWVudERUeXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yTGlzdFJlc2VydmVcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJlbGVtZW50U2hhcGVcIix0eXBlOlwic2hhcGVcIn0se3N0YXJ0OjEsbmFtZTpcIm51bUVsZW1lbnRzXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJlbGVtZW50X2R0eXBlXCIsbmFtZTpcImVsZW1lbnREVHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIlRlbnNvckxpc3RGcm9tVGVuc29yXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZWxlbWVudFNoYXBlXCIsdHlwZTpcInNoYXBlXCJ9XSxhdHRyczpbe3RmTmFtZTpcImVsZW1lbnRfZHR5cGVcIixuYW1lOlwiZWxlbWVudERUeXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yTGlzdFN0YWNrXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yTGlzdElkXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZWxlbWVudFNoYXBlXCIsdHlwZTpcInNoYXBlXCJ9XSxhdHRyczpbe3RmTmFtZTpcImVsZW1lbnRfZHR5cGVcIixuYW1lOlwiZWxlbWVudERUeXBlXCIsdHlwZTpcImR0eXBlXCJ9LHt0Zk5hbWU6XCJudW1fZWxlbWVudHNcIixuYW1lOlwibnVtRWxlbWVudHNcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JMaXN0U3BsaXRcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJlbGVtZW50U2hhcGVcIix0eXBlOlwic2hhcGVcIn0se3N0YXJ0OjIsbmFtZTpcImxlbmd0aHNcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwiZWxlbWVudF9kdHlwZVwiLG5hbWU6XCJlbGVtZW50RFR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JMaXN0Q29uY2F0XCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yTGlzdElkXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJlbGVtZW50X3NoYXBlXCIsbmFtZTpcImVsZW1lbnRTaGFwZVwiLHR5cGU6XCJzaGFwZVwifSx7dGZOYW1lOlwiZWxlbWVudF9kdHlwZVwiLG5hbWU6XCJlbGVtZW50RFR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JMaXN0Q29uY2F0VjJcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JMaXN0SWRcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImVsZW1lbnRfc2hhcGVcIixuYW1lOlwiZWxlbWVudFNoYXBlXCIsdHlwZTpcInNoYXBlXCJ9LHt0Zk5hbWU6XCJlbGVtZW50X2R0eXBlXCIsbmFtZTpcImVsZW1lbnREVHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIlRlbnNvckxpc3RQb3BCYWNrXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yTGlzdElkXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZWxlbWVudFNoYXBlXCIsdHlwZTpcInNoYXBlXCJ9XSxhdHRyczpbe3RmTmFtZTpcImVsZW1lbnRfZHR5cGVcIixuYW1lOlwiZWxlbWVudERUeXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yTGlzdFB1c2hCYWNrXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yTGlzdElkXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJlbGVtZW50X2R0eXBlXCIsbmFtZTpcImVsZW1lbnREVHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIlRlbnNvckxpc3RMZW5ndGhcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JMaXN0SWRcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yTGlzdFJlc2l6ZVwiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvckxpc3RJZFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInNpemVcIix0eXBlOlwibnVtYmVyXCJ9XX1dLFVDPXt9O19lKFVDLHtqc29uOigpPT54cX0pO3ZhciB4cT1be3RmT3BOYW1lOlwiQXZnUG9vbFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzdHJpZGVzXCIsbmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcInBhZGRpbmdcIixuYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJrc2l6ZVwiLG5hbWU6XCJrZXJuZWxTaXplXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk1heFBvb2xcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwia3NpemVcIixuYW1lOlwia2VybmVsU2l6ZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZOYW1lOlwiZXhwbGljaXRfcGFkZGluZ3NcIixuYW1lOlwiZXhwbGljaXRQYWRkaW5nc1wiLHR5cGU6XCJudW1iZXJbXVwiLGRlZmF1bHRWYWx1ZTpbXSxub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk1heFBvb2xXaXRoQXJnbWF4XCIsY2F0ZWdvcnk6XCJjb252b2x1dGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcInN0cmlkZXNcIixuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZOYW1lOlwicGFkZGluZ1wiLG5hbWU6XCJwYWRcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJrc2l6ZVwiLG5hbWU6XCJrZXJuZWxTaXplXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJpbmNsdWRlX2JhdGNoX2luX2luZGV4XCIsbmFtZTpcImluY2x1ZGVCYXRjaEluSW5kZXhcIix0eXBlOlwiYm9vbFwifSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBdmdQb29sM0RcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwia3NpemVcIixuYW1lOlwia2VybmVsU2l6ZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJNYXhQb29sM0RcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwia3NpemVcIixuYW1lOlwia2VybmVsU2l6ZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJDb252MURcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImZpbHRlclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwic3RyaWRlXCIsbmFtZTpcInN0cmlkZVwiLHR5cGU6XCJudW1iZXJcIn0se3RmTmFtZTpcInBhZGRpbmdcIixuYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixkZWZhdWx0VmFsdWU6XCJOV0NcIn0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJkaWxhdGlvblwiLG5hbWU6XCJkaWxhdGlvblwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MX1dfSx7dGZPcE5hbWU6XCJDb252MkRcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImZpbHRlclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcInN0cmlkZXNcIixuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZOYW1lOlwicGFkZGluZ1wiLG5hbWU6XCJwYWRcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJ1c2VDdWRubk9uR3B1XCIsbmFtZTpcInVzZUN1ZG5uT25HcHVcIix0eXBlOlwiYm9vbFwifSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixkZWZhdWx0VmFsdWU6XCJOSFdDXCJ9LHt0Zk5hbWU6XCJleHBsaWNpdF9wYWRkaW5nc1wiLG5hbWU6XCJleHBsaWNpdFBhZGRpbmdzXCIsdHlwZTpcIm51bWJlcltdXCIsZGVmYXVsdFZhbHVlOltdfSx7dGZOYW1lOlwiZGlsYXRpb25zXCIsbmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIl9GdXNlZENvbnYyRFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZmlsdGVyXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixlbmQ6MCxuYW1lOlwiYXJnc1wiLHR5cGU6XCJ0ZW5zb3JzXCJ9XSxhdHRyczpbe3RmTmFtZTpcIm51bV9hcmdzXCIsbmFtZTpcIm51bUFyZ3NcIix0eXBlOlwibnVtYmVyXCJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImV4cGxpY2l0X3BhZGRpbmdzXCIsbmFtZTpcImV4cGxpY2l0UGFkZGluZ3NcIix0eXBlOlwibnVtYmVyW11cIixkZWZhdWx0VmFsdWU6W119LHt0Zk5hbWU6XCJ1c2VfY3Vkbm5fb25fZ3B1XCIsbmFtZTpcInVzZUN1ZG5uT25HcHVcIix0eXBlOlwiYm9vbFwiLGRlZmF1bHRWYWx1ZTohMH0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsZGVmYXVsdFZhbHVlOlwiTkhXQ1wifSx7dGZOYW1lOlwiZGlsYXRpb25zXCIsbmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJudW1iZXJbXVwiLGRlZmF1bHRWYWx1ZTpbMSwxLDEsMV19LHt0Zk5hbWU6XCJmdXNlZF9vcHNcIixuYW1lOlwiZnVzZWRPcHNcIix0eXBlOlwic3RyaW5nW11cIixkZWZhdWx0VmFsdWU6W119LHt0Zk5hbWU6XCJlcHNpbG9uXCIsbmFtZTpcImVwc2lsb25cIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjFlLTR9LHt0Zk5hbWU6XCJsZWFreXJlbHVfYWxwaGFcIixuYW1lOlwibGVha3lyZWx1QWxwaGFcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOi4yfV19LHt0Zk9wTmFtZTpcIkNvbnYyREJhY2twcm9wSW5wdXRcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MixuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImZpbHRlclwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjAsbmFtZTpcIm91dHB1dFNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcInN0cmlkZXNcIixuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZOYW1lOlwicGFkZGluZ1wiLG5hbWU6XCJwYWRcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJkYXRhX2Zvcm1hdFwiLG5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcImV4cGxpY2l0X3BhZGRpbmdzXCIsbmFtZTpcImV4cGxpY2l0UGFkZGluZ3NcIix0eXBlOlwibnVtYmVyW11cIixkZWZhdWx0VmFsdWU6W119LHt0Zk5hbWU6XCJkaWxhdGlvbnNcIixuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcIm51bWJlcltdXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkRlcHRod2lzZUNvbnYyZFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJpbnB1dFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImZpbHRlclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsZGVmYXVsdFZhbHVlOlwiTkhXQ1wifSx7dGZOYW1lOlwiZXhwbGljaXRfcGFkZGluZ3NcIixuYW1lOlwiZXhwbGljaXRQYWRkaW5nc1wiLHR5cGU6XCJudW1iZXJbXVwiLGRlZmF1bHRWYWx1ZTpbXX0se3RmTmFtZTpcImRpbGF0aW9uc1wiLG5hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJEZXB0aHdpc2VDb252MmROYXRpdmVcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiaW5wdXRcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJmaWx0ZXJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcInN0cmlkZXNcIixuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZOYW1lOlwicGFkZGluZ1wiLG5hbWU6XCJwYWRcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJkYXRhX2Zvcm1hdFwiLG5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLGRlZmF1bHRWYWx1ZTpcIk5IV0NcIn0se3RmTmFtZTpcImV4cGxpY2l0X3BhZGRpbmdzXCIsbmFtZTpcImV4cGxpY2l0UGFkZGluZ3NcIix0eXBlOlwibnVtYmVyW11cIixkZWZhdWx0VmFsdWU6W119LHt0Zk5hbWU6XCJkaWxhdGlvbnNcIixuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiRnVzZWREZXB0aHdpc2VDb252MmROYXRpdmVcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImZpbHRlclwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsZW5kOjAsbmFtZTpcImFyZ3NcIix0eXBlOlwidGVuc29yc1wifV0sYXR0cnM6W3t0Zk5hbWU6XCJudW1fYXJnc1wiLG5hbWU6XCJudW1BcmdzXCIsdHlwZTpcIm51bWJlclwifSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcInN0cmlkZXNcIixuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZOYW1lOlwicGFkZGluZ1wiLG5hbWU6XCJwYWRcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJkYXRhX2Zvcm1hdFwiLG5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLGRlZmF1bHRWYWx1ZTpcIk5IV0NcIn0se3RmTmFtZTpcImRpbGF0aW9uc1wiLG5hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwibnVtYmVyW11cIixkZWZhdWx0VmFsdWU6WzEsMSwxLDFdfSx7dGZOYW1lOlwiZnVzZWRfb3BzXCIsbmFtZTpcImZ1c2VkT3BzXCIsdHlwZTpcInN0cmluZ1tdXCIsZGVmYXVsdFZhbHVlOltdfSx7dGZOYW1lOlwiZXhwbGljaXRfcGFkZGluZ3NcIixuYW1lOlwiZXhwbGljaXRQYWRkaW5nc1wiLHR5cGU6XCJudW1iZXJbXVwiLGRlZmF1bHRWYWx1ZTpbXX1dfSx7dGZPcE5hbWU6XCJDb252M0RcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImZpbHRlclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsZGVmYXVsdFZhbHVlOlwiTkhXQ1wifSx7dGZOYW1lOlwiZGlsYXRpb25zXCIsbmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIkRpbGF0aW9uMkRcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImZpbHRlclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJyYXRlc1wiLG5hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcInBhZGRpbmdcIixuYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifV19XSxHQz17fTtfZShHQyx7anNvbjooKT0+dnF9KTt2YXIgdnE9W3t0Zk9wTmFtZTpcIkZpbGxcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwic2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjEsbmFtZTpcInZhbHVlXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiTGluU3BhY2VcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwic3RhcnRcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoxLG5hbWU6XCJzdG9wXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MixuYW1lOlwibnVtXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk9uZUhvdFwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJpbmRpY2VzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZGVwdGhcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoyLG5hbWU6XCJvblZhbHVlXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToxfSx7c3RhcnQ6MyxuYW1lOlwib2ZmVmFsdWVcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9XSxhdHRyczpbe3RmTmFtZTpcImF4aXNcIixuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiT25lc1wiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiT25lc0xpa2VcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZHR5cGVcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJSYW5kb21TdGFuZGFyZE5vcm1hbFwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzZWVkXCIsbmFtZTpcInNlZWRcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0Zk5hbWU6XCJzZWVkMlwiLG5hbWU6XCJzZWVkMlwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MCxub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJkdHlwZVwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJUXCIsdHlwZTpcIm51bWJlclwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSYW5kb21Vbmlmb3JtXCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcIm1pbnZhbFwiLG5hbWU6XCJtaW52YWxcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0Zk5hbWU6XCJtYXh2YWxcIixuYW1lOlwibWF4dmFsXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToxfSx7dGZOYW1lOlwiZHR5cGVcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn0se3RmTmFtZTpcInNlZWRcIixuYW1lOlwic2VlZFwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmTmFtZTpcInNlZWQyXCIsbmFtZTpcInNlZWQyXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcIlRcIixuYW1lOlwiVFwiLHR5cGU6XCJudW1iZXJcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUmFuZG9tVW5pZm9ybUludFwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJtaW52YWxcIixuYW1lOlwibWludmFsXCIsdHlwZTpcIm51bWJlclwifSx7dGZOYW1lOlwibWF4dmFsXCIsbmFtZTpcIm1heHZhbFwiLHR5cGU6XCJudW1iZXJcIn0se3RmTmFtZTpcInNlZWRcIixuYW1lOlwic2VlZFwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmTmFtZTpcInNlZWQyXCIsbmFtZTpcInNlZWQyXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSYW5nZVwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzdGFydFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjEsbmFtZTpcInN0b3BcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoyLG5hbWU6XCJzdGVwXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfV0sYXR0cnM6W3t0Zk5hbWU6XCJUaWR4XCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiVHJ1bmNhdGVkTm9ybWFsXCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcIm1lYW5zXCIsbmFtZTpcIm1lYW5cIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0Zk5hbWU6XCJzdGRkZXZcIixuYW1lOlwic3RkRGV2XCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToxfSx7dGZOYW1lOlwic2VlZFwiLG5hbWU6XCJzZWVkXCIsdHlwZTpcIm51bWJlclwifSx7dGZOYW1lOlwic2VlZDJcIixuYW1lOlwic2VlZDJcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjAsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwiZHR5cGVcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn0se3RmTmFtZTpcIlRcIixuYW1lOlwiVFwiLHR5cGU6XCJudW1iZXJcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiWmVyb3NcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwic2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIlplcm9zTGlrZVwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiTXVsdGlub21pYWxcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwibG9naXRzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwibnVtU2FtcGxlc1wiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwic2VlZFwiLG5hbWU6XCJzZWVkXCIsdHlwZTpcIm51bWJlclwifSx7dGZOYW1lOlwic2VlZDJcIixuYW1lOlwic2VlZDJcIix0eXBlOlwibnVtYmVyXCJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9LHt0Zk5hbWU6XCJvdXRwdXRfZHR5cGVcIixuYW1lOlwib3V0cHV0X2R0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX1dLEhDPXt9O19lKEhDLHtqc29uOigpPT53cX0pO3ZhciB3cT1be3RmT3BOYW1lOlwiTm9uTWF4U3VwcHJlc3Npb25WMlwiLGNhdGVnb3J5OlwiZHluYW1pY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImJveGVzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwic2NvcmVzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwibWF4T3V0cHV0U2l6ZVwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjMsbmFtZTpcImlvdVRocmVzaG9sZFwiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJOb25NYXhTdXBwcmVzc2lvblYzXCIsY2F0ZWdvcnk6XCJkeW5hbWljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYm94ZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJzY29yZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJtYXhPdXRwdXRTaXplXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MyxuYW1lOlwiaW91VGhyZXNob2xkXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6NCxuYW1lOlwic2NvcmVUaHJlc2hvbGRcIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiTm9uTWF4U3VwcHJlc3Npb25WNFwiLGNhdGVnb3J5OlwiZHluYW1pY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImJveGVzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwic2NvcmVzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwibWF4T3V0cHV0U2l6ZVwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjMsbmFtZTpcImlvdVRocmVzaG9sZFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjQsbmFtZTpcInNjb3JlVGhyZXNob2xkXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwiVF90aHJlc2hvbGRcIixuYW1lOlwidGhyZXNob2xkXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwicGFkX3RvX21heF9vdXRwdXRfc2l6ZVwiLG5hbWU6XCJwYWRUb01heE91dHB1dFNpemVcIix0eXBlOlwiYm9vbFwifV19LHt0Zk9wTmFtZTpcIk5vbk1heFN1cHByZXNzaW9uVjVcIixjYXRlZ29yeTpcImR5bmFtaWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJib3hlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInNjb3Jlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcIm1heE91dHB1dFNpemVcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDozLG5hbWU6XCJpb3VUaHJlc2hvbGRcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDo0LG5hbWU6XCJzY29yZVRocmVzaG9sZFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjUsbmFtZTpcInNvZnRObXNTaWdtYVwiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJXaGVyZVwiLGNhdGVnb3J5OlwiZHluYW1pY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImNvbmRpdGlvblwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMaXN0RGlmZlwiLGNhdGVnb3J5OlwiZHluYW1pY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJ5XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19XSxqQz17fTtfZShqQyx7anNvbjooKT0+a3F9KTt2YXIga3E9W3t0Zk9wTmFtZTpcIkxvd2VyQm91bmRcIixjYXRlZ29yeTpcImV2YWx1YXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzb3J0ZWRTZXF1ZW5jZVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInZhbHVlc1wiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJUb3BLVjJcIixjYXRlZ29yeTpcImV2YWx1YXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwia1wiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwic29ydGVkXCIsbmFtZTpcInNvcnRlZFwiLHR5cGU6XCJib29sXCJ9XX0se3RmT3BOYW1lOlwiVXBwZXJCb3VuZFwiLGNhdGVnb3J5OlwiZXZhbHVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInNvcnRlZFNlcXVlbmNlXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwidmFsdWVzXCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlVuaXF1ZVwiLGNhdGVnb3J5OlwiZXZhbHVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiVW5pcXVlVjJcIixjYXRlZ29yeTpcImV2YWx1YXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIn1dfV0scUM9e307X2UocUMse2pzb246KCk9PklxfSk7dmFyIElxPVt7dGZPcE5hbWU6XCJQbGFjZWhvbGRlcldpdGhEZWZhdWx0XCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImRlZmF1bHRcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcInNoYXBlXCIsbmFtZTpcInNoYXBlXCIsdHlwZTpcInNoYXBlXCJ9LHt0Zk5hbWU6XCJkdHlwZVwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIlBsYWNlaG9sZGVyXCIsY2F0ZWdvcnk6XCJncmFwaFwiLGF0dHJzOlt7dGZOYW1lOlwic2hhcGVcIixuYW1lOlwic2hhcGVcIix0eXBlOlwic2hhcGVcIn0se3RmTmFtZTpcImR0eXBlXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiQ29uc3RcIixjYXRlZ29yeTpcImdyYXBoXCJ9LHt0Zk9wTmFtZTpcIklkZW50aXR5XCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiSWRlbnRpdHlOXCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbe3N0YXJ0OjAsZW5kOjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yc1wifV19LHt0Zk9wTmFtZTpcIlNuYXBzaG90XCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiUmFua1wiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlNpemVcIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJTaGFwZVwiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlNoYXBlTlwiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W3tzdGFydDowLGVuZDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvcnNcIn1dfSx7dGZPcE5hbWU6XCJQcmludFwiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZGF0YVwiLHR5cGU6XCJ0ZW5zb3JzXCJ9XSxhdHRyczpbe3RmTmFtZTpcIm1lc3NhZ2VcIixuYW1lOlwibWVzc2FnZVwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImZpcnN0X25cIixuYW1lOlwiZmlyc3ROXCIsdHlwZTpcIm51bWJlclwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcInN1bW1hcml6ZVwiLG5hbWU6XCJzdW1tYXJpemVcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjN9XX0se3RmT3BOYW1lOlwiTm9PcFwiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W119LHt0Zk9wTmFtZTpcIlN0b3BHcmFkaWVudFwiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIkZha2VRdWFudFdpdGhNaW5NYXhWYXJzXCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIm1pblwiLG5hbWU6XCJtaW5cIix0eXBlOlwibnVtYmVyXCJ9LHt0Zk5hbWU6XCJtYXhcIixuYW1lOlwibWF4XCIsdHlwZTpcIm51bWJlclwifV19XSxLQz17fTtfZShLQyx7anNvbjooKT0+U3F9KTt2YXIgU3E9W3t0Zk9wTmFtZTpcIkhhc2hUYWJsZVwiLGNhdGVnb3J5OlwiaGFzaF90YWJsZVwiLGlucHV0czpbXSxhdHRyczpbe3RmTmFtZTpcInNoYXJlZF9uYW1lXCIsbmFtZTpcInNoYXJlZE5hbWVcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJ1c2Vfbm9kZV9uYW1lX3NoYXJpbmdcIixuYW1lOlwidXNlTm9kZU5hbWVTaGFyaW5nXCIsdHlwZTpcImJvb2xcIn0se3RmTmFtZTpcImtleV9kdHlwZVwiLG5hbWU6XCJrZXlEVHlwZVwiLHR5cGU6XCJkdHlwZVwifSx7dGZOYW1lOlwidmFsdWVfZHR5cGVcIixuYW1lOlwidmFsdWVEVHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIkhhc2hUYWJsZVYyXCIsY2F0ZWdvcnk6XCJoYXNoX3RhYmxlXCIsaW5wdXRzOltdLGF0dHJzOlt7dGZOYW1lOlwic2hhcmVkX25hbWVcIixuYW1lOlwic2hhcmVkTmFtZVwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcInVzZV9ub2RlX25hbWVfc2hhcmluZ1wiLG5hbWU6XCJ1c2VOb2RlTmFtZVNoYXJpbmdcIix0eXBlOlwiYm9vbFwifSx7dGZOYW1lOlwia2V5X2R0eXBlXCIsbmFtZTpcImtleURUeXBlXCIsdHlwZTpcImR0eXBlXCJ9LHt0Zk5hbWU6XCJ2YWx1ZV9kdHlwZVwiLG5hbWU6XCJ2YWx1ZURUeXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiTG9va3VwVGFibGVJbXBvcnRcIixjYXRlZ29yeTpcImhhc2hfdGFibGVcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0YWJsZUhhbmRsZVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImtleXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJ2YWx1ZXNcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRpblwiLG5hbWU6XCJ0SW5cIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJUb3V0XCIsbmFtZTpcInRPdXRcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTG9va3VwVGFibGVJbXBvcnRWMlwiLGNhdGVnb3J5OlwiaGFzaF90YWJsZVwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRhYmxlSGFuZGxlXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwia2V5c1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcInZhbHVlc1wiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVGluXCIsbmFtZTpcInRJblwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcIlRvdXRcIixuYW1lOlwidE91dFwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMb29rdXBUYWJsZUZpbmRcIixjYXRlZ29yeTpcImhhc2hfdGFibGVcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0YWJsZUhhbmRsZVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImtleXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJkZWZhdWx0VmFsdWVcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRpblwiLG5hbWU6XCJ0SW5cIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJUb3V0XCIsbmFtZTpcInRPdXRcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTG9va3VwVGFibGVGaW5kVjJcIixjYXRlZ29yeTpcImhhc2hfdGFibGVcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0YWJsZUhhbmRsZVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImtleXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJkZWZhdWx0VmFsdWVcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRpblwiLG5hbWU6XCJ0SW5cIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJUb3V0XCIsbmFtZTpcInRPdXRcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTG9va3VwVGFibGVTaXplXCIsY2F0ZWdvcnk6XCJoYXNoX3RhYmxlXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGFibGVIYW5kbGVcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiTG9va3VwVGFibGVTaXplVjJcIixjYXRlZ29yeTpcImhhc2hfdGFibGVcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0YWJsZUhhbmRsZVwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJJbml0aWFsaXplVGFibGVcIixjYXRlZ29yeTpcImhhc2hfdGFibGVcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0YWJsZUhhbmRsZVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImtleXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJ2YWx1ZXNcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiSW5pdGlhbGl6ZVRhYmxlVjJcIixjYXRlZ29yeTpcImhhc2hfdGFibGVcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0YWJsZUhhbmRsZVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImtleXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJ2YWx1ZXNcIix0eXBlOlwidGVuc29yXCJ9XX1dLFhDPXt9O19lKFhDLHtqc29uOigpPT5OcX0pO3ZhciBOcT1be3RmT3BOYW1lOlwiUmVzaXplQmlsaW5lYXJcIixjYXRlZ29yeTpcImltYWdlXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiaW1hZ2VzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwic2l6ZVwiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJhbGlnbl9jb3JuZXJzXCIsbmFtZTpcImFsaWduQ29ybmVyc1wiLHR5cGU6XCJib29sXCJ9LHt0Zk5hbWU6XCJoYWxmX3BpeGVsX2NlbnRlcnNcIixuYW1lOlwiaGFsZlBpeGVsQ2VudGVyc1wiLHR5cGU6XCJib29sXCJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJlc2l6ZU5lYXJlc3ROZWlnaGJvclwiLGNhdGVnb3J5OlwiaW1hZ2VcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJpbWFnZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJzaXplXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImFsaWduX2Nvcm5lcnNcIixuYW1lOlwiYWxpZ25Db3JuZXJzXCIsdHlwZTpcImJvb2xcIn0se3RmTmFtZTpcImhhbGZfcGl4ZWxfY2VudGVyc1wiLG5hbWU6XCJoYWxmUGl4ZWxDZW50ZXJzXCIsdHlwZTpcImJvb2xcIn0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQ3JvcEFuZFJlc2l6ZVwiLGNhdGVnb3J5OlwiaW1hZ2VcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJpbWFnZVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJveGVzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwiYm94SW5kXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MyxuYW1lOlwiY3JvcFNpemVcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwibWV0aG9kXCIsbmFtZTpcIm1ldGhvZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImV4dHJhcG9sYXRpb25fdmFsdWVcIixuYW1lOlwiZXh0cmFwb2xhdGlvblZhbHVlXCIsdHlwZTpcIm51bWJlclwifV19LHt0Zk9wTmFtZTpcIkltYWdlUHJvamVjdGl2ZVRyYW5zZm9ybVYzXCIsY2F0ZWdvcnk6XCJpbWFnZVwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImltYWdlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInRyYW5zZm9ybXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJvdXRwdXRTaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MyxuYW1lOlwiZmlsbFZhbHVlXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJpbnRlcnBvbGF0aW9uXCIsbmFtZTpcImludGVycG9sYXRpb25cIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJmaWxsX21vZGVcIixuYW1lOlwiZmlsbE1vZGVcIix0eXBlOlwic3RyaW5nXCJ9XX1dLFlDPXt9O19lKFlDLHtqc29uOigpPT5UcX0pO3ZhciBUcT1be3RmT3BOYW1lOlwiRXF1YWxcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJOb3RFcXVhbFwiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkdyZWF0ZXJcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJHcmVhdGVyRXF1YWxcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMZXNzXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTGVzc0VxdWFsXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTG9naWNhbEFuZFwiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxvZ2ljYWxOb3RcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxvZ2ljYWxPclwiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNlbGVjdFwiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImNvbmRpdGlvblwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNlbGVjdFYyXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiY29uZGl0aW9uXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQml0d2lzZUFuZFwiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJ5XCIsdHlwZTpcInRlbnNvclwifV19XSxaQz17fTtfZShaQyx7anNvbjooKT0+Q3F9KTt2YXIgQ3E9W3t0Zk9wTmFtZTpcIl9GdXNlZE1hdE11bFwiLGNhdGVnb3J5OlwibWF0cmljZXNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsZW5kOjAsbmFtZTpcImFyZ3NcIix0eXBlOlwidGVuc29yc1wifV0sYXR0cnM6W3t0Zk5hbWU6XCJudW1fYXJnc1wiLG5hbWU6XCJudW1BcmdzXCIsdHlwZTpcIm51bWJlclwifSx7dGZOYW1lOlwiZnVzZWRfb3BzXCIsbmFtZTpcImZ1c2VkT3BzXCIsdHlwZTpcInN0cmluZ1tdXCIsZGVmYXVsdFZhbHVlOltdfSx7dGZOYW1lOlwiZXBzaWxvblwiLG5hbWU6XCJlcHNpbG9uXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToxZS00fSx7dGZOYW1lOlwidHJhbnNwb3NlX2FcIixuYW1lOlwidHJhbnNwb3NlQVwiLHR5cGU6XCJib29sXCIsZGVmYXVsdFZhbHVlOiExfSx7dGZOYW1lOlwidHJhbnNwb3NlX2JcIixuYW1lOlwidHJhbnNwb3NlQlwiLHR5cGU6XCJib29sXCIsZGVmYXVsdFZhbHVlOiExfSx7dGZOYW1lOlwibGVha3lyZWx1X2FscGhhXCIsbmFtZTpcImxlYWt5cmVsdUFscGhhXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTouMn0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTWF0TXVsXCIsY2F0ZWdvcnk6XCJtYXRyaWNlc1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJ0cmFuc3Bvc2VfYVwiLG5hbWU6XCJ0cmFuc3Bvc2VBXCIsdHlwZTpcImJvb2xcIixkZWZhdWx0VmFsdWU6ITF9LHt0Zk5hbWU6XCJ0cmFuc3Bvc2VfYlwiLG5hbWU6XCJ0cmFuc3Bvc2VCXCIsdHlwZTpcImJvb2xcIixkZWZhdWx0VmFsdWU6ITF9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkJhdGNoTWF0TXVsXCIsY2F0ZWdvcnk6XCJtYXRyaWNlc1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJhZGpfeFwiLG5hbWU6XCJ0cmFuc3Bvc2VBXCIsdHlwZTpcImJvb2xcIixkZWZhdWx0VmFsdWU6ITF9LHt0Zk5hbWU6XCJhZGpfeVwiLG5hbWU6XCJ0cmFuc3Bvc2VCXCIsdHlwZTpcImJvb2xcIixkZWZhdWx0VmFsdWU6ITF9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkJhdGNoTWF0TXVsVjJcIixjYXRlZ29yeTpcIm1hdHJpY2VzXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImFkal94XCIsbmFtZTpcInRyYW5zcG9zZUFcIix0eXBlOlwiYm9vbFwiLGRlZmF1bHRWYWx1ZTohMX0se3RmTmFtZTpcImFkal95XCIsbmFtZTpcInRyYW5zcG9zZUJcIix0eXBlOlwiYm9vbFwiLGRlZmF1bHRWYWx1ZTohMX0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVHJhbnNwb3NlXCIsY2F0ZWdvcnk6XCJtYXRyaWNlc1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJwZXJtXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRWluc3VtXCIsY2F0ZWdvcnk6XCJtYXRyaWNlc1wiLGlucHV0czpbe3N0YXJ0OjAsZW5kOjAsbmFtZTpcInRlbnNvcnNcIix0eXBlOlwidGVuc29yc1wifV0sYXR0cnM6W3t0Zk5hbWU6XCJlcXVhdGlvblwiLG5hbWU6XCJlcXVhdGlvblwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcIk5cIixuYW1lOlwiblwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6Mn0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJNYXRyaXhCYW5kUGFydFwiLGNhdGVnb3J5OlwibWF0cmljZXNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwibnVtTG93ZXJcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJudW1VcHBlclwiLHR5cGU6XCJ0ZW5zb3JcIn1dfV0sSkM9e307X2UoSkMse2pzb246KCk9PkVxfSk7dmFyIEVxPVt7dGZPcE5hbWU6XCJFdWNsaWRlYW5Ob3JtXCIsY2F0ZWdvcnk6XCJub3JtYWxpemF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwia2VlcF9kaW1zXCIsbmFtZTpcImtlZXBEaW1zXCIsdHlwZTpcImJvb2xcIixkZWZhdWx0VmFsdWU6ITF9XX0se3RmT3BOYW1lOlwiRnVzZWRCYXRjaE5vcm1cIixjYXRlZ29yeTpcIm5vcm1hbGl6YXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwic2NhbGVcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJvZmZzZXRcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDozLG5hbWU6XCJtZWFuXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6NCxuYW1lOlwidmFyaWFuY2VcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImVwc2lsb25cIixuYW1lOlwiZXBzaWxvblwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6LjAwMX0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkZ1c2VkQmF0Y2hOb3JtVjJcIixjYXRlZ29yeTpcIm5vcm1hbGl6YXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwic2NhbGVcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJvZmZzZXRcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDozLG5hbWU6XCJtZWFuXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6NCxuYW1lOlwidmFyaWFuY2VcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImVwc2lsb25cIixuYW1lOlwiZXBzaWxvblwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6LjAwMX0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkZ1c2VkQmF0Y2hOb3JtVjNcIixjYXRlZ29yeTpcIm5vcm1hbGl6YXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwic2NhbGVcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJvZmZzZXRcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDozLG5hbWU6XCJtZWFuXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6NCxuYW1lOlwidmFyaWFuY2VcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImVwc2lsb25cIixuYW1lOlwiZXBzaWxvblwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6LjAwMX0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxSTlwiLGNhdGVnb3J5Olwibm9ybWFsaXphdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImRlcHRoX3JhZGl1c1wiLG5hbWU6XCJyYWRpdXNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjV9LHt0Zk5hbWU6XCJiaWFzXCIsbmFtZTpcImJpYXNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjF9LHt0Zk5hbWU6XCJhbHBoYVwiLG5hbWU6XCJhbHBoYVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MX0se3RmTmFtZTpcImJldGFcIixuYW1lOlwiYmV0YVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6LjV9XX0se3RmT3BOYW1lOlwiU29mdG1heFwiLGNhdGVnb3J5Olwibm9ybWFsaXphdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiTG9nU29mdG1heFwiLGNhdGVnb3J5Olwibm9ybWFsaXphdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX1dLFFDPXt9O19lKFFDLHtqc29uOigpPT5fcX0pO3ZhciBfcT1be3RmT3BOYW1lOlwiQmluY291bnRcIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJzaXplXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MixuYW1lOlwid2VpZ2h0c1wiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJEZW5zZUJpbmNvdW50XCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwic2l6ZVwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjIsbmFtZTpcIndlaWdodHNcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImJpbmFyeV9vdXRwdXRcIixuYW1lOlwiYmluYXJ5T3V0cHV0XCIsdHlwZTpcImJvb2xcIn1dfSx7dGZPcE5hbWU6XCJNYXhcIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImtlZXBfZGltc1wiLG5hbWU6XCJrZWVwRGltc1wiLHR5cGU6XCJib29sXCJ9XX0se3RmT3BOYW1lOlwiTWVhblwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwia2VlcF9kaW1zXCIsbmFtZTpcImtlZXBEaW1zXCIsdHlwZTpcImJvb2xcIn1dfSx7dGZPcE5hbWU6XCJNaW5cIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImtlZXBfZGltc1wiLG5hbWU6XCJrZWVwRGltc1wiLHR5cGU6XCJib29sXCJ9XX0se3RmT3BOYW1lOlwiU3VtXCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJrZWVwX2RpbXNcIixuYW1lOlwia2VlcERpbXNcIix0eXBlOlwiYm9vbFwifV19LHt0Zk9wTmFtZTpcIkFsbFwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwia2VlcF9kaW1zXCIsbmFtZTpcImtlZXBEaW1zXCIsdHlwZTpcImJvb2xcIn1dfSx7dGZPcE5hbWU6XCJBbnlcIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImtlZXBfZGltc1wiLG5hbWU6XCJrZWVwRGltc1wiLHR5cGU6XCJib29sXCJ9XX0se3RmT3BOYW1lOlwiQXJnTWF4XCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJBcmdNaW5cIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwifV19LHt0Zk9wTmFtZTpcIlByb2RcIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImtlZXBfZGltc1wiLG5hbWU6XCJrZWVwRGltc1wiLHR5cGU6XCJib29sXCJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkN1bXByb2RcIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJleGNsdXNpdmVcIixuYW1lOlwiZXhjbHVzaXZlXCIsdHlwZTpcImJvb2xcIn0se3RmTmFtZTpcInJldmVyc2VcIixuYW1lOlwicmV2ZXJzZVwiLHR5cGU6XCJib29sXCJ9XX0se3RmT3BOYW1lOlwiQ3Vtc3VtXCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZXhjbHVzaXZlXCIsbmFtZTpcImV4Y2x1c2l2ZVwiLHR5cGU6XCJib29sXCJ9LHt0Zk5hbWU6XCJyZXZlcnNlXCIsbmFtZTpcInJldmVyc2VcIix0eXBlOlwiYm9vbFwifV19XSxlRT17fTtfZShlRSx7anNvbjooKT0+QXF9KTt2YXIgQXE9W3t0Zk9wTmFtZTpcIkNvbmNhdFYyXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxlbmQ6LTEsbmFtZTpcInRlbnNvcnNcIix0eXBlOlwidGVuc29yc1wifSx7c3RhcnQ6LTEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcIk5cIixuYW1lOlwiblwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6Mn1dfSx7dGZPcE5hbWU6XCJDb25jYXRcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDoxLGVuZDowLG5hbWU6XCJ0ZW5zb3JzXCIsdHlwZTpcInRlbnNvcnNcIn0se3N0YXJ0OjAsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcIk5cIixuYW1lOlwiblwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6Mn1dfSx7dGZPcE5hbWU6XCJHYXRoZXJWMlwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJpbmRpY2VzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH1dLGF0dHJzOlt7dGZOYW1lOlwiYmF0Y2hfZGltc1wiLG5hbWU6XCJiYXRjaERpbXNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9XX0se3RmT3BOYW1lOlwiR2F0aGVyXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcInZhbGlkYXRlX2luZGljZXNcIixuYW1lOlwidmFsaWRhdGVJbmRpY2VzXCIsdHlwZTpcImJvb2xcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUmV2ZXJzZVwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJkaW1zXCIsdHlwZTpcImJvb2xbXVwifV19LHt0Zk9wTmFtZTpcIlJldmVyc2VWMlwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiU2xpY2VcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYmVnaW5cIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjIsbmFtZTpcInNpemVcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJTdHJpZGVkU2xpY2VcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYmVnaW5cIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjIsbmFtZTpcImVuZFwiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MyxuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJiZWdpbl9tYXNrXCIsbmFtZTpcImJlZ2luTWFza1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmTmFtZTpcImVuZF9tYXNrXCIsbmFtZTpcImVuZE1hc2tcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0Zk5hbWU6XCJuZXdfYXhpc19tYXNrXCIsbmFtZTpcIm5ld0F4aXNNYXNrXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZOYW1lOlwiZWxsaXBzaXNfbWFza1wiLG5hbWU6XCJlbGxpcHNpc01hc2tcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0Zk5hbWU6XCJzaHJpbmtfYXhpc19tYXNrXCIsbmFtZTpcInNocmlua0F4aXNNYXNrXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfV19LHt0Zk9wTmFtZTpcIlBhY2tcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLGVuZDowLG5hbWU6XCJ0ZW5zb3JzXCIsdHlwZTpcInRlbnNvcnNcIn1dLGF0dHJzOlt7dGZOYW1lOlwiYXhpc1wiLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfV19LHt0Zk9wTmFtZTpcIlVucGFja1wiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiYXhpc1wiLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZOYW1lOlwibnVtXCIsbmFtZTpcIm51bVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MCxub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVGlsZVwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJyZXBzXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiU3BsaXRcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7c3RhcnQ6MSxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwibnVtX3NwbGl0XCIsbmFtZTpcIm51bU9yU2l6ZVNwbGl0c1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MX1dfSx7dGZPcE5hbWU6XCJTcGxpdFZcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwibnVtT3JTaXplU3BsaXRzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfV19LHt0Zk9wTmFtZTpcIlNjYXR0ZXJOZFwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJ2YWx1ZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIkdhdGhlck5kXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiU3BhcnNlVG9EZW5zZVwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInNwYXJzZUluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJvdXRwdXRTaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MixuYW1lOlwic3BhcnNlVmFsdWVzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MyxuYW1lOlwiZGVmYXVsdFZhbHVlXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJ2YWxpZGF0ZV9pbmRpY2VzXCIsbmFtZTpcInZhbGlkYXRlSW5kaWNlc1wiLHR5cGU6XCJib29sXCIsZGVmYXVsdFZhbHVlOiExLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJUZW5zb3JTY2F0dGVyVXBkYXRlXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcInZhbHVlc1wiLHR5cGU6XCJ0ZW5zb3JcIn1dfV0sdEU9e307X2UodEUse2pzb246KCk9PkZxfSk7dmFyIEZxPVt7dGZPcE5hbWU6XCJTcGFyc2VGaWxsRW1wdHlSb3dzXCIsY2F0ZWdvcnk6XCJzcGFyc2VcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJpbmRpY2VzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwidmFsdWVzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwiZGVuc2VTaGFwZVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjMsbmFtZTpcImRlZmF1bHRWYWx1ZVwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJTcGFyc2VSZXNoYXBlXCIsY2F0ZWdvcnk6XCJzcGFyc2VcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJpbnB1dEluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJpbnB1dFNoYXBlXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwibmV3U2hhcGVcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU3BhcnNlU2VnbWVudE1lYW5cIixjYXRlZ29yeTpcInNwYXJzZVwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImRhdGFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJpbmRpY2VzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwic2VnbWVudElkc1wiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJTcGFyc2VTZWdtZW50U3VtXCIsY2F0ZWdvcnk6XCJzcGFyc2VcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJkYXRhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcInNlZ21lbnRJZHNcIix0eXBlOlwidGVuc29yXCJ9XX1dLG5FPXt9O19lKG5FLHtqc29uOigpPT4kcX0pO3ZhciAkcT1be3RmT3BOYW1lOlwiRkZUXCIsY2F0ZWdvcnk6XCJzcGVjdHJhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiSUZGVFwiLGNhdGVnb3J5Olwic3BlY3RyYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlJGRlRcIixjYXRlZ29yeTpcInNwZWN0cmFsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImZmdF9sZW5ndGhcIix0eXBlOlwibnVtYmVyXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIklSRkZUXCIsY2F0ZWdvcnk6XCJzcGVjdHJhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJmZnRfbGVuZ3RoXCIsdHlwZTpcIm51bWJlclwiLG5vdFN1cHBvcnRlZDohMH1dfV0sYUU9e307X2UoYUUse2pzb246KCk9PkRxfSk7dmFyIERxPVt7dGZPcE5hbWU6XCJTdGF0aWNSZWdleFJlcGxhY2VcIixjYXRlZ29yeTpcInN0cmluZ1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImlucHV0XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJwYXR0ZXJuXCIsbmFtZTpcInBhdHRlcm5cIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJyZXdyaXRlXCIsbmFtZTpcInJld3JpdGVcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJyZXBsYWNlX2dsb2JhbFwiLG5hbWU6XCJyZXBsYWNlR2xvYmFsXCIsdHlwZTpcImJvb2xcIn1dfSx7dGZPcE5hbWU6XCJTdHJpbmdOR3JhbXNcIixjYXRlZ29yeTpcInN0cmluZ1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImRhdGFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJkYXRhU3BsaXRzXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzZXBhcmF0b3JcIixuYW1lOlwic2VwYXJhdG9yXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwibmdyYW1fd2lkdGhzXCIsbmFtZTpcIm5HcmFtV2lkdGhzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJsZWZ0X3BhZFwiLG5hbWU6XCJsZWZ0UGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwicmlnaHRfcGFkXCIsbmFtZTpcInJpZ2h0UGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwicGFkX3dpZHRoXCIsbmFtZTpcInBhZFdpZHRoXCIsdHlwZTpcIm51bWJlclwifSx7dGZOYW1lOlwicHJlc2VydmVfc2hvcnRfc2VxdWVuY2VzXCIsbmFtZTpcInByZXNlcnZlU2hvcnRTZXF1ZW5jZXNcIix0eXBlOlwiYm9vbFwifV0sb3V0cHV0czpbXCJuZ3JhbXNcIixcIm5ncmFtc19zcGxpdHNcIl19LHt0Zk9wTmFtZTpcIlN0cmluZ1NwbGl0XCIsY2F0ZWdvcnk6XCJzdHJpbmdcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJpbnB1dFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImRlbGltaXRlclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwic2tpcF9lbXB0eVwiLG5hbWU6XCJza2lwRW1wdHlcIix0eXBlOlwiYm9vbFwifV0sb3V0cHV0czpbXCJpbmRpY2VzXCIsXCJ2YWx1ZXNcIixcInNoYXBlXCJdfSx7dGZPcE5hbWU6XCJTdHJpbmdUb0hhc2hCdWNrZXRGYXN0XCIsY2F0ZWdvcnk6XCJzdHJpbmdcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJpbnB1dFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwibnVtX2J1Y2tldHNcIixuYW1lOlwibnVtQnVja2V0c1wiLHR5cGU6XCJudW1iZXJcIn1dfV0sckU9e307X2UockUse2pzb246KCk9PlJxfSk7dmFyIFJxPVt7dGZPcE5hbWU6XCJDYXN0XCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlNyY1RcIixuYW1lOlwic2R0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwiRHN0VFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIkV4cGFuZERpbXNcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiTWlycm9yUGFkXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJwYWRkaW5nXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcIm1vZGVcIixuYW1lOlwibW9kZVwiLHR5cGU6XCJzdHJpbmdcIn1dfSx7dGZPcE5hbWU6XCJQYWRcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInBhZGRpbmdcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwiY29uc3RhbnRfdmFsdWVcIixuYW1lOlwiY29uc3RhbnRWYWx1ZVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH1dfSx7dGZPcE5hbWU6XCJQYWRWMlwiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwicGFkZGluZ1wiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MixuYW1lOlwiY29uc3RhbnRWYWx1ZVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH1dfSx7dGZPcE5hbWU6XCJSZXNoYXBlXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIkVuc3VyZVNoYXBlXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIlNxdWVlemVcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiYXhpc1wiLHRmRGVwcmVjYXRlZE5hbWU6XCJzcXVlZXplX2RpbXNcIixuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIlNwYWNlVG9CYXRjaE5EXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJibG9ja1NoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJwYWRkaW5nc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIkJhdGNoVG9TcGFjZU5EXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJibG9ja1NoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJjcm9wc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIkRlcHRoVG9TcGFjZVwiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJibG9ja19zaXplXCIsbmFtZTpcImJsb2NrU2l6ZVwiLHR5cGU6XCJudW1iZXJcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCJ9XX0se3RmT3BOYW1lOlwiQnJvYWRjYXN0VG9cIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbXX0se3RmT3BOYW1lOlwiQnJvYWRjYXN0QXJnc1wiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzMFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInMxXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W119XSx6ST1jbGFzc3tzdGF0aWMgZ2V0IEluc3RhbmNlKCl7cmV0dXJuIHRoaXMuX2luc3RhbmNlfHwodGhpcy5faW5zdGFuY2U9bmV3IHRoaXMpfWNvbnN0cnVjdG9yKCl7bGV0IGU9W1dDLEJDLFZDLFVDLEdDLEhDLGpDLHFDLEtDLFhDLFlDLFpDLEpDLFFDLGVFLHRFLG5FLGFFLHJFXSx0PVtdLmNvbmNhdCguLi5lLm1hcChuPT5uLmpzb24pKTt0aGlzLm9wTWFwcGVycz10LnJlZHVjZSgobixhKT0+KG5bYS50Zk9wTmFtZV09YSxuKSx7fSl9dHJhbnNmb3JtR3JhcGgoZSx0PXt9KXtsZXQgbj1lLm5vZGUsYT1bXSxyPVtdLHM9W10saT1uLnJlZHVjZSgobSxmKT0+KG1bZi5uYW1lXT10aGlzLm1hcE5vZGUoZiksZi5vcC5zdGFydHNXaXRoKFwiUGxhY2Vob2xkZXJcIik/YS5wdXNoKG1bZi5uYW1lXSk6Zi5vcD09PVwiQ29uc3RcIj9yLnB1c2gobVtmLm5hbWVdKTooZi5pbnB1dD09bnVsbHx8Zi5pbnB1dC5sZW5ndGg9PT0wKSYmcy5wdXNoKG1bZi5uYW1lXSksbSkse30pLG89W10sbD1bXSx1PXt9LHA9e307dCE9bnVsbCYmKHU9dGhpcy5tYXBTaWduYXR1cmVFbnRyaWVzKHQuaW5wdXRzKSxwPXRoaXMubWFwU2lnbmF0dXJlRW50cmllcyh0Lm91dHB1dHMpKTtsZXQgZD1PYmplY3Qua2V5cyhpKTtkLmZvckVhY2gobT0+e2xldCBmPWlbbV07Zi5pbnB1dE5hbWVzLmZvckVhY2goKGcsYik9PntsZXRbeSwseF09U3IoZyksdj1pW3ldO2lmKHYub3V0cHV0cyE9bnVsbCl7bGV0IEk9di5vdXRwdXRzLmluZGV4T2YoeCk7aWYoSSE9PS0xKXtsZXQgTj1gJHt5fToke0l9YDtmLmlucHV0TmFtZXNbYl09Tn19Zi5pbnB1dHMucHVzaCh2KSx2LmNoaWxkcmVuLnB1c2goZil9KX0pLE9iamVjdC5rZXlzKHApLmxlbmd0aD09PTA/ZC5mb3JFYWNoKG09PntsZXQgZj1pW21dO2YuY2hpbGRyZW4ubGVuZ3RoPT09MCYmbC5wdXNoKGYpfSk6T2JqZWN0LmtleXMocCkuZm9yRWFjaChtPT57bGV0W2ZdPVNyKG0pLGc9aVtmXTtnIT1udWxsJiYoZy5zaWduYXR1cmVLZXk9cFttXSxsLnB1c2goZykpfSksT2JqZWN0LmtleXModSkubGVuZ3RoPjA/T2JqZWN0LmtleXModSkuZm9yRWFjaChtPT57bGV0W2ZdPVNyKG0pLGc9aVtmXTtnJiYoZy5zaWduYXR1cmVLZXk9dVttXSxvLnB1c2goZykpfSk6bz1hO2xldCBjPXt9O2UubGlicmFyeSE9bnVsbCYmZS5saWJyYXJ5LmZ1bmN0aW9uIT1udWxsJiYoYz1lLmxpYnJhcnkuZnVuY3Rpb24ucmVkdWNlKChtLGYpPT4obVtmLnNpZ25hdHVyZS5uYW1lXT10aGlzLm1hcEZ1bmN0aW9uKGYpLG0pLHt9KSk7bGV0IGg9e25vZGVzOmksaW5wdXRzOm8sb3V0cHV0czpsLHdlaWdodHM6cixwbGFjZWhvbGRlcnM6YSxzaWduYXR1cmU6dCxmdW5jdGlvbnM6Y307cmV0dXJuIHMubGVuZ3RoPjAmJihoLmluaXROb2Rlcz1zKSxofW1hcFNpZ25hdHVyZUVudHJpZXMoZSl7cmV0dXJuIE9iamVjdC5rZXlzKGV8fHt9KS5yZWR1Y2UoKHQsbik9Pih0W2Vbbl0ubmFtZV09bix0KSx7fSl9bWFwTm9kZShlKXtsZXQgdD16QyhlLm9wKXx8dGhpcy5vcE1hcHBlcnNbZS5vcF18fHt9O2UuYXR0cj09bnVsbCYmKGUuYXR0cj17fSk7bGV0IG49e25hbWU6ZS5uYW1lLG9wOmUub3AsY2F0ZWdvcnk6dC5jYXRlZ29yeSxpbnB1dE5hbWVzOihlLmlucHV0fHxbXSkubWFwKGE9PmEuc3RhcnRzV2l0aChcIl5cIik/YS5zbGljZSgxKTphKSxpbnB1dHM6W10sY2hpbGRyZW46W10saW5wdXRQYXJhbXM6e30sYXR0clBhcmFtczp7fSxyYXdBdHRyczplLmF0dHIsb3V0cHV0czp0Lm91dHB1dHN9O3JldHVybiB0LmlucHV0cyE9bnVsbCYmKG4uaW5wdXRQYXJhbXM9dC5pbnB1dHMucmVkdWNlKChhLHIpPT4oYVtyLm5hbWVdPXt0eXBlOnIudHlwZSxpbnB1dEluZGV4U3RhcnQ6ci5zdGFydCxpbnB1dEluZGV4RW5kOnIuZW5kfSxhKSx7fSkpLHQuYXR0cnMhPW51bGwmJihuLmF0dHJQYXJhbXM9dC5hdHRycy5yZWR1Y2UoKGEscik9PntsZXQgcz1yLnR5cGUsaTtzd2l0Y2goci50eXBlKXtjYXNlXCJzdHJpbmdcIjppPVh4KGUuYXR0cixyLnRmTmFtZSxyLmRlZmF1bHRWYWx1ZSksaT09PXZvaWQgMCYmci50ZkRlcHJlY2F0ZWROYW1lJiYoaT1YeChlLmF0dHIsci50ZkRlcHJlY2F0ZWROYW1lLHIuZGVmYXVsdFZhbHVlKSk7YnJlYWs7Y2FzZVwic3RyaW5nW11cIjppPW52KGUuYXR0cixyLnRmTmFtZSxyLmRlZmF1bHRWYWx1ZSksaT09PXZvaWQgMCYmci50ZkRlcHJlY2F0ZWROYW1lJiYoaT1udihlLmF0dHIsci50ZkRlcHJlY2F0ZWROYW1lLHIuZGVmYXVsdFZhbHVlKSk7YnJlYWs7Y2FzZVwibnVtYmVyXCI6aT1aeChlLmF0dHIsci50Zk5hbWUsci5kZWZhdWx0VmFsdWV8fDApLGk9PT12b2lkIDAmJnIudGZEZXByZWNhdGVkTmFtZSYmKGk9WngoZS5hdHRyLHIudGZEZXByZWNhdGVkTmFtZSxyLmRlZmF1bHRWYWx1ZSkpO2JyZWFrO2Nhc2VcIm51bWJlcltdXCI6aT10dihlLmF0dHIsci50Zk5hbWUsci5kZWZhdWx0VmFsdWUpLGk9PT12b2lkIDAmJnIudGZEZXByZWNhdGVkTmFtZSYmKGk9dHYoZS5hdHRyLHIudGZEZXByZWNhdGVkTmFtZSxyLmRlZmF1bHRWYWx1ZSkpO2JyZWFrO2Nhc2VcImJvb2xcIjppPVl4KGUuYXR0cixyLnRmTmFtZSxyLmRlZmF1bHRWYWx1ZSksaT09PXZvaWQgMCYmci50ZkRlcHJlY2F0ZWROYW1lJiYoaT1ZeChlLmF0dHIsci50ZkRlcHJlY2F0ZWROYW1lLHIuZGVmYXVsdFZhbHVlKSk7YnJlYWs7Y2FzZVwiYm9vbFtdXCI6aT1ydihlLmF0dHIsci50Zk5hbWUsci5kZWZhdWx0VmFsdWUpLGk9PT12b2lkIDAmJnIudGZEZXByZWNhdGVkTmFtZSYmKGk9cnYoZS5hdHRyLHIudGZEZXByZWNhdGVkTmFtZSxyLmRlZmF1bHRWYWx1ZSkpO2JyZWFrO2Nhc2VcInNoYXBlXCI6aT1ldihlLmF0dHIsci50Zk5hbWUsci5kZWZhdWx0VmFsdWUpLGk9PT12b2lkIDAmJnIudGZEZXByZWNhdGVkTmFtZSYmKGk9ZXYoZS5hdHRyLHIudGZEZXByZWNhdGVkTmFtZSxyLmRlZmF1bHRWYWx1ZSkpO2JyZWFrO2Nhc2VcInNoYXBlW11cIjppPWF2KGUuYXR0cixyLnRmTmFtZSxyLmRlZmF1bHRWYWx1ZSksaT09PXZvaWQgMCYmci50ZkRlcHJlY2F0ZWROYW1lJiYoaT1hdihlLmF0dHIsci50ZkRlcHJlY2F0ZWROYW1lLHIuZGVmYXVsdFZhbHVlKSk7YnJlYWs7Y2FzZVwiZHR5cGVcIjppPUp4KGUuYXR0cixyLnRmTmFtZSxyLmRlZmF1bHRWYWx1ZSksaT09PXZvaWQgMCYmci50ZkRlcHJlY2F0ZWROYW1lJiYoaT1KeChlLmF0dHIsci50ZkRlcHJlY2F0ZWROYW1lLHIuZGVmYXVsdFZhbHVlKSk7YnJlYWs7Y2FzZVwiZHR5cGVbXVwiOmk9UXgoZS5hdHRyLHIudGZOYW1lLHIuZGVmYXVsdFZhbHVlKSxpPT09dm9pZCAwJiZyLnRmRGVwcmVjYXRlZE5hbWUmJihpPVF4KGUuYXR0cixyLnRmRGVwcmVjYXRlZE5hbWUsci5kZWZhdWx0VmFsdWUpKTticmVhaztjYXNlXCJmdW5jXCI6aT1XSShlLmF0dHIsci50Zk5hbWUsci5kZWZhdWx0VmFsdWUpLGk9PT12b2lkIDAmJnIudGZEZXByZWNhdGVkTmFtZSYmKGk9V0koZS5hdHRyLHIudGZEZXByZWNhdGVkTmFtZSxyLmRlZmF1bHRWYWx1ZSkpO2JyZWFrO2Nhc2VcInRlbnNvclwiOmNhc2VcInRlbnNvcnNcIjpicmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGFyYW0gdHlwZTogJHtyLnR5cGV9IGZvciBvcDogJHtlLm9wfWApfXJldHVybiBhW3IubmFtZV09e3ZhbHVlOmksdHlwZTpzfSxhfSx7fSkpLG59bWFwRnVuY3Rpb24oZSl7bGV0IHQ9ZS5ub2RlRGVmLG49W10sYT1bXSxyPXt9O3QhPW51bGwmJihyPXQucmVkdWNlKCh1LHApPT4odVtwLm5hbWVdPXRoaXMubWFwTm9kZShwKSxwLm9wPT09XCJDb25zdFwiJiZhLnB1c2godVtwLm5hbWVdKSx1KSx7fSkpO2xldCBzPVtdLGk9W107ZS5zaWduYXR1cmUuaW5wdXRBcmcuZm9yRWFjaCh1PT57bGV0W3BdPVNyKHUubmFtZSksZD17bmFtZTpwLG9wOlwiUGxhY2Vob2xkZXJcIixpbnB1dHM6W10saW5wdXROYW1lczpbXSxjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRQYXJhbXM6e30sYXR0clBhcmFtczp7ZHR5cGU6e3ZhbHVlOkExKHUudHlwZSksdHlwZTpcImR0eXBlXCJ9fSxjaGlsZHJlbjpbXX07ZC5zaWduYXR1cmVLZXk9dS5uYW1lLHMucHVzaChkKSxyW3BdPWR9KSxPYmplY3Qua2V5cyhyKS5mb3JFYWNoKHU9PntsZXQgcD1yW3VdO3AuaW5wdXROYW1lcy5mb3JFYWNoKChkLGMpPT57bGV0W2gsLG1dPVNyKGQpLGY9cltoXTtpZihmLm91dHB1dHMhPW51bGwpe2xldCBnPWYub3V0cHV0cy5pbmRleE9mKG0pO2lmKGchPT0tMSl7bGV0IGI9YCR7aH06JHtnfWA7cC5pbnB1dE5hbWVzW2NdPWJ9fXAuaW5wdXRzLnB1c2goZiksZi5jaGlsZHJlbi5wdXNoKHApfSl9KTtsZXQgbz1lLnJldDtlLnNpZ25hdHVyZS5vdXRwdXRBcmcuZm9yRWFjaCh1PT57bGV0W3AsZF09U3Iob1t1Lm5hbWVdKSxjPXJbcF07YyE9bnVsbCYmKGMuZGVmYXVsdE91dHB1dD1kLGkucHVzaChjKSl9KTtsZXQgbD10aGlzLm1hcEFyZ3NUb1NpZ25hdHVyZShlKTtyZXR1cm57bm9kZXM6cixpbnB1dHM6cyxvdXRwdXRzOmksd2VpZ2h0czphLHBsYWNlaG9sZGVyczpuLHNpZ25hdHVyZTpsfX1tYXBBcmdzVG9TaWduYXR1cmUoZSl7cmV0dXJue21ldGhvZE5hbWU6ZS5zaWduYXR1cmUubmFtZSxpbnB1dHM6ZS5zaWduYXR1cmUuaW5wdXRBcmcucmVkdWNlKCh0LG4pPT4odFtuLm5hbWVdPXRoaXMubWFwQXJnVG9UZW5zb3JJbmZvKG4pLHQpLHt9KSxvdXRwdXRzOmUuc2lnbmF0dXJlLm91dHB1dEFyZy5yZWR1Y2UoKHQsbik9Pih0W24ubmFtZV09dGhpcy5tYXBBcmdUb1RlbnNvckluZm8obixlLnJldCksdCkse30pfX1tYXBBcmdUb1RlbnNvckluZm8oZSx0KXtsZXQgbj1lLm5hbWU7cmV0dXJuIHQhPW51bGwmJihuPXRbbl0pLHtuYW1lOm4sZHR5cGU6ZS50eXBlfX19O2Z1bmN0aW9uIE1xKGUpe2xldCB0PUcoKS5nbG9iYWw7aWYodHlwZW9mIHQuYXRvYiE9XCJ1bmRlZmluZWRcIilyZXR1cm4gdC5hdG9iKGUpO2lmKHR5cGVvZiBCdWZmZXIhPVwidW5kZWZpbmVkXCIpcmV0dXJuIG5ldyBCdWZmZXIoZSxcImJhc2U2NFwiKS50b1N0cmluZygpO3Rocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBkZWNvZGUgYmFzZTY0IGluIHRoaXMgZW52aXJvbm1lbnQuIE1pc3NpbmcgYnVpbHQtaW4gYXRvYigpIG9yIEJ1ZmZlcigpXCIpfWZ1bmN0aW9uIHNFKGUsdCl7bGV0IG49QXJyYXkuaXNBcnJheShlKT9TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsZSk6TXEoZSk7cmV0dXJuIHQ/bjpuLnRvTG93ZXJDYXNlKCl9ZnVuY3Rpb24gWHgoZSx0LG4sYT0hMSl7bGV0IHI9ZVt0XTtyZXR1cm4gciE9bnVsbD9zRShyLnMsYSk6bn1mdW5jdGlvbiBZeChlLHQsbil7bGV0IGE9ZVt0XTtyZXR1cm4gYT9hLmI6bn1mdW5jdGlvbiBaeChlLHQsbil7bGV0IGE9ZVt0XXx8e30scj1hLmkhPW51bGw/YS5pOmEuZiE9bnVsbD9hLmY6bjtyZXR1cm4gdHlwZW9mIHI9PVwibnVtYmVyXCI/cjpwYXJzZUludChyLDEwKX1mdW5jdGlvbiBBMShlKXtzd2l0Y2godHlwZW9mIGU9PVwic3RyaW5nXCImJihlPXFuW2VdKSxlKXtjYXNlIHFuLkRUX0ZMT0FUOmNhc2UgcW4uRFRfSEFMRjpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIHFuLkRUX0lOVDMyOmNhc2UgcW4uRFRfSU5UNjQ6Y2FzZSBxbi5EVF9JTlQ4OmNhc2UgcW4uRFRfVUlOVDg6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgcW4uRFRfQk9PTDpyZXR1cm5cImJvb2xcIjtjYXNlIHFuLkRUX0RPVUJMRTpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIHFuLkRUX1NUUklORzpyZXR1cm5cInN0cmluZ1wiO2Nhc2UgcW4uRFRfQ09NUExFWDY0OmNhc2UgcW4uRFRfQ09NUExFWDEyODpyZXR1cm5cImNvbXBsZXg2NFwiO2RlZmF1bHQ6cmV0dXJuIG51bGx9fWZ1bmN0aW9uIFdJKGUsdCxuKXtsZXQgYT1lW3RdO3JldHVybiBhJiZhLmZ1bmM/YS5mdW5jLm5hbWU6bn1mdW5jdGlvbiBKeChlLHQsbil7bGV0IGE9ZVt0XTtyZXR1cm4gYSYmYS50eXBlP0ExKGEudHlwZSk6bn1mdW5jdGlvbiBReChlLHQsbil7bGV0IGE9ZVt0XTtyZXR1cm4gYSYmYS5saXN0JiZhLmxpc3QudHlwZT9hLmxpc3QudHlwZS5tYXAocj0+QTEocikpOm59ZnVuY3Rpb24gaUUoZSl7aWYoIWUudW5rbm93blJhbmspcmV0dXJuIGUuZGltIT1udWxsP2UuZGltLm1hcCh0PT50eXBlb2YgdC5zaXplPT1cIm51bWJlclwiP3Quc2l6ZTpwYXJzZUludCh0LnNpemUsMTApKTpbXX1mdW5jdGlvbiBldihlLHQsbil7bGV0IGE9ZVt0XTtyZXR1cm4gYSYmYS5zaGFwZT9pRShhLnNoYXBlKTpufWZ1bmN0aW9uIHR2KGUsdCxuKXtsZXQgYT1lW3RdO3JldHVybiBhPygoYS5saXN0LmYmJmEubGlzdC5mLmxlbmd0aD9hLmxpc3QuZjphLmxpc3QuaSl8fFtdKS5tYXAocj0+dHlwZW9mIHI9PVwibnVtYmVyXCI/cjpwYXJzZUludChyLDEwKSk6bn1mdW5jdGlvbiBudihlLHQsbixhPSExKXtsZXQgcj1lW3RdO3JldHVybiByJiZyLmxpc3QmJnIubGlzdC5zP3IubGlzdC5zLm1hcChzPT5zRShzLGEpKTpufWZ1bmN0aW9uIGF2KGUsdCxuKXtsZXQgYT1lW3RdO3JldHVybiBhJiZhLmxpc3QmJmEubGlzdC5zaGFwZT9hLmxpc3Quc2hhcGUubWFwKHI9PmlFKHIpKTpufWZ1bmN0aW9uIHJ2KGUsdCxuKXtsZXQgYT1lW3RdO3JldHVybiBhJiZhLmxpc3QmJmEubGlzdC5iP2EubGlzdC5iOm59dmFyIE9xPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuKXt0aGlzLm5vZGU9ZSx0aGlzLnRlbnNvck1hcD10LHRoaXMuY29udGV4dD1uLHRoaXMuaW5wdXRzPVtdLHRoaXMuYXR0cnM9e30sdGhpcy5pbnB1dHM9ZS5pbnB1dE5hbWVzLm1hcChhPT50aGlzLmdldElucHV0KGEpKSxlLnJhd0F0dHJzIT1udWxsJiYodGhpcy5hdHRycz1PYmplY3Qua2V5cyhlLnJhd0F0dHJzKS5yZWR1Y2UoKGEscik9PihhW3JdPXRoaXMuZ2V0QXR0cihyKSxhKSx7fSkpfWdldElucHV0KGUpe3JldHVybiBwbihlLHRoaXMudGVuc29yTWFwLHRoaXMuY29udGV4dCl9Z2V0QXR0cihlLHQpe2xldCBuPXRoaXMubm9kZS5yYXdBdHRyc1tlXTtpZihuLnRlbnNvciE9bnVsbClyZXR1cm4gcG4oZSx0aGlzLnRlbnNvck1hcCx0aGlzLmNvbnRleHQpO2lmKG4uaSE9bnVsbHx8bi5mIT1udWxsKXJldHVybiBaeCh0aGlzLm5vZGUucmF3QXR0cnMsZSx0KTtpZihuLnMhPW51bGwpcmV0dXJuIFh4KHRoaXMubm9kZS5yYXdBdHRycyxlLHQpO2lmKG4uYiE9bnVsbClyZXR1cm4gWXgodGhpcy5ub2RlLnJhd0F0dHJzLGUsdCk7aWYobi5zaGFwZSE9bnVsbClyZXR1cm4gZXYodGhpcy5ub2RlLnJhd0F0dHJzLGUsdCk7aWYobi50eXBlIT1udWxsKXJldHVybiBKeCh0aGlzLm5vZGUucmF3QXR0cnMsZSx0KTtpZihuLmxpc3QhPW51bGwpe2lmKG4ubGlzdC5pIT1udWxsfHxuLmxpc3QuZiE9bnVsbClyZXR1cm4gdHYodGhpcy5ub2RlLnJhd0F0dHJzLGUsdCk7aWYobi5saXN0LnMhPW51bGwpcmV0dXJuIG52KHRoaXMubm9kZS5yYXdBdHRycyxlLHQpO2lmKG4ubGlzdC5zaGFwZSE9bnVsbClyZXR1cm4gYXYodGhpcy5ub2RlLnJhd0F0dHJzLGUsdCk7aWYobi5saXN0LmIhPW51bGwpcmV0dXJuIHJ2KHRoaXMubm9kZS5yYXdBdHRycyxlLHQpO2lmKG4ubGlzdC50eXBlIT1udWxsKXJldHVybiBReCh0aGlzLm5vZGUucmF3QXR0cnMsZSx0KX1yZXR1cm4gdH19LG9uPXt9O19lKG9uLHtPUF9TQ09QRV9TVUZGSVg6KCk9PkZ2LGFiczooKT0+THQsYWNvczooKT0+UHYsYWNvc2g6KCk9Pkx2LGFkZDooKT0+WCxhZGROOigpPT52TixhbGw6KCk9PkxtLGFueTooKT0+eWMsYXJnTWF4OigpPT5kaSxhcmdNaW46KCk9Pnp2LGFzaW46KCk9Pld2LGFzaW5oOigpPT5CdixhdGFuOigpPT5WdixhdGFuMjooKT0+VXYsYXRhbmg6KCk9Pkd2LGF2Z1Bvb2w6KCk9PnlhLGF2Z1Bvb2wzZDooKT0+anYsYmFzaWNMU1RNQ2VsbDooKT0+U04sYmF0Y2hOb3JtOigpPT5OcyxiYXRjaE5vcm0yZDooKT0+cXYsYmF0Y2hOb3JtM2Q6KCk9Pkt2LGJhdGNoTm9ybTRkOigpPT5YdixiYXRjaFRvU3BhY2VORDooKT0+aWQsYmluY291bnQ6KCk9Pll2LGJpdHdpc2VBbmQ6KCk9Pk5OLGJvb2xlYW5NYXNrQXN5bmM6KCk9Pm1ULGJyb2FkY2FzdEFyZ3M6KCk9PlROLGJyb2FkY2FzdFRvOigpPT5haSxidWZmZXI6KCk9Pk9lLGNhc3Q6KCk9PnJlLGNlaWw6KCk9Plp2LGNsaXBCeVZhbHVlOigpPT5hbixjbG9uZTooKT0+c3IsY29tcGxleDooKT0+X3IsY29uY2F0OigpPT5ldCxjb25jYXQxZDooKT0+SnYsY29uY2F0MmQ6KCk9PlF2LGNvbmNhdDNkOigpPT5ldyxjb25jYXQ0ZDooKT0+dHcsY29udjFkOigpPT56bSxjb252MmQ6KCk9PiR0LGNvbnYyZFRyYW5zcG9zZTooKT0+V20sY29udjNkOigpPT5hdyxjb252M2RUcmFuc3Bvc2U6KCk9PnJ3LGNvczooKT0+b2QsY29zaDooKT0+Qm0sY29zaW5lV2luZG93OigpPT5wZixjdW1wcm9kOigpPT53YyxjdW1zdW06KCk9PlZtLGRlbnNlQmluY291bnQ6KCk9PlhoLGRlcHRoVG9TcGFjZTooKT0+c3csZGVwdGh3aXNlQ29udjJkOigpPT5UcyxkaWFnOigpPT5FTixkaWxhdGlvbjJkOigpPT5pdyxkaXY6KCk9PmhlLGRpdk5vTmFuOigpPT5vdyxkb3Q6KCk9Pmx3LGRyb3BvdXQ6KCk9PlB3LGVpbnN1bTooKT0+WnMsZWx1OigpPT5RdSxlbmNsb3NpbmdQb3dlck9mVHdvOigpPT5MdyxlbnN1cmVTaGFwZTooKT0+QU4sZXF1YWw6KCk9PkpuLGVyZjooKT0+VW0sZXVjbGlkZWFuTm9ybTooKT0+Y3csZXhwOigpPT5kbixleHBhbmREaW1zOigpPT5HdCxleHBtMTooKT0+ZHcsZXllOigpPT5HbSxmZnQ6KCk9PmJkLGZpbGw6KCk9PnluLGZsb29yOigpPT50cCxmbG9vckRpdjooKT0+UG0sZnVzZWQ6KCk9PlZsLGdhdGhlcjooKT0+bnAsZ2F0aGVyTkQ6KCk9PnlULGdyZWF0ZXI6KCk9PkNuLGdyZWF0ZXJFcXVhbDooKT0+JHIsaWZmdDooKT0+QmwsaW1hZzooKT0+bGQsaW1hZ2U6KCk9PlpuLGluVG9wS0FzeW5jOigpPT54VCxpcmZmdDooKT0+YWYsaXNGaW5pdGU6KCk9Pmh3LGlzSW5mOigpPT5tdyxpc05hTjooKT0+ZncsbGVha3lSZWx1OigpPT51ZCxsZXNzOigpPT5QbCxsZXNzRXF1YWw6KCk9PkNzLGxpbmFsZzooKT0+QncsbGluc3BhY2U6KCk9Pk1OLGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uOigpPT5ndyxsb2c6KCk9PlFuLGxvZzFwOigpPT5wZCxsb2dTaWdtb2lkOigpPT5idyxsb2dTb2Z0bWF4OigpPT5qbSxsb2dTdW1FeHA6KCk9PmNkLGxvZ2ljYWxBbmQ6KCk9Pl9hLGxvZ2ljYWxOb3Q6KCk9PmRkLGxvZ2ljYWxPcjooKT0+cW0sbG9naWNhbFhvcjooKT0+eXcsbG9zc2VzOigpPT5GVCxsb3dlckJvdW5kOigpPT5QTixtYXRNdWw6KCk9PiRlLG1heDooKT0+bWEsbWF4UG9vbDooKT0+RHQsbWF4UG9vbDNkOigpPT54dyxtYXhQb29sV2l0aEFyZ21heDooKT0+TE4sbWF4aW11bTooKT0+aHIsbWVhbjooKT0+Q3QsbWVzaGdyaWQ6KCk9PnpOLG1pbjooKT0+T2wsbWluaW11bTooKT0+ZHMsbWlycm9yUGFkOigpPT52dyxtb2Q6KCk9Pnd3LG1vbWVudHM6KCk9PmhkLG1vdmluZ0F2ZXJhZ2U6KCk9PmZULG11bDooKT0+eixtdWx0aVJOTkNlbGw6KCk9PldOLG11bHRpbm9taWFsOigpPT5CTixuZWc6KCk9Pnl0LG5vcm06KCk9PmVwLG5vdEVxdWFsOigpPT5maSxvbmVIb3Q6KCk9PkxsLG9uZXM6KCk9PlBuLG9uZXNMaWtlOigpPT5lYSxvcDooKT0+TCxvdXRlclByb2R1Y3Q6KCk9PlZOLHBhZDooKT0+eGEscGFkMWQ6KCk9PlVOLHBhZDJkOigpPT5HTixwYWQzZDooKT0+SE4scGFkNGQ6KCk9PmpOLHBvb2w6KCk9Pmt3LHBvdzooKT0+dXIscHJlbHU6KCk9PmZkLHByaW50OigpPT5Pdixwcm9kOigpPT5JdyxyYWdnZWRHYXRoZXI6KCk9PnFOLHJhZ2dlZFJhbmdlOigpPT5LTixyYWdnZWRUZW5zb3JUb1RlbnNvcjooKT0+WE4scmFuZDooKT0+WU4scmFuZG9tR2FtbWE6KCk9PmVULHJhbmRvbU5vcm1hbDooKT0+WG0scmFuZG9tU3RhbmRhcmROb3JtYWw6KCk9PnRULHJhbmRvbVVuaWZvcm06KCk9PkVzLHJhbmRvbVVuaWZvcm1JbnQ6KCk9Pm5ULHJhbmdlOigpPT5naSxyZWFsOigpPT56bCxyZWNpcHJvY2FsOigpPT5FdyxyZWx1OigpPT5LZSxyZWx1NjooKT0+WW0scmVzaGFwZTooKT0+VyxyZXZlcnNlOigpPT5iYSxyZXZlcnNlMWQ6KCk9PmFULHJldmVyc2UyZDooKT0+clQscmV2ZXJzZTNkOigpPT5zVCxyZXZlcnNlNGQ6KCk9PmlULHJmZnQ6KCk9PnlkLHJvdW5kOigpPT5abSxyc3FydDooKT0+Sm0sc2NhbGFyOigpPT54ZSxzY2F0dGVyTkQ6KCk9PmdULHNlYXJjaFNvcnRlZDooKT0+S20sc2VsdTooKT0+UW0sc2VwYXJhYmxlQ29udjJkOigpPT5fcyxzZXRkaWZmMWRBc3luYzooKT0+b1Qsc2lnbW9pZDooKT0+aGEsc2lnbjooKT0+X3csc2lnbmFsOigpPT5BVCxzaW46KCk9PmVmLHNpbmg6KCk9PnRmLHNsaWNlOigpPT5WZSxzbGljZTFkOigpPT5nZCxzbGljZTJkOigpPT5uZixzbGljZTNkOigpPT5IbyxzbGljZTRkOigpPT5XbCxzb2Z0bWF4OigpPT5xYSxzb2Z0cGx1czooKT0+R28sc3BhY2VUb0JhdGNoTkQ6KCk9Pm1kLHNwYXJzZTooKT0+JFQsc3BhcnNlVG9EZW5zZTooKT0+YlQsc3BlY3RyYWw6KCk9Pl9ULHNwbGl0OigpPT5MbixzcXJ0OigpPT5ybixzcXVhcmU6KCk9PnB0LHNxdWFyZWREaWZmZXJlbmNlOigpPT5yZixzcXVlZXplOigpPT5BcyxzdGFjazooKT0+QXQsc3RlcDooKT0+am8sc3RyaWRlZFNsaWNlOigpPT5BdyxzdHJpbmc6KCk9PkRULHN1YjooKT0+cGUsc3VtOigpPT5mZSx0YW46KCk9PkZ3LHRhbmg6KCk9PmNzLHRlbnNvcjooKT0+Ym4sdGVuc29yMWQ6KCk9PmplLHRlbnNvcjJkOigpPT5FYSx0ZW5zb3IzZDooKT0+eGQsdGVuc29yNGQ6KCk9PkZhLHRlbnNvcjVkOigpPT5sVCx0ZW5zb3I2ZDooKT0+dVQsdGVuc29yU2NhdHRlclVwZGF0ZTooKT0+Y1QsdGlsZTooKT0+T24sdG9wazooKT0+RHcsdHJhbnNwb3NlOigpPT5EZSx0cnVuY2F0ZWROb3JtYWw6KCk9PmxmLHVuaXF1ZTooKT0+UncsdW5zb3J0ZWRTZWdtZW50U3VtOigpPT51Zix1bnN0YWNrOigpPT5kdCx1cHBlckJvdW5kOigpPT5kVCx2YXJpYWJsZTooKT0+TXcsd2hlcmU6KCk9Pm5uLHdoZXJlQXN5bmM6KCk9Pk93LHplcm9zOigpPT5JdCx6ZXJvc0xpa2U6KCk9PnFlfSk7dmFyIFBxPShlLHQsbixhPW9uKT0+e3N3aXRjaChlLm9wKXtjYXNlXCJCaWFzQWRkXCI6Y2FzZVwiQWRkVjJcIjpjYXNlXCJBZGRcIjpyZXR1cm5bYS5hZGQoayhcImFcIixlLHQsbiksayhcImJcIixlLHQsbikpXTtjYXNlXCJBZGROXCI6cmV0dXJuW2EuYWRkTihrKFwidGVuc29yc1wiLGUsdCxuKSldO2Nhc2VcIkZsb29yTW9kXCI6Y2FzZVwiTW9kXCI6cmV0dXJuW2EubW9kKGsoXCJhXCIsZSx0LG4pLGsoXCJiXCIsZSx0LG4pKV07Y2FzZVwiTXVsXCI6cmV0dXJuW2EubXVsKGsoXCJhXCIsZSx0LG4pLGsoXCJiXCIsZSx0LG4pKV07Y2FzZVwiUmVhbERpdlwiOmNhc2VcIkRpdlwiOnJldHVyblthLmRpdihrKFwiYVwiLGUsdCxuKSxrKFwiYlwiLGUsdCxuKSldO2Nhc2VcIkRpdk5vTmFuXCI6cmV0dXJuW2EuZGl2Tm9OYW4oayhcImFcIixlLHQsbiksayhcImJcIixlLHQsbikpXTtjYXNlXCJGbG9vckRpdlwiOnJldHVyblthLmZsb29yRGl2KGsoXCJhXCIsZSx0LG4pLGsoXCJiXCIsZSx0LG4pKV07Y2FzZVwiU3ViXCI6cmV0dXJuW2Euc3ViKGsoXCJhXCIsZSx0LG4pLGsoXCJiXCIsZSx0LG4pKV07Y2FzZVwiTWluaW11bVwiOnJldHVyblthLm1pbmltdW0oayhcImFcIixlLHQsbiksayhcImJcIixlLHQsbikpXTtjYXNlXCJNYXhpbXVtXCI6cmV0dXJuW2EubWF4aW11bShrKFwiYVwiLGUsdCxuKSxrKFwiYlwiLGUsdCxuKSldO2Nhc2VcIlBvd1wiOnJldHVyblthLnBvdyhrKFwiYVwiLGUsdCxuKSxrKFwiYlwiLGUsdCxuKSldO2Nhc2VcIlNxdWFyZWREaWZmZXJlbmNlXCI6cmV0dXJuW2Euc3F1YXJlZERpZmZlcmVuY2UoayhcImFcIixlLHQsbiksayhcImJcIixlLHQsbikpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihgTm9kZSB0eXBlICR7ZS5vcH0gaXMgbm90IGltcGxlbWVudGVkYCl9fSxMcT0oZSx0LG4sYT1vbik9Pntzd2l0Y2goZS5vcCl7Y2FzZVwiQWJzXCI6Y2FzZVwiQ29tcGxleEFic1wiOnJldHVyblthLmFicyhrKFwieFwiLGUsdCxuKSldO2Nhc2VcIkFjb3NcIjpyZXR1cm5bYS5hY29zKGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiQWNvc2hcIjpyZXR1cm5bYS5hY29zaChrKFwieFwiLGUsdCxuKSldO2Nhc2VcIkFzaW5cIjpyZXR1cm5bYS5hc2luKGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiQXNpbmhcIjpyZXR1cm5bYS5hc2luaChrKFwieFwiLGUsdCxuKSldO2Nhc2VcIkF0YW5cIjpyZXR1cm5bYS5hdGFuKGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiQXRhbjJcIjpyZXR1cm5bYS5hdGFuMihrKFwieFwiLGUsdCxuKSxrKFwieVwiLGUsdCxuKSldO2Nhc2VcIkF0YW5oXCI6cmV0dXJuW2EuYXRhbmgoayhcInhcIixlLHQsbikpXTtjYXNlXCJDZWlsXCI6cmV0dXJuW2EuY2VpbChrKFwieFwiLGUsdCxuKSldO2Nhc2VcIkNvbXBsZXhcIjpyZXR1cm5bYS5jb21wbGV4KGsoXCJyZWFsXCIsZSx0LG4pLGsoXCJpbWFnXCIsZSx0LG4pKV07Y2FzZVwiQ29zXCI6cmV0dXJuW2EuY29zKGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiQ29zaFwiOnJldHVyblthLmNvc2goayhcInhcIixlLHQsbikpXTtjYXNlXCJFbHVcIjpyZXR1cm5bYS5lbHUoayhcInhcIixlLHQsbikpXTtjYXNlXCJFcmZcIjpyZXR1cm5bYS5lcmYoayhcInhcIixlLHQsbikpXTtjYXNlXCJFeHBcIjpyZXR1cm5bYS5leHAoayhcInhcIixlLHQsbikpXTtjYXNlXCJFeHBtMVwiOnJldHVyblthLmV4cG0xKGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiRmxvb3JcIjpyZXR1cm5bYS5mbG9vcihrKFwieFwiLGUsdCxuKSldO2Nhc2VcIkxvZ1wiOnJldHVyblthLmxvZyhrKFwieFwiLGUsdCxuKSldO2Nhc2VcIkxvZzFwXCI6cmV0dXJuW2EubG9nMXAoayhcInhcIixlLHQsbikpXTtjYXNlXCJJbWFnXCI6cmV0dXJuW2EuaW1hZyhrKFwieFwiLGUsdCxuKSldO2Nhc2VcIk5lZ1wiOnJldHVyblthLm5lZyhrKFwieFwiLGUsdCxuKSldO2Nhc2VcIlJlY2lwcm9jYWxcIjpyZXR1cm5bYS5yZWNpcHJvY2FsKGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiUmVhbFwiOnJldHVyblthLnJlYWwoayhcInhcIixlLHQsbikpXTtjYXNlXCJSZWx1XCI6cmV0dXJuW2EucmVsdShrKFwieFwiLGUsdCxuKSldO2Nhc2VcIlJvdW5kXCI6cmV0dXJuW2Eucm91bmQoayhcInhcIixlLHQsbikpXTtjYXNlXCJTZWx1XCI6cmV0dXJuW2Euc2VsdShrKFwieFwiLGUsdCxuKSldO2Nhc2VcIlNpZ21vaWRcIjpyZXR1cm5bYS5zaWdtb2lkKGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiU2luXCI6cmV0dXJuW2Euc2luKGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiU2lnblwiOnJldHVyblthLnNpZ24oayhcInhcIixlLHQsbikpXTtjYXNlXCJTaW5oXCI6cmV0dXJuW2Euc2luaChrKFwieFwiLGUsdCxuKSldO2Nhc2VcIlNvZnRwbHVzXCI6cmV0dXJuW2Euc29mdHBsdXMoayhcInhcIixlLHQsbikpXTtjYXNlXCJTcXJ0XCI6cmV0dXJuW2Euc3FydChrKFwieFwiLGUsdCxuKSldO2Nhc2VcIlNxdWFyZVwiOnJldHVyblthLnNxdWFyZShrKFwieFwiLGUsdCxuKSldO2Nhc2VcIlRhbmhcIjpyZXR1cm5bYS50YW5oKGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiVGFuXCI6cmV0dXJuW2EudGFuKGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiQ2xpcEJ5VmFsdWVcIjpyZXR1cm5bYS5jbGlwQnlWYWx1ZShrKFwieFwiLGUsdCxuKSxrKFwiY2xpcFZhbHVlTWluXCIsZSx0LG4pLGsoXCJjbGlwVmFsdWVNYXhcIixlLHQsbikpXTtjYXNlXCJSZWx1NlwiOnJldHVyblthLnJlbHU2KGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiUnNxcnRcIjpyZXR1cm5bYS5yc3FydChwbihlLmlucHV0TmFtZXNbMF0sdCxuKSldO2Nhc2VcIkxlYWt5UmVsdVwiOnJldHVyblthLmxlYWt5UmVsdShrKFwieFwiLGUsdCxuKSxrKFwiYWxwaGFcIixlLHQsbikpXTtjYXNlXCJQcmVsdVwiOnJldHVyblthLnByZWx1KGsoXCJ4XCIsZSx0LG4pLGsoXCJhbHBoYVwiLGUsdCxuKSldO2Nhc2VcIklzTmFuXCI6cmV0dXJuW2EuaXNOYU4ocG4oZS5pbnB1dE5hbWVzWzBdLHQsbikpXTtjYXNlXCJJc0luZlwiOnJldHVyblthLmlzSW5mKHBuKGUuaW5wdXROYW1lc1swXSx0LG4pKV07Y2FzZVwiSXNGaW5pdGVcIjpyZXR1cm5bYS5pc0Zpbml0ZShwbihlLmlucHV0TmFtZXNbMF0sdCxuKSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKGBOb2RlIHR5cGUgJHtlLm9wfSBpcyBub3QgaW1wbGVtZW50ZWRgKX19O2Z1bmN0aW9uIENhKGUsdCxuPVwiXCIpe2lmKCEodHlwZW9mIGU9PVwibnVtYmVyXCJ8fHR5cGVvZiB0PT1cIm51bWJlclwiKSl7dy5hc3NlcnQoZS5sZW5ndGg9PT10Lmxlbmd0aCwoKT0+bitgIFNoYXBlcyAke2V9IGFuZCAke3R9IG11c3QgbWF0Y2hgKTtmb3IobGV0IGE9MDthPGUubGVuZ3RoO2ErKyl7bGV0IHI9ZVthXSxzPXRbYV07dy5hc3NlcnQocjwwfHxzPDB8fHI9PT1zLCgpPT5uK2AgU2hhcGVzICR7ZX0gYW5kICR7dH0gbXVzdCBtYXRjaGApfX19ZnVuY3Rpb24gQkkoZSl7cmV0dXJuISh0eXBlb2YgZT09XCJudW1iZXJcInx8ZS5zb21lKHQ9PnQ8MCkpfWZ1bmN0aW9uIFpwKGUsdCxuKXtsZXQgYT1zdihlLG4pLHI9IUJJKGEpO2lmKHImJnQubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoYFRyaWVkIHRvIGNhbGN1bGF0ZSBlbGVtZW50cyBvZiBhbiBlbXB0eSBsaXN0IHdpdGggbm9uLWZ1bGx5LWRlZmluZWQgZWxlbWVudFNoYXBlOiAke2F9YCk7aWYociYmdC5mb3JFYWNoKHM9PnthPXN2KHMuc2hhcGUsYSl9KSwhQkkoYSkpdGhyb3cgbmV3IEVycm9yKGBOb24tZnVsbHktZGVmaW5lZCBlbGVtZW50U2hhcGU6ICR7YX1gKTtyZXR1cm4gYX1mdW5jdGlvbiBzdihlLHQpe2lmKHR5cGVvZiBlPT1cIm51bWJlclwiKXJldHVybiB0O2lmKHR5cGVvZiB0PT1cIm51bWJlclwiKXJldHVybiBlO2lmKGUubGVuZ3RoIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBJbmNvbXBhdGlibGUgcmFua3MgZHVyaW5nIG1lcmdlOiAke2V9IHZzLiAke3R9YCk7bGV0IG49W107Zm9yKGxldCBhPTA7YTxlLmxlbmd0aDsrK2Epe2xldCByPWVbYV0scz10W2FdO2lmKHI+PTAmJnM+PTAmJnIhPT1zKXRocm93IG5ldyBFcnJvcihgSW5jb21wYXRpYmxlIHNoYXBlIGR1cmluZyBtZXJnZTogJHtlfSB2cy4gJHt0fWApO25bYV09cj49MD9yOnN9cmV0dXJuIG59dmFyIHpxPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuLGEscixzLGkpe3RoaXMubmFtZT1lLHRoaXMuZHR5cGU9dCx0aGlzLm1heFNpemU9bix0aGlzLmVsZW1lbnRTaGFwZT1hLHRoaXMuaWRlbnRpY2FsRWxlbWVudFNoYXBlcz1yLHRoaXMuZHluYW1pY1NpemU9cyx0aGlzLmNsZWFyQWZ0ZXJSZWFkPWksdGhpcy50ZW5zb3JzPVtdLHRoaXMuY2xvc2VkXz0hMSx0aGlzLmlkVGVuc29yPXhlKDApLEh0KHRoaXMuaWRUZW5zb3IpfWdldCBpZCgpe3JldHVybiB0aGlzLmlkVGVuc29yLmlkfWdldCBjbG9zZWQoKXtyZXR1cm4gdGhpcy5jbG9zZWRffWNsZWFyQW5kQ2xvc2UoZSl7dGhpcy50ZW5zb3JzLmZvckVhY2godD0+eyhlPT1udWxsfHwhZS5oYXModC50ZW5zb3IuaWQpKSYmdC50ZW5zb3IuZGlzcG9zZSgpfSksdGhpcy50ZW5zb3JzPVtdLHRoaXMuY2xvc2VkXz0hMCx0aGlzLmlkVGVuc29yLmRpc3Bvc2UoKX1zaXplKCl7cmV0dXJuIHRoaXMudGVuc29ycy5sZW5ndGh9cmVhZChlKXtpZih0aGlzLmNsb3NlZF8pdGhyb3cgbmV3IEVycm9yKGBUZW5zb3JBcnJheSAke3RoaXMubmFtZX0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuYCk7aWYoZTwwfHxlPj10aGlzLnNpemUoKSl0aHJvdyBuZXcgRXJyb3IoYFRyaWVkIHRvIHJlYWQgZnJvbSBpbmRleCAke2V9LCBidXQgYXJyYXkgc2l6ZSBpczogJHt0aGlzLnNpemUoKX1gKTtsZXQgdD10aGlzLnRlbnNvcnNbZV07aWYodC5jbGVhcmVkKXRocm93IG5ldyBFcnJvcihgVGVuc29yQXJyYXkgJHt0aGlzLm5hbWV9OiBDb3VsZCBub3QgcmVhZCBpbmRleCAke2V9IHR3aWNlIGJlY2F1c2UgaXQgd2FzIGNsZWFyZWQgYWZ0ZXIgYSBwcmV2aW91cyByZWFkIChwZXJoYXBzIHRyeSBzZXR0aW5nIGNsZWFyX2FmdGVyX3JlYWQgPSBmYWxzZT8pLmApO3JldHVybiB0aGlzLmNsZWFyQWZ0ZXJSZWFkJiYodC5jbGVhcmVkPSEwKSx0LnJlYWQ9ITAsdC50ZW5zb3J9cmVhZE1hbnkoZSl7cmV0dXJuIGUubWFwKHQ9PnRoaXMucmVhZCh0KSl9d3JpdGUoZSx0KXtpZih0aGlzLmNsb3NlZF8pdGhyb3cgbmV3IEVycm9yKGBUZW5zb3JBcnJheSAke3RoaXMubmFtZX0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuYCk7aWYoZTwwfHwhdGhpcy5keW5hbWljU2l6ZSYmZT49dGhpcy5tYXhTaXplKXRocm93IG5ldyBFcnJvcihgVHJpZWQgdG8gd3JpdGUgdG8gaW5kZXggJHtlfSwgYnV0IGFycmF5IGlzIG5vdCByZXNpemVhYmxlIGFuZCBzaXplIGlzOiAke3RoaXMubWF4U2l6ZX1gKTtsZXQgbj10aGlzLnRlbnNvcnNbZV18fHt9O2lmKHQuZHR5cGUhPT10aGlzLmR0eXBlKXRocm93IG5ldyBFcnJvcihgVGVuc29yQXJyYXkgJHt0aGlzLm5hbWV9OiBDb3VsZCBub3Qgd3JpdGUgdG8gVGVuc29yQXJyYXkgaW5kZXggJHtlfSxcbiAgICAgICAgICBiZWNhdXNlIHRoZSB2YWx1ZSBkdHlwZSBpcyAke3QuZHR5cGV9LCBidXQgVGVuc29yQXJyYXkgZHR5cGUgaXMgJHt0aGlzLmR0eXBlfS5gKTtpZih0aGlzLnNpemUoKT09PTAmJih0aGlzLmVsZW1lbnRTaGFwZT09bnVsbHx8dGhpcy5lbGVtZW50U2hhcGUubGVuZ3RoPT09MCkmJih0aGlzLmVsZW1lbnRTaGFwZT10LnNoYXBlKSxDYSh0aGlzLmVsZW1lbnRTaGFwZSx0LnNoYXBlLGBUZW5zb3JBcnJheSAke3RoaXMubmFtZX06IENvdWxkIG5vdCB3cml0ZSB0byBUZW5zb3JBcnJheSBpbmRleCAke2V9LmApLG4ucmVhZCl0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckFycmF5ICR7dGhpcy5uYW1lfTogQ291bGQgbm90IHdyaXRlIHRvIFRlbnNvckFycmF5IGluZGV4ICR7ZX0sIGJlY2F1c2UgaXQgaGFzIGFscmVhZHkgYmVlbiByZWFkLmApO2lmKG4ud3JpdHRlbil0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckFycmF5ICR7dGhpcy5uYW1lfTogQ291bGQgbm90IHdyaXRlIHRvIFRlbnNvckFycmF5IGluZGV4ICR7ZX0sIGJlY2F1c2UgaXQgaGFzIGFscmVhZHkgYmVlbiB3cml0dGVuLmApO24udGVuc29yPXQsSHQodCksbi53cml0dGVuPSEwLHRoaXMudGVuc29yc1tlXT1ufXdyaXRlTWFueShlLHQpe2lmKGUubGVuZ3RoIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBUZW5zb3JBcnJheSAke3RoaXMubmFtZX06IGNvdWxkIG5vdCB3cml0ZSBtdWx0aXBsZSB0ZW5zb3JzLGJlY2F1c2UgdGhlIGluZGV4IHNpemU6ICR7ZS5sZW5ndGh9IGlzIG5vdCB0aGUgc2FtZSBhcyB0ZW5zb3JzIHNpemU6ICR7dC5sZW5ndGh9LmApO2UuZm9yRWFjaCgobixhKT0+dGhpcy53cml0ZShuLHRbYV0pKX1nYXRoZXIoZSx0KXtpZih0JiZ0IT09dGhpcy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckFycmF5IGR0eXBlIGlzICR7dGhpcy5kdHlwZX0gYnV0IGdhdGhlciByZXF1ZXN0ZWQgZHR5cGUgJHt0fWApO2lmKGUpZT1lLnNsaWNlKDAsdGhpcy5zaXplKCkpO2Vsc2V7ZT1bXTtmb3IobGV0IGE9MDthPHRoaXMuc2l6ZSgpO2ErKyllLnB1c2goYSl9aWYoZS5sZW5ndGg9PT0wKXJldHVybiBibihbXSxbMF0uY29uY2F0KHRoaXMuZWxlbWVudFNoYXBlKSk7bGV0IG49dGhpcy5yZWFkTWFueShlKTtyZXR1cm4gQ2EodGhpcy5lbGVtZW50U2hhcGUsblswXS5zaGFwZSxcIlRlbnNvckFycmF5IHNoYXBlIG1pc21hdGNoOiBcIiksQXQobiwwKX1jb25jYXQoZSl7aWYoZSYmZSE9PXRoaXMuZHR5cGUpdGhyb3cgbmV3IEVycm9yKGBUZW5zb3JBcnJheSBkdHlwZSBpcyAke3RoaXMuZHR5cGV9IGJ1dCBjb25jYXQgcmVxdWVzdGVkIGR0eXBlICR7ZX1gKTtpZih0aGlzLnNpemUoKT09PTApcmV0dXJuIGJuKFtdLFswXS5jb25jYXQodGhpcy5lbGVtZW50U2hhcGUpKTtsZXQgdD1bXTtmb3IobGV0IGE9MDthPHRoaXMuc2l6ZSgpO2ErKyl0LnB1c2goYSk7bGV0IG49dGhpcy5yZWFkTWFueSh0KTtyZXR1cm4gQ2EodGhpcy5lbGVtZW50U2hhcGUsblswXS5zaGFwZSxgVGVuc29yQXJyYXkgc2hhcGUgbWlzbWF0Y2g6IHRlbnNvciBhcnJheSBzaGFwZSAoJHt0aGlzLmVsZW1lbnRTaGFwZX0pIHZzIGZpcnN0IHRlbnNvciBzaGFwZSAoJHtuWzBdLnNoYXBlfSlgKSxldChuLDApfXNjYXR0ZXIoZSx0KXtpZih0LmR0eXBlIT09dGhpcy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckFycmF5IGR0eXBlIGlzICR7dGhpcy5kdHlwZX0gYnV0IHRlbnNvciBoYXMgZHR5cGUgJHt0LmR0eXBlfWApO2lmKGUubGVuZ3RoIT09dC5zaGFwZVswXSl0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGxlbihpbmRpY2VzKSA9PSB0ZW5zb3Iuc2hhcGVbMF0sIGJ1dCBzYXc6ICR7ZS5sZW5ndGh9IHZzLiAke3Quc2hhcGVbMF19YCk7bGV0IG49TWF0aC5tYXgoLi4uZSk7aWYoIXRoaXMuZHluYW1pY1NpemUmJm4+PXRoaXMubWF4U2l6ZSl0aHJvdyBuZXcgRXJyb3IoYE1heCBpbmRleCBtdXN0IGJlIDwgYXJyYXkgc2l6ZSAoJHtufSAgdnMuICR7dGhpcy5tYXhTaXplfSlgKTt0aGlzLndyaXRlTWFueShlLGR0KHQsMCkpfXNwbGl0KGUsdCl7aWYodC5kdHlwZSE9PXRoaXMuZHR5cGUpdGhyb3cgbmV3IEVycm9yKGBUZW5zb3JBcnJheSBkdHlwZSBpcyAke3RoaXMuZHR5cGV9IGJ1dCB0ZW5zb3IgaGFzIGR0eXBlICR7dC5kdHlwZX1gKTtsZXQgbj0wLGE9ZS5tYXAobz0+KG4rPW8sbikpO2lmKG4hPT10LnNoYXBlWzBdKXRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgc3VtIG9mIGxlbmd0aHMgdG8gYmUgZXF1YWwgdG9cbiAgICAgICAgICB0ZW5zb3Iuc2hhcGVbMF0sIGJ1dCBzdW0gb2YgbGVuZ3RocyBpc1xuICAgICAgICAke259LCBhbmQgdGVuc29yJ3Mgc2hhcGUgaXM6ICR7dC5zaGFwZX1gKTtpZighdGhpcy5keW5hbWljU2l6ZSYmZS5sZW5ndGghPT10aGlzLm1heFNpemUpdGhyb3cgbmV3IEVycm9yKGBUZW5zb3JBcnJheSdzIHNpemUgaXMgbm90IGVxdWFsIHRvIHRoZSBzaXplIG9mIGxlbmd0aHMgKCR7dGhpcy5tYXhTaXplfSB2cy4gJHtlLmxlbmd0aH0pLCBhbmQgdGhlIFRlbnNvckFycmF5IGlzIG5vdCBtYXJrZWQgYXMgZHluYW1pY2FsbHkgcmVzaXplYWJsZWApO2xldCByPW49PT0wPzA6dC5zaXplL24scz1bXTtPKCgpPT57dD1XKHQsWzEsbixyXSk7Zm9yKGxldCBvPTA7bzxlLmxlbmd0aDsrK28pe2xldCBsPVswLG89PT0wPzA6YVtvLTFdLDBdLHU9WzEsZVtvXSxyXTtzW29dPVcoVmUodCxsLHUpLHRoaXMuZWxlbWVudFNoYXBlKX1yZXR1cm4gc30pO2xldCBpPVtdO2ZvcihsZXQgbz0wO288ZS5sZW5ndGg7bysrKWlbb109bzt0aGlzLndyaXRlTWFueShpLHMpfX0sTGY9Y2xhc3MgaXZ7Z2V0IGlkKCl7cmV0dXJuIHRoaXMuaWRUZW5zb3IuaWR9Y29uc3RydWN0b3IodCxuLGEscj0tMSl7dGhpcy50ZW5zb3JzPXQsdGhpcy5lbGVtZW50U2hhcGU9bix0aGlzLmVsZW1lbnREdHlwZT1hLHQhPW51bGwmJnQuZm9yRWFjaChzPT57aWYoYSE9PXMuZHR5cGUpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGEgdHlwZXM7IG9wIGVsZW1lbnRzICR7YX0sIGJ1dCBsaXN0IGVsZW1lbnRzICR7cy5kdHlwZX1gKTtDYShuLHMuc2hhcGUsXCJUZW5zb3JMaXN0IHNoYXBlIG1pc21hdGNoOiBcIiksSHQocyl9KSx0aGlzLmlkVGVuc29yPXhlKDApLHRoaXMubWF4TnVtRWxlbWVudHM9cixIdCh0aGlzLmlkVGVuc29yKX1jb3B5KCl7cmV0dXJuIG5ldyBpdihbLi4udGhpcy50ZW5zb3JzXSx0aGlzLmVsZW1lbnRTaGFwZSx0aGlzLmVsZW1lbnREdHlwZSl9Y2xlYXJBbmRDbG9zZSh0KXt0aGlzLnRlbnNvcnMuZm9yRWFjaChuPT57KHQ9PW51bGx8fCF0LmhhcyhuLmlkKSkmJm4uZGlzcG9zZSgpfSksdGhpcy50ZW5zb3JzLmxlbmd0aD0wLHRoaXMuaWRUZW5zb3IuZGlzcG9zZSgpfXNpemUoKXtyZXR1cm4gdGhpcy50ZW5zb3JzLmxlbmd0aH1zdGFjayh0LG4sYT0tMSl7aWYobiE9PXRoaXMuZWxlbWVudER0eXBlKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhIHR5cGVzOyBvcCBlbGVtZW50cyAke259LCBidXQgbGlzdCBlbGVtZW50cyAke3RoaXMuZWxlbWVudER0eXBlfWApO2lmKGEhPT0tMSYmdGhpcy50ZW5zb3JzLmxlbmd0aCE9PWEpdGhyb3cgbmV3IEVycm9yKGBPcGVyYXRpb24gZXhwZWN0ZWQgYSBsaXN0IHdpdGggJHthfSBlbGVtZW50cyBidXQgZ290IGEgbGlzdCB3aXRoICR7dGhpcy50ZW5zb3JzLmxlbmd0aH0gZWxlbWVudHMuYCk7Q2EodCx0aGlzLmVsZW1lbnRTaGFwZSxcIlRlbnNvckxpc3Qgc2hhcGUgbWlzbWF0Y2g6IFwiKTtsZXQgcj1acCh0aGlzLmVsZW1lbnRTaGFwZSx0aGlzLnRlbnNvcnMsdCk7cmV0dXJuIE8oKCk9PntsZXQgcz10aGlzLnRlbnNvcnMubWFwKGk9PlcoaSxyKSk7cmV0dXJuIEF0KHMsMCl9KX1wb3BCYWNrKHQsbil7aWYobiE9PXRoaXMuZWxlbWVudER0eXBlKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhIHR5cGVzOyBvcCBlbGVtZW50cyAke259LCBidXQgbGlzdCBlbGVtZW50cyAke3RoaXMuZWxlbWVudER0eXBlfWApO2lmKHRoaXMuc2l6ZSgpPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJUcnlpbmcgdG8gcG9wIGZyb20gYW4gZW1wdHkgbGlzdC5cIik7bGV0IGE9WnAodGhpcy5lbGVtZW50U2hhcGUsdGhpcy50ZW5zb3JzLHQpLHI9dGhpcy50ZW5zb3JzLnBvcCgpO3JldHVybiByLmtlcHQ9ITEsQ2Eoci5zaGFwZSx0LFwiVGVuc29yTGlzdCBzaGFwZSBtaXNtYXRjaDogXCIpLFcocixhKX1wdXNoQmFjayh0KXtpZih0LmR0eXBlIT09dGhpcy5lbGVtZW50RHR5cGUpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGEgdHlwZXM7IG9wIGVsZW1lbnRzICR7dC5kdHlwZX0sIGJ1dCBsaXN0IGVsZW1lbnRzICR7dGhpcy5lbGVtZW50RHR5cGV9YCk7aWYoQ2EodC5zaGFwZSx0aGlzLmVsZW1lbnRTaGFwZSxcIlRlbnNvckxpc3Qgc2hhcGUgbWlzbWF0Y2g6IFwiKSx0aGlzLm1heE51bUVsZW1lbnRzPT09dGhpcy5zaXplKCkpdGhyb3cgbmV3IEVycm9yKFwiVHJ5aW5nIHRvIHB1c2ggZWxlbWVudCBpbnRvIGEgZnVsbCBsaXN0LlwiKTtIdCh0KSx0aGlzLnRlbnNvcnMucHVzaCh0KX1yZXNpemUodCl7aWYodDwwKXRocm93IG5ldyBFcnJvcihgVGVuc29yTGlzdFJlc2l6ZSBleHBlY3RzIHNpemUgdG8gYmUgbm9uLW5lZ2F0aXZlLiBHb3Q6ICR7dH1gKTtpZih0aGlzLm1heE51bUVsZW1lbnRzIT09LTEmJnQ+dGhpcy5tYXhOdW1FbGVtZW50cyl0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckxpc3RSZXNpemUgaW5wdXQgc2l6ZSAke3R9IGlzIGdyZWF0ZXIgbWF4TnVtRWxlbWVudCAke3RoaXMubWF4TnVtRWxlbWVudHN9LmApO2xldCBuPW5ldyBpdihbXSx0aGlzLmVsZW1lbnRTaGFwZSx0aGlzLmVsZW1lbnREdHlwZSx0aGlzLm1heE51bUVsZW1lbnRzKTtuLnRlbnNvcnMubGVuZ3RoPXQ7Zm9yKGxldCBhPTA7YTxNYXRoLm1pbih0aGlzLnRlbnNvcnMubGVuZ3RoLHQpOysrYSluLnRlbnNvcnNbYV09dGhpcy50ZW5zb3JzW2FdO3JldHVybiBufWdldEl0ZW0odCxuLGEpe2lmKGEhPT10aGlzLmVsZW1lbnREdHlwZSl0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGF0YSB0eXBlczsgb3AgZWxlbWVudHMgJHthfSwgYnV0IGxpc3QgZWxlbWVudHMgJHt0aGlzLmVsZW1lbnREdHlwZX1gKTtpZih0PDB8fHQ+dGhpcy50ZW5zb3JzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYFRyeWluZyB0byBhY2Nlc3MgZWxlbWVudCAke3R9IGluIGEgbGlzdCB3aXRoICR7dGhpcy50ZW5zb3JzLmxlbmd0aH0gZWxlbWVudHMuYCk7aWYodGhpcy50ZW5zb3JzW3RdPT1udWxsKXRocm93IG5ldyBFcnJvcihgZWxlbWVudCBhdCBpbmRleCAke3R9IGlzIG51bGwuYCk7Q2EodGhpcy50ZW5zb3JzW3RdLnNoYXBlLG4sXCJUZW5zb3JMaXN0IHNoYXBlIG1pc21hdGNoOiBcIik7bGV0IHI9WnAodGhpcy5lbGVtZW50U2hhcGUsdGhpcy50ZW5zb3JzLG4pO3JldHVybiBXKHRoaXMudGVuc29yc1t0XSxyKX1zZXRJdGVtKHQsbil7aWYobi5kdHlwZSE9PXRoaXMuZWxlbWVudER0eXBlKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhIHR5cGVzOyBvcCBlbGVtZW50cyAke24uZHR5cGV9LCBidXQgbGlzdCBlbGVtZW50cyAke3RoaXMuZWxlbWVudER0eXBlfWApO2lmKHQ8MHx8dGhpcy5tYXhOdW1FbGVtZW50cyE9PS0xJiZ0Pj10aGlzLm1heE51bUVsZW1lbnRzKXRocm93IG5ldyBFcnJvcihgVHJ5aW5nIHRvIHNldCBlbGVtZW50ICR7dH0gaW4gYSBsaXN0IHdpdGggbWF4ICR7dGhpcy5tYXhOdW1FbGVtZW50c30gZWxlbWVudHMuYCk7Q2EodGhpcy5lbGVtZW50U2hhcGUsbi5zaGFwZSxcIlRlbnNvckxpc3Qgc2hhcGUgbWlzbWF0Y2g6IFwiKSxIdChuKSx0aGlzLnRlbnNvcnNbdF0hPW51bGwmJih0aGlzLnRlbnNvcnNbdF0ua2VwdD0hMSksdGhpcy50ZW5zb3JzW3RdPW59Z2F0aGVyKHQsbixhKXtpZihuIT09dGhpcy5lbGVtZW50RHR5cGUpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGEgdHlwZXM7IG9wIGVsZW1lbnRzICR7bn0sIGJ1dCBsaXN0IGVsZW1lbnRzICR7dGhpcy5lbGVtZW50RHR5cGV9YCk7Q2EodGhpcy5lbGVtZW50U2hhcGUsYSxcIlRlbnNvckxpc3Qgc2hhcGUgbWlzbWF0Y2g6IFwiKSx0PXQuc2xpY2UoMCx0aGlzLnNpemUoKSk7bGV0IHI9WnAodGhpcy5lbGVtZW50U2hhcGUsdGhpcy50ZW5zb3JzLGEpO3JldHVybiB0Lmxlbmd0aD09PTA/Ym4oW10sWzBdLmNvbmNhdChyKSk6TygoKT0+e2xldCBzPXQubWFwKGk9PlcodGhpcy50ZW5zb3JzW2ldLHIpKTtyZXR1cm4gQXQocywwKX0pfWNvbmNhdCh0LG4pe2lmKHQmJnQhPT10aGlzLmVsZW1lbnREdHlwZSl0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckxpc3QgZHR5cGUgaXMgJHt0aGlzLmVsZW1lbnREdHlwZX0gYnV0IGNvbmNhdCByZXF1ZXN0ZWQgZHR5cGUgJHt0fWApO0NhKHRoaXMuZWxlbWVudFNoYXBlLG4sXCJUZW5zb3JMaXN0IHNoYXBlIG1pc21hdGNoOiBcIik7bGV0IGE9WnAodGhpcy5lbGVtZW50U2hhcGUsdGhpcy50ZW5zb3JzLG4pO3JldHVybiB0aGlzLnNpemUoKT09PTA/Ym4oW10sWzBdLmNvbmNhdChhKSk6TygoKT0+e2xldCByPXRoaXMudGVuc29ycy5tYXAocz0+VyhzLGEpKTtyZXR1cm4gZXQociwwKX0pfX07ZnVuY3Rpb24gV3EoZSx0LG4pe2xldCBhPWUuZHR5cGU7aWYoZS5zaGFwZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoYFRlbnNvciBtdXN0IGJlIGF0IGxlYXN0IGEgdmVjdG9yLCBidXQgc2F3IHNoYXBlOiAke2Uuc2hhcGV9YCk7aWYoZS5kdHlwZSE9PW4pdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGEgdHlwZXM7IG9wIGVsZW1lbnRzICR7ZS5kdHlwZX0sIGJ1dCBsaXN0IGVsZW1lbnRzICR7bn1gKTtsZXQgcj1lLnNoYXBlLnNsaWNlKDEpO0NhKHIsdCxcIlRlbnNvckxpc3Qgc2hhcGUgbWlzbWF0Y2g6IFwiKTtsZXQgcz1kdChlKTtyZXR1cm4gbmV3IExmKHMsdCxhKX1mdW5jdGlvbiBCcShlLHQsbixhKXtyZXR1cm4gbmV3IExmKFtdLGUsdCxhKX1mdW5jdGlvbiBWcShlLHQsbixhKXtpZih0Lmxlbmd0aCE9PWUuc2hhcGVbMF0pdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBsZW4oaW5kaWNlcykgPT0gdGVuc29yLnNoYXBlWzBdLCBidXQgc2F3OiAke3QubGVuZ3RofSB2cy4gJHtlLnNoYXBlWzBdfWApO2xldCByPU1hdGgubWF4KC4uLnQpO2lmKGEhPW51bGwmJmEhPT0tMSYmcj49YSl0aHJvdyBuZXcgRXJyb3IoYE1heCBpbmRleCBtdXN0IGJlIDwgYXJyYXkgc2l6ZSAoJHtyfSAgdnMuICR7YX0pYCk7bGV0IHM9bmV3IExmKFtdLG4sZS5kdHlwZSxhKSxpPWR0KGUsMCk7cmV0dXJuIHQuZm9yRWFjaCgobyxsKT0+e3Muc2V0SXRlbShvLGlbbF0pfSksc31mdW5jdGlvbiBVcShlLHQsbil7bGV0IGE9MCxyPXQubWFwKHA9PihhKz1wLGEpKTtpZihhIT09ZS5zaGFwZVswXSl0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHN1bSBvZiBsZW5ndGhzIHRvIGJlIGVxdWFsIHRvXG4gICAgICAgICAgdGVuc29yLnNoYXBlWzBdLCBidXQgc3VtIG9mIGxlbmd0aHMgaXNcbiAgICAgICAgJHthfSwgYW5kIHRlbnNvcidzIHNoYXBlIGlzOiAke2Uuc2hhcGV9YCk7bGV0IHM9ZS5zaGFwZS5zbGljZSgxKSxpPXN2KHMsbiksbz1hPT09MD8wOmUuc2l6ZS9hLGw9TygoKT0+e2xldCBwPVtdO2U9VyhlLFsxLGEsb10pO2ZvcihsZXQgZD0wO2Q8dC5sZW5ndGg7KytkKXtsZXQgYz1bMCxkPT09MD8wOnJbZC0xXSwwXSxoPVsxLHRbZF0sb107cFtkXT1XKFZlKGUsYyxoKSxpKX1yZXR1cm4gZS5kaXNwb3NlKCkscH0pLHU9bmV3IExmKFtdLG4sZS5kdHlwZSx0Lmxlbmd0aCk7Zm9yKGxldCBwPTA7cDxsLmxlbmd0aDtwKyspdS5zZXRJdGVtKHAsbFtwXSk7cmV0dXJuIHV9dmFyIEdxPWFzeW5jKGUsdCxuKT0+e3N3aXRjaChlLm9wKXtjYXNlXCJJZlwiOmNhc2VcIlN0YXRlbGVzc0lmXCI6e2xldCBhPWsoXCJ0aGVuQnJhbmNoXCIsZSx0LG4pLHI9ayhcImVsc2VCcmFuY2hcIixlLHQsbikscz1rKFwiY29uZFwiLGUsdCxuKSxpPWsoXCJhcmdzXCIsZSx0LG4pO3JldHVybihhd2FpdCBzLmRhdGEoKSlbMF0/bi5mdW5jdGlvbk1hcFthXS5leGVjdXRlRnVuY3Rpb25Bc3luYyhpLG4udGVuc29yQXJyYXlNYXAsbi50ZW5zb3JMaXN0TWFwKTpuLmZ1bmN0aW9uTWFwW3JdLmV4ZWN1dGVGdW5jdGlvbkFzeW5jKGksbi50ZW5zb3JBcnJheU1hcCxuLnRlbnNvckxpc3RNYXApfWNhc2VcIldoaWxlXCI6Y2FzZVwiU3RhdGVsZXNzV2hpbGVcIjp7bGV0IGE9ayhcImJvZHlcIixlLHQsbikscj1rKFwiY29uZFwiLGUsdCxuKSxzPWsoXCJhcmdzXCIsZSx0LG4pLGk9YXdhaXQgbi5mdW5jdGlvbk1hcFtyXS5leGVjdXRlRnVuY3Rpb25Bc3luYyhzLG4udGVuc29yQXJyYXlNYXAsbi50ZW5zb3JMaXN0TWFwKSxvPXMubWFwKHA9PnAuaWQpLGw9YXdhaXQgaVswXS5kYXRhKCk7aS5mb3JFYWNoKHA9PnshcC5rZXB0JiZvLmluZGV4T2YocC5pZCk9PT0tMSYmcC5kaXNwb3NlKCl9KTtsZXQgdT1zO2Zvcig7bFswXTspe2xldCBwPXU7dT1hd2FpdCBuLmZ1bmN0aW9uTWFwW2FdLmV4ZWN1dGVGdW5jdGlvbkFzeW5jKHUsbi50ZW5zb3JBcnJheU1hcCxuLnRlbnNvckxpc3RNYXApO2xldCBkPXUubWFwKGg9PmguaWQpO3AuZm9yRWFjaChoPT57IWgua2VwdCYmby5pbmRleE9mKGguaWQpPT09LTEmJmQuaW5kZXhPZihoLmlkKT09PS0xJiZoLmRpc3Bvc2UoKX0pO2xldCBjPWF3YWl0IG4uZnVuY3Rpb25NYXBbcl0uZXhlY3V0ZUZ1bmN0aW9uQXN5bmModSxuLnRlbnNvckFycmF5TWFwLG4udGVuc29yTGlzdE1hcCk7bD1hd2FpdCBjWzBdLmRhdGEoKSxjLmZvckVhY2goaD0+eyFoLmtlcHQmJm8uaW5kZXhPZihoLmlkKT09PS0xJiZkLmluZGV4T2YoaC5pZCk9PT0tMSYmaC5kaXNwb3NlKCl9KX1yZXR1cm4gdX1jYXNlXCJMb29wQ29uZFwiOntsZXQgYT1rKFwicHJlZFwiLGUsdCxuKTtyZXR1cm5bTnIoYSldfWNhc2VcIlN3aXRjaFwiOntsZXQgYT1rKFwicHJlZFwiLGUsdCxuKSxyPWsoXCJkYXRhXCIsZSx0LG4pO3JldHVybiByLmtlcHR8fChyPU5yKHIpKSwoYXdhaXQgYS5kYXRhKCkpWzBdP1t2b2lkIDAscl06W3Isdm9pZCAwXX1jYXNlXCJNZXJnZVwiOntsZXQgYT1lLmlucHV0TmFtZXMuZmluZChyPT5wbihyLHQsbikhPT12b2lkIDApO2lmKGEpe2xldCByPXBuKGEsdCxuKTtyZXR1cm5bTnIocildfXJldHVybn1jYXNlXCJFbnRlclwiOntsZXQgYT1rKFwiZnJhbWVOYW1lXCIsZSx0LG4pLHI9ayhcInRlbnNvclwiLGUsdCxuKTtyZXR1cm4gbi5lbnRlckZyYW1lKGEpLFtOcihyKV19Y2FzZVwiRXhpdFwiOntsZXQgYT1rKFwidGVuc29yXCIsZSx0LG4pO3JldHVybiBuLmV4aXRGcmFtZSgpLFtOcihhKV19Y2FzZVwiTmV4dEl0ZXJhdGlvblwiOntsZXQgYT1rKFwidGVuc29yXCIsZSx0LG4pO3JldHVybiBuLm5leHRJdGVyYXRpb24oKSxbTnIoYSldfWNhc2VcIlRlbnNvckFycmF5VjNcIjp7bGV0IGE9ayhcInNpemVcIixlLHQsbikscj1rKFwiZHR5cGVcIixlLHQsbikscz1rKFwiZWxlbWVudFNoYXBlXCIsZSx0LG4pLGk9ayhcImR5bmFtaWNTaXplXCIsZSx0LG4pLG89ayhcImNsZWFyQWZ0ZXJSZWFkXCIsZSx0LG4pLGw9ayhcImlkZW50aWNhbEVsZW1lbnRTaGFwZXNcIixlLHQsbiksdT1rKFwibmFtZVwiLGUsdCxuKSxwPW5ldyB6cSh1LHIsYSxzLGwsaSxvKTtyZXR1cm4gbi5hZGRUZW5zb3JBcnJheShwKSxbcC5pZFRlbnNvcix4ZSgxKV19Y2FzZVwiVGVuc29yQXJyYXlXcml0ZVYzXCI6e2xldCBhPWsoXCJ0ZW5zb3JBcnJheUlkXCIsZSx0LG4pLHI9ayhcImluZGV4XCIsZSx0LG4pLHM9ayhcInRlbnNvclwiLGUsdCxuKSxpPW4uZ2V0VGVuc29yQXJyYXkoYS5pZCk7cmV0dXJuIGkud3JpdGUocixzKSxbaS5pZFRlbnNvcl19Y2FzZVwiVGVuc29yQXJyYXlSZWFkVjNcIjp7bGV0IGE9ayhcInRlbnNvckFycmF5SWRcIixlLHQsbikscj1rKFwiaW5kZXhcIixlLHQsbik7cmV0dXJuW24uZ2V0VGVuc29yQXJyYXkoYS5pZCkucmVhZChyKV19Y2FzZVwiVGVuc29yQXJyYXlHYXRoZXJWM1wiOntsZXQgYT1rKFwidGVuc29yQXJyYXlJZFwiLGUsdCxuKSxyPWsoXCJpbmRpY2VzXCIsZSx0LG4pLHM9ayhcImR0eXBlXCIsZSx0LG4pO3JldHVybltuLmdldFRlbnNvckFycmF5KGEuaWQpLmdhdGhlcihyLHMpXX1jYXNlXCJUZW5zb3JBcnJheVNjYXR0ZXJWM1wiOntsZXQgYT1rKFwidGVuc29yQXJyYXlJZFwiLGUsdCxuKSxyPWsoXCJpbmRpY2VzXCIsZSx0LG4pLHM9ayhcInRlbnNvclwiLGUsdCxuKSxpPW4uZ2V0VGVuc29yQXJyYXkoYS5pZCk7cmV0dXJuIGkuc2NhdHRlcihyLHMpLFtpLmlkVGVuc29yXX1jYXNlXCJUZW5zb3JBcnJheUNvbmNhdFYzXCI6e2xldCBhPWsoXCJ0ZW5zb3JBcnJheUlkXCIsZSx0LG4pLHI9bi5nZXRUZW5zb3JBcnJheShhLmlkKSxzPWsoXCJkdHlwZVwiLGUsdCxuKTtyZXR1cm5bci5jb25jYXQocyldfWNhc2VcIlRlbnNvckFycmF5U3BsaXRWM1wiOntsZXQgYT1rKFwidGVuc29yQXJyYXlJZFwiLGUsdCxuKSxyPWsoXCJ0ZW5zb3JcIixlLHQsbikscz1rKFwibGVuZ3Roc1wiLGUsdCxuKSxpPW4uZ2V0VGVuc29yQXJyYXkoYS5pZCk7cmV0dXJuIGkuc3BsaXQocyxyKSxbaS5pZFRlbnNvcl19Y2FzZVwiVGVuc29yQXJyYXlTaXplVjNcIjp7bGV0IGE9ayhcInRlbnNvckFycmF5SWRcIixlLHQsbikscj1uLmdldFRlbnNvckFycmF5KGEuaWQpO3JldHVyblt4ZShyLnNpemUoKSxcImludDMyXCIpXX1jYXNlXCJUZW5zb3JBcnJheUNsb3NlVjNcIjp7bGV0IGE9ayhcInRlbnNvckFycmF5SWRcIixlLHQsbikscj1uLmdldFRlbnNvckFycmF5KGEuaWQpO3JldHVybiByLmNsZWFyQW5kQ2xvc2UoKSxbci5pZFRlbnNvcl19Y2FzZVwiVGVuc29yTGlzdFNldEl0ZW1cIjp7bGV0IGE9ayhcInRlbnNvckxpc3RJZFwiLGUsdCxuKSxyPWsoXCJpbmRleFwiLGUsdCxuKSxzPWsoXCJ0ZW5zb3JcIixlLHQsbiksaT1uLmdldFRlbnNvckxpc3QoYS5pZCk7cmV0dXJuIGkuc2V0SXRlbShyLHMpLFtpLmlkVGVuc29yXX1jYXNlXCJUZW5zb3JMaXN0R2V0SXRlbVwiOntsZXQgYT1rKFwidGVuc29yTGlzdElkXCIsZSx0LG4pLHI9ayhcImluZGV4XCIsZSx0LG4pLHM9ayhcImVsZW1lbnRTaGFwZVwiLGUsdCxuKSxpPWsoXCJlbGVtZW50RFR5cGVcIixlLHQsbik7cmV0dXJuW24uZ2V0VGVuc29yTGlzdChhLmlkKS5nZXRJdGVtKHIscyxpKV19Y2FzZVwiVGVuc29yTGlzdFNjYXR0ZXJWMlwiOmNhc2VcIlRlbnNvckxpc3RTY2F0dGVyXCI6e2xldCBhPWsoXCJpbmRpY2VzXCIsZSx0LG4pLHI9ayhcInRlbnNvclwiLGUsdCxuKSxzPWsoXCJlbGVtZW50U2hhcGVcIixlLHQsbiksaT1rKFwibnVtRWxlbWVudHNcIixlLHQsbiksbz1WcShyLGEscyxpKTtyZXR1cm4gbi5hZGRUZW5zb3JMaXN0KG8pLFtvLmlkVGVuc29yXX1jYXNlXCJUZW5zb3JMaXN0UmVzZXJ2ZVwiOmNhc2VcIkVtcHR5VGVuc29yTGlzdFwiOntsZXQgYT1rKFwiZWxlbWVudFNoYXBlXCIsZSx0LG4pLHI9ayhcImVsZW1lbnREVHlwZVwiLGUsdCxuKSxzO2Uub3A9PT1cIlRlbnNvckxpc3RSZXNlcnZlXCI/cz1cIm51bUVsZW1lbnRzXCI6cz1cIm1heE51bUVsZW1lbnRzXCI7bGV0IGk9ayhzLGUsdCxuKSxvPWUub3A9PT1cIlRlbnNvckxpc3RSZXNlcnZlXCI/LTE6aSxsPUJxKGEscixpLG8pO3JldHVybiBuLmFkZFRlbnNvckxpc3QobCksW2wuaWRUZW5zb3JdfWNhc2VcIlRlbnNvckxpc3RHYXRoZXJcIjp7bGV0IGE9ayhcInRlbnNvckxpc3RJZFwiLGUsdCxuKSxyPWsoXCJpbmRpY2VzXCIsZSx0LG4pLHM9ayhcImVsZW1lbnRTaGFwZVwiLGUsdCxuKSxpPWsoXCJlbGVtZW50RFR5cGVcIixlLHQsbik7cmV0dXJuW24uZ2V0VGVuc29yTGlzdChhLmlkKS5nYXRoZXIocixpLHMpXX1jYXNlXCJUZW5zb3JMaXN0U3RhY2tcIjp7bGV0IGE9ayhcInRlbnNvckxpc3RJZFwiLGUsdCxuKSxyPWsoXCJlbGVtZW50U2hhcGVcIixlLHQsbikscz1rKFwiZWxlbWVudERUeXBlXCIsZSx0LG4pLGk9ayhcIm51bUVsZW1lbnRzXCIsZSx0LG4pO3JldHVybltuLmdldFRlbnNvckxpc3QoYS5pZCkuc3RhY2socixzLGkpXX1jYXNlXCJUZW5zb3JMaXN0RnJvbVRlbnNvclwiOntsZXQgYT1rKFwidGVuc29yXCIsZSx0LG4pLHI9ayhcImVsZW1lbnRTaGFwZVwiLGUsdCxuKSxzPWsoXCJlbGVtZW50RFR5cGVcIixlLHQsbiksaT1XcShhLHIscyk7cmV0dXJuIG4uYWRkVGVuc29yTGlzdChpKSxbaS5pZFRlbnNvcl19Y2FzZVwiVGVuc29yTGlzdENvbmNhdFwiOmNhc2VcIlRlbnNvckxpc3RDb25jYXRWMlwiOntsZXQgYT1rKFwidGVuc29yTGlzdElkXCIsZSx0LG4pLHI9bi5nZXRUZW5zb3JMaXN0KGEuaWQpLHM9ayhcImR0eXBlXCIsZSx0LG4pLGk9ayhcImVsZW1lbnRTaGFwZVwiLGUsdCxuKTtyZXR1cm5bci5jb25jYXQocyxpKV19Y2FzZVwiVGVuc29yTGlzdFB1c2hCYWNrXCI6e2xldCBhPWsoXCJ0ZW5zb3JMaXN0SWRcIixlLHQsbikscj1rKFwidGVuc29yXCIsZSx0LG4pLHM9bi5nZXRUZW5zb3JMaXN0KGEuaWQpO3JldHVybiBzLnB1c2hCYWNrKHIpLFtzLmlkVGVuc29yXX1jYXNlXCJUZW5zb3JMaXN0UG9wQmFja1wiOntsZXQgYT1rKFwidGVuc29yTGlzdElkXCIsZSx0LG4pLHI9ayhcImVsZW1lbnRTaGFwZVwiLGUsdCxuKSxzPWsoXCJlbGVtZW50RFR5cGVcIixlLHQsbik7cmV0dXJuW24uZ2V0VGVuc29yTGlzdChhLmlkKS5wb3BCYWNrKHIscyldfWNhc2VcIlRlbnNvckxpc3RTcGxpdFwiOntsZXQgYT1rKFwidGVuc29yXCIsZSx0LG4pLHI9ayhcImVsZW1lbnRTaGFwZVwiLGUsdCxuKSxzPWsoXCJsZW5ndGhzXCIsZSx0LG4pLGk9VXEoYSxzLHIpO3JldHVybiBuLmFkZFRlbnNvckxpc3QoaSksW2kuaWRUZW5zb3JdfWNhc2VcIlRlbnNvckxpc3RMZW5ndGhcIjp7bGV0IGE9ayhcInRlbnNvckxpc3RJZFwiLGUsdCxuKSxyPW4uZ2V0VGVuc29yTGlzdChhLmlkKTtyZXR1cm5beGUoci5zaXplKCksXCJpbnQzMlwiKV19Y2FzZVwiVGVuc29yTGlzdFJlc2l6ZVwiOntsZXQgYT1rKFwidGVuc29yTGlzdElkXCIsZSx0LG4pLHI9ayhcInNpemVcIixlLHQsbikscz1uLmdldFRlbnNvckxpc3QoYS5pZCkucmVzaXplKHIpO3JldHVybiBuLmFkZFRlbnNvckxpc3QocyksW3MuaWRUZW5zb3JdfWRlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKGBOb2RlIHR5cGUgJHtlLm9wfSBpcyBub3QgaW1wbGVtZW50ZWRgKX19O2Z1bmN0aW9uIFZJKGUsdCxuKXtsZXRbYSxyXT1rKFwiZnVzZWRPcHNcIixlLHQsbikscz1hPT09XCJiaWFzYWRkXCIsaT0hcyxvPXI9PT1cInByZWx1XCIsbD1hPT09XCJmdXNlZGJhdGNobm9ybVwiLHU9ayhcIm51bUFyZ3NcIixlLHQsbik7aWYocyl7aWYobyYmdSE9PTIpdGhyb3cgbmV3IEVycm9yKFwiRnVzZWRDb252MmQgYW5kIERlcHRod2lzZUNvbnYyZCB3aXRoIEJpYXNBZGQgYW5kIFByZWx1IG11c3QgaGF2ZSB0d28gZXh0cmEgYXJndW1lbnRzOiBiaWFzIGFuZCBhbHBoYS5cIik7aWYoIW8mJnMmJnUhPT0xKXRocm93IG5ldyBFcnJvcihcIkZ1c2VkQ29udjJkIGFuZCBEZXB0aHdpc2VDb252MmQgd2l0aCBCaWFzQWRkIG11c3QgaGF2ZSBvbmUgZXh0cmEgYXJndW1lbnQ6IGJpYXMuXCIpfWlmKGwpdGhyb3cgbmV3IEVycm9yKFwiRnVzZWRDb252MmQgYW5kIERlcHRod2lzZUNvbnYyZCB3aXRoIEZ1c2VkQmF0Y2hOb3JtIGlzIG5vdCBzdXBwb3J0ZWRcIik7bGV0IHA9ayhcInN0cmlkZXNcIixlLHQsbiksZD1NaChlLHQsbiksYz1rKFwiZGF0YUZvcm1hdFwiLGUsdCxuKS50b1VwcGVyQ2FzZSgpLGg9ayhcImRpbGF0aW9uc1wiLGUsdCxuKSxbbSxmXT1rKFwiYXJnc1wiLGUsdCxuKTtpJiYoZj1tLG09dm9pZCAwKTtsZXQgZz1rKFwibGVha3lyZWx1QWxwaGFcIixlLHQsbik7cmV0dXJue3N0cmlkZTpwLHBhZDpkLGRhdGFGb3JtYXQ6YyxkaWxhdGlvbnM6aCxiaWFzQXJnOm0scHJlbHVBcmc6ZixhY3RpdmF0aW9uRnVuYzpyLGxlYWt5cmVsdUFscGhhOmd9fXZhciBIcT0oZSx0LG4sYT1vbik9Pntzd2l0Y2goZS5vcCl7Y2FzZVwiQ29udjFEXCI6e2xldCByPWsoXCJzdHJpZGVcIixlLHQsbikscz1rKFwicGFkXCIsZSx0LG4pLGk9ayhcImRhdGFGb3JtYXRcIixlLHQsbikudG9VcHBlckNhc2UoKSxvPWsoXCJkaWxhdGlvblwiLGUsdCxuKTtyZXR1cm5bYS5jb252MWQoayhcInhcIixlLHQsbiksayhcImZpbHRlclwiLGUsdCxuKSxyLHMsaSxvKV19Y2FzZVwiQ29udjJEXCI6e2xldCByPWsoXCJzdHJpZGVzXCIsZSx0LG4pLHM9TWgoZSx0LG4pLGk9ayhcImRhdGFGb3JtYXRcIixlLHQsbikudG9VcHBlckNhc2UoKSxvPWsoXCJkaWxhdGlvbnNcIixlLHQsbik7cmV0dXJuW2EuY29udjJkKGsoXCJ4XCIsZSx0LG4pLGsoXCJmaWx0ZXJcIixlLHQsbiksW3JbMV0sclsyXV0scyxpLFtvWzFdLG9bMl1dKV19Y2FzZVwiX0Z1c2VkQ29udjJEXCI6e2xldHtzdHJpZGU6cixwYWQ6cyxkYXRhRm9ybWF0OmksZGlsYXRpb25zOm8sYmlhc0FyZzpsLHByZWx1QXJnOnUsYWN0aXZhdGlvbkZ1bmM6cCxsZWFreXJlbHVBbHBoYTpkfT1WSShlLHQsbik7cmV0dXJuW2EuZnVzZWQuY29udjJkKHt4OmsoXCJ4XCIsZSx0LG4pLGZpbHRlcjprKFwiZmlsdGVyXCIsZSx0LG4pLHN0cmlkZXM6W3JbMV0sclsyXV0scGFkOnMsZGF0YUZvcm1hdDppLGRpbGF0aW9uczpbb1sxXSxvWzJdXSxiaWFzOmwsYWN0aXZhdGlvbjpwLHByZWx1QWN0aXZhdGlvbldlaWdodHM6dSxsZWFreXJlbHVBbHBoYTpkfSldfWNhc2VcIkZ1c2VkRGVwdGh3aXNlQ29udjJkTmF0aXZlXCI6e2xldHtzdHJpZGU6cixwYWQ6cyxkYXRhRm9ybWF0OmksZGlsYXRpb25zOm8sYmlhc0FyZzpsLHByZWx1QXJnOnUsYWN0aXZhdGlvbkZ1bmM6cCxsZWFreXJlbHVBbHBoYTpkfT1WSShlLHQsbik7cmV0dXJuW2EuZnVzZWQuZGVwdGh3aXNlQ29udjJkKHt4OmsoXCJ4XCIsZSx0LG4pLGZpbHRlcjprKFwiZmlsdGVyXCIsZSx0LG4pLHN0cmlkZXM6W3JbMV0sclsyXV0scGFkOnMsZGF0YUZvcm1hdDppLGRpbGF0aW9uczpbb1sxXSxvWzJdXSxiaWFzOmwsYWN0aXZhdGlvbjpwLHByZWx1QWN0aXZhdGlvbldlaWdodHM6dSxsZWFreXJlbHVBbHBoYTpkfSldfWNhc2VcIkNvbnYyREJhY2twcm9wSW5wdXRcIjpjYXNlXCJDb252MmRUcmFuc3Bvc2VcIjp7bGV0IHI9ayhcIm91dHB1dFNoYXBlXCIsZSx0LG4pLHM9ayhcInN0cmlkZXNcIixlLHQsbiksaT1NaChlLHQsbik7cmV0dXJuW2EuY29udjJkVHJhbnNwb3NlKGsoXCJ4XCIsZSx0LG4pLGsoXCJmaWx0ZXJcIixlLHQsbikscixbc1sxXSxzWzJdXSxpKV19Y2FzZVwiRGVwdGh3aXNlQ29udjJkTmF0aXZlXCI6Y2FzZVwiRGVwdGh3aXNlQ29udjJkXCI6e2xldCByPWsoXCJzdHJpZGVzXCIsZSx0LG4pLHM9TWgoZSx0LG4pLGk9ayhcImRpbGF0aW9uc1wiLGUsdCxuKSxvPWsoXCJkYXRhRm9ybWF0XCIsZSx0LG4pLnRvVXBwZXJDYXNlKCk7cmV0dXJuW2EuZGVwdGh3aXNlQ29udjJkKGsoXCJpbnB1dFwiLGUsdCxuKSxrKFwiZmlsdGVyXCIsZSx0LG4pLFtyWzFdLHJbMl1dLHMsbyxbaVsxXSxpWzJdXSldfWNhc2VcIkNvbnYzRFwiOntsZXQgcj1rKFwic3RyaWRlc1wiLGUsdCxuKSxzPWsoXCJwYWRcIixlLHQsbiksaT1rKFwiZGF0YUZvcm1hdFwiLGUsdCxuKS50b1VwcGVyQ2FzZSgpLG89ayhcImRpbGF0aW9uc1wiLGUsdCxuKTtyZXR1cm5bYS5jb252M2QoayhcInhcIixlLHQsbiksayhcImZpbHRlclwiLGUsdCxuKSxbclsxXSxyWzJdLHJbM11dLHMsaSxbb1sxXSxvWzJdLG9bM11dKV19Y2FzZVwiQXZnUG9vbFwiOntsZXQgcj1rKFwic3RyaWRlc1wiLGUsdCxuKSxzPWsoXCJwYWRcIixlLHQsbiksaT1rKFwia2VybmVsU2l6ZVwiLGUsdCxuKTtyZXR1cm5bYS5hdmdQb29sKGsoXCJ4XCIsZSx0LG4pLFtpWzFdLGlbMl1dLFtyWzFdLHJbMl1dLHMpXX1jYXNlXCJNYXhQb29sXCI6e2xldCByPWsoXCJzdHJpZGVzXCIsZSx0LG4pLHM9ayhcInBhZFwiLGUsdCxuKSxpPWsoXCJrZXJuZWxTaXplXCIsZSx0LG4pO3JldHVyblthLm1heFBvb2woayhcInhcIixlLHQsbiksW2lbMV0saVsyXV0sW3JbMV0sclsyXV0scyldfWNhc2VcIk1heFBvb2xXaXRoQXJnbWF4XCI6e2xldCByPWsoXCJzdHJpZGVzXCIsZSx0LG4pLHM9ayhcInBhZFwiLGUsdCxuKSxpPWsoXCJrZXJuZWxTaXplXCIsZSx0LG4pLG89ayhcImluY2x1ZGVCYXRjaEluSW5kZXhcIixlLHQsbikse3Jlc3VsdDpsLGluZGV4ZXM6dX09YS5tYXhQb29sV2l0aEFyZ21heChrKFwieFwiLGUsdCxuKSxbaVsxXSxpWzJdXSxbclsxXSxyWzJdXSxzLG8pO3JldHVybltsLHVdfWNhc2VcIkF2Z1Bvb2wzRFwiOntsZXQgcj1rKFwic3RyaWRlc1wiLGUsdCxuKSxzPWsoXCJwYWRcIixlLHQsbiksaT1rKFwia2VybmVsU2l6ZVwiLGUsdCxuKTtyZXR1cm5bYS5hdmdQb29sM2QoayhcInhcIixlLHQsbiksW2lbMV0saVsyXSxpWzNdXSxbclsxXSxyWzJdLHJbM11dLHMpXX1jYXNlXCJNYXhQb29sM0RcIjp7bGV0IHI9ayhcInN0cmlkZXNcIixlLHQsbikscz1rKFwicGFkXCIsZSx0LG4pLGk9ayhcImtlcm5lbFNpemVcIixlLHQsbik7cmV0dXJuW2EubWF4UG9vbDNkKGsoXCJ4XCIsZSx0LG4pLFtpWzFdLGlbMl0saVszXV0sW3JbMV0sclsyXSxyWzNdXSxzKV19Y2FzZVwiRGlsYXRpb24yRFwiOntsZXQgcj1rKFwic3RyaWRlc1wiLGUsdCxuKSxzPWsoXCJwYWRcIixlLHQsbiksaT1rKFwiZGlsYXRpb25zXCIsZSx0LG4pLG89clsxXSxsPXJbMl0sdT1pWzFdLHA9aVsyXTtyZXR1cm5bYS5kaWxhdGlvbjJkKGsoXCJ4XCIsZSx0LG4pLGsoXCJmaWx0ZXJcIixlLHQsbiksW28sbF0scyxbdSxwXSxcIk5IV0NcIildfWRlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKGBOb2RlIHR5cGUgJHtlLm9wfSBpcyBub3QgaW1wbGVtZW50ZWRgKX19LGpxPShlLHQsbixhPW9uKT0+e3N3aXRjaChlLm9wKXtjYXNlXCJGaWxsXCI6e2xldCByPWsoXCJzaGFwZVwiLGUsdCxuKSxzPWsoXCJkdHlwZVwiLGUsdCxuKSxpPWsoXCJ2YWx1ZVwiLGUsdCxuKTtyZXR1cm5bYS5maWxsKHIsaSxzKV19Y2FzZVwiTGluU3BhY2VcIjp7bGV0IHI9ayhcInN0YXJ0XCIsZSx0LG4pLHM9ayhcInN0b3BcIixlLHQsbiksaT1rKFwibnVtXCIsZSx0LG4pO3JldHVyblthLmxpbnNwYWNlKHIscyxpKV19Y2FzZVwiTXVsdGlub21pYWxcIjp7bGV0IHI9ayhcImxvZ2l0c1wiLGUsdCxuKSxzPWsoXCJudW1TYW1wbGVzXCIsZSx0LG4pLGk9ayhcInNlZWRcIixlLHQsbik7cmV0dXJuW2EubXVsdGlub21pYWwocixzLGkpXX1jYXNlXCJPbmVIb3RcIjp7bGV0IHI9ayhcImluZGljZXNcIixlLHQsbikscz1rKFwiZGVwdGhcIixlLHQsbiksaT1rKFwib25WYWx1ZVwiLGUsdCxuKSxvPWsoXCJvZmZWYWx1ZVwiLGUsdCxuKSxsPWsoXCJkdHlwZVwiLGUsdCxuKTtyZXR1cm5bYS5vbmVIb3QocixzLGksbyxsKV19Y2FzZVwiT25lc1wiOnJldHVyblthLm9uZXMoayhcInNoYXBlXCIsZSx0LG4pLGsoXCJkdHlwZVwiLGUsdCxuKSldO2Nhc2VcIk9uZXNMaWtlXCI6cmV0dXJuW2Eub25lc0xpa2UoayhcInhcIixlLHQsbikpXTtjYXNlXCJSYW5kb21TdGFuZGFyZE5vcm1hbFwiOnJldHVyblthLnJhbmRvbVN0YW5kYXJkTm9ybWFsKGsoXCJzaGFwZVwiLGUsdCxuKSxrKFwiZHR5cGVcIixlLHQsbiksayhcInNlZWRcIixlLHQsbikpXTtjYXNlXCJSYW5kb21Vbmlmb3JtXCI6cmV0dXJuW2EucmFuZG9tVW5pZm9ybShrKFwic2hhcGVcIixlLHQsbiksayhcIm1pbnZhbFwiLGUsdCxuKSxrKFwibWF4dmFsXCIsZSx0LG4pLGsoXCJkdHlwZVwiLGUsdCxuKSldO2Nhc2VcIlJhbmRvbVVuaWZvcm1JbnRcIjpyZXR1cm5bYS5yYW5kb21Vbmlmb3JtSW50KGsoXCJzaGFwZVwiLGUsdCxuKSxrKFwibWludmFsXCIsZSx0LG4pLGsoXCJtYXh2YWxcIixlLHQsbiksayhcInNlZWRcIixlLHQsbikpXTtjYXNlXCJSYW5nZVwiOntsZXQgcj1rKFwic3RhcnRcIixlLHQsbikscz1rKFwic3RvcFwiLGUsdCxuKSxpPWsoXCJzdGVwXCIsZSx0LG4pO3JldHVyblthLnJhbmdlKHIscyxpLGsoXCJkdHlwZVwiLGUsdCxuKSldfWNhc2VcIlRydW5jYXRlZE5vcm1hbFwiOntsZXQgcj1rKFwic2hhcGVcIixlLHQsbikscz1rKFwibWVhblwiLGUsdCxuKSxpPWsoXCJzdGREZXZcIixlLHQsbiksbz1rKFwic2VlZFwiLGUsdCxuKTtyZXR1cm5bYS50cnVuY2F0ZWROb3JtYWwocixzLGksayhcImR0eXBlXCIsZSx0LG4pLG8pXX1jYXNlXCJaZXJvc1wiOnJldHVyblthLnplcm9zKGsoXCJzaGFwZVwiLGUsdCxuKSxrKFwiZHR5cGVcIixlLHQsbikpXTtjYXNlXCJaZXJvc0xpa2VcIjpyZXR1cm5bYS56ZXJvc0xpa2UoayhcInhcIixlLHQsbikpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihgTm9kZSB0eXBlICR7ZS5vcH0gaXMgbm90IGltcGxlbWVudGVkYCl9fTtmdW5jdGlvbiBneChlLHQsbil7bGV0IGE9ayhcImJveGVzXCIsZSx0LG4pLHI9ayhcInNjb3Jlc1wiLGUsdCxuKSxzPWsoXCJtYXhPdXRwdXRTaXplXCIsZSx0LG4pLGk9ayhcImlvdVRocmVzaG9sZFwiLGUsdCxuKSxvPWsoXCJzY29yZVRocmVzaG9sZFwiLGUsdCxuKSxsPWsoXCJzb2Z0Tm1zU2lnbWFcIixlLHQsbik7cmV0dXJue2JveGVzOmEsc2NvcmVzOnIsbWF4T3V0cHV0U2l6ZTpzLGlvdVRocmVzaG9sZDppLHNjb3JlVGhyZXNob2xkOm8sc29mdE5tc1NpZ21hOmx9fXZhciBxcT1hc3luYyhlLHQsbixhLHI9b24pPT57c3dpdGNoKGUub3Ape2Nhc2VcIk5vbk1heFN1cHByZXNzaW9uVjVcIjp7bGV0e2JveGVzOnMsc2NvcmVzOmksbWF4T3V0cHV0U2l6ZTpvLGlvdVRocmVzaG9sZDpsLHNjb3JlVGhyZXNob2xkOnUsc29mdE5tc1NpZ21hOnB9PWd4KGUsdCxuKSxkPWF3YWl0IHIuaW1hZ2Uubm9uTWF4U3VwcHJlc3Npb25XaXRoU2NvcmVBc3luYyhzLGksbyxsLHUscCk7cmV0dXJuW2Quc2VsZWN0ZWRJbmRpY2VzLGQuc2VsZWN0ZWRTY29yZXNdfWNhc2VcIk5vbk1heFN1cHByZXNzaW9uVjRcIjp7bGV0e2JveGVzOnMsc2NvcmVzOmksbWF4T3V0cHV0U2l6ZTpvLGlvdVRocmVzaG9sZDpsLHNjb3JlVGhyZXNob2xkOnV9PWd4KGUsdCxuKSxwPWsoXCJwYWRUb01heE91dHB1dFNpemVcIixlLHQsbiksZD1hd2FpdCByLmltYWdlLm5vbk1heFN1cHByZXNzaW9uUGFkZGVkQXN5bmMocyxpLG8sbCx1LHApO3JldHVybltkLnNlbGVjdGVkSW5kaWNlcyxkLnZhbGlkT3V0cHV0c119Y2FzZVwiTm9uTWF4U3VwcHJlc3Npb25WM1wiOmNhc2VcIk5vbk1heFN1cHByZXNzaW9uVjJcIjp7bGV0e2JveGVzOnMsc2NvcmVzOmksbWF4T3V0cHV0U2l6ZTpvLGlvdVRocmVzaG9sZDpsLHNjb3JlVGhyZXNob2xkOnV9PWd4KGUsdCxuKTtyZXR1cm5bYXdhaXQgci5pbWFnZS5ub25NYXhTdXBwcmVzc2lvbkFzeW5jKHMsaSxvLGwsdSldfWNhc2VcIldoZXJlXCI6e2xldCBzPXIuY2FzdChrKFwiY29uZGl0aW9uXCIsZSx0LG4pLFwiYm9vbFwiKSxpPVthd2FpdCByLndoZXJlQXN5bmMocyldO3JldHVybiBzLmRpc3Bvc2UoKSxpfWNhc2VcIkxpc3REaWZmXCI6cmV0dXJuIHIuc2V0ZGlmZjFkQXN5bmMoayhcInhcIixlLHQsbiksayhcInlcIixlLHQsbikpO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKGBOb2RlIHR5cGUgJHtlLm9wfSBpcyBub3QgaW1wbGVtZW50ZWRgKX19LEtxPShlLHQsbixhPW9uKT0+e3N3aXRjaChlLm9wKXtjYXNlXCJMb3dlckJvdW5kXCI6e2xldCByPWsoXCJzb3J0ZWRTZXF1ZW5jZVwiLGUsdCxuKSxzPWsoXCJ2YWx1ZXNcIixlLHQsbik7cmV0dXJuW2EubG93ZXJCb3VuZChyLHMpXX1jYXNlXCJUb3BLVjJcIjp7bGV0IHI9ayhcInhcIixlLHQsbikscz1rKFwia1wiLGUsdCxuKSxpPWsoXCJzb3J0ZWRcIixlLHQsbiksbz1hLnRvcGsocixzLGkpO3JldHVybltvLnZhbHVlcyxvLmluZGljZXNdfWNhc2VcIlVwcGVyQm91bmRcIjp7bGV0IHI9ayhcInNvcnRlZFNlcXVlbmNlXCIsZSx0LG4pLHM9ayhcInZhbHVlc1wiLGUsdCxuKTtyZXR1cm5bYS51cHBlckJvdW5kKHIscyldfWNhc2VcIlVuaXF1ZVwiOntsZXQgcj1rKFwieFwiLGUsdCxuKSxzPWEudW5pcXVlKHIpO3JldHVybltzLnZhbHVlcyxzLmluZGljZXNdfWNhc2VcIlVuaXF1ZVYyXCI6e2xldCByPWsoXCJ4XCIsZSx0LG4pLHM9ayhcImF4aXNcIixlLHQsbiksaT1hLnVuaXF1ZShyLHMpO3JldHVybltpLnZhbHVlcyxpLmluZGljZXNdfWRlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKGBOb2RlIHR5cGUgJHtlLm9wfSBpcyBub3QgaW1wbGVtZW50ZWRgKX19LFhxPShlLHQsbixhPW9uKT0+e3N3aXRjaChlLm9wKXtjYXNlXCJDb25zdFwiOnJldHVybiB0W2UubmFtZV07Y2FzZVwiUGxhY2Vob2xkZXJXaXRoRGVmYXVsdFwiOmxldCByPWsoXCJkZWZhdWx0XCIsZSx0LG4pO3JldHVybltwbihlLm5hbWUsdCxuKXx8cl07Y2FzZVwiUGxhY2Vob2xkZXJcIjpyZXR1cm5bcG4oZS5uYW1lLHQsbildO2Nhc2VcIklkZW50aXR5XCI6Y2FzZVwiU3RvcEdyYWRpZW50XCI6Y2FzZVwiRmFrZVF1YW50V2l0aE1pbk1heFZhcnNcIjp7bGV0IHA9ayhcInhcIixlLHQsbik7cmV0dXJuW05yKHApXX1jYXNlXCJJZGVudGl0eU5cIjpyZXR1cm4gayhcInhcIixlLHQsbikubWFwKHA9Pk5yKHApKTtjYXNlXCJTbmFwc2hvdFwiOmxldCBzPWsoXCJ4XCIsZSx0LG4pO3JldHVybltOcihzKV07Y2FzZVwiU2hhcGVcIjpyZXR1cm5bYS50ZW5zb3IxZChrKFwieFwiLGUsdCxuKS5zaGFwZSxcImludDMyXCIpXTtjYXNlXCJTaGFwZU5cIjpyZXR1cm4gayhcInhcIixlLHQsbikubWFwKHA9PmEudGVuc29yMWQocC5zaGFwZSkpO2Nhc2VcIlNpemVcIjpyZXR1cm5bYS5zY2FsYXIoayhcInhcIixlLHQsbikuc2l6ZSxcImludDMyXCIpXTtjYXNlXCJSYW5rXCI6cmV0dXJuW2Euc2NhbGFyKGsoXCJ4XCIsZSx0LG4pLnJhbmssXCJpbnQzMlwiKV07Y2FzZVwiTm9PcFwiOnJldHVyblthLnNjYWxhcigxKV07Y2FzZVwiUHJpbnRcIjpsZXQgaT1rKFwieFwiLGUsdCxuKSxvPWsoXCJkYXRhXCIsZSx0LG4pLGw9ayhcIm1lc3NhZ2VcIixlLHQsbiksdT1rKFwic3VtbWFyaXplXCIsZSx0LG4pO2NvbnNvbGUud2FybihcIlRoZSBncmFwaCBoYXMgYSB0Zi5wcmludCgpIG9wZXJhdGlvbix1c3VhbGx5IHVzZWQgZm9yIGRlYnVnZ2luZywgd2hpY2ggc2xvd3MgZG93biBwZXJmb3JtYW5jZS5cIiksY29uc29sZS5sb2cobCk7Zm9yKGxldCBwPTA7cDxvLmxlbmd0aDtwKyspY29uc29sZS5sb2coQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob1twXS5kYXRhU3luYygpKS5zbGljZSgwLHUpKTtyZXR1cm5baV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoYE5vZGUgdHlwZSAke2Uub3B9IGlzIG5vdCBpbXBsZW1lbnRlZGApfX0sWXE9Y2xhc3N7Z2V0IGlkKCl7cmV0dXJuIHRoaXMuaGFuZGxlLmlkfWNvbnN0cnVjdG9yKGUsdCl7dGhpcy5rZXlEVHlwZT1lLHRoaXMudmFsdWVEVHlwZT10LHRoaXMuaGFuZGxlPXhlKDApLHRoaXMudGVuc29yTWFwPW5ldyBNYXAsSHQodGhpcy5oYW5kbGUpfWNsZWFyQW5kQ2xvc2UoKXt0aGlzLnRlbnNvck1hcC5mb3JFYWNoKGU9PmUuZGlzcG9zZSgpKSx0aGlzLnRlbnNvck1hcC5jbGVhcigpLHRoaXMuaGFuZGxlLmRpc3Bvc2UoKX1zaXplKCl7cmV0dXJuIHRoaXMudGVuc29yTWFwLnNpemV9dGVuc29yU2l6ZSgpe3JldHVybiB4ZSh0aGlzLnNpemUoKSxcImludDMyXCIpfWFzeW5jIGltcG9ydChlLHQpe3RoaXMuY2hlY2tLZXlBbmRWYWx1ZVRlbnNvcihlLHQpO2xldCBuPWF3YWl0IGUuZGF0YSgpO3JldHVybiB0aGlzLnRlbnNvck1hcC5mb3JFYWNoKGE9PmEuZGlzcG9zZSgpKSx0aGlzLnRlbnNvck1hcC5jbGVhcigpLE8oKCk9PntsZXQgYT1kdCh0KSxyPW4ubGVuZ3RoLHM9YS5sZW5ndGg7dy5hc3NlcnQocj09PXMsKCk9PmBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGRvZXNuJ3QgbWF0Y2gsIGtleXMgaGFzICR7cn0gZWxlbWVudHMsIHRoZSB2YWx1ZXMgaGFzICR7c30gZWxlbWVudHMuYCk7Zm9yKGxldCBpPTA7aTxyO2krKyl7bGV0IG89bltpXSxsPWFbaV07SHQobCksdGhpcy50ZW5zb3JNYXAuc2V0KG8sbCl9cmV0dXJuIHRoaXMuaGFuZGxlfSl9YXN5bmMgZmluZChlLHQpe3RoaXMuY2hlY2tLZXlBbmRWYWx1ZVRlbnNvcihlLHQpO2xldCBuPWF3YWl0IGUuZGF0YSgpO3JldHVybiBPKCgpPT57bGV0IGE9W107Zm9yKGxldCByPTA7cjxuLmxlbmd0aDtyKyspe2xldCBzPW5bcl0saT10aGlzLmZpbmRXaXRoRGVmYXVsdChzLHQpO2EucHVzaChpKX1yZXR1cm4gQXQoYSl9KX1maW5kV2l0aERlZmF1bHQoZSx0KXtsZXQgbj10aGlzLnRlbnNvck1hcC5nZXQoZSk7cmV0dXJuIG4hPW51bGw/bjp0fWNoZWNrS2V5QW5kVmFsdWVUZW5zb3IoZSx0KXtpZihlLmR0eXBlIT09dGhpcy5rZXlEVHlwZSl0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdCBrZXkgZHR5cGUgJHt0aGlzLmtleURUeXBlfSwgYnV0IGdvdCAke2UuZHR5cGV9YCk7aWYodC5kdHlwZSE9PXRoaXMudmFsdWVEVHlwZSl0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdCB2YWx1ZSBkdHlwZSAke3RoaXMudmFsdWVEVHlwZX0sIGJ1dCBnb3QgJHt0LmR0eXBlfWApfX0sWnE9YXN5bmMoZSx0LG4sYSk9Pntzd2l0Y2goZS5vcCl7Y2FzZVwiSGFzaFRhYmxlXCI6Y2FzZVwiSGFzaFRhYmxlVjJcIjp7bGV0IHI9YS5nZXRIYXNoVGFibGVIYW5kbGVCeU5hbWUoZS5uYW1lKTtpZihyIT1udWxsKXJldHVybltyXTt7bGV0IHM9ayhcImtleURUeXBlXCIsZSx0LG4pLGk9ayhcInZhbHVlRFR5cGVcIixlLHQsbiksbz1uZXcgWXEocyxpKTtyZXR1cm4gYS5hZGRIYXNoVGFibGUoZS5uYW1lLG8pLFtvLmhhbmRsZV19fWNhc2VcIkluaXRpYWxpemVUYWJsZVwiOmNhc2VcIkluaXRpYWxpemVUYWJsZVYyXCI6Y2FzZVwiTG9va3VwVGFibGVJbXBvcnRcIjpjYXNlXCJMb29rdXBUYWJsZUltcG9ydFYyXCI6e2xldCByPWsoXCJ0YWJsZUhhbmRsZVwiLGUsdCxuLGEpLHM9ayhcImtleXNcIixlLHQsbiksaT1rKFwidmFsdWVzXCIsZSx0LG4pO3JldHVyblthd2FpdCBhLmdldEhhc2hUYWJsZUJ5SWQoci5pZCkuaW1wb3J0KHMsaSldfWNhc2VcIkxvb2t1cFRhYmxlRmluZFwiOmNhc2VcIkxvb2t1cFRhYmxlRmluZFYyXCI6e2xldCByPWsoXCJ0YWJsZUhhbmRsZVwiLGUsdCxuLGEpLHM9ayhcImtleXNcIixlLHQsbiksaT1rKFwiZGVmYXVsdFZhbHVlXCIsZSx0LG4pO3JldHVyblthd2FpdCBhLmdldEhhc2hUYWJsZUJ5SWQoci5pZCkuZmluZChzLGkpXX1jYXNlXCJMb29rdXBUYWJsZVNpemVcIjpjYXNlXCJMb29rdXBUYWJsZVNpemVWMlwiOntsZXQgcj1rKFwidGFibGVIYW5kbGVcIixlLHQsbixhKTtyZXR1cm5bYS5nZXRIYXNoVGFibGVCeUlkKHIuaWQpLnRlbnNvclNpemUoKV19ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoYE5vZGUgdHlwZSAke2Uub3B9IGlzIG5vdCBpbXBsZW1lbnRlZGApfX0sSnE9KGUsdCxuLGE9b24pPT57c3dpdGNoKGUub3Ape2Nhc2VcIlJlc2l6ZUJpbGluZWFyXCI6e2xldCByPWsoXCJpbWFnZXNcIixlLHQsbikscz1rKFwic2l6ZVwiLGUsdCxuKSxpPWsoXCJhbGlnbkNvcm5lcnNcIixlLHQsbiksbz1rKFwiaGFsZlBpeGVsQ2VudGVyc1wiLGUsdCxuKTtyZXR1cm5bYS5pbWFnZS5yZXNpemVCaWxpbmVhcihyLFtzWzBdLHNbMV1dLGksbyldfWNhc2VcIlJlc2l6ZU5lYXJlc3ROZWlnaGJvclwiOntsZXQgcj1rKFwiaW1hZ2VzXCIsZSx0LG4pLHM9ayhcInNpemVcIixlLHQsbiksaT1rKFwiYWxpZ25Db3JuZXJzXCIsZSx0LG4pLG89ayhcImhhbGZQaXhlbENlbnRlcnNcIixlLHQsbik7cmV0dXJuW2EuaW1hZ2UucmVzaXplTmVhcmVzdE5laWdoYm9yKHIsW3NbMF0sc1sxXV0saSxvKV19Y2FzZVwiQ3JvcEFuZFJlc2l6ZVwiOntsZXQgcj1rKFwiaW1hZ2VcIixlLHQsbikscz1rKFwiYm94ZXNcIixlLHQsbiksaT1rKFwiYm94SW5kXCIsZSx0LG4pLG89ayhcImNyb3BTaXplXCIsZSx0LG4pLGw9ayhcIm1ldGhvZFwiLGUsdCxuKSx1PWsoXCJleHRyYXBvbGF0aW9uVmFsdWVcIixlLHQsbik7cmV0dXJuW2EuaW1hZ2UuY3JvcEFuZFJlc2l6ZShyLHMsaSxvLGwsdSldfWNhc2VcIkltYWdlUHJvamVjdGl2ZVRyYW5zZm9ybVYzXCI6e2xldCByPWsoXCJpbWFnZXNcIixlLHQsbikscz1rKFwidHJhbnNmb3Jtc1wiLGUsdCxuKSxpPWsoXCJvdXRwdXRTaGFwZVwiLGUsdCxuKSxvPWsoXCJmaWxsVmFsdWVcIixlLHQsbiksbD1rKFwiaW50ZXJwb2xhdGlvblwiLGUsdCxuKSx1PWsoXCJmaWxsTW9kZVwiLGUsdCxuKTtyZXR1cm5bYS5pbWFnZS50cmFuc2Zvcm0ocixzLGwudG9Mb3dlckNhc2UoKSx1LnRvTG93ZXJDYXNlKCksbyxpKV19ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoYE5vZGUgdHlwZSAke2Uub3B9IGlzIG5vdCBpbXBsZW1lbnRlZGApfX0sUXE9KGUsdCxuLGE9b24pPT57c3dpdGNoKGUub3Ape2Nhc2VcIkVxdWFsXCI6cmV0dXJuW2EuZXF1YWwoayhcImFcIixlLHQsbiksayhcImJcIixlLHQsbikpXTtjYXNlXCJOb3RFcXVhbFwiOnJldHVyblthLm5vdEVxdWFsKGsoXCJhXCIsZSx0LG4pLGsoXCJiXCIsZSx0LG4pKV07Y2FzZVwiR3JlYXRlclwiOnJldHVyblthLmdyZWF0ZXIoayhcImFcIixlLHQsbiksayhcImJcIixlLHQsbikpXTtjYXNlXCJHcmVhdGVyRXF1YWxcIjpyZXR1cm5bYS5ncmVhdGVyRXF1YWwoayhcImFcIixlLHQsbiksayhcImJcIixlLHQsbikpXTtjYXNlXCJMZXNzXCI6cmV0dXJuW2EubGVzcyhrKFwiYVwiLGUsdCxuKSxrKFwiYlwiLGUsdCxuKSldO2Nhc2VcIkxlc3NFcXVhbFwiOnJldHVyblthLmxlc3NFcXVhbChrKFwiYVwiLGUsdCxuKSxrKFwiYlwiLGUsdCxuKSldO2Nhc2VcIkxvZ2ljYWxBbmRcIjpyZXR1cm5bYS5sb2dpY2FsQW5kKGsoXCJhXCIsZSx0LG4pLGsoXCJiXCIsZSx0LG4pKV07Y2FzZVwiTG9naWNhbE5vdFwiOnJldHVyblthLmxvZ2ljYWxOb3QoayhcImFcIixlLHQsbikpXTtjYXNlXCJMb2dpY2FsT3JcIjpyZXR1cm5bYS5sb2dpY2FsT3IoayhcImFcIixlLHQsbiksayhcImJcIixlLHQsbikpXTtjYXNlXCJTZWxlY3RcIjpjYXNlXCJTZWxlY3RWMlwiOnJldHVyblthLndoZXJlKGsoXCJjb25kaXRpb25cIixlLHQsbiksayhcImFcIixlLHQsbiksayhcImJcIixlLHQsbikpXTtjYXNlXCJCaXR3aXNlQW5kXCI6cmV0dXJuW2EuYml0d2lzZUFuZChrKFwiYVwiLGUsdCxuKSxrKFwiYlwiLGUsdCxuKSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKGBOb2RlIHR5cGUgJHtlLm9wfSBpcyBub3QgaW1wbGVtZW50ZWRgKX19LGU1PShlLHQsbixhPW9uKT0+e3N3aXRjaChlLm9wKXtjYXNlXCJCYXRjaE1hdE11bFwiOmNhc2VcIkJhdGNoTWF0TXVsVjJcIjpjYXNlXCJNYXRNdWxcIjpyZXR1cm5bYS5tYXRNdWwoayhcImFcIixlLHQsbiksayhcImJcIixlLHQsbiksayhcInRyYW5zcG9zZUFcIixlLHQsbiksayhcInRyYW5zcG9zZUJcIixlLHQsbikpXTtjYXNlXCJFaW5zdW1cIjpyZXR1cm5bYS5laW5zdW0oayhcImVxdWF0aW9uXCIsZSx0LG4pLC4uLmsoXCJ0ZW5zb3JzXCIsZSx0LG4pKV07Y2FzZVwiVHJhbnNwb3NlXCI6cmV0dXJuW2EudHJhbnNwb3NlKGsoXCJ4XCIsZSx0LG4pLGsoXCJwZXJtXCIsZSx0LG4pKV07Y2FzZVwiX0Z1c2VkTWF0TXVsXCI6bGV0W3Isc109ayhcImZ1c2VkT3BzXCIsZSx0LG4pLGk9cj09PVwiYmlhc2FkZFwiLG89cz09PVwicHJlbHVcIixsPWsoXCJudW1BcmdzXCIsZSx0LG4pLHU9ayhcImxlYWt5cmVsdUFscGhhXCIsZSx0LG4pO2lmKGkpe2lmKG8mJmwhPT0yKXRocm93IG5ldyBFcnJvcihcIkZ1c2VkIE1hdE11bCB3aXRoIEJpYXNBZGQgYW5kIFByZWx1IG11c3QgaGF2ZSB0d28gZXh0cmEgYXJndW1lbnRzOiBiaWFzIGFuZCBhbHBoYS5cIik7aWYoIW8mJmwhPT0xKXRocm93IG5ldyBFcnJvcihcIkZ1c2VkIE1hdE11bCB3aXRoIEJpYXNBZGQgbXVzdCBoYXZlIG9uZSBleHRyYSBhcmd1bWVudDogYmlhcy5cIil9bGV0W3AsZF09ayhcImFyZ3NcIixlLHQsbik7cmV0dXJuW2EuZnVzZWQubWF0TXVsKHthOmsoXCJhXCIsZSx0LG4pLGI6ayhcImJcIixlLHQsbiksdHJhbnNwb3NlQTprKFwidHJhbnNwb3NlQVwiLGUsdCxuKSx0cmFuc3Bvc2VCOmsoXCJ0cmFuc3Bvc2VCXCIsZSx0LG4pLGJpYXM6cCxhY3RpdmF0aW9uOnMscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czpkLGxlYWt5cmVsdUFscGhhOnV9KV07Y2FzZVwiTWF0cml4QmFuZFBhcnRcIjpyZXR1cm5bYS5saW5hbGcuYmFuZFBhcnQoayhcImFcIixlLHQsbiksayhcIm51bUxvd2VyXCIsZSx0LG4pLGsoXCJudW1VcHBlclwiLGUsdCxuKSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKGBOb2RlIHR5cGUgJHtlLm9wfSBpcyBub3QgaW1wbGVtZW50ZWRgKX19LHQ1PShlLHQsbixhPW9uKT0+e3N3aXRjaChlLm9wKXtjYXNlXCJFdWNsaWRlYW5Ob3JtXCI6cmV0dXJuW2EuZXVjbGlkZWFuTm9ybShrKFwieFwiLGUsdCxuKSxrKFwiYXhpc1wiLGUsdCxuKSxrKFwia2VlcERpbXNcIixlLHQsbikpXTtjYXNlXCJGdXNlZEJhdGNoTm9ybVwiOmNhc2VcIkZ1c2VkQmF0Y2hOb3JtVjJcIjpyZXR1cm5bYS5iYXRjaE5vcm0oayhcInhcIixlLHQsbiksayhcIm1lYW5cIixlLHQsbiksayhcInZhcmlhbmNlXCIsZSx0LG4pLGsoXCJvZmZzZXRcIixlLHQsbiksayhcInNjYWxlXCIsZSx0LG4pLGsoXCJlcHNpbG9uXCIsZSx0LG4pKV07Y2FzZVwiRnVzZWRCYXRjaE5vcm1WM1wiOnJldHVyblthLmJhdGNoTm9ybShrKFwieFwiLGUsdCxuKSxrKFwibWVhblwiLGUsdCxuKSxrKFwidmFyaWFuY2VcIixlLHQsbiksayhcIm9mZnNldFwiLGUsdCxuKSxrKFwic2NhbGVcIixlLHQsbiksayhcImVwc2lsb25cIixlLHQsbikpXTtjYXNlXCJMUk5cIjpyZXR1cm5bYS5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbihrKFwieFwiLGUsdCxuKSxrKFwicmFkaXVzXCIsZSx0LG4pLGsoXCJiaWFzXCIsZSx0LG4pLGsoXCJhbHBoYVwiLGUsdCxuKSxrKFwiYmV0YVwiLGUsdCxuKSldO2Nhc2VcIlNvZnRtYXhcIjpyZXR1cm5bYS5zb2Z0bWF4KGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiTG9nU29mdG1heFwiOnJldHVyblthLmxvZ1NvZnRtYXgoayhcInhcIixlLHQsbikpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihgTm9kZSB0eXBlICR7ZS5vcH0gaXMgbm90IGltcGxlbWVudGVkYCl9fSxuNT0oZSx0LG4sYT1vbik9Pntzd2l0Y2goZS5vcCl7Y2FzZVwiUmFnZ2VkR2F0aGVyXCI6e2xldHtvdXRwdXROZXN0ZWRTcGxpdHM6cixvdXRwdXREZW5zZVZhbHVlczpzfT1hLnJhZ2dlZEdhdGhlcihrKFwicGFyYW1zTmVzdGVkU3BsaXRzXCIsZSx0LG4pLGsoXCJwYXJhbXNEZW5zZVZhbHVlc1wiLGUsdCxuKSxrKFwiaW5kaWNlc1wiLGUsdCxuKSxrKFwib3V0cHV0UmFnZ2VkUmFua1wiLGUsdCxuKSk7cmV0dXJuIHIuY29uY2F0KHMpfWNhc2VcIlJhZ2dlZFJhbmdlXCI6e2xldHtydE5lc3RlZFNwbGl0czpyLHJ0RGVuc2VWYWx1ZXM6c309YS5yYWdnZWRSYW5nZShrKFwic3RhcnRzXCIsZSx0LG4pLGsoXCJsaW1pdHNcIixlLHQsbiksayhcInNwbGl0c1wiLGUsdCxuKSk7cmV0dXJuW3Isc119Y2FzZVwiUmFnZ2VkVGVuc29yVG9UZW5zb3JcIjpyZXR1cm5bYS5yYWdnZWRUZW5zb3JUb1RlbnNvcihrKFwic2hhcGVcIixlLHQsbiksayhcInZhbHVlc1wiLGUsdCxuKSxrKFwiZGVmYXVsdFZhbHVlXCIsZSx0LG4pLGsoXCJyb3dQYXJ0aXRpb25UZW5zb3JzXCIsZSx0LG4pLGsoXCJyb3dQYXJ0aXRpb25UeXBlc1wiLGUsdCxuKSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKGBOb2RlIHR5cGUgJHtlLm9wfSBpcyBub3QgaW1wbGVtZW50ZWRgKX19LGE1PShlLHQsbixhPW9uKT0+e3N3aXRjaChlLm9wKXtjYXNlXCJNYXhcIjp7bGV0IG89ayhcImF4aXNcIixlLHQsbiksbD1rKFwia2VlcERpbXNcIixlLHQsbik7cmV0dXJuW2EubWF4KGsoXCJ4XCIsZSx0LG4pLG8sbCldfWNhc2VcIk1lYW5cIjp7bGV0IG89ayhcImF4aXNcIixlLHQsbiksbD1rKFwia2VlcERpbXNcIixlLHQsbik7cmV0dXJuW2EubWVhbihrKFwieFwiLGUsdCxuKSxvLGwpXX1jYXNlXCJNaW5cIjp7bGV0IG89ayhcImF4aXNcIixlLHQsbiksbD1rKFwia2VlcERpbXNcIixlLHQsbik7cmV0dXJuW2EubWluKGsoXCJ4XCIsZSx0LG4pLG8sbCldfWNhc2VcIlN1bVwiOntsZXQgbz1rKFwiYXhpc1wiLGUsdCxuKSxsPWsoXCJrZWVwRGltc1wiLGUsdCxuKTtyZXR1cm5bYS5zdW0oayhcInhcIixlLHQsbiksbyxsKV19Y2FzZVwiQWxsXCI6e2xldCBvPWsoXCJheGlzXCIsZSx0LG4pLGw9ayhcImtlZXBEaW1zXCIsZSx0LG4pO3JldHVyblthLmFsbChrKFwieFwiLGUsdCxuKSxvLGwpXX1jYXNlXCJBbnlcIjp7bGV0IG89ayhcImF4aXNcIixlLHQsbiksbD1rKFwia2VlcERpbXNcIixlLHQsbik7cmV0dXJuW2EuYW55KGsoXCJ4XCIsZSx0LG4pLG8sbCldfWNhc2VcIkFyZ01heFwiOntsZXQgbz1rKFwiYXhpc1wiLGUsdCxuKTtyZXR1cm5bYS5hcmdNYXgoayhcInhcIixlLHQsbiksbyldfWNhc2VcIkFyZ01pblwiOntsZXQgbz1rKFwiYXhpc1wiLGUsdCxuKTtyZXR1cm5bYS5hcmdNaW4oayhcInhcIixlLHQsbiksbyldfWNhc2VcIlByb2RcIjp7bGV0IG89ayhcImF4aXNcIixlLHQsbiksbD1rKFwia2VlcERpbXNcIixlLHQsbik7cmV0dXJuW2EucHJvZChrKFwieFwiLGUsdCxuKSxvLGwpXX1jYXNlXCJDdW1wcm9kXCI6e2xldCBvPWsoXCJheGlzXCIsZSx0LG4pLGw9ayhcImV4Y2x1c2l2ZVwiLGUsdCxuKSx1PWsoXCJyZXZlcnNlXCIsZSx0LG4pO3JldHVyblthLmN1bXByb2QoayhcInhcIixlLHQsbiksbyxsLHUpXX1jYXNlXCJDdW1zdW1cIjp7bGV0IG89ayhcImF4aXNcIixlLHQsbiksbD1rKFwiZXhjbHVzaXZlXCIsZSx0LG4pLHU9ayhcInJldmVyc2VcIixlLHQsbik7cmV0dXJuW2EuY3Vtc3VtKGsoXCJ4XCIsZSx0LG4pLG8sbCx1KV19Y2FzZVwiQmluY291bnRcIjpsZXQgcj1rKFwieFwiLGUsdCxuKSxzPWsoXCJ3ZWlnaHRzXCIsZSx0LG4pLGk9ayhcInNpemVcIixlLHQsbik7cmV0dXJuW2EuYmluY291bnQocixzLGkpXTtjYXNlXCJEZW5zZUJpbmNvdW50XCI6e2xldCBvPWsoXCJ4XCIsZSx0LG4pLGw9ayhcIndlaWdodHNcIixlLHQsbiksdT1rKFwic2l6ZVwiLGUsdCxuKSxwPWsoXCJiaW5hcnlPdXRwdXRcIixlLHQsbik7cmV0dXJuW2EuZGVuc2VCaW5jb3VudChvLGwsdSxwKV19ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoYE5vZGUgdHlwZSAke2Uub3B9IGlzIG5vdCBpbXBsZW1lbnRlZGApfX0scjU9KGUsdCxuLGE9b24pPT57c3dpdGNoKGUub3Ape2Nhc2VcIkNvbmNhdFYyXCI6Y2FzZVwiQ29uY2F0XCI6e2xldCByPWsoXCJuXCIsZSx0LG4pLHM9ayhcImF4aXNcIixlLHQsbiksaT1rKFwidGVuc29yc1wiLGUsdCxuKTtyZXR1cm4gaT1pLnNsaWNlKDAsciksW2EuY29uY2F0KGkscyldfWNhc2VcIkdhdGhlclwiOntsZXQgcj1rKFwieFwiLGUsdCxuKSxzPWsoXCJpbmRpY2VzXCIsZSx0LG4pO3JldHVyblthLmdhdGhlcihyLGEuY2FzdChzLFwiaW50MzJcIiksMCldfWNhc2VcIkdhdGhlclYyXCI6e2xldCByPWsoXCJheGlzXCIsZSx0LG4pLHM9ayhcImJhdGNoRGltc1wiLGUsdCxuKSxpPWsoXCJ4XCIsZSx0LG4pLG89ayhcImluZGljZXNcIixlLHQsbik7cmV0dXJuW2EuZ2F0aGVyKGksYS5jYXN0KG8sXCJpbnQzMlwiKSxyLHMpXX1jYXNlXCJSZXZlcnNlXCI6e2xldCByPWsoXCJkaW1zXCIsZSx0LG4pLHM9W107Zm9yKGxldCBvPTA7bzxyLmxlbmd0aDtvKyspcltvXSYmcy5wdXNoKG8pO2xldCBpPWsoXCJ4XCIsZSx0LG4pO3JldHVyblthLnJldmVyc2UoaSxzKV19Y2FzZVwiUmV2ZXJzZVYyXCI6e2xldCByPWsoXCJheGlzXCIsZSx0LG4pLHM9ayhcInhcIixlLHQsbik7cmV0dXJuW2EucmV2ZXJzZShzLHIpXX1jYXNlXCJTbGljZVwiOntsZXQgcj1rKFwiYmVnaW5cIixlLHQsbikscz1rKFwic2l6ZVwiLGUsdCxuKTtyZXR1cm5bYS5zbGljZShrKFwieFwiLGUsdCxuKSxyLHMpXX1jYXNlXCJTdHJpZGVkU2xpY2VcIjp7bGV0IHI9ayhcImJlZ2luXCIsZSx0LG4pLHM9ayhcImVuZFwiLGUsdCxuKSxpPWsoXCJzdHJpZGVzXCIsZSx0LG4pLG89ayhcImJlZ2luTWFza1wiLGUsdCxuKSxsPWsoXCJlbmRNYXNrXCIsZSx0LG4pLHU9ayhcImVsbGlwc2lzTWFza1wiLGUsdCxuKSxwPWsoXCJuZXdBeGlzTWFza1wiLGUsdCxuKSxkPWsoXCJzaHJpbmtBeGlzTWFza1wiLGUsdCxuKSxjPWsoXCJ4XCIsZSx0LG4pO3JldHVyblthLnN0cmlkZWRTbGljZShjLHIscyxpLG8sbCx1LHAsZCldfWNhc2VcIlBhY2tcIjpyZXR1cm4gTygoKT0+e2xldCByPWsoXCJheGlzXCIsZSx0LG4pLHM9ayhcInRlbnNvcnNcIixlLHQsbiksaT1zWzBdLnNoYXBlLG89YS5zcXVlZXplKHNbMF0pLnNoYXBlLGw9cy5tYXAodT0+e2xldCBwPXcuYXJyYXlzRXF1YWwodS5zaGFwZSxpKTtpZighcCYmIXcuYXJyYXlzRXF1YWwoYS5zcXVlZXplKHUpLnNoYXBlLG8pKXRocm93IG5ldyBFcnJvcihcInRoZSBpbnB1dCB0ZW5zb3JzIHNoYXBlIGRvZXMgbm90IG1hdGNoXCIpO3JldHVybiBwP3U6YS5yZXNoYXBlKHUsaSl9KTtyZXR1cm5bYS5zdGFjayhsLHIpXX0pO2Nhc2VcIlVucGFja1wiOntsZXQgcj1rKFwiYXhpc1wiLGUsdCxuKSxzPWsoXCJ0ZW5zb3JcIixlLHQsbik7cmV0dXJuIGEudW5zdGFjayhzLHIpfWNhc2VcIlRpbGVcIjp7bGV0IHI9ayhcInJlcHNcIixlLHQsbik7cmV0dXJuW2EudGlsZShrKFwieFwiLGUsdCxuKSxyKV19Y2FzZVwiU3BsaXRcIjpjYXNlXCJTcGxpdFZcIjp7bGV0IHI9ayhcImF4aXNcIixlLHQsbikscz1rKFwibnVtT3JTaXplU3BsaXRzXCIsZSx0LG4pLGk9ayhcInhcIixlLHQsbik7cmV0dXJuIGEuc3BsaXQoaSxzLHIpfWNhc2VcIlNjYXR0ZXJOZFwiOntsZXQgcj1rKFwiaW5kaWNlc1wiLGUsdCxuKSxzPWsoXCJ2YWx1ZXNcIixlLHQsbiksaT1rKFwic2hhcGVcIixlLHQsbik7cmV0dXJuW2Euc2NhdHRlck5EKHIscyxpKV19Y2FzZVwiR2F0aGVyTmRcIjp7bGV0IHI9ayhcInhcIixlLHQsbikscz1rKFwiaW5kaWNlc1wiLGUsdCxuKTtyZXR1cm5bYS5nYXRoZXJORChyLHMpXX1jYXNlXCJTcGFyc2VUb0RlbnNlXCI6e2xldCByPWsoXCJzcGFyc2VJbmRpY2VzXCIsZSx0LG4pLHM9ayhcIm91dHB1dFNoYXBlXCIsZSx0LG4pLGk9ayhcInNwYXJzZVZhbHVlc1wiLGUsdCxuKSxvPWsoXCJkZWZhdWx0VmFsdWVcIixlLHQsbik7cmV0dXJuW2Euc3BhcnNlVG9EZW5zZShyLGkscyxpLmR0eXBlPT09by5kdHlwZT9vOmEuY2FzdChvLGkuZHR5cGUpKV19Y2FzZVwiVGVuc29yU2NhdHRlclVwZGF0ZVwiOntsZXQgcj1rKFwiaW5kaWNlc1wiLGUsdCxuKSxzPWsoXCJ2YWx1ZXNcIixlLHQsbiksaT1rKFwidGVuc29yXCIsZSx0LG4pO3JldHVyblthLnRlbnNvclNjYXR0ZXJVcGRhdGUoaSxyLHMpXX1kZWZhdWx0OnRocm93IFR5cGVFcnJvcihgTm9kZSB0eXBlICR7ZS5vcH0gaXMgbm90IGltcGxlbWVudGVkYCl9fSxzNT0oZSx0LG4sYT1vbik9Pntzd2l0Y2goZS5vcCl7Y2FzZVwiU3BhcnNlRmlsbEVtcHR5Um93c1wiOntsZXR7b3V0cHV0SW5kaWNlczpyLG91dHB1dFZhbHVlczpzLGVtcHR5Um93SW5kaWNhdG9yOmkscmV2ZXJzZUluZGV4TWFwOm99PWEuc3BhcnNlLnNwYXJzZUZpbGxFbXB0eVJvd3MoayhcImluZGljZXNcIixlLHQsbiksayhcInZhbHVlc1wiLGUsdCxuKSxrKFwiZGVuc2VTaGFwZVwiLGUsdCxuKSxrKFwiZGVmYXVsdFZhbHVlXCIsZSx0LG4pKTtyZXR1cm5bcixzLGksb119Y2FzZVwiU3BhcnNlUmVzaGFwZVwiOntsZXR7b3V0cHV0SW5kaWNlczpyLG91dHB1dFNoYXBlOnN9PWEuc3BhcnNlLnNwYXJzZVJlc2hhcGUoayhcImlucHV0SW5kaWNlc1wiLGUsdCxuKSxrKFwiaW5wdXRTaGFwZVwiLGUsdCxuKSxrKFwibmV3U2hhcGVcIixlLHQsbikpO3JldHVybltyLHNdfWNhc2VcIlNwYXJzZVNlZ21lbnRNZWFuXCI6cmV0dXJuW2Euc3BhcnNlLnNwYXJzZVNlZ21lbnRNZWFuKGsoXCJkYXRhXCIsZSx0LG4pLGsoXCJpbmRpY2VzXCIsZSx0LG4pLGsoXCJzZWdtZW50SWRzXCIsZSx0LG4pKV07Y2FzZVwiU3BhcnNlU2VnbWVudFN1bVwiOnJldHVyblthLnNwYXJzZS5zcGFyc2VTZWdtZW50U3VtKGsoXCJkYXRhXCIsZSx0LG4pLGsoXCJpbmRpY2VzXCIsZSx0LG4pLGsoXCJzZWdtZW50SWRzXCIsZSx0LG4pKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoYE5vZGUgdHlwZSAke2Uub3B9IGlzIG5vdCBpbXBsZW1lbnRlZGApfX0saTU9KGUsdCxuLGE9b24pPT57c3dpdGNoKGUub3Ape2Nhc2VcIkZGVFwiOnJldHVyblthLmZmdChrKFwieFwiLGUsdCxuKSldO2Nhc2VcIklGRlRcIjpyZXR1cm5bYS5pZmZ0KGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiUkZGVFwiOnJldHVyblthLnJmZnQoayhcInhcIixlLHQsbikpXTtjYXNlXCJJUkZGVFwiOnJldHVyblthLmlyZmZ0KGsoXCJ4XCIsZSx0LG4pKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoYE5vZGUgdHlwZSAke2Uub3B9IGlzIG5vdCBpbXBsZW1lbnRlZGApfX0sbzU9KGUsdCxuLGE9b24pPT57c3dpdGNoKGUub3Ape2Nhc2VcIlN0YXRpY1JlZ2V4UmVwbGFjZVwiOnJldHVyblthLnN0cmluZy5zdGF0aWNSZWdleFJlcGxhY2UoayhcImlucHV0XCIsZSx0LG4pLGsoXCJwYXR0ZXJuXCIsZSx0LG4pLGsoXCJyZXdyaXRlXCIsZSx0LG4pLGsoXCJyZXBsYWNlR2xvYmFsXCIsZSx0LG4pKV07Y2FzZVwiU3RyaW5nTkdyYW1zXCI6e2xldHtuR3JhbXM6cixuR3JhbXNTcGxpdHM6c309YS5zdHJpbmcuc3RyaW5nTkdyYW1zKGsoXCJkYXRhXCIsZSx0LG4pLGsoXCJkYXRhU3BsaXRzXCIsZSx0LG4pLGsoXCJzZXBhcmF0b3JcIixlLHQsbiksayhcIm5HcmFtV2lkdGhzXCIsZSx0LG4pLGsoXCJsZWZ0UGFkXCIsZSx0LG4pLGsoXCJyaWdodFBhZFwiLGUsdCxuKSxrKFwicGFkV2lkdGhcIixlLHQsbiksayhcInByZXNlcnZlU2hvcnRTZXF1ZW5jZXNcIixlLHQsbikpO3JldHVybltyLHNdfWNhc2VcIlN0cmluZ1NwbGl0XCI6e2xldHtpbmRpY2VzOnIsdmFsdWVzOnMsc2hhcGU6aX09YS5zdHJpbmcuc3RyaW5nU3BsaXQoayhcImlucHV0XCIsZSx0LG4pLGsoXCJkZWxpbWl0ZXJcIixlLHQsbiksayhcInNraXBFbXB0eVwiLGUsdCxuKSk7cmV0dXJuW3IscyxpXX1jYXNlXCJTdHJpbmdUb0hhc2hCdWNrZXRGYXN0XCI6cmV0dXJuW2Euc3RyaW5nLnN0cmluZ1RvSGFzaEJ1Y2tldEZhc3QoayhcImlucHV0XCIsZSx0LG4pLGsoXCJudW1CdWNrZXRzXCIsZSx0LG4pKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoYE5vZGUgdHlwZSAke2Uub3B9IGlzIG5vdCBpbXBsZW1lbnRlZGApfX0sbDU9KGUsdCxuLGE9b24pPT57c3dpdGNoKGUub3Ape2Nhc2VcIkNhc3RcIjpyZXR1cm5bYS5jYXN0KGsoXCJ4XCIsZSx0LG4pLGsoXCJkdHlwZVwiLGUsdCxuKSldO2Nhc2VcIkV4cGFuZERpbXNcIjp7bGV0IHI9ayhcImF4aXNcIixlLHQsbik7cmV0dXJuW2EuZXhwYW5kRGltcyhrKFwieFwiLGUsdCxuKSxyKV19Y2FzZVwiU3F1ZWV6ZVwiOntsZXQgcj1rKFwiYXhpc1wiLGUsdCxuKTtyZXR1cm5bYS5zcXVlZXplKGsoXCJ4XCIsZSx0LG4pLHIpXX1jYXNlXCJSZXNoYXBlXCI6cmV0dXJuW2EucmVzaGFwZShrKFwieFwiLGUsdCxuKSxrKFwic2hhcGVcIixlLHQsbikpXTtjYXNlXCJFbnN1cmVTaGFwZVwiOnJldHVyblthLmVuc3VyZVNoYXBlKGsoXCJ4XCIsZSx0LG4pLGsoXCJzaGFwZVwiLGUsdCxuKSldO2Nhc2VcIk1pcnJvclBhZFwiOnJldHVyblthLm1pcnJvclBhZChrKFwieFwiLGUsdCxuKSxrKFwicGFkZGluZ1wiLGUsdCxuKSxrKFwibW9kZVwiLGUsdCxuKSldO2Nhc2VcIlBhZFYyXCI6Y2FzZVwiUGFkXCI6cmV0dXJuW2EucGFkKGsoXCJ4XCIsZSx0LG4pLGsoXCJwYWRkaW5nXCIsZSx0LG4pLGsoXCJjb25zdGFudFZhbHVlXCIsZSx0LG4pKV07Y2FzZVwiU3BhY2VUb0JhdGNoTkRcIjp7bGV0IHI9ayhcImJsb2NrU2hhcGVcIixlLHQsbikscz1rKFwicGFkZGluZ3NcIixlLHQsbik7cmV0dXJuW2Euc3BhY2VUb0JhdGNoTkQoayhcInhcIixlLHQsbikscixzKV19Y2FzZVwiQmF0Y2hUb1NwYWNlTkRcIjp7bGV0IHI9ayhcImJsb2NrU2hhcGVcIixlLHQsbikscz1rKFwiY3JvcHNcIixlLHQsbik7cmV0dXJuW2EuYmF0Y2hUb1NwYWNlTkQoayhcInhcIixlLHQsbikscixzKV19Y2FzZVwiRGVwdGhUb1NwYWNlXCI6e2xldCByPWsoXCJibG9ja1NpemVcIixlLHQsbikscz1rKFwiZGF0YUZvcm1hdFwiLGUsdCxuKS50b1VwcGVyQ2FzZSgpO3JldHVyblthLmRlcHRoVG9TcGFjZShrKFwieFwiLGUsdCxuKSxyLHMpXX1jYXNlXCJCcm9hZGNhc3RUb1wiOnJldHVyblthLmJyb2FkY2FzdFRvKGsoXCJ4XCIsZSx0LG4pLGsoXCJzaGFwZVwiLGUsdCxuKSldO2Nhc2VcIkJyb2FkY2FzdEFyZ3NcIjpyZXR1cm5bYS5icm9hZGNhc3RBcmdzKGsoXCJzMFwiLGUsdCxuKSxrKFwiczFcIixlLHQsbikpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihgTm9kZSB0eXBlICR7ZS5vcH0gaXMgbm90IGltcGxlbWVudGVkYCl9fTtmdW5jdGlvbiBVSShlLHQsbixhLHI9Tyl7bGV0IHM9KChpLG8sbCk9Pntzd2l0Y2goaS5jYXRlZ29yeSl7Y2FzZVwiYXJpdGhtZXRpY1wiOnJldHVybiByKCgpPT5QcShpLG8sbCkpO2Nhc2VcImJhc2ljX21hdGhcIjpyZXR1cm4gcigoKT0+THEoaSxvLGwpKTtjYXNlXCJjb250cm9sXCI6cmV0dXJuIEdxKGksbyxsKTtjYXNlXCJjb252b2x1dGlvblwiOnJldHVybiByKCgpPT5IcShpLG8sbCkpO2Nhc2VcImNyZWF0aW9uXCI6cmV0dXJuIHIoKCk9PmpxKGksbyxsKSk7Y2FzZVwiZHluYW1pY1wiOnJldHVybiBxcShpLG8sbCk7Y2FzZVwiZXZhbHVhdGlvblwiOnJldHVybiByKCgpPT5LcShpLG8sbCkpO2Nhc2VcImltYWdlXCI6cmV0dXJuIHIoKCk9PkpxKGksbyxsKSk7Y2FzZVwiZ3JhcGhcIjpyZXR1cm4gcigoKT0+WHEoaSxvLGwpKTtjYXNlXCJsb2dpY2FsXCI6cmV0dXJuIHIoKCk9PlFxKGksbyxsKSk7Y2FzZVwibWF0cmljZXNcIjpyZXR1cm4gcigoKT0+ZTUoaSxvLGwpKTtjYXNlXCJub3JtYWxpemF0aW9uXCI6cmV0dXJuIHIoKCk9PnQ1KGksbyxsKSk7Y2FzZVwicmFnZ2VkXCI6cmV0dXJuIHIoKCk9Pm41KGksbyxsKSk7Y2FzZVwicmVkdWN0aW9uXCI6cmV0dXJuIHIoKCk9PmE1KGksbyxsKSk7Y2FzZVwic2xpY2Vfam9pblwiOnJldHVybiByKCgpPT5yNShpLG8sbCkpO2Nhc2VcInNwYXJzZVwiOnJldHVybiByKCgpPT5zNShpLG8sbCkpO2Nhc2VcInNwZWN0cmFsXCI6cmV0dXJuIHIoKCk9Pmk1KGksbyxsKSk7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIHIoKCk9Pm81KGksbyxsKSk7Y2FzZVwidHJhbnNmb3JtYXRpb25cIjpyZXR1cm4gcigoKT0+bDUoaSxvLGwpKTtjYXNlXCJoYXNoX3RhYmxlXCI6cmV0dXJuIFpxKGksbyxsLGEpO2Nhc2VcImN1c3RvbVwiOmxldCB1PXpDKGkub3ApO2lmKHUmJnUuY3VzdG9tRXhlY3V0b3IpcmV0dXJuIHUuY3VzdG9tRXhlY3V0b3IobmV3IE9xKGksbyxsKSk7dGhyb3cgVHlwZUVycm9yKGBDdXN0b20gb3AgJHtpLm9wfSBpcyBub3QgcmVnaXN0ZXJlZC5gKTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihgVW5rbm93biBvcCAnJHtpLm9wfScuIEZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGZqcy9pc3N1ZXMgc28gd2UgY2FuIGFkZCBpdCwgb3IgcmVnaXN0ZXIgYSBjdXN0b20gZXhlY3V0aW9uIHdpdGggdGYucmVnaXN0ZXJPcCgpYCl9fSkoZSx0LG4pO3JldHVybiB3LmlzUHJvbWlzZShzKT9zLnRoZW4oaT0+W10uY29uY2F0KGkpKTpbXS5jb25jYXQocyl9dmFyIEdJPWNsYXNze2NvbnN0cnVjdG9yKGU9e30sdD17fSxuPXt9LGE9e30scil7dGhpcy53ZWlnaHRNYXA9ZSx0aGlzLnRlbnNvckFycmF5TWFwPXQsdGhpcy50ZW5zb3JMaXN0TWFwPW4sdGhpcy5mdW5jdGlvbk1hcD1hLHRoaXMucGFyc2VOb2RlTmFtZUNhY2hlPXIsdGhpcy5yb290Q29udGV4dD17aWQ6MCxmcmFtZU5hbWU6XCJcIixpdGVyYXRpb25JZDowfSx0aGlzLmNvbnRleHRzPVt0aGlzLnJvb3RDb250ZXh0XSx0aGlzLmxhc3RJZD0wLHRoaXMuZ2VuZXJhdGVDdXJyZW50Q29udGV4dElkcygpfW5ld0ZyYW1lKGUsdCl7cmV0dXJue2lkOmUsZnJhbWVOYW1lOnQsaXRlcmF0aW9uSWQ6MH19c2V0IGN1cnJlbnRDb250ZXh0KGUpe3RoaXMuY29udGV4dHMhPT1lJiYodGhpcy5jb250ZXh0cz1lLHRoaXMuZ2VuZXJhdGVDdXJyZW50Q29udGV4dElkcygpKX1nZXQgY3VycmVudENvbnRleHQoKXtyZXR1cm4gdGhpcy5jb250ZXh0c31nZXQgY3VycmVudENvbnRleHRJZCgpe3JldHVybiB0aGlzLl9jdXJyZW50Q29udGV4dElkc1swXX1nZXQgY3VycmVudENvbnRleHRJZHMoKXtyZXR1cm4gdGhpcy5fY3VycmVudENvbnRleHRJZHN9Z2VuZXJhdGVDdXJyZW50Q29udGV4dElkcygpe2xldCBlPVtdO2ZvcihsZXQgdD0wO3Q8dGhpcy5jb250ZXh0cy5sZW5ndGgtMTt0Kyspe2xldCBuPXRoaXMuY29udGV4dHMuc2xpY2UoMCx0aGlzLmNvbnRleHRzLmxlbmd0aC10KTtlLnB1c2godGhpcy5jb250ZXh0SWRmb3JDb250ZXh0cyhuKSl9ZS5wdXNoKFwiXCIpLHRoaXMuX2N1cnJlbnRDb250ZXh0SWRzPWV9Y29udGV4dElkZm9yQ29udGV4dHMoZSl7cmV0dXJuIGU/ZS5tYXAodD0+dC5pZD09PTAmJnQuaXRlcmF0aW9uSWQ9PT0wP1wiXCI6YCR7dC5mcmFtZU5hbWV9LSR7dC5pdGVyYXRpb25JZH1gKS5qb2luKFwiL1wiKTpcIlwifWVudGVyRnJhbWUoZSl7dGhpcy5jb250ZXh0cyYmKHRoaXMubGFzdElkKyssdGhpcy5jb250ZXh0cz10aGlzLmNvbnRleHRzLnNsaWNlKCksdGhpcy5jb250ZXh0cy5wdXNoKHRoaXMubmV3RnJhbWUodGhpcy5sYXN0SWQsZSkpLHRoaXMuX2N1cnJlbnRDb250ZXh0SWRzLnVuc2hpZnQodGhpcy5jb250ZXh0SWRmb3JDb250ZXh0cyh0aGlzLmNvbnRleHRzKSkpfWV4aXRGcmFtZSgpe2lmKHRoaXMuY29udGV4dHMmJnRoaXMuY29udGV4dHMubGVuZ3RoPjEpdGhpcy5jb250ZXh0cz10aGlzLmNvbnRleHRzLnNsaWNlKCksdGhpcy5jb250ZXh0cy5zcGxpY2UoLTEpLHRoaXMuY3VycmVudENvbnRleHRJZHMuc2hpZnQoKTtlbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBleGl0IGZyYW1lLCB0aGUgY29udGV4dCBpcyBlbXB0eVwiKX1uZXh0SXRlcmF0aW9uKCl7aWYodGhpcy5jb250ZXh0cyYmdGhpcy5jb250ZXh0cy5sZW5ndGg+MCl7dGhpcy5jb250ZXh0cz10aGlzLmNvbnRleHRzLnNsaWNlKCksdGhpcy5sYXN0SWQrKztsZXQgZT1PYmplY3QuYXNzaWduKHt9LHRoaXMuY29udGV4dHNbdGhpcy5jb250ZXh0cy5sZW5ndGgtMV0pO2UuaXRlcmF0aW9uSWQrPTEsZS5pZD10aGlzLmxhc3RJZCx0aGlzLmNvbnRleHRzLnNwbGljZSgtMSwxLGUpLHRoaXMuX2N1cnJlbnRDb250ZXh0SWRzLnNwbGljZSgwLDEsdGhpcy5jb250ZXh0SWRmb3JDb250ZXh0cyh0aGlzLmNvbnRleHRzKSl9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaW5jcmVhc2UgZnJhbWUgaXRlcmF0aW9uLCB0aGUgY29udGV4dCBpcyBlbXB0eVwiKX1nZXRXZWlnaHQoZSl7cmV0dXJuIHRoaXMud2VpZ2h0TWFwW2VdfWFkZFRlbnNvckFycmF5KGUpe3RoaXMudGVuc29yQXJyYXlNYXBbZS5pZF09ZX1nZXRUZW5zb3JBcnJheShlKXtyZXR1cm4gdGhpcy50ZW5zb3JBcnJheU1hcFtlXX1hZGRUZW5zb3JMaXN0KGUpe3RoaXMudGVuc29yTGlzdE1hcFtlLmlkXT1lfWdldFRlbnNvckxpc3QoZSl7cmV0dXJuIHRoaXMudGVuc29yTGlzdE1hcFtlXX1kaXNwb3NlKGUpe2ZvcihsZXQgdCBpbiB0aGlzLnRlbnNvckFycmF5TWFwKXRoaXMudGVuc29yQXJyYXlNYXBbdF0uY2xlYXJBbmRDbG9zZShlKTtmb3IobGV0IHQgaW4gdGhpcy50ZW5zb3JMaXN0TWFwKXRoaXMudGVuc29yTGlzdE1hcFt0XS5jbGVhckFuZENsb3NlKGUpfX07ZnVuY3Rpb24gSEkoZSx0LG4sYSl7bGV0IHI9bmV3IFNldCxzPVtdLGk9bnVsbCxvPW51bGwsbD1uZXcgU2V0LHU9bmV3IFNldChPYmplY3Qua2V5cyhlKS5tYXAoYz0+WG4oYylbMF0pKTthPWF8fFtdO2xldCBwPW5ldyBTZXQoYS5tYXAoYz0+WG4oYy5uYW1lKVswXSkpLGQ9Wy4uLnRdO2Zvcig7ZC5sZW5ndGg+MDspe2xldCBjPWQucG9wKCk7aWYoKFFzKGMpfHxnNShjKXx8YjUoYykpJiZpPT1udWxsJiYoaT1jLG89aS5jaGlsZHJlbi5tYXAoaD0+aC5uYW1lKS5maWx0ZXIoaD0+ci5oYXMoaCkpKSxyLmFkZChjLm5hbWUpLG5bYy5uYW1lXT09bnVsbCYmIXUuaGFzKGMubmFtZSkmJiFwLmhhcyhjLm5hbWUpKXtpZihjLmlucHV0cy5sZW5ndGg9PT0wKXtzLnB1c2goYy5uYW1lKTtjb250aW51ZX1jLmlucHV0cy5mb3JFYWNoKGg9PntsLmhhcyhoLm5hbWUpfHwobC5hZGQoaC5uYW1lKSxkLnB1c2goaCkpfSl9fXJldHVybntpbnB1dHM6ZSxvdXRwdXRzOnQsdXNlZE5vZGVzOnIsbWlzc2luZ0lucHV0czpzLGR5bmFtaWNOb2RlOmksc3luY0lucHV0czpvfX1mdW5jdGlvbiB1NShlLHQpe2xldHt1c2VkTm9kZXM6bixpbnB1dHM6YX09dCxyPU9iamVjdC5rZXlzKGEpLm1hcChnPT5YbihnKVswXSkubWFwKGc9PmUubm9kZXNbZ10pLHM9ZS5pbml0Tm9kZXN8fFtdLGk9Zz0+bi5oYXModHlwZW9mIGc9PVwic3RyaW5nXCI/ZzpnLm5hbWUpO2Z1bmN0aW9uIG8oZyl7cmV0dXJuWy4uLm5ldyBNYXAoZy5tYXAoYj0+W2IubmFtZSxiXSkpLnZhbHVlcygpXX1sZXQgbD1vKFsuLi5yLC4uLmUud2VpZ2h0cywuLi5zXSkuZmlsdGVyKGkpLHU9byhbLi4ubCwuLi5PYmplY3QudmFsdWVzKGUubm9kZXMpXSkuZmlsdGVyKGkpLHA9bmV3IE1hcCh1Lm1hcChnPT5bZy5uYW1lLGddKSksZD17fTtmb3IobGV0IGcgb2YgdSl7ZFtnLm5hbWVdPWRbZy5uYW1lXXx8MDtmb3IobGV0IGIgb2YgZy5jaGlsZHJlbilpKGIpfHwoZFtiLm5hbWVdPU51bWJlci5QT1NJVElWRV9JTkZJTklUWSksZFtiLm5hbWVdPShkW2IubmFtZV18fDApKzF9bGV0IGM9T2JqZWN0LmVudHJpZXMoZCkuZmlsdGVyKChbLGddKT0+Zz09PTApLm1hcCgoW2ddKT0+ZyksaD1bLi4uY107Zm9yKDtjLmxlbmd0aD4wOyl7bGV0IGc9Yy5wb3AoKSxiPXAuZ2V0KGcpO2ZvcihsZXQgeSBvZiBiLmNoaWxkcmVuLmZpbHRlcihpKSktLWRbeS5uYW1lXT09PTAmJihoLnB1c2goeS5uYW1lKSxjLnB1c2goeS5uYW1lKSl9bGV0IG09aC5tYXAoZz0+cC5nZXQoZykpLGY9cDUobSxsKTtyZXR1cm4gYzUoZixsKSxmfWZ1bmN0aW9uIHA1KGUsdCl7bGV0IG49bmV3IE1hcChlLm1hcChzPT5bcy5uYW1lLHNdKSksYT10Lm1hcChzPT5zLm5hbWUpLHI9bmV3IFNldChhKTtmb3IoO2EubGVuZ3RoPjA7KXtsZXQgcz1hLnBvcCgpLGk9bi5nZXQocyk7Zm9yKGxldCBvIG9mIGkuY2hpbGRyZW4pIW4uaGFzKG8ubmFtZSl8fHIuaGFzKG8ubmFtZSl8fChyLmFkZChvLm5hbWUpLGEucHVzaChvLm5hbWUpKX1yZXR1cm4gZS5maWx0ZXIocz0+ci5oYXMocy5uYW1lKSl9dmFyIFRoPWNsYXNzIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IoZSl7c3VwZXIoYE5vZGVzRXhlY3V0aW9uT3JkZXJFcnJvcjogJHtlfWApfX07ZnVuY3Rpb24gYzUoZSx0KXtsZXQgbj1uZXcgTWFwKGUubWFwKChvLGwpPT5bby5uYW1lLGxdKSksYT1uZXcgU2V0KHQubWFwKG89Pm8ubmFtZSkpLHI9bz0+YS5oYXModHlwZW9mIG89PVwic3RyaW5nXCI/bzpvLm5hbWUpLHM9bmV3IFNldChlLm1hcChvPT5vLm5hbWUpKSxpPW89PnMuaGFzKHR5cGVvZiBvPT1cInN0cmluZ1wiP286by5uYW1lKTtmb3IobGV0IG8gb2YgZSl7Zm9yKGxldCBsIG9mIG8uY2hpbGRyZW4uZmlsdGVyKGkpKXtpZighbi5oYXMobC5uYW1lKSl0aHJvdyBuZXcgVGgoYENoaWxkICR7bC5uYW1lfSBvZiBub2RlICR7by5uYW1lfSBpcyB1bnJlYWNoYWJsZS5gKTtpZihuLmdldChvLm5hbWUpPm4uZ2V0KGwubmFtZSkpdGhyb3cgbmV3IFRoKGBOb2RlICR7by5uYW1lfSBpcyBzY2hlZHVsZWQgdG8gcnVuIGFmdGVyIGl0cyBjaGlsZCAke2wubmFtZX0uYCl9aWYoIXIobykpZm9yKGxldCBsIG9mIG8uaW5wdXRzKXtpZighbi5oYXMobC5uYW1lKSl0aHJvdyBuZXcgVGgoYElucHV0ICR7bC5uYW1lfSBvZiBub2RlICR7by5uYW1lfSBpcyB1bnJlYWNoYWJsZS5gKTtpZihuLmdldChsLm5hbWUpPm4uZ2V0KG8ubmFtZSkpdGhyb3cgbmV3IFRoKGBOb2RlICR7by5uYW1lfSBpcyBzY2hlZHVsZWQgdG8gcnVuIGJlZm9yZSBpdHMgaW5wdXQgJHtsLm5hbWV9LmApfX19ZnVuY3Rpb24gZDUoZSl7bGV0IHQ9bmV3IE1hcChlLm1hcCgobyxsKT0+W28ubmFtZSxsXSkpLG49TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsYT1lLm1hcCgobyxsKT0+UXMobyk/bjpsKSxyPW89PntsZXQgbD1hW3QuZ2V0KG8ubmFtZSldO3JldHVybiBsPT1udWxsPy0xOmx9LHM9ZS5tYXAoKG8sbCk9Pm8uY2hpbGRyZW4ubWFwKHIpLnJlZHVjZSgodSxwKT0+TWF0aC5tYXgodSxwKSxhW2xdKSksaT1uZXcgTWFwO2ZvcihsZXQgbz0wO288ZS5sZW5ndGg7KytvKXtsZXQgbD1zW29dO2lmKGw9PT1uKWNvbnRpbnVlO2xldCB1PWVbb10scD1lW2xdO2kuaGFzKHAubmFtZSl8fGkuc2V0KHAubmFtZSxbXSksaS5nZXQocC5uYW1lKS5wdXNoKHUpfXJldHVybiBpfXZhciBoNT1uZXcgU2V0KFtcIlN3aXRjaFwiLFwiTWVyZ2VcIixcIkVudGVyXCIsXCJFeGl0XCIsXCJOZXh0SXRlcmF0aW9uXCIsXCJTdGF0ZWxlc3NJZlwiLFwiU3RhdGVsZXNzV2hpbGVcIixcImlmXCIsXCJXaGlsZVwiXSksbTU9bmV3IFNldChbXCJOb25NYXhTdXBwcmVzc2lvblYyXCIsXCJOb25NYXhTdXBwcmVzc2lvblYzXCIsXCJOb25NYXhTdXBwcmVzc2lvblY1XCIsXCJXaGVyZVwiXSksZjU9bmV3IFNldChbXCJIYXNoVGFibGVcIixcIkhhc2hUYWJsZVYyXCIsXCJMb29rdXBUYWJsZUltcG9ydFwiLFwiTG9va3VwVGFibGVJbXBvcnRWMlwiLFwiTG9va3VwVGFibGVGaW5kXCIsXCJMb29rdXBUYWJsZUZpbmRWMlwiLFwiTG9va3VwVGFibGVTaXplXCIsXCJMb29rdXBUYWJsZVNpemVWMlwiXSk7ZnVuY3Rpb24gUXMoZSl7cmV0dXJuIGg1LmhhcyhlLm9wKX1mdW5jdGlvbiBnNShlKXtyZXR1cm4gbTUuaGFzKGUub3ApfWZ1bmN0aW9uIGI1KGUpe3JldHVybiBmNS5oYXMoZS5vcCl9dmFyIGpJPWNsYXNzIG9Fe2dldCB3ZWlnaHRJZHMoKXtyZXR1cm4gdGhpcy5wYXJlbnQ/dGhpcy5wYXJlbnQud2VpZ2h0SWRzOnRoaXMuX3dlaWdodElkc31nZXQgZnVuY3Rpb25FeGVjdXRvck1hcCgpe3JldHVybiB0aGlzLnBhcmVudD90aGlzLnBhcmVudC5mdW5jdGlvbkV4ZWN1dG9yTWFwOnRoaXMuX2Z1bmN0aW9uRXhlY3V0b3JNYXB9Z2V0IHdlaWdodE1hcCgpe3JldHVybiB0aGlzLnBhcmVudD90aGlzLnBhcmVudC53ZWlnaHRNYXA6dGhpcy5fd2VpZ2h0TWFwfXNldCB3ZWlnaHRNYXAodCl7bGV0IG49T2JqZWN0LmtleXModCkubWFwKGE9PnRbYV0ubWFwKHI9PnIuaWQpKTt0aGlzLl93ZWlnaHRJZHM9W10uY29uY2F0KC4uLm4pLHRoaXMuX3dlaWdodE1hcD10fXNldCByZXNvdXJjZU1hbmFnZXIodCl7dGhpcy5fcmVzb3VyY2VNYW5hZ2VyPXR9Z2V0IGlucHV0cygpe3JldHVybiB0aGlzLl9pbnB1dHMubWFwKHQ9Pih7bmFtZTp0Lm5hbWUsc2hhcGU6dC5hdHRyUGFyYW1zLnNoYXBlP3QuYXR0clBhcmFtcy5zaGFwZS52YWx1ZTp2b2lkIDAsZHR5cGU6dC5hdHRyUGFyYW1zLmR0eXBlP3QuYXR0clBhcmFtcy5kdHlwZS52YWx1ZTp2b2lkIDB9KSl9Z2V0IG91dHB1dHMoKXtyZXR1cm4gdGhpcy5fb3V0cHV0cy5tYXAodD0+KHtuYW1lOnQubmFtZSxzaGFwZTp0LmF0dHJQYXJhbXMuc2hhcGU/dC5hdHRyUGFyYW1zLnNoYXBlLnZhbHVlOnZvaWQgMCxkdHlwZTp0LmF0dHJQYXJhbXMuZHR5cGU/dC5hdHRyUGFyYW1zLmR0eXBlLnZhbHVlOnZvaWQgMH0pKX1nZXQgaW5wdXROb2Rlcygpe3JldHVybiB0aGlzLl9pbnB1dHMubWFwKHQ9PnQuc2lnbmF0dXJlS2V5fHx0Lm5hbWUpfWdldCBvdXRwdXROb2Rlcygpe3JldHVybiB0aGlzLl9vdXRwdXRzLm1hcCh0PT57bGV0IG49dC5zaWduYXR1cmVLZXl8fHQubmFtZTtyZXR1cm4gdC5kZWZhdWx0T3V0cHV0P2Ake259OiR7dC5kZWZhdWx0T3V0cHV0fWA6bn0pfWdldCBmdW5jdGlvbnMoKXtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5fZnVuY3Rpb25zKS5yZWR1Y2UoKHQsbik9Pih0W25dPXRoaXMuX2Z1bmN0aW9uc1tuXS5zaWduYXR1cmUsdCkse30pfWNvbnN0cnVjdG9yKHQsbil7dGhpcy5ncmFwaD10LHRoaXMucGFyZW50PW4sdGhpcy5jb21waWxlZE1hcD1uZXcgTWFwLHRoaXMucGFyc2VOb2RlTmFtZUNhY2hlPW5ldyBNYXAsdGhpcy5fd2VpZ2h0TWFwPXt9LHRoaXMuU0VQQVJBVE9SPVwiLFwiLHRoaXMuX2Z1bmN0aW9ucz17fSx0aGlzLl9mdW5jdGlvbkV4ZWN1dG9yTWFwPXt9LHRoaXMua2VlcEludGVybWVkaWF0ZVRlbnNvcnM9ITEsdGhpcy5fb3V0cHV0cz10Lm91dHB1dHMsdGhpcy5faW5wdXRzPXQuaW5wdXRzLHRoaXMuX2luaXROb2Rlcz10LmluaXROb2Rlcyx0aGlzLl9zaWduYXR1cmU9dC5zaWduYXR1cmUsdGhpcy5fZnVuY3Rpb25zPXQuZnVuY3Rpb25zLHQuZnVuY3Rpb25zIT1udWxsJiZPYmplY3Qua2V5cyh0LmZ1bmN0aW9ucykuZm9yRWFjaChhPT57dGhpcy5fZnVuY3Rpb25FeGVjdXRvck1hcFthXT1uZXcgb0UodC5mdW5jdGlvbnNbYV0sdGhpcyl9KX1nZXRDb21waWxhdGlvbktleSh0LG4pe2xldCBhPXQubWFwKHM9PnMubmFtZSkuc29ydCgpLHI9bi5tYXAocz0+cy5uYW1lKS5zb3J0KCk7cmV0dXJuIGEuam9pbih0aGlzLlNFUEFSQVRPUikrXCItLVwiK3Iuam9pbih0aGlzLlNFUEFSQVRPUil9Y29tcGlsZSh0LG4pe2xldCBhPUhJKHQsbix0aGlzLndlaWdodE1hcCx0aGlzLl9pbml0Tm9kZXMpLHttaXNzaW5nSW5wdXRzOnIsZHluYW1pY05vZGU6cyxzeW5jSW5wdXRzOml9PWE7aWYocyE9bnVsbCl0aHJvdyBuZXcgRXJyb3IoYFRoaXMgZXhlY3V0aW9uIGNvbnRhaW5zIHRoZSBub2RlICcke3MubmFtZX0nLCB3aGljaCBoYXMgdGhlIGR5bmFtaWMgb3AgJyR7cy5vcH0nLiBQbGVhc2UgdXNlIG1vZGVsLmV4ZWN1dGVBc3luYygpIGluc3RlYWQuIEFsdGVybmF0aXZlbHksIHRvIGF2b2lkIHRoZSBkeW5hbWljIG9wcywgc3BlY2lmeSB0aGUgaW5wdXRzIFske2l9XWApO2lmKHIubGVuZ3RoPjApe2xldCB1PW4ubWFwKGQ9PmQubmFtZSkscD1PYmplY3Qua2V5cyh0KTt0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb21wdXRlIHRoZSBvdXRwdXRzIFske3V9XSBmcm9tIHRoZSBwcm92aWRlZCBpbnB1dHMgWyR7cH1dLiBNaXNzaW5nIHRoZSBmb2xsb3dpbmcgaW5wdXRzOiBbJHtyfV1gKX1sZXQgbz11NSh0aGlzLmdyYXBoLGEpLGw9ZDUobyk7cmV0dXJue29yZGVyZWROb2RlczpvLG5vZGVMaXZlVW50aWxNYXA6bH19Y2xvbmVBbmRLZWVwVGVuc29yKHQpe2lmKHQ9PW51bGwpcmV0dXJuIG51bGw7bGV0IG49dC5jbG9uZSgpO3JldHVybiBIdChuKSxufWNsb25lVGVuc29yTGlzdCh0KXtyZXR1cm4gdD90Lm1hcChuPT50aGlzLmNsb25lQW5kS2VlcFRlbnNvcihuKSk6bnVsbH1jbG9uZVRlbnNvck1hcCh0KXtyZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHQpLm1hcCgoW24sYV0pPT5bbix0aGlzLmNsb25lVGVuc29yTGlzdChhKV0pKX1leGVjdXRlKHQsbil7dGhpcy5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ycygpLHQ9dGhpcy5tYXBJbnB1dHModCk7bGV0IGE9T2JqZWN0LmtleXModCkuc29ydCgpO3RoaXMuY2hlY2tJbnB1dHModCksdGhpcy5jaGVja0lucHV0U2hhcGVBbmRUeXBlKHQpLG49dGhpcy5tYXBPdXRwdXRzKG4pLHRoaXMuY2hlY2tPdXRwdXRzKG4pO2xldCByPWEubWFwKGM9PnRoaXMuZ3JhcGgubm9kZXNbWG4oYylbMF1dKSxzPW4ubWFwKGM9PlhuKGMpWzBdKSxpPW5ldyBTZXQocyksbz1zLm1hcChjPT50aGlzLmdyYXBoLm5vZGVzW2NdKTtvLmxlbmd0aD09PTAmJihvPXRoaXMuX291dHB1dHMpO2xldCBsPXRoaXMuZ2V0Q29tcGlsYXRpb25LZXkocixvKSx1PXRoaXMuY29tcGlsZWRNYXAuZ2V0KGwpO3U9PW51bGwmJih1PXRoaXMuY29tcGlsZSh0LG8pLHRoaXMuY29tcGlsZWRNYXAuc2V0KGwsdSkpO3RyeXt0aGlzLmtlZXBJbnRlcm1lZGlhdGVUZW5zb3JzPUcoKS5nZXRCb29sKFwiS0VFUF9JTlRFUk1FRElBVEVfVEVOU09SU1wiKX1jYXRjaChjKXt0aGlzLmtlZXBJbnRlcm1lZGlhdGVUZW5zb3JzPSExLGNvbnNvbGUud2FybihjLm1lc3NhZ2UpfWxldCBwPXt9LGQ9e307cmV0dXJuIE8oKCk9PntsZXQgYz1uZXcgR0kodGhpcy53ZWlnaHRNYXAscCxkLHRoaXMuZnVuY3Rpb25FeGVjdXRvck1hcCx0aGlzLnBhcnNlTm9kZU5hbWVDYWNoZSksaD1PYmplY3QuYXNzaWduKHt9LHRoaXMud2VpZ2h0TWFwKTt0aGlzLmtlZXBJbnRlcm1lZGlhdGVUZW5zb3JzJiYodGhpcy5jbG9uZWRUZW5zb3JzTWFwPXRoaXMuY2xvbmVUZW5zb3JNYXAodGhpcy53ZWlnaHRNYXApKSxPYmplY3Qua2V5cyh0KS5mb3JFYWNoKGI9PntsZXRbeSx4XT1YbihiLGMpLHY9W107dlt4XT10W2JdLGhbeV09dix0aGlzLmtlZXBJbnRlcm1lZGlhdGVUZW5zb3JzJiYodGhpcy5jbG9uZWRUZW5zb3JzTWFwW3ldPXRoaXMuY2xvbmVUZW5zb3JMaXN0KHYpKX0pO2xldCBtPXRoaXMuZ2V0RnJvemVuVGVuc29ySWRzKGgpLHtvcmRlcmVkTm9kZXM6Zixub2RlTGl2ZVVudGlsTWFwOmd9PXU7Zm9yKGxldCBiIG9mIGYpe2lmKGhbYi5uYW1lXSljb250aW51ZTtsZXQgeT1VSShiLGgsYyx0aGlzLl9yZXNvdXJjZU1hbmFnZXIpO2lmKHcuaXNQcm9taXNlKHkpKXRocm93IG5ldyBFcnJvcihgVGhlIGV4ZWN1dGlvbiBvZiB0aGUgb3AgJyR7Yi5vcH0nIHJldHVybmVkIGEgcHJvbWlzZS4gUGxlYXNlIHVzZSBtb2RlbC5leGVjdXRlQXN5bmMoKSBpbnN0ZWFkLmApO2hbYi5uYW1lXT15LHRoaXMua2VlcEludGVybWVkaWF0ZVRlbnNvcnMmJih0aGlzLmNsb25lZFRlbnNvcnNNYXBbYi5uYW1lXT10aGlzLmNsb25lVGVuc29yTGlzdCh5KSksdGhpcy5jaGVja1RlbnNvckZvckRpc3Bvc2FsV2l0aE5vZGVMaXZlVW50aWxJbmZvKGIsaCxjLG0saSxnLmdldChiLm5hbWUpKX1yZXR1cm4gdGhpcy5wYXJlbnQ9PW51bGwmJmMuZGlzcG9zZShtKSxuLm1hcChiPT5wbihiLGgsYykpfSl9Z2V0RnJvemVuVGVuc29ySWRzKHQpe2xldCBuPVtdLmNvbmNhdC5hcHBseShbXSxPYmplY3Qua2V5cyh0KS5tYXAoYT0+dFthXSkubWFwKGE9PmEubWFwKHI9PnIuaWQpKSk7cmV0dXJuIG5ldyBTZXQobil9Y2hlY2tUZW5zb3JGb3JEaXNwb3NhbCh0LG4sYSxyLHMsaSxvKXtpZighKFFzKG4pfHxpLmhhcyh0KSkpe2ZvcihsZXQgbCBvZiBhW3RdKWwhPW51bGwmJihvW2wuaWRdPShvW2wuaWRdfHwwKStuLmNoaWxkcmVuLmxlbmd0aCk7Zm9yKGxldCBsIG9mIG4uaW5wdXRzKXtpZihRcyhsKSljb250aW51ZTtsZXQgdT1MSShsLm5hbWUsYSxyKTtpZih1IT1udWxsKWZvcihsZXQgcCBvZiB1KXtpZighcHx8cC5rZXB0fHxzLmhhcyhwLmlkKSljb250aW51ZTtsZXQgZD1vW3AuaWRdO2Q9PT0xPyhwLmRpc3Bvc2UoKSxkZWxldGUgb1twLmlkXSk6ZCE9bnVsbCYmb1twLmlkXS0tfX19fWNoZWNrVGVuc29yRm9yRGlzcG9zYWxXaXRoTm9kZUxpdmVVbnRpbEluZm8odCxuLGEscixzLGkpe2Z1bmN0aW9uIG8obCl7cmV0dXJuIFFzKGwpfHxzLmhhcyhsLm5hbWUpfWlmKCEoUXModCl8fGk9PW51bGwpKWZvcihsZXQgbCBvZiBpKXtpZihvKGwpKWNvbnRpbnVlO2xldCB1PUxJKGwubmFtZSxuLGEpO2ZvcihsZXQgcCBvZiB1KSFwfHxwLmtlcHR8fHIuaGFzKHAuaWQpfHxwLmRpc3Bvc2UoKX19YXN5bmMgZXhlY3V0ZUFzeW5jKHQsbil7cmV0dXJuIHRoaXMuX2V4ZWN1dGVBc3luYyh0LG4pfWRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JzKCl7dGhpcy5jbG9uZWRUZW5zb3JzTWFwJiYoT2JqZWN0LnZhbHVlcyh0aGlzLmNsb25lZFRlbnNvcnNNYXApLmZvckVhY2godD0+e2ZvcihsZXQgbiBvZiB0KW4mJiFuLmlzRGlzcG9zZWQmJm4uZGlzcG9zZSgpfSksdGhpcy5jbG9uZWRUZW5zb3JzTWFwPW51bGwpfWdldEludGVybWVkaWF0ZVRlbnNvcnMoKXtyZXR1cm4gdGhpcy5jbG9uZWRUZW5zb3JzTWFwfWFzeW5jIF9leGVjdXRlQXN5bmModCxuLGE9ITEscj17fSxzPXt9KXt0aGlzLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JzKCksYXx8KHQ9dGhpcy5tYXBJbnB1dHModCksdGhpcy5jaGVja0lucHV0cyh0KSx0aGlzLmNoZWNrSW5wdXRTaGFwZUFuZFR5cGUodCksbj10aGlzLm1hcE91dHB1dHMobiksdGhpcy5jaGVja091dHB1dHMobikpO3RyeXt0aGlzLmtlZXBJbnRlcm1lZGlhdGVUZW5zb3JzPUcoKS5nZXRCb29sKFwiS0VFUF9JTlRFUk1FRElBVEVfVEVOU09SU1wiKX1jYXRjaChjKXt0aGlzLmtlZXBJbnRlcm1lZGlhdGVUZW5zb3JzPSExLGNvbnNvbGUud2FybihjLm1lc3NhZ2UpfWxldCBpPW5ldyBHSSh0aGlzLndlaWdodE1hcCxyLHMsdGhpcy5mdW5jdGlvbkV4ZWN1dG9yTWFwLHRoaXMucGFyc2VOb2RlTmFtZUNhY2hlKTt0aGlzLmtlZXBJbnRlcm1lZGlhdGVUZW5zb3JzJiYodGhpcy5jbG9uZWRUZW5zb3JzTWFwPXRoaXMuY2xvbmVUZW5zb3JNYXAodGhpcy53ZWlnaHRNYXApKTtsZXQgbz1hd2FpdCB0aGlzLmV4ZWN1dGVXaXRoQ29udHJvbEZsb3codCxpLG4sYSksbD1uLm1hcChjPT5wbihjLG8saSkpLHU9bC5tYXAoYz0+Yy5pZCkscD1PYmplY3Qua2V5cyh0KS5tYXAoYz0+dFtjXS5pZCksZD1uZXcgU2V0KFsuLi51LC4uLnAsLi4udGhpcy53ZWlnaHRJZHNdKTtyZXR1cm4gT2JqZWN0LnZhbHVlcyhvKS5mb3JFYWNoKGM9PntjLmZvckVhY2goaD0+e2gmJiFoLmlzRGlzcG9zZWQmJiFkLmhhcyhoLmlkKSYmaC5kaXNwb3NlKCl9KX0pLHRoaXMucGFyZW50PT1udWxsJiZpLmRpc3Bvc2UoZCksbH1hc3luYyBleGVjdXRlRnVuY3Rpb25Bc3luYyh0LG4sYSl7bGV0IHI9dC5yZWR1Y2UoKHMsaSxvKT0+KHNbdGhpcy5pbnB1dHNbb10ubmFtZV09aSxzKSx7fSk7cmV0dXJuIHRoaXMuX2V4ZWN1dGVBc3luYyhyLHRoaXMub3V0cHV0Tm9kZXMsITAsbixhKX1hc3luYyBleGVjdXRlV2l0aENvbnRyb2xGbG93KHQsbixhLHIpe2xldCBzPU9iamVjdC5rZXlzKHQpLGk9cy5tYXAodj0+dGhpcy5ncmFwaC5ub2Rlc1tYbih2KVswXV0pLG89YS5tYXAodj0+WG4odilbMF0pLGw9bmV3IFNldChvKSx1PW8ubWFwKHY9PnRoaXMuZ3JhcGgubm9kZXNbdl0pO3UubGVuZ3RoPT09MCYmKHU9dGhpcy5fb3V0cHV0cyk7bGV0e3VzZWROb2RlczpwLG1pc3NpbmdJbnB1dHM6ZCxkeW5hbWljTm9kZTpjLHN5bmNJbnB1dHM6aH09SEkodCx1LHRoaXMud2VpZ2h0TWFwLHRoaXMuX2luaXROb2RlcyksbT1bLi4uaSwuLi50aGlzLmdyYXBoLndlaWdodHMsLi4udGhpcy5faW5pdE5vZGVzfHxbXV0ubWFwKHY9Pih7bm9kZTp2LGNvbnRleHRzOm4uY3VycmVudENvbnRleHR9KSksZj1PYmplY3QuYXNzaWduKHt9LHRoaXMud2VpZ2h0TWFwKTtPYmplY3Qua2V5cyh0KS5mb3JFYWNoKHY9PntsZXRbSSxOXT1Ybih2KSxDPVtdO0NbTl09dFt2XSxmW0ldPUN9KTtsZXQgZz17fSxiPXRoaXMuZ2V0RnJvemVuVGVuc29ySWRzKGYpLHk9e307Zm9yKDttLmxlbmd0aD4wOyl7bGV0IHY9dGhpcy5wcm9jZXNzU3RhY2soaSxtLG4sZix5LGIsbCxnLHApO2F3YWl0IFByb21pc2UuYWxsKHYpfWM9PW51bGwmJiFyJiZjb25zb2xlLndhcm4oXCJUaGlzIG1vZGVsIGV4ZWN1dGlvbiBkaWQgbm90IGNvbnRhaW4gYW55IG5vZGVzIHdpdGggY29udHJvbCBmbG93IG9yIGR5bmFtaWMgb3V0cHV0IHNoYXBlcy4gWW91IGNhbiB1c2UgbW9kZWwuZXhlY3V0ZSgpIGluc3RlYWQuXCIpO2xldCB4PXUuZmlsdGVyKHY9PiFRcyh2KSYmIXBuKHYubmFtZSxmLG4pKS5tYXAodj0+di5uYW1lKTtpZih4Lmxlbmd0aD4wKXtsZXQgdj1cIlwiO3Rocm93IGMhPW51bGwmJih2PWBBbHRlcm5hdGl2ZWx5LCB0byBhdm9pZCB0aGUgZHluYW1pYyBvcHMsIHVzZSBtb2RlbC5leGVjdXRlKCkgYW5kIHNwZWNpZnkgdGhlIGlucHV0cyBbJHtofV1gKSxuZXcgRXJyb3IoYENhbm5vdCBjb21wdXRlIHRoZSBvdXRwdXRzIFske3h9XSBmcm9tIHRoZSBwcm92aWRlZCBpbnB1dHMgWyR7c31dLiBDb25zaWRlciBwcm92aWRpbmcgdGhlIGZvbGxvd2luZyBpbnB1dHM6IFske2R9XS4gJHt2fWApfXJldHVybiBmfXByb2Nlc3NTdGFjayh0LG4sYSxyLHMsaSxvLGwsdSl7bGV0IHA9W107Zm9yKDtuLmxlbmd0aD4wOyl7bGV0IGQ9bi5wb3AoKTthLmN1cnJlbnRDb250ZXh0PWQuY29udGV4dHM7bGV0IGM9XCJcIjtpZihkLm5vZGUub3A9PT1cIkVudGVyXCImJmsoXCJpc0NvbnN0YW50XCIsZC5ub2RlLHIsYSkmJihbY109U3IoZC5ub2RlLm5hbWUsYSkpLHJbZC5ub2RlLm5hbWVdPT1udWxsKXtsZXQgaD1VSShkLm5vZGUscixhLHRoaXMuX3Jlc291cmNlTWFuYWdlcik7Y3x8KFtjXT1TcihkLm5vZGUubmFtZSxhKSk7bGV0IG09YS5jdXJyZW50Q29udGV4dDt3LmlzUHJvbWlzZShoKT9wLnB1c2goaC50aGVuKGY9PihyW2NdPWYsdGhpcy5rZWVwSW50ZXJtZWRpYXRlVGVuc29ycyYmKHRoaXMuY2xvbmVkVGVuc29yc01hcFtjXT10aGlzLmNsb25lVGVuc29yTGlzdChmKSksYS5jdXJyZW50Q29udGV4dD1tLHRoaXMuY2hlY2tUZW5zb3JGb3JEaXNwb3NhbChjLGQubm9kZSxyLGEsaSxvLGwpLHRoaXMucHJvY2Vzc0NoaWxkTm9kZXMoZC5ub2RlLG4sYSxyLHMsdSksZikpKToocltjXT1oLHRoaXMua2VlcEludGVybWVkaWF0ZVRlbnNvcnMmJih0aGlzLmNsb25lZFRlbnNvcnNNYXBbY109dGhpcy5jbG9uZVRlbnNvckxpc3QoaCkpLHRoaXMuY2hlY2tUZW5zb3JGb3JEaXNwb3NhbChjLGQubm9kZSxyLGEsaSxvLGwpLHRoaXMucHJvY2Vzc0NoaWxkTm9kZXMoZC5ub2RlLG4sYSxyLHMsdSkpfWVsc2UgdGhpcy5wcm9jZXNzQ2hpbGROb2RlcyhkLm5vZGUsbixhLHIscyx1KX1yZXR1cm4gcH1wcm9jZXNzQ2hpbGROb2Rlcyh0LG4sYSxyLHMsaSl7dC5jaGlsZHJlbi5mb3JFYWNoKG89PntsZXRbbF09U3Ioby5uYW1lLGEpO3NbbF18fCFpLmhhcyhvLm5hbWUpfHwoby5vcD09PVwiTWVyZ2VcIj9vLmlucHV0TmFtZXMuc29tZSh1PT4hIXBuKHUscixhKSkmJihzW2xdPSEwLG4ucHVzaCh7Y29udGV4dHM6YS5jdXJyZW50Q29udGV4dCxub2RlOm99KSk6by5pbnB1dE5hbWVzLmV2ZXJ5KHU9PiEhcG4odSxyLGEpKSYmKHNbbF09ITAsbi5wdXNoKHtjb250ZXh0czphLmN1cnJlbnRDb250ZXh0LG5vZGU6b30pKSl9KX1kaXNwb3NlKCl7T2JqZWN0LmtleXModGhpcy53ZWlnaHRNYXApLmZvckVhY2godD0+dGhpcy53ZWlnaHRNYXBbdF0uZm9yRWFjaChuPT5uLmRpc3Bvc2UoKSkpfWNoZWNrSW5wdXRTaGFwZUFuZFR5cGUodCl7T2JqZWN0LmtleXModCkuZm9yRWFjaChuPT57bGV0IGE9dFtuXSxbcl09WG4obikscz10aGlzLmdyYXBoLm5vZGVzW3JdO2lmKHMuYXR0clBhcmFtcy5zaGFwZSYmcy5hdHRyUGFyYW1zLnNoYXBlLnZhbHVlKXtsZXQgaT1zLmF0dHJQYXJhbXMuc2hhcGUudmFsdWUsbz1pLmxlbmd0aD09PWEuc2hhcGUubGVuZ3RoJiZhLnNoYXBlLmV2ZXJ5KChsLHUpPT5pW3VdPT09LTF8fGlbdV09PT1sKTt3LmFzc2VydChvLCgpPT5gVGhlIHNoYXBlIG9mIGRpY3RbJyR7cy5uYW1lfSddIHByb3ZpZGVkIGluIG1vZGVsLmV4ZWN1dGUoZGljdCkgbXVzdCBiZSBbJHtpfV0sIGJ1dCB3YXMgWyR7YS5zaGFwZX1dYCl9cy5hdHRyUGFyYW1zLmR0eXBlJiZzLmF0dHJQYXJhbXMuZHR5cGUudmFsdWUmJncuYXNzZXJ0KGEuZHR5cGU9PT1zLmF0dHJQYXJhbXMuZHR5cGUudmFsdWUsKCk9PmBUaGUgZHR5cGUgb2YgZGljdFsnJHtzLm5hbWV9J10gcHJvdmlkZWQgaW4gbW9kZWwuZXhlY3V0ZShkaWN0KSBtdXN0IGJlICR7cy5hdHRyUGFyYW1zLmR0eXBlLnZhbHVlfSwgYnV0IHdhcyAke2EuZHR5cGV9YCl9KX1tYXBJbnB1dHModCl7dmFyIG4sYTtsZXQgcj17fTtmb3IobGV0IHMgaW4gdCl7bGV0IGk9KGE9KG49dGhpcy5fc2lnbmF0dXJlKT09PW51bGx8fG49PT12b2lkIDA/dm9pZCAwOm4uaW5wdXRzKT09PW51bGx8fGE9PT12b2lkIDA/dm9pZCAwOmFbc107aSE9bnVsbD9yW2kubmFtZV09dFtzXTpyW3NdPXRbc119cmV0dXJuIHJ9Y2hlY2tJbnB1dHModCl7bGV0IG49T2JqZWN0LmtleXModCkuZmlsdGVyKGE9PntsZXRbcl09WG4oYSk7cmV0dXJuIHRoaXMuZ3JhcGgubm9kZXNbcl09PW51bGx9KTtpZihuLmxlbmd0aD4wKXRocm93IG5ldyBFcnJvcihgVGhlIGRpY3QgcHJvdmlkZWQgaW4gbW9kZWwuZXhlY3V0ZShkaWN0KSBoYXMga2V5czogWyR7bn1dIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIGdyYXBoYCl9bWFwT3V0cHV0cyh0KXtyZXR1cm4gdC5tYXAobj0+e3ZhciBhLHI7bGV0IHM9KHI9KGE9dGhpcy5fc2lnbmF0dXJlKT09PW51bGx8fGE9PT12b2lkIDA/dm9pZCAwOmEub3V0cHV0cyk9PT1udWxsfHxyPT09dm9pZCAwP3ZvaWQgMDpyW25dO3JldHVybiBzIT1udWxsP3MubmFtZTpufSx7fSl9Y2hlY2tPdXRwdXRzKHQpe3QuZm9yRWFjaChuPT57bGV0W2FdPVhuKG4pO2lmKCF0aGlzLmdyYXBoLm5vZGVzW2FdKXRocm93IG5ldyBFcnJvcihgVGhlIG91dHB1dCAnJHtufScgaXMgbm90IGZvdW5kIGluIHRoZSBncmFwaGApfSl9fSx5NT1jbGFzc3tjb25zdHJ1Y3RvcihlPXt9LHQ9e30pe3RoaXMuaGFzaFRhYmxlTmFtZVRvSGFuZGxlPWUsdGhpcy5oYXNoVGFibGVNYXA9dH1hZGRIYXNoVGFibGUoZSx0KXt0aGlzLmhhc2hUYWJsZU5hbWVUb0hhbmRsZVtlXT10LmhhbmRsZSx0aGlzLmhhc2hUYWJsZU1hcFt0LmlkXT10fWdldEhhc2hUYWJsZUhhbmRsZUJ5TmFtZShlKXtyZXR1cm4gdGhpcy5oYXNoVGFibGVOYW1lVG9IYW5kbGVbZV19Z2V0SGFzaFRhYmxlQnlJZChlKXtyZXR1cm4gdGhpcy5oYXNoVGFibGVNYXBbZV19ZGlzcG9zZSgpe2ZvcihsZXQgZSBpbiB0aGlzLmhhc2hUYWJsZU1hcCl0aGlzLmhhc2hUYWJsZU1hcFtlXS5jbGVhckFuZENsb3NlKCksZGVsZXRlIHRoaXMuaGFzaFRhYmxlTWFwW2VdO2ZvcihsZXQgZSBpbiB0aGlzLmhhc2hUYWJsZU5hbWVUb0hhbmRsZSl0aGlzLmhhc2hUYWJsZU5hbWVUb0hhbmRsZVtlXS5kaXNwb3NlKCksZGVsZXRlIHRoaXMuaGFzaFRhYmxlTmFtZVRvSGFuZGxlW2VdfX0seDU9XCI/dGZqcy1mb3JtYXQ9ZmlsZVwiLHY1PVwibW9kZWwuanNvblwiLEYxPWNsYXNze2dldCBtb2RlbFZlcnNpb24oKXtyZXR1cm4gdGhpcy52ZXJzaW9ufWdldCBpbnB1dE5vZGVzKCl7cmV0dXJuIHRoaXMuZXhlY3V0b3IuaW5wdXROb2Rlc31nZXQgb3V0cHV0Tm9kZXMoKXtyZXR1cm4gdGhpcy5leGVjdXRvci5vdXRwdXROb2Rlc31nZXQgaW5wdXRzKCl7cmV0dXJuIHRoaXMuZXhlY3V0b3IuaW5wdXRzfWdldCBvdXRwdXRzKCl7cmV0dXJuIHRoaXMuZXhlY3V0b3Iub3V0cHV0c31nZXQgd2VpZ2h0cygpe3JldHVybiB0aGlzLmV4ZWN1dG9yLndlaWdodE1hcH1nZXQgbWV0YWRhdGEoKXtyZXR1cm4gdGhpcy5hcnRpZmFjdHMudXNlckRlZmluZWRNZXRhZGF0YX1nZXQgbW9kZWxTaWduYXR1cmUoKXtyZXR1cm4gdGhpcy5zaWduYXR1cmV9Z2V0IG1vZGVsU3RydWN0dXJlZE91dHB1dEtleXMoKXtyZXR1cm4gdGhpcy5zdHJ1Y3R1cmVkT3V0cHV0S2V5c31jb25zdHJ1Y3RvcihlLHQ9e30sbj1qdCl7dGhpcy5tb2RlbFVybD1lLHRoaXMubG9hZE9wdGlvbnM9dCx0aGlzLnZlcnNpb249XCJuL2FcIix0aGlzLmlvPW4sdD09bnVsbCYmKHRoaXMubG9hZE9wdGlvbnM9e30pLHRoaXMucmVzb3VyY2VNYW5hZ2VyPW5ldyB5NX1maW5kSU9IYW5kbGVyKCl7bGV0IGU9dGhpcy5tb2RlbFVybDtpZihlLmxvYWQhPW51bGwpdGhpcy5oYW5kbGVyPWU7ZWxzZSBpZih0aGlzLmxvYWRPcHRpb25zLnJlcXVlc3RJbml0IT1udWxsKXRoaXMuaGFuZGxlcj10aGlzLmlvLmJyb3dzZXJIVFRQUmVxdWVzdChlLHRoaXMubG9hZE9wdGlvbnMpO2Vsc2V7bGV0IHQ9dGhpcy5pby5nZXRMb2FkSGFuZGxlcnMoZSx0aGlzLmxvYWRPcHRpb25zKTtpZih0Lmxlbmd0aD09PTApdC5wdXNoKHRoaXMuaW8uYnJvd3NlckhUVFBSZXF1ZXN0KGUsdGhpcy5sb2FkT3B0aW9ucykpO2Vsc2UgaWYodC5sZW5ndGg+MSl0aHJvdyBuZXcgRXJyb3IoYEZvdW5kIG1vcmUgdGhhbiBvbmUgKCR7dC5sZW5ndGh9KSBsb2FkIGhhbmRsZXJzIGZvciBVUkwgJyR7W2VdfSdgKTt0aGlzLmhhbmRsZXI9dFswXX19bG9hZCgpe2lmKHRoaXMuZmluZElPSGFuZGxlcigpLHRoaXMuaGFuZGxlci5sb2FkPT1udWxsKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwcm9jZWVkIHdpdGggbW9kZWwgbG9hZGluZyBiZWNhdXNlIHRoZSBJT0hhbmRsZXIgcHJvdmlkZWQgZG9lcyBub3QgaGF2ZSB0aGUgYGxvYWRgIG1ldGhvZCBpbXBsZW1lbnRlZC5cIik7bGV0IGU9dGhpcy5oYW5kbGVyLmxvYWQoKTtyZXR1cm4gdy5pc1Byb21pc2UoZSk/ZS50aGVuKHQ9PnQuZ2V0V2VpZ2h0U3RyZWFtPT1udWxsP3RoaXMubG9hZFN5bmModCk6dGhpcy5sb2FkU3RyZWFtaW5nKHQpKTp0aGlzLmxvYWRTeW5jKGUpfWxvYWRTeW5jKGUpe2xldCB0PXRoaXMuaW8uZGVjb2RlV2VpZ2h0cyhlLndlaWdodERhdGEsZS53ZWlnaHRTcGVjcyk7cmV0dXJuIHRoaXMubG9hZFdpdGhXZWlnaHRNYXAoZSx0KX1hc3luYyBsb2FkU3RyZWFtaW5nKGUpe2lmKGUuZ2V0V2VpZ2h0U3RyZWFtPT1udWxsKXRocm93IG5ldyBFcnJvcihcIk1vZGVsIGFydGlmYWN0cyBtaXNzaW5nIHN0cmVhbVdlaWdodHMgZnVuY3Rpb25cIik7bGV0IHQ9YXdhaXQgcE4oZS5nZXRXZWlnaHRTdHJlYW0oKSxlLndlaWdodFNwZWNzKTtyZXR1cm4gdGhpcy5sb2FkV2l0aFdlaWdodE1hcChlLHQpfWxvYWRXaXRoV2VpZ2h0TWFwKGUsdCl7dGhpcy5hcnRpZmFjdHM9ZTtsZXQgbj10aGlzLmFydGlmYWN0cy5tb2RlbFRvcG9sb2d5LGE9dGhpcy5hcnRpZmFjdHMuc2lnbmF0dXJlO2lmKHRoaXMuYXJ0aWZhY3RzLnVzZXJEZWZpbmVkTWV0YWRhdGEhPW51bGwpe2xldCByPXRoaXMuYXJ0aWZhY3RzLnVzZXJEZWZpbmVkTWV0YWRhdGE7ci5zaWduYXR1cmUhPW51bGwmJihhPXIuc2lnbmF0dXJlKSxyLnN0cnVjdHVyZWRPdXRwdXRLZXlzIT1udWxsJiYodGhpcy5zdHJ1Y3R1cmVkT3V0cHV0S2V5cz1yLnN0cnVjdHVyZWRPdXRwdXRLZXlzKX1pZih0aGlzLnNpZ25hdHVyZT1hLHRoaXMudmVyc2lvbj1gJHtuLnZlcnNpb25zLnByb2R1Y2VyfS4ke24udmVyc2lvbnMubWluQ29uc3VtZXJ9YCx0aGlzLmV4ZWN1dG9yPW5ldyBqSSh6SS5JbnN0YW5jZS50cmFuc2Zvcm1HcmFwaChuLHRoaXMuc2lnbmF0dXJlKSksdGhpcy5leGVjdXRvci53ZWlnaHRNYXA9dGhpcy5jb252ZXJ0VGVuc29yTWFwVG9UZW5zb3JzTWFwKHQpLHRoaXMuZXhlY3V0b3IucmVzb3VyY2VNYW5hZ2VyPXRoaXMucmVzb3VyY2VNYW5hZ2VyLGUubW9kZWxJbml0aWFsaXplciE9bnVsbCYmZS5tb2RlbEluaXRpYWxpemVyLm5vZGUhPW51bGwpe2xldCByPXpJLkluc3RhbmNlLnRyYW5zZm9ybUdyYXBoKGUubW9kZWxJbml0aWFsaXplcik7dGhpcy5pbml0aWFsaXplcj1uZXcgakkociksdGhpcy5pbml0aWFsaXplci53ZWlnaHRNYXA9dGhpcy5leGVjdXRvci53ZWlnaHRNYXAsdGhpcy5pbml0aWFsaXplci5yZXNvdXJjZU1hbmFnZXI9dGhpcy5yZXNvdXJjZU1hbmFnZXIsdGhpcy5pbml0aWFsaXplclNpZ25hdHVyZT1lLmluaXRpYWxpemVyU2lnbmF0dXJlfXJldHVybiEwfWFzeW5jIHNhdmUoZSx0KXtpZih0eXBlb2YgZT09XCJzdHJpbmdcIil7bGV0IG49dGhpcy5pby5nZXRTYXZlSGFuZGxlcnMoZSk7aWYobi5sZW5ndGg9PT0wKXRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgYW55IHNhdmUgaGFuZGxlcnMgZm9yIFVSTCAnJHtlfSdgKTtpZihuLmxlbmd0aD4xKXRocm93IG5ldyBFcnJvcihgRm91bmQgbW9yZSB0aGFuIG9uZSAoJHtuLmxlbmd0aH0pIHNhdmUgaGFuZGxlcnMgZm9yIFVSTCAnJHtlfSdgKTtlPW5bMF19aWYoZS5zYXZlPT1udWxsKXRocm93IG5ldyBFcnJvcihcIkdyYXBoTW9kZWwuc2F2ZSgpIGNhbm5vdCBwcm9jZWVkIGJlY2F1c2UgdGhlIElPSGFuZGxlciBwcm92aWRlZCBkb2VzIG5vdCBoYXZlIHRoZSBgc2F2ZWAgYXR0cmlidXRlIGRlZmluZWQuXCIpO3JldHVybiBlLnNhdmUodGhpcy5hcnRpZmFjdHMpfWFkZFN0cnVjdHVyZWRPdXRwdXROYW1lcyhlKXtpZih0aGlzLnN0cnVjdHVyZWRPdXRwdXRLZXlzKXtsZXQgdD1lIGluc3RhbmNlb2YgQ2U/W2VdOmUsbj17fTtyZXR1cm4gdC5mb3JFYWNoKChhLHIpPT5uW3RoaXMuc3RydWN0dXJlZE91dHB1dEtleXNbcl1dPWEpLG59cmV0dXJuIGV9cHJlZGljdChlLHQpe2xldCBuPXRoaXMuZXhlY3V0ZShlLHRoaXMub3V0cHV0Tm9kZXMpO3JldHVybiB0aGlzLmFkZFN0cnVjdHVyZWRPdXRwdXROYW1lcyhuKX1hc3luYyBwcmVkaWN0QXN5bmMoZSx0KXtsZXQgbj1hd2FpdCB0aGlzLmV4ZWN1dGVBc3luYyhlLHRoaXMub3V0cHV0Tm9kZXMpO3JldHVybiB0aGlzLmFkZFN0cnVjdHVyZWRPdXRwdXROYW1lcyhuKX1ub3JtYWxpemVJbnB1dHMoZSl7dmFyIHQ7aWYoIShlIGluc3RhbmNlb2YgQ2UpJiYhQXJyYXkuaXNBcnJheShlKSl7bGV0IHI9KHQ9dGhpcy5zaWduYXR1cmUpPT09bnVsbHx8dD09PXZvaWQgMD92b2lkIDA6dC5pbnB1dHM7aWYociE9bnVsbClmb3IobGV0IHMgaW4gcil7bGV0IGk9cltzXTtpLnJlc291cmNlSWQhPW51bGwmJihlW3NdPXRoaXMucmVzb3VyY2VJZFRvQ2FwdHVyZWRJbnB1dFtpLnJlc291cmNlSWRdKX1yZXR1cm4gZX1lPUFycmF5LmlzQXJyYXkoZSk/ZTpbZV07bGV0IG49T2JqZWN0LmtleXModGhpcy5yZXNvdXJjZUlkVG9DYXB0dXJlZElucHV0KS5sZW5ndGg7aWYoZS5sZW5ndGgrbiE9PXRoaXMuaW5wdXROb2Rlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCB0ZW5zb3IgY291bnQgbWlzbWF0Y2gsIHRoZSBncmFwaCBtb2RlbCBoYXMgJHt0aGlzLmlucHV0Tm9kZXMubGVuZ3RoLW59IG5vbi1yZXNvdXJjZSBwbGFjZWhvbGRlcnMsIHdoaWxlIHRoZXJlIGFyZSAke2UubGVuZ3RofSBpbnB1dCB0ZW5zb3JzIHByb3ZpZGVkLmApO2xldCBhPTA7cmV0dXJuIHRoaXMuaW5wdXROb2Rlcy5yZWR1Y2UoKHIscyk9Pnt2YXIgaSxvLGw7bGV0IHU9KGw9KG89KGk9dGhpcy5zaWduYXR1cmUpPT09bnVsbHx8aT09PXZvaWQgMD92b2lkIDA6aS5pbnB1dHMpPT09bnVsbHx8bz09PXZvaWQgMD92b2lkIDA6b1tzXSk9PT1udWxsfHxsPT09dm9pZCAwP3ZvaWQgMDpsLnJlc291cmNlSWQ7cmV0dXJuIHUhPW51bGw/cltzXT10aGlzLnJlc291cmNlSWRUb0NhcHR1cmVkSW5wdXRbdV06cltzXT1lW2ErK10scn0se30pfW5vcm1hbGl6ZU91dHB1dHMoZSl7cmV0dXJuIGU9ZXx8dGhpcy5vdXRwdXROb2RlcyxBcnJheS5pc0FycmF5KGUpP2U6W2VdfWV4ZWN1dGVJbml0aWFsaXplckdyYXBoKCl7cmV0dXJuIHRoaXMuaW5pdGlhbGl6ZXI9PW51bGw/W106dGhpcy5pbml0aWFsaXplclNpZ25hdHVyZT09bnVsbD90aGlzLmluaXRpYWxpemVyLmV4ZWN1dGUoe30sW10pOnRoaXMuaW5pdGlhbGl6ZXIuZXhlY3V0ZSh7fSxPYmplY3Qua2V5cyh0aGlzLmluaXRpYWxpemVyU2lnbmF0dXJlLm91dHB1dHMpKX1hc3luYyBleGVjdXRlSW5pdGlhbGl6ZXJHcmFwaEFzeW5jKCl7cmV0dXJuIHRoaXMuaW5pdGlhbGl6ZXI9PW51bGw/W106dGhpcy5pbml0aWFsaXplclNpZ25hdHVyZT09bnVsbD90aGlzLmluaXRpYWxpemVyLmV4ZWN1dGVBc3luYyh7fSxbXSk6dGhpcy5pbml0aWFsaXplci5leGVjdXRlQXN5bmMoe30sT2JqZWN0LmtleXModGhpcy5pbml0aWFsaXplclNpZ25hdHVyZS5vdXRwdXRzKSl9c2V0UmVzb3VyY2VJZFRvQ2FwdHVyZWRJbnB1dChlKXtpZih0aGlzLnJlc291cmNlSWRUb0NhcHR1cmVkSW5wdXQ9e30sdGhpcy5pbml0aWFsaXplclNpZ25hdHVyZSl7bGV0IHQ9dGhpcy5pbml0aWFsaXplclNpZ25hdHVyZS5vdXRwdXRzLG49T2JqZWN0LmtleXModCk7Zm9yKGxldCBhPTA7YTxuLmxlbmd0aDthKyspe2xldCByPW5bYV0scz10W3JdO3RoaXMucmVzb3VyY2VJZFRvQ2FwdHVyZWRJbnB1dFtzLnJlc291cmNlSWRdPWVbYV19fX1leGVjdXRlKGUsdCl7dGhpcy5yZXNvdXJjZUlkVG9DYXB0dXJlZElucHV0PT1udWxsJiZ0aGlzLnNldFJlc291cmNlSWRUb0NhcHR1cmVkSW5wdXQodGhpcy5leGVjdXRlSW5pdGlhbGl6ZXJHcmFwaCgpKSxlPXRoaXMubm9ybWFsaXplSW5wdXRzKGUpLHQ9dGhpcy5ub3JtYWxpemVPdXRwdXRzKHQpO2xldCBuPXRoaXMuZXhlY3V0b3IuZXhlY3V0ZShlLHQpO3JldHVybiBuLmxlbmd0aD4xP246blswXX1hc3luYyBleGVjdXRlQXN5bmMoZSx0KXt0aGlzLnJlc291cmNlSWRUb0NhcHR1cmVkSW5wdXQ9PW51bGwmJnRoaXMuc2V0UmVzb3VyY2VJZFRvQ2FwdHVyZWRJbnB1dChhd2FpdCB0aGlzLmV4ZWN1dGVJbml0aWFsaXplckdyYXBoQXN5bmMoKSksZT10aGlzLm5vcm1hbGl6ZUlucHV0cyhlKSx0PXRoaXMubm9ybWFsaXplT3V0cHV0cyh0KTtsZXQgbj1hd2FpdCB0aGlzLmV4ZWN1dG9yLmV4ZWN1dGVBc3luYyhlLHQpO3JldHVybiBuLmxlbmd0aD4xP246blswXX1nZXRJbnRlcm1lZGlhdGVUZW5zb3JzKCl7cmV0dXJuIHRoaXMuZXhlY3V0b3IuZ2V0SW50ZXJtZWRpYXRlVGVuc29ycygpfWRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JzKCl7dGhpcy5leGVjdXRvci5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ycygpfWNvbnZlcnRUZW5zb3JNYXBUb1RlbnNvcnNNYXAoZSl7cmV0dXJuIE9iamVjdC5rZXlzKGUpLnJlZHVjZSgodCxuKT0+KHRbbl09W2Vbbl1dLHQpLHt9KX1kaXNwb3NlKCl7dGhpcy5leGVjdXRvci5kaXNwb3NlKCksdGhpcy5pbml0aWFsaXplciYmKHRoaXMuaW5pdGlhbGl6ZXIuZGlzcG9zZSgpLHRoaXMucmVzb3VyY2VJZFRvQ2FwdHVyZWRJbnB1dCYmRWUodGhpcy5yZXNvdXJjZUlkVG9DYXB0dXJlZElucHV0KSksdGhpcy5yZXNvdXJjZU1hbmFnZXIuZGlzcG9zZSgpfX07YXN5bmMgZnVuY3Rpb24gdzUoZSx0PXt9LG49anQpe2lmKGU9PW51bGwpdGhyb3cgbmV3IEVycm9yKFwibW9kZWxVcmwgaW4gbG9hZEdyYXBoTW9kZWwoKSBjYW5ub3QgYmUgbnVsbC4gUGxlYXNlIHByb3ZpZGUgYSB1cmwgb3IgYW4gSU9IYW5kbGVyIHRoYXQgbG9hZHMgdGhlIG1vZGVsXCIpO3Q9PW51bGwmJih0PXt9KSx0LmZyb21URkh1YiYmdHlwZW9mIGU9PVwic3RyaW5nXCImJihlPUk1KGUpKTtsZXQgYT1uZXcgRjEoZSx0LG4pO3JldHVybiBhd2FpdCBhLmxvYWQoKSxhfWZ1bmN0aW9uIGs1KGUpe2lmKGU9PW51bGwpdGhyb3cgbmV3IEVycm9yKFwibW9kZWxVcmwgaW4gbG9hZEdyYXBoTW9kZWxTeW5jKCkgY2Fubm90IGJlIG51bGwuIFBsZWFzZSBwcm92aWRlIG1vZGVsIGFydGlmYWN0cyBvciBhbiBJT0hhbmRsZXIgdGhhdCBsb2FkcyB0aGUgbW9kZWxcIik7bGV0IHQ7aWYoZSBpbnN0YW5jZW9mIEFycmF5KXtsZXRbYSxyXT1lO2lmKCFhKXRocm93IG5ldyBFcnJvcihcIm1vZGVsSlNPTiBtdXN0IGJlIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBhcnJheVwiKTtpZighcnx8IShyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKXRocm93IG5ldyBFcnJvcihcIkFuIEFycmF5QnVmZmVyIG9mIHdlaWdodHMgbXVzdCBiZSB0aGUgc2Vjb25kIGVsZW1lbnQgb2YgdGhlIGFycmF5XCIpO2lmKCEoXCJtb2RlbFRvcG9sb2d5XCJpbiBhKSl0aHJvdyBuZXcgRXJyb3IoXCJNb2RlbCBKU09OIGlzIG1pc3NpbmcgJ21vZGVsVG9wb2xvZ3knXCIpO2lmKCEoXCJ3ZWlnaHRzTWFuaWZlc3RcImluIGEpKXRocm93IG5ldyBFcnJvcihcIk1vZGVsIEpTT04gaXMgbWlzc2luZyAnd2VpZ2h0c01hbmlmZXN0J1wiKTtsZXQgcz1qdC5nZXRXZWlnaHRTcGVjcyhhLndlaWdodHNNYW5pZmVzdCksaT1qdC5nZXRNb2RlbEFydGlmYWN0c0ZvckpTT05TeW5jKGEscyxyKTt0PWp0LmZyb21NZW1vcnlTeW5jKGkpfWVsc2UgaWYoXCJsb2FkXCJpbiBlKXQ9ZTtlbHNlIGlmKFwibW9kZWxUb3BvbG9neVwiaW4gZSYmXCJ3ZWlnaHRTcGVjc1wiaW4gZSYmXCJ3ZWlnaHREYXRhXCJpbiBlKXQ9anQuZnJvbU1lbW9yeVN5bmMoZSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG1vZGVsIGZvcm1hdFwiKTtsZXQgbj1uZXcgRjEodCk7cmV0dXJuIG4ubG9hZCgpLG59ZnVuY3Rpb24gSTUoZSl7cmV0dXJuIGUuZW5kc1dpdGgoXCIvXCIpfHwoZT1lK1wiL1wiKSxgJHtlfSR7djV9JHt4NX1gfXZhciBTNT1cIjQuMjIuMFwiLGxFPXt9O19lKGxFLHtDU1ZEYXRhc2V0OigpPT54RSxEYXRhc2V0OigpPT5pcCxGaWxlRGF0YVNvdXJjZTooKT0+VEUsVGV4dExpbmVEYXRhc2V0OigpPT55RSxVUkxEYXRhU291cmNlOigpPT5DRSxhcnJheTooKT0+cTUsY3N2OigpPT5pOCxmdW5jOigpPT5vOCxnZW5lcmF0b3I6KCk9Pmw4LG1pY3JvcGhvbmU6KCk9PnA4LHZlcnNpb25fZGF0YTooKT0+Yzgsd2ViY2FtOigpPT51OCx6aXA6KCk9Pks1fSk7dmFyIE41PXhzKGJtKCkpLFQ1PXhzKGJtKCkpO2Z1bmN0aW9uIEM1KGUsdCl7cmV0dXJuIG9tKGUsdCl9ZnVuY3Rpb24gb20oZSx0LG49bmV3IE1hcCxhPW5ldyBTZXQpe2lmKGU9PW51bGwpcmV0dXJuIG51bGw7aWYodHlwZW9mIEJsb2I9PVwiZnVuY3Rpb25cIiYmZSBpbnN0YW5jZW9mIEJsb2IpcmV0dXJuIGUuc2xpY2UoKTtpZihhLmhhcyhlKSl0aHJvdyBuZXcgRXJyb3IoXCJDaXJjdWxhciByZWZlcmVuY2VzIGFyZSBub3Qgc3VwcG9ydGVkLlwiKTtpZihuLmhhcyhlKSlyZXR1cm4gbi5nZXQoZSk7bGV0IHI9dChlKTtpZihyLnJlY3Vyc2UmJnIudmFsdWUhPT1udWxsKXRocm93IG5ldyBFcnJvcihcIkEgZGVlcCBtYXAgZnVuY3Rpb24gbWF5IG5vdCByZXR1cm4gYm90aCBhIHZhbHVlIGFuZCByZWN1cnNlPXRydWUuXCIpO2lmKHIucmVjdXJzZSlpZihIbChlKSl7bGV0IHM9QXJyYXkuaXNBcnJheShlKT9bXTp7fTthLmFkZChlKTtmb3IobGV0IGkgaW4gZSl7bGV0IG89ZVtpXSxsPW9tKG8sdCxuLGEpO3NbaV09bH1yZXR1cm4gYS5kZWxldGUoZSksZS5fX3Byb3RvX18mJihzLl9fcHJvdG9fXz1lLl9fcHJvdG9fXyksc31lbHNlIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgcmVjdXJzZSBpbnRvIG5vbi1pdGVyYWJsZSB0eXBlOiAke2V9YCk7ZWxzZSByZXR1cm4gbi5zZXQoZSxyLnZhbHVlKSxyLnZhbHVlfWZ1bmN0aW9uIEU1KGUsdD1wRSl7cmV0dXJuIHVFKGUsdCl9ZnVuY3Rpb24gdUUoZSx0LG49bmV3IFNldCl7bGV0IGE9ZVswXTtpZihuLmhhcyhhKSl0aHJvdyBuZXcgRXJyb3IoXCJDaXJjdWxhciByZWZlcmVuY2VzIGFyZSBub3Qgc3VwcG9ydGVkLlwiKTtsZXQgcj10KGUpO2lmKHIucmVjdXJzZSYmci52YWx1ZSE9PW51bGwpdGhyb3cgbmV3IEVycm9yKFwiQSBkZWVwIHppcCBmdW5jdGlvbiBtYXkgbm90IHJldHVybiBib3RoIGEgdmFsdWUgYW5kIHJlY3Vyc2U9dHJ1ZS5cIik7aWYoci5yZWN1cnNlKWlmKEhsKGEpKXtsZXQgcz1BcnJheS5pc0FycmF5KGEpP1tdOnt9O24uYWRkKGEpO2ZvcihsZXQgaSBpbiBhKXtsZXQgbz1lLm1hcCh1PT51W2ldKSxsPXVFKG8sdCxuKTtzW2ldPWx9cmV0dXJuIG4uZGVsZXRlKGEpLHN9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHJlY3Vyc2UgaW50byBub24taXRlcmFibGUgdHlwZTogJHthfWApO2Vsc2UgcmV0dXJuIHIudmFsdWV9ZnVuY3Rpb24gcEUoZSl7cmV0dXJuIGU9PT1udWxsP251bGw6SGwoZVswXSk/e3ZhbHVlOm51bGwscmVjdXJzZTohMH06e3ZhbHVlOmUscmVjdXJzZTohMX19YXN5bmMgZnVuY3Rpb24gY0UoZSx0KXtsZXQgbj1uZXcgTWFwO29tKGUsdCxuKTtmb3IobGV0IGEgb2YgQXJyYXkuZnJvbShuLmtleXMoKSkpe2xldCByPW4uZ2V0KGEpO2lmKHcuaXNQcm9taXNlKHIpKXtsZXQgcz1hd2FpdCByO24uc2V0KGEscyl9fXJldHVybiBvbShlLHQsbil9ZnVuY3Rpb24gSGwoZSl7bGV0IHQ9ITE7aWYoRygpLmdldChcIklTX0JST1dTRVJcIikpdD1lIGluc3RhbmNlb2YgVGV4dERlY29kZXI7ZWxzZXtsZXR7U3RyaW5nRGVjb2RlcjpufT1GUygpO3Q9ZSBpbnN0YW5jZW9mIG59cmV0dXJuIGUhPW51bGwmJiFBcnJheUJ1ZmZlci5pc1ZpZXcoZSkmJihBcnJheS5pc0FycmF5KGUpfHx0eXBlb2YgZT09XCJvYmplY3RcIiYmIShlIGluc3RhbmNlb2YgQ2UpJiYhKGUgaW5zdGFuY2VvZiBQcm9taXNlKSYmIXQpfWZ1bmN0aW9uIF81KGUpe3JldHVybiBlPT1udWxsfHxBNShlKXx8QXJyYXkuaXNBcnJheShlKXx8dHlwZW9mIGU9PVwib2JqZWN0XCImJmUgaW5zdGFuY2VvZiBDZXx8dy5pc1R5cGVkQXJyYXkoZSl9ZnVuY3Rpb24gQTUoZSl7cmV0dXJuIGU9PT1udWxsfHx0eXBlb2YgZSE9XCJvYmplY3RcIiYmdHlwZW9mIGUhPVwiZnVuY3Rpb25cIn1mdW5jdGlvbiBGNShlKXtyZXR1cm4gQzUoZSwkNSl9ZnVuY3Rpb24gJDUoZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBDZT97dmFsdWU6ZS5jbG9uZSgpLHJlY3Vyc2U6ITF9OkhsKGUpP3t2YWx1ZTpudWxsLHJlY3Vyc2U6ITB9Ont2YWx1ZTplLHJlY3Vyc2U6ITF9fXZhciBkRT1jbGFzc3tjb25zdHJ1Y3RvcihlKXtpZih0aGlzLmNhcGFjaXR5PWUsdGhpcy5iZWdpbj0wLHRoaXMuZW5kPTAsZT09bnVsbCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IGNyZWF0ZSBhIHJpbmcgYnVmZmVyIG9mIHVua25vd24gY2FwYWNpdHkuXCIpO2lmKGU8MSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IGNyZWF0ZSByaW5nIGJ1ZmZlciBvZiBjYXBhY2l0eSA8IDEuXCIpO3RoaXMuZGF0YT1uZXcgQXJyYXkoZSksdGhpcy5kb3VibGVkQ2FwYWNpdHk9MiplfXdyYXAoZSl7Zm9yKDtlPDA7KWUrPXRoaXMuZG91YmxlZENhcGFjaXR5O3JldHVybiBlJXRoaXMuZG91YmxlZENhcGFjaXR5fWdldChlKXtpZihlPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBnZXQgaXRlbSBhdCBhIG5lZ2F0aXZlIGluZGV4LlwiKTtyZXR1cm4gdGhpcy5kYXRhW2UldGhpcy5jYXBhY2l0eV19c2V0KGUsdCl7aWYoZTwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3Qgc2V0IGl0ZW0gYXQgYSBuZWdhdGl2ZSBpbmRleC5cIik7dGhpcy5kYXRhW2UldGhpcy5jYXBhY2l0eV09dH1sZW5ndGgoKXtsZXQgZT10aGlzLmVuZC10aGlzLmJlZ2luO3JldHVybiBlPDAmJihlPXRoaXMuZG91YmxlZENhcGFjaXR5K2UpLGV9aXNGdWxsKCl7cmV0dXJuIHRoaXMubGVuZ3RoKCk9PT10aGlzLmNhcGFjaXR5fWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5sZW5ndGgoKT09PTB9cHVzaChlKXtpZih0aGlzLmlzRnVsbCgpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiUmluZyBidWZmZXIgaXMgZnVsbC5cIik7dGhpcy5zZXQodGhpcy5lbmQsZSksdGhpcy5lbmQ9dGhpcy53cmFwKHRoaXMuZW5kKzEpfXB1c2hBbGwoZSl7Zm9yKGxldCB0IG9mIGUpdGhpcy5wdXNoKHQpfXBvcCgpe2lmKHRoaXMuaXNFbXB0eSgpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiUmluZyBidWZmZXIgaXMgZW1wdHkuXCIpO3RoaXMuZW5kPXRoaXMud3JhcCh0aGlzLmVuZC0xKTtsZXQgZT10aGlzLmdldCh0aGlzLmVuZCk7cmV0dXJuIHRoaXMuc2V0KHRoaXMuZW5kLHZvaWQgMCksZX11bnNoaWZ0KGUpe2lmKHRoaXMuaXNGdWxsKCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSaW5nIGJ1ZmZlciBpcyBmdWxsLlwiKTt0aGlzLmJlZ2luPXRoaXMud3JhcCh0aGlzLmJlZ2luLTEpLHRoaXMuc2V0KHRoaXMuYmVnaW4sZSl9c2hpZnQoKXtpZih0aGlzLmlzRW1wdHkoKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJpbmcgYnVmZmVyIGlzIGVtcHR5LlwiKTtsZXQgZT10aGlzLmdldCh0aGlzLmJlZ2luKTtyZXR1cm4gdGhpcy5zZXQodGhpcy5iZWdpbix2b2lkIDApLHRoaXMuYmVnaW49dGhpcy53cmFwKHRoaXMuYmVnaW4rMSksZX1zaHVmZmxlRXhjaXNlKGUpe2lmKHRoaXMuaXNFbXB0eSgpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiUmluZyBidWZmZXIgaXMgZW1wdHkuXCIpO2xldCB0PXRoaXMud3JhcCh0aGlzLmJlZ2luK2UpLG49dGhpcy5nZXQodCk7cmV0dXJuIHRoaXMuc2V0KHQsdGhpcy5wb3AoKSksbn19LGhFPWNsYXNzIG1FIGV4dGVuZHMgZEV7Y29uc3RydWN0b3IoKXtzdXBlcihtRS5JTklUSUFMX0NBUEFDSVRZKX1pc0Z1bGwoKXtyZXR1cm4hMX1wdXNoKHQpe3N1cGVyLmlzRnVsbCgpJiZ0aGlzLmV4cGFuZCgpLHN1cGVyLnB1c2godCl9dW5zaGlmdCh0KXtzdXBlci5pc0Z1bGwoKSYmdGhpcy5leHBhbmQoKSxzdXBlci51bnNoaWZ0KHQpfWV4cGFuZCgpe2xldCB0PXRoaXMuY2FwYWNpdHkqMixuPW5ldyBBcnJheSh0KSxhPXRoaXMubGVuZ3RoKCk7Zm9yKGxldCByPTA7cjxhO3IrKyluW3JdPXRoaXMuZ2V0KHRoaXMud3JhcCh0aGlzLmJlZ2luK3IpKTt0aGlzLmRhdGE9bix0aGlzLmNhcGFjaXR5PXQsdGhpcy5kb3VibGVkQ2FwYWNpdHk9Mip0aGlzLmNhcGFjaXR5LHRoaXMuYmVnaW49MCx0aGlzLmVuZD1hfX07aEUuSU5JVElBTF9DQVBBQ0lUWT0zMjtmdW5jdGlvbiBmRShlKXtyZXR1cm4gbmV3IE01KGUpfWZ1bmN0aW9uICQxKGUpe3JldHVybiBuZXcgTzUoZSl9ZnVuY3Rpb24gRDUoZSx0KXtyZXR1cm4gbmV3IGdFKGUsdCl9ZnVuY3Rpb24gUjUoZSx0PWVzLkZBSUwpe3JldHVybiBuZXcgSDUoZSx0KX12YXIgc249Y2xhc3N7YXN5bmMgdG9BcnJheSgpe2xldCBlPVtdLHQ9YXdhaXQgdGhpcy5uZXh0KCk7Zm9yKDshdC5kb25lOyllLnB1c2godC52YWx1ZSksdD1hd2FpdCB0aGlzLm5leHQoKTtyZXR1cm4gZX1hc3luYyB0b0FycmF5Rm9yVGVzdCgpe2xldCBlPXRoaXMucHJlZmV0Y2goMTAwKSx0PVtdLG49YXdhaXQgZS5uZXh0KCk7Zm9yKDshbi5kb25lOyl0LnB1c2gobi52YWx1ZSksbj1hd2FpdCBlLm5leHQoKTtyZXR1cm4gdH1hc3luYyByZXNvbHZlRnVsbHkoKXtsZXQgZT1hd2FpdCB0aGlzLm5leHQoKTtmb3IoOyFlLmRvbmU7KWU9YXdhaXQgdGhpcy5uZXh0KCl9YXN5bmMgcmVzb2x2ZVdoaWxlKGUpe2xldCB0PWF3YWl0IHRoaXMubmV4dCgpLG49ZSh0LnZhbHVlKTtmb3IoOyF0LmRvbmUmJm47KXQ9YXdhaXQgdGhpcy5uZXh0KCksbj1lKHQudmFsdWUpfWhhbmRsZUVycm9ycyhlKXtyZXR1cm4gbmV3IFU1KHRoaXMsZSl9ZmlsdGVyKGUpe3JldHVybiBuZXcgQjUodGhpcyxlKX1tYXAoZSl7cmV0dXJuIG5ldyBWNSh0aGlzLGUpfW1hcEFzeW5jKGUpe3JldHVybiBuZXcgcUkodGhpcyxlKX1zZXJpYWxNYXBBc3luYyhlKXtyZXR1cm4gbmV3IHFJKHRoaXMsZSkuc2VyaWFsKCl9ZmxhdG1hcChlKXtyZXR1cm4gbmV3IEc1KHRoaXMsZSl9YXN5bmMgZm9yRWFjaEFzeW5jKGUpe3JldHVybiB0aGlzLm1hcChlKS5yZXNvbHZlRnVsbHkoKX1hc3luYyBzZXJpYWxGb3JFYWNoKGUpe3JldHVybiB0aGlzLnNlcmlhbE1hcEFzeW5jKGUpLnJlc29sdmVXaGlsZSh0PT50PT09ITApfXJvd01ham9yQmF0Y2goZSx0PSEwKXtyZXR1cm4gbmV3IFc1KHRoaXMsZSx0KX1jb2x1bW5NYWpvckJhdGNoKGUsdD0hMCxuPXBFKXtyZXR1cm4gdGhpcy5yb3dNYWpvckJhdGNoKGUsdCkubWFwKGE9PkU1KGEsbikpfWNvbmNhdGVuYXRlKGUsdCl7cmV0dXJuIG5ldyBnRShmRShbdGhpcyxlXSksdCl9dGFrZShlKXtyZXR1cm4gZTwwfHxlPT1udWxsP3RoaXM6bmV3IHo1KHRoaXMsZSl9c2tpcChlKXtyZXR1cm4gZTwwfHxlPT1udWxsP3RoaXM6bmV3IEw1KHRoaXMsZSl9cHJlZmV0Y2goZSl7cmV0dXJuIG5ldyBiRSh0aGlzLGUpfXNodWZmbGUoZSx0KXtyZXR1cm4gbmV3IGo1KHRoaXMsZSx0KX1zZXJpYWwoKXtyZXR1cm4gbmV3IFA1KHRoaXMpfX0sTTU9Y2xhc3MgZXh0ZW5kcyBzbntjb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMuaXRlbXM9ZSx0aGlzLnRyYXY9MH1zdW1tYXJ5KCl7cmV0dXJuYEFycmF5IG9mICR7dGhpcy5pdGVtcy5sZW5ndGh9IGl0ZW1zYH1hc3luYyBuZXh0KCl7aWYodGhpcy50cmF2Pj10aGlzLml0ZW1zLmxlbmd0aClyZXR1cm57dmFsdWU6bnVsbCxkb25lOiEwfTtsZXQgZT10aGlzLml0ZW1zW3RoaXMudHJhdl07cmV0dXJuIHRoaXMudHJhdisrLHt2YWx1ZTpGNShlKSxkb25lOiExfX19LE81PWNsYXNzIGV4dGVuZHMgc257Y29uc3RydWN0b3IoZSl7c3VwZXIoKSx0aGlzLm5leHRGbj1lfXN1bW1hcnkoKXtyZXR1cm5cIkZ1bmN0aW9uIGNhbGxcIn1hc3luYyBuZXh0KCl7dHJ5e3JldHVybiB0aGlzLm5leHRGbigpfWNhdGNoKGUpe3Rocm93IGUubWVzc2FnZT1gRXJyb3IgdGhyb3duIHdoaWxlIGl0ZXJhdGluZyB0aHJvdWdoIGEgZGF0YXNldDogJHtlLm1lc3NhZ2V9YCxlfX19LFA1PWNsYXNzIGV4dGVuZHMgc257Y29uc3RydWN0b3IoZSl7c3VwZXIoKSx0aGlzLnVwc3RyZWFtPWUsdGhpcy5sYXN0UmVhZD1Qcm9taXNlLnJlc29sdmUoe3ZhbHVlOm51bGwsZG9uZTohMX0pfXN1bW1hcnkoKXtyZXR1cm5gJHt0aGlzLnVwc3RyZWFtLnN1bW1hcnkoKX0gLT4gU2VyaWFsYH1hc3luYyBuZXh0KCl7cmV0dXJuIHRoaXMubGFzdFJlYWQ9dGhpcy5sYXN0UmVhZC50aGVuKCgpPT50aGlzLnNlcmlhbE5leHQoKSksdGhpcy5sYXN0UmVhZH1hc3luYyBzZXJpYWxOZXh0KCl7cmV0dXJuIHRoaXMudXBzdHJlYW0ubmV4dCgpfX0sTDU9Y2xhc3MgZXh0ZW5kcyBzbntjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKCksdGhpcy51cHN0cmVhbT1lLHRoaXMubWF4Q291bnQ9dCx0aGlzLmNvdW50PTAsdGhpcy5sYXN0UmVhZD1Qcm9taXNlLnJlc29sdmUoe3ZhbHVlOm51bGwsZG9uZTohMX0pfXN1bW1hcnkoKXtyZXR1cm5gJHt0aGlzLnVwc3RyZWFtLnN1bW1hcnkoKX0gLT4gU2tpcGB9YXN5bmMgbmV4dCgpe3JldHVybiB0aGlzLmxhc3RSZWFkPXRoaXMubGFzdFJlYWQudGhlbigoKT0+dGhpcy5zZXJpYWxOZXh0KCkpLHRoaXMubGFzdFJlYWR9YXN5bmMgc2VyaWFsTmV4dCgpe2Zvcig7dGhpcy5jb3VudCsrPHRoaXMubWF4Q291bnQ7KXtsZXQgZT1hd2FpdCB0aGlzLnVwc3RyZWFtLm5leHQoKTtpZihlLmRvbmUpcmV0dXJuIGU7RWUoZS52YWx1ZSl9cmV0dXJuIHRoaXMudXBzdHJlYW0ubmV4dCgpfX0sejU9Y2xhc3MgZXh0ZW5kcyBzbntjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKCksdGhpcy51cHN0cmVhbT1lLHRoaXMubWF4Q291bnQ9dCx0aGlzLmNvdW50PTB9c3VtbWFyeSgpe3JldHVybmAke3RoaXMudXBzdHJlYW0uc3VtbWFyeSgpfSAtPiBUYWtlYH1hc3luYyBuZXh0KCl7cmV0dXJuIHRoaXMuY291bnQrKz49dGhpcy5tYXhDb3VudD97dmFsdWU6bnVsbCxkb25lOiEwfTp0aGlzLnVwc3RyZWFtLm5leHQoKX19LFc1PWNsYXNzIGV4dGVuZHMgc257Y29uc3RydWN0b3IoZSx0LG49ITApe3N1cGVyKCksdGhpcy51cHN0cmVhbT1lLHRoaXMuYmF0Y2hTaXplPXQsdGhpcy5lbmFibGVTbWFsbExhc3RCYXRjaD1uLHRoaXMubGFzdFJlYWQ9UHJvbWlzZS5yZXNvbHZlKHt2YWx1ZTpudWxsLGRvbmU6ITF9KX1zdW1tYXJ5KCl7cmV0dXJuYCR7dGhpcy51cHN0cmVhbS5zdW1tYXJ5KCl9IC0+IFJvd01ham9yQmF0Y2hgfWFzeW5jIG5leHQoKXtyZXR1cm4gdGhpcy5sYXN0UmVhZD10aGlzLmxhc3RSZWFkLnRoZW4oKCk9PnRoaXMuc2VyaWFsTmV4dCgpKSx0aGlzLmxhc3RSZWFkfWFzeW5jIHNlcmlhbE5leHQoKXtsZXQgZT1bXTtmb3IoO2UubGVuZ3RoPHRoaXMuYmF0Y2hTaXplOyl7bGV0IHQ9YXdhaXQgdGhpcy51cHN0cmVhbS5uZXh0KCk7aWYodC5kb25lKXJldHVybiB0aGlzLmVuYWJsZVNtYWxsTGFzdEJhdGNoJiZlLmxlbmd0aD4wP3t2YWx1ZTplLGRvbmU6ITF9Ont2YWx1ZTpudWxsLGRvbmU6ITB9O2UucHVzaCh0LnZhbHVlKX1yZXR1cm57dmFsdWU6ZSxkb25lOiExfX19LEI1PWNsYXNzIGV4dGVuZHMgc257Y29uc3RydWN0b3IoZSx0KXtzdXBlcigpLHRoaXMudXBzdHJlYW09ZSx0aGlzLnByZWRpY2F0ZT10LHRoaXMubGFzdFJlYWQ9UHJvbWlzZS5yZXNvbHZlKHt2YWx1ZTpudWxsLGRvbmU6ITF9KX1zdW1tYXJ5KCl7cmV0dXJuYCR7dGhpcy51cHN0cmVhbS5zdW1tYXJ5KCl9IC0+IEZpbHRlcmB9YXN5bmMgbmV4dCgpe3JldHVybiB0aGlzLmxhc3RSZWFkPXRoaXMubGFzdFJlYWQudGhlbigoKT0+dGhpcy5zZXJpYWxOZXh0KCkpLHRoaXMubGFzdFJlYWR9YXN5bmMgc2VyaWFsTmV4dCgpe2Zvcig7Oyl7bGV0IGU9YXdhaXQgdGhpcy51cHN0cmVhbS5uZXh0KCk7aWYoZS5kb25lfHx0aGlzLnByZWRpY2F0ZShlLnZhbHVlKSlyZXR1cm4gZTtFZShlLnZhbHVlKX19fSxWNT1jbGFzcyBleHRlbmRzIHNue2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoKSx0aGlzLnVwc3RyZWFtPWUsdGhpcy50cmFuc2Zvcm09dH1zdW1tYXJ5KCl7cmV0dXJuYCR7dGhpcy51cHN0cmVhbS5zdW1tYXJ5KCl9IC0+IE1hcGB9YXN5bmMgbmV4dCgpe2xldCBlPWF3YWl0IHRoaXMudXBzdHJlYW0ubmV4dCgpO2lmKGUuZG9uZSlyZXR1cm57dmFsdWU6bnVsbCxkb25lOiEwfTtsZXQgdD1XYS5nZXRUZW5zb3JzSW5Db250YWluZXIoZS52YWx1ZSksbj10aGlzLnRyYW5zZm9ybShlLnZhbHVlKSxhPVdhLmdldFRlbnNvcnNJbkNvbnRhaW5lcihuKTtmb3IobGV0IHIgb2YgdClXYS5pc1RlbnNvckluTGlzdChyLGEpfHxyLmRpc3Bvc2UoKTtyZXR1cm57dmFsdWU6bixkb25lOiExfX19LFU1PWNsYXNzIGV4dGVuZHMgc257Y29uc3RydWN0b3IoZSx0KXtzdXBlcigpLHRoaXMudXBzdHJlYW09ZSx0aGlzLmhhbmRsZXI9dCx0aGlzLmNvdW50PTAsdGhpcy5sYXN0UmVhZD1Qcm9taXNlLnJlc29sdmUoe3ZhbHVlOm51bGwsZG9uZTohMX0pfXN1bW1hcnkoKXtyZXR1cm5gJHt0aGlzLnVwc3RyZWFtLnN1bW1hcnkoKX0gLT4gaGFuZGxlRXJyb3JzYH1hc3luYyBuZXh0KCl7cmV0dXJuIHRoaXMubGFzdFJlYWQ9dGhpcy5sYXN0UmVhZC50aGVuKCgpPT50aGlzLnNlcmlhbE5leHQoKSksdGhpcy5sYXN0UmVhZH1hc3luYyBzZXJpYWxOZXh0KCl7Zm9yKDs7KXRyeXtyZXR1cm4gYXdhaXQgdGhpcy51cHN0cmVhbS5uZXh0KCl9Y2F0Y2goZSl7aWYoIXRoaXMuaGFuZGxlcihlKSlyZXR1cm57dmFsdWU6bnVsbCxkb25lOiEwfX19fSxxST1jbGFzcyBleHRlbmRzIHNue2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoKSx0aGlzLnVwc3RyZWFtPWUsdGhpcy50cmFuc2Zvcm09dH1zdW1tYXJ5KCl7cmV0dXJuYCR7dGhpcy51cHN0cmVhbS5zdW1tYXJ5KCl9IC0+IEFzeW5jTWFwYH1hc3luYyBuZXh0KCl7bGV0IGU9YXdhaXQgdGhpcy51cHN0cmVhbS5uZXh0KCk7aWYoZS5kb25lKXJldHVybnt2YWx1ZTpudWxsLGRvbmU6ITB9O2xldCB0PVdhLmdldFRlbnNvcnNJbkNvbnRhaW5lcihlLnZhbHVlKSxuPWF3YWl0IHRoaXMudHJhbnNmb3JtKGUudmFsdWUpLGE9V2EuZ2V0VGVuc29yc0luQ29udGFpbmVyKG4pO2ZvcihsZXQgciBvZiB0KVdhLmlzVGVuc29ySW5MaXN0KHIsYSl8fHIuZGlzcG9zZSgpO3JldHVybnt2YWx1ZTpuLGRvbmU6ITF9fX0sRDE9Y2xhc3MgZXh0ZW5kcyBzbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5vdXRwdXRRdWV1ZT1uZXcgaEUsdGhpcy5sYXN0UmVhZD1Qcm9taXNlLnJlc29sdmUoe3ZhbHVlOm51bGwsZG9uZTohMX0pfWFzeW5jIG5leHQoKXtyZXR1cm4gdGhpcy5sYXN0UmVhZD10aGlzLmxhc3RSZWFkLnRoZW4oKCk9PnRoaXMuc2VyaWFsTmV4dCgpKSx0aGlzLmxhc3RSZWFkfWFzeW5jIHNlcmlhbE5leHQoKXtmb3IoO3RoaXMub3V0cHV0UXVldWUubGVuZ3RoKCk9PT0wOylpZighYXdhaXQgdGhpcy5wdW1wKCkpcmV0dXJue3ZhbHVlOm51bGwsZG9uZTohMH07cmV0dXJue3ZhbHVlOnRoaXMub3V0cHV0UXVldWUuc2hpZnQoKSxkb25lOiExfX19LEc1PWNsYXNzIGV4dGVuZHMgRDF7Y29uc3RydWN0b3IoZSx0KXtzdXBlcigpLHRoaXMudXBzdHJlYW09ZSx0aGlzLnRyYW5zZm9ybT10fXN1bW1hcnkoKXtyZXR1cm5gJHt0aGlzLnVwc3RyZWFtLnN1bW1hcnkoKX0gLT4gRmxhdG1hcGB9YXN5bmMgcHVtcCgpe2xldCBlPWF3YWl0IHRoaXMudXBzdHJlYW0ubmV4dCgpO2lmKGUuZG9uZSlyZXR1cm4hMTtsZXQgdD1XYS5nZXRUZW5zb3JzSW5Db250YWluZXIoZS52YWx1ZSksbj10aGlzLnRyYW5zZm9ybShlLnZhbHVlKSxhPVdhLmdldFRlbnNvcnNJbkNvbnRhaW5lcihuKTt0aGlzLm91dHB1dFF1ZXVlLnB1c2hBbGwobik7Zm9yKGxldCByIG9mIHQpV2EuaXNUZW5zb3JJbkxpc3QocixhKXx8ci5kaXNwb3NlKCk7cmV0dXJuITB9fSxnRT1jbGFzcyBleHRlbmRzIHNue2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoKSx0aGlzLmJhc2VFcnJvckhhbmRsZXI9dCx0aGlzLmxhc3RSZWFkPW51bGwsdGhpcy5pdGVyYXRvcj1udWxsLHRoaXMubW9yZUl0ZXJhdG9ycz1lfXN1bW1hcnkoKXtyZXR1cm5cIlRPRE86IGZpbGwgaW4gdXBzdHJlYW0gb2YgY2hhaW5lZCBzdW1tYXJpZXMgLT4gQ2hhaW5lZFwifWFzeW5jIG5leHQoKXtyZXR1cm4gdGhpcy5sYXN0UmVhZD10aGlzLnJlYWRGcm9tQ2hhaW4odGhpcy5sYXN0UmVhZCksdGhpcy5sYXN0UmVhZH1hc3luYyByZWFkRnJvbUNoYWluKGUpe2lmKGF3YWl0IGUsdGhpcy5pdGVyYXRvcj09bnVsbCl7bGV0IG49YXdhaXQgdGhpcy5tb3JlSXRlcmF0b3JzLm5leHQoKTtpZihuLmRvbmUpcmV0dXJue3ZhbHVlOm51bGwsZG9uZTohMH07dGhpcy5pdGVyYXRvcj1uLnZhbHVlLHRoaXMuYmFzZUVycm9ySGFuZGxlciE9bnVsbCYmKHRoaXMuaXRlcmF0b3I9dGhpcy5pdGVyYXRvci5oYW5kbGVFcnJvcnModGhpcy5iYXNlRXJyb3JIYW5kbGVyKSl9bGV0IHQ9YXdhaXQgdGhpcy5pdGVyYXRvci5uZXh0KCk7cmV0dXJuIHQuZG9uZT8odGhpcy5pdGVyYXRvcj1udWxsLHRoaXMucmVhZEZyb21DaGFpbihlKSk6dH19LGVzOyhmdW5jdGlvbihlKXtlW2UuRkFJTD0wXT1cIkZBSUxcIixlW2UuU0hPUlRFU1Q9MV09XCJTSE9SVEVTVFwiLGVbZS5MT05HRVNUPTJdPVwiTE9OR0VTVFwifSkoZXN8fChlcz17fSkpO3ZhciBINT1jbGFzcyBleHRlbmRzIHNue2NvbnN0cnVjdG9yKGUsdD1lcy5GQUlMKXtzdXBlcigpLHRoaXMuaXRlcmF0b3JzPWUsdGhpcy5taXNtYXRjaE1vZGU9dCx0aGlzLmNvdW50PTAsdGhpcy5jdXJyZW50UHJvbWlzZT1udWxsfXN1bW1hcnkoKXtyZXR1cm5cIntUT0RPOiBmaWxsIGluIHVwc3RyZWFtIG9mIHppcCBzdW1tYXJpZXN9IC0+IFppcFwifWFzeW5jIG5leHRTdGF0ZShlKXthd2FpdCBlO2xldCB0PTAsbj0wO2Z1bmN0aW9uIGEocyl7cmV0dXJuIHMgaW5zdGFuY2VvZiBzbj97dmFsdWU6cy5uZXh0KCkudGhlbihpPT4odCsrLGkuZG9uZSYmbisrLGkudmFsdWUpKSxyZWN1cnNlOiExfTp7dmFsdWU6bnVsbCxyZWN1cnNlOiEwfX1sZXQgcj1hd2FpdCBjRSh0aGlzLml0ZXJhdG9ycyxhKTtpZih0PT09bilyZXR1cm57dmFsdWU6bnVsbCxkb25lOiEwfTtpZihuPjApc3dpdGNoKHRoaXMubWlzbWF0Y2hNb2RlKXtjYXNlIGVzLkZBSUw6dGhyb3cgbmV3IEVycm9yKGBaaXBwZWQgc3RyZWFtcyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBsZW5ndGguIE1pc21hdGNoZWQgYXQgZWxlbWVudCAke3RoaXMuY291bnR9LmApO2Nhc2UgZXMuU0hPUlRFU1Q6cmV0dXJue3ZhbHVlOm51bGwsZG9uZTohMH07Y2FzZSBlcy5MT05HRVNUOmRlZmF1bHQ6fXJldHVybiB0aGlzLmNvdW50Kysse3ZhbHVlOnIsZG9uZTohMX19YXN5bmMgbmV4dCgpe3JldHVybiB0aGlzLmN1cnJlbnRQcm9taXNlPXRoaXMubmV4dFN0YXRlKHRoaXMuY3VycmVudFByb21pc2UpLHRoaXMuY3VycmVudFByb21pc2V9fSxiRT1jbGFzcyBleHRlbmRzIHNue2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoKSx0aGlzLnVwc3RyZWFtPWUsdGhpcy5idWZmZXJTaXplPXQsdGhpcy5idWZmZXI9bmV3IGRFKHQpfXN1bW1hcnkoKXtyZXR1cm5gJHt0aGlzLnVwc3RyZWFtLnN1bW1hcnkoKX0gLT4gUHJlZmV0Y2hgfXJlZmlsbCgpe2Zvcig7IXRoaXMuYnVmZmVyLmlzRnVsbCgpOyl7bGV0IGU9dGhpcy51cHN0cmVhbS5uZXh0KCk7dGhpcy5idWZmZXIucHVzaChlKX19bmV4dCgpe3JldHVybiB0aGlzLnJlZmlsbCgpLHRoaXMuYnVmZmVyLnNoaWZ0KCl9fSxqNT1jbGFzcyBleHRlbmRzIGJFe2NvbnN0cnVjdG9yKGUsdCxuKXtzdXBlcihlLHQpLHRoaXMudXBzdHJlYW09ZSx0aGlzLndpbmRvd1NpemU9dCx0aGlzLnVwc3RyZWFtRXhoYXVzdGVkPSExLHRoaXMucmFuZG9tPVQ1LmFsZWEobnx8dy5ub3coKS50b1N0cmluZygpKSx0aGlzLmxhc3RSZWFkPVByb21pc2UucmVzb2x2ZSh7dmFsdWU6bnVsbCxkb25lOiExfSl9YXN5bmMgbmV4dCgpe3JldHVybiB0aGlzLmxhc3RSZWFkPXRoaXMubGFzdFJlYWQudGhlbigoKT0+dGhpcy5zZXJpYWxOZXh0KCkpLHRoaXMubGFzdFJlYWR9cmFuZG9tSW50KGUpe3JldHVybiBNYXRoLmZsb29yKHRoaXMucmFuZG9tKCkqZSl9Y2hvb3NlSW5kZXgoKXtyZXR1cm4gdGhpcy5yYW5kb21JbnQodGhpcy5idWZmZXIubGVuZ3RoKCkpfWFzeW5jIHNlcmlhbE5leHQoKXtmb3IodGhpcy51cHN0cmVhbUV4aGF1c3RlZHx8dGhpcy5yZWZpbGwoKTshdGhpcy5idWZmZXIuaXNFbXB0eSgpOyl7bGV0IGU9dGhpcy5jaG9vc2VJbmRleCgpLHQ9YXdhaXQgdGhpcy5idWZmZXIuc2h1ZmZsZUV4Y2lzZShlKTtpZih0LmRvbmUpdGhpcy51cHN0cmVhbUV4aGF1c3RlZD0hMDtlbHNlIHJldHVybiB0aGlzLnJlZmlsbCgpLHR9cmV0dXJue3ZhbHVlOm51bGwsZG9uZTohMH19fSxpcD1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuc2l6ZT1udWxsfWJhdGNoKGUsdD0hMCl7bGV0IG49dGhpczt3LmFzc2VydChlPjAsKCk9PmBiYXRjaFNpemUgbmVlZHMgdG8gYmUgcG9zaXRpdmUsIGJ1dCBpdCBpc1xuICAgICAgJHtlfWApO2xldCBhO3JldHVybiB0aGlzLnNpemU9PT0xLzB8fHRoaXMuc2l6ZT09bnVsbD9hPXRoaXMuc2l6ZTp0P2E9TWF0aC5jZWlsKHRoaXMuc2l6ZS9lKTphPU1hdGguZmxvb3IodGhpcy5zaXplL2UpLEtuKGFzeW5jKCk9Pihhd2FpdCBuLml0ZXJhdG9yKCkpLmNvbHVtbk1ham9yQmF0Y2goZSx0LFg1KSxhKX1jb25jYXRlbmF0ZShlKXtsZXQgdD10aGlzLG47cmV0dXJuIHRoaXMuc2l6ZT09PTEvMHx8ZS5zaXplPT09MS8wP249MS8wOnRoaXMuc2l6ZSE9bnVsbCYmZS5zaXplIT1udWxsP249dGhpcy5zaXplK2Uuc2l6ZTpuPW51bGwsS24oYXN5bmMoKT0+KGF3YWl0IHQuaXRlcmF0b3IoKSkuY29uY2F0ZW5hdGUoYXdhaXQgZS5pdGVyYXRvcigpKSxuKX1maWx0ZXIoZSl7bGV0IHQ9dGhpcyxuO3JldHVybiB0aGlzLnNpemU9PT0xLzA/bj0xLzA6bj1udWxsLEtuKGFzeW5jKCk9Pihhd2FpdCB0Lml0ZXJhdG9yKCkpLmZpbHRlcihhPT5PKCgpPT5lKGEpKSksbil9YXN5bmMgZm9yRWFjaEFzeW5jKGUpe3JldHVybihhd2FpdCB0aGlzLml0ZXJhdG9yKCkpLmZvckVhY2hBc3luYyhlKX1tYXAoZSl7bGV0IHQ9dGhpcztyZXR1cm4gS24oYXN5bmMoKT0+KGF3YWl0IHQuaXRlcmF0b3IoKSkubWFwKG49Pk8oKCk9PmUobikpKSx0aGlzLnNpemUpfW1hcEFzeW5jKGUpe2xldCB0PXRoaXM7cmV0dXJuIEtuKGFzeW5jKCk9Pihhd2FpdCB0Lml0ZXJhdG9yKCkpLm1hcEFzeW5jKGUpLHRoaXMuc2l6ZSl9cHJlZmV0Y2goZSl7aWYoZT09bnVsbCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImBEYXRhc2V0LnByZWZldGNoKClgIHJlcXVpcmVzIGJ1ZmZlclNpemUgdG8gYmUgc3BlY2lmaWVkLlwiKTtsZXQgdD10aGlzO3JldHVybiBLbihhc3luYygpPT4oYXdhaXQgdC5pdGVyYXRvcigpKS5wcmVmZXRjaChlKSx0aGlzLnNpemUpfXJlcGVhdChlKXtsZXQgdD10aGlzLG47cmV0dXJuIHRoaXMuc2l6ZSE9bnVsbCYmZT4wP249dGhpcy5zaXplKmU6ZT09PTA/bj0wOnRoaXMuc2l6ZSE9bnVsbCYmKGU9PT12b2lkIDB8fGU8MCk/bj0xLzA6bj1udWxsLEtuKGFzeW5jKCk9PntsZXQgYT0kMShhc3luYygpPT4oe3ZhbHVlOmF3YWl0IHQuaXRlcmF0b3IoKSxkb25lOiExfSkpO3JldHVybiBENShhLnRha2UoZSkpfSxuKX1za2lwKGUpe2xldCB0PXRoaXMsbjtyZXR1cm4gdGhpcy5zaXplIT1udWxsJiZlPj0wJiZ0aGlzLnNpemU+PWU/bj10aGlzLnNpemUtZTp0aGlzLnNpemUhPW51bGwmJih0aGlzLnNpemU8ZXx8ZT09PXZvaWQgMHx8ZTwwKT9uPTA6bj1udWxsLEtuKGFzeW5jKCk9Pihhd2FpdCB0Lml0ZXJhdG9yKCkpLnNraXAoZSksbil9c2h1ZmZsZShlLHQsbj0hMCl7aWYoZT09bnVsbHx8ZTwwKXRocm93IHRoaXMuc2l6ZT09bnVsbD9uZXcgUmFuZ2VFcnJvcihcImBEYXRhc2V0LnNodWZmbGUoKWAgcmVxdWlyZXMgYnVmZmVyU2l6ZSB0byBiZSBzcGVjaWZpZWQuXCIpOm5ldyBSYW5nZUVycm9yKGBcXGBEYXRhc2V0LnNodWZmbGUoKVxcYCByZXF1aXJlcyBidWZmZXJTaXplIHRvIGJlIHNwZWNpZmllZC4gIElmIHlvdXIgZGF0YSBmaXRzIGluIG1haW4gbWVtb3J5IChmb3IgcmVndWxhciBKUyBvYmplY3RzKSwgYW5kL29yIEdQVSBtZW1vcnkgKGZvciBcXGB0Zi5UZW5zb3JcXGBzKSwgY29uc2lkZXIgc2V0dGluZyBidWZmZXJTaXplIHRvIHRoZSBkYXRhc2V0IHNpemUgKCR7dGhpcy5zaXplfSBlbGVtZW50cylgKTtsZXQgYT10aGlzLHI9TjUuYWxlYSh0fHx3Lm5vdygpLnRvU3RyaW5nKCkpO3JldHVybiBLbihhc3luYygpPT57bGV0IHM9ci5pbnQzMigpO3JldHVybiBuJiYocys9ci5pbnQzMigpKSwoYXdhaXQgYS5pdGVyYXRvcigpKS5zaHVmZmxlKGUscy50b1N0cmluZygpKX0sdGhpcy5zaXplKX10YWtlKGUpe2xldCB0PXRoaXMsbjtyZXR1cm4gdGhpcy5zaXplIT1udWxsJiZ0aGlzLnNpemU+ZT9uPWU6dGhpcy5zaXplIT1udWxsJiZ0aGlzLnNpemU8PWU/bj10aGlzLnNpemU6bj1udWxsLEtuKGFzeW5jKCk9Pihhd2FpdCB0Lml0ZXJhdG9yKCkpLnRha2UoZSksbil9YXN5bmMgdG9BcnJheSgpe2lmKHRoaXMuc2l6ZT09PTEvMCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGNvbnZlcnQgaW5maW5pdGUgZGF0YSBzdHJlYW0gdG8gYXJyYXkuXCIpO3JldHVybihhd2FpdCB0aGlzLml0ZXJhdG9yKCkpLnRvQXJyYXkoKX1hc3luYyB0b0FycmF5Rm9yVGVzdCgpe2lmKHRoaXMuc2l6ZT09PTEvMCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGNvbnZlcnQgaW5maW5pdGUgZGF0YSBzdHJlYW0gdG8gYXJyYXkuXCIpO3JldHVybihhd2FpdCB0aGlzLml0ZXJhdG9yKCkpLnRvQXJyYXlGb3JUZXN0KCl9fTtpcC5NQVhfQlVGRkVSX1NJWkU9MWU0O2Z1bmN0aW9uIEtuKGUsdD1udWxsKXtyZXR1cm4gbmV3IGNsYXNzIGV4dGVuZHMgaXB7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMuc2l6ZT10fWFzeW5jIGl0ZXJhdG9yKCl7cmV0dXJuIGUoKX19fWZ1bmN0aW9uIHE1KGUpe3JldHVybiBLbihhc3luYygpPT5mRShlKSxlLmxlbmd0aCl9ZnVuY3Rpb24gSzUoZSl7aWYoIUhsKGUpKXRocm93IG5ldyBFcnJvcihcIlRoZSBhcmd1bWVudCB0byB6aXAoKSBtdXN0IGJlIGFuIG9iamVjdCBvciBhcnJheS5cIik7bGV0IHQ7aWYoQXJyYXkuaXNBcnJheShlKSlmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyl0PXQ9PW51bGw/ZVtuXS5zaXplOk1hdGgubWluKHQsZVtuXS5zaXplKTtlbHNlIGlmKGUgaW5zdGFuY2VvZiBPYmplY3QpZm9yKGxldCBuIGluIGUpdD10PT1udWxsP2Vbbl0uc2l6ZTpNYXRoLm1pbih0LGVbbl0uc2l6ZSk7cmV0dXJuIEtuKGFzeW5jKCk9PntsZXQgbj1hd2FpdCBjRShlLGE9PntpZihhIGluc3RhbmNlb2YgaXApcmV0dXJue3ZhbHVlOmEuaXRlcmF0b3IoKSxyZWN1cnNlOiExfTtpZihIbChhKSlyZXR1cm57dmFsdWU6bnVsbCxyZWN1cnNlOiEwfTt0aHJvdyBuZXcgRXJyb3IoXCJMZWF2ZXMgb2YgdGhlIHN0cnVjdHVyZSBwYXNzZWQgdG8gemlwKCkgbXVzdCBiZSBEYXRhc2V0cywgbm90IHByaW1pdGl2ZXMuXCIpfSk7cmV0dXJuIFI1KG4sZXMuU0hPUlRFU1QpfSx0KX1mdW5jdGlvbiBYNShlKXtpZihlPT09bnVsbClyZXR1cm4gbnVsbDtsZXQgdD1lWzBdO3JldHVybiBfNSh0KT97dmFsdWU6WTUoZSkscmVjdXJzZTohMX06e3ZhbHVlOm51bGwscmVjdXJzZTohMH19ZnVuY3Rpb24gWTUoZSl7aWYoZS5sZW5ndGg9PT0wKXRocm93IG5ldyBFcnJvcihcIkNhbid0IG1ha2UgYSBiYXRjaCBvZiB6ZXJvIGVsZW1lbnRzLlwiKTtyZXR1cm4gZVswXWluc3RhbmNlb2YgQ2U/QXQoZSk6Ym4oZSl9dmFyIHlFPWNsYXNzIGV4dGVuZHMgaXB7Y29uc3RydWN0b3IoZSl7c3VwZXIoKSx0aGlzLmlucHV0PWV9YXN5bmMgaXRlcmF0b3IoKXtyZXR1cm4oYXdhaXQgdGhpcy5pbnB1dC5pdGVyYXRvcigpKS5kZWNvZGVVVEY4KCkuc3BsaXQoYFxuYCkubWFwKGU9PihlLmVuZHNXaXRoKFwiXFxyXCIpJiYoZT1lLnNsaWNlKDAsLTEpKSxlKSl9fSxDaD0nXCInLEpwPVN5bWJvbChcIm91dFwiKSxLST1TeW1ib2woXCJmaWVsZFwiKSxFaD1TeW1ib2woXCJxdW90ZVwiKSxieD1TeW1ib2woXCJxdW90ZWFmdGVycXVvdGVcIiksWEk9U3ltYm9sKFwicXVvdGVpbnF1b3RlXCIpLHhFPWNsYXNzIGV4dGVuZHMgaXB7YXN5bmMgY29sdW1uTmFtZXMoKXtyZXR1cm4gdGhpcy5jb2x1bW5OYW1lc1ZhbGlkYXRlZHx8YXdhaXQgdGhpcy5zZXRDb2x1bW5OYW1lcygpLHRoaXMuY29uZmlndXJlZENvbHVtbnNPbmx5P09iamVjdC5rZXlzKHRoaXMuY29sdW1uQ29uZmlncyk6dGhpcy5mdWxsQ29sdW1uTmFtZXN9YXN5bmMgc2V0Q29sdW1uTmFtZXMoKXtsZXQgZT1hd2FpdCB0aGlzLm1heWJlUmVhZEhlYWRlckxpbmUoKTtpZighdGhpcy5mdWxsQ29sdW1uTmFtZXMmJiFlKXRocm93IG5ldyBFcnJvcihcIkNvbHVtbiBuYW1lcyBtdXN0IGJlIHByb3ZpZGVkIGlmIHRoZXJlIGlzIG5vIGhlYWRlciBsaW5lLlwiKTt0aGlzLmZ1bGxDb2x1bW5OYW1lcyYmZSYmdy5hc3NlcnQoZS5sZW5ndGg9PT10aGlzLmZ1bGxDb2x1bW5OYW1lcy5sZW5ndGgsKCk9PlwiVGhlIGxlbmd0aCBvZiBwcm92aWRlZCBjb2x1bW5OYW1lcyAoXCIrdGhpcy5mdWxsQ29sdW1uTmFtZXMubGVuZ3RoLnRvU3RyaW5nKCkrXCIpIGRvZXMgbm90IG1hdGNoIHRoZSBsZW5ndGggb2YgdGhlIGhlYWRlciBsaW5lIHJlYWQgZnJvbSBmaWxlIChcIitlLmxlbmd0aC50b1N0cmluZygpK1wiKS5cIiksdGhpcy5mdWxsQ29sdW1uTmFtZXN8fCh0aGlzLmZ1bGxDb2x1bW5OYW1lcz1lKTtsZXQgdD10aGlzLmZ1bGxDb2x1bW5OYW1lcy5yZWR1Y2UoKGEscik9PihhW3JdPWFbcl0rMXx8MSxhKSx7fSksbj1PYmplY3Qua2V5cyh0KS5maWx0ZXIoYT0+dFthXT4xKTtpZih3LmFzc2VydChuLmxlbmd0aD09PTAsKCk9PlwiRHVwbGljYXRlIGNvbHVtbiBuYW1lcyBmb3VuZDogXCIrbi50b1N0cmluZygpKSx0aGlzLmNvbHVtbkNvbmZpZ3Mpe2ZvcihsZXQgYSBvZiBPYmplY3Qua2V5cyh0aGlzLmNvbHVtbkNvbmZpZ3MpKWlmKHRoaXMuZnVsbENvbHVtbk5hbWVzLmluZGV4T2YoYSk9PT0tMSl0aHJvdyBuZXcgRXJyb3IoJ1RoZSBrZXkgXCInK2ErJ1wiIHByb3ZpZGVkIGluIGNvbHVtbkNvbmZpZ3MgZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSBjb2x1bW4gbmFtZXMgKCcrdGhpcy5mdWxsQ29sdW1uTmFtZXMudG9TdHJpbmcoKStcIikuXCIpfXRoaXMuY29sdW1uTmFtZXNWYWxpZGF0ZWQ9ITB9YXN5bmMgbWF5YmVSZWFkSGVhZGVyTGluZSgpe2lmKHRoaXMuaGFzSGVhZGVyKXtsZXQgZT1hd2FpdChhd2FpdCB0aGlzLmJhc2UuaXRlcmF0b3IoKSkubmV4dCgpO2lmKGUuZG9uZSl0aHJvdyBuZXcgRXJyb3IoXCJObyBkYXRhIHdhcyBmb3VuZCBmb3IgQ1NWIHBhcnNpbmcuXCIpO2xldCB0PWUudmFsdWU7cmV0dXJuIHRoaXMucGFyc2VSb3codCwhMSl9ZWxzZSByZXR1cm4gbnVsbH1jb25zdHJ1Y3RvcihlLHQpe3N1cGVyKCksdGhpcy5pbnB1dD1lLHRoaXMuaGFzSGVhZGVyPSEwLHRoaXMuZnVsbENvbHVtbk5hbWVzPW51bGwsdGhpcy5jb2x1bW5OYW1lc1ZhbGlkYXRlZD0hMSx0aGlzLmNvbHVtbkNvbmZpZ3M9bnVsbCx0aGlzLmNvbmZpZ3VyZWRDb2x1bW5zT25seT0hMSx0aGlzLmRlbGltaXRlcj1cIixcIix0aGlzLmRlbGltV2hpdGVzcGFjZT0hMSx0aGlzLmJhc2U9bmV3IHlFKGUpLHR8fCh0PXt9KSx0aGlzLmhhc0hlYWRlcj10Lmhhc0hlYWRlciE9PSExLHRoaXMuZnVsbENvbHVtbk5hbWVzPXQuY29sdW1uTmFtZXMsdGhpcy5jb2x1bW5Db25maWdzPXQuY29sdW1uQ29uZmlncyx0aGlzLmNvbmZpZ3VyZWRDb2x1bW5zT25seT10LmNvbmZpZ3VyZWRDb2x1bW5zT25seSx0LmRlbGltV2hpdGVzcGFjZT8ody5hc3NlcnQodC5kZWxpbWl0ZXI9PW51bGwsKCk9PlwiRGVsaW1pdGVyIHNob3VsZCBub3QgYmUgcHJvdmlkZWQgd2hlbiBkZWxpbVdoaXRlc3BhY2UgaXMgdHJ1ZS5cIiksdGhpcy5kZWxpbVdoaXRlc3BhY2U9ITAsdGhpcy5kZWxpbWl0ZXI9XCIgXCIpOnRoaXMuZGVsaW1pdGVyPXQuZGVsaW1pdGVyP3QuZGVsaW1pdGVyOlwiLFwifWFzeW5jIGl0ZXJhdG9yKCl7dGhpcy5jb2x1bW5OYW1lc1ZhbGlkYXRlZHx8YXdhaXQgdGhpcy5zZXRDb2x1bW5OYW1lcygpO2xldCBlPWF3YWl0IHRoaXMuYmFzZS5pdGVyYXRvcigpO3JldHVybiB0aGlzLmhhc0hlYWRlciYmKGU9ZS5za2lwKDEpKSxlLm1hcCh0PT50aGlzLm1ha2VEYXRhRWxlbWVudCh0KSl9bWFrZURhdGFFbGVtZW50KGUpe2xldCB0PXRoaXMucGFyc2VSb3coZSksbj17fSxhPXt9O2ZvcihsZXQgcj0wO3I8dGhpcy5mdWxsQ29sdW1uTmFtZXMubGVuZ3RoO3IrKyl7bGV0IHM9dGhpcy5mdWxsQ29sdW1uTmFtZXNbcl0saT10aGlzLmNvbHVtbkNvbmZpZ3M/dGhpcy5jb2x1bW5Db25maWdzW3NdOm51bGw7aWYoISh0aGlzLmNvbmZpZ3VyZWRDb2x1bW5zT25seSYmIWkpKXtsZXQgbz10W3JdLGw9bnVsbDtpZihvPT09XCJcIilpZihpJiZpLmRlZmF1bHQhPT12b2lkIDApbD1pLmRlZmF1bHQ7ZWxzZXtpZihpJiYoaS5yZXF1aXJlZHx8aS5pc0xhYmVsKSl0aHJvdyBuZXcgRXJyb3IoYFJlcXVpcmVkIGNvbHVtbiAke3N9IGlzIGVtcHR5IGluIHRoaXMgbGluZTogJHtlfWApO2w9dm9pZCAwfWVsc2V7bGV0IHU9TnVtYmVyKG8pO2lmKGlzTmFOKHUpKWkmJmkuZHR5cGU9PT1cImJvb2xcIj9sPXRoaXMuZ2V0Qm9vbGVhbihvKTpsPW87ZWxzZSBpZighaXx8IWkuZHR5cGUpbD11O2Vsc2Ugc3dpdGNoKGkuZHR5cGUpe2Nhc2VcImZsb2F0MzJcIjpsPXU7YnJlYWs7Y2FzZVwiaW50MzJcIjpsPU1hdGguZmxvb3IodSk7YnJlYWs7Y2FzZVwiYm9vbFwiOmw9dGhpcy5nZXRCb29sZWFuKG8pO2JyZWFrO2RlZmF1bHQ6bD11fX1pJiZpLmlzTGFiZWw/YVtzXT1sOm5bc109bH19cmV0dXJuIE9iamVjdC5rZXlzKGEpLmxlbmd0aD09PTA/bjp7eHM6bix5czphfX1nZXRCb29sZWFuKGUpe3JldHVybiBlPT09XCIxXCJ8fGUudG9Mb3dlckNhc2UoKT09PVwidHJ1ZVwiPzE6MH1wYXJzZVJvdyhlLHQ9ITApe2xldCBuPVtdLGE9MCxyPWUubGVuZ3RoLHM9SnA7Zm9yKGxldCBpPTA7aTxyO2krKylzd2l0Y2gocyl7Y2FzZSBKcDpzd2l0Y2goZS5jaGFyQXQoaSkpe2Nhc2UgQ2g6YT1pKzEscz1FaDticmVhaztjYXNlIHRoaXMuZGVsaW1pdGVyOmlmKGE9aSsxLHRoaXMuZGVsaW1pdGVyPT09XCIgXCImJnRoaXMuZGVsaW1XaGl0ZXNwYWNlKWJyZWFrO24ucHVzaChcIlwiKSxzPUpwO2JyZWFrO2RlZmF1bHQ6cz1LSSxhPWk7YnJlYWt9YnJlYWs7Y2FzZSBLSTpzd2l0Y2goZS5jaGFyQXQoaSkpe2Nhc2UgdGhpcy5kZWxpbWl0ZXI6bi5wdXNoKGUuc3Vic3RyaW5nKGEsaSkpLHM9SnAsYT1pKzE7YnJlYWs7ZGVmYXVsdDp9YnJlYWs7Y2FzZSBFaDpzd2l0Y2goZS5jaGFyQXQoaSkpe2Nhc2UgQ2g6cz1ieDticmVhaztkZWZhdWx0On1icmVhaztjYXNlIGJ4OnN3aXRjaChlLmNoYXJBdChpKSl7Y2FzZSB0aGlzLmRlbGltaXRlcjpuLnB1c2goZS5zdWJzdHJpbmcoYSxpLTEpKSxzPUpwLGE9aSsxO2JyZWFrO2Nhc2UgQ2g6cz1FaDticmVhaztkZWZhdWx0OnM9WEk7YnJlYWt9YnJlYWs7Y2FzZSBYSTpzd2l0Y2goZS5jaGFyQXQoaSkpe2Nhc2UgQ2g6cz1FaDticmVhaztkZWZhdWx0On1icmVhaztkZWZhdWx0On1pZihzPT09Yng/bi5wdXNoKGUuc3Vic3RyaW5nKGEsci0xKSk6bi5wdXNoKGUuc3Vic3RyaW5nKGEpKSx0JiZuLmxlbmd0aCE9PXRoaXMuZnVsbENvbHVtbk5hbWVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcm93IGluIGNzdiBmaWxlLiBTaG91bGQgaGF2ZSAke3RoaXMuZnVsbENvbHVtbk5hbWVzLmxlbmd0aH0gZWxlbWVudHMgaW4gYSByb3csIGJ1dCBnb3QgJHtufWApO3JldHVybiBufX0sWjU9Y2xhc3MgdkUgZXh0ZW5kcyBzbntjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMubWljcm9waG9uZUNvbmZpZz10LHRoaXMuaXNDbG9zZWQ9ITEsdGhpcy5mZnRTaXplPXQuZmZ0U2l6ZXx8MTAyNDtsZXQgbj1NYXRoLmxvZzIodGhpcy5mZnRTaXplKTtpZih0aGlzLmZmdFNpemU8MHx8bjw0fHxuPjE0fHwhTnVtYmVyLmlzSW50ZWdlcihuKSl0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmZ0U2l6ZTogaXQgbXVzdCBiZSBhIHBvd2VyIG9mIDIgYmV0d2VlbiAyIHRvIDQgYW5kIDIgdG8gMTQsIGJ1dCBnb3QgJHt0aGlzLmZmdFNpemV9YCk7aWYodGhpcy5udW1GcmFtZXM9dC5udW1GcmFtZXNQZXJTcGVjdHJvZ3JhbXx8NDMsdGhpcy5zYW1wbGVSYXRlSHo9dC5zYW1wbGVSYXRlSHosdGhpcy5jb2x1bW5UcnVuY2F0ZUxlbmd0aD10LmNvbHVtblRydW5jYXRlTGVuZ3RofHx0aGlzLmZmdFNpemUsdGhpcy5hdWRpb1RyYWNrQ29uc3RyYWludHM9dC5hdWRpb1RyYWNrQ29uc3RyYWludHMsdGhpcy5zbW9vdGhpbmdUaW1lQ29uc3RhbnQ9dC5zbW9vdGhpbmdUaW1lQ29uc3RhbnR8fDAsdGhpcy5pbmNsdWRlU3BlY3Ryb2dyYW09dC5pbmNsdWRlU3BlY3Ryb2dyYW0hPT0hMSx0aGlzLmluY2x1ZGVXYXZlZm9ybT10LmluY2x1ZGVXYXZlZm9ybT09PSEwLCF0aGlzLmluY2x1ZGVTcGVjdHJvZ3JhbSYmIXRoaXMuaW5jbHVkZVdhdmVmb3JtKXRocm93IG5ldyBFcnJvcihcIkJvdGggaW5jbHVkZVNwZWN0cm9ncmFtIGFuZCBpbmNsdWRlV2F2ZWZvcm0gYXJlIGZhbHNlLiBBdCBsZWFzdCBvbmUgdHlwZSBvZiBkYXRhIHNob3VsZCBiZSByZXR1cm5lZC5cIil9c3VtbWFyeSgpe3JldHVyblwibWljcm9waG9uZVwifXN0YXRpYyBhc3luYyBjcmVhdGUodD17fSl7aWYoIUcoKS5nZXQoXCJJU19CUk9XU0VSXCIpKXRocm93IG5ldyBFcnJvcihcIm1pY3JvcGhvbmUgQVBJIGlzIG9ubHkgc3VwcG9ydGVkIGluIGJyb3dzZXIgZW52aXJvbm1lbnQuXCIpO2xldCBuPW5ldyB2RSh0KTtyZXR1cm4gYXdhaXQgbi5zdGFydCgpLG59YXN5bmMgc3RhcnQoKXt0cnl7dGhpcy5zdHJlYW09YXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe2F1ZGlvOnRoaXMuYXVkaW9UcmFja0NvbnN0cmFpbnRzPT1udWxsPyEwOnRoaXMuYXVkaW9UcmFja0NvbnN0cmFpbnRzLHZpZGVvOiExfSl9Y2F0Y2goYSl7dGhyb3cgbmV3IEVycm9yKGBFcnJvciB0aHJvd24gd2hpbGUgaW5pdGlhbGl6aW5nIHZpZGVvIHN0cmVhbTogJHthLm1lc3NhZ2V9YCl9aWYoIXRoaXMuc3RyZWFtKXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBvYnRhaW4gYXVkaW8gZnJvbSBtaWNyb3Bob25lLlwiKTtsZXQgdD13aW5kb3cuQXVkaW9Db250ZXh0fHx3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0O2lmKHRoaXMuYXVkaW9Db250ZXh0PW5ldyB0LCF0aGlzLnNhbXBsZVJhdGVIeil0aGlzLnNhbXBsZVJhdGVIej10aGlzLmF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlO2Vsc2UgaWYodGhpcy5hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSE9PXRoaXMuc2FtcGxlUmF0ZUh6KXRocm93IG5ldyBFcnJvcihgTWlzbWF0Y2ggaW4gc2FtcGxpbmcgcmF0ZTogRXhwZWN0ZWQ6ICR7dGhpcy5zYW1wbGVSYXRlSHp9OyBBY3R1YWw6ICR7dGhpcy5hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZX1gKTtsZXQgbj10aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZSh0aGlzLnN0cmVhbSk7dGhpcy5hbmFseXNlcj10aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVBbmFseXNlcigpLHRoaXMuYW5hbHlzZXIuZmZ0U2l6ZT10aGlzLmZmdFNpemUqMix0aGlzLmFuYWx5c2VyLnNtb290aGluZ1RpbWVDb25zdGFudD10aGlzLnNtb290aGluZ1RpbWVDb25zdGFudCxuLmNvbm5lY3QodGhpcy5hbmFseXNlciksdGhpcy5mcmVxRGF0YT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuZmZ0U2l6ZSksdGhpcy50aW1lRGF0YT1uZXcgRmxvYXQzMkFycmF5KHRoaXMuZmZ0U2l6ZSl9YXN5bmMgbmV4dCgpe2lmKHRoaXMuaXNDbG9zZWQpcmV0dXJue3ZhbHVlOm51bGwsZG9uZTohMH07bGV0IHQsbixhPWF3YWl0IHRoaXMuZ2V0QXVkaW9EYXRhKCk7aWYodGhpcy5pbmNsdWRlU3BlY3Ryb2dyYW0pe2xldCByPXRoaXMuZmxhdHRlblF1ZXVlKGEuZnJlcURhdGFRdWV1ZSk7dD10aGlzLmdldFRlbnNvckZyb21BdWRpb0RhdGFBcnJheShyLFt0aGlzLm51bUZyYW1lcyx0aGlzLmNvbHVtblRydW5jYXRlTGVuZ3RoLDFdKX1pZih0aGlzLmluY2x1ZGVXYXZlZm9ybSl7bGV0IHI9dGhpcy5mbGF0dGVuUXVldWUoYS50aW1lRGF0YVF1ZXVlKTtuPXRoaXMuZ2V0VGVuc29yRnJvbUF1ZGlvRGF0YUFycmF5KHIsW3RoaXMubnVtRnJhbWVzKnRoaXMuZmZ0U2l6ZSwxXSl9cmV0dXJue3ZhbHVlOntzcGVjdHJvZ3JhbTp0LHdhdmVmb3JtOm59LGRvbmU6ITF9fWFzeW5jIGNhcHR1cmUoKXtyZXR1cm4oYXdhaXQgdGhpcy5uZXh0KCkpLnZhbHVlfWFzeW5jIGdldEF1ZGlvRGF0YSgpe2xldCB0PVtdLG49W10sYT0wO3JldHVybiBuZXcgUHJvbWlzZShyPT57bGV0IHM9c2V0SW50ZXJ2YWwoKCk9Pnt0aGlzLmluY2x1ZGVTcGVjdHJvZ3JhbSYmKHRoaXMuYW5hbHlzZXIuZ2V0RmxvYXRGcmVxdWVuY3lEYXRhKHRoaXMuZnJlcURhdGEpLHRoaXMuZnJlcURhdGFbMF09PT0tMS8wJiZyKHtmcmVxRGF0YVF1ZXVlOnQsdGltZURhdGFRdWV1ZTpufSksdC5wdXNoKHRoaXMuZnJlcURhdGEuc2xpY2UoMCx0aGlzLmNvbHVtblRydW5jYXRlTGVuZ3RoKSkpLHRoaXMuaW5jbHVkZVdhdmVmb3JtJiYodGhpcy5hbmFseXNlci5nZXRGbG9hdFRpbWVEb21haW5EYXRhKHRoaXMudGltZURhdGEpLG4ucHVzaCh0aGlzLnRpbWVEYXRhLnNsaWNlKCkpKSwrK2E9PT10aGlzLm51bUZyYW1lcyYmKGNsZWFySW50ZXJ2YWwocykscih7ZnJlcURhdGFRdWV1ZTp0LHRpbWVEYXRhUXVldWU6bn0pKX0sdGhpcy5mZnRTaXplL3RoaXMuc2FtcGxlUmF0ZUh6KjFlMyl9KX1zdG9wKCl7dGhpcy5pc0Nsb3NlZHx8KHRoaXMuaXNDbG9zZWQ9ITAsdGhpcy5hbmFseXNlci5kaXNjb25uZWN0KCksdGhpcy5hdWRpb0NvbnRleHQuY2xvc2UoKSx0aGlzLnN0cmVhbSE9bnVsbCYmdGhpcy5zdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoPjAmJnRoaXMuc3RyZWFtLmdldFRyYWNrcygpWzBdLnN0b3AoKSl9dG9BcnJheSgpe3Rocm93IG5ldyBFcnJvcihcIkNhbiBub3QgY29udmVydCBpbmZpbml0ZSBhdWRpbyBzdHJlYW0gdG8gYXJyYXkuXCIpfWdldFNhbXBsZVJhdGUoKXtyZXR1cm4gdGhpcy5zYW1wbGVSYXRlSHp9ZmxhdHRlblF1ZXVlKHQpe2xldCBuPXRbMF0ubGVuZ3RoLGE9bmV3IEZsb2F0MzJBcnJheSh0Lmxlbmd0aCpuKTtyZXR1cm4gdC5mb3JFYWNoKChyLHMpPT5hLnNldChyLHMqbikpLGF9Z2V0VGVuc29yRnJvbUF1ZGlvRGF0YUFycmF5KHQsbil7bGV0IGE9bmV3IEZsb2F0MzJBcnJheSh3LnNpemVGcm9tU2hhcGUobikpO3JldHVybiBhLnNldCh0LGEubGVuZ3RoLXQubGVuZ3RoKSxibihhLG4pfX0sSjU9Y2xhc3Mgd0UgZXh0ZW5kcyBzbntjb25zdHJ1Y3Rvcih0LG4pe2lmKHN1cGVyKCksdGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQ9dCx0aGlzLndlYmNhbUNvbmZpZz1uLHRoaXMuaXNDbG9zZWQ9ITAsdGhpcy5yZXNpemU9ITEsdGhpcy5uZWVkVG9SZXNpemUoKSlpZih0aGlzLnJlc2l6ZT0hMCx0aGlzLmNyb3BTaXplPVt0aGlzLndlYmNhbUNvbmZpZy5yZXNpemVIZWlnaHQsdGhpcy53ZWJjYW1Db25maWcucmVzaXplV2lkdGhdLHRoaXMuY3JvcEJveEluZD1qZShbMF0sXCJpbnQzMlwiKSx0aGlzLndlYmNhbUNvbmZpZy5jZW50ZXJDcm9wKXtsZXQgYT10aGlzLndlYmNhbUNvbmZpZy5yZXNpemVXaWR0aCoxL3RoaXMud2ViY2FtVmlkZW9FbGVtZW50LndpZHRoLHI9dGhpcy53ZWJjYW1Db25maWcucmVzaXplSGVpZ2h0KjEvdGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQuaGVpZ2h0LHM9KDEtYSkvMixpPSgxLXIpLzIsbz1zK2EsbD1yK2k7dGhpcy5jcm9wQm94PUVhKFtpLHMsbCxvXSxbMSw0XSl9ZWxzZSB0aGlzLmNyb3BCb3g9RWEoWzAsMCwxLDFdLFsxLDRdKX1zdW1tYXJ5KCl7cmV0dXJuXCJ3ZWJjYW1cIn1zdGF0aWMgYXN5bmMgY3JlYXRlKHQsbj17fSl7aWYoIUcoKS5nZXQoXCJJU19CUk9XU0VSXCIpKXRocm93IG5ldyBFcnJvcihcInRmLmRhdGEud2ViY2FtIGlzIG9ubHkgc3VwcG9ydGVkIGluIGJyb3dzZXIgZW52aXJvbm1lbnQuXCIpO2lmKCF0KXtpZih0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKSwhbi5yZXNpemVXaWR0aHx8IW4ucmVzaXplSGVpZ2h0KXRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIHdlYmNhbSB2aWRlbyBlbGVtZW50LCBvciByZXNpemVXaWR0aCBhbmQgcmVzaXplSGVpZ2h0IHRvIGNyZWF0ZSBhIGhpZGRlbiB2aWRlbyBlbGVtZW50LlwiKTt0LndpZHRoPW4ucmVzaXplV2lkdGgsdC5oZWlnaHQ9bi5yZXNpemVIZWlnaHR9bGV0IGE9bmV3IHdFKHQsbik7cmV0dXJuIGF3YWl0IGEuc3RhcnQoKSxhfWFzeW5jIHN0YXJ0KCl7dGhpcy53ZWJjYW1Db25maWcuZmFjaW5nTW9kZSYmdy5hc3NlcnQodGhpcy53ZWJjYW1Db25maWcuZmFjaW5nTW9kZT09PVwidXNlclwifHx0aGlzLndlYmNhbUNvbmZpZy5mYWNpbmdNb2RlPT09XCJlbnZpcm9ubWVudFwiLCgpPT5gSW52YWxpZCB3ZWJjYW0gZmFjaW5nIG1vZGU6ICR7dGhpcy53ZWJjYW1Db25maWcuZmFjaW5nTW9kZX0uIFBsZWFzZSBwcm92aWRlICd1c2VyJyBvciAnZW52aXJvbm1lbnQnYCk7dHJ5e3RoaXMuc3RyZWFtPWF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHt2aWRlbzp7ZGV2aWNlSWQ6dGhpcy53ZWJjYW1Db25maWcuZGV2aWNlSWQsZmFjaW5nTW9kZTp0aGlzLndlYmNhbUNvbmZpZy5mYWNpbmdNb2RlP3RoaXMud2ViY2FtQ29uZmlnLmZhY2luZ01vZGU6XCJ1c2VyXCIsd2lkdGg6dGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQud2lkdGgsaGVpZ2h0OnRoaXMud2ViY2FtVmlkZW9FbGVtZW50LmhlaWdodH19KX1jYXRjaCh0KXt0aHJvdyB0Lm1lc3NhZ2U9YEVycm9yIHRocm93biB3aGlsZSBpbml0aWFsaXppbmcgdmlkZW8gc3RyZWFtOiAke3QubWVzc2FnZX1gLHR9aWYoIXRoaXMuc3RyZWFtKXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBvYnRhaW4gdmlkZW8gZnJvbSB3ZWJjYW0uXCIpO3RyeXt0aGlzLndlYmNhbVZpZGVvRWxlbWVudC5zcmNPYmplY3Q9dGhpcy5zdHJlYW19Y2F0Y2godCl7Y29uc29sZS5sb2codCksdGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQuc3JjPXdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKHRoaXMuc3RyZWFtKX1yZXR1cm4gdGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQucGxheSgpLHRoaXMuaXNDbG9zZWQ9ITEsbmV3IFByb21pc2UodD0+e3RoaXMud2ViY2FtVmlkZW9FbGVtZW50Lm9ubG9hZGVkbWV0YWRhdGE9KCk9Pnt0KCl9fSl9YXN5bmMgbmV4dCgpe2lmKHRoaXMuaXNDbG9zZWQpcmV0dXJue3ZhbHVlOm51bGwsZG9uZTohMH07bGV0IHQ7dHJ5e3Q9cW8uZnJvbVBpeGVscyh0aGlzLndlYmNhbVZpZGVvRWxlbWVudCl9Y2F0Y2gobil7dGhyb3cgbmV3IEVycm9yKGBFcnJvciB0aHJvd24gY29udmVydGluZyB2aWRlbyB0byBwaXhlbHM6ICR7SlNPTi5zdHJpbmdpZnkobil9YCl9aWYodGhpcy5yZXNpemUpdHJ5e3JldHVybnt2YWx1ZTp0aGlzLmNyb3BBbmRSZXNpemVGcmFtZSh0KSxkb25lOiExfX1jYXRjaChuKXt0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHRocm93biBjcm9wcGluZyB0aGUgdmlkZW86ICR7bi5tZXNzYWdlfWApfWZpbmFsbHl7dC5kaXNwb3NlKCl9ZWxzZSByZXR1cm57dmFsdWU6dCxkb25lOiExfX1uZWVkVG9SZXNpemUoKXtyZXR1cm4hISh0aGlzLndlYmNhbUNvbmZpZy5yZXNpemVXaWR0aCYmdGhpcy53ZWJjYW1Db25maWcucmVzaXplSGVpZ2h0JiYodGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQud2lkdGghPT10aGlzLndlYmNhbUNvbmZpZy5yZXNpemVXaWR0aHx8dGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQuaGVpZ2h0IT09dGhpcy53ZWJjYW1Db25maWcucmVzaXplSGVpZ2h0KSl9Y3JvcEFuZFJlc2l6ZUZyYW1lKHQpe3JldHVybiBPKCgpPT57bGV0IG49R3QocmUodCxcImZsb2F0MzJcIiksMCksYTthPVpuLmNyb3BBbmRSZXNpemUobix0aGlzLmNyb3BCb3gsdGhpcy5jcm9wQm94SW5kLHRoaXMuY3JvcFNpemUsXCJiaWxpbmVhclwiKTtsZXQgcj1hLnNoYXBlO3JldHVybiBXKGEsci5zbGljZSgxKSl9KX1hc3luYyBjYXB0dXJlKCl7cmV0dXJuKGF3YWl0IHRoaXMubmV4dCgpKS52YWx1ZX1zdG9wKCl7dGhpcy5zdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0PT50LnN0b3AoKSk7dHJ5e3RoaXMud2ViY2FtVmlkZW9FbGVtZW50LnNyY09iamVjdD1udWxsfWNhdGNoKHQpe2NvbnNvbGUubG9nKHQpLHRoaXMud2ViY2FtVmlkZW9FbGVtZW50LnNyYz1udWxsfXRoaXMuaXNDbG9zZWQ9ITB9dG9BcnJheSgpe3Rocm93IG5ldyBFcnJvcihcIkNhbiBub3QgY29udmVydCBpbmZpbml0ZSB2aWRlbyBzdHJlYW0gdG8gYXJyYXkuXCIpfX0sa0U9Y2xhc3N7fSxJRT1jbGFzcyBleHRlbmRzIHNue3NwbGl0KGUpe3JldHVybiBuZXcgUTUodGhpcyxlKX19LFE1PWNsYXNzIGV4dGVuZHMgSUV7Y29uc3RydWN0b3IoZSx0KXtzdXBlcigpLHRoaXMudXBzdHJlYW09ZSx0aGlzLmltcGw9bmV3IGU4KGUsdCl9c3VtbWFyeSgpe3JldHVybiB0aGlzLmltcGwuc3VtbWFyeSgpfWFzeW5jIG5leHQoKXtyZXR1cm4gdGhpcy5pbXBsLm5leHQoKX19LGU4PWNsYXNzIGV4dGVuZHMgRDF7Y29uc3RydWN0b3IoZSx0KXtzdXBlcigpLHRoaXMudXBzdHJlYW09ZSx0aGlzLnNlcGFyYXRvcj10LHRoaXMuY2FycnlvdmVyPVwiXCJ9c3VtbWFyeSgpe3JldHVybmAke3RoaXMudXBzdHJlYW0uc3VtbWFyeSgpfSAtPiBTcGxpdCgnJHt0aGlzLnNlcGFyYXRvcn0nKWB9YXN5bmMgcHVtcCgpe2xldCBlPWF3YWl0IHRoaXMudXBzdHJlYW0ubmV4dCgpO2lmKGUuZG9uZSlyZXR1cm4gdGhpcy5jYXJyeW92ZXI9PT1cIlwiPyExOih0aGlzLm91dHB1dFF1ZXVlLnB1c2godGhpcy5jYXJyeW92ZXIpLHRoaXMuY2FycnlvdmVyPVwiXCIsITApO2xldCB0PWUudmFsdWUuc3BsaXQodGhpcy5zZXBhcmF0b3IpO3RbMF09dGhpcy5jYXJyeW92ZXIrdFswXTtmb3IobGV0IG4gb2YgdC5zbGljZSgwLC0xKSl0aGlzLm91dHB1dFF1ZXVlLnB1c2gobik7cmV0dXJuIHRoaXMuY2FycnlvdmVyPXRbdC5sZW5ndGgtMV0sITB9fSx0OD1jbGFzcyBleHRlbmRzIHNue2RlY29kZVVURjgoKXtyZXR1cm4gbmV3IG44KHRoaXMpfX0sbjg9Y2xhc3MgZXh0ZW5kcyBJRXtjb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMudXBzdHJlYW09ZSx0aGlzLmltcGw9bmV3IGE4KGUpfXN1bW1hcnkoKXtyZXR1cm4gdGhpcy5pbXBsLnN1bW1hcnkoKX1hc3luYyBuZXh0KCl7cmV0dXJuIHRoaXMuaW1wbC5uZXh0KCl9fSxhOD1jbGFzcyBleHRlbmRzIEQxe2NvbnN0cnVjdG9yKGUpe2lmKHN1cGVyKCksdGhpcy51cHN0cmVhbT1lLEcoKS5nZXQoXCJJU19CUk9XU0VSXCIpKXRoaXMuZGVjb2Rlcj1uZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKTtlbHNle2xldHtTdHJpbmdEZWNvZGVyOnR9PUZTKCk7dGhpcy5kZWNvZGVyPW5ldyB0KFwidXRmOFwiKX19c3VtbWFyeSgpe3JldHVybmAke3RoaXMudXBzdHJlYW0uc3VtbWFyeSgpfSAtPiBVdGY4YH1hc3luYyBwdW1wKCl7bGV0IGU9YXdhaXQgdGhpcy51cHN0cmVhbS5uZXh0KCksdDtpZihlLmRvbmUpcmV0dXJuITE7dD1lLnZhbHVlO2xldCBuO3JldHVybiBHKCkuZ2V0KFwiSVNfQlJPV1NFUlwiKT9uPXRoaXMuZGVjb2Rlci5kZWNvZGUodCx7c3RyZWFtOiEwfSk6bj10aGlzLmRlY29kZXIud3JpdGUoQnVmZmVyLmZyb20odC5idWZmZXIpKSx0aGlzLm91dHB1dFF1ZXVlLnB1c2gobiksITB9fSxTRT1jbGFzcyBleHRlbmRzIHQ4e2NvbnN0cnVjdG9yKGUsdD17fSl7c3VwZXIoKSx0aGlzLmZpbGU9ZSx0aGlzLm9wdGlvbnM9dCx3LmFzc2VydChlIGluc3RhbmNlb2YgVWludDhBcnJheXx8KEcoKS5nZXQoXCJJU19CUk9XU0VSXCIpP2UgaW5zdGFuY2VvZiBGaWxlfHxlIGluc3RhbmNlb2YgQmxvYjohMSksKCk9PlwiRmlsZUNodW5rSXRlcmF0b3Igb25seSBzdXBwb3J0cyBGaWxlLCBCbG9iIGFuZCBVaW50OEFycmF5IHJpZ2h0IG5vdy5cIiksdGhpcy5vZmZzZXQ9dC5vZmZzZXR8fDAsdGhpcy5jaHVua1NpemU9dC5jaHVua1NpemV8fDEwMjQqMTAyNH1zdW1tYXJ5KCl7cmV0dXJuYEZpbGVDaHVua3MgJHt0aGlzLmZpbGV9YH1hc3luYyBuZXh0KCl7cmV0dXJuIHRoaXMub2Zmc2V0Pj0odGhpcy5maWxlIGluc3RhbmNlb2YgVWludDhBcnJheT90aGlzLmZpbGUuYnl0ZUxlbmd0aDp0aGlzLmZpbGUuc2l6ZSk/e3ZhbHVlOm51bGwsZG9uZTohMH06e3ZhbHVlOmF3YWl0IG5ldyBQcm9taXNlKChlLHQpPT57bGV0IG49dGhpcy5vZmZzZXQrdGhpcy5jaHVua1NpemU7aWYodGhpcy5maWxlIGluc3RhbmNlb2YgVWludDhBcnJheSllKG5ldyBVaW50OEFycmF5KHRoaXMuZmlsZS5zbGljZSh0aGlzLm9mZnNldCxuKSkpO2Vsc2V7bGV0IGE9bmV3IEZpbGVSZWFkZXI7YS5vbmxvYWQ9cz0+e2xldCBpPWEucmVzdWx0O2lmKGkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciYmKGk9bmV3IFVpbnQ4QXJyYXkoaSkpLCEoaSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKXJldHVybiB0KG5ldyBUeXBlRXJyb3IoXCJGaWxlUmVhZGVyIHJldHVybmVkIHVua25vd24gdHlwZS5cIikpO2UoaSl9LGEub25hYm9ydD1zPT50KG5ldyBFcnJvcihcIkFib3J0ZWRcIikpLGEub25lcnJvcj1zPT50KG5ldyBFcnJvcihzLnR5cGUpKTtsZXQgcj10aGlzLmZpbGUuc2xpY2UodGhpcy5vZmZzZXQsbik7YS5yZWFkQXNBcnJheUJ1ZmZlcihyKX10aGlzLm9mZnNldD1ufSksZG9uZTohMX19fTthc3luYyBmdW5jdGlvbiByOChlLHQ9e30sbil7bGV0IGEscjt0eXBlb2YgZT09XCJzdHJpbmdcIj9hPWU6KGE9ZS51cmwscj1zOChlKSk7bGV0IHM9YXdhaXQobnx8dy5mZXRjaCkoYSxyKTtpZihzLm9rKXtsZXQgaT1uZXcgVWludDhBcnJheShhd2FpdCBzLmFycmF5QnVmZmVyKCkpO3JldHVybiBuZXcgU0UoaSx0KX1lbHNlIHRocm93IG5ldyBFcnJvcihzLnN0YXR1c1RleHQpfXZhciBzOD1lPT4oe21ldGhvZDplLm1ldGhvZCxoZWFkZXJzOmUuaGVhZGVycyxib2R5OmUuYm9keSxtb2RlOmUubW9kZSxjcmVkZW50aWFsczplLmNyZWRlbnRpYWxzLGNhY2hlOmUuY2FjaGUscmVkaXJlY3Q6ZS5yZWRpcmVjdCxyZWZlcnJlcjplLnJlZmVycmVyLGludGVncml0eTplLmludGVncml0eX0pO2Z1bmN0aW9uIE5FKGUpe3JldHVybiB0eXBlb2YgZT09XCJzdHJpbmdcIiYmZS5zbGljZSgwLDcpPT09XCJmaWxlOi8vXCJ9dmFyIFRFPWNsYXNzIGV4dGVuZHMga0V7Y29uc3RydWN0b3IoZSx0PXt9KXtzdXBlcigpLHRoaXMuaW5wdXQ9ZSx0aGlzLm9wdGlvbnM9dH1hc3luYyBpdGVyYXRvcigpe2lmKE5FKHRoaXMuaW5wdXQpJiZHKCkuZ2V0KFwiSVNfTk9ERVwiKSl7bGV0IGU9SXYoKTt0aGlzLmlucHV0PWUucmVhZEZpbGVTeW5jKHRoaXMuaW5wdXQuc2xpY2UoNykpfXJldHVybiBuZXcgU0UodGhpcy5pbnB1dCx0aGlzLm9wdGlvbnMpfX0sQ0U9Y2xhc3MgZXh0ZW5kcyBrRXtjb25zdHJ1Y3RvcihlLHQ9e30pe3N1cGVyKCksdGhpcy51cmw9ZSx0aGlzLmZpbGVPcHRpb25zPXR9YXN5bmMgaXRlcmF0b3IoKXtyZXR1cm4gTkUodGhpcy51cmwpP25ldyBURSh0aGlzLnVybCx0aGlzLmZpbGVPcHRpb25zKS5pdGVyYXRvcigpOnI4KHRoaXMudXJsLHRoaXMuZmlsZU9wdGlvbnMpfX07ZnVuY3Rpb24gaTgoZSx0PXt9KXtyZXR1cm4gbmV3IHhFKG5ldyBDRShlKSx0KX1mdW5jdGlvbiBvOChlKXtsZXQgdD0kMShlKTtyZXR1cm4gS24oYXN5bmMoKT0+dCl9ZnVuY3Rpb24gbDgoZSl7cmV0dXJuIEtuKGFzeW5jKCk9PntsZXQgdD1hd2FpdCBlKCk7cmV0dXJuICQxKCgpPT50Lm5leHQoKSl9KX1hc3luYyBmdW5jdGlvbiB1OChlLHQpe3JldHVybiBKNS5jcmVhdGUoZSx0KX1hc3luYyBmdW5jdGlvbiBwOChlKXtyZXR1cm4gWjUuY3JlYXRlKGUpfXZhciBjOD1cIjQuMjIuMFwiO2Z1bmN0aW9uIGdlKGUsdCl7QXJyYXkuaXNBcnJheShlKXx8KGU9W2VdKSxlLmZvckVhY2gobj0+e24hPW51bGwmJncuYXNzZXJ0KG4uZHR5cGUhPT1cImNvbXBsZXg2NFwiLCgpPT5gJHt0fSBkb2VzIG5vdCBzdXBwb3J0IGNvbXBsZXg2NCB0ZW5zb3JzIGluIHRoZSBDUFUgYmFja2VuZC5gKX0pfXZhciBkOD1tci53aGVyZUltcGwsUjE9Y2xhc3MgRUUgZXh0ZW5kcyBGY3tuZXh0RGF0YUlkKCl7cmV0dXJuIEVFLm5leHREYXRhSWQrK31jb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5ibG9ja1NpemU9NDgsdGhpcy5maXJzdFVzZT0hMCx0aGlzLmRhdGE9bmV3IHltKHRoaXMsVGEoKSl9d3JpdGUodCxuLGEpe3RoaXMuZmlyc3RVc2UmJih0aGlzLmZpcnN0VXNlPSExLEcoKS5nZXQoXCJJU19OT0RFXCIpJiZULndhcm4oYFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuSGksIGxvb2tzIGxpa2UgeW91IGFyZSBydW5uaW5nIFRlbnNvckZsb3cuanMgaW4gTm9kZS5qcy4gVG8gc3BlZWQgdGhpbmdzIHVwIGRyYW1hdGljYWxseSwgaW5zdGFsbCBvdXIgbm9kZSBiYWNrZW5kLCB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzLW5vZGUgZm9yIG1vcmUgZGV0YWlscy4gXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09YCkpO2xldCByPXtpZDp0aGlzLm5leHREYXRhSWQoKX07cmV0dXJuIHRoaXMuZGF0YS5zZXQocix7dmFsdWVzOnQsZHR5cGU6YSxyZWZDb3VudDoxfSkscn1tYWtlVGVuc29ySW5mbyh0LG4sYSl7bGV0IHI7aWYobj09PVwic3RyaW5nXCImJmEhPW51bGwmJmEubGVuZ3RoPjAmJncuaXNTdHJpbmcoYVswXSkpe2xldCBzPWEubWFwKGk9PncuZW5jb2RlU3RyaW5nKGkpKTtyPXRoaXMud3JpdGUocyx0LG4pfWVsc2Ugcj10aGlzLndyaXRlKGEsdCxuKTtyZXR1cm57ZGF0YUlkOnIsc2hhcGU6dCxkdHlwZTpufX1yZWZDb3VudCh0KXtyZXR1cm4gdGhpcy5kYXRhLmhhcyh0KT90aGlzLmRhdGEuZ2V0KHQpLnJlZkNvdW50OjB9aW5jUmVmKHQpe2xldCBuPXRoaXMuZGF0YS5nZXQodCk7bi5yZWZDb3VudCsrfWRlY1JlZih0KXtpZih0aGlzLmRhdGEuaGFzKHQpKXtsZXQgbj10aGlzLmRhdGEuZ2V0KHQpO24ucmVmQ291bnQtLX19bW92ZSh0LG4sYSxyLHMpe3RoaXMuZGF0YS5zZXQodCx7dmFsdWVzOm4sZHR5cGU6cixyZWZDb3VudDpzfSl9bnVtRGF0YUlkcygpe3JldHVybiB0aGlzLmRhdGEubnVtRGF0YUlkcygpfWFzeW5jIHJlYWQodCl7cmV0dXJuIHRoaXMucmVhZFN5bmModCl9cmVhZFN5bmModCl7bGV0e2R0eXBlOm4sY29tcGxleFRlbnNvckluZm9zOmF9PXRoaXMuZGF0YS5nZXQodCk7aWYobj09PVwiY29tcGxleDY0XCIpe2xldCByPXRoaXMucmVhZFN5bmMoYS5yZWFsLmRhdGFJZCkscz10aGlzLnJlYWRTeW5jKGEuaW1hZy5kYXRhSWQpO3JldHVybiBULm1lcmdlUmVhbEFuZEltYWdBcnJheXMocixzKX1yZXR1cm4gdy5jb252ZXJ0QmFja2VuZFZhbHVlc0FuZEFycmF5QnVmZmVyKHRoaXMuZGF0YS5nZXQodCkudmFsdWVzLG4pfWJ1ZmZlclN5bmModCl7bGV0IG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCk7aWYodC5kdHlwZT09PVwic3RyaW5nXCIpdHJ5e2xldCBhPW4ubWFwKHI9PncuZGVjb2RlU3RyaW5nKHIpKTtyZXR1cm4gT2UodC5zaGFwZSx0LmR0eXBlLGEpfWNhdGNoKGEpe3Rocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZWNvZGUgZW5jb2RlZCBzdHJpbmcgYnl0ZXMgaW50byB1dGYtOFwiKX1yZXR1cm4gT2UodC5zaGFwZSx0LmR0eXBlLG4pfW1ha2VPdXRwdXQodCxuLGEpe3JldHVybiBUYSgpLm1ha2VUZW5zb3JGcm9tVGVuc29ySW5mbyh0aGlzLm1ha2VUZW5zb3JJbmZvKG4sYSx0KSx0aGlzKX1kaXNwb3NlRGF0YSh0LG49ITEpe2lmKHRoaXMuZGF0YS5oYXModCkpe2lmKHRoaXMuZGF0YS5nZXQodCkucmVmQ291bnQtLSwhbiYmdGhpcy5kYXRhLmdldCh0KS5yZWZDb3VudD4wKXJldHVybiExO2xldHtjb21wbGV4VGVuc29ySW5mb3M6YX09dGhpcy5kYXRhLmdldCh0KTthIT1udWxsJiYodGhpcy5kaXNwb3NlRGF0YShhLnJlYWwuZGF0YUlkLCEwKSx0aGlzLmRpc3Bvc2VEYXRhKGEuaW1hZy5kYXRhSWQsITApKSx0aGlzLmRhdGEuZGVsZXRlKHQpfXJldHVybiEwfWRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHQpe3RoaXMuZGlzcG9zZURhdGEodC5kYXRhSWQpfWFzeW5jIHRpbWUodCl7bGV0IG49dy5ub3coKTtyZXR1cm4gdCgpLHtrZXJuZWxNczp3Lm5vdygpLW59fW1lbW9yeSgpe3JldHVybnt1bnJlbGlhYmxlOiEwLHJlYXNvbnM6W1wiVGhlIHJlcG9ydGVkIG1lbW9yeSBpcyBhbiB1cHBlciBib3VuZC4gRHVlIHRvIGF1dG9tYXRpYyBnYXJiYWdlIGNvbGxlY3Rpb24sIHRoZSB0cnVlIGFsbG9jYXRlZCBtZW1vcnkgbWF5IGJlIGxlc3MuXCJdfX13aGVyZSh0KXtnZShbdF0sXCJ3aGVyZVwiKTtsZXQgbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKTtyZXR1cm4gZDgodC5zaGFwZSxuKX1kaXNwb3NlKCl7fWZsb2F0UHJlY2lzaW9uKCl7cmV0dXJuIDMyfWVwc2lsb24oKXtyZXR1cm4gc3VwZXIuZXBzaWxvbigpfX07UjEubmV4dERhdGFJZD0wO3ZhciBNMT17fTtfZShNMSx7YWRkSW1wbDooKT0+RkUsYmluY291bnRJbXBsOigpPT5QMSxiaW5jb3VudFJlZHVjZUltcGw6KCk9PiRFLGJpdHdpc2VBbmRJbXBsOigpPT5ERSxjYXN0SW1wbDooKT0+QUUsY2VpbEltcGw6KCk9PlJFLGNvbmNhdEltcGw6KCk9PkwxLGVxdWFsSW1wbDooKT0+TUUsZXhwSW1wbDooKT0+UEUsZXhwbTFJbXBsOigpPT56RSxmbG9vckRpdkltcGw6KCk9PkJFLGZsb29ySW1wbDooKT0+V0UsZ2F0aGVyTmRJbXBsOigpPT5WRSxnYXRoZXJWMkltcGw6KCk9PlVFLGdyZWF0ZXJFcXVhbEltcGw6KCk9PkhFLGdyZWF0ZXJJbXBsOigpPT5HRSxsZXNzRXF1YWxJbXBsOigpPT5xRSxsZXNzSW1wbDooKT0+akUsbGluU3BhY2VJbXBsOigpPT5LRSxsb2dJbXBsOigpPT5YRSxtYXhJbXBsOigpPT5ZRSxtYXhpbXVtSW1wbDooKT0+WkUsbWluaW11bUltcGw6KCk9PkpFLG11bHRpcGx5SW1wbDooKT0+ejEsbmVnSW1wbDooKT0+UUUsbm90RXF1YWxJbXBsOigpPT5lXyxwcm9kSW1wbDooKT0+dF8scmFnZ2VkR2F0aGVySW1wbDooKT0+bl8scmFnZ2VkUmFuZ2VJbXBsOigpPT5hXyxyYWdnZWRUZW5zb3JUb1RlbnNvckltcGw6KCk9PnJfLHJhbmdlSW1wbDooKT0+QjEscnNxcnRJbXBsOigpPT5zXyxzY2F0dGVySW1wbDooKT0+bmksc2lnbW9pZEltcGw6KCk9PmNLLHNpbXBsZUFic0ltcGw6KCk9Pl9FLHNsaWNlSW1wbDooKT0+dW0sc3BhcnNlRmlsbEVtcHR5Um93c0ltcGw6KCk9Pm9fLHNwYXJzZVJlc2hhcGVJbXBsOigpPT5sXyxzcGFyc2VTZWdtZW50UmVkdWN0aW9uSW1wbDooKT0+VjEsc3FydEltcGw6KCk9Pm1LLHNxdWFyZWREaWZmZXJlbmNlSW1wbDooKT0+dV8sc3RhdGljUmVnZXhSZXBsYWNlSW1wbDooKT0+cF8sc3RyaWRlZFNsaWNlSW1wbDooKT0+Y18sc3RyaW5nTkdyYW1zSW1wbDooKT0+VTEsc3RyaW5nU3BsaXRJbXBsOigpPT5HMSxzdHJpbmdUb0hhc2hCdWNrZXRGYXN0SW1wbDooKT0+SDEsc3ViSW1wbDooKT0+ZF8sdGlsZUltcGw6KCk9PmhfLHRvcEtJbXBsOigpPT5mXyx0cmFuc3Bvc2VJbXBsOigpPT5XMSx1bmlxdWVJbXBsOigpPT5xMX0pO2Z1bmN0aW9uIF9FKGUpe2xldCB0PW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7KytuKXRbbl09TWF0aC5hYnMoZVtuXSk7cmV0dXJuIHR9dmFyIGg4PWU9PntsZXR7eDp0fT1lLmlucHV0cyxuPWUuYmFja2VuZDtnZSh0LFwiYWJzXCIpO2xldCBhPW5ldyBGbG9hdDMyQXJyYXkody5zaXplRnJvbVNoYXBlKHQuc2hhcGUpKSxyPW4uZGF0YS5nZXQodC5kYXRhSWQpLnZhbHVlcztyZXR1cm4gYT1fRShyKSxuLm1ha2VPdXRwdXQoYSx0LnNoYXBlLHQuZHR5cGUpfSxtOD17a2VybmVsTmFtZTpZbCxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6aDh9O2Z1bmN0aW9uIE10KGUpe3JldHVybih0LG4sYSxyLHMpPT57bGV0IGk9VC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZSh0LG4pLG89aS5sZW5ndGgsbD13LmNvbXB1dGVTdHJpZGVzKGkpLHU9dy5zaXplRnJvbVNoYXBlKGkpLHA9dy5nZXRUeXBlZEFycmF5RnJvbURUeXBlKHMsdSksZD10Lmxlbmd0aCxjPW4ubGVuZ3RoLGg9dy5jb21wdXRlU3RyaWRlcyh0KSxtPXcuY29tcHV0ZVN0cmlkZXMobiksZj1ULmdldEJyb2FkY2FzdERpbXModCxpKSxnPVQuZ2V0QnJvYWRjYXN0RGltcyhuLGkpO2lmKGYubGVuZ3RoK2cubGVuZ3RoPT09MClmb3IobGV0IGI9MDtiPHAubGVuZ3RoOysrYilwW2JdPWUoYVtiJWEubGVuZ3RoXSxyW2Ilci5sZW5ndGhdKTtlbHNlIGZvcihsZXQgYj0wO2I8cC5sZW5ndGg7KytiKXtsZXQgeT13LmluZGV4VG9Mb2MoYixvLGwpLHg9eS5zbGljZSgtZCk7Zi5mb3JFYWNoKEM9PnhbQ109MCk7bGV0IHY9dy5sb2NUb0luZGV4KHgsZCxoKSxJPXkuc2xpY2UoLWMpO2cuZm9yRWFjaChDPT5JW0NdPTApO2xldCBOPXcubG9jVG9JbmRleChJLGMsbSk7cFtiXT1lKGFbdl0scltOXSl9cmV0dXJuW3AsaV19fWZ1bmN0aW9uIFluKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse3JlYWw6YSxpbWFnOnJ9PXQscz1uLmRhdGEuZ2V0KGEuZGF0YUlkKS52YWx1ZXMsaT1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsbz1uLm1ha2VUZW5zb3JJbmZvKGEuc2hhcGUsXCJjb21wbGV4NjRcIiksbD1uLmRhdGEuZ2V0KG8uZGF0YUlkKTtyZXR1cm4gbC5jb21wbGV4VGVuc29ySW5mb3M9e3JlYWw6bi5tYWtlVGVuc29ySW5mbyhhLnNoYXBlLFwiZmxvYXQzMlwiLHMpLGltYWc6bi5tYWtlVGVuc29ySW5mbyhyLnNoYXBlLFwiZmxvYXQzMlwiLGkpfSxvfXZhciBmOD17a2VybmVsTmFtZTp3bSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6WW59O2Z1bmN0aW9uIGxtKGUsdCxuPVwiZmxvYXQzMlwiKXtpZihuPT09XCJjb21wbGV4NjRcIil7bGV0IHI9bG0oZSx0LFwiZmxvYXQzMlwiKSxzPWxtKGUsdCxcImZsb2F0MzJcIik7cmV0dXJuIFluKHtpbnB1dHM6e3JlYWw6cixpbWFnOnN9LGJhY2tlbmQ6ZX0pfWxldCBhPXcubWFrZVplcm9zVHlwZWRBcnJheSh3LnNpemVGcm9tU2hhcGUodCksbik7cmV0dXJuIGUubWFrZVRlbnNvckluZm8odCxuLGEpfWZ1bmN0aW9uIGNyKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse3g6YX09dDtyZXR1cm4gbi5pbmNSZWYoYS5kYXRhSWQpLHtkYXRhSWQ6YS5kYXRhSWQsc2hhcGU6YS5zaGFwZSxkdHlwZTphLmR0eXBlfX12YXIgZzg9e2tlcm5lbE5hbWU6ZW8sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmNyfTtmdW5jdGlvbiB5aShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHtpbnB1dDphfT10LHI9bi5kYXRhLmdldChhLmRhdGFJZCkuY29tcGxleFRlbnNvckluZm9zLnJlYWwscz1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXM7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8oci5zaGFwZSxyLmR0eXBlLHMpfXZhciBiOD17a2VybmVsTmFtZTpEbSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6eWl9O2Z1bmN0aW9uIEFFKGUsdCxuLGEpe2lmKGE9PT1cImludDMyXCIpe2xldCByPUludDMyQXJyYXkuZnJvbShlKTtyZXR1cm5bdCxcImludDMyXCIscl19aWYoYT09PVwiYm9vbFwiKXtsZXQgcj13LnRvVHlwZWRBcnJheShbMF0sbiksW3MsaV09TXQoKG8sbCk9Pm8hPT1sPzE6MCkodCxbXSxlLHIsXCJib29sXCIpO3JldHVybltpLFwiYm9vbFwiLHNdfXRocm93IG5ldyBFcnJvcihgRXJyb3IgaW4gQ2FzdDogZmFpbGVkIHRvIGNhc3QgJHtufSB0byAke2F9YCl9ZnVuY3Rpb24gYnMoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2R0eXBlOnN9PWE7aWYocz09PVwiY29tcGxleDY0XCIpe2lmKHIuZHR5cGU9PT1cImNvbXBsZXg2NFwiKXJldHVybiBjcih7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bn0pO2xldCBwPWxtKG4sci5zaGFwZSxyLmR0eXBlKSxkPWJzKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntkdHlwZTpcImZsb2F0MzJcIn19KSxjPVluKHtpbnB1dHM6e3JlYWw6ZCxpbWFnOnB9LGJhY2tlbmQ6bn0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHApLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZCksY31pZihyLmR0eXBlPT09XCJjb21wbGV4NjRcIil7bGV0IHA9eWkoe2lucHV0czp7aW5wdXQ6cn0sYmFja2VuZDpufSksZD1icyh7aW5wdXRzOnt4OnB9LGJhY2tlbmQ6bixhdHRyczp7ZHR5cGU6c319KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhwKSxkfWlmKCF3Lmhhc0VuY29kaW5nTG9zcyhyLmR0eXBlLHMpKXtsZXQgcD1jcih7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bn0pO3JldHVybntkYXRhSWQ6cC5kYXRhSWQsc2hhcGU6cC5zaGFwZSxkdHlwZTpzfX1sZXQgaT1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsW28sbCx1XT1BRShpLHIuc2hhcGUsci5kdHlwZSxzKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhvLGwsdSl9dmFyIHk4PXtrZXJuZWxOYW1lOk1pLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpic307ZnVuY3Rpb24gWnQoZSx0LG4sYSl7cmV0dXJuIG49PW51bGw/KHtpbnB1dHM6cixiYWNrZW5kOnN9KT0+e2xldHthOmksYjpvfT1yLGw9cztnZShbaSxvXSxlKTtsZXQgdT1sLmRhdGEuZ2V0KGkuZGF0YUlkKS52YWx1ZXMscD1sLmRhdGEuZ2V0KG8uZGF0YUlkKS52YWx1ZXMsZD1pLmR0eXBlPT09XCJzdHJpbmdcIj9ULmZyb21VaW50OFRvU3RyaW5nQXJyYXkodSk6dSxjPWkuZHR5cGU9PT1cInN0cmluZ1wiP1QuZnJvbVVpbnQ4VG9TdHJpbmdBcnJheShwKTpwLGg9YXx8aS5kdHlwZSxbbSxmXT10KGkuc2hhcGUsby5zaGFwZSxkLGMsaCk7cmV0dXJuIGwubWFrZVRlbnNvckluZm8oZixoLG0pfTooe2lucHV0czpyLGJhY2tlbmQ6c30pPT57bGV0e2E6aSxiOm99PXIsbD1zO2lmKGkuZHR5cGU9PT1cImNvbXBsZXg2NFwifHxvLmR0eXBlPT09XCJjb21wbGV4NjRcIil7bGV0IHU9YnMoe2lucHV0czp7eDppfSxiYWNrZW5kOmwsYXR0cnM6e2R0eXBlOlwiY29tcGxleDY0XCJ9fSkscD1sLmRhdGEuZ2V0KHUuZGF0YUlkKSxkPXAuY29tcGxleFRlbnNvckluZm9zLnJlYWwsYz1wLmNvbXBsZXhUZW5zb3JJbmZvcy5pbWFnLGg9bC5kYXRhLmdldChkLmRhdGFJZCkudmFsdWVzLG09bC5kYXRhLmdldChjLmRhdGFJZCkudmFsdWVzLGY9YnMoe2lucHV0czp7eDpvfSxiYWNrZW5kOmwsYXR0cnM6e2R0eXBlOlwiY29tcGxleDY0XCJ9fSksZz1sLmRhdGEuZ2V0KGYuZGF0YUlkKSxiPWcuY29tcGxleFRlbnNvckluZm9zLnJlYWwseT1nLmNvbXBsZXhUZW5zb3JJbmZvcy5pbWFnLHg9bC5kYXRhLmdldChiLmRhdGFJZCkudmFsdWVzLHY9bC5kYXRhLmdldCh5LmRhdGFJZCkudmFsdWVzLFtJLE4sQ109bihpLnNoYXBlLG8uc2hhcGUsaCxtLHgsdiksXz1sLm1ha2VUZW5zb3JJbmZvKEMsXCJmbG9hdDMyXCIsSSksRj1sLm1ha2VUZW5zb3JJbmZvKEMsXCJmbG9hdDMyXCIsTiksRD1Zbih7aW5wdXRzOntyZWFsOl8saW1hZzpGfSxiYWNrZW5kOmx9KTtyZXR1cm4gbC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh1KSxsLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGYpLGwuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oXyksbC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhGKSxEfWVsc2V7bGV0IHU9bC5kYXRhLmdldChpLmRhdGFJZCkudmFsdWVzLHA9bC5kYXRhLmdldChvLmRhdGFJZCkudmFsdWVzLGQ9YXx8aS5kdHlwZSxbYyxoXT10KGkuc2hhcGUsby5zaGFwZSx1LHAsZCk7cmV0dXJuIGwubWFrZVRlbnNvckluZm8oaCxkLGMpfX19ZnVuY3Rpb24gTzEoZSl7cmV0dXJuKHQsbixhLHIscyxpKT0+e2xldCBvPVQuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUodCxuKSxsPXcuc2l6ZUZyb21TaGFwZShvKSx1PW8ubGVuZ3RoLHA9dy5jb21wdXRlU3RyaWRlcyhvKSxkPXcuZ2V0VHlwZWRBcnJheUZyb21EVHlwZShcImZsb2F0MzJcIixsKSxjPXcuZ2V0VHlwZWRBcnJheUZyb21EVHlwZShcImZsb2F0MzJcIixsKSxoPVQuZ2V0QnJvYWRjYXN0RGltcyh0LG8pLG09VC5nZXRCcm9hZGNhc3REaW1zKG4sbyksZj1ULm1lcmdlUmVhbEFuZEltYWdBcnJheXMoYSxyKSxnPVQubWVyZ2VSZWFsQW5kSW1hZ0FycmF5cyhzLGkpLGI9dC5sZW5ndGgseT13LmNvbXB1dGVTdHJpZGVzKHQpLHg9bi5sZW5ndGgsdj13LmNvbXB1dGVTdHJpZGVzKG4pO2lmKGgubGVuZ3RoK20ubGVuZ3RoPT09MClmb3IobGV0IEk9MDtJPGQubGVuZ3RoO0krKyl7bGV0IE49SSVmLmxlbmd0aCxDPUklZy5sZW5ndGgsXz1lKGZbTioyXSxmW04qMisxXSxnW0MqMl0sZ1tDKjIrMV0pO2RbSV09Xy5yZWFsLGNbSV09Xy5pbWFnfWVsc2UgZm9yKGxldCBJPTA7STxkLmxlbmd0aDtJKyspe2xldCBOPXcuaW5kZXhUb0xvYyhJLHUscCksQz1OLnNsaWNlKC1iKTtoLmZvckVhY2goUz0+Q1tTXT0wKTtsZXQgXz13LmxvY1RvSW5kZXgoQyxiLHkpLEY9Ti5zbGljZSgteCk7bS5mb3JFYWNoKFM9PkZbU109MCk7bGV0IEQ9dy5sb2NUb0luZGV4KEYseCx2KSwkPWUoZltfKjJdLGZbXyoyKzFdLGdbRCoyXSxnW0QqMisxXSk7ZFtJXT0kLnJlYWwsY1tJXT0kLmltYWd9cmV0dXJuW2QsYyxvXX19dmFyIEZFPU10KChlLHQpPT5lK3QpLHg4PU8xKChlLHQsbixhKT0+KHtyZWFsOmUrbixpbWFnOnQrYX0pKSxqbD1adCh2cyxGRSx4OCksdjg9e2tlcm5lbE5hbWU6dnMsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmpsfTtmdW5jdGlvbiBQMShlLHQsbixhLHIpe2xldCBzPXcuc2l6ZUZyb21TaGFwZShhKSxpPXcubWFrZVplcm9zVHlwZWRBcnJheShyLG4pO2ZvcihsZXQgbz0wO288ZS5sZW5ndGg7bysrKXtsZXQgbD1lW29dO2lmKGw8MCl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB4IG11c3QgYmUgbm9uLW5lZ2F0aXZlIVwiKTtsPj1yfHwocz4wP2lbbF0rPXRbb106aVtsXSs9MSl9cmV0dXJuIGl9ZnVuY3Rpb24gJEUoZSx0LG4sYT0hMSl7bGV0IHI9ZS5zaGFwZVswXSxzPWUuc2hhcGVbMV0saT1PZShbcixuXSx0LmR0eXBlKTtmb3IobGV0IG89MDtvPHI7bysrKWZvcihsZXQgbD0wO2w8cztsKyspe2xldCB1PWUuZ2V0KG8sbCk7aWYodTwwKXRocm93IG5ldyBFcnJvcihcIklucHV0IHggbXVzdCBiZSBub24tbmVnYXRpdmUhXCIpO3U+PW58fChhP2kuc2V0KDEsbyx1KTp0LnNpemU+MD9pLnNldChpLmdldChvLHUpK3QuZ2V0KG8sbCksbyx1KTppLnNldChpLmdldChvLHUpKzEsbyx1KSl9cmV0dXJuIGl9dmFyIERFPU10KChlLHQpPT5lJnQpLHc4PVp0KHJ1LERFKSxrOD17a2VybmVsTmFtZTpydSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6dzh9O2Z1bmN0aW9uIGZyKGUpe3JldHVybih0LG4sYSk9PntsZXQgcj13LmdldEFycmF5RnJvbURUeXBlKG4sdC5sZW5ndGgpO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7KytzKXJbc109ZSh0W3NdLGEpO3JldHVybiByfX1mdW5jdGlvbiBsdChlLHQsbil7bGV0IGE9ZnIodCk7cmV0dXJuIEZzKGUsYSxuKX1mdW5jdGlvbiBGcyhlLHQsbil7cmV0dXJuKHtpbnB1dHM6YSxhdHRyczpyLGJhY2tlbmQ6c30pPT57bGV0e3g6aX09YTtnZShpLGUpO2xldCBvPXMsbD1vLmRhdGEuZ2V0KGkuZGF0YUlkKS52YWx1ZXMsdTtpZihpLmR0eXBlPT09XCJzdHJpbmdcIil7aWYoIUFycmF5LmlzQXJyYXkobCkpdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nIHRlbnNvcidzIHZhbHVlIHdhcyBub3QgYW4gaW5zdGFuY2Ugb2YgQXJyYXlcIik7dT1ULmZyb21VaW50OFRvU3RyaW5nQXJyYXkobCl9ZWxzZSB1PWw7bGV0IHA9bnx8aS5kdHlwZSxkPXQodSxwLHIpO3JldHVybiBvLm1ha2VUZW5zb3JJbmZvKGkuc2hhcGUscCxkKX19dmFyIFJFPWZyKGU9Pk1hdGguY2VpbChlKSksSTg9RnMoT2ksUkUpLFM4PXtrZXJuZWxOYW1lOk9pLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpJOH07ZnVuY3Rpb24gTDEoZSx0LG4sYSl7bGV0IHI9dy5nZXRBcnJheUZyb21EVHlwZShuLHcuc2l6ZUZyb21TaGFwZSh0KSk7aWYoYSYmbiE9PVwic3RyaW5nXCIpe2xldCBzPTA7ZS5mb3JFYWNoKGk9PntsZXQgbz13LnNpemVGcm9tU2hhcGUoaS5zaGFwZSk7ci5zZXQoaS52YWxzLHMpLHMrPW99KX1lbHNle2xldCBzPTA7ZS5mb3JFYWNoKGk9PntsZXQgbz1uPT09XCJzdHJpbmdcIj9ULmZyb21VaW50OFRvU3RyaW5nQXJyYXkoaS52YWxzKTppLnZhbHMsbD0wO2ZvcihsZXQgdT0wO3U8aS5zaGFwZVswXTsrK3Upe2xldCBwPXUqdFsxXStzO2ZvcihsZXQgZD0wO2Q8aS5zaGFwZVsxXTsrK2QpcltwK2RdPW9bbCsrXX1zKz1pLnNoYXBlWzFdfSl9cmV0dXJuIHJ9dmFyIE1FPU10KChlLHQpPT5lPT09dD8xOjApLE9FPVp0KGR1LE1FLG51bGwsXCJib29sXCIpLE44PXtrZXJuZWxOYW1lOmR1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpPRX0sUEU9ZnIoZT0+TWF0aC5leHAoZSkpLExFPUZzKEtpLFBFLFwiZmxvYXQzMlwiKSxUOD17a2VybmVsTmFtZTpLaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6TEV9LHpFPWZyKGU9Pk1hdGguZXhwbTEoZSkpLEM4PUZzKFhpLHpFKSxFOD17a2VybmVsTmFtZTpYaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Qzh9LFdFPWZyKGU9Pk1hdGguZmxvb3IoZSkpLF84PUZzKFlpLFdFKSxBOD17a2VybmVsTmFtZTpZaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Xzh9LEJFPU10KChlLHQpPT5NYXRoLmZsb29yKGUvdCkpLEY4PVp0KFppLEJFLG51bGwsXCJpbnQzMlwiKSwkOD17a2VybmVsTmFtZTpaaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Rjh9O2Z1bmN0aW9uIFZFKGUsdCxuLGEscixzLGksbyxsKXtsZXQgdT1PZShbYSxzXSxuKTtmb3IobGV0IHA9MDtwPGE7cCsrKXtsZXQgZD1bXSxjPTA7Zm9yKGxldCBoPTA7aDxyO2grKyl7bGV0IG09ZVtwKnIraF07Yys9bSppW2hdLGQucHVzaChtKX1pZihjPDB8fGM+PWwvcyl0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaW5kaWNlczogJHtkfSBkb2VzIG5vdCBpbmRleCBpbnRvICR7b31gKTtmb3IobGV0IGg9MDtoPHM7aCsrKXUudmFsdWVzW3AqcytoXT10LmdldCguLi50LmluZGV4VG9Mb2MoYypzK2gpKX1yZXR1cm4gdX1mdW5jdGlvbiBVRShlLHQsbil7bGV0IGE9T2UobixlLmR0eXBlKTtmb3IobGV0IHI9MDtyPGEuc2l6ZTsrK3Ipe2xldCBzPWEuaW5kZXhUb0xvYyhyKS5zbGljZSgpLGk9c1swXSxvPXNbMl0sbD10LmxvY1RvSW5kZXgoW2ksb10pO3NbMl09dC52YWx1ZXNbbF07bGV0IHU9ZS5sb2NUb0luZGV4KHMpOzA8PXUmJnU8ZS52YWx1ZXMubGVuZ3RoJiYoYS52YWx1ZXNbcl09ZS52YWx1ZXNbdV0pfXJldHVybiBhfXZhciBHRT1NdCgoZSx0KT0+ZT50PzE6MCksRDg9WnQoYnUsR0UsbnVsbCxcImJvb2xcIiksUjg9e2tlcm5lbE5hbWU6YnUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOkQ4fSxIRT1NdCgoZSx0KT0+ZT49dD8xOjApLE04PVp0KFFpLEhFLG51bGwsXCJib29sXCIpLE84PXtrZXJuZWxOYW1lOlFpLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpNOH0sakU9TXQoKGUsdCk9PmU8dD8xOjApLFA4PVp0KHl1LGpFLG51bGwsXCJib29sXCIpLEw4PXtrZXJuZWxOYW1lOnl1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpQOH0scUU9TXQoKGUsdCk9PmU8PXQ/MTowKSx6OD1adCh4dSxxRSxudWxsLFwiYm9vbFwiKSxXOD17a2VybmVsTmFtZTp4dSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6ejh9O2Z1bmN0aW9uIEtFKGUsdCxuKXtsZXQgYT0odC1lKS8obi0xKSxyPXcubWFrZVplcm9zVHlwZWRBcnJheShuLFwiZmxvYXQzMlwiKTtyWzBdPWU7Zm9yKGxldCBzPTE7czxyLmxlbmd0aDtzKyspcltzXT1yW3MtMV0rYTtyZXR1cm4gcn12YXIgWEU9ZnIoZT0+TWF0aC5sb2coZSkpLEI4PUZzKHNvLFhFKSxWOD17a2VybmVsTmFtZTpzbyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Qjh9O2Z1bmN0aW9uIFlFKGUsdCxuLGEpe2xldCByPXcuZ2V0VHlwZWRBcnJheUZyb21EVHlwZShhLHcuc2l6ZUZyb21TaGFwZShuKSk7Zm9yKGxldCBzPTA7czxyLmxlbmd0aDsrK3Mpe2xldCBpPXMqdCxvPWVbaV07Zm9yKGxldCBsPTA7bDx0OysrbCl7bGV0IHU9ZVtpK2xdOyhOdW1iZXIuaXNOYU4odSl8fHU+bykmJihvPXUpfXJbc109b31yZXR1cm4gcn12YXIgWkU9TXQoKGUsdCk9Pk1hdGgubWF4KGUsdCkpLFU4PVp0KHVvLFpFKSxHOD17a2VybmVsTmFtZTp1byxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6VTh9LEpFPU10KChlLHQpPT5NYXRoLm1pbihlLHQpKSxIOD1adChtbyxKRSksajg9e2tlcm5lbE5hbWU6bW8sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOkg4fSx6MT1NdCgoZSx0KT0+ZSp0KSxxOD1PMSgoZSx0LG4sYSk9Pih7cmVhbDplKm4tdCphLGltYWc6ZSphK3Qqbn0pKSx6Zj1adChibyx6MSxxOCksSzg9e2tlcm5lbE5hbWU6Ym8sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOnpmfTtmdW5jdGlvbiBRRShlLHQsbil7bGV0IGE9dy5jcmVhdGVTY2FsYXJWYWx1ZSgtMSxuKTtyZXR1cm4gejEoW10sdCxhLGUsbil9ZnVuY3Rpb24gWDgoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7eDphfT10O2dlKGEsXCJuZWdcIik7bGV0IHI9bi5kYXRhLmdldChhLmRhdGFJZCkudmFsdWVzLFtzLGldPVFFKHIsYS5zaGFwZSxhLmR0eXBlKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhpLGEuZHR5cGUscyl9dmFyIFk4PXtrZXJuZWxOYW1lOkN1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpYOH0sZV89TXQoKGUsdCk9PmUhPT10PzE6MCksWjg9WnQoRXUsZV8sbnVsbCxcImJvb2xcIiksSjg9e2tlcm5lbE5hbWU6RXUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOlo4fTtmdW5jdGlvbiBXMShlLHQsbixhLHIpe2xldCBzPXQubGVuZ3RoLGk9dy5zaXplRnJvbVNoYXBlKHQpLG89dy5jb21wdXRlU3RyaWRlcyh0KSxsPXcuY29tcHV0ZVN0cmlkZXMociksdT13LmdldFR5cGVkQXJyYXlGcm9tRFR5cGUobix3LnNpemVGcm9tU2hhcGUocikpO2ZvcihsZXQgcD0wO3A8aTsrK3Ape2xldCBkPXcuaW5kZXhUb0xvYyhwLHMsbyksYz1uZXcgQXJyYXkoZC5sZW5ndGgpO2ZvcihsZXQgbT0wO208Yy5sZW5ndGg7bSsrKWNbbV09ZFthW21dXTtsZXQgaD13LmxvY1RvSW5kZXgoYyxzLGwpO3VbaF09ZVtwXX1yZXR1cm4gdX1mdW5jdGlvbiBWbihlKXtsZXR7aW5wdXRzOnQsYXR0cnM6bixiYWNrZW5kOmF9PWUse3g6cn09dCx7cGVybTpzfT1uO2dlKHIsXCJ0cmFuc3Bvc2VcIik7bGV0IGk9ci5zaGFwZS5sZW5ndGgsbz1uZXcgQXJyYXkoaSk7Zm9yKGxldCBwPTA7cDxvLmxlbmd0aDtwKyspb1twXT1yLnNoYXBlW3NbcF1dO2xldCBsPWEuZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyx1PVcxKGwsci5zaGFwZSxyLmR0eXBlLHMsbyk7cmV0dXJue2RhdGFJZDphLndyaXRlKHUsbyxyLmR0eXBlKSxzaGFwZTpvLGR0eXBlOnIuZHR5cGV9fXZhciBROD17a2VybmVsTmFtZTpDcixiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Vm59O2Z1bmN0aW9uIHRfKGUsdCxuLGEpe2xldFtyLHNdPVQuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhlLGEpLGk9ZmEodCxcImludDMyXCIpLG89dy5tYWtlWmVyb3NUeXBlZEFycmF5KHcuc2l6ZUZyb21TaGFwZShyKSxpKSxsPXcuc2l6ZUZyb21TaGFwZShzKTtmb3IobGV0IHU9MDt1PG8ubGVuZ3RoOysrdSl7bGV0IHA9dSpsLGQ9MTtmb3IobGV0IGM9MDtjPGw7KytjKWQqPW5bcCtjXTtvW3VdPWR9cmV0dXJue291dFZhbHM6byxvdXRTaGFwZTpyLG91dER0eXBlOml9fWZ1bmN0aW9uIGVLKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtheGlzOnMsa2VlcERpbXM6aX09YTtnZShyLFwicHJvZFwiKTtsZXQgbz1yLnNoYXBlLmxlbmd0aCxsPXcucGFyc2VBeGlzUGFyYW0ocyxyLnNoYXBlKSx1PVQuZ2V0QXhlc1Blcm11dGF0aW9uKGwsbykscD1sLGQ9cixjPVtdO3UhPW51bGwmJihkPVZuKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntwZXJtOnV9fSksYy5wdXNoKGQpLHA9VC5nZXRJbm5lck1vc3RBeGVzKHAubGVuZ3RoLG8pKTtsZXQgaD1uLmRhdGEuZ2V0KGQuZGF0YUlkKS52YWx1ZXMse291dFZhbHM6bSxvdXRTaGFwZTpmLG91dER0eXBlOmd9PXRfKGQuc2hhcGUsZC5kdHlwZSxoLHApLGI9ZjtyZXR1cm4gaSYmKGI9VC5leHBhbmRTaGFwZVRvS2VlcERpbShmLGwpKSxjLmZvckVhY2goeT0+bi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh5KSksbi5tYWtlVGVuc29ySW5mbyhiLGcsbSl9dmFyIHRLPXtrZXJuZWxOYW1lOmtvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzplS307ZnVuY3Rpb24gbksoZSx0LG4pe2UuZm9yRWFjaCgoYSxyKT0+e2lmKGE8MHx8YT49bil7bGV0IHM9dy5pbmRleFRvTG9jKHIsdC5sZW5ndGgsdy5jb21wdXRlU3RyaWRlcyh0KSkuam9pbihcIixcIik7dGhyb3cgbmV3IEVycm9yKGBpbmRpY2VzWyR7c31dID0gJHthfSBpcyBub3QgaW4gWzAsICR7bn0pYCl9fSl9ZnVuY3Rpb24gYUsoZSx0KXtmb3IobGV0IG49MDtuPGUubGVuZ3RoOysrbil7bGV0IGE9ZVtuXSxyPW49PT1lLmxlbmd0aC0xP3Q6ZVtuKzFdLmxlbmd0aDtpZihhLmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKFwiUmFnZ2VkIHNwbGl0cyBtYXkgbm90IGJlIGVtcHR5XCIpO2lmKGFbMF08MCl0aHJvdyBuZXcgRXJyb3IoXCJSYWdnZWQgc3BsaXRzIG11c3QgYmUgbm9uLW5lZ2F0aXZlXCIpO2lmKGFbYS5sZW5ndGgtMV0+cil0aHJvdyBuZXcgRXJyb3IoXCJSYWdnZWQgc3BsaXRzIG11c3Qgbm90IHBvaW50IHBhc3QgdmFsdWVzXCIpO2ZvcihsZXQgcz0xO3M8YS5sZW5ndGg7KytzKWlmKGFbcy0xXT5hW3NdKXRocm93IG5ldyBFcnJvcihcIlJhZ2dlZCBzcGxpdHMgbXVzdCBiZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyXCIpfX1mdW5jdGlvbiBySyhlLHQsbixhKXtsZXQgcj1bXSxzPTAsaT10Lmxlbmd0aC0xK24ubGVuZ3RoLG89bmV3IEFycmF5KGkpLmZpbGwobnVsbCkubWFwKCgpPT5bMF0pO2FLKG4sYSk7bGV0IGw9MTtmb3IobGV0IHU9MDt1PHQubGVuZ3RoLTE7Kyt1KXtsKj10W3VdO2xldCBwPXRbdSsxXTtmb3IobGV0IGQ9MTtkPGwrMTsrK2Qpb1t1XS5wdXNoKGQqcCl9Zm9yKGxldCB1PTA7dTxlLmxlbmd0aDsrK3Upe2xldCBwPWVbdV0sZD1lW3VdKzE7Zm9yKGxldCBjPTA7YzxuLmxlbmd0aDsrK2Mpe2xldCBoPW5bY10sbT1jK3QubGVuZ3RoLTE7aWYobT49MCl7bGV0IGY9b1ttXSxnPWZbZi5sZW5ndGgtMV0taFtwXTtmb3IobGV0IGI9cDtiPGQ7KytiKW9bbV0ucHVzaChoW2IrMV0rZyl9cD1oW3BdLGQ9aFtkXX1kIT09cCYmKHIucHVzaChbcCxkXSkscys9ZC1wKX1yZXR1cm57b3V0U3BsaXRzOm8sdmFsdWVTbGljZXM6cixudW1WYWx1ZXM6c319ZnVuY3Rpb24gc0soZSl7bGV0IHQ9W107Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDsrK24pe2xldCBhPWVbbl0ubGVuZ3RoLHI9dy5nZXRBcnJheUZyb21EVHlwZShcImludDMyXCIsYSk7dC5wdXNoKHIpLGVbbl0uZm9yRWFjaCgocyxpKT0+cltpXT1zKX1yZXR1cm4gdH1mdW5jdGlvbiBZSShlLHQpe2xldCBuPWUuc2xpY2UoMCx0KTtmb3IoO24ubGVuZ3RoPHQ7KW4ucHVzaCgxKTtmb3IobGV0IGE9dDthPGUubGVuZ3RoO2ErKyluW3QtMV0qPWVbYV07cmV0dXJuIG59ZnVuY3Rpb24gaUsoZSx0LG4sYSxyLHMpe2xldCBpPVlJKHQsMilbMV0sbz1ZSShzLDIpWzFdLGw9MDtmb3IobGV0IHUgb2Ygbilmb3IobGV0IHA9dVswXTtwPHVbMV07KytwKXtmb3IobGV0IGQ9MDtkPGE7KytkKXJbbCpvK2RdPWVbcCppK2RdOysrbH19ZnVuY3Rpb24gb0soZSx0LG4sYSxyKXtsZXQgcz10LnNsaWNlKCk7c1swXT1yO2xldCBpPXcuZ2V0QXJyYXlGcm9tRFR5cGUobix3LnNpemVGcm9tU2hhcGUocykpLG89ZS5sZW5ndGgsbD1vPT09MD8wOm8vdFswXTtyZXR1cm4gaUsoZSx0LGEsbCxpLHMpLFtpLHNdfWZ1bmN0aW9uIG5fKGUsdCxuLGEscixzLGksbyl7aWYoZS5sZW5ndGg9PT0wKXRocm93IG5ldyBFcnJvcihcInBhcmFtc05lc3RlZFNwbGl0cyBtdXN0IGJlIG5vbiBlbXB0eVwiKTtpZih0WzBdLmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKFwiU3BsaXQgdGVuc29ycyBtdXN0IG5vdCBiZSBzY2FsYXJzXCIpO2xldCBsPXRbMF1bMF0tMTtpZihuSyhzLGksbCksYS5sZW5ndGg9PT0wKXRocm93IG5ldyBFcnJvcihcInBhcmFtcy5yYW5rIG11c3QgYmUgbm9uemVyb1wiKTtsZXQgdT1hWzBdLHtvdXRTcGxpdHM6cCx2YWx1ZVNsaWNlczpkLG51bVZhbHVlczpjfT1ySyhzLGksZSx1KSxoPXNLKHApLG09b0sobixhLHIsZCxjKTtyZXR1cm5baCxtWzBdLG1bMV1dfXZhciBaST0yMTQ3NDgzNjQ3O2Z1bmN0aW9uIGFfKGUsdCxuLGEscixzLGkpe2lmKHQubGVuZ3RoPjEpdGhyb3cgbmV3IEVycm9yKFwic3RhcnRzIG11c3QgYmUgYSBzY2FsYXIgb3IgdmVjdG9yXCIpO2lmKHIubGVuZ3RoPjEpdGhyb3cgbmV3IEVycm9yKFwibGltaXRzIG11c3QgYmUgYSBzY2FsYXIgb3IgdmVjdG9yXCIpO2lmKGkubGVuZ3RoPjEpdGhyb3cgbmV3IEVycm9yKFwiZGVsdGFzIG11c3QgYmUgYSBzY2FsYXIgb3IgdmVjdG9yXCIpO2xldCBvPXQubGVuZ3RoPT09MCxsPXIubGVuZ3RoPT09MCx1PWkubGVuZ3RoPT09MCxwPVtdO298fHAucHVzaCh0WzBdKSxsfHxwLnB1c2goclswXSksdXx8cC5wdXNoKGlbMF0pO2ZvcihsZXQgZz0xO2c8cC5sZW5ndGg7KytnKWlmKHBbZ10hPT1wW2ctMV0pdGhyb3cgbmV3IEVycm9yKFwic3RhcnRzLCBsaW1pdHMsIGFuZCBkZWx0YXMgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlXCIpO2xldCBkPXAubGVuZ3RoPT09MD8xOnBbMF0sYz13LmdldEFycmF5RnJvbURUeXBlKFwiaW50MzJcIixkKzEpO2NbMF09MDtmb3IobGV0IGc9MDtnPGQ7KytnKXtsZXQgYj1vP2VbMF06ZVtnXSx5PWw/YVswXTphW2ddLHg9dT9zWzBdOnNbZ107aWYoeD09PTApdGhyb3cgbmV3IEVycm9yKFwiUmVxdWlyZXMgZGVsdGEgIT0gMFwiKTtsZXQgdjtpZih4PjAmJnk8Ynx8eDwwJiZ5PmIpdj0wO2Vsc2UgaWYodj1NYXRoLmNlaWwoTWF0aC5hYnMoKHktYikveCkpLHY+WkkpdGhyb3cgbmV3IEVycm9yKGBSZXF1aXJlcyAoKGxpbWl0IC0gc3RhcnQpIC8gZGVsdGEpIDw9ICR7Wkl9YCk7Y1tnKzFdPWNbZ10rdn1sZXQgaD1jW2RdLG09dy5nZXRBcnJheUZyb21EVHlwZShuLGgpLGY9MDtmb3IobGV0IGc9MDtnPGQ7KytnKXtsZXQgYj1jW2crMV0tY1tnXSx5PW8/ZVswXTplW2ddLHg9dT9zWzBdOnNbZ107Zm9yKGxldCB2PTA7djxiOysrdiltW2YrK109eSx5Kz14fXJldHVybltjLG1dfXZhciBOYT1ULlJvd1BhcnRpdGlvblR5cGUsbEs9Y2xhc3Mgb3Z7Y29uc3RydWN0b3IodCxuLGEscixzLGksbyxsLHUscCl7dGhpcy5zaGFwZT10LHRoaXMuc2hhcGVTaGFwZT1uLHRoaXMudmFsdWVzPWEsdGhpcy52YWx1ZXNTaGFwZT1yLHRoaXMudmFsdWVzRFR5cGU9cyx0aGlzLmRlZmF1bHRWYWx1ZT1pLHRoaXMuZGVmYXVsdFZhbHVlU2hhcGU9byx0aGlzLnJvd1BhcnRpdGlvblZhbHVlcz1sLHRoaXMucm93UGFydGl0aW9uVmFsdWVzU2hhcGVzPXUsdGhpcy5yb3dQYXJ0aXRpb25UeXBlcz1ULmdldFJvd1BhcnRpdGlvblR5cGVzSGVscGVyKHApLHRoaXMucmFnZ2VkUmFuaz1ULmdldFJhZ2dlZFJhbmsodGhpcy5yb3dQYXJ0aXRpb25UeXBlcyl9Z2V0Um93UGFydGl0aW9uVHlwZUJ5RGltZW5zaW9uKHQpe3JldHVybiB0aGlzLnJvd1BhcnRpdGlvblR5cGVzWzBdPT09TmEuRklSU1RfRElNX1NJWkU/dGhpcy5yb3dQYXJ0aXRpb25UeXBlc1t0KzFdOnRoaXMucm93UGFydGl0aW9uVHlwZXNbdF19Z2V0Um93UGFydGl0aW9uVGVuc29yKHQpe3JldHVybiB0aGlzLnJvd1BhcnRpdGlvblR5cGVzWzBdPT09TmEuRklSU1RfRElNX1NJWkU/dGhpcy5yb3dQYXJ0aXRpb25WYWx1ZXNbdCsxXTp0aGlzLnJvd1BhcnRpdGlvblZhbHVlc1t0XX1nZXRNYXhXaWR0aCh0KXtsZXQgbj10aGlzLmdldFJvd1BhcnRpdGlvblRlbnNvcih0LTEpO3N3aXRjaCh0aGlzLmdldFJvd1BhcnRpdGlvblR5cGVCeURpbWVuc2lvbih0LTEpKXtjYXNlIE5hLlZBTFVFX1JPV0lEUzpyZXR1cm4gb3YuZ2V0TWF4V2lkdGhWYWx1ZVJvd0lEKG4pO2Nhc2UgTmEuUk9XX1NQTElUUzpyZXR1cm4gb3YuZ2V0TWF4V2lkdGhSb3dTcGxpdChuKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgQ2Fubm90IGhhbmRsZSBwYXJ0aXRpb24gdHlwZSAke05hW3RoaXMuZ2V0Um93UGFydGl0aW9uVHlwZUJ5RGltZW5zaW9uKHQtMSldfWApfX1zdGF0aWMgZ2V0TWF4V2lkdGhSb3dTcGxpdCh0KXtsZXQgbj10Lmxlbmd0aDtpZihuPT09MHx8bj09PTEpcmV0dXJuIDA7bGV0IGE9MDtmb3IobGV0IHI9MDtyPG4tMTsrK3Ipe2xldCBzPXRbcisxXS10W3JdO3M+YSYmKGE9cyl9cmV0dXJuIGF9c3RhdGljIGdldE1heFdpZHRoVmFsdWVSb3dJRCh0KXtsZXQgbj10Lmxlbmd0aDtpZihuPT09MClyZXR1cm4gMDtsZXQgYT0wLHI9dFswXSxzPTA7Zm9yKGxldCBpPTE7aTxuOysraSl7bGV0IG89dFtpXTtvIT09ciYmKHI9byxzPU1hdGgubWF4KGktYSxzKSxhPWkpfXJldHVybiBNYXRoLm1heChuLWEscyl9dGVuc29yU2hhcGVGcm9tVGVuc29yKHQsbixhPSEwKXtpZihuLmxlbmd0aD09PTApe2lmKHRbMF09PT0tMSlyZXR1cm5bXTt0aHJvdyBuZXcgRXJyb3IoXCJUaGUgb25seSB2YWxpZCBzY2FsYXIgc2hhcGUgdGVuc29yIGlzIHRoZSBmdWxseSB1bmtub3duIHNoYXBlIHNwZWNpZmllZCBhcyAtMS5cIil9cmV0dXJuIFFJKHQsYSl9Y2FsY3VsYXRlT3V0cHV0U2l6ZSh0KXtsZXQgbj10aGlzLnZhbHVlc1NoYXBlLGE9dGhpcy5kZWZhdWx0VmFsdWVTaGFwZTtULnZhbGlkYXRlRGVmYXVsdFZhbHVlU2hhcGUoYSxuKTtsZXQgcj10aGlzLnRlbnNvclNoYXBlRnJvbVRlbnNvcih0aGlzLnNoYXBlLHRoaXMuc2hhcGVTaGFwZSkscz1ULmNvbWJpbmVSYWdnZWRUZW5zb3JUb1RlbnNvclNoYXBlcyh0aGlzLnJhZ2dlZFJhbmsscixuKTtzWzBdPDAmJihzWzBdPXQpO2ZvcihsZXQgaT0xO2k8PXRoaXMucmFnZ2VkUmFuazsrK2kpc1tpXTwwJiYoc1tpXT10aGlzLmdldE1heFdpZHRoKGkpKTtyZXR1cm4gc31jYWxjdWxhdGVGaXJzdFBhcmVudE91dHB1dEluZGV4KHQsbixhKXtsZXQgcj1NYXRoLm1pbih0LGEpLHM9W10saT0wO2ZvcihsZXQgbz0wO288cjsrK28saSs9bilzLnB1c2goaSk7Zm9yKGxldCBvPXI7bzx0OysrbylzLnB1c2goLTEpO3JldHVybiB3LmFzc2VydChzLmxlbmd0aD09PXQsKCk9PlwiRmluYWwgbGVuZ3RoIG9mIHJlc3VsdCBtdXN0IGJlIGVxdWFsIHRvIGZpcnN0RGltZW5zaW9uLlwiKSxzfWNhbGN1bGF0ZU91dHB1dEluZGV4Um93U3BsaXQodCxuLGEscil7bGV0IHM9dC5sZW5ndGgsaT1bXTtmb3IobGV0IG89MDtvPHMtMTsrK28pe2xldCBsPXRbbysxXS10W29dLHU9TWF0aC5taW4ocixsKSxwPW5bb107cD09PS0xJiYodT0wKTtmb3IobGV0IGQ9MDtkPHU7KytkKWkucHVzaChwKSxwKz1hO2ZvcihsZXQgZD0wO2Q8bC11OysrZClpLnB1c2goLTEpfWlmKHM+MCYmaS5sZW5ndGghPT10W3MtMV0pdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3cgc3BsaXQgc2l6ZS5cIik7cmV0dXJuIGl9Y2FsY3VsYXRlT3V0cHV0SW5kZXhWYWx1ZVJvd0lEKHQsbixhLHIpe2xldCBzPXQubGVuZ3RoLGk9W107aWYocz09PTApcmV0dXJuW107bGV0IG89MCxsPXRbMF07aWYobD49bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBHb3QgY3VycmVudFZhbHVlUm93SWQ9JHtsfSwgd2hpY2ggaXMgbm90IGxlc3MgdGhhbiAke24ubGVuZ3RofWApO2xldCB1PW5bbF07aS5wdXNoKHUpO2ZvcihsZXQgcD0xO3A8czsrK3Ape2xldCBkPXRbcF07aWYoZD09PWwpdT49MCYmKCsrbyxvPHI/dSs9YTp1PS0xKTtlbHNle2lmKG89MCxsPWQsZD49bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBHb3QgbmV4dFZhbHVlUm93SWQ9JHtkfSB3aGljaCBpcyBub3QgbGVzcyB0aGFuICR7bi5sZW5ndGh9YCk7dT1uW2RdfWkucHVzaCh1KX1pZihpLmxlbmd0aCE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm93IGlkcy5cIik7cmV0dXJuIGl9Y2FsY3VsYXRlT3V0cHV0SW5kZXgodCxuLGEscil7bGV0IHM9dGhpcy5nZXRSb3dQYXJ0aXRpb25UZW5zb3IodCksaT10aGlzLmdldFJvd1BhcnRpdGlvblR5cGVCeURpbWVuc2lvbih0KTtzd2l0Y2goaSl7Y2FzZSBOYS5WQUxVRV9ST1dJRFM6cmV0dXJuIHRoaXMuY2FsY3VsYXRlT3V0cHV0SW5kZXhWYWx1ZVJvd0lEKHMsbixhLHIpO2Nhc2UgTmEuUk9XX1NQTElUUzppZihzLmxlbmd0aC0xPm4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgUm93IHBhcnRpdGlvbiBzaXplIGlzIGdyZWF0ZXIgdGhhbiBvdXRwdXQgc2l6ZTogJHtzLmxlbmd0aC0xfSA+ICR7bi5sZW5ndGh9YCk7cmV0dXJuIHRoaXMuY2FsY3VsYXRlT3V0cHV0SW5kZXhSb3dTcGxpdChzLG4sYSxyKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGFydGl0aW9uIHR5cGU6ICR7TmFbaV19YCl9fWdldEZpcnN0RGltZW5zaW9uU2l6ZSgpe2xldCB0PXRoaXMucm93UGFydGl0aW9uVmFsdWVzWzBdO2lmKHRoaXMucm93UGFydGl0aW9uVHlwZXMubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJObyByb3dfcGFydGl0aW9uX3R5cGVzIGdpdmVuLlwiKTtsZXQgbj10aGlzLnJvd1BhcnRpdGlvblR5cGVzWzBdO3N3aXRjaChuKXtjYXNlIE5hLkZJUlNUX0RJTV9TSVpFOnJldHVybiB0WzBdO2Nhc2UgTmEuVkFMVUVfUk9XSURTOnRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBoYW5kbGUgVkFMVUVfUk9XSURTIGluIGZpcnN0IGRpbWVuc2lvbi5cIik7Y2FzZSBOYS5ST1dfU1BMSVRTOnJldHVybiB0aGlzLnJvd1BhcnRpdGlvblZhbHVlc1NoYXBlc1swXVswXS0xO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgaGFuZGxlIHR5cGUgJHtOYVtuXX1gKX19Y29tcHV0ZSgpe2lmKHRoaXMucm93UGFydGl0aW9uVmFsdWVzWzBdLmxlbmd0aDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGZpcnN0IHBhcnRpdGlvbiBpbnB1dC4gVGVuc29yIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBlbGVtZW50LlwiKTtsZXQgdD10aGlzLmdldEZpcnN0RGltZW5zaW9uU2l6ZSgpLG49dGhpcy5jYWxjdWxhdGVPdXRwdXRTaXplKHQpLGE9bmV3IEFycmF5KHRoaXMucmFnZ2VkUmFuaysxKTthW2EubGVuZ3RoLTFdPTE7Zm9yKGxldCBpPWEubGVuZ3RoLTI7aT49MDstLWkpYVtpXT1hW2krMV0qbltpKzFdO2xldCByPVFJKG4sITEpLHM9dy5nZXRBcnJheUZyb21EVHlwZSh0aGlzLnZhbHVlc0RUeXBlLHcuc2l6ZUZyb21TaGFwZShyKSk7aWYoYVswXSpuWzBdPjApe2xldCBpPXRoaXMuY2FsY3VsYXRlRmlyc3RQYXJlbnRPdXRwdXRJbmRleCh0LGFbMF0sblswXSk7Zm9yKGxldCBvPTE7bzw9dGhpcy5yYWdnZWRSYW5rOysrbylpPXRoaXMuY2FsY3VsYXRlT3V0cHV0SW5kZXgoby0xLGksYVtvXSxuW29dKTt0aGlzLnNldE91dHB1dCh0aGlzLnJhZ2dlZFJhbmssaSxzLHIpfXJldHVybltyLHNdfXNldE91dHB1dCh0LG4sYSxyKXtpZihhLmxlbmd0aD09PTApcmV0dXJuO2xldCBzPXRoaXMudmFsdWVzLGk9YSxvPXIuc2xpY2UoKTtvPW8uc2xpY2UodCsxKTtsZXQgbD13LnNpemVGcm9tU2hhcGUobyksdT1uLmxlbmd0aCxwPXRoaXMuZGVmYXVsdFZhbHVlO2lmKHAubGVuZ3RoIT09bCYmcC5sZW5ndGghPT0xKXtsZXQgbT10aGlzLmRlZmF1bHRWYWx1ZVNoYXBlO08oKCk9PntsZXQgZj1XKHAsbSk7cD1haShmLG8pLmRhdGFTeW5jKCl9KX1sZXQgZD0wLGM9MCxoPTA7Zm9yKGxldCBtPTA7bTw9dTsrK20pe2xldCBmPW08dT9uW21dOi0xO2lmKGY9PT1oKXsrK2g7Y29udGludWV9aWYoYzxoKXtsZXQgZz1zLnN1YmFycmF5KGQqbCksYj1pLnN1YmFycmF5KGMqbCkseT0oaC1jKSpsO0pJKGIsZyx5KX1pZihtPj11KXtsZXQgZz1hLmxlbmd0aDtmPU1hdGguZmxvb3IoZy9sKX1pZihmPmgpaWYodGhpcy5kZWZhdWx0VmFsdWUubGVuZ3RoPT09MSlpLnN1YmFycmF5KGgqbCxmKmwpLmZpbGwodGhpcy5kZWZhdWx0VmFsdWVbMF0pLGg9ZjtlbHNlIGZvcig7Zj5oOyl7bGV0IGc9aS5zbGljZShoKmwpO0pJKGcscCxsKSwrK2h9ZjwwPyhkPW0rMSxjPWgpOihkPW0sYz1oLGg9YysxKX19fTtmdW5jdGlvbiBKSShlLHQsbil7Zm9yKGxldCBhPTA7YTxuO2ErKyllW2FdPXRbYV19ZnVuY3Rpb24gUUkoZSx0KXtsZXQgbj1bXTtmb3IobGV0IGEgb2YgZSl7aWYoYTwwKXtpZighdCl0aHJvdyBuZXcgRXJyb3IoYERpbWVuc2lvbiAke2F9IG11c3QgYmUgPj0gMGApO2lmKGE8LTEpdGhyb3cgbmV3IEVycm9yKGBEaW1lbnNpb24gJHthfSBtdXN0IGJlID49IC0xYCk7YT0tMX1uLnB1c2goYSl9cmV0dXJuIG59ZnVuY3Rpb24gcl8oZSx0LG4sYSxyLHMsaSxvLGwsdSl7cmV0dXJuIG5ldyBsSyhlLHQsbixhLHIscyxpLG8sbCx1KS5jb21wdXRlKCl9ZnVuY3Rpb24gQjEoZSx0LG4sYSl7bGV0IHI9ZT09PXQscz1lPHQmJm48MCxpPXQ8ZSYmbj4xO2lmKHJ8fHN8fGkpcmV0dXJuIHcubWFrZVplcm9zVHlwZWRBcnJheSgwLGEpO2xldCBvPU1hdGguYWJzKE1hdGguY2VpbCgodC1lKS9uKSksbD13Lm1ha2VaZXJvc1R5cGVkQXJyYXkobyxhKTt0PGUmJm49PT0xJiYobj0tMSksbFswXT1lO2ZvcihsZXQgdT0xO3U8bC5sZW5ndGg7dSsrKWxbdV09bFt1LTFdK247cmV0dXJuIGx9dmFyIHNfPWZyKGU9PjEvTWF0aC5zcXJ0KGUpKSx1Sz1GcyhBbyxzXykscEs9e2tlcm5lbE5hbWU6QW8sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOnVLfTtmdW5jdGlvbiBuaShlLHQsbixhLHIscyxpLG8sbCx1KXtsZXQgcD1bYS9yLHJdLGQ9ZS52YWx1ZXMsYz10LnZhbHVlcztpZihhPT09MClyZXR1cm4gT2Uobix0LmR0eXBlKTtsZXQgaD1sIGluc3RhbmNlb2YgV3Q/bDpPZShwLHQuZHR5cGUpO3R5cGVvZiBsPT1cInN0cmluZ1wifHx0eXBlb2YgbD09XCJudW1iZXJcIj9oLnZhbHVlcy5maWxsKGwpOnR5cGVvZiBsPT1cImJvb2xlYW5cIiYmaC52YWx1ZXMuZmlsbCgrbCk7Zm9yKGxldCBtPTA7bTxzO20rKyl7bGV0IGY9W10sZz0wO2ZvcihsZXQgYj0wO2I8aTtiKyspe2xldCB5PWRbbSppK2JdO2YucHVzaCh5KSxnKz15Km9bYl19aWYoZzwwfHxnPj1hL3IpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGluZGljZXM6ICR7Zn0gZG9lcyBub3QgaW5kZXggaW50byAke259YCk7Zm9yKGxldCBiPTA7YjxyO2IrKyl1P2gudmFsdWVzW2cqcitiXSs9Y1ttKnIrYl06aC52YWx1ZXNbZypyK2JdPXQucmFuaz09PTA/Y1swXTpjW20qcitiXX1yZXR1cm4gaH12YXIgY0s9ZnIoZT0+MS8oMStNYXRoLmV4cCgtZSkpKSxpXz1sdChNbyxlPT4xLygxK01hdGguZXhwKC1lKSkpLGRLPXtrZXJuZWxOYW1lOk1vLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzppX307ZnVuY3Rpb24gdW0oZSx0LG4sYSxyKXtsZXQgcz1LdC5pc1NsaWNlQ29udGlub3VzKGEsdCxuKSxpPXcuc2l6ZUZyb21TaGFwZShuKSxvPXcuY29tcHV0ZVN0cmlkZXMoYSk7aWYocyl7bGV0IGQ9S3QuY29tcHV0ZUZsYXRPZmZzZXQodCxvKTtyZXR1cm4gcj09PVwic3RyaW5nXCI/ZS5zbGljZShkLGQraSk6ZS5zdWJhcnJheShkLGQraSl9bGV0IGw9cj09PVwic3RyaW5nXCI/VC5mcm9tVWludDhUb1N0cmluZ0FycmF5KGUpOmUsdT1PZShhLHIsbCkscD1PZShuLHIpO2ZvcihsZXQgZD0wO2Q8cC5zaXplOysrZCl7bGV0IGM9cC5pbmRleFRvTG9jKGQpLGg9Yy5tYXAoKG0sZik9Pm0rdFtmXSk7cC5zZXQodS5nZXQoLi4uaCksLi4uYyl9cmV0dXJuIHI9PT1cInN0cmluZ1wiP1QuZnJvbVN0cmluZ0FycmF5VG9VaW50OChwLnZhbHVlcyk6cC52YWx1ZXN9ZnVuY3Rpb24geGkoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2JlZ2luOnMsc2l6ZTppfT1hO2dlKHIsXCJzbGljZVwiKTtsZXRbbyxsXT1LdC5wYXJzZVNsaWNlUGFyYW1zKHIscyxpKTtLdC5hc3NlcnRQYXJhbXNWYWxpZChyLG8sbCk7bGV0IHU9bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLHA9dW0odSxvLGwsci5zaGFwZSxyLmR0eXBlKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhsLHIuZHR5cGUscCl9dmFyIGhLPXtrZXJuZWxOYW1lOkJ1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzp4aX07ZnVuY3Rpb24gb18oZSx0LG4sYSxyLHMsaSl7bGV0IG89dFswXSxsPXNbMF0sdT1uZXcgQXJyYXkobCkscD1uZXcgQXJyYXkobyksZD10WzFdO2lmKGw9PT0wKXtpZihvIT09MCl0aHJvdyBuZXcgRXJyb3IoVC5nZXRTcGFyc2VGaWxsRW1wdHlSb3dzSW5kaWNlc0RlbnNlU2hhcGVNaXNtYXRjaChvKSk7bGV0IGc9dy5nZXRBcnJheUZyb21EVHlwZShuLDApLGI9dy5nZXRBcnJheUZyb21EVHlwZShyLDApO3JldHVybltnLFswLGRdLGIsdSxwXX1sZXQgYz0hMCxoPTAsbT1uZXcgQXJyYXkobCkuZmlsbCgwKTtmb3IobGV0IGc9MDtnPG87KytnKXtsZXQgYj1lW2cqZF07aWYoYjwwKXRocm93IG5ldyBFcnJvcihULmdldFNwYXJzZUZpbGxFbXB0eVJvd3NOZWdhdGl2ZUluZGV4RXJyb3JNZXNzYWdlKGcsYikpO2lmKGI+PWwpdGhyb3cgbmV3IEVycm9yKFQuZ2V0U3BhcnNlRmlsbEVtcHR5Um93c091dE9mUmFuZ2VJbmRleEVycm9yTWVzc2FnZShnLGIsbCkpOysrbVtiXSxjPWMmJmI+PWgsaD1ifWxldCBmPSEwO2ZvcihsZXQgZz0wO2c8bDsrK2cpe2xldCBiPW1bZ109PT0wO3VbZ109YixmPWYmJiFiLG1bZ109TWF0aC5tYXgobVtnXSwxKSxnPjAmJihtW2ddKz1tW2ctMV0pfWlmKGYmJmMpe2xldCBnPWUsYj1hO2ZvcihsZXQgeT0wO3k8bzsrK3kpcFt5XT15O3JldHVybltnLFtvLGRdLGIsdSxwXX1lbHNle2xldCBnPW1bbC0xXSxiPXcuZ2V0QXJyYXlGcm9tRFR5cGUobixnKmQpLHk9dy5nZXRBcnJheUZyb21EVHlwZShyLGcpLHg9bmV3IEFycmF5KGwpLmZpbGwoMCk7Zm9yKGxldCB2PTA7djxvOysrdil7bGV0IEk9ZVt2KmRdLE49eFtJXSxDPShJPT09MD8wOm1bSS0xXSkrTjt4W0ldKys7Zm9yKGxldCBfPTA7XzxkOysrXyliW0MqZCtfXT1lW3YqZCtfXTt5W0NdPWFbdl0scFt2XT1DfWZvcihsZXQgdj0wO3Y8bDsrK3YpaWYoeFt2XT09PTApe2xldCBJPXY9PT0wPzA6bVt2LTFdO2JbSSpkKzBdPXY7Zm9yKGxldCBOPTE7TjxkOysrTiliW0kqZCtOXT0wO3lbSV09aX1yZXR1cm5bYixbZyxkXSx5LHUscF19fWZ1bmN0aW9uIGxfKGUsdCxuLGEscil7bGV0IHM9dy5zaXplRnJvbVNoYXBlKGEpLGk9dFswXSxvPXIubGVuZ3RoLGw9W10sdT0xLHA9LTE7Zm9yKGxldCBmPTA7ZjxvOysrZil7bGV0IGc9cltmXTtpZihnPT09LTEpe2lmKHAhPT0tMSl0aHJvdyBuZXcgRXJyb3IoVC5nZXRTcGFyc2VSZXNoYXBlTXVsdGlwbGVOZWdhdGl2ZU9uZU91dHB1dERpbUVycm9yTWVzc2FnZShwLGYpKTtwPWYsbC5wdXNoKDEpfWVsc2V7aWYoZzwwKXRocm93IG5ldyBFcnJvcihULmdldFNwYXJzZVJlc2hhcGVOZWdhdGl2ZU91dHB1dERpbUVycm9yTWVzc2FnZShmLGcpKTt1Kj1nLGwucHVzaChnKX19aWYocCE9PS0xKXtpZih1PD0wKXRocm93IG5ldyBFcnJvcihULmdldFNwYXJzZVJlc2hhcGVFbXB0eVRlbnNvclplcm9PdXRwdXREaW1FcnJvck1lc3NhZ2UoKSk7bGV0IGY9TWF0aC50cnVuYyhzL3UpO2lmKHUqZiE9PXMpdGhyb3cgbmV3IEVycm9yKFQuZ2V0U3BhcnNlUmVzaGFwZUlucHV0T3V0cHV0TXVsdGlwbGVFcnJvck1lc3NhZ2UoYSxsKSk7bFtwXT1mfWlmKHcuc2l6ZUZyb21TaGFwZShsKSE9PXMpdGhyb3cgbmV3IEVycm9yKFQuZ2V0U3BhcnNlUmVzaGFwZUlucHV0T3V0cHV0TWlzbWF0Y2hFcnJvck1lc3NhZ2UoYSxsKSk7bGV0IGQ9YS5sZW5ndGgsYz1bXTtpZihkPjApe2NbZC0xXT0xO2ZvcihsZXQgZj1kLTI7Zj49MDstLWYpY1tmXT1jW2YrMV0qYVtmKzFdfWxldCBoPVtdO2lmKG8+MCl7aFtvLTFdPTE7Zm9yKGxldCBmPW8tMjtmPj0wOy0tZiloW2ZdPWhbZisxXSpsW2YrMV19bGV0IG09dy5nZXRBcnJheUZyb21EVHlwZShuLGkqbyk7Zm9yKGxldCBmPTA7ZjxpOysrZil7bGV0IGc9MDtmb3IobGV0IGI9MDtiPGQ7KytiKWcrPWVbZipkK2JdKmNbYl07Zm9yKGxldCBiPTA7YjxvOysrYiltW2YqbytiXT1NYXRoLnRydW5jKGcvaFtiXSksZyU9aFtiXX1yZXR1cm5bbSxbaSxvXSxsXX1mdW5jdGlvbiBWMShlLHQsbixhLHIscz0hMSxpPTApe2xldCBvPWEubGVuZ3RoLGw9W3RbMF0sZS5sZW5ndGgvdFswXV0sdT1sWzFdLHA9bz4wP3Jbby0xXSsxOjA7aWYocDwwKXRocm93IG5ldyBFcnJvcihULmdldFNwYXJzZVNlZ21lbnRSZWR1Y3Rpb25OZWdhdGl2ZVNlZ21lbnRJZHNFcnJvck1lc3NhZ2UoKSk7bGV0IGQ9dC5zbGljZSgpO2RbMF09cDtsZXQgYz1kLnJlZHVjZSgoeSx4KT0+eSp4LDEpLGg9dy5nZXRBcnJheUZyb21EVHlwZShuLGMpO2lmKG89PT0wKXJldHVybiBwPjAmJmguZmlsbChpKSxbaCxkXTtpZihwPD0wKXRocm93IG5ldyBFcnJvcihULmdldFNwYXJzZVNlZ21lbnRSZWR1Y3Rpb25OZWdhdGl2ZVNlZ21lbnRJZHNFcnJvck1lc3NhZ2UoKSk7bGV0IG09MCxmPTEsZz0wLGI9clttXTtmb3IoOzspe2xldCB5PTA7aWYoZjxvKXtpZih5PXJbZl0sYj09PXkpeysrZjtjb250aW51ZX1pZihiPj15KXRocm93IG5ldyBFcnJvcihULmdldFNwYXJzZVNlZ21lbnRSZWR1Y3Rpb25Ob25JbmNyZWFzaW5nU2VnbWVudElkc0Vycm9yTWVzc2FnZSgpKX1pZihiPDB8fGI+PXApdGhyb3cgbmV3IEVycm9yKFQuZ2V0U3BhcnNlU2VnbWVudFJlZHVjdGlvblNlZ21lbnRJZE91dE9mUmFuZ2VFcnJvck1lc3NhZ2UoYixwKSk7Yj5nJiZoLmZpbGwoaSxnKnUsYip1KTtmb3IobGV0IHg9bTt4PGY7Kyt4KXtsZXQgdj1hW3hdO2lmKHY8MHx8dj49bFswXSl0aHJvdyBuZXcgRXJyb3IoVC5nZXRTcGFyc2VTZWdtZW50UmVkdWN0aW9uSW5kaWNlc091dE9mUmFuZ2VFcnJvck1lc3NhZ2UoeCxhW3hdLGxbMF0pKTtmb3IobGV0IEk9MDtJPHU7SSsrKWhbYip1K0ldKz1lW3YqdStJXX1pZihzKWZvcihsZXQgeD0wO3g8dTt4KyspaFtiKnUreF0vPWYtbTtpZihtPWYsKytmLGc9YisxLGI9eSxmPm8pYnJlYWt9cmV0dXJuIGc8cCYmaC5maWxsKGksZyp1LHAqdSksW2gsZF19dmFyIG1LPWZyKGU9Pk1hdGguc3FydChlKSksZks9bHQoUG8sZT0+TWF0aC5zcXJ0KGUpKSxnSz17a2VybmVsTmFtZTpQbyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Zkt9LHVfPU10KChlLHQpPT57bGV0IG49ZS10O3JldHVybiBuKm59KSxiSz1adChXbyx1XykseUs9e2tlcm5lbE5hbWU6V28sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmJLfSxwXz1mcigoZSx0KT0+e2xldHtwYXR0ZXJuOm4scmVwbGFjZUdsb2JhbDphLHJld3JpdGU6cn09dDtyZXR1cm4gZS5yZXBsYWNlKG5ldyBSZWdFeHAobixhP1wiZ1wiOlwiXCIpLHIpfSkseEs9RnMoS2MscF8pLHZLPXtrZXJuZWxOYW1lOktjLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzp4S307ZnVuY3Rpb24gY18oZSx0LG4sYSl7bGV0IHI9T2UoZSx0LmR0eXBlKTtmb3IobGV0IHM9MDtzPHIuc2l6ZTtzKyspe2xldCBpPXIuaW5kZXhUb0xvYyhzKSxvPW5ldyBBcnJheShpLmxlbmd0aCk7Zm9yKGxldCBsPTA7bDxvLmxlbmd0aDtsKyspb1tsXT1pW2xdKm5bbF0rYVtsXTtyLnNldCh0LmdldCguLi5vKSwuLi5pKX1yZXR1cm4gcn12YXIgd0s9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4sYSxyLHMpe3RoaXMuc2VwYXJhdG9yPXcuZW5jb2RlU3RyaW5nKGUpLHRoaXMubkdyYW1XaWR0aHM9dCx0aGlzLmxlZnRQYWQ9dy5lbmNvZGVTdHJpbmcobiksdGhpcy5yaWdodFBhZD13LmVuY29kZVN0cmluZyhhKSx0aGlzLnBhZFdpZHRoPXIsdGhpcy5wcmVzZXJ2ZVNob3J0PXN9Z2V0UGFkV2lkdGgoZSl7cmV0dXJuIE1hdGgubWluKHRoaXMucGFkV2lkdGg8MD9lLTE6dGhpcy5wYWRXaWR0aCxlLTEpfWdldE51bU5HcmFtcyhlLHQpe2xldCBuPXRoaXMuZ2V0UGFkV2lkdGgodCk7cmV0dXJuIE1hdGgubWF4KDAsZSsyKm4tdCsxKX1jcmVhdGVOR3JhbXMoZSx0LG4sYSxyLHMpe2ZvcihsZXQgaT0wO2k8cjsrK2kpe2xldCBvPXRoaXMuZ2V0UGFkV2lkdGgocyksbD1NYXRoLm1heCgwLG8taSksdT1NYXRoLm1heCgwLG8tKHItKGkrMSkpKSxwPXMtKGwrdSksZD10KyhsPjA/MDppLW8pLGM9MDtjKz1sKnRoaXMubGVmdFBhZC5sZW5ndGg7Zm9yKGxldCBiPTA7YjxwOysrYiljKz1lW2QrYl0ubGVuZ3RoO2MrPXUqdGhpcy5yaWdodFBhZC5sZW5ndGg7bGV0IGg9bCt1K3AtMTtjKz1oKnRoaXMuc2VwYXJhdG9yLmxlbmd0aCxuW2EraV09bmV3IFVpbnQ4QXJyYXkoYyk7bGV0IG09blthK2ldLGY9MCxnPWI9PmIuZm9yRWFjaCh5PT5tW2YrK109eSk7Zm9yKGxldCBiPTA7YjxsOysrYilnKHRoaXMubGVmdFBhZCksZyh0aGlzLnNlcGFyYXRvcik7Zm9yKGxldCBiPTA7YjxwLTE7KytiKWcoZVtkK2JdKSxnKHRoaXMuc2VwYXJhdG9yKTtpZihwPjApe2coZVtkK3AtMV0pO2ZvcihsZXQgYj0wO2I8dTsrK2IpZyh0aGlzLnNlcGFyYXRvciksZyh0aGlzLnJpZ2h0UGFkKX1lbHNle2ZvcihsZXQgYj0wO2I8dS0xOysrYilnKHRoaXMucmlnaHRQYWQpLGcodGhpcy5zZXBhcmF0b3IpO2codGhpcy5yaWdodFBhZCl9fX1jb21wdXRlKGUsdCl7bGV0IG49ZS5sZW5ndGgsYT10Lmxlbmd0aDtpZihhPjApe2xldCBvPXRbMF07aWYobyE9PTApdGhyb3cgbmV3IEVycm9yKGBGaXJzdCBzcGxpdCB2YWx1ZSBtdXN0IGJlIDAsIGdvdCAke299YCk7Zm9yKGxldCBsPTE7bDxhOysrbCl7bGV0IHU9dFtsXT49bztpZih1PXUmJnRbbF08PW4sIXUpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNwbGl0IHZhbHVlICR7dFtsXX0sIG11c3QgYmUgaW4gWyR7b30sICR7bn1dYCk7bz10W2xdfWlmKG8hPT1uKXRocm93IG5ldyBFcnJvcihgTGFzdCBzcGxpdCB2YWx1ZSBtdXN0IGJlIGRhdGEgc2l6ZS4gRXhwZWN0ZWQgJHtufSwgZ290ICR7b31gKX1sZXQgcj1hLTEscz13LmdldEFycmF5RnJvbURUeXBlKFwiaW50MzJcIixhKTtpZihuPT09MHx8YT09PTApe2xldCBvPW5ldyBBcnJheShuKTtmb3IobGV0IGw9MDtsPD1yOysrbClzW2xdPTA7cmV0dXJuW28sc119c1swXT0wO2ZvcihsZXQgbz0xO288PXI7KytvKXtsZXQgbD10W29dLXRbby0xXSx1PTA7dGhpcy5uR3JhbVdpZHRocy5mb3JFYWNoKHA9Pnt1Kz10aGlzLmdldE51bU5HcmFtcyhsLHApfSksdGhpcy5wcmVzZXJ2ZVNob3J0JiZsPjAmJnU9PT0wJiYodT0xKSxzW29dPXNbby0xXSt1fWxldCBpPW5ldyBBcnJheShzW3JdKTtmb3IobGV0IG89MDtvPHI7KytvKXtsZXQgbD10W29dLHU9c1tvXTtpZih0aGlzLm5HcmFtV2lkdGhzLmZvckVhY2gocD0+e2xldCBkPXRbbysxXS10W29dLGM9dGhpcy5nZXROdW1OR3JhbXMoZCxwKTt0aGlzLmNyZWF0ZU5HcmFtcyhlLGwsaSx1LGMscCksdSs9Y30pLHRoaXMucHJlc2VydmVTaG9ydCYmdT09PXNbb10pe2xldCBwPXRbbysxXS10W29dO2lmKHA9PT0wKWNvbnRpbnVlO2xldCBkPXArMip0aGlzLnBhZFdpZHRoO3RoaXMuY3JlYXRlTkdyYW1zKGUsbCxpLHUsMSxkKX19cmV0dXJuW2ksc119fTtmdW5jdGlvbiBVMShlLHQsbixhLHIscyxpLG8pe3JldHVybiBuZXcgd0sobixhLHIscyxpLG8pLmNvbXB1dGUoZSx0KX1mdW5jdGlvbiBrSyhlLHQsbixhKXtpZighZS5sZW5ndGgpcmV0dXJuO2lmKHQubGVuZ3RoPT09MCl7Zm9yKGxldCBzPTA7czxlLmxlbmd0aDsrK3MpYS5wdXNoKGUuc3ViYXJyYXkocyxzKzEpKTtyZXR1cm59aWYodC5sZW5ndGg9PT0xKXtsZXQgcz10WzBdLGk9ZS5pbmRleE9mKHMpO2Zvcig7aSE9PS0xOyl7bGV0IG89ZS5zdWJhcnJheSgwLGkpOyghbnx8by5sZW5ndGghPT0wKSYmYS5wdXNoKG8pLGU9ZS5zdWJhcnJheShpKzEpLGk9ZS5pbmRleE9mKHMpfSghbnx8ZS5sZW5ndGghPT0wKSYmYS5wdXNoKGUpO3JldHVybn1sZXQgcj0wO2ZvcihsZXQgcz0wO3M8ZS5sZW5ndGgrMTtzKyspaWYocz09PWUubGVuZ3RofHx0LmluZGV4T2YoZVtzXSkhPT0tMSl7bGV0IGk9ZS5zdWJhcnJheShyLHMpOyghbnx8aS5sZW5ndGghPT0wKSYmYS5wdXNoKGkpLHI9cysxfX1mdW5jdGlvbiBHMShlLHQsbil7bGV0IGE9ZS5sZW5ndGgscj1bXSxzPTAsaT0wLG89bmV3IEFycmF5KGEpO2ZvcihsZXQgYz0wO2M8YTsrK2Mpe2xldCBoPXIubGVuZ3RoO2tLKGVbY10sdCxuLHIpO2xldCBtPXIubGVuZ3RoLWg7b1tjXT1tLHMrPW0saT1NYXRoLm1heChpLG0pfWxldCBsPXcuZ2V0QXJyYXlGcm9tRFR5cGUoXCJpbnQzMlwiLHMqMiksdT1uZXcgQXJyYXkocykscD1bYSxpXSxkPTA7Zm9yKGxldCBjPTA7YzxhOysrYylmb3IobGV0IGg9MDtoPG9bY107KytoKWxbZCoyXT1jLGxbZCoyKzFdPWgsdVtkXT1yW2RdLCsrZDtyZXR1cm5bbCx1LHBdfWZ1bmN0aW9uIEgxKGUsdCl7bGV0IG49dy5nZXRBcnJheUZyb21EVHlwZShcImludDMyXCIsZS5sZW5ndGgpO2ZvcihsZXQgYT0wO2E8ZS5sZW5ndGg7KythKW5bYV09dy5maW5nZXJQcmludDY0KGVbYV0pLm1vZHVsbyh0KS5nZXRMb3dCaXRzVW5zaWduZWQoKTtyZXR1cm4gbn12YXIgZF89TXQoKGUsdCk9PmUtdCksSUs9TzEoKGUsdCxuLGEpPT4oe3JlYWw6ZS1uLGltYWc6dC1hfSkpLGoxPVp0KEJvLGRfLElLKSxTSz17a2VybmVsTmFtZTpCbyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6ajF9O2Z1bmN0aW9uIGhfKGUsdCl7bGV0IG49bmV3IEFycmF5KGUucmFuayk7Zm9yKGxldCByPTA7cjxuLmxlbmd0aDtyKyspbltyXT1lLnNoYXBlW3JdKnRbcl07bGV0IGE9T2UobixlLmR0eXBlKTtmb3IobGV0IHI9MDtyPGEudmFsdWVzLmxlbmd0aDsrK3Ipe2xldCBzPWEuaW5kZXhUb0xvYyhyKSxpPW5ldyBBcnJheShlLnJhbmspO2ZvcihsZXQgbD0wO2w8aS5sZW5ndGg7bCsrKWlbbF09c1tsXSVlLnNoYXBlW2xdO2xldCBvPWUubG9jVG9JbmRleChpKTthLnZhbHVlc1tyXT1lLnZhbHVlc1tvXX1yZXR1cm4gYX12YXIgbmM9KGUsdCk9PntsZXQgbj10LnZhbHVlLWUudmFsdWU7cmV0dXJuIG49PT0wP2UuaW5kZXgtdC5pbmRleDpufTtmdW5jdGlvbiBtXyhlLHQsbj0wLGE9ZS5sZW5ndGgtMSl7Zm9yKDthPm47KXtpZihhLW4+NjAwKXtsZXQgbz1hLW4rMSxsPXQtbisxLHU9TWF0aC5sb2cobykscD0uNSpNYXRoLmV4cCgyKnUvMyksZD0uNSpNYXRoLnNxcnQodSpwKihvLXApL28pKk1hdGguc2lnbihsLW8vMiksYz1NYXRoLm1heChuLE1hdGguZmxvb3IodC1sKnAvbytkKSksaD1NYXRoLm1pbihhLE1hdGguZmxvb3IodCsoby1sKSpwL28rZCkpO21fKGUsdCxjLGgpfWxldCByPWVbdF0scz1uLGk9YTtmb3Iody5zd2FwKGUsbix0KSxuYyhlW2FdLHIpPjAmJncuc3dhcChlLG4sYSk7czxpOyl7Zm9yKHcuc3dhcChlLHMsaSkscysrLGktLTtuYyhlW3NdLHIpPDA7KXM9cysxO2Zvcig7bmMoZVtpXSxyKT4wOylpPWktMX1uYyhlW25dLHIpPT09MD93LnN3YXAoZSxuLGkpOihpPWkrMSx3LnN3YXAoZSxpLGEpKSxpPD10JiYobj1pKzEpLHQ8PWkmJihhPWktMSl9fWZ1bmN0aW9uIGZfKGUsdCxuLGEscil7bGV0IHM9dFt0Lmxlbmd0aC0xXSxbaSxvXT1bZS5sZW5ndGgvcyxzXSxsPXcuZ2V0VHlwZWRBcnJheUZyb21EVHlwZShuLGkqYSksdT13LmdldFR5cGVkQXJyYXlGcm9tRFR5cGUoXCJpbnQzMlwiLGkqYSk7Zm9yKGxldCBkPTA7ZDxpO2QrKyl7bGV0IGM9ZCpvLGg9ZS5zdWJhcnJheShjLGMrbyksbT1uZXcgQXJyYXkoaC5sZW5ndGgpO2guZm9yRWFjaCgoeSx4KT0+bVt4XT17dmFsdWU6eSxpbmRleDp4fSksYTxtLmxlbmd0aCYmKG1fKG0sYSksbT1tLnNsaWNlKDAsYSkpLHImJm0uc29ydChuYyk7bGV0IGY9ZCphLGc9bC5zdWJhcnJheShmLGYrYSksYj11LnN1YmFycmF5KGYsZithKTtmb3IobGV0IHk9MDt5PGE7eSsrKWdbeV09bVt5XS52YWx1ZSxiW3ldPW1beV0uaW5kZXh9bGV0IHA9dC5zbGljZSgpO3JldHVybiBwW3AubGVuZ3RoLTFdPWEsW09lKHAsbixsKSxPZShwLFwiaW50MzJcIix1KV19ZnVuY3Rpb24gcTEoZSx0LG4sYSl7bGV0IHI9dy5wYXJzZUF4aXNQYXJhbSh0LG4pWzBdLHM9WzEsblswXSwxXTtmb3IobGV0IG09MDttPHI7bSsrKXNbMF0qPW5bbV07c1sxXT1uW3JdO2ZvcihsZXQgbT1yKzE7bTxuLmxlbmd0aDttKyspc1syXSo9blttXTtsZXQgaT1uZXcgTWFwLG89bmV3IEludDMyQXJyYXkobltyXSksbD1uZXcgV3QocyxhLGUpLHU9W10scD1zWzBdPT09MSYmc1syXT09PTE7Zm9yKGxldCBtPTA7bTxuW3JdO20rKyl7bGV0IGY7aWYocClmPWVbbV0udG9TdHJpbmcoKTtlbHNle2xldCBiPVtdO2ZvcihsZXQgeT0wO3k8c1swXTt5KyspZm9yKGxldCB4PTA7eDxzWzJdO3grKyliLnB1c2gobC5nZXQoeSxtLHgpKTtmPWIuam9pbihcIixcIil9bGV0IGc9aS5nZXQoZik7aWYoZyE9bnVsbClvW21dPWc7ZWxzZXtsZXQgYj1pLnNpemU7aS5zZXQoZixiKSxvW21dPWIsdS5wdXNoKG0pfX1sZXQgZD1zLnNsaWNlKCk7ZFsxXT1pLnNpemU7bGV0IGM9bmV3IFd0KGQsYSk7dS5mb3JFYWNoKChtLGYpPT57Zm9yKGxldCBnPTA7ZzxzWzBdO2crKylmb3IobGV0IGI9MDtiPHNbMl07YisrKWMuc2V0KGwuZ2V0KGcsbSxiKSxnLGYsYil9KTtsZXQgaD1uLnNsaWNlKCk7cmV0dXJuIGhbcl09ZFsxXSx7b3V0cHV0VmFsdWVzOmMudmFsdWVzLG91dHB1dFNoYXBlOmgsaW5kaWNlczpvfX12YXIgTks9XCI0LjIyLjBcIjtPbShcImNwdVwiLCgpPT5uZXcgUjEsMSk7dmFyIGdfPWx0KGppLGU9PmU+PTA/ZTpNYXRoLmV4cChlKS0xKSxUSz17a2VybmVsTmFtZTpqaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Z199O2Z1bmN0aW9uIGJfKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHthbHBoYTpzfT1hO2dlKFtyXSxcImxlYWt5UmVsdVwiKTtsZXQgaT13LnNpemVGcm9tU2hhcGUoci5zaGFwZSksbz1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsbD13LmdldFR5cGVkQXJyYXlGcm9tRFR5cGUoXCJmbG9hdDMyXCIsaSk7Zm9yKGxldCB1PTA7dTxvLmxlbmd0aDt1KyspbFt1XT1vW3VdPDA/cypvW3VdOm9bdV07cmV0dXJuIG4ubWFrZVRlbnNvckluZm8oci5zaGFwZSxcImZsb2F0MzJcIixsKX12YXIgQ0s9e2tlcm5lbE5hbWU6cm8sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmJffSxFSz1NdCgoZSx0KT0+ZTwwP3QqZTplKTtmdW5jdGlvbiB5XyhlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHt4OmEsYWxwaGE6cn09dDtnZShbYSxyXSxcInByZWx1XCIpO2xldCBzPW4uZGF0YS5nZXQoYS5kYXRhSWQpLnZhbHVlcyxpPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxbbyxsXT1FSyhhLnNoYXBlLHIuc2hhcGUscyxpLFwiZmxvYXQzMlwiKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhsLFwiZmxvYXQzMlwiLG8pfXZhciBfSz17a2VybmVsTmFtZTp3byxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6eV99LHhfPWx0KFNvLGU9Pk1hdGgubWF4KDAsZSkpLEFLPXtrZXJuZWxOYW1lOlNvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzp4X30sdl89bHQoQ28sZT0+TWF0aC5taW4oTWF0aC5tYXgoMCxlKSw2KSksRks9e2tlcm5lbE5hbWU6Q28sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOnZffTtmdW5jdGlvbiBwbShlLHQsbixhLHIpe2lmKG49PT1cImxpbmVhclwiKXJldHVybiBjcih7aW5wdXRzOnt4OnR9LGJhY2tlbmQ6ZX0pO2lmKG49PT1cInJlbHVcIilyZXR1cm4geF8oe2lucHV0czp7eDp0fSxiYWNrZW5kOmV9KTtpZihuPT09XCJlbHVcIilyZXR1cm4gZ18oe2lucHV0czp7eDp0fSxiYWNrZW5kOmV9KTtpZihuPT09XCJyZWx1NlwiKXJldHVybiB2Xyh7aW5wdXRzOnt4OnR9LGJhY2tlbmQ6ZX0pO2lmKG49PT1cInByZWx1XCIpcmV0dXJuIHlfKHtpbnB1dHM6e3g6dCxhbHBoYTphfSxiYWNrZW5kOmV9KTtpZihuPT09XCJsZWFreXJlbHVcIilyZXR1cm4gYl8oe2lucHV0czp7eDp0fSxiYWNrZW5kOmUsYXR0cnM6e2FscGhhOnJ9fSk7aWYobj09PVwic2lnbW9pZFwiKXJldHVybiBpXyh7aW5wdXRzOnt4OnR9LGJhY2tlbmQ6ZX0pO3Rocm93IG5ldyBFcnJvcihgQWN0aXZhdGlvbiAke259IGhhcyBub3QgYmVlbiBpbXBsZW1lbnRlZCBmb3IgdGhlIENQVSBiYWNrZW5kLmApfWZ1bmN0aW9uIHh0KGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtzaGFwZTpzfT1hLGk9dy5zaXplRnJvbVNoYXBlKHIuc2hhcGUpLG89dy5pbmZlckZyb21JbXBsaWNpdFNoYXBlKHMsaSksbD13LnNpemVGcm9tU2hhcGUobyk7dy5hc3NlcnQoaT09PWwsKCk9PmBUaGUgbmV3IHNoYXBlICgke299KSBoYXMgJHtsfSBlbGVtZW50cyBhbmQgdGhlIG9sZCBzaGFwZSAoJHtyLnNoYXBlfSkgaGFzICR7aX0gZWxlbWVudHMuIFRoZSBuZXcgc2hhcGUgYW5kIG9sZCBzaGFwZSBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLmApLG4uaW5jUmVmKHIuZGF0YUlkKTtsZXQgdT1uLmRhdGEuZ2V0KHIuZGF0YUlkKTtpZih1LmNvbXBsZXhUZW5zb3JJbmZvcyE9bnVsbCl7bGV0IHA9dS5jb21wbGV4VGVuc29ySW5mb3MucmVhbCxkPXUuY29tcGxleFRlbnNvckluZm9zLmltYWc7cC5zaGFwZT1vLGQuc2hhcGU9b31yZXR1cm57ZGF0YUlkOnIuZGF0YUlkLHNoYXBlOm8sZHR5cGU6ci5kdHlwZX19dmFyICRLPXtrZXJuZWxOYW1lOlJ1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzp4dH07ZnVuY3Rpb24gd18oZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHthOnIsYjpzfT10LHt0cmFuc3Bvc2VBOmksdHJhbnNwb3NlQjpvfT1hO2dlKFtyLHNdLFwibWF0TXVsXCIpO2xldCBsPXIuc2hhcGUubGVuZ3RoLHU9cy5zaGFwZS5sZW5ndGgscD1pP3Iuc2hhcGVbbC0yXTpyLnNoYXBlW2wtMV0sZD1vP3Muc2hhcGVbdS0xXTpzLnNoYXBlW3UtMl0sYz1pP3Iuc2hhcGVbbC0xXTpyLnNoYXBlW2wtMl0saD1vP3Muc2hhcGVbdS0yXTpzLnNoYXBlW3UtMV0sbT1yLnNoYXBlLnNsaWNlKDAsLTIpLGY9cy5zaGFwZS5zbGljZSgwLC0yKSxnPXcuc2l6ZUZyb21TaGFwZShtKSxiPXcuc2l6ZUZyb21TaGFwZShmKSx5PUp1LmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHIuc2hhcGUuc2xpY2UoMCwtMikscy5zaGFwZS5zbGljZSgwLC0yKSkuY29uY2F0KFtjLGhdKTt3LmFzc2VydChwPT09ZCwoKT0+YEVycm9yIGluIG1hdE11bDogaW5uZXIgc2hhcGVzICgke3B9KSBhbmQgKCR7ZH0pIG9mIFRlbnNvcnMgd2l0aCBzaGFwZXMgJHtyLnNoYXBlfSBhbmQgJHtzLnNoYXBlfSBhbmQgdHJhbnNwb3NlQT0ke2l9IGFuZCB0cmFuc3Bvc2VCPSR7b30gbXVzdCBtYXRjaC5gKTtsZXQgeD1pP1tnLHAsY106W2csYyxwXSx2PW8/W2IsaCxkXTpbYixkLGhdLEk9eHQoe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOnh9fSksTj14dCh7aW5wdXRzOnt4OnN9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6dn19KSxDPWk/SS5zaGFwZVsxXTpJLnNoYXBlWzJdLF89aT9JLnNoYXBlWzJdOkkuc2hhcGVbMV0sRj1vP04uc2hhcGVbMV06Ti5zaGFwZVsyXSxEPU1hdGgubWF4KGcsYiksJD1uLmRhdGEuZ2V0KEkuZGF0YUlkKS52YWx1ZXMsUz1uLmRhdGEuZ2V0KE4uZGF0YUlkKS52YWx1ZXMsTT13LmNvbXB1dGVTdHJpZGVzKEkuc2hhcGUpLEI9dy5jb21wdXRlU3RyaWRlcyhOLnNoYXBlKSxbVSxILHFdPWk/W01bMF0sMSxNWzFdXTpbTVswXSxNWzFdLDFdLFtLLFosSl09bz9bMSxCWzFdLEJbMF1dOltCWzFdLDEsQlswXV0sZWU9XypGLGFlPU9lKFtELF8sRl0sSS5kdHlwZSksdGU9YWUudmFsdWVzLHNlPW4uYmxvY2tTaXplO2ZvcihsZXQgaWU9MDtpZTxEO2llKyspe2xldCB2ZT1pZSVnLHVlPWllJWI7Zm9yKGxldCB5ZT0wO3llPF87eWUrPXNlKXtsZXQga2U9TWF0aC5taW4oeWUrc2UsXyk7Zm9yKGxldCBTZT0wO1NlPEY7U2UrPXNlKXtsZXQgTGU9TWF0aC5taW4oU2Urc2UsRik7Zm9yKGxldCBVZT0wO1VlPEM7VWUrPXNlKXtsZXQgbXQ9TWF0aC5taW4oVWUrc2UsQyk7Zm9yKGxldCBzdD15ZTtzdDxrZTtzdCsrKWZvcihsZXQgdHQ9U2U7dHQ8TGU7dHQrKyl7bGV0IG50PTA7Zm9yKGxldCBSZT1VZTtSZTxtdDtSZSsrKXtsZXQgZ3Q9JFt2ZSpVK3N0KkgrUmUqcV0sR249U1tSZSpLK3R0KlordWUqSl07bnQrPWd0KkdufXRlW2llKmVlKyhzdCpGK3R0KV0rPW50fX19fX1yZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhJKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKE4pLG4ubWFrZVRlbnNvckluZm8oeSxhZS5kdHlwZSxhZS52YWx1ZXMpfXZhciBESz17a2VybmVsTmFtZTpSaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6d199O2Z1bmN0aW9uIFJLKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7YTpyLGI6cyxiaWFzOmkscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czpvfT10LHt0cmFuc3Bvc2VBOmwsdHJhbnNwb3NlQjp1LGFjdGl2YXRpb246cCxsZWFreXJlbHVBbHBoYTpkfT1hLGMsaCxtLGY9W107Yz13Xyh7aW5wdXRzOnthOnIsYjpzfSxhdHRyczp7dHJhbnNwb3NlQTpsLHRyYW5zcG9zZUI6dX0sYmFja2VuZDpufSksaSYmKGg9amwoe2lucHV0czp7YTpjLGI6aX0sYmFja2VuZDpufSksZi5wdXNoKGMpLGM9aCkscCYmKG09cG0obixjLHAsbyxkKSxmLnB1c2goYyksYz1tKTtmb3IobGV0IGcgb2YgZiluLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGcpO3JldHVybiBjfXZhciBNSz17a2VybmVsTmFtZTppaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Ukt9LE9LPWx0KE5pLGU9Pk1hdGguYWNvcyhlKSksUEs9e2tlcm5lbE5hbWU6TmksYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOk9LfSxMSz1sdChUaSxlPT5NYXRoLmFjb3NoKGUpKSx6Sz17a2VybmVsTmFtZTpUaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6TEt9O2Z1bmN0aW9uIFdLKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUsYT10O2dlKHQsXCJhZGROXCIpO2xldCByPWEubWFwKG89Pm4uZGF0YS5nZXQoby5kYXRhSWQpLnZhbHVlcykscz1PZShhWzBdLnNoYXBlLGFbMF0uZHR5cGUpLGk9cy52YWx1ZXM7Zm9yKGxldCBvPTA7bzxhLmxlbmd0aDtvKyspe2xldCBsPXJbb107Zm9yKGxldCB1PTA7dTxpLmxlbmd0aDt1KyspaVt1XSs9bFt1XX1yZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhzLnNoYXBlLHMuZHR5cGUscy52YWx1ZXMpfXZhciBCSz17a2VybmVsTmFtZTpDaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6V0t9O2Z1bmN0aW9uIFZLKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtheGlzOnMsa2VlcERpbXM6aX09YTtnZShyLFwiYWxsXCIpO2xldCBvPXcucGFyc2VBeGlzUGFyYW0ocyxyLnNoYXBlKSxsPW8sdT1ULmdldEF4ZXNQZXJtdXRhdGlvbihsLHIuc2hhcGUubGVuZ3RoKSxwPXI7dSE9bnVsbCYmKHA9Vm4oe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3Blcm06dX19KSxsPVQuZ2V0SW5uZXJNb3N0QXhlcyhsLmxlbmd0aCxyLnNoYXBlLmxlbmd0aCkpLFQuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJhbGxcIixsLHAuc2hhcGUubGVuZ3RoKTtsZXRbZCxjXT1ULmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMocC5zaGFwZSxsKSxoPXcuc2l6ZUZyb21TaGFwZShjKSxtPXcubWFrZVplcm9zVHlwZWRBcnJheSh3LnNpemVGcm9tU2hhcGUoZCkscC5kdHlwZSksZj1uLmRhdGEuZ2V0KHAuZGF0YUlkKS52YWx1ZXM7Zm9yKGxldCBiPTA7YjxtLmxlbmd0aDsrK2Ipe2xldCB5PWIqaCx4PWZbeV07Zm9yKGxldCB2PTA7djxoOysrdil7bGV0IEk9Zlt5K3ZdO3g9eCYmSX1tW2JdPXh9dSE9bnVsbCYmbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhwKTtsZXQgZz1uLm1ha2VUZW5zb3JJbmZvKGQscC5kdHlwZSxtKTtpZihpKXtsZXQgYj1ULmV4cGFuZFNoYXBlVG9LZWVwRGltKGQsbykseT14dCh7aW5wdXRzOnt4Omd9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6Yn19KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhnKSx5fXJldHVybiBnfXZhciBVSz17a2VybmVsTmFtZTpabCxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Vkt9O2Z1bmN0aW9uIEdLKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtheGlzOnMsa2VlcERpbXM6aX09YTtnZShyLFwiYW55XCIpO2xldCBvPXcucGFyc2VBeGlzUGFyYW0ocyxyLnNoYXBlKSxsPW8sdT1ULmdldEF4ZXNQZXJtdXRhdGlvbihsLHIuc2hhcGUubGVuZ3RoKSxwPXI7dSE9bnVsbCYmKHA9Vm4oe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3Blcm06dX19KSxsPVQuZ2V0SW5uZXJNb3N0QXhlcyhsLmxlbmd0aCxyLnNoYXBlLmxlbmd0aCkpLFQuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJhbnlcIixsLHAuc2hhcGUubGVuZ3RoKTtsZXRbZCxjXT1ULmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMocC5zaGFwZSxsKSxoPXcuc2l6ZUZyb21TaGFwZShjKSxtPXcubWFrZVplcm9zVHlwZWRBcnJheSh3LnNpemVGcm9tU2hhcGUoZCkscC5kdHlwZSksZj1uLmRhdGEuZ2V0KHAuZGF0YUlkKS52YWx1ZXM7Zm9yKGxldCBiPTA7YjxtLmxlbmd0aDsrK2Ipe2xldCB5PWIqaCx4PWZbeV07Zm9yKGxldCB2PTA7djxoOysrdil7bGV0IEk9Zlt5K3ZdO3g9eHx8SX1tW2JdPXh9dSE9bnVsbCYmbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhwKTtsZXQgZz1uLm1ha2VUZW5zb3JJbmZvKGQscC5kdHlwZSxtKTtpZihpKXtsZXQgYj1ULmV4cGFuZFNoYXBlVG9LZWVwRGltKGQsbykseT14dCh7aW5wdXRzOnt4Omd9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6Yn19KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhnKSx5fXJldHVybiBnfXZhciBISz17a2VybmVsTmFtZTpKbCxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6R0t9O2Z1bmN0aW9uIGpLKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtheGlzOnN9PWE7Z2UocixcImFyZ01heFwiKTtsZXQgaT13LnBhcnNlQXhpc1BhcmFtKHMsci5zaGFwZSksbz1ULmdldEF4ZXNQZXJtdXRhdGlvbihpLHIuc2hhcGUubGVuZ3RoKSxsPXIsdT1bXTtvIT1udWxsJiYobD1Wbih7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bixhdHRyczp7cGVybTpvfX0pLHUucHVzaChsKSxpPVQuZ2V0SW5uZXJNb3N0QXhlcyhpLmxlbmd0aCxsLnNoYXBlLmxlbmd0aCkpLGk9W2lbMF1dLFQuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJhcmdNYXhcIixpLGwuc2hhcGUubGVuZ3RoKTtsZXRbcCxkXT1ULmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMobC5zaGFwZSxpKSxjPXcuc2l6ZUZyb21TaGFwZShwKSxoPXcubWFrZVplcm9zVHlwZWRBcnJheShjLFwiaW50MzJcIiksbT13LnNpemVGcm9tU2hhcGUoZCksZj1uLmRhdGEuZ2V0KGwuZGF0YUlkKS52YWx1ZXM7Zm9yKGxldCBnPTA7ZzxoLmxlbmd0aDsrK2cpe2xldCBiPWcqbSx5PWZbYl0seD0wO2ZvcihsZXQgdj0wO3Y8bTsrK3Ype2xldCBJPWZbYit2XTtJPnkmJih5PUkseD12KX1oW2ddPXh9cmV0dXJuIHUuZm9yRWFjaChnPT5uLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGcpKSxuLm1ha2VUZW5zb3JJbmZvKHAsXCJpbnQzMlwiLGgpfXZhciBxSz17a2VybmVsTmFtZTpRbCxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6akt9O2Z1bmN0aW9uIEtLKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtheGlzOnN9PWE7Z2UocixcImFyZ01pblwiKTtsZXQgaT13LnBhcnNlQXhpc1BhcmFtKHMsci5zaGFwZSksbz1ULmdldEF4ZXNQZXJtdXRhdGlvbihpLHIuc2hhcGUubGVuZ3RoKSxsPXIsdT1bXTtvIT1udWxsJiYobD1Wbih7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bixhdHRyczp7cGVybTpvfX0pLHUucHVzaChsKSxpPVQuZ2V0SW5uZXJNb3N0QXhlcyhpLmxlbmd0aCxsLnNoYXBlLmxlbmd0aCkpLGk9W2lbMF1dLFQuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJhcmdNaW5cIixpLGwuc2hhcGUubGVuZ3RoKTtsZXRbcCxkXT1ULmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMobC5zaGFwZSxpKSxjPXcuc2l6ZUZyb21TaGFwZShwKSxoPXcubWFrZVplcm9zVHlwZWRBcnJheShjLFwiaW50MzJcIiksbT13LnNpemVGcm9tU2hhcGUoZCksZj1uLmRhdGEuZ2V0KGwuZGF0YUlkKS52YWx1ZXM7Zm9yKGxldCBnPTA7ZzxoLmxlbmd0aDsrK2cpe2xldCBiPWcqbSx5PWZbYl0seD0wO2ZvcihsZXQgdj0wO3Y8bTsrK3Ype2xldCBJPWZbYit2XTtJPHkmJih5PUkseD12KX1oW2ddPXh9cmV0dXJuIHUuZm9yRWFjaChnPT5uLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGcpKSxuLm1ha2VUZW5zb3JJbmZvKHAsXCJpbnQzMlwiLGgpfXZhciBYSz17a2VybmVsTmFtZTpldSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6S0t9LFlLPWx0KEVpLGU9Pk1hdGguYXNpbihlKSksWks9e2tlcm5lbE5hbWU6RWksYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOllLfSxKSz1sdChfaSxlPT5NYXRoLmFzaW5oKGUpKSxRSz17a2VybmVsTmFtZTpfaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Skt9LGVYPWx0KEFpLGU9Pk1hdGguYXRhbihlKSksdFg9e2tlcm5lbE5hbWU6QWksYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmVYfSxuWD1NdCgoZSx0KT0+TWF0aC5hdGFuMihlLHQpKSxhWD1adCgkaSxuWCksclg9e2tlcm5lbE5hbWU6JGksYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmFYfSxzWD1sdChGaSxlPT5NYXRoLmF0YW5oKGUpKSxpWD17a2VybmVsTmFtZTpGaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6c1h9O2Z1bmN0aW9uIEsxKGUsdCxuLGEscixzKXtsZXQgaT1yLnN0cmlkZUhlaWdodCxvPXIuc3RyaWRlV2lkdGgsbD1yLmRpbGF0aW9uSGVpZ2h0LHU9ci5kaWxhdGlvbldpZHRoLHA9ci5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsZD1yLmVmZmVjdGl2ZUZpbHRlcldpZHRoLGM9ci5wYWRJbmZvLnRvcCxoPXIucGFkSW5mby5sZWZ0LG09cz09PVwibWF4XCI/TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZOk51bWJlci5QT1NJVElWRV9JTkZJTklUWSxmPU9lKHIub3V0U2hhcGUsbiksZz1mLnZhbHVlcyxiPXIub3V0U2hhcGVbMV0qci5vdXRTaGFwZVsyXSpyLm91dFNoYXBlWzNdLHk9ci5vdXRTaGFwZVsyXSpyLm91dFNoYXBlWzNdLHg9ci5vdXRTaGFwZVszXTtmb3IobGV0IHY9MDt2PHIuYmF0Y2hTaXplOysrdil7bGV0IEk9dipiLE49diphWzBdO2ZvcihsZXQgQz0wO0M8ci5pbkNoYW5uZWxzOysrQylmb3IobGV0IF89MDtfPHIub3V0SGVpZ2h0OysrXyl7bGV0IEY9XyppLWMsRD1NYXRoLm1heCgwLEYpLCQ9TWF0aC5taW4oci5pbkhlaWdodCxwK0YpLFM9SStfKnk7Zm9yKGxldCBNPTA7TTxyLm91dFdpZHRoOysrTSl7bGV0IEI9TSpvLWgsVT1NYXRoLm1heCgwLEIpLEg9TWF0aC5taW4oci5pbldpZHRoLGQrQikscT1tLEs9MCxaPTA7Zm9yKGxldCBlZT1EO2VlPCQ7ZWUrPWwpe2xldCBhZT1OK2VlKmFbMV07Zm9yKGxldCB0ZT1VO3RlPEg7dGUrPXUpe2xldCBzZT1hZSt0ZSphWzJdLGllPWVbc2UrQ107cz09PVwibWF4XCImJmllPnE/cT1pZTpzPT09XCJhdmdcIiYmKEsrPWllLForKyl9aWYoaXNOYU4ocSkpYnJlYWt9bGV0IEo9UytNKngrQztnW0pdPXM9PT1cImF2Z1wiP0svWjpxfX19cmV0dXJuIGZ9ZnVuY3Rpb24ga18oZSx0LG4sYSxyPSExLHM9ITEpe2xldCBpPU9lKGEub3V0U2hhcGUsXCJpbnQzMlwiKSxvPWEuc3RyaWRlSGVpZ2h0LGw9YS5zdHJpZGVXaWR0aCx1PWEuZGlsYXRpb25IZWlnaHQscD1hLmRpbGF0aW9uV2lkdGgsZD1hLmVmZmVjdGl2ZUZpbHRlckhlaWdodCxjPWEuZWZmZWN0aXZlRmlsdGVyV2lkdGgsaD1hLnBhZEluZm8udG9wLG09YS5wYWRJbmZvLmxlZnQsZj1PZSh0LG4sZSk7Zm9yKGxldCBnPTA7ZzxhLmJhdGNoU2l6ZTsrK2cpZm9yKGxldCBiPTA7YjxhLmluQ2hhbm5lbHM7KytiKWZvcihsZXQgeT0wO3k8YS5vdXRIZWlnaHQ7Kyt5KXtsZXQgeD15Km8taCx2PXg7Zm9yKDt2PDA7KXYrPXU7bGV0IEk9TWF0aC5taW4oYS5pbkhlaWdodCxkK3gpO2ZvcihsZXQgTj0wO048YS5vdXRXaWR0aDsrK04pe2xldCBDPU4qbC1tLF89Qztmb3IoO188MDspXys9cDtsZXQgRj1NYXRoLm1pbihhLmluV2lkdGgsYytDKSxEPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSwkPS0xO2ZvcihsZXQgUz12O1M8STtTKz11KXtsZXQgTT1TLXg7Zm9yKGxldCBCPV87QjxGO0IrPXApe2xldCBVPUItQyxIPWYuZ2V0KGcsUyxCLGIpO0g+RCYmKEQ9SCxyPyQ9cz8oKGcqYS5pbkhlaWdodCtTKSphLmluV2lkdGgrQikqYS5pbkNoYW5uZWxzK2I6KFMqYS5pbldpZHRoK0IpKmEuaW5DaGFubmVscytiOiQ9TSpjK1UpfX1pLnNldCgkLGcseSxOLGIpfX1yZXR1cm4gaX1mdW5jdGlvbiBJXyhlLHQsbixhLHIscyl7bGV0IGk9ci5zdHJpZGVEZXB0aCxvPXIuc3RyaWRlSGVpZ2h0LGw9ci5zdHJpZGVXaWR0aCx1PXIuZGlsYXRpb25EZXB0aCxwPXIuZGlsYXRpb25IZWlnaHQsZD1yLmRpbGF0aW9uV2lkdGgsYz1yLmVmZmVjdGl2ZUZpbHRlckRlcHRoLGg9ci5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsbT1yLmVmZmVjdGl2ZUZpbHRlcldpZHRoLGY9ci5wYWRJbmZvLmZyb250LGc9ci5wYWRJbmZvLnRvcCxiPXIucGFkSW5mby5sZWZ0LHk9cz09PVwibWF4XCI/TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZOk51bWJlci5QT1NJVElWRV9JTkZJTklUWSx4PU9lKHIub3V0U2hhcGUsbiksdj14LnZhbHVlcyxJPXIub3V0U2hhcGVbMV0qci5vdXRTaGFwZVsyXSpyLm91dFNoYXBlWzNdKnIub3V0U2hhcGVbNF0sTj1yLm91dFNoYXBlWzJdKnIub3V0U2hhcGVbM10qci5vdXRTaGFwZVs0XSxDPXIub3V0U2hhcGVbM10qci5vdXRTaGFwZVs0XSxfPXIub3V0U2hhcGVbNF07Zm9yKGxldCBGPTA7RjxyLmJhdGNoU2l6ZTsrK0Ype2xldCBEPUYqSSwkPUYqYVswXTtmb3IobGV0IFM9MDtTPHIuaW5DaGFubmVsczsrK1MpZm9yKGxldCBNPTA7TTxyLm91dERlcHRoOysrTSl7bGV0IEI9TSppLWYsVT1CO2Zvcig7VTwwOylVKz11O2xldCBIPU1hdGgubWluKHIuaW5EZXB0aCxjK0IpLHE9RCtNKk47Zm9yKGxldCBLPTA7SzxyLm91dEhlaWdodDsrK0spe2xldCBaPUsqby1nLEo9Wjtmb3IoO0o8MDspSis9cDtsZXQgZWU9TWF0aC5taW4oci5pbkhlaWdodCxoK1opLGFlPXErSypDO2ZvcihsZXQgdGU9MDt0ZTxyLm91dFdpZHRoOysrdGUpe2xldCBzZT10ZSpsLWIsaWU9c2U7Zm9yKDtpZTwwOylpZSs9ZDtsZXQgdmU9TWF0aC5taW4oci5pbldpZHRoLG0rc2UpLHVlPWFlK3RlKl8seWU9eSxrZT0wLFNlPTA7Zm9yKGxldCBVZT1VO1VlPEg7VWUrPXUpe2xldCBtdD0kK1VlKmFbMV07Zm9yKGxldCBzdD1KO3N0PGVlO3N0Kz1wKXtsZXQgdHQ9bXQrc3QqYVsyXTtmb3IobGV0IG50PWllO250PHZlO250Kz1kKXtsZXQgUmU9dHQrbnQqYVszXSxndD1lW1JlK1NdO2lmKHM9PT1cIm1heFwiJiZndD55ZT95ZT1ndDpzPT09XCJhdmdcIiYmKGtlKz1ndCxTZSsrKSxpc05hTih5ZSkpYnJlYWt9aWYoaXNOYU4oeWUpKWJyZWFrfWlmKGlzTmFOKHllKSlicmVha31sZXQgTGU9dWUrUzt2W0xlXT1zPT09XCJhdmdcIj9rZS9NYXRoLm1heChTZSwxKTp5ZX19fX1yZXR1cm4geH1mdW5jdGlvbiBvWChlLHQpe2xldCBuPU9lKHQub3V0U2hhcGUsXCJpbnQzMlwiKSxhPXQuc3RyaWRlRGVwdGgscj10LnN0cmlkZUhlaWdodCxzPXQuc3RyaWRlV2lkdGgsaT10LmRpbGF0aW9uRGVwdGgsbz10LmRpbGF0aW9uSGVpZ2h0LGw9dC5kaWxhdGlvbldpZHRoLHU9dC5lZmZlY3RpdmVGaWx0ZXJEZXB0aCxwPXQuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LGQ9dC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxjPXQucGFkSW5mby5mcm9udCxoPXQucGFkSW5mby50b3AsbT10LnBhZEluZm8ubGVmdDtmb3IobGV0IGY9MDtmPHQuYmF0Y2hTaXplOysrZilmb3IobGV0IGc9MDtnPHQuaW5DaGFubmVsczsrK2cpZm9yKGxldCBiPTA7Yjx0Lm91dERlcHRoOysrYil7bGV0IHk9YiphLWMseD15O2Zvcig7eDwwOyl4Kz1pO2xldCB2PU1hdGgubWluKHQuaW5EZXB0aCx1K3kpO2ZvcihsZXQgST0wO0k8dC5vdXRIZWlnaHQ7KytJKXtsZXQgTj1JKnItaCxDPU47Zm9yKDtDPDA7KUMrPW87bGV0IF89TWF0aC5taW4odC5pbkhlaWdodCxwK04pO2ZvcihsZXQgRj0wO0Y8dC5vdXRXaWR0aDsrK0Ype2xldCBEPUYqcy1tLCQ9RDtmb3IoOyQ8MDspJCs9bDtsZXQgUz1NYXRoLm1pbih0LmluV2lkdGgsZCtEKSxNPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSxCPS0xO2ZvcihsZXQgVT14O1U8djtVKz1pKXtsZXQgSD1VLXk7Zm9yKGxldCBxPUM7cTxfO3ErPW8pe2xldCBLPXEtTjtmb3IobGV0IFo9JDtaPFM7Wis9bCl7bGV0IEo9Wi1ELGVlPWUuZ2V0KGYsVSxxLFosZyk7ZWU+PU0mJihNPWVlLEI9SCpwKmQrSypwK0opfX19bi5zZXQoQixmLGIsSSxGLGcpfX19cmV0dXJuIG59ZnVuY3Rpb24gbFgoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQ7Z2UocixcImF2Z1Bvb2xcIik7bGV0e2ZpbHRlclNpemU6cyxzdHJpZGVzOmkscGFkOm8sZGltUm91bmRpbmdNb2RlOmx9PWEsdT0xO3cuYXNzZXJ0KFQuZWl0aGVyU3RyaWRlc09yRGlsYXRpb25zQXJlT25lKGksdSksKCk9PmBFcnJvciBpbiBhdmdQb29sOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyAke2l9IGFuZCBkaWxhdGlvbnMgJyR7dX0nYCk7bGV0IHA9VC5jb21wdXRlUG9vbDJESW5mbyhyLnNoYXBlLHMsaSx1LG8sbCksZDtpZihwLmZpbHRlcldpZHRoPT09MSYmcC5maWx0ZXJIZWlnaHQ9PT0xJiZ3LmFycmF5c0VxdWFsKHAuaW5TaGFwZSxwLm91dFNoYXBlKSlkPWNyKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpufSk7ZWxzZXtsZXQgYz1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsaD13LmNvbXB1dGVTdHJpZGVzKHIuc2hhcGUpLG09SzEoYyxyLnNoYXBlLHIuZHR5cGUsaCxwLFwiYXZnXCIpO2Q9bi5tYWtlVGVuc29ySW5mbyhwLm91dFNoYXBlLHIuZHR5cGUsbS52YWx1ZXMpfXJldHVybiBkfXZhciB1WD17a2VybmVsTmFtZTpEaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6bFh9O2Z1bmN0aW9uIHBYKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtmaWx0ZXJTaXplOnMsc3RyaWRlczppLHBhZDpvLGRpbVJvdW5kaW5nTW9kZTpsLGRhdGFGb3JtYXQ6dX09YTtnZShyLFwiYXZnUG9vbDNkXCIpO2xldCBwPVQuY29tcHV0ZVBvb2wzREluZm8oci5zaGFwZSxzLGksMSxvLGwsdSksZD1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsYz1JXyhkLHIuc2hhcGUsci5kdHlwZSx3LmNvbXB1dGVTdHJpZGVzKHIuc2hhcGUpLHAsXCJhdmdcIik7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8oYy5zaGFwZSxcImZsb2F0MzJcIixjLnZhbHVlcyl9dmFyIGNYPXtrZXJuZWxOYW1lOnR1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpwWH07ZnVuY3Rpb24gZFgoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtkeTpyLGlucHV0OnN9PXQse2ZpbHRlclNpemU6aSxzdHJpZGVzOm8scGFkOmwsZGltUm91bmRpbmdNb2RlOnV9PWE7Z2UoW3Isc10sXCJhdmdQb29sM0RHcmFkXCIpO2xldCBwPVQuY29tcHV0ZVBvb2wzREluZm8ocy5zaGFwZSxpLG8sMSxsLHUpLGQ9cC5zdHJpZGVEZXB0aCxjPXAuc3RyaWRlSGVpZ2h0LGg9cC5zdHJpZGVXaWR0aCxtPXAuZmlsdGVyRGVwdGgsZj1wLmZpbHRlckhlaWdodCxnPXAuZmlsdGVyV2lkdGgsYj1wLmRpbGF0aW9uRGVwdGgseT1wLmRpbGF0aW9uSGVpZ2h0LHg9cC5kaWxhdGlvbldpZHRoLHY9cC5lZmZlY3RpdmVGaWx0ZXJEZXB0aCxJPXAuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LE49cC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxDPXYtMS1wLnBhZEluZm8uZnJvbnQsXz1OLTEtcC5wYWRJbmZvLmxlZnQsRj1JLTEtcC5wYWRJbmZvLnRvcCxEPU9lKHMuc2hhcGUsXCJmbG9hdDMyXCIpLCQ9MS8obSpmKmcpLFM9bi5idWZmZXJTeW5jKHIpO2ZvcihsZXQgTT0wO008cC5iYXRjaFNpemU7KytNKWZvcihsZXQgQj0wO0I8cC5pbkNoYW5uZWxzOysrQilmb3IobGV0IFU9MDtVPHAuaW5EZXB0aDsrK1UpZm9yKGxldCBIPTA7SDxwLmluSGVpZ2h0OysrSClmb3IobGV0IHE9MDtxPHAuaW5XaWR0aDsrK3Epe2xldCBLPVUtQyxaPUgtRixKPXEtXyxlZT0wO2ZvcihsZXQgYWU9MDthZTx2O2FlKz1iKXtsZXQgdGU9KEsrYWUpL2Q7aWYoISh0ZTwwfHx0ZT49cC5vdXREZXB0aHx8TWF0aC5mbG9vcih0ZSkhPT10ZSkpZm9yKGxldCBzZT0wO3NlPEk7c2UrPXkpe2xldCBpZT0oWitzZSkvYztpZighKGllPDB8fGllPj1wLm91dEhlaWdodHx8TWF0aC5mbG9vcihpZSkhPT1pZSkpZm9yKGxldCB2ZT0wO3ZlPE47dmUrPXgpe2xldCB1ZT0oSit2ZSkvaDtpZih1ZTwwfHx1ZT49cC5vdXRXaWR0aHx8TWF0aC5mbG9vcih1ZSkhPT11ZSljb250aW51ZTtsZXQgeWU9Uy5nZXQoTSx0ZSxpZSx1ZSxCKTtlZSs9eWV9fX1ELnNldChlZSokLE0sVSxILHEsQil9cmV0dXJuIG4ubWFrZVRlbnNvckluZm8oRC5zaGFwZSxELmR0eXBlLEQudmFsdWVzKX12YXIgaFg9e2tlcm5lbE5hbWU6UmMsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmRYfTtmdW5jdGlvbiBtWChlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2R5OnIsaW5wdXQ6c309dCxpPXM7Z2UoW3Isc10sXCJhdmdQb29sR3JhZFwiKTtsZXR7ZmlsdGVyU2l6ZTpvLHN0cmlkZXM6bCxwYWQ6dX09YSxwPVQuY29tcHV0ZVBvb2wyREluZm8oaS5zaGFwZSxvLGwsMSx1KSxkPXAuc3RyaWRlSGVpZ2h0LGM9cC5zdHJpZGVXaWR0aCxoPXAuZmlsdGVySGVpZ2h0LG09cC5maWx0ZXJXaWR0aCxmPXAuZGlsYXRpb25IZWlnaHQsZz1wLmRpbGF0aW9uV2lkdGgsYj1wLmVmZmVjdGl2ZUZpbHRlckhlaWdodCx5PXAuZWZmZWN0aXZlRmlsdGVyV2lkdGgseD15LTEtcC5wYWRJbmZvLmxlZnQsdj1iLTEtcC5wYWRJbmZvLnRvcCxJPU9lKGkuc2hhcGUsXCJmbG9hdDMyXCIpLE49MS8oaCptKSxDPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxfPU9lKHIuc2hhcGUsXCJmbG9hdDMyXCIsQyk7Zm9yKGxldCBGPTA7RjxwLmJhdGNoU2l6ZTsrK0YpZm9yKGxldCBEPTA7RDxwLmluQ2hhbm5lbHM7KytEKWZvcihsZXQgJD0wOyQ8cC5pbkhlaWdodDsrKyQpZm9yKGxldCBTPTA7UzxwLmluV2lkdGg7KytTKXtsZXQgTT0kLXYsQj1TLXgsVT0wO2ZvcihsZXQgSD0wO0g8YjtIKz1mKXtsZXQgcT0oTStIKS9kO2lmKCEocTwwfHxxPj1wLm91dEhlaWdodHx8TWF0aC5mbG9vcihxKSE9PXEpKWZvcihsZXQgSz0wO0s8eTtLKz1nKXtsZXQgWj0oQitLKS9jO2lmKFo8MHx8Wj49cC5vdXRXaWR0aHx8TWF0aC5mbG9vcihaKSE9PVopY29udGludWU7bGV0IEo9Xy5nZXQoRixxLFosRCk7VSs9Sn19SS5zZXQoVSpOLEYsJCxTLEQpfXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKEkuc2hhcGUsSS5kdHlwZSxJLnZhbHVlcyl9dmFyIGZYPXtrZXJuZWxOYW1lOkRjLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzptWH07ZnVuY3Rpb24gZ1goZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsc2NhbGU6cyxvZmZzZXQ6aSxtZWFuOm8sdmFyaWFuY2U6bH09dDt3LmFzc2VydChvLnNoYXBlLmxlbmd0aD09PWwuc2hhcGUubGVuZ3RoLCgpPT5cIkJhdGNoIG5vcm1hbGl6YXRpb24gZ3JhZGllbnQgcmVxdWlyZXMgbWVhbiBhbmQgdmFyaWFuY2UgdG8gaGF2ZSBlcXVhbCByYW5rcy5cIiksdy5hc3NlcnQoaT09bnVsbHx8by5zaGFwZS5sZW5ndGg9PT1pLnNoYXBlLmxlbmd0aCwoKT0+XCJCYXRjaCBub3JtYWxpemF0aW9uIGdyYWRpZW50IHJlcXVpcmVzIG1lYW4gYW5kIG9mZnNldCB0byBoYXZlIGVxdWFsIHJhbmtzLlwiKSx3LmFzc2VydChzPT1udWxsfHxvLnNoYXBlLmxlbmd0aD09PXMuc2hhcGUubGVuZ3RoLCgpPT5cIkJhdGNoIG5vcm1hbGl6YXRpb24gZ3JhZGllbnQgcmVxdWlyZXMgbWVhbiBhbmQgc2NhbGUgdG8gaGF2ZSBlcXVhbCByYW5rcy5cIiksZ2UoW3IsbyxsLHMsaV0sXCJiYXRjaE5vcm1cIik7bGV0e3ZhcmlhbmNlRXBzaWxvbjp1fT1hO3U9PW51bGwmJih1PS4wMDEpO2xldCBwPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxkPW4uZGF0YS5nZXQoby5kYXRhSWQpLnZhbHVlcyxjPW4uZGF0YS5nZXQobC5kYXRhSWQpLnZhbHVlcyxoPXM/bi5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzOm5ldyBGbG9hdDMyQXJyYXkoWzFdKSxtPWk/bi5kYXRhLmdldChpLmRhdGFJZCkudmFsdWVzOm5ldyBGbG9hdDMyQXJyYXkoWzBdKSxmPW5ldyBGbG9hdDMyQXJyYXkocC5sZW5ndGgpLGc9bS5sZW5ndGgsYj1oLmxlbmd0aCx5PWMubGVuZ3RoLHg9ZC5sZW5ndGgsdj0wLEk9MCxOPTAsQz0wO2ZvcihsZXQgXz0wO188cC5sZW5ndGg7KytfKWZbX109bVt2KytdKyhwW19dLWRbSSsrXSkqaFtOKytdL01hdGguc3FydChjW0MrK10rdSksdj49ZyYmKHY9MCksST49eCYmKEk9MCksTj49YiYmKE49MCksQz49eSYmKEM9MCk7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8oci5zaGFwZSxyLmR0eXBlLGYpfXZhciBiWD17a2VybmVsTmFtZTpKaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Z1h9O2Z1bmN0aW9uIHlYKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtibG9ja1NoYXBlOnMsY3JvcHM6aX09YTtnZShbcl0sXCJiYXRjaFRvU3BhY2VORFwiKTtsZXQgbz1zLnJlZHVjZSgoYix5KT0+Yip5KSxsPVQuZ2V0UmVzaGFwZWQoci5zaGFwZSxzLG8pLHU9VC5nZXRQZXJtdXRlZChsLmxlbmd0aCxzLmxlbmd0aCkscD1ULmdldFJlc2hhcGVkUGVybXV0ZWQoci5zaGFwZSxzLG8pLGQ9VC5nZXRTbGljZUJlZ2luQ29vcmRzKGkscy5sZW5ndGgpLGM9VC5nZXRTbGljZVNpemUocCxpLHMubGVuZ3RoKSxoPXh0KHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpsfX0pLG09Vm4oe2lucHV0czp7eDpofSxiYWNrZW5kOm4sYXR0cnM6e3Blcm06dX19KSxmPXh0KHtpbnB1dHM6e3g6bX0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpwfX0pLGc9eGkoe2lucHV0czp7eDpmfSxiYWNrZW5kOm4sYXR0cnM6e2JlZ2luOmQsc2l6ZTpjfX0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGgpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obSksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhmKSxnfXZhciB4WD17a2VybmVsTmFtZTpudSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6eVh9O2Z1bmN0aW9uIHZYKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyLHdlaWdodHM6c309dCx7c2l6ZTppfT1hLG89bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLGw9bi5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzLHU9UDEobyxsLHMuZHR5cGUscy5zaGFwZSxpKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhbaV0scy5kdHlwZSx1KX12YXIgd1g9e2tlcm5lbE5hbWU6YXUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOnZYfTtmdW5jdGlvbiBrWChlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHtzMDphLHMxOnJ9PXQscz1uLmRhdGEuZ2V0KGEuZGF0YUlkKS52YWx1ZXMsaT1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsbz1ULmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKEFycmF5LmZyb20ocyksQXJyYXkuZnJvbShpKSk7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8oW28ubGVuZ3RoXSxcImludDMyXCIsSW50MzJBcnJheS5mcm9tKG8pKX12YXIgSVg9e2tlcm5lbE5hbWU6TWMsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmtYfSxTWD1sdCh3cywoZSx0KT0+e2xldCBuPXQ7cmV0dXJuIGU+bi5jbGlwVmFsdWVNYXg/bi5jbGlwVmFsdWVNYXg6ZTxuLmNsaXBWYWx1ZU1pbj9uLmNsaXBWYWx1ZU1pbjplfSksTlg9e2tlcm5lbE5hbWU6d3MsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOlNYfSxUWD1lPT57bGV0e3g6dH09ZS5pbnB1dHMsbj1lLmJhY2tlbmQsYT1uZXcgRmxvYXQzMkFycmF5KHcuc2l6ZUZyb21TaGFwZSh0LnNoYXBlKSkscj1uLmRhdGEuZ2V0KHQuZGF0YUlkKSxzPXIuY29tcGxleFRlbnNvckluZm9zLnJlYWwsaT1yLmNvbXBsZXhUZW5zb3JJbmZvcy5pbWFnLG89bi5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzLGw9bi5kYXRhLmdldChpLmRhdGFJZCkudmFsdWVzO2ZvcihsZXQgdT0wO3U8by5sZW5ndGg7dSsrKXtsZXQgcD1vW3VdLGQ9bFt1XTthW3VdPU1hdGguaHlwb3QocCxkKX1yZXR1cm4gbi5tYWtlT3V0cHV0KGEsdC5zaGFwZSxcImZsb2F0MzJcIil9LENYPXtrZXJuZWxOYW1lOk9jLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpUWH07ZnVuY3Rpb24gcWwoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7aW5wdXQ6YX09dCxyPW4uZGF0YS5nZXQoYS5kYXRhSWQpLmNvbXBsZXhUZW5zb3JJbmZvcy5pbWFnLHM9bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKHIuc2hhcGUsci5kdHlwZSxzKX12YXIgRVg9e2tlcm5lbE5hbWU6X20sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOnFsfTtmdW5jdGlvbiBLbChlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2F4aXM6cn09YSxzPXcucGFyc2VBeGlzUGFyYW0ocix0WzBdLnNoYXBlKVswXSxpPXQubWFwKGY9PmYuc2hhcGUpO1QuYXNzZXJ0UGFyYW1zQ29uc2lzdGVudChpLHMpO2xldCBvPVQuY29tcHV0ZU91dFNoYXBlKHQubWFwKGY9PmYuc2hhcGUpLHMpO2lmKHcuc2l6ZUZyb21TaGFwZShvKT09PTApcmV0dXJuIG4ubWFrZVRlbnNvckluZm8obyx0WzBdLmR0eXBlLFtdKTtsZXQgbD10LmZpbHRlcihmPT53LnNpemVGcm9tU2hhcGUoZi5zaGFwZSk+MCk7aWYobC5sZW5ndGg9PT0xKXJldHVybiBjcih7aW5wdXRzOnt4OmxbMF19LGJhY2tlbmQ6bn0pO2lmKGxbMF0uZHR5cGU9PT1cImNvbXBsZXg2NFwiKXtsZXQgZj1sLm1hcCh2PT55aSh7aW5wdXRzOntpbnB1dDp2fSxiYWNrZW5kOm59KSksZz1sLm1hcCh2PT5xbCh7aW5wdXRzOntpbnB1dDp2fSxiYWNrZW5kOm59KSksYj1LbCh7aW5wdXRzOmYsYmFja2VuZDpuLGF0dHJzOntheGlzOnN9fSkseT1LbCh7aW5wdXRzOmcsYmFja2VuZDpuLGF0dHJzOntheGlzOnN9fSkseD1Zbih7aW5wdXRzOntyZWFsOmIsaW1hZzp5fSxiYWNrZW5kOm59KTtyZXR1cm4gZi5mb3JFYWNoKHY9Pm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odikpLGcuZm9yRWFjaCh2PT5uLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHYpKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGIpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oeSkseH1sZXQgdT1sLm1hcChmPT57bGV0IGc9Wy0xLHcuc2l6ZUZyb21TaGFwZShmLnNoYXBlLnNsaWNlKHMpKV07cmV0dXJuIHh0KHtpbnB1dHM6e3g6Zn0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpnfX0pfSkscD11Lm1hcChmPT4oe3ZhbHM6bi5kYXRhLmdldChmLmRhdGFJZCkudmFsdWVzLHNoYXBlOmYuc2hhcGV9KSk7bz1ULmNvbXB1dGVPdXRTaGFwZSh1Lm1hcChmPT5mLnNoYXBlKSwxKTtsZXQgZD11WzBdLnNoYXBlWzBdPT09MSxjPUwxKHAsbyx0WzBdLmR0eXBlLGQpLGg9VC5jb21wdXRlT3V0U2hhcGUobC5tYXAoZj0+Zi5zaGFwZSkscyksbT1uLm1ha2VUZW5zb3JJbmZvKGgsdFswXS5kdHlwZSxjKTtyZXR1cm4gdS5mb3JFYWNoKGY9Pm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZikpLG19dmFyIF9YPXtrZXJuZWxOYW1lOnN1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpLbH07ZnVuY3Rpb24gU18oZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsZmlsdGVyOnN9PXQse3N0cmlkZXM6aSxwYWQ6byxkYXRhRm9ybWF0OmwsZGlsYXRpb25zOnUsZGltUm91bmRpbmdNb2RlOnB9PWE7Z2UoW3Isc10sXCJjb252MmRcIik7bGV0IGQ9VC5jb252ZXJ0Q29udjJERGF0YUZvcm1hdChsKSxjPVQuY29tcHV0ZUNvbnYyREluZm8oci5zaGFwZSxzLnNoYXBlLGksdSxvLHAsITEsZCksaD1jLmZpbHRlckhlaWdodCxtPWMuZmlsdGVyV2lkdGgsZj1jLmRpbGF0aW9uSGVpZ2h0LGc9Yy5kaWxhdGlvbldpZHRoLGI9Yy5wYWRJbmZvLmxlZnQseT1jLnBhZEluZm8udG9wLHg9Yy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0xhc3RcIix2PW5ldyBXdChjLm91dFNoYXBlLHIuZHR5cGUpLEk9dy5jb21wdXRlU3RyaWRlcyhyLnNoYXBlKSxOPXcuY29tcHV0ZVN0cmlkZXMocy5zaGFwZSksQz1JWzBdLF89eD9JWzFdOklbMl0sRj14P0lbMl06MSxEPXg/MTpJWzFdLCQ9di5zdHJpZGVzWzBdLFM9eD92LnN0cmlkZXNbMV06di5zdHJpZGVzWzJdLE09eD92LnN0cmlkZXNbMl06MSxCPXg/MTp2LnN0cmlkZXNbMV0sVT1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsSD1uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMscT12LnZhbHVlcztmb3IobGV0IEs9MDtLPGMuYmF0Y2hTaXplOysrSyl7bGV0IFo9SypDLEo9SyokO2ZvcihsZXQgZWU9MDtlZTxjLm91dEhlaWdodDsrK2VlKXtsZXQgYWU9SitlZSpTLHRlPWVlKmMuc3RyaWRlSGVpZ2h0LXk7Zm9yKGxldCBzZT0wO3NlPGg7KytzZSl7bGV0IGllPXRlK3NlKmY7aWYoaWU8MHx8aWU+PWMuaW5IZWlnaHQpY29udGludWU7bGV0IHZlPXNlKk5bMF0sdWU9WitpZSpfO2ZvcihsZXQgeWU9MDt5ZTxjLm91dFdpZHRoOysreWUpe2xldCBrZT1hZSt5ZSpNLFNlPXllKmMuc3RyaWRlV2lkdGgtYjtmb3IobGV0IExlPTA7TGU8bTsrK0xlKXtsZXQgVWU9U2UrTGUqZztpZihVZTwwfHxVZT49Yy5pbldpZHRoKWNvbnRpbnVlO2xldCBtdD12ZStMZSpOWzFdLHN0PXVlK1VlKkYsdHQ9bXQ7Zm9yKGxldCBudD0wO250PGMuaW5DaGFubmVsczsrK250KXtsZXQgUmU9VVtzdCtudCpEXTtmb3IobGV0IGd0PTA7Z3Q8Yy5vdXRDaGFubmVsczsrK2d0KXFba2UrZ3QqQl0rPVJlKkhbdHQrZ3RdO3R0Kz1jLm91dENoYW5uZWxzfX19fX19cmV0dXJuIG4ubWFrZVRlbnNvckluZm8odi5zaGFwZSx2LmR0eXBlLHEpfXZhciBBWD17a2VybmVsTmFtZTpQaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6U199O2Z1bmN0aW9uIEZYKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyLGR5OnN9PXQse3N0cmlkZXM6aSxwYWQ6byxkYXRhRm9ybWF0OmwsZGltUm91bmRpbmdNb2RlOnUsZmlsdGVyU2hhcGU6cH09YTtnZShbcixzXSxcImNvbnYyZEJhY2twcm9wRmlsdGVyXCIpO2xldCBkPVQuY29udmVydENvbnYyRERhdGFGb3JtYXQobCksYz1ULmNvbXB1dGVDb252MkRJbmZvKHIuc2hhcGUscCxpLDEsbyx1LCExLGQpLHtzdHJpZGVIZWlnaHQ6aCxzdHJpZGVXaWR0aDptLGZpbHRlckhlaWdodDpmLGZpbHRlcldpZHRoOmd9PWMsYj1jLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzTGFzdFwiLHk9bmV3IFd0KGMuZmlsdGVyU2hhcGUsXCJmbG9hdDMyXCIpLHg9Yy5wYWRJbmZvLmxlZnQsdj1jLnBhZEluZm8udG9wLEk9bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLE49bi5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzLEM9bmV3IFd0KHIuc2hhcGUsci5kdHlwZSxJKSxfPW5ldyBXdChzLnNoYXBlLHMuZHR5cGUsTik7Zm9yKGxldCBGPTA7RjxmOysrRil7bGV0IEQ9TWF0aC5tYXgoMCxNYXRoLmNlaWwoKHYtRikvaCkpLCQ9TWF0aC5taW4oYy5vdXRIZWlnaHQsKGMuaW5IZWlnaHQrdi1GKS9oKTtmb3IobGV0IFM9MDtTPGc7KytTKXtsZXQgTT1NYXRoLm1heCgwLE1hdGguY2VpbCgoeC1TKS9tKSksQj1NYXRoLm1pbihjLm91dFdpZHRoLChjLmluV2lkdGgreC1TKS9tKTtmb3IobGV0IFU9MDtVPGMuaW5DaGFubmVsczsrK1UpZm9yKGxldCBIPTA7SDxjLm91dENoYW5uZWxzOysrSCl7bGV0IHE9MDtmb3IobGV0IEs9MDtLPGMuYmF0Y2hTaXplOysrSylmb3IobGV0IFo9RDtaPCQ7KytaKXtsZXQgSj1GK1oqaC12O2ZvcihsZXQgZWU9TTtlZTxCOysrZWUpe2xldCBhZT1TK2VlKm0teDtiP3ErPUMuZ2V0KEssSixhZSxVKSpfLmdldChLLFosZWUsSCk6cSs9Qy5nZXQoSyxVLEosYWUpKl8uZ2V0KEssSCxaLGVlKX19eS5zZXQocSxGLFMsVSxIKX19fXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKHkuc2hhcGUseS5kdHlwZSx5LnZhbHVlcyl9dmFyICRYPXtrZXJuZWxOYW1lOmttLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpGWH07ZnVuY3Rpb24gRFgoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtkeTpyLGZpbHRlcjpzfT10LHtpbnB1dFNoYXBlOmksc3RyaWRlczpvLHBhZDpsLGRhdGFGb3JtYXQ6dSxkaW1Sb3VuZGluZ01vZGU6cH09YTtnZShbcixzXSxcImNvbnYyZEJhY2twcm9wSW5wdXRcIik7bGV0IGQ9dy5jb21wdXRlU3RyaWRlcyhzLnNoYXBlKSxjPXcuY29tcHV0ZVN0cmlkZXMoci5zaGFwZSksaD1ULmNvbnZlcnRDb252MkREYXRhRm9ybWF0KHUpLG09VC5jb21wdXRlQ29udjJESW5mbyhpLHMuc2hhcGUsbywxLGwscCwhMSxoKSxmPW5ldyBXdChtLmluU2hhcGUsXCJmbG9hdDMyXCIpLGc9Zi52YWx1ZXMsYj1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMseT1uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMsW3gsdixJXT1kLHtiYXRjaFNpemU6TixmaWx0ZXJIZWlnaHQ6QyxmaWx0ZXJXaWR0aDpfLGluQ2hhbm5lbHM6RixpbkhlaWdodDpELGluV2lkdGg6JCxvdXRDaGFubmVsczpTLG91dEhlaWdodDpNLG91dFdpZHRoOkIsc3RyaWRlSGVpZ2h0OlUsc3RyaWRlV2lkdGg6SH09bTtoPW0uZGF0YUZvcm1hdDtsZXQgcT1DLTEtbS5wYWRJbmZvLnRvcCxLPV8tMS1tLnBhZEluZm8ubGVmdCxaPWg9PT1cImNoYW5uZWxzTGFzdFwiLEo9Zi5zdHJpZGVzWzBdLGVlPVo/Zi5zdHJpZGVzWzFdOmYuc3RyaWRlc1syXSxhZT1aP2Yuc3RyaWRlc1syXToxLHRlPVo/MTpmLnN0cmlkZXNbMV0sc2U9Y1swXSxpZT1aP2NbMV06Y1syXSx2ZT1aP2NbMl06MSx1ZT1aPzE6Y1sxXTtmb3IobGV0IHllPTA7eWU8TjsrK3llKWZvcihsZXQga2U9MDtrZTxGOysra2UpZm9yKGxldCBTZT0wO1NlPEQ7KytTZSl7bGV0IExlPVNlLXEsVWU9TWF0aC5tYXgoMCxNYXRoLmNlaWwoTGUvVSkpLG10PU1hdGgubWluKE0sKEMrTGUpL1UpO2ZvcihsZXQgc3Q9MDtzdDwkOysrc3Qpe2xldCB0dD1zdC1LLG50PU1hdGgubWF4KDAsTWF0aC5jZWlsKHR0L0gpKSxSZT1NYXRoLm1pbihCLChfK3R0KS9IKSxndD0wO2ZvcihsZXQgT3Q9VWU7T3Q8bXQ7KytPdCl7bGV0IGlhPU90KlUtTGU7Zm9yKGxldCB1bj1udDt1bjxSZTsrK3VuKXtsZXQgRm49dW4qSC10dCxvYT1zZSp5ZStpZSpPdCt2ZSp1biwkbj14KihDLTEtaWEpK3YqKF8tMS1GbikrSSprZTtmb3IobGV0IHV0PTA7dXQ8UzsrK3V0KXtsZXQgRG49YltvYSt1ZSp1dF0sSG49eVskbit1dF07Z3QrPURuKkhufX19bGV0IEduPUoqeWUrZWUqU2UrYWUqc3QrdGUqa2U7Z1tHbl09Z3R9fXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKGYuc2hhcGUsZi5kdHlwZSxmLnZhbHVlcyl9dmFyIFJYPXtrZXJuZWxOYW1lOkxpLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpEWH07ZnVuY3Rpb24gTVgoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsZmlsdGVyOnN9PXQse3N0cmlkZXM6aSxwYWQ6byxkaWxhdGlvbnM6bH09YTtnZShbcixzXSxcImNvbnYzZFwiKTtsZXQgdT1ULmNvbXB1dGVDb252M0RJbmZvKHIuc2hhcGUscy5zaGFwZSxpLGwsbykse2ZpbHRlckRlcHRoOnAsZmlsdGVySGVpZ2h0OmQsZmlsdGVyV2lkdGg6YyxkaWxhdGlvbkRlcHRoOmgsZGlsYXRpb25IZWlnaHQ6bSxkaWxhdGlvbldpZHRoOmYscGFkSW5mbzpnfT11LGI9Zy5mcm9udCx5PWcubGVmdCx4PWcudG9wLHY9bmV3IFd0KHUub3V0U2hhcGUsci5kdHlwZSksST1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsTj1uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMsQz12LnZhbHVlcyxfPXcuY29tcHV0ZVN0cmlkZXMoci5zaGFwZSksRj13LmNvbXB1dGVTdHJpZGVzKHMuc2hhcGUpO2ZvcihsZXQgRD0wO0Q8dS5iYXRjaFNpemU7KytEKXtsZXQgJD1EKl9bMF0sUz1EKnYuc3RyaWRlc1swXTtmb3IobGV0IE09MDtNPHUub3V0RGVwdGg7KytNKXtsZXQgQj1TK00qdi5zdHJpZGVzWzFdLFU9TSp1LnN0cmlkZURlcHRoLWI7Zm9yKGxldCBIPTA7SDxwOysrSCl7bGV0IHE9VStIKmg7aWYocTwwfHxxPj11LmluRGVwdGgpY29udGludWU7bGV0IEs9SCpGWzBdLFo9JCtxKl9bMV07Zm9yKGxldCBKPTA7Sjx1Lm91dEhlaWdodDsrK0ope2xldCBlZT1CK0oqdi5zdHJpZGVzWzJdLGFlPUoqdS5zdHJpZGVIZWlnaHQteDtmb3IobGV0IHRlPTA7dGU8ZDsrK3RlKXtsZXQgc2U9YWUrdGUqbTtpZihzZTwwfHxzZT49dS5pbkhlaWdodCljb250aW51ZTtsZXQgaWU9Syt0ZSpGWzFdLHZlPVorc2UqX1syXTtmb3IobGV0IHVlPTA7dWU8dS5vdXRXaWR0aDsrK3VlKXtsZXQgeWU9ZWUrdWUqdS5vdXRDaGFubmVscyxrZT11ZSp1LnN0cmlkZVdpZHRoLXk7Zm9yKGxldCBTZT0wO1NlPGM7KytTZSl7bGV0IExlPWtlK1NlKmY7aWYoTGU8MHx8TGU+PXUuaW5XaWR0aCljb250aW51ZTtsZXQgVWU9aWUrU2UqRlsyXSxtdD12ZStMZSp1LmluQ2hhbm5lbHMsc3Q9VWU7Zm9yKGxldCB0dD0wO3R0PHUuaW5DaGFubmVsczsrK3R0KXtsZXQgbnQ9SVttdCt0dF07Zm9yKGxldCBSZT0wO1JlPHUub3V0Q2hhbm5lbHM7KytSZSlDW3llK1JlXSs9bnQqTltzdCtSZV07c3QrPXUub3V0Q2hhbm5lbHN9fX19fX19fXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKHYuc2hhcGUsdi5kdHlwZSx2LnZhbHVlcyl9dmFyIE9YPXtrZXJuZWxOYW1lOnppLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpNWH07ZnVuY3Rpb24gUFgoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsZHk6c309dCx7c3RyaWRlczppLHBhZDpvLGZpbHRlclNoYXBlOmx9PWE7Z2UoW3Isc10sXCJjb252M2RCYWNrcHJvcEZpbHRlclYyXCIpO2xldCB1PXcuY29tcHV0ZVN0cmlkZXMoci5zaGFwZSkscD13LmNvbXB1dGVTdHJpZGVzKHMuc2hhcGUpLGQ9VC5jb21wdXRlQ29udjNESW5mbyhyLnNoYXBlLGwsaSwxLG8pLGM9ZC5zdHJpZGVEZXB0aCxoPWQuc3RyaWRlSGVpZ2h0LG09ZC5zdHJpZGVXaWR0aCxmPWQuZmlsdGVyRGVwdGgsZz1kLmZpbHRlckhlaWdodCxiPWQuZmlsdGVyV2lkdGgseT1uZXcgV3QoZC5maWx0ZXJTaGFwZSxcImZsb2F0MzJcIikseD15LnZhbHVlcyxbdixJLE4sQ109eS5zdHJpZGVzLF89bi5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzLFtGLEQsJCxTXT1wLE09bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLFtCLFUsSCxxXT11LEs9ZC5wYWRJbmZvLmZyb250LFo9ZC5wYWRJbmZvLmxlZnQsSj1kLnBhZEluZm8udG9wO2ZvcihsZXQgZWU9MDtlZTxmOysrZWUpe2xldCBhZT1NYXRoLm1heCgwLE1hdGguY2VpbCgoSy1lZSkvYykpLHRlPU1hdGgubWluKGQub3V0RGVwdGgsKGQuaW5EZXB0aCtLLWVlKS9jKSxzZT1lZSp2O2ZvcihsZXQgaWU9MDtpZTxnOysraWUpe2xldCB2ZT1NYXRoLm1heCgwLE1hdGguY2VpbCgoSi1pZSkvaCkpLHVlPU1hdGgubWluKGQub3V0SGVpZ2h0LChkLmluSGVpZ2h0K0otaWUpL2gpLHllPWllKkkrc2U7Zm9yKGxldCBrZT0wO2tlPGI7KytrZSl7bGV0IFNlPU1hdGgubWF4KDAsTWF0aC5jZWlsKChaLWtlKS9tKSksTGU9TWF0aC5taW4oZC5vdXRXaWR0aCwoZC5pbldpZHRoK1ota2UpL20pLFVlPWtlKk4reWU7Zm9yKGxldCBtdD0wO210PGQuaW5DaGFubmVsczsrK210KXtsZXQgc3Q9bXQqQytVZTtmb3IobGV0IHR0PTA7dHQ8ZC5vdXRDaGFubmVsczsrK3R0KXtsZXQgbnQ9MDtmb3IobGV0IFJlPTA7UmU8ZC5iYXRjaFNpemU7KytSZSl7bGV0IGd0PVJlKkIsR249UmUqRjtmb3IobGV0IE90PWFlO090PHRlOysrT3Qpe2xldCBpYT0oZWUrT3QqYy1LKSpVK2d0LHVuPU90KkQrR247Zm9yKGxldCBGbj12ZTtGbjx1ZTsrK0ZuKXtsZXQgb2E9KGllK0ZuKmgtSikqSCtpYSwkbj1GbiokK3VuO2ZvcihsZXQgdXQ9U2U7dXQ8TGU7Kyt1dCl7bGV0IERuPShrZSt1dCptLVopKnErb2EsSG49dXQqUyskbjtudCs9TVtEbittdF0qX1tIbit0dF19fX19eFtzdCt0dF09bnR9fX19fXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKHkuc2hhcGUseS5kdHlwZSx5LnZhbHVlcyl9dmFyIExYPXtrZXJuZWxOYW1lOml1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpQWH07ZnVuY3Rpb24gelgoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtkeTpyLGZpbHRlcjpzfT10LHtwYWQ6aSxzdHJpZGVzOm8saW5wdXRTaGFwZTpsfT1hO2dlKFtyXSxcImNvbnYzZEJhY2twcm9wSW5wdXRWMlwiKTtsZXQgdT13LmNvbXB1dGVTdHJpZGVzKHIuc2hhcGUpLHA9dy5jb21wdXRlU3RyaWRlcyhzLnNoYXBlKSxkPVQuY29tcHV0ZUNvbnYzREluZm8obCxzLnNoYXBlLG8sMSxpKSxjPW5ldyBXdChkLmluU2hhcGUsXCJmbG9hdDMyXCIpLGg9Yy52YWx1ZXMsW20sZixnLGJdPWMuc3RyaWRlcyx5PW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxbeCx2LEksTl09dSxDPW4uZGF0YS5nZXQocy5kYXRhSWQpLnZhbHVlcyxbXyxGLEQsJF09cCx7YmF0Y2hTaXplOlMsZmlsdGVyRGVwdGg6TSxmaWx0ZXJIZWlnaHQ6QixmaWx0ZXJXaWR0aDpVLGluQ2hhbm5lbHM6SCxpbkRlcHRoOnEsaW5IZWlnaHQ6SyxpbldpZHRoOlosb3V0Q2hhbm5lbHM6SixvdXREZXB0aDplZSxvdXRIZWlnaHQ6YWUsb3V0V2lkdGg6dGUsc3RyaWRlRGVwdGg6c2Usc3RyaWRlSGVpZ2h0OmllLHN0cmlkZVdpZHRoOnZlfT1kLHVlPU0tMS1kLnBhZEluZm8uZnJvbnQseWU9Qi0xLWQucGFkSW5mby50b3Asa2U9VS0xLWQucGFkSW5mby5sZWZ0O2ZvcihsZXQgU2U9MDtTZTxTOysrU2UpZm9yKGxldCBMZT0wO0xlPEg7KytMZSlmb3IobGV0IFVlPTA7VWU8cTsrK1VlKXtsZXQgbXQ9VWUtdWUsc3Q9TWF0aC5tYXgoMCxNYXRoLmNlaWwobXQvc2UpKSx0dD1NYXRoLm1pbihlZSwoTSttdCkvc2UpO2ZvcihsZXQgbnQ9MDtudDxLOysrbnQpe2xldCBSZT1udC15ZSxndD1NYXRoLm1heCgwLE1hdGguY2VpbChSZS9pZSkpLEduPU1hdGgubWluKGFlLChCK1JlKS9pZSk7Zm9yKGxldCBPdD0wO090PFo7KytPdCl7bGV0IGlhPU90LWtlLHVuPU1hdGgubWF4KDAsTWF0aC5jZWlsKGlhL3ZlKSksRm49TWF0aC5taW4odGUsKFUraWEpL3ZlKSxvYT0wO2ZvcihsZXQgJG49c3Q7JG48dHQ7Kyskbil7bGV0IHV0PSRuKnNlLW10O2ZvcihsZXQgRG49Z3Q7RG48R247KytEbil7bGV0IEhuPURuKmllLVJlO2ZvcihsZXQgeHI9dW47eHI8Rm47Kyt4cil7bGV0IG1sPXhyKnZlLWlhLFphPXgqU2UrdiokbitJKkRuK04qeHIsV3A9XyooTS0xLXV0KStGKihCLTEtSG4pK0QqKFUtMS1tbCkrJCpMZTtmb3IobGV0IElhPTA7SWE8SjsrK0lhKXtsZXQgVXI9eVtaYStJYV0sSnQ9Q1tXcCtJYV07b2ErPVVyKkp0fX19fWhbbSpTZStmKlVlK2cqbnQrYipPdCtMZV09b2F9fX1yZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhjLnNoYXBlLGMuZHR5cGUsYy52YWx1ZXMpfXZhciBXWD17a2VybmVsTmFtZTpvdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6elh9LEJYPWx0KFdpLGU9Pk1hdGguY29zKGUpKSxWWD17a2VybmVsTmFtZTpXaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Qlh9LFVYPWx0KEJpLGU9Pk1hdGguY29zaChlKSksR1g9e2tlcm5lbE5hbWU6QmksYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOlVYfTtmdW5jdGlvbiBIWChlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2ltYWdlOnIsYm94ZXM6cyxib3hJbmQ6aX09dCx7Y3JvcFNpemU6byxtZXRob2Q6bCxleHRyYXBvbGF0aW9uVmFsdWU6dX09YSxbcCxkLGMsaF09ci5zaGFwZSxtPXMuc2hhcGVbMF0sW2YsZ109byxiPU9lKFttLGYsZyxoXSxcImZsb2F0MzJcIikseT1uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMseD1uLmRhdGEuZ2V0KGkuZGF0YUlkKS52YWx1ZXMsdj1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsST13LmNvbXB1dGVTdHJpZGVzKHIuc2hhcGUpLE49dy5jb21wdXRlU3RyaWRlcyhiLnNoYXBlKTtmb3IobGV0IEM9MDtDPG07QysrKXtsZXQgXz1DKjQsRj15W19dLEQ9eVtfKzFdLCQ9eVtfKzJdLFM9eVtfKzNdLE09eFtDXTtpZihNPj1wKWNvbnRpbnVlO2xldCBCPWY+MT8oJC1GKSooZC0xKS8oZi0xKTowLFU9Zz4xPyhTLUQpKihjLTEpLyhnLTEpOjA7Zm9yKGxldCBIPTA7SDxmO0grKyl7bGV0IHE9Zj4xP0YqKGQtMSkrSCpCOi41KihGKyQpKihkLTEpO2lmKHE8MHx8cT5kLTEpe2ZvcihsZXQgSz0wO0s8ZztLKyspZm9yKGxldCBaPTA7WjxoO1orKyl7bGV0IEo9WitLKk5bMl0rSCpOWzFdK0MqTlswXTtiLnZhbHVlc1tKXT11fWNvbnRpbnVlfWlmKGw9PT1cImJpbGluZWFyXCIpe2xldCBLPU1hdGguZmxvb3IocSksWj1NYXRoLmNlaWwocSksSj1xLUs7Zm9yKGxldCBlZT0wO2VlPGc7ZWUrKyl7bGV0IGFlPWc+MT9EKihjLTEpK2VlKlU6LjUqKEQrUykqKGMtMSk7aWYoYWU8MHx8YWU+Yy0xKXtmb3IobGV0IHZlPTA7dmU8aDt2ZSsrKXtsZXQgdWU9dmUrZWUqTlsyXStIKk5bMV0rQypOWzBdO2IudmFsdWVzW3VlXT11fWNvbnRpbnVlfWxldCB0ZT1NYXRoLmZsb29yKGFlKSxzZT1NYXRoLmNlaWwoYWUpLGllPWFlLXRlO2ZvcihsZXQgdmU9MDt2ZTxoO3ZlKyspe2xldCB1ZT12ZSt0ZSpJWzJdK0sqSVsxXStNKklbMF0seWU9dlt1ZV07dWU9dmUrc2UqSVsyXStLKklbMV0rTSpJWzBdO2xldCBrZT12W3VlXTt1ZT12ZSt0ZSpJWzJdK1oqSVsxXStNKklbMF07bGV0IFNlPXZbdWVdO3VlPXZlK3NlKklbMl0rWipJWzFdK00qSVswXTtsZXQgTGU9dlt1ZV0sVWU9eWUrKGtlLXllKSppZSxtdD1TZSsoTGUtU2UpKmllO3VlPXZlK2VlKk5bMl0rSCpOWzFdK0MqTlswXSxiLnZhbHVlc1t1ZV09VWUrKG10LVVlKSpKfX19ZWxzZSBmb3IobGV0IEs9MDtLPGc7KytLKXtsZXQgWj1nPjE/RCooYy0xKStLKlU6LjUqKEQrUykqKGMtMSk7aWYoWjwwfHxaPmMtMSl7Zm9yKGxldCBhZT0wO2FlPGg7YWUrKyl7bGV0IHRlPWFlK0sqTlsyXStIKk5bMV0rQypOWzBdO2IudmFsdWVzW3RlXT11fWNvbnRpbnVlfWxldCBKPU1hdGgucm91bmQoWiksZWU9TWF0aC5yb3VuZChxKTtmb3IobGV0IGFlPTA7YWU8aDthZSsrKXtsZXQgdGU9YWUrSipJWzJdK2VlKklbMV0rTSpJWzBdLHNlPWFlK0sqTlsyXStIKk5bMV0rQypOWzBdO2IudmFsdWVzW3NlXT12W3RlXX19fX1yZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhiLnNoYXBlLGIuZHR5cGUsYi52YWx1ZXMpfXZhciBqWD17a2VybmVsTmFtZTp1dSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6SFh9O2Z1bmN0aW9uIHFYKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtheGlzOnMsZXhjbHVzaXZlOmkscmV2ZXJzZTpvfT1hO2dlKHIsXCJjdW1wcm9kXCIpO2xldCBsPVQuZ2V0QXhlc1Blcm11dGF0aW9uKFtzXSxyLnNoYXBlLmxlbmd0aCksdT1yO2whPW51bGwmJih1PVZuKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntwZXJtOmx9fSkpO2xldCBwPVQuZ2V0SW5uZXJNb3N0QXhlcygxLHIuc2hhcGUubGVuZ3RoKVswXTtpZihwIT09dS5zaGFwZS5sZW5ndGgtMSl0aHJvdyBuZXcgRXJyb3IoYGJhY2tlbmQuY3VtcHJvZCBpbiBDUFUgZXhwZWN0cyBhbiBpbm5lci1tb3N0IGF4aXM9JHt1LnNoYXBlLmxlbmd0aC0xfSBidXQgZ290IGF4aXM9JHtwfWApO2xldCBkPWZhKHUuZHR5cGUsXCJpbnQzMlwiKSxjPXcubWFrZU9uZXNUeXBlZEFycmF5KHcuc2l6ZUZyb21TaGFwZSh1LnNoYXBlKSxkKSxoPW4uZGF0YS5nZXQodS5kYXRhSWQpLnZhbHVlcyxtPXUuc2hhcGVbdS5zaGFwZS5sZW5ndGgtMV0sZj1vPyhiLHkpPT5iK20teS0xOihiLHkpPT5iK3k7Zm9yKGxldCBiPTA7YjxoLmxlbmd0aDtiKz1tKWZvcihsZXQgeT0wO3k8bTt5Kyspe2xldCB4PWYoYix5KTtpZih5PT09MCljW3hdPWk/MTpoW3hdO2Vsc2V7bGV0IHY9ZihiLHktMSk7Y1t4XT1pP2hbdl0qY1t2XTpoW3hdKmNbdl19fWxldCBnPW4ubWFrZVRlbnNvckluZm8odS5zaGFwZSxkLGMpO2lmKGwhPW51bGwpe2xldCBiPVQuZ2V0VW5kb0F4ZXNQZXJtdXRhdGlvbihsKSx5PVZuKHtpbnB1dHM6e3g6Z30sYmFja2VuZDpuLGF0dHJzOntwZXJtOmJ9fSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZyksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh1KSx5fXJldHVybiBnfXZhciBLWD17a2VybmVsTmFtZTpsdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6cVh9O2Z1bmN0aW9uIFhYKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtheGlzOnMsZXhjbHVzaXZlOmkscmV2ZXJzZTpvfT1hO2dlKHIsXCJjdW1zdW1cIik7bGV0IGw9VC5nZXRBeGVzUGVybXV0YXRpb24oW3NdLHIuc2hhcGUubGVuZ3RoKSx1PXI7bCE9bnVsbCYmKHU9Vm4oe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3Blcm06bH19KSk7bGV0IHA9VC5nZXRJbm5lck1vc3RBeGVzKDEsci5zaGFwZS5sZW5ndGgpWzBdO2lmKHAhPT11LnNoYXBlLmxlbmd0aC0xKXRocm93IG5ldyBFcnJvcihgYmFja2VuZC5jdW1zdW0gaW4gQ1BVIGV4cGVjdHMgYW4gaW5uZXItbW9zdCBheGlzPSR7dS5zaGFwZS5sZW5ndGgtMX0gYnV0IGdvdCBheGlzPSR7cH1gKTtsZXQgZD1mYSh1LmR0eXBlLFwiaW50MzJcIiksYz13Lm1ha2VaZXJvc1R5cGVkQXJyYXkody5zaXplRnJvbVNoYXBlKHUuc2hhcGUpLGQpLGg9bi5kYXRhLmdldCh1LmRhdGFJZCkudmFsdWVzLG09dS5zaGFwZVt1LnNoYXBlLmxlbmd0aC0xXSxmPW8/KGIseSk9PmIrbS15LTE6KGIseSk9PmIreTtmb3IobGV0IGI9MDtiPGgubGVuZ3RoO2IrPW0pZm9yKGxldCB5PTA7eTxtO3krKyl7bGV0IHg9ZihiLHkpO2lmKHk9PT0wKWNbeF09aT8wOmhbeF07ZWxzZXtsZXQgdj1mKGIseS0xKTtjW3hdPWk/aFt2XStjW3ZdOmhbeF0rY1t2XX19bGV0IGc9bi5tYWtlVGVuc29ySW5mbyh1LnNoYXBlLGQsYyk7aWYobCE9bnVsbCl7bGV0IGI9VC5nZXRVbmRvQXhlc1Blcm11dGF0aW9uKGwpLHk9Vm4oe2lucHV0czp7eDpnfSxiYWNrZW5kOm4sYXR0cnM6e3Blcm06Yn19KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhnKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHUpLHl9cmV0dXJuIGd9dmFyIFlYPXtrZXJuZWxOYW1lOlZpLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpYWH07ZnVuY3Rpb24gWlgoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsd2VpZ2h0czpzfT10LHtzaXplOmksYmluYXJ5T3V0cHV0Om99PWE7aWYoci5zaGFwZS5sZW5ndGg9PT0xKXtsZXQgbD1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsdT1uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMscD1QMShsLHUscy5kdHlwZSxzLnNoYXBlLGkpO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKFtpXSxzLmR0eXBlLHApfWVsc2UgaWYoci5zaGFwZS5sZW5ndGg9PT0yKXtsZXQgbD1uLmJ1ZmZlclN5bmMociksdT1uLmJ1ZmZlclN5bmMocykscD0kRShsLHUsaSxvKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhwLnNoYXBlLHMuZHR5cGUscC52YWx1ZXMpfXRocm93IG5ldyBFcnJvcihgRXJyb3IgaW4gZGVuc2VCaW5jb3VudDogaW5wdXQgbXVzdCBiZSBhdCBtb3N0IHJhbmsgMiwgYnV0IGdvdCByYW5rJHtyLnNoYXBlLmxlbmd0aH0uYCl9dmFyIEpYPXtrZXJuZWxOYW1lOlBjLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpaWH07ZnVuY3Rpb24gUVgoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2Jsb2NrU2l6ZTpzLGRhdGFGb3JtYXQ6aX09YTt3LmFzc2VydChpPT09XCJOSFdDXCIsKCk9PmBPbmx5IE5IV0MgZGF0YUZvcm1hdCBzdXBwb3J0ZWQgb24gQ1BVIGZvciBkZXB0aFRvU3BhY2UuIEdvdCAke2l9YCk7bGV0IG89ci5zaGFwZVswXSxsPXIuc2hhcGVbMV0sdT1yLnNoYXBlWzJdLHA9ci5zaGFwZVszXSxkPWwqcyxjPXUqcyxoPXAvKHMqcyksbT1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsZj1uZXcgRmxvYXQzMkFycmF5KG8qZCpjKmgpLGc9MDtmb3IobGV0IGI9MDtiPG87KytiKWZvcihsZXQgeT0wO3k8ZDsrK3kpe2xldCB4PU1hdGguZmxvb3IoeS9zKSx2PXklcztmb3IobGV0IEk9MDtJPGM7KytJKXtsZXQgTj1NYXRoLmZsb29yKEkvcyksQz1JJXMsXz0odipzK0MpKmg7Zm9yKGxldCBGPTA7RjxoOysrRil7bGV0IEQ9RitfK3AqKE4rdSooeCtsKmIpKTtmW2crK109bVtEXX19fXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKFtvLGQsYyxoXSxyLmR0eXBlLGYpfXZhciBlWT17a2VybmVsTmFtZTpwdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6UVh9O2Z1bmN0aW9uIE5fKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyLGZpbHRlcjpzfT10LHtzdHJpZGVzOmkscGFkOm8sZGlsYXRpb25zOmwsZGltUm91bmRpbmdNb2RlOnV9PWE7Z2UoW3Isc10sXCJkZXB0aHdpc2VDb252MkROYXRpdmVcIik7bGV0IHA9dy5jb21wdXRlU3RyaWRlcyhyLnNoYXBlKSxkPXcuY29tcHV0ZVN0cmlkZXMocy5zaGFwZSksYz1sO2M9PW51bGwmJihjPVsxLDFdKSx3LmFzc2VydChULmVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShpLGMpLCgpPT5gRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyAke2l9IGFuZCBkaWxhdGlvbnMgJyR7Y30nYCk7bGV0IGg9VC5jb21wdXRlQ29udjJESW5mbyhyLnNoYXBlLHMuc2hhcGUsaSxjLG8sdSwhMCkse2ZpbHRlckhlaWdodDptLGZpbHRlcldpZHRoOmYsZGlsYXRpb25IZWlnaHQ6ZyxkaWxhdGlvbldpZHRoOmIscGFkSW5mbzp5fT1oLHg9eS5sZWZ0LHY9eS50b3AsST1oLm91dENoYW5uZWxzL2guaW5DaGFubmVscyxOPW5ldyBXdChoLm91dFNoYXBlLHIuZHR5cGUpLEM9bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLF89bi5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzLEY9Ti52YWx1ZXM7Zm9yKGxldCBEPTA7RDxoLmJhdGNoU2l6ZTsrK0Qpe2xldCAkPUQqcFswXSxTPUQqTi5zdHJpZGVzWzBdO2ZvcihsZXQgTT0wO008aC5vdXRIZWlnaHQ7KytNKXtsZXQgQj1TK00qTi5zdHJpZGVzWzFdLFU9TSpoLnN0cmlkZUhlaWdodC12O2ZvcihsZXQgSD0wO0g8bTsrK0gpe2xldCBxPVUrSCpnO2lmKHE8MHx8cT49aC5pbkhlaWdodCljb250aW51ZTtsZXQgSz1IKmRbMF0sWj0kK3EqcFsxXTtmb3IobGV0IEo9MDtKPGgub3V0V2lkdGg7KytKKXtsZXQgZWU9QitKKk4uc3RyaWRlc1syXSxhZT1KKmguc3RyaWRlV2lkdGgteDtmb3IobGV0IHRlPTA7dGU8ZjsrK3RlKXtsZXQgc2U9YWUrdGUqYjtpZihzZTwwfHxzZT49aC5pbldpZHRoKWNvbnRpbnVlO2xldCBpZT1LK3RlKmRbMV0sdmU9WitzZSpoLmluQ2hhbm5lbHMsdWU9ZWUseWU9aWU7Zm9yKGxldCBrZT0wO2tlPGguaW5DaGFubmVsczsrK2tlKXtsZXQgU2U9Q1t2ZStrZV07Zm9yKGxldCBMZT0wO0xlPEk7KytMZSlGW3VlK0xlXSs9U2UqX1t5ZStMZV07dWUrPUkseWUrPUl9fX19fX1yZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhOLnNoYXBlLE4uZHR5cGUsTi52YWx1ZXMpfXZhciB0WT17a2VybmVsTmFtZTpVaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Tl99O2Z1bmN0aW9uIG5ZKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyLGR5OnN9PXQse3N0cmlkZXM6aSxkaWxhdGlvbnM6byxwYWQ6bCxkaW1Sb3VuZGluZ01vZGU6dSxmaWx0ZXJTaGFwZTpwfT1hO2dlKFtyLHNdLFwiZGVwdGh3aXNlQ29udjJkTmF0aXZlQmFja3Byb3BGaWx0ZXJcIik7bGV0IGQ9VC5jb21wdXRlQ29udjJESW5mbyhyLnNoYXBlLHAsaSxvLGwsdSwhMCkse3N0cmlkZUhlaWdodDpjLHN0cmlkZVdpZHRoOmgsZmlsdGVySGVpZ2h0Om0sZmlsdGVyV2lkdGg6Zn09ZCxnPW5ldyBXdChkLmZpbHRlclNoYXBlLFwiZmxvYXQzMlwiKSxiPWQucGFkSW5mby5sZWZ0LHk9ZC5wYWRJbmZvLnRvcCx4PWQub3V0Q2hhbm5lbHMvZC5pbkNoYW5uZWxzLHY9bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLEk9bmV3IFd0KHIuc2hhcGUsci5kdHlwZSx2KSxOPW4uZGF0YS5nZXQocy5kYXRhSWQpLnZhbHVlcyxDPW5ldyBXdChzLnNoYXBlLHMuZHR5cGUsTik7Zm9yKGxldCBfPTA7XzxtOysrXyl7bGV0IEY9TWF0aC5tYXgoMCxNYXRoLmNlaWwoKHktXykvYykpLEQ9TWF0aC5taW4oZC5vdXRIZWlnaHQsKGQuaW5IZWlnaHQreS1fKS9jKTtmb3IobGV0ICQ9MDskPGY7KyskKXtsZXQgUz1NYXRoLm1heCgwLE1hdGguY2VpbCgoYi0kKS9oKSksTT1NYXRoLm1pbihkLm91dFdpZHRoLChkLmluV2lkdGgrYi0kKS9oKTtmb3IobGV0IEI9MDtCPGQub3V0Q2hhbm5lbHM7KytCKXtsZXQgVT1NYXRoLnRydW5jKEIveCksSD1CJXgscT0wO2ZvcihsZXQgSz0wO0s8ZC5iYXRjaFNpemU7KytLKWZvcihsZXQgWj1GO1o8RDsrK1ope2xldCBKPV8rWipjLXk7Zm9yKGxldCBlZT1TO2VlPE07KytlZSl7bGV0IGFlPSQrZWUqaC1iO3ErPUkuZ2V0KEssSixhZSxVKSpDLmdldChLLFosZWUsQil9fWcuc2V0KHEsXywkLFUsSCl9fX1yZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhnLnNoYXBlLGcuZHR5cGUsZy52YWx1ZXMpfXZhciBhWT17a2VybmVsTmFtZTpJbSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6bll9O2Z1bmN0aW9uIHJZKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7ZHk6cixmaWx0ZXI6c309dCx7c3RyaWRlczppLGRpbGF0aW9uczpvLHBhZDpsLGRpbVJvdW5kaW5nTW9kZTp1LGlucHV0U2hhcGU6cH09YTtnZShbcixzXSxcImRlcHRod2lzZUNvbnYyRE5hdGl2ZUJhY2twcm9wSW5wdXRcIik7bGV0IGQ9dy5jb21wdXRlU3RyaWRlcyhyLnNoYXBlKSxjPXcuY29tcHV0ZVN0cmlkZXMocy5zaGFwZSksaD1ULmNvbXB1dGVDb252MkRJbmZvKHAscy5zaGFwZSxpLG8sbCx1LCEwKSxtPW5ldyBXdChoLmluU2hhcGUsXCJmbG9hdDMyXCIpLGY9bS52YWx1ZXMsW2csYix5XT1tLnN0cmlkZXMseD1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsW3YsSSxOXT1kLEM9bi5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzLFtfLEYsRF09Yyx7YmF0Y2hTaXplOiQsZmlsdGVySGVpZ2h0OlMsZmlsdGVyV2lkdGg6TSxpbkNoYW5uZWxzOkIsaW5IZWlnaHQ6VSxpbldpZHRoOkgsb3V0Q2hhbm5lbHM6cSxvdXRIZWlnaHQ6SyxvdXRXaWR0aDpaLHN0cmlkZUhlaWdodDpKLHN0cmlkZVdpZHRoOmVlfT1oLGFlPVMtMS1oLnBhZEluZm8udG9wLHRlPU0tMS1oLnBhZEluZm8ubGVmdCxzZT1xL0I7Zm9yKGxldCBpZT0wO2llPCQ7KytpZSlmb3IobGV0IHZlPTA7dmU8QjsrK3ZlKWZvcihsZXQgdWU9MDt1ZTxVOysrdWUpe2xldCB5ZT11ZS1hZSxrZT1NYXRoLm1heCgwLE1hdGguY2VpbCh5ZS9KKSksU2U9TWF0aC5taW4oSywoUyt5ZSkvSik7Zm9yKGxldCBMZT0wO0xlPEg7KytMZSl7bGV0IFVlPUxlLXRlLG10PU1hdGgubWF4KDAsTWF0aC5jZWlsKFVlL2VlKSksc3Q9TWF0aC5taW4oWiwoTStVZSkvZWUpLHR0PTA7Zm9yKGxldCBudD1rZTtudDxTZTsrK250KXtsZXQgUmU9bnQqSi15ZTtmb3IobGV0IGd0PW10O2d0PHN0OysrZ3Qpe2xldCBHbj1ndCplZS1VZSxPdD12KmllK0kqbnQrTipndCxpYT1fKihTLTEtUmUpK0YqKE0tMS1HbikrRCp2ZTtmb3IobGV0IHVuPTA7dW48c2U7Kyt1bil7bGV0IEZuPXZlKnNlK3VuLG9hPXhbT3QrRm5dLCRuPUNbaWErdW5dO3R0Kz1vYSokbn19fWZbZyppZStiKnVlK3kqTGUrdmVdPXR0fX1yZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhtLnNoYXBlLG0uZHR5cGUsbS52YWx1ZXMpfXZhciBzWT17a2VybmVsTmFtZTpTbSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6cll9O2Z1bmN0aW9uIGlZKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse3g6YX09dCxyPXcuc2l6ZUZyb21TaGFwZShhLnNoYXBlKSxzPW4uZGF0YS5nZXQoYS5kYXRhSWQpLnZhbHVlcyxpPU9lKFtyLHJdLGEuZHR5cGUpLG89aS52YWx1ZXM7Zm9yKGxldCB1PTA7dTxzLmxlbmd0aDt1Kyspb1t1KnIrdV09c1t1XTtsZXQgbD1bLi4uYS5zaGFwZSwuLi5hLnNoYXBlXTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhsLGkuZHR5cGUsaS52YWx1ZXMpfXZhciBvWT17a2VybmVsTmFtZTpMYyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6aVl9LGxZPXtrZXJuZWxOYW1lOkdpLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzooe2lucHV0czplLGJhY2tlbmQ6dCxhdHRyczpufSk9PntsZXR7eDphLGZpbHRlcjpyfT1lLHtzdHJpZGVzOnMscGFkOmksZGlsYXRpb25zOm99PW4sbD10LHU9bC5kYXRhLmdldChhLmRhdGFJZCkudmFsdWVzLHA9YS5zaGFwZS5sZW5ndGgsZD1sLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsYz1yLnNoYXBlLmxlbmd0aCx7YmF0Y2hTaXplOmgsaW5IZWlnaHQ6bSxpbldpZHRoOmYsaW5DaGFubmVsczpnLG91dEhlaWdodDpiLG91dFdpZHRoOnkscGFkSW5mbzp4LHN0cmlkZUhlaWdodDp2LHN0cmlkZVdpZHRoOkksZmlsdGVySGVpZ2h0Ok4sZmlsdGVyV2lkdGg6QyxkaWxhdGlvbkhlaWdodDpfLGRpbGF0aW9uV2lkdGg6RixvdXRTaGFwZTpEfT1ULmNvbXB1dGVEaWxhdGlvbjJESW5mbyhhLnNoYXBlLHIuc2hhcGUscyxpLFwiTkhXQ1wiLG8pLCQ9dy5zaXplRnJvbVNoYXBlKEQpLFM9RC5sZW5ndGgsTT13LmdldEFycmF5RnJvbURUeXBlKGEuZHR5cGUsJCk7Zm9yKGxldCBCPTA7QjxoOysrQilmb3IobGV0IFU9MDtVPGI7KytVKXtsZXQgSD1VKnYteC50b3A7Zm9yKGxldCBxPTA7cTx5OysrcSl7bGV0IEs9cSpJLXgubGVmdDtmb3IobGV0IFo9MDtaPGc7KytaKXtsZXQgSj1OdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtmb3IobGV0IGFlPTA7YWU8TjsrK2FlKXtsZXQgdGU9SCthZSpfO2lmKHRlPj0wJiZ0ZTxtKWZvcihsZXQgc2U9MDtzZTxDOysrc2Upe2xldCBpZT1LK3NlKkY7aWYoaWU+PTAmJmllPGYpe2xldCB2ZT13LmxvY1RvSW5kZXgoW0IsdGUsaWUsWl0scCx3LmNvbXB1dGVTdHJpZGVzKGEuc2hhcGUpKSx1ZT13LmxvY1RvSW5kZXgoW2FlLHNlLFpdLGMsdy5jb21wdXRlU3RyaWRlcyhyLnNoYXBlKSkseWU9dVt2ZV0rZFt1ZV07eWU+SiYmKEo9eWUpfX19bGV0IGVlPXcubG9jVG9JbmRleChbQixVLHEsWl0sUyx3LmNvbXB1dGVTdHJpZGVzKEQpKTtNW2VlXT1KfX19cmV0dXJue2RhdGFJZDpsLndyaXRlKHcudG9UeXBlZEFycmF5KE0sYS5kdHlwZSksRCxhLmR0eXBlKSxzaGFwZTpELGR0eXBlOmEuZHR5cGV9fX0sdVk9e2tlcm5lbE5hbWU6UmwsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOih7aW5wdXRzOmUsYmFja2VuZDp0LGF0dHJzOm59KT0+e2xldHt4OmEsZmlsdGVyOnIsZHk6c309ZSx7c3RyaWRlczppLHBhZDpvLGRpbGF0aW9uczpsfT1uLHU9dCxwPXcudG9OZXN0ZWRBcnJheShhLnNoYXBlLHUuZGF0YS5nZXQoYS5kYXRhSWQpLnZhbHVlcyksZD13LnRvTmVzdGVkQXJyYXkoci5zaGFwZSx1LmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMpLHtiYXRjaFNpemU6YyxpbkhlaWdodDpoLGluV2lkdGg6bSxpbkNoYW5uZWxzOmYsb3V0SGVpZ2h0Omcsb3V0V2lkdGg6YixwYWRJbmZvOnksc3RyaWRlSGVpZ2h0Ongsc3RyaWRlV2lkdGg6dixmaWx0ZXJIZWlnaHQ6SSxmaWx0ZXJXaWR0aDpOLGRpbGF0aW9uSGVpZ2h0OkMsZGlsYXRpb25XaWR0aDpfLG91dFNoYXBlOkZ9PVQuY29tcHV0ZURpbGF0aW9uMkRJbmZvKGEuc2hhcGUsci5zaGFwZSxpLG8sXCJOSFdDXCIsbCk7dy5hc3NlcnQocy5yYW5rPT09Ri5sZW5ndGgsKCk9PmBFcnJvciBpbiAke1JsfSwgZHkgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsgYXMgb3V0cHV0ICR7Ri5sZW5ndGh9LCBidXQgZ290ICR7cy5yYW5rfWApO2xldCBEPXcudG9OZXN0ZWRBcnJheShGLHUuZGF0YS5nZXQocy5kYXRhSWQpLnZhbHVlcyksJD13Lm1ha2VaZXJvc05lc3RlZFR5cGVkQXJyYXkoci5zaGFwZSxyLmR0eXBlKTtmb3IobGV0IFM9MDtTPGM7KytTKWZvcihsZXQgTT0wO008ZzsrK00pe2xldCBCPU0qeC15LnRvcDtmb3IobGV0IFU9MDtVPGI7KytVKXtsZXQgSD1VKnYteS5sZWZ0O2ZvcihsZXQgcT0wO3E8ZjsrK3Epe2xldCBLPU51bWJlci5NSU5fU0FGRV9JTlRFR0VSLFo9MCxKPTA7Zm9yKGxldCBlZT0wO2VlPEk7KytlZSl7bGV0IGFlPUIrZWUqQztpZihhZT49MCYmYWU8aClmb3IobGV0IHRlPTA7dGU8TjsrK3RlKXtsZXQgc2U9SCt0ZSpfO2lmKHNlPj0wJiZzZTxtKXtsZXQgaWU9cFtTXVthZV1bc2VdW3FdK2RbZWVdW3RlXVtxXTtpZT5LJiYoSz1pZSxaPWVlLEo9dGUpfX19JFtaXVtKXVtxXSs9RFtTXVtNXVtVXVtxXX19fXJldHVybntkYXRhSWQ6dS53cml0ZSh3LnRvVHlwZWRBcnJheSgkLGEuZHR5cGUpLHIuc2hhcGUsci5kdHlwZSksc2hhcGU6ci5zaGFwZSxkdHlwZTpyLmR0eXBlfX19LHBZPXtrZXJuZWxOYW1lOkRsLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzooe2lucHV0czplLGJhY2tlbmQ6dCxhdHRyczpufSk9PntsZXR7eDphLGZpbHRlcjpyLGR5OnN9PWUse3N0cmlkZXM6aSxwYWQ6byxkaWxhdGlvbnM6bH09bix1PXQscD13LnRvTmVzdGVkQXJyYXkoYS5zaGFwZSx1LmRhdGEuZ2V0KGEuZGF0YUlkKS52YWx1ZXMpLGQ9dy50b05lc3RlZEFycmF5KHIuc2hhcGUsdS5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzKSx7YmF0Y2hTaXplOmMsaW5IZWlnaHQ6aCxpbldpZHRoOm0saW5DaGFubmVsczpmLG91dEhlaWdodDpnLG91dFdpZHRoOmIscGFkSW5mbzp5LHN0cmlkZUhlaWdodDp4LHN0cmlkZVdpZHRoOnYsZmlsdGVySGVpZ2h0OkksZmlsdGVyV2lkdGg6TixkaWxhdGlvbkhlaWdodDpDLGRpbGF0aW9uV2lkdGg6XyxvdXRTaGFwZTpGfT1ULmNvbXB1dGVEaWxhdGlvbjJESW5mbyhhLnNoYXBlLHIuc2hhcGUsaSxvLFwiTkhXQ1wiLGwpO3cuYXNzZXJ0KHMucmFuaz09PUYubGVuZ3RoLCgpPT5gRXJyb3IgaW4gJHtEbH0sIGR5IG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rIGFzIG91dHB1dCAke0YubGVuZ3RofSwgYnV0IGdvdCAke3MucmFua31gKTtsZXQgRD13LnRvTmVzdGVkQXJyYXkoRix1LmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMpLCQ9dy5tYWtlWmVyb3NOZXN0ZWRUeXBlZEFycmF5KGEuc2hhcGUsYS5kdHlwZSk7Zm9yKGxldCBTPTA7UzxjOysrUylmb3IobGV0IE09MDtNPGc7KytNKXtsZXQgQj1NKngteS50b3A7Zm9yKGxldCBVPTA7VTxiOysrVSl7bGV0IEg9VSp2LXkubGVmdDtmb3IobGV0IHE9MDtxPGY7KytxKXtsZXQgSz1OdW1iZXIuTUlOX1NBRkVfSU5URUdFUixaPUI8MD8wOkIsSj1IPDA/MDpIO2ZvcihsZXQgZWU9MDtlZTxJOysrZWUpe2xldCBhZT1CK2VlKkM7aWYoYWU+PTAmJmFlPGgpZm9yKGxldCB0ZT0wO3RlPE47Kyt0ZSl7bGV0IHNlPUgrdGUqXztpZihzZT49MCYmc2U8bSl7bGV0IGllPXBbU11bYWVdW3NlXVtxXStkW2VlXVt0ZV1bcV07aWU+SyYmKEs9aWUsWj1hZSxKPXNlKX19fSRbU11bWl1bSl1bcV0rPURbU11bTV1bVV1bcV19fX1yZXR1cm57ZGF0YUlkOnUud3JpdGUody50b1R5cGVkQXJyYXkoJCxhLmR0eXBlKSxhLnNoYXBlLGEuZHR5cGUpLHNoYXBlOmEuc2hhcGUsZHR5cGU6YS5kdHlwZX19fTtmdW5jdGlvbiBjWShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2ltYWdlOnJ9PXQse2NhbnZhczpzLG9wdGlvbnM6aX09YSx7Y29udGV4dE9wdGlvbnM6byxpbWFnZU9wdGlvbnM6bH09aXx8e30sdT0obD09bnVsbD92b2lkIDA6bC5hbHBoYSl8fDEscD0obz09bnVsbD92b2lkIDA6by5jb250ZXh0VHlwZSl8fFwiMmRcIjtpZihwIT09XCIyZFwiKXRocm93IG5ldyBFcnJvcihgQ29udGV4dCB0eXBlICR7by5jb250ZXh0VHlwZX0gaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgQ1BVIGJhY2tlbmQuYCk7bGV0IGQ9cy5nZXRDb250ZXh0KHAsKG89PW51bGw/dm9pZCAwOm8uY29udGV4dEF0dHJpYnV0ZXMpfHx7fSk7aWYoZD09bnVsbCl0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBnZXQgdGhlIGNvbnRleHQgd2l0aCAke3B9IHR5cGUuYCk7bGV0W2MsaF09ci5zaGFwZS5zbGljZSgwLDIpLG09ci5zaGFwZS5sZW5ndGg9PT0yPzE6ci5zaGFwZVsyXSxmPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxnPXIuZHR5cGU9PT1cImZsb2F0MzJcIj8yNTU6MSxiPW5ldyBVaW50OENsYW1wZWRBcnJheShoKmMqNCk7Zm9yKGxldCB4PTA7eDxjKmg7Kyt4KXtsZXQgdj1bMCwwLDAsMjU1KnVdO2ZvcihsZXQgTj0wO048bTtOKyspe2xldCBDPWZbeCptK05dO2lmKHIuZHR5cGU9PT1cImZsb2F0MzJcIil7aWYoQzwwfHxDPjEpdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IgdmFsdWVzIGZvciBhIGZsb2F0MzIgVGVuc29yIG11c3QgYmUgaW4gdGhlIHJhbmdlIFswIC0gMV0gYnV0IGVuY291bnRlcmVkICR7Q30uYCl9ZWxzZSBpZihyLmR0eXBlPT09XCJpbnQzMlwiJiYoQzwwfHxDPjI1NSkpdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IgdmFsdWVzIGZvciBhIGludDMyIFRlbnNvciBtdXN0IGJlIGluIHRoZSByYW5nZSBbMCAtIDI1NV0gYnV0IGVuY291bnRlcmVkICR7Q30uYCk7bT09PTE/KHZbMF09QypnLHZbMV09QypnLHZbMl09QypnKTp2W05dPUMqZ31sZXQgST14KjQ7YltJKzBdPU1hdGgucm91bmQodlswXSksYltJKzFdPU1hdGgucm91bmQodlsxXSksYltJKzJdPU1hdGgucm91bmQodlsyXSksYltJKzNdPU1hdGgucm91bmQodlszXSl9cy53aWR0aD1oLHMuaGVpZ2h0PWM7bGV0IHk9bmV3IEltYWdlRGF0YShiLGgsYyk7cmV0dXJuIGQucHV0SW1hZ2VEYXRhKHksMCwwKSxyfXZhciBkWT17a2VybmVsTmFtZTpObSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Y1l9O2Z1bmN0aW9uIEVkKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtheGlzOnMsa2VlcERpbXM6aX09YTtnZShyLFwic3VtXCIpO2xldCBvO3IuZHR5cGU9PT1cImJvb2xcIj9vPWJzKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntkdHlwZTpcImludDMyXCJ9fSk6bz1jcih7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bn0pO2xldCBsPW8uc2hhcGUubGVuZ3RoLHU9dy5wYXJzZUF4aXNQYXJhbShzLG8uc2hhcGUpLHA9VC5nZXRBeGVzUGVybXV0YXRpb24odSxsKSxkPXUsYz1vO3AhPW51bGwmJihjPVZuKHtpbnB1dHM6e3g6b30sYmFja2VuZDpuLGF0dHJzOntwZXJtOnB9fSksZD1ULmdldElubmVyTW9zdEF4ZXMoZC5sZW5ndGgsbCkpLFQuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJzdW1cIixkLGMuc2hhcGUubGVuZ3RoKTtsZXRbaCxtXT1ULmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoYy5zaGFwZSxkKSxmPVQudXBjYXN0VHlwZShjLmR0eXBlLFwiaW50MzJcIiksZz1sbShuLGgsZiksYj13LnNpemVGcm9tU2hhcGUobSkseT1uLmRhdGEuZ2V0KGcuZGF0YUlkKS52YWx1ZXMseD1uLmRhdGEuZ2V0KGMuZGF0YUlkKS52YWx1ZXM7Zm9yKGxldCB2PTA7djx5Lmxlbmd0aDsrK3Ype2xldCBJPXYqYixOPTA7Zm9yKGxldCBDPTA7QzxiOysrQylOKz14W0krQ107eVt2XT1OfWlmKGkpe2xldCB2PVQuZXhwYW5kU2hhcGVUb0tlZXBEaW0oZy5zaGFwZSx1KSxJPWc7Zz14dCh7aW5wdXRzOnt4Omd9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6dn19KSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKEkpfXJldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG8pLHAhPW51bGwmJm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oYyksZ312YXIgaFk9e2tlcm5lbE5hbWU6TG8sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOkVkfTtmdW5jdGlvbiBtWShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2VxdWF0aW9uOnJ9PWEscz10LHthbGxEaW1zOmksc3VtbWVkRGltczpvLGlkRGltczpsfT1ULmRlY29kZUVpbnN1bUVxdWF0aW9uKHIscy5sZW5ndGgpO1QuY2hlY2tFaW5zdW1EaW1TaXplcyhpLmxlbmd0aCxsLHMpO2xldHtwYXRoOnUsc3RlcHM6cH09VC5nZXRFaW5zdW1Db21wdXRlUGF0aChvLGwpLGQ9cC5sZW5ndGgsYz1udWxsLGg9aS5sZW5ndGgsbT1bXTtmb3IobGV0IGY9MDtmPGQ7KytmKXtmb3IobGV0IGcgb2YgcFtmXSl7bGV0e3Blcm11dGF0aW9uSW5kaWNlczpiLGV4cGFuZERpbXM6eX09VC5nZXRFaW5zdW1QZXJtdXRhdGlvbihoLGxbZ10pLHg7VC5pc0lkZW50aXR5UGVybXV0YXRpb24oYik/eD1zW2ddOih4PVZuKHtpbnB1dHM6e3g6c1tnXX0sYmFja2VuZDpuLGF0dHJzOntwZXJtOmJ9fSksbS5wdXNoKHgpKTtsZXQgdj14LnNoYXBlLnNsaWNlKCk7Zm9yKGxldCBJPTA7STx5Lmxlbmd0aDsrK0kpdi5zcGxpY2UoeVtJXSwwLDEpO3cuYXJyYXlzRXF1YWwoeC5zaGFwZSx2KXx8KHg9eHQoe2lucHV0czp7eH0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTp2fX0pLG0ucHVzaCh4KSksYz09PW51bGw/Yz14OihjPXpmKHtpbnB1dHM6e2E6eCxiOmN9LGJhY2tlbmQ6bn0pLG0ucHVzaChjKSl9ZjxkLTEmJih1W2ZdPj0wJiYoYz1FZCh7aW5wdXRzOnt4OmN9LGJhY2tlbmQ6bixhdHRyczp7YXhpczp1W2ZdLShpLmxlbmd0aC1oKSxrZWVwRGltczohMX19KSxtLnB1c2goYykpLGgtLSl9Zm9yKGxldCBmIG9mIG0pZiE9PWMmJm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZik7cmV0dXJuIGN9dmFyIGZZPXtrZXJuZWxOYW1lOlRtLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzptWX07ZnVuY3Rpb24gZ1koZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7ZHk6YSx5OnJ9PXQ7Z2UoW2Escl0sXCJlbHVHcmFkXCIpO2xldCBzPW5ldyBGbG9hdDMyQXJyYXkody5zaXplRnJvbVNoYXBlKHIuc2hhcGUpKSxpPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxvPW4uZGF0YS5nZXQoYS5kYXRhSWQpLnZhbHVlcztmb3IobGV0IGw9MDtsPGkubGVuZ3RoOysrbCl7bGV0IHU9aVtsXTt1Pj0wP3NbbF09b1tsXTpzW2xdPW9bbF0qKHUrMSl9cmV0dXJuIG4ubWFrZVRlbnNvckluZm8oci5zaGFwZSxcImZsb2F0MzJcIixzKX12YXIgYlk9e2tlcm5lbE5hbWU6Y3UsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmdZfSx5WT1ULkVSRl9QLHhZPVQuRVJGX0ExLHZZPVQuRVJGX0EyLHdZPVQuRVJGX0EzLGtZPVQuRVJGX0E0LElZPVQuRVJGX0E1LFNZPWx0KHFpLGU9PntsZXQgdD1NYXRoLnNpZ24oZSksbj1NYXRoLmFicyhlKSxhPTEvKDEreVkqbik7cmV0dXJuIHQqKDEtKCgoKElZKmEra1kpKmErd1kpKmErdlkpKmEreFkpKmEqTWF0aC5leHAoLW4qbikpfSksTlk9e2tlcm5lbE5hbWU6cWksYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOlNZfTtmdW5jdGlvbiBjbShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2lucHV0OnJ9PXQse2RpbTpzfT1hLGk9ci5zaGFwZS5sZW5ndGgsbz1yLnNoYXBlLnNsaWNlKCksbD1zO3JldHVybiBzPDAmJih3LmFzc2VydCgtKGkrMSk8PXMsKCk9PmBBeGlzIG11c3QgYmUgaW4gdGhlIGludGVydmFsIFskey0oaSsxKX0sICR7aX1dYCksbD1pK3MrMSksby5zcGxpY2UobCwwLDEpLHh0KHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpvfX0pfXZhciBUWT17a2VybmVsTmFtZTpodSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Y219LENZPU10KChlLHQpPT5lL3QpLFgxPVp0KEhpLENZKSxsdj17a2VybmVsTmFtZTpIaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6WDF9O2Z1bmN0aW9uIFRfKGUsdCxuKXtsZXQgYT1lLnNoYXBlLHI9YVswXSxzPWFbMV0saT1uLmRhdGEuZ2V0KGUuZGF0YUlkKSxvPWkuY29tcGxleFRlbnNvckluZm9zLnJlYWwsbD1pLmNvbXBsZXhUZW5zb3JJbmZvcy5pbWFnLHU9W3Isc10scD13LnNpemVGcm9tU2hhcGUodSksZD13LmdldFR5cGVkQXJyYXlGcm9tRFR5cGUoXCJmbG9hdDMyXCIscCksYz13LmdldFR5cGVkQXJyYXlGcm9tRFR5cGUoXCJmbG9hdDMyXCIscCk7Zm9yKGxldCBnPTA7ZzxyO2crKyl7bGV0IGI9eGkoe2lucHV0czp7eDpvfSxiYWNrZW5kOm4sYXR0cnM6e2JlZ2luOltnLDBdLHNpemU6WzEsc119fSkseT14aSh7aW5wdXRzOnt4Omx9LGJhY2tlbmQ6bixhdHRyczp7YmVnaW46W2csMF0sc2l6ZTpbMSxzXX19KSx4PVluKHtpbnB1dHM6e3JlYWw6YixpbWFnOnl9LGJhY2tlbmQ6bn0pLHtyZWFsOnYsaW1hZzpJfT1FWSh4LHQsbiksTj1ULm1lcmdlUmVhbEFuZEltYWdBcnJheXModixJKTtmb3IobGV0IEM9MDtDPHM7QysrKXtsZXQgXz1ULmdldENvbXBsZXhXaXRoSW5kZXgoTixDKTtkW2cqcytDXT1fLnJlYWwsY1tnKnMrQ109Xy5pbWFnfW4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oYiksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh5KSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHgpfWxldCBoPW4ubWFrZVRlbnNvckluZm8odSxcImZsb2F0MzJcIixkKSxtPW4ubWFrZVRlbnNvckluZm8odSxcImZsb2F0MzJcIixjKSxmPVluKHtpbnB1dHM6e3JlYWw6aCxpbWFnOm19LGJhY2tlbmQ6bn0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGgpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obSksZn1mdW5jdGlvbiBFWShlLHQsbil7bGV0IGE9dy5zaXplRnJvbVNoYXBlKGUuc2hhcGUpLHI9bi5kYXRhLmdldChlLmRhdGFJZCkscz1uLmRhdGEuZ2V0KHIuY29tcGxleFRlbnNvckluZm9zLnJlYWwuZGF0YUlkKS52YWx1ZXMsaT1uLmRhdGEuZ2V0KHIuY29tcGxleFRlbnNvckluZm9zLmltYWcuZGF0YUlkKS52YWx1ZXM7aWYoX1koYSkpe2xldCBvPXV2KHMsaSxhLHQsbiksbD1bZS5zaGFwZVswXSxlLnNoYXBlWzFdXTtpZih0KXtsZXQgdT1uLm1ha2VUZW5zb3JJbmZvKGwsXCJmbG9hdDMyXCIsby5yZWFsKSxwPW4ubWFrZVRlbnNvckluZm8obCxcImZsb2F0MzJcIixvLmltYWcpLGQ9bi5tYWtlVGVuc29ySW5mbyhbXSxcImZsb2F0MzJcIix3LmNyZWF0ZVNjYWxhclZhbHVlKGEsXCJmbG9hdDMyXCIpKSxjPWNyKHtpbnB1dHM6e3g6ZH0sYmFja2VuZDpufSksaD1sdi5rZXJuZWxGdW5jKHtpbnB1dHM6e2E6dSxiOmR9LGJhY2tlbmQ6bn0pLG09bHYua2VybmVsRnVuYyh7aW5wdXRzOnthOnAsYjpjfSxiYWNrZW5kOm59KSxmPW4uZGF0YS5nZXQoaC5kYXRhSWQpLnZhbHVlcyxnPW4uZGF0YS5nZXQobS5kYXRhSWQpLnZhbHVlcztyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh1KSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHApLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZCksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhjKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGgpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obSkse3JlYWw6ZixpbWFnOmd9fXJldHVybiBvfWVsc2V7bGV0IG89VC5tZXJnZVJlYWxBbmRJbWFnQXJyYXlzKHMsaSksbD1BWShvLGEsdCk7cmV0dXJuIFQuc3BsaXRSZWFsQW5kSW1hZ0FycmF5cyhsKX19ZnVuY3Rpb24gX1koZSl7cmV0dXJuKGUmZS0xKT09PTB9ZnVuY3Rpb24gdXYoZSx0LG4sYSxyKXtpZihuPT09MSlyZXR1cm57cmVhbDplLGltYWc6dH07bGV0IHM9VC5tZXJnZVJlYWxBbmRJbWFnQXJyYXlzKGUsdCksaT1uLzIsbz1ULmNvbXBsZXhXaXRoRXZlbkluZGV4KHMpLGw9by5yZWFsLHU9by5pbWFnLHA9W2wubGVuZ3RoXSxkPXIubWFrZVRlbnNvckluZm8ocCxcImZsb2F0MzJcIixsKSxjPXIubWFrZVRlbnNvckluZm8ocCxcImZsb2F0MzJcIix1KSxoPVluKHtpbnB1dHM6e3JlYWw6ZCxpbWFnOmN9LGJhY2tlbmQ6cn0pLG09VC5jb21wbGV4V2l0aE9kZEluZGV4KHMpLGY9bS5yZWFsLGc9bS5pbWFnLGI9W2YubGVuZ3RoXSx5PXIubWFrZVRlbnNvckluZm8oYixcImZsb2F0MzJcIixmKSx4PXIubWFrZVRlbnNvckluZm8oYixcImZsb2F0MzJcIixnKSx2PVluKHtpbnB1dHM6e3JlYWw6eSxpbWFnOnh9LGJhY2tlbmQ6cn0pLEk9dXYobCx1LGksYSxyKSxOPUkucmVhbCxDPUkuaW1hZyxfPVtOLmxlbmd0aF0sRj1yLm1ha2VUZW5zb3JJbmZvKF8sXCJmbG9hdDMyXCIsTiksRD1yLm1ha2VUZW5zb3JJbmZvKF8sXCJmbG9hdDMyXCIsQyksJD1Zbih7aW5wdXRzOntyZWFsOkYsaW1hZzpEfSxiYWNrZW5kOnJ9KSxTPXV2KGYsZyxpLGEsciksTT1TLnJlYWwsQj1TLmltYWcsVT1bTS5sZW5ndGhdLEg9ci5tYWtlVGVuc29ySW5mbyhVLFwiZmxvYXQzMlwiLE0pLHE9ci5tYWtlVGVuc29ySW5mbyhVLFwiZmxvYXQzMlwiLEIpLEs9WW4oe2lucHV0czp7cmVhbDpILGltYWc6cX0sYmFja2VuZDpyfSksWj1ULmV4cG9uZW50cyhuLGEpLEo9W1oucmVhbC5sZW5ndGhdLGVlPXIubWFrZVRlbnNvckluZm8oSixcImZsb2F0MzJcIixaLnJlYWwpLGFlPXIubWFrZVRlbnNvckluZm8oSixcImZsb2F0MzJcIixaLmltYWcpLHRlPVluKHtpbnB1dHM6e3JlYWw6ZWUsaW1hZzphZX0sYmFja2VuZDpyfSksc2U9emYoe2lucHV0czp7YTp0ZSxiOkt9LGJhY2tlbmQ6cn0pLGllPWpsKHtpbnB1dHM6e2E6JCxiOnNlfSxiYWNrZW5kOnJ9KSx2ZT1qMSh7aW5wdXRzOnthOiQsYjpzZX0sYmFja2VuZDpyfSksdWU9eWkoe2lucHV0czp7aW5wdXQ6aWV9LGJhY2tlbmQ6cn0pLHllPXlpKHtpbnB1dHM6e2lucHV0OnZlfSxiYWNrZW5kOnJ9KSxrZT1xbCh7aW5wdXRzOntpbnB1dDppZX0sYmFja2VuZDpyfSksU2U9cWwoe2lucHV0czp7aW5wdXQ6dmV9LGJhY2tlbmQ6cn0pLExlPUtsKHtpbnB1dHM6W3VlLHllXSxiYWNrZW5kOnIsYXR0cnM6e2F4aXM6MH19KSxVZT1LbCh7aW5wdXRzOltrZSxTZV0sYmFja2VuZDpyLGF0dHJzOntheGlzOjB9fSksbXQ9ci5kYXRhLmdldChMZS5kYXRhSWQpLnZhbHVlcyxzdD1yLmRhdGEuZ2V0KFVlLmRhdGFJZCkudmFsdWVzO3JldHVybiByLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGQpLHIuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oYyksci5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhoKSxyLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHkpLHIuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oeCksci5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh2KSxyLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKEYpLHIuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oRCksci5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbygkKSxyLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKEgpLHIuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocSksci5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhLKSxyLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGVlKSxyLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGFlKSxyLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHRlKSxyLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHNlKSxyLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGllKSxyLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHZlKSxyLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHVlKSxyLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGtlKSxyLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHllKSxyLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKFNlKSxyLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKExlKSxyLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKFVlKSx7cmVhbDptdCxpbWFnOnN0fX1mdW5jdGlvbiBBWShlLHQsbil7bGV0IGE9bmV3IEZsb2F0MzJBcnJheSh0KjIpO2ZvcihsZXQgcj0wO3I8dDtyKyspe2xldCBzPTAsaT0wO2ZvcihsZXQgbz0wO288dDtvKyspe2xldCBsPVQuZXhwb25lbnQocipvLHQsbiksdT1ULmdldENvbXBsZXhXaXRoSW5kZXgoZSxvKTtzKz11LnJlYWwqbC5yZWFsLXUuaW1hZypsLmltYWcsaSs9dS5yZWFsKmwuaW1hZyt1LmltYWcqbC5yZWFsfW4mJihzLz10LGkvPXQpLFQuYXNzaWduVG9UeXBlZEFycmF5KGEscyxpLHIpfXJldHVybiBhfWZ1bmN0aW9uIEZZKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse2lucHV0OmF9PXQscj13LnNpemVGcm9tU2hhcGUoYS5zaGFwZSkscz1hLnNoYXBlW2Euc2hhcGUubGVuZ3RoLTFdLGk9ci9zLG89eHQoe2lucHV0czp7eDphfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOltpLHNdfX0pLGw9VF8obywhMSxuKSx1PXh0KHtpbnB1dHM6e3g6bH0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTphLnNoYXBlfX0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG8pLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obCksdX12YXIgJFk9e2tlcm5lbE5hbWU6Q20sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOkZZfTtmdW5jdGlvbiBZMShlKXtsZXR7YmFja2VuZDp0LGF0dHJzOm59PWUse3NoYXBlOmEsdmFsdWU6cixkdHlwZTpzfT1uLGk9c3x8dy5pbmZlckR0eXBlKHIpLG89dy5nZXRBcnJheUZyb21EVHlwZShpLHcuc2l6ZUZyb21TaGFwZShhKSk7cmV0dXJuIFJZKG8scixpKSx0Lm1ha2VUZW5zb3JJbmZvKGEsaSxvKX12YXIgRFk9e2tlcm5lbE5hbWU6emMsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOlkxfTtmdW5jdGlvbiBSWShlLHQsbil7ZS5maWxsKHQpfXZhciBNWT17a2VybmVsTmFtZTptdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6KHtpbnB1dHM6ZSxhdHRyczp0LGJhY2tlbmQ6bn0pPT57bGV0e2ltYWdlOmF9PWUscj1uLHM9dy5nZXRUeXBlZEFycmF5RnJvbURUeXBlKGEuZHR5cGUsdy5zaXplRnJvbVNoYXBlKGEuc2hhcGUpKSxbaSxvLGwsdV09YS5zaGFwZSxwPXIuZGF0YS5nZXQoYS5kYXRhSWQpLnZhbHVlcztmb3IobGV0IGQ9MDtkPGk7ZCsrKXtsZXQgYz1kKmwqbyp1O2ZvcihsZXQgaD0wO2g8bztoKyspe2xldCBtPWgqKGwqdSk7Zm9yKGxldCBmPTA7ZjxsO2YrKyl7bGV0IGc9Zip1O2ZvcihsZXQgYj0wO2I8dTtiKyspe2xldCB5PU1hdGgucm91bmQobC1mLTEpLHg9YyttK2crYix2PXBbeF07aWYoeT49MCYmeTxsKXtsZXQgST15KnUsTj1jK20rSStiO3Y9cFtOXX1zW3hdPXZ9fX19cmV0dXJue2RhdGFJZDpyLndyaXRlKHMsYS5zaGFwZSxhLmR0eXBlKSxzaGFwZTphLnNoYXBlLGR0eXBlOmEuZHR5cGV9fX07ZnVuY3Rpb24gT1koZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsZmlsdGVyOnMsYmlhczppLHByZWx1QWN0aXZhdGlvbldlaWdodHM6b309dCx7c3RyaWRlczpsLHBhZDp1LGRhdGFGb3JtYXQ6cCxkaWxhdGlvbnM6ZCxkaW1Sb3VuZGluZ01vZGU6YyxhY3RpdmF0aW9uOmgsbGVha3lyZWx1QWxwaGE6bX09YSxmPVNfKHtpbnB1dHM6e3g6cixmaWx0ZXI6c30sYmFja2VuZDpuLGF0dHJzOntzdHJpZGVzOmwscGFkOnUsZGF0YUZvcm1hdDpwLGRpbGF0aW9uczpkLGRpbVJvdW5kaW5nTW9kZTpjfX0pO2lmKGkpe2xldCBnPWY7aWYocD09PVwiTkNIV1wiJiZpLnNoYXBlLmxlbmd0aD09PTEmJmkuc2hhcGVbMF0hPT0xKXtsZXQgYj14dCh7aW5wdXRzOnt4Oml9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6W2kuc2hhcGVbMF0sMSwxXX19KTtmPWpsKHtpbnB1dHM6e2E6ZixifSxiYWNrZW5kOm59KSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGIpfWVsc2UgZj1qbCh7aW5wdXRzOnthOmYsYjppfSxiYWNrZW5kOm59KTtuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGcpfWlmKGgpe2xldCBnPWY7aWYocD09PVwiTkNIV1wiJiZoPT09XCJwcmVsdVwiJiZvLnNoYXBlLmxlbmd0aD09PTEmJm8uc2hhcGVbMF0hPT0xKXtsZXQgYj14dCh7aW5wdXRzOnt4Om99LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6W28uc2hhcGVbMF0sMSwxXX19KTtmPXBtKG4sZixoLGIsbSksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhiKX1lbHNlIGY9cG0obixmLGgsbyxtKTtuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGcpfXJldHVybiBmfXZhciBQWT17a2VybmVsTmFtZTpvaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6T1l9O2Z1bmN0aW9uIExZKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyLGZpbHRlcjpzLGJpYXM6aSxwcmVsdUFjdGl2YXRpb25XZWlnaHRzOm99PXQse3N0cmlkZXM6bCxwYWQ6dSxkYXRhRm9ybWF0OnAsZGlsYXRpb25zOmQsZGltUm91bmRpbmdNb2RlOmMsYWN0aXZhdGlvbjpoLGxlYWt5cmVsdUFscGhhOm19PWEsZj1OXyh7aW5wdXRzOnt4OnIsZmlsdGVyOnN9LGJhY2tlbmQ6bixhdHRyczp7c3RyaWRlczpsLHBhZDp1LGRhdGFGb3JtYXQ6cCxkaWxhdGlvbnM6ZCxkaW1Sb3VuZGluZ01vZGU6Y319KTtpZihpKXtsZXQgZz1mO2Y9amwoe2lucHV0czp7YTpmLGI6aX0sYmFja2VuZDpufSksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhnKX1pZihoKXtsZXQgZz1mO2Y9cG0obixmLGgsbyxtKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGcpfXJldHVybiBmfXZhciB6WT17a2VybmVsTmFtZTpsaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6TFl9O2Z1bmN0aW9uIFdZKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse3BhcmFtczphLGluZGljZXM6cn09dCxzPXcuc2l6ZUZyb21TaGFwZShhLnNoYXBlKSxpPXIuc2hhcGUsbz1pW2kubGVuZ3RoLTFdLFtsLHUscCxkXT1ULnByZXBhcmVBbmRWYWxpZGF0ZShhLHIpO2lmKHU9PT0wKXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKGwsYS5kdHlwZSxbXSk7bGV0IGM9bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLGg9bi5idWZmZXJTeW5jKGEpLG09VkUoYyxoLGEuZHR5cGUsdSxvLHAsZCxhLnNoYXBlLHMpO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKGwsYS5kdHlwZSxtLnZhbHVlcyl9dmFyIEJZPXtrZXJuZWxOYW1lOmd1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpXWX07ZnVuY3Rpb24gVlkoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsaW5kaWNlczpzfT10LHtheGlzOmksYmF0Y2hEaW1zOm99PWE7Z2UoW3Isc10sXCJnYXRoZXJWMlwiKTtsZXQgbD13LnBhcnNlQXhpc1BhcmFtKGksci5zaGFwZSlbMF0sdT1uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMscD1yLnNoYXBlW2xdO2ZvcihsZXQgdj0wO3Y8dS5sZW5ndGg7Kyt2KXtsZXQgST11W3ZdO3cuYXNzZXJ0KEk8PXAtMSYmST49MCwoKT0+YEdhdGhlclYyOiB0aGUgaW5kZXggdmFsdWUgJHtJfSBpcyBub3QgaW4gWzAsICR7cC0xfV1gKX1sZXQgZD1vO289PW51bGwmJihkPTApO2xldCBjPXcuc2l6ZUZyb21TaGFwZShzLnNoYXBlKSxoPVQuc2VnbWVudF91dGlsLmNvbGxlY3RHYXRoZXJPcFNoYXBlSW5mbyhyLHMsbCxkKSxtPXh0KHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpbaC5iYXRjaFNpemUsaC5vdXRlclNpemUsaC5kaW1TaXplLGguc2xpY2VTaXplXX19KSxmPXh0KHtpbnB1dHM6e3g6c30sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpbaC5iYXRjaFNpemUsYy9oLmJhdGNoU2l6ZV19fSksZz1baC5iYXRjaFNpemUsaC5vdXRlclNpemUsYy9oLmJhdGNoU2l6ZSxoLnNsaWNlU2l6ZV0sYj1uLmJ1ZmZlclN5bmMoZikseT1uLmJ1ZmZlclN5bmMobSkseD1VRSh5LGIsZyk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obSksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhmKSxuLm1ha2VUZW5zb3JJbmZvKGgub3V0cHV0U2hhcGUseC5kdHlwZSx4LnZhbHVlcyl9dmFyIFVZPXtrZXJuZWxOYW1lOmZ1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpWWX07ZnVuY3Rpb24gR1koZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7aW5wdXQ6YX09dCxyPXcuc2l6ZUZyb21TaGFwZShhLnNoYXBlKSxzPWEuc2hhcGVbYS5zaGFwZS5sZW5ndGgtMV0saT1yL3Msbz14dCh7aW5wdXRzOnt4OmF9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6W2ksc119fSksbD1UXyhvLCEwLG4pLHU9eHQoe2lucHV0czp7eDpsfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOmEuc2hhcGV9fSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obyksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhsKSx1fXZhciBIWT17a2VybmVsTmFtZTpFbSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6R1l9LGpZPWx0KHRvLGU9Pk51bWJlci5pc0Zpbml0ZShlKT8xOjAsXCJib29sXCIpLHFZPXtrZXJuZWxOYW1lOnRvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpqWX0sS1k9bHQobm8sZT0+TWF0aC5hYnMoZSk9PT0xLzA/MTowLFwiYm9vbFwiKSxYWT17a2VybmVsTmFtZTpubyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6S1l9LFlZPWx0KGFvLGU9Pk51bWJlci5pc05hTihlKT8xOjAsXCJib29sXCIpLFpZPXtrZXJuZWxOYW1lOmFvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpZWX07ZnVuY3Rpb24gSlkoZSl7bGV0e2JhY2tlbmQ6dCxhdHRyczpufT1lLHtzdGFydDphLHN0b3A6cixudW06c309bixpPUtFKGEscixzKTtyZXR1cm4gdC5tYWtlVGVuc29ySW5mbyhbaS5sZW5ndGhdLFwiZmxvYXQzMlwiLGkpfXZhciBRWT17a2VybmVsTmFtZTp2dSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Sll9LGU3PWx0KGlvLGU9Pk1hdGgubG9nMXAoZSkpLHQ3PXtrZXJuZWxOYW1lOmlvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzplN30sbjc9TXQoKGUsdCk9PmUmJnQpLGE3PVp0KHd1LG43LG51bGwsXCJib29sXCIpLHI3PXtrZXJuZWxOYW1lOnd1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzphN30sczc9bHQoa3UsZT0+ZT8wOjEsXCJib29sXCIpLGk3PXtrZXJuZWxOYW1lOmt1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpzN30sbzc9TXQoKGUsdCk9PmV8fHQpLGw3PVp0KEl1LG83LG51bGwsXCJib29sXCIpLHU3PXtrZXJuZWxOYW1lOkl1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpsN307ZnVuY3Rpb24gcDcoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2RlcHRoUmFkaXVzOnMsYmlhczppLGFscGhhOm8sYmV0YTpsfT1hO2dlKHIsXCJMUk5cIik7bGV0IHU9ci5zaGFwZVszXSxwPXUtMSxkPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxjPXcuc2l6ZUZyb21TaGFwZShyLnNoYXBlKSxoPW5ldyBGbG9hdDMyQXJyYXkoYyk7ZnVuY3Rpb24gbShmKXtsZXQgZz1mJXUsYj1mLWcrTWF0aC5tYXgoMCxnLXMpLHk9Zi1nK01hdGgubWluKGcrcyxwKSx4PTA7Zm9yKDtiPD15O2IrKyl7bGV0IHY9ZFtiXTt4Kz12KnZ9cmV0dXJuIHh9Zm9yKGxldCBmPTA7ZjxjO2YrKyl7bGV0IGc9bShmKSxiPWRbZl0qTWF0aC5wb3coaStvKmcsLWwpO2hbZl09Yn1yZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhyLnNoYXBlLHIuZHR5cGUsaCl9dmFyIGM3PXtrZXJuZWxOYW1lOm9vLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpwN307ZnVuY3Rpb24gZDcoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIseTpzLGR5Oml9PXQse2RlcHRoUmFkaXVzOm8sYmlhczpsLGFscGhhOnUsYmV0YTpwfT1hO2dlKGksXCJMUk5HcmFkXCIpO2xldCBkPXcuc2l6ZUZyb21TaGFwZShpLnNoYXBlKSxjPWkuc2hhcGVbM10saD1uLmRhdGEuZ2V0KGkuZGF0YUlkKS52YWx1ZXMsbT1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsZj1uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMsZz1uZXcgRmxvYXQzMkFycmF5KGQpLGI9ZDtmb3IobGV0IHk9MDt5PGI7eSsrKXtsZXQgeD15JWMsdj15LXgrTWF0aC5tYXgoMCx4LW8pLEk9eS14K01hdGgubWluKGMseCtvKzEpLE49MDtmb3IobGV0IEM9djtDPEk7QysrKU4rPU1hdGgucG93KG1bQ10sMik7Tj11Kk4rbDtmb3IobGV0IEM9djtDPEk7QysrKXtsZXQgXz0tMip1KnAqbVtDXSpmW3ldL047eT09PUMmJihfKz1NYXRoLnBvdyhOLC1wKSksXyo9aFt5XSxnW0NdKz1ffX1yZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhpLnNoYXBlLHIuZHR5cGUsZyl9dmFyIGg3PXtrZXJuZWxOYW1lOlN1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpkN307ZnVuY3Rpb24gQ18oZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse3JlZHVjdGlvbkluZGljZXM6cyxrZWVwRGltczppfT1hLG89bixsPXIuc2hhcGUsdT1sLmxlbmd0aCxwPXcucGFyc2VBeGlzUGFyYW0ocyxsKSxkPXAsYz1ULmdldEF4ZXNQZXJtdXRhdGlvbihkLHUpLGg9by5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzO2lmKGMhPW51bGwpe2xldCB2PW5ldyBBcnJheSh1KTtmb3IobGV0IEk9MDtJPHYubGVuZ3RoO0krKyl2W0ldPWxbY1tJXV07aD1XMShoLGwsci5kdHlwZSxjLHYpLGQ9VC5nZXRJbm5lck1vc3RBeGVzKGQubGVuZ3RoLHUpLGw9dn1nZShyLFwibWF4XCIpLFQuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJtYXhcIixkLHUpO2xldFttLGZdPVQuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhsLGQpLGc9dy5zaXplRnJvbVNoYXBlKGYpLGI9WUUoaCxnLG0sci5kdHlwZSkseT1vLndyaXRlKGIsbSxyLmR0eXBlKSx4PW07cmV0dXJuIGkmJih4PVQuZXhwYW5kU2hhcGVUb0tlZXBEaW0obSxwKSkse2RhdGFJZDp5LHNoYXBlOngsZHR5cGU6ci5kdHlwZX19dmFyIG03PXtrZXJuZWxOYW1lOmxvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpDX307ZnVuY3Rpb24gZjcoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQ7Z2UocixcIm1heFBvb2xcIik7bGV0e2ZpbHRlclNpemU6cyxzdHJpZGVzOmkscGFkOm8sZGltUm91bmRpbmdNb2RlOmx9PWEsdT0xO3cuYXNzZXJ0KFQuZWl0aGVyU3RyaWRlc09yRGlsYXRpb25zQXJlT25lKGksdSksKCk9PmBFcnJvciBpbiBtYXhQb29sOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyAke2l9IGFuZCBkaWxhdGlvbnMgJyR7dX0nYCk7bGV0IHA9VC5jb21wdXRlUG9vbDJESW5mbyhyLnNoYXBlLHMsaSx1LG8sbCksZDtpZihwLmZpbHRlcldpZHRoPT09MSYmcC5maWx0ZXJIZWlnaHQ9PT0xJiZ3LmFycmF5c0VxdWFsKHAuaW5TaGFwZSxwLm91dFNoYXBlKSlkPWNyKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpufSk7ZWxzZXtsZXQgYz1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsaD13LmNvbXB1dGVTdHJpZGVzKHIuc2hhcGUpLG09SzEoYyxyLnNoYXBlLHIuZHR5cGUsaCxwLFwibWF4XCIpO2Q9bi5tYWtlVGVuc29ySW5mbyhwLm91dFNoYXBlLHIuZHR5cGUsbS52YWx1ZXMpfXJldHVybiBkfXZhciBnNz17a2VybmVsTmFtZTpwbyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Zjd9O2Z1bmN0aW9uIGI3KGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtmaWx0ZXJTaXplOnMsc3RyaWRlczppLHBhZDpvLGRpbVJvdW5kaW5nTW9kZTpsLGRhdGFGb3JtYXQ6dX09YTtnZShyLFwibWF4UG9vbDNkXCIpO2xldCBwPVQuY29tcHV0ZVBvb2wzREluZm8oci5zaGFwZSxzLGksMSxvLGwsdSksZD1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsYz1JXyhkLHIuc2hhcGUsci5kdHlwZSx3LmNvbXB1dGVTdHJpZGVzKHIuc2hhcGUpLHAsXCJtYXhcIik7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8oYy5zaGFwZSxcImZsb2F0MzJcIixjLnZhbHVlcyl9dmFyIHk3PXtrZXJuZWxOYW1lOk51LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpiN307ZnVuY3Rpb24geDcoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtkeTpyLGlucHV0OnN9PXQse2ZpbHRlclNpemU6aSxzdHJpZGVzOm8scGFkOmwsZGltUm91bmRpbmdNb2RlOnV9PWE7Z2UoW3Isc10sXCJtYXhQb29sM0RHcmFkXCIpO2xldCBwPVQuY29tcHV0ZVBvb2wzREluZm8ocy5zaGFwZSxpLG8sMSxsLHUpLGQ9bi5idWZmZXJTeW5jKHMpLGM9b1goZCxwKSxoPXAuc3RyaWRlRGVwdGgsbT1wLnN0cmlkZUhlaWdodCxmPXAuc3RyaWRlV2lkdGgsZz1wLmRpbGF0aW9uRGVwdGgsYj1wLmRpbGF0aW9uSGVpZ2h0LHk9cC5kaWxhdGlvbldpZHRoLHg9cC5lZmZlY3RpdmVGaWx0ZXJEZXB0aCx2PXAuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LEk9cC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxOPXgtMS1wLnBhZEluZm8uZnJvbnQsQz1JLTEtcC5wYWRJbmZvLmxlZnQsXz12LTEtcC5wYWRJbmZvLnRvcCxGPU9lKHMuc2hhcGUsXCJmbG9hdDMyXCIpLEQ9bi5idWZmZXJTeW5jKHIpO2ZvcihsZXQgJD0wOyQ8cC5iYXRjaFNpemU7KyskKWZvcihsZXQgUz0wO1M8cC5pbkNoYW5uZWxzOysrUylmb3IobGV0IE09MDtNPHAuaW5EZXB0aDsrK00pZm9yKGxldCBCPTA7QjxwLmluSGVpZ2h0OysrQilmb3IobGV0IFU9MDtVPHAuaW5XaWR0aDsrK1Upe2xldCBIPU0tTixxPUItXyxLPVUtQyxaPTA7Zm9yKGxldCBKPTA7Sjx4O0orPWcpe2xldCBlZT0oSCtKKS9oO2lmKCEoZWU8MHx8ZWU+PXAub3V0RGVwdGh8fE1hdGguZmxvb3IoZWUpIT09ZWUpKWZvcihsZXQgYWU9MDthZTx2O2FlKz1iKXtsZXQgdGU9KHErYWUpL207aWYoISh0ZTwwfHx0ZT49cC5vdXRIZWlnaHR8fE1hdGguZmxvb3IodGUpIT09dGUpKWZvcihsZXQgc2U9MDtzZTxJO3NlKz15KXtsZXQgaWU9KEsrc2UpL2Y7aWYoaWU8MHx8aWU+PXAub3V0V2lkdGh8fE1hdGguZmxvb3IoaWUpIT09aWUpY29udGludWU7bGV0IHZlPXgqdipJLTEtYy5nZXQoJCxlZSx0ZSxpZSxTKSx1ZT1KKnYqSSthZSpJK3NlLHllPXZlPT09dWU/MTowO2lmKHllPT09MCljb250aW51ZTtsZXQga2U9RC5nZXQoJCxlZSx0ZSxpZSxTKTtaKz1rZSp5ZX19fUYuc2V0KFosJCxNLEIsVSxTKX1yZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhGLnNoYXBlLEYuZHR5cGUsRi52YWx1ZXMpfXZhciB2Nz17a2VybmVsTmFtZTpCYyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6eDd9O2Z1bmN0aW9uIHc3KGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7ZHk6cixpbnB1dDpzLG91dHB1dDppfT10LG89cztnZShbcyxpXSxcIm1heFBvb2xHcmFkXCIpO2xldHtmaWx0ZXJTaXplOmwsc3RyaWRlczp1LHBhZDpwLGRpbVJvdW5kaW5nTW9kZTpkfT1hLGM9VC5jb21wdXRlUG9vbDJESW5mbyhvLnNoYXBlLGwsdSwxLHAsZCksaD1uLmRhdGEuZ2V0KG8uZGF0YUlkKS52YWx1ZXMsbT1PZShjLm91dFNoYXBlLG8uZHR5cGUsa18oaCxvLnNoYXBlLG8uZHR5cGUsYykudmFsdWVzKSxmPWMuc3RyaWRlSGVpZ2h0LGc9Yy5zdHJpZGVXaWR0aCxiPWMuZGlsYXRpb25IZWlnaHQseT1jLmRpbGF0aW9uV2lkdGgseD1jLmVmZmVjdGl2ZUZpbHRlckhlaWdodCx2PWMuZWZmZWN0aXZlRmlsdGVyV2lkdGgsST12LTEtYy5wYWRJbmZvLmxlZnQsTj14LTEtYy5wYWRJbmZvLnRvcCxDPU9lKG8uc2hhcGUsXCJmbG9hdDMyXCIpLF89bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLEY9T2Uoci5zaGFwZSxcImZsb2F0MzJcIixfKTtmb3IobGV0IEQ9MDtEPGMuYmF0Y2hTaXplOysrRClmb3IobGV0ICQ9MDskPGMuaW5DaGFubmVsczsrKyQpZm9yKGxldCBTPTA7UzxjLmluSGVpZ2h0OysrUylmb3IobGV0IE09MDtNPGMuaW5XaWR0aDsrK00pe2xldCBCPVMtTixVPU0tSSxIPTA7Zm9yKGxldCBxPTA7cTx4O3ErPWIpe2xldCBLPShCK3EpL2Y7aWYoIShLPDB8fEs+PWMub3V0SGVpZ2h0fHxNYXRoLmZsb29yKEspIT09SykpZm9yKGxldCBaPTA7Wjx2O1orPXkpe2xldCBKPShVK1opL2c7aWYoSjwwfHxKPj1jLm91dFdpZHRofHxNYXRoLmZsb29yKEopIT09Siljb250aW51ZTtsZXQgZWU9eCp2LTEtbS5nZXQoRCxLLEosJCksYWU9cSp2K1osdGU9ZWU9PT1hZT8xOjA7aWYodGU9PT0wKWNvbnRpbnVlO2xldCBzZT1GLmdldChELEssSiwkKTtIKz1zZSp0ZX19Qy5zZXQoSCxELFMsTSwkKX1yZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhDLnNoYXBlLEMuZHR5cGUsQy52YWx1ZXMpfXZhciBrNz17a2VybmVsTmFtZTpXYyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6dzd9O2Z1bmN0aW9uIEk3KGUsdCxuLGEscil7bGV0IHM9dy5jb21wdXRlU3RyaWRlcyh0KSxpPUsxKGUsdCxuLHMscixcIm1heFwiKSxvPWtfKGUsdCxuLHIsITAsYSk7cmV0dXJuW2kudmFsdWVzLG8udmFsdWVzXX12YXIgUzc9e2tlcm5lbE5hbWU6VmMsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOih7aW5wdXRzOmUsYXR0cnM6dCxiYWNrZW5kOm59KT0+e2xldHt4OmF9PWUse2ZpbHRlclNpemU6cixzdHJpZGVzOnMscGFkOmksaW5jbHVkZUJhdGNoSW5JbmRleDpvfT10LGw9bjtnZShhLFwiTWF4UG9vbFdpdGhBcmdtYXhcIik7bGV0IHU9bC5kYXRhLmdldChhLmRhdGFJZCkudmFsdWVzLHA9VC5jb21wdXRlUG9vbDJESW5mbyhhLnNoYXBlLHIscyxbMSwxXSxpKSxbZCxjXT1JNyh1LGEuc2hhcGUsYS5kdHlwZSxvLHApLGg9bC53cml0ZShkLHAub3V0U2hhcGUsYS5kdHlwZSksbT1sLndyaXRlKGMscC5vdXRTaGFwZSxhLmR0eXBlKTtyZXR1cm5be2RhdGFJZDpoLHNoYXBlOnAub3V0U2hhcGUsZHR5cGU6YS5kdHlwZX0se2RhdGFJZDptLHNoYXBlOnAub3V0U2hhcGUsZHR5cGU6XCJpbnQzMlwifV19fTtmdW5jdGlvbiBONyhlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7YXhpczpzLGtlZXBEaW1zOml9PWEsbz13LnBhcnNlQXhpc1BhcmFtKHMsci5zaGFwZSksbD1ULmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoci5zaGFwZSxvKVsxXSx1PXcuc2l6ZUZyb21TaGFwZShsKSxwPVtdLGQ9bi5tYWtlVGVuc29ySW5mbyhbXSxcImZsb2F0MzJcIixuZXcgRmxvYXQzMkFycmF5KFt1XSkpO3AucHVzaChkKTtsZXQgYz1icyh7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bixhdHRyczp7ZHR5cGU6XCJmbG9hdDMyXCJ9fSk7cC5wdXNoKGMpO2xldCBoPVgxKHtpbnB1dHM6e2E6YyxiOmR9LGJhY2tlbmQ6bn0pO3AucHVzaChoKTtsZXQgbT1FZCh7aW5wdXRzOnt4Omh9LGJhY2tlbmQ6bixhdHRyczp7YXhpczpzLGtlZXBEaW1zOml9fSk7cmV0dXJuIHAuZm9yRWFjaChmPT5uLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGYpKSxtfXZhciBUNz17a2VybmVsTmFtZTpjbyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Tjd9O2Z1bmN0aW9uIEM3KGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtheGlzOnMsa2VlcERpbXM6aX09YTtnZShyLFwibWluXCIpO2xldCBvPXcucGFyc2VBeGlzUGFyYW0ocyxyLnNoYXBlKSxsPW8sdT1ULmdldEF4ZXNQZXJtdXRhdGlvbihsLHIuc2hhcGUubGVuZ3RoKSxwPXI7dSE9bnVsbCYmKHA9Vm4oe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3Blcm06dX19KSxsPVQuZ2V0SW5uZXJNb3N0QXhlcyhsLmxlbmd0aCxyLnNoYXBlLmxlbmd0aCkpLFQuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJtaW5cIixsLHAuc2hhcGUubGVuZ3RoKTtsZXRbZCxjXT1ULmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMocC5zaGFwZSxsKSxoPXcuc2l6ZUZyb21TaGFwZShjKSxtPXcubWFrZVplcm9zVHlwZWRBcnJheSh3LnNpemVGcm9tU2hhcGUoZCkscC5kdHlwZSksZj1uLmRhdGEuZ2V0KHAuZGF0YUlkKS52YWx1ZXM7Zm9yKGxldCBiPTA7YjxtLmxlbmd0aDsrK2Ipe2xldCB5PWIqaCx4PWZbeV07Zm9yKGxldCB2PTA7djxoOysrdil7bGV0IEk9Zlt5K3ZdOyhOdW1iZXIuaXNOYU4oSSl8fEk8eCkmJih4PUkpfW1bYl09eH11IT1udWxsJiZuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHApO2xldCBnPW4ubWFrZVRlbnNvckluZm8oZCxwLmR0eXBlLG0pO2lmKGkpe2xldCBiPVQuZXhwYW5kU2hhcGVUb0tlZXBEaW0oZCxvKSx5PXh0KHtpbnB1dHM6e3g6Z30sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpifX0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGcpLHl9cmV0dXJuIGd9dmFyIEU3PXtrZXJuZWxOYW1lOmhvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpDN307ZnVuY3Rpb24gXzcoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse3BhZGRpbmdzOnMsbW9kZTppfT1hO2dlKHIsXCJtaXJyb3JQYWRcIik7bGV0IG89cy5tYXAoKHkseCk9PnlbMF0rci5zaGFwZVt4XSt5WzFdKSxsPXMubWFwKHk9PnlbMF0pLHU9cy5tYXAoKHkseCk9PnlbMF0rci5zaGFwZVt4XSkscD1pPT09XCJyZWZsZWN0XCI/MDoxLGQ9bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLGM9ci5zaGFwZS5sZW5ndGgsaD13LmNvbXB1dGVTdHJpZGVzKHIuc2hhcGUpLG09dy5zaXplRnJvbVNoYXBlKG8pLGY9by5sZW5ndGgsZz13LmNvbXB1dGVTdHJpZGVzKG8pLGI9dy5nZXRUeXBlZEFycmF5RnJvbURUeXBlKHIuZHR5cGUsbSk7Zm9yKGxldCB5PTA7eTxtO3krKyl7bGV0IHg9dy5pbmRleFRvTG9jKHksZixnKTtmb3IobGV0IEk9MDtJPGY7SSsrKXhbSV08bFtJXT94W0ldPWxbSV0qMi14W0ldLXA6eFtJXT49dVtJXSYmKHhbSV09KHVbSV0tMSkqMi14W0ldK3ApO3g9eC5tYXAoKEksTik9PkktbFtOXSk7bGV0IHY9dy5sb2NUb0luZGV4KHgsYyxoKTtiW3ldPWRbdl19cmV0dXJue2RhdGFJZDpuLndyaXRlKGIsbyxyLmR0eXBlKSxzaGFwZTpvLGR0eXBlOnIuZHR5cGV9fXZhciBBNz17a2VybmVsTmFtZTpmbyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Xzd9LEY3PU10KChlLHQpPT57bGV0IG49ZSV0O3JldHVybiBlPDAmJnQ8MHx8ZT49MCYmdD49MD9uOihuK3QpJXR9KSwkNz1adChnbyxGNyksRDc9e2tlcm5lbE5hbWU6Z28sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOiQ3fSxSNz14cyhibSgpKTtmdW5jdGlvbiBFXyhlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2xvZ2l0czpyfT10LHtkaW06c309YSxpPXIuc2hhcGUubGVuZ3RoLG89cztpZihvPT09LTEmJihvPWktMSksbyE9PWktMSl0aHJvdyBFcnJvcihgU29mdG1heCBhbG9uZyBhIG5vbi1sYXN0IGRpbWVuc2lvbiBpcyBub3QgeWV0IHN1cHBvcnRlZC4gTG9naXRzIHdhcyByYW5rICR7aX0gYW5kIGRpbSB3YXMgJHtvfWApO2xldCBsPXcucGFyc2VBeGlzUGFyYW0oW29dLHIuc2hhcGUpLHU9Q18oe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3JlZHVjdGlvbkluZGljZXM6bCxrZWVwRGltczohMX19KSxwPVQuZXhwYW5kU2hhcGVUb0tlZXBEaW0odS5zaGFwZSxsKSxkPXh0KHtpbnB1dHM6e3g6dX0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpwfX0pLGM9ajEoe2lucHV0czp7YTpyLGI6ZH0sYmFja2VuZDpufSksaD1MRSh7aW5wdXRzOnt4OmN9LGJhY2tlbmQ6bn0pLG09RWQoe2lucHV0czp7eDpofSxiYWNrZW5kOm4sYXR0cnM6e2F4aXM6bCxrZWVwRGltczohMX19KSxmPXh0KHtpbnB1dHM6e3g6bX0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpwfX0pLGc9WDEoe2lucHV0czp7YTpoLGI6Zn0sYmFja2VuZDpufSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odSksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhkKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGMpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaCksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhtKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGYpLGd9dmFyIE03PXtrZXJuZWxOYW1lOnpvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpFX307ZnVuY3Rpb24gTzcoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtsb2dpdHM6cn09dCx7bnVtU2FtcGxlczpzLHNlZWQ6aSxub3JtYWxpemVkOm99PWE7Z2UocixcIm11bHRpbm9taWFsXCIpO2xldCBsPW8/cjpFXyh7aW5wdXRzOntsb2dpdHM6cn0sYmFja2VuZDpuLGF0dHJzOntkaW06LTF9fSksdT1sLnNoYXBlWzBdLHA9bC5zaGFwZVsxXSxkPW4uZGF0YS5nZXQobC5kYXRhSWQpLnZhbHVlcyxjPVt1LHNdLGg9dy5tYWtlWmVyb3NUeXBlZEFycmF5KHcuc2l6ZUZyb21TaGFwZShjKSxcImludDMyXCIpO2ZvcihsZXQgbT0wO208dTsrK20pe2xldCBmPW0qcCxnPW5ldyBGbG9hdDMyQXJyYXkocC0xKTtnWzBdPWRbZl07Zm9yKGxldCB4PTE7eDxnLmxlbmd0aDsrK3gpZ1t4XT1nW3gtMV0rZFtmK3hdO2xldCBiPVI3LmFsZWEoaS50b1N0cmluZygpKSx5PW0qcztmb3IobGV0IHg9MDt4PHM7Kyt4KXtsZXQgdj1iKCk7aFt5K3hdPWcubGVuZ3RoO2ZvcihsZXQgST0wO0k8Zy5sZW5ndGg7SSsrKWlmKHY8Z1tJXSl7aFt5K3hdPUk7YnJlYWt9fX1yZXR1cm4gb3x8bi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhsKSxuLm1ha2VUZW5zb3JJbmZvKGMsXCJpbnQzMlwiLGgpfXZhciBQNz17a2VybmVsTmFtZTpUdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Tzd9LEw3PW1yLm5vbk1heFN1cHByZXNzaW9uVjNJbXBsO2Z1bmN0aW9uIHo3KGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7Ym94ZXM6cixzY29yZXM6c309dCx7bWF4T3V0cHV0U2l6ZTppLGlvdVRocmVzaG9sZDpvLHNjb3JlVGhyZXNob2xkOmx9PWE7Z2UocixcIk5vbk1heFN1cHByZXNzaW9uXCIpO2xldCB1PW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxwPW4uZGF0YS5nZXQocy5kYXRhSWQpLnZhbHVlcyx7c2VsZWN0ZWRJbmRpY2VzOmR9PUw3KHUscCxpLG8sbCk7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8oW2QubGVuZ3RoXSxcImludDMyXCIsbmV3IEludDMyQXJyYXkoZCkpfXZhciBXNz17a2VybmVsTmFtZTpfdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6ejd9LEI3PW1yLm5vbk1heFN1cHByZXNzaW9uVjRJbXBsO2Z1bmN0aW9uIFY3KGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7Ym94ZXM6cixzY29yZXM6c309dCx7bWF4T3V0cHV0U2l6ZTppLGlvdVRocmVzaG9sZDpvLHNjb3JlVGhyZXNob2xkOmwscGFkVG9NYXhPdXRwdXRTaXplOnV9PWE7Z2UocixcIk5vbk1heFN1cHByZXNzaW9uUGFkZGVkXCIpO2xldCBwPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxkPW4uZGF0YS5nZXQocy5kYXRhSWQpLnZhbHVlcyx7c2VsZWN0ZWRJbmRpY2VzOmMsdmFsaWRPdXRwdXRzOmh9PUI3KHAsZCxpLG8sbCx1KTtyZXR1cm5bbi5tYWtlVGVuc29ySW5mbyhbYy5sZW5ndGhdLFwiaW50MzJcIixuZXcgSW50MzJBcnJheShjKSksbi5tYWtlVGVuc29ySW5mbyhbXSxcImludDMyXCIsbmV3IEludDMyQXJyYXkoW2hdKSldfXZhciBVNz17a2VybmVsTmFtZTpBdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Vjd9LEc3PW1yLm5vbk1heFN1cHByZXNzaW9uVjVJbXBsO2Z1bmN0aW9uIEg3KGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7Ym94ZXM6cixzY29yZXM6c309dCx7bWF4T3V0cHV0U2l6ZTppLGlvdVRocmVzaG9sZDpvLHNjb3JlVGhyZXNob2xkOmwsc29mdE5tc1NpZ21hOnV9PWE7Z2UocixcIk5vbk1heFN1cHByZXNzaW9uV2l0aFNjb3JlXCIpO2xldCBwPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxkPW4uZGF0YS5nZXQocy5kYXRhSWQpLnZhbHVlcyxjPWksaD1vLG09bCxmPXUse3NlbGVjdGVkSW5kaWNlczpnLHNlbGVjdGVkU2NvcmVzOmJ9PUc3KHAsZCxjLGgsbSxmKTtyZXR1cm5bbi5tYWtlVGVuc29ySW5mbyhbZy5sZW5ndGhdLFwiaW50MzJcIixuZXcgSW50MzJBcnJheShnKSksbi5tYWtlVGVuc29ySW5mbyhbYi5sZW5ndGhdLFwiZmxvYXQzMlwiLG5ldyBGbG9hdDMyQXJyYXkoYikpXX12YXIgajc9e2tlcm5lbE5hbWU6RnUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOkg3fTtmdW5jdGlvbiBxNyhlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2luZGljZXM6cn09dCx7ZHR5cGU6cyxkZXB0aDppLG9uVmFsdWU6byxvZmZWYWx1ZTpsfT1hO2dlKHIsXCJvbmVIb3RcIik7bGV0IHU9dy5zaXplRnJvbVNoYXBlKHIuc2hhcGUpLHA9bmV3IEZsb2F0MzJBcnJheSh1KmkpO3AuZmlsbChsKTtsZXQgZD1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXM7Zm9yKGxldCBjPTA7Yzx1OysrYylkW2NdPj0wJiZkW2NdPGkmJihwW2MqaStkW2NdXT1vKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhbLi4uci5zaGFwZSxpXSxzLHApfXZhciBLNz17a2VybmVsTmFtZTp5byxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6cTd9O2Z1bmN0aW9uIGRtKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse3g6YX09dDtpZihhLmR0eXBlPT09XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoXCJ6ZXJvc0xpa2UgaXMgbm90IHN1cHBvcnRlZCBmb3Igc3RyaW5nIHRlbnNvcnNcIik7aWYoYS5kdHlwZT09PVwiY29tcGxleDY0XCIpe2xldCByPXlpKHtpbnB1dHM6e2lucHV0OmF9LGJhY2tlbmQ6bn0pLHM9ZG0oe2lucHV0czp7eDpyfSxiYWNrZW5kOm59KSxpPXFsKHtpbnB1dHM6e2lucHV0OmF9LGJhY2tlbmQ6bn0pLG89ZG0oe2lucHV0czp7eDppfSxiYWNrZW5kOm59KSxsPVluKHtpbnB1dHM6e3JlYWw6cyxpbWFnOm99LGJhY2tlbmQ6bn0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHIpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocyksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhpKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG8pLGx9ZWxzZSByZXR1cm4gWTEoe2JhY2tlbmQ6bixhdHRyczp7c2hhcGU6YS5zaGFwZSx2YWx1ZTowLGR0eXBlOmEuZHR5cGV9fSl9dmFyIFg3PXtrZXJuZWxOYW1lOll1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpkbX07ZnVuY3Rpb24gX18oZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7eDphfT10O2lmKGEuZHR5cGU9PT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihcIm9uZXNMaWtlIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHN0cmluZyB0ZW5zb3JzXCIpO2lmKGEuZHR5cGU9PT1cImNvbXBsZXg2NFwiKXtsZXQgcj15aSh7aW5wdXRzOntpbnB1dDphfSxiYWNrZW5kOm59KSxzPV9fKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpufSksaT1xbCh7aW5wdXRzOntpbnB1dDphfSxiYWNrZW5kOm59KSxvPWRtKHtpbnB1dHM6e3g6aX0sYmFja2VuZDpufSksbD1Zbih7aW5wdXRzOntyZWFsOnMsaW1hZzpvfSxiYWNrZW5kOm59KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhyKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHMpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaSksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhvKSxsfWVsc2UgcmV0dXJuIFkxKHtiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOmEuc2hhcGUsdmFsdWU6MSxkdHlwZTphLmR0eXBlfX0pfXZhciBZNz17a2VybmVsTmFtZTokdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6X199O2Z1bmN0aW9uIEFfKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7YXhpczpyfT1hO2lmKHQubGVuZ3RoPT09MSlyZXR1cm4gY20oe2lucHV0czp7aW5wdXQ6dFswXX0sYmFja2VuZDpuLGF0dHJzOntkaW06cn19KTtsZXQgcz10WzBdLnNoYXBlLGk9dFswXS5kdHlwZTt0LmZvckVhY2gocD0+e3cuYXNzZXJ0U2hhcGVzTWF0Y2gocyxwLnNoYXBlLFwiQWxsIHRlbnNvcnMgcGFzc2VkIHRvIHN0YWNrIG11c3QgaGF2ZSBtYXRjaGluZyBzaGFwZXNcIiksdy5hc3NlcnQoaT09PXAuZHR5cGUsKCk9PlwiQWxsIHRlbnNvcnMgcGFzc2VkIHRvIHN0YWNrIG11c3QgaGF2ZSBtYXRjaGluZyBkdHlwZXNcIil9KTtsZXQgbz1bXSxsPXQubWFwKHA9PntsZXQgZD1jbSh7aW5wdXRzOntpbnB1dDpwfSxiYWNrZW5kOm4sYXR0cnM6e2RpbTpyfX0pO3JldHVybiBvLnB1c2goZCksZH0pLHU9S2woe2lucHV0czpsLGJhY2tlbmQ6bixhdHRyczp7YXhpczpyfX0pO3JldHVybiBvLmZvckVhY2gocD0+bi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhwKSksdX12YXIgWjc9e2tlcm5lbE5hbWU6RHUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOkFffTtmdW5jdGlvbiBKNyhlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7cGFkZGluZ3M6cyxjb25zdGFudFZhbHVlOml9PWE7Z2UocixcInBhZFwiKTtsZXQgbz1zLm1hcCgoYix5KT0+YlswXStyLnNoYXBlW3ldK2JbMV0pLGw9cy5tYXAoYj0+YlswXSksdT1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMscD13LnNpemVGcm9tU2hhcGUoci5zaGFwZSksZD1yLnNoYXBlLmxlbmd0aCxjPXcuY29tcHV0ZVN0cmlkZXMoci5zaGFwZSksaD13LnNpemVGcm9tU2hhcGUobyksbT1vLmxlbmd0aCxmPXcuY29tcHV0ZVN0cmlkZXMobyksZz13LmdldFR5cGVkQXJyYXlGcm9tRFR5cGUoci5kdHlwZSxoKTtpIT09MCYmZy5maWxsKGkpO2ZvcihsZXQgYj0wO2I8cDtiKyspe2xldCB5PXcuaW5kZXhUb0xvYyhiLGQsYykubWFwKCh2LEkpPT52K2xbSV0pLHg9dy5sb2NUb0luZGV4KHksbSxmKTtnW3hdPXVbYl19cmV0dXJue2RhdGFJZDpuLndyaXRlKGcsbyxyLmR0eXBlKSxzaGFwZTpvLGR0eXBlOnIuZHR5cGV9fXZhciBGXz17a2VybmVsTmFtZTp4byxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Sjd9LFE3PU10KChlLHQpPT5NYXRoLnBvdyhlLHQpKSxlWj1adCh2byxRNyksdFo9e2tlcm5lbE5hbWU6dm8sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmVafTtmdW5jdGlvbiBuWihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3BhcmFtc05lc3RlZFNwbGl0czpyLHBhcmFtc0RlbnNlVmFsdWVzOnMsaW5kaWNlczppfT10LHtvdXRwdXRSYWdnZWRSYW5rOm99PWEsbD1yLm1hcChiPT5uLmRhdGEuZ2V0KGIuZGF0YUlkKS52YWx1ZXMpLHU9ci5tYXAoYj0+Yi5zaGFwZSkscD1uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMsZD1uLmRhdGEuZ2V0KGkuZGF0YUlkKS52YWx1ZXMsW2MsaCxtXT1uXyhsLHUscCxzLnNoYXBlLHMuZHR5cGUsZCxpLnNoYXBlLG8pLGY9Yy5tYXAoYj0+bi5tYWtlVGVuc29ySW5mbyhbYi5sZW5ndGhdLFwiaW50MzJcIixiKSksZz1uLm1ha2VUZW5zb3JJbmZvKG0scy5kdHlwZSxoKTtyZXR1cm4gZi5jb25jYXQoW2ddKX12YXIgYVo9e2tlcm5lbE5hbWU6QW0sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOm5afTtmdW5jdGlvbiByWihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHtzdGFydHM6YSxsaW1pdHM6cixkZWx0YXM6c309dCxpPW4uZGF0YS5nZXQoYS5kYXRhSWQpLnZhbHVlcyxvPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxsPW4uZGF0YS5nZXQocy5kYXRhSWQpLnZhbHVlcyxbdSxwXT1hXyhpLGEuc2hhcGUsYS5kdHlwZSxvLHIuc2hhcGUsbCxzLnNoYXBlKSxkPW4ubWFrZVRlbnNvckluZm8oW3UubGVuZ3RoXSxcImludDMyXCIsdSksYz1uLm1ha2VUZW5zb3JJbmZvKFtwLmxlbmd0aF0sYS5kdHlwZSxwKTtyZXR1cm5bZCxjXX12YXIgc1o9e2tlcm5lbE5hbWU6Rm0sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOnJafTtmdW5jdGlvbiBpWihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3NoYXBlOnIsdmFsdWVzOnMsZGVmYXVsdFZhbHVlOmkscm93UGFydGl0aW9uVGVuc29yczpvfT10LHtyb3dQYXJ0aXRpb25UeXBlczpsfT1hLHU9bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLHA9bi5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzLGQ9bi5kYXRhLmdldChpLmRhdGFJZCkudmFsdWVzLGM9by5tYXAoZz0+bi5kYXRhLmdldChnLmRhdGFJZCkudmFsdWVzKSxoPW8ubWFwKGc9Pmcuc2hhcGUpLFttLGZdPXJfKHUsci5zaGFwZSxwLHMuc2hhcGUscy5kdHlwZSxkLGkuc2hhcGUsYyxoLGwpO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKG0scy5kdHlwZSxmKX12YXIgb1o9e2tlcm5lbE5hbWU6JG0sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmlafTtmdW5jdGlvbiBsWihlKXtsZXR7YmFja2VuZDp0LGF0dHJzOm59PWUse3N0YXJ0OmEsc3RvcDpyLGR0eXBlOnMsc3RlcDppfT1uLG89QjEoYSxyLGkscyk7cmV0dXJuIHQubWFrZVRlbnNvckluZm8oW28ubGVuZ3RoXSxzLG8pfXZhciB1Wj17a2VybmVsTmFtZTpVYyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6bFp9LHBaPWx0KElvLGU9PjEvZSksY1o9e2tlcm5lbE5hbWU6SW8sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOnBafTtmdW5jdGlvbiBkWihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2ltYWdlczpyfT10LHthbGlnbkNvcm5lcnM6cyxoYWxmUGl4ZWxDZW50ZXJzOmksc2l6ZTpvfT1hO2dlKHIsXCJyZXNpemVCaWxpbmVhclwiKTtsZXQgbD13LmNvbXB1dGVTdHJpZGVzKHIuc2hhcGUpLFt1LHBdPW8sW2QsYyxoLG1dPXIuc2hhcGUsZj1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsZz1uZXcgRmxvYXQzMkFycmF5KHcuc2l6ZUZyb21TaGFwZShbZCx1LHAsbV0pKSxiPVtzJiZ1PjE/Yy0xOmMscyYmcD4xP2gtMTpoXSx5PVtzJiZ1PjE/dS0xOnUscyYmcD4xP3AtMTpwXSx4PTAsdj1iWzBdL3lbMF0sST1iWzFdL3lbMV07Zm9yKGxldCBOPTA7TjxkO04rKylmb3IobGV0IEM9MDtDPHU7QysrKXtsZXQgXztpP189diooQysuNSktLjU6Xz12KkM7bGV0IEY9TWF0aC5tYXgoMCxNYXRoLmZsb29yKF8pKSxEPV8tRiwkPU1hdGgubWluKGMtMSxNYXRoLmNlaWwoXykpLFM9TipsWzBdK0YqbFsxXSxNPU4qbFswXSskKmxbMV07Zm9yKGxldCBCPTA7QjxwO0IrKyl7bGV0IFU7aT9VPUkqKEIrLjUpLS41OlU9SSpCO2xldCBIPU1hdGgubWF4KDAsTWF0aC5mbG9vcihVKSkscT1VLUgsSz1NYXRoLm1pbihoLTEsTWF0aC5jZWlsKFUpKSxaPVMrSCpsWzJdLEo9TStIKmxbMl0sZWU9UytLKmxbMl0sYWU9TStLKmxbMl07Zm9yKGxldCB0ZT0wO3RlPG07dGUrKyl7bGV0IHNlPWZbWit0ZV0saWU9ZltKK3RlXSx2ZT1mW2VlK3RlXSx1ZT1mW2FlK3RlXSx5ZT1zZSsodmUtc2UpKnEsa2U9aWUrKHVlLWllKSpxLFNlPXllKyhrZS15ZSkqRDtnW3grK109U2V9fX1yZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhbZCx1LHAsbV0sXCJmbG9hdDMyXCIsZyl9dmFyIGhaPXtrZXJuZWxOYW1lOlRvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpkWn07ZnVuY3Rpb24gbVooZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtpbWFnZXM6cixkeTpzfT10LHthbGlnbkNvcm5lcnM6aX09YTtnZShbcyxyXSxcInJlc2l6ZUJpbGluZWFyR3JhZFwiKTtsZXQgbz13LmNvbXB1dGVTdHJpZGVzKHIuc2hhcGUpLFtsLHUscCxkXT1yLnNoYXBlLFssYyxoXT1zLnNoYXBlLG09bmV3IEZsb2F0MzJBcnJheShsKnUqcCpkKSxmPVtpJiZjPjE/dS0xOnUsaSYmaD4xP3AtMTpwXSxnPVtpJiZjPjE/Yy0xOmMsaSYmaD4xP2gtMTpoXSxiPWZbMF0vZ1swXSx5PWZbMV0vZ1sxXSx4PW4uZGF0YS5nZXQocy5kYXRhSWQpLnZhbHVlcyx2PTA7Zm9yKGxldCBJPTA7STxsO0krKyl7bGV0IE49SSpvWzBdO2ZvcihsZXQgQz0wO0M8YztDKyspe2xldCBfPUMqYixGPU1hdGguZmxvb3IoXyksRD1NYXRoLm1pbihNYXRoLmNlaWwoXyksdS0xKSwkPU4rRipvWzFdLFM9TitEKm9bMV0sTT1fLUYsQj0xLU07Zm9yKGxldCBVPTA7VTxoO1UrKyl7bGV0IEg9VSp5LHE9TWF0aC5mbG9vcihIKSxLPU1hdGgubWluKE1hdGguY2VpbChIKSxwLTEpLFo9SC1xLEo9MS1aLGVlPSQrcSpvWzJdLGFlPSQrSypvWzJdLHRlPVMrcSpvWzJdLHNlPVMrSypvWzJdLGllPUIqSix2ZT1CKlosdWU9TSpKLHllPU0qWjtmb3IobGV0IGtlPTA7a2U8ZDtrZSsrKXtsZXQgU2U9eFt2KytdO21bZWUra2VdKz1TZSppZSxtW2FlK2tlXSs9U2UqdmUsbVt0ZStrZV0rPVNlKnVlLG1bc2Ura2VdKz1TZSp5ZX19fX1yZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhbbCxwLHUsZF0sXCJmbG9hdDMyXCIsbSl9dmFyIGZaPXtrZXJuZWxOYW1lOk91LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzptWn07ZnVuY3Rpb24gZ1ooZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtpbWFnZXM6cn09dCx7YWxpZ25Db3JuZXJzOnMsaGFsZlBpeGVsQ2VudGVyczppLHNpemU6b309YTtnZShyLFwicmVzaXplTmVhcmVzdE5laWdoYm9yXCIpO2xldCBsPXcuY29tcHV0ZVN0cmlkZXMoci5zaGFwZSksW3UscF09byxbZCxjLGgsbV09ci5zaGFwZSxmPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxnPW5ldyBGbG9hdDMyQXJyYXkoZCp1KnAqbSksYj1bcyYmdT4xP2MtMTpjLHMmJnA+MT9oLTE6aF0seT1bcyYmdT4xP3UtMTp1LHMmJnA+MT9wLTE6cF0seD1iWzBdL3lbMF0sdj1iWzFdL3lbMV0sST0wO2ZvcihsZXQgTj0wO048ZDtOKyspe2xldCBDPU4qbFswXTtmb3IobGV0IF89MDtfPHU7XysrKXtsZXQgRj1pP3gqKF8rLjUpOngqXyxEPU1hdGgubWluKGMtMSxzP01hdGgucm91bmQoRik6TWF0aC5mbG9vcihGKSk7aSYmKEQ9TWF0aC5tYXgoMCxEKSk7bGV0ICQ9QytEKmxbMV07Zm9yKGxldCBTPTA7UzxwO1MrKyl7bGV0IE09aT92KihTKy41KTp2KlMsQj1NYXRoLm1pbihoLTEscz9NYXRoLnJvdW5kKE0pOk1hdGguZmxvb3IoTSkpO2kmJihCPU1hdGgubWF4KDAsQikpO2xldCBVPSQrQipsWzJdO2ZvcihsZXQgSD0wO0g8bTtIKyspe2xldCBxPWZbVStIXTtnW0krK109cX19fX1yZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhbZCx1LHAsbV0sci5kdHlwZSxnKX12YXIgYlo9e2tlcm5lbE5hbWU6Tm8sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmdafTtmdW5jdGlvbiB5WihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2ltYWdlczpyLGR5OnN9PXQse2FsaWduQ29ybmVyczppfT1hO2dlKFtzLHJdLFwicmVzaXplTmVhcmVzdE5laWdoYm9yR3JhZFwiKTtsZXQgbz13LmNvbXB1dGVTdHJpZGVzKHIuc2hhcGUpLGw9dy5jb21wdXRlU3RyaWRlcyhzLnNoYXBlKSxbdSxwLGQsY109ci5zaGFwZSxbLGgsbV09cy5zaGFwZSxmPW5ldyBGbG9hdDMyQXJyYXkodSpwKmQqYyksZz1uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMsYj1baSYmaD4xP3AtMTpwLGkmJm0+MT9kLTE6ZF0seT1baSYmaD4xP2gtMTpoLGkmJm0+MT9tLTE6bV0seD1iWzBdL3lbMF0sdj1iWzFdL3lbMV0sST0xL3gsTj0xL3YsQz1NYXRoLmNlaWwoSSkqMisyLF89TWF0aC5jZWlsKE4pKjIrMjtmb3IobGV0IEY9MDtGPHU7RisrKXtsZXQgRD1GKm9bMF07Zm9yKGxldCAkPTA7JDxwOyQrKyl7bGV0IFM9RCskKm9bMV0sTT1NYXRoLmZsb29yKCQqSSksQj1NYXRoLmZsb29yKE0tQy8yKTtmb3IobGV0IFU9MDtVPGQ7VSsrKXtsZXQgSD1TK1Uqb1syXSxxPU1hdGguZmxvb3IoVSpOKSxLPU1hdGguZmxvb3IocS1fLzIpO2ZvcihsZXQgWj0wO1o8YztaKyspe2xldCBKPTA7Zm9yKGxldCBlZT0wO2VlPEM7ZWUrKyl7bGV0IGFlPWVlK0I7aWYoYWU8MHx8YWU+PWgpY29udGludWU7bGV0IHRlPUQrYWUqbFsxXSxzZT1hZSp4LGllPU1hdGgubWluKHAtMSxpP01hdGgucm91bmQoc2UpOk1hdGguZmxvb3Ioc2UpKTtpZigkPT09aWUpZm9yKGxldCB2ZT0wO3ZlPF87dmUrKyl7bGV0IHVlPXZlK0s7aWYodWU8MHx8dWU+PW0pY29udGludWU7bGV0IHllPXRlK3VlKmxbMl0sa2U9dWUqdixTZT1NYXRoLm1pbihkLTEsaT9NYXRoLnJvdW5kKGtlKTpNYXRoLmZsb29yKGtlKSk7VT09PVNlJiYoSis9Z1t5ZStaXSl9fWZbSCtaXT1KfX19fXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKHIuc2hhcGUsci5kdHlwZSxmKX12YXIgeFo9e2tlcm5lbE5hbWU6TXUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOnlafTtmdW5jdGlvbiB2WihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7ZGltczpzfT1hO2dlKHIsXCJyZXZlcnNlXCIpO2xldCBpPXIuc2hhcGUubGVuZ3RoLG89dy5wYXJzZUF4aXNQYXJhbShzLHIuc2hhcGUpO2lmKGk9PT0wKXJldHVybiBjcih7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bn0pO2xldCBsPW5ldyBXdChyLnNoYXBlLHIuZHR5cGUpLHU9bi5idWZmZXJTeW5jKHIpO2ZvcihsZXQgcD0wO3A8bC5zaXplO3ArKyl7bGV0IGQ9bC5pbmRleFRvTG9jKHApLGM9ZC5zbGljZSgpO28uZm9yRWFjaChoPT5jW2hdPXIuc2hhcGVbaF0tMS1jW2hdKSxsLnNldCh1LmdldCguLi5jKSwuLi5kKX1yZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhsLnNoYXBlLGwuZHR5cGUsbC52YWx1ZXMpfXZhciB3Wj17a2VybmVsTmFtZTpFbyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6dlp9LGtaPXtrZXJuZWxOYW1lOlp1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzooe2lucHV0czplLGF0dHJzOnQsYmFja2VuZDpufSk9PntsZXR7aW1hZ2U6YX09ZSx7cmFkaWFuczpyLGZpbGxWYWx1ZTpzLGNlbnRlcjppfT10LG89bixsPXcuZ2V0VHlwZWRBcnJheUZyb21EVHlwZShhLmR0eXBlLHcuc2l6ZUZyb21TaGFwZShhLnNoYXBlKSksW3UscCxkLGNdPWEuc2hhcGUsW2gsbV09VC5nZXRJbWFnZUNlbnRlcihpLHAsZCksZj0yNTUsZz1NYXRoLnNpbihyKSxiPU1hdGguY29zKHIpLHk9by5kYXRhLmdldChhLmRhdGFJZCkudmFsdWVzO2ZvcihsZXQgeD0wO3g8dTt4Kyspe2xldCB2PXgqZCpwKmM7Zm9yKGxldCBJPTA7STxwO0krKyl7bGV0IE49SSooZCpjKTtmb3IobGV0IEM9MDtDPGQ7QysrKXtsZXQgXz1DKmM7Zm9yKGxldCBGPTA7RjxjO0YrKyl7bGV0IEQ9W3UsSSxDLEZdLCQ9RFsyXSxTPURbMV0sTT0oJC1oKSpiLShTLW0pKmcsQj0oJC1oKSpnKyhTLW0pKmI7TT1NYXRoLnJvdW5kKE0raCksQj1NYXRoLnJvdW5kKEIrbSk7bGV0IFU9cztpZih0eXBlb2YgcyE9XCJudW1iZXJcIiYmKEY9PT0zP1U9ZjpVPXNbRl0pLE0+PTAmJk08ZCYmQj49MCYmQjxwKXtsZXQgcT1CKihkKmMpLEs9TSpjLFo9ditxK0srRjtVPXlbWl19bGV0IEg9ditOK18rRjtsW0hdPVV9fX19cmV0dXJue2RhdGFJZDpvLndyaXRlKGwsYS5zaGFwZSxhLmR0eXBlKSxzaGFwZTphLnNoYXBlLGR0eXBlOmEuZHR5cGV9fX0sSVo9bHQoX28sZT0+e2xldCB0PU1hdGguZmxvb3IoZSk7cmV0dXJuIGUtdDwuNT9NYXRoLmZsb29yKGUpOmUtdD4uNT9NYXRoLmNlaWwoZSk6dCUyPT09MD90OnQrMX0pLFNaPXtrZXJuZWxOYW1lOl9vLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpJWn07ZnVuY3Rpb24gTlooZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtpbmRpY2VzOnIsdXBkYXRlczpzfT10LHtzaGFwZTppfT1hLHtzbGljZVJhbms6byxudW1VcGRhdGVzOmwsc2xpY2VTaXplOnUsc3RyaWRlczpwLG91dHB1dFNpemU6ZH09VC5jYWxjdWxhdGVTaGFwZXMocyxyLGkpLGM9ITAsaD1uLmJ1ZmZlclN5bmMociksbT1uLmJ1ZmZlclN5bmMocyksZj1uaShoLG0saSxkLHUsbCxvLHAsMCxjKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhpLGYuZHR5cGUsZi52YWx1ZXMpfXZhciBUWj17a2VybmVsTmFtZTpQdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Tlp9O2Z1bmN0aW9uIENaKGUsdCl7bGV0IG49MCxhPWUubGVuZ3RoLHI9MDtmb3IoO248YTspcj1NYXRoLmZsb29yKChuK2EpLzIpLGVbcl08dD9uPXIrMTphPXI7cmV0dXJuIGF9ZnVuY3Rpb24gRVooZSx0KXtsZXQgbj0wLGE9ZS5sZW5ndGgscj0wO2Zvcig7bjxhOylyPU1hdGguZmxvb3IoKG4rYSkvMiksZVtyXTw9dD9uPXIrMTphPXI7cmV0dXJuIGF9ZnVuY3Rpb24gX1ooZSx0LG4sYSxyLHMpe2xldCBpPXcuZ2V0QXJyYXlGcm9tRFR5cGUoXCJpbnQzMlwiLG4qcik7Zm9yKGxldCBvPTA7bzxuOysrbyl7bGV0IGw9ZS5zbGljZShvKmEsKG8rMSkqYSksdT1vKnI7Zm9yKGxldCBwPTA7cDxyOysrcClpW3UrcF09cz09PVwibGVmdFwiP0NaKGwsdFtwK3VdKTpFWihsLHRbcCt1XSl9cmV0dXJuIGl9ZnVuY3Rpb24gQVooZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtzb3J0ZWRTZXF1ZW5jZTpyLHZhbHVlczpzfT10LHtzaWRlOml9PWEsbz1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsbD1uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMsdT1fWihvLGwsci5zaGFwZVswXSxyLnNoYXBlWzFdLHMuc2hhcGVbMV0saSk7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8ocy5zaGFwZSxcImludDMyXCIsdSl9dmFyIEZaPXtrZXJuZWxOYW1lOnp1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpBWn07ZnVuY3Rpb24gJFooZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7Y29uZGl0aW9uOmEsdDpyLGU6c309dDtnZShbYSxyLHNdLFwic2VsZWN0XCIpO2xldCBpPWEuc2hhcGUubGVuZ3RoLG89bi5kYXRhLmdldChhLmRhdGFJZCkudmFsdWVzLGw9bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLHU9bi5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzLHA9ZmEoci5kdHlwZSxzLmR0eXBlKSxkPXcubWFrZVplcm9zVHlwZWRBcnJheSh3LnNpemVGcm9tU2hhcGUoci5zaGFwZSkscCksYz0wLGg9aT09PTB8fGk+MXx8ci5zaGFwZS5sZW5ndGg9PT0xPzE6dy5zaXplRnJvbVNoYXBlKHIuc2hhcGUuc2xpY2UoMSkpO2ZvcihsZXQgbT0wO208by5sZW5ndGg7bSsrKWZvcihsZXQgZj0wO2Y8aDtmKyspb1ttXT09PTE/ZFtjKytdPWxbbV06ZFtjKytdPXVbbV07cmV0dXJuIG4ubWFrZVRlbnNvckluZm8oci5zaGFwZSxwLGQpfXZhciBEWj17a2VybmVsTmFtZTpXdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6JFp9LFJaPVQuU0VMVV9TQ0FMRUFMUEhBLE1aPVQuU0VMVV9TQ0FMRSxPWj1sdChGbyxlPT5lPj0wP01aKmU6UloqKE1hdGguZXhwKGUpLTEpKSxQWj17a2VybmVsTmFtZTpGbyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6T1p9LExaPWx0KFJvLGU9PmU8MD8tMTplPjA/MTowKSx6Wj17a2VybmVsTmFtZTpSbyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6TFp9LFdaPWx0KCRvLGU9Pk1hdGguc2luKGUpKSxCWj17a2VybmVsTmFtZTokbyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6V1p9LFZaPWx0KERvLGU9Pk1hdGguc2luaChlKSksVVo9e2tlcm5lbE5hbWU6RG8sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOlZafSxHWj0xMTkyMDkyODk1NTA3ODEyNWUtMjMsZVM9TWF0aC5sb2coR1opKzIsSFo9bHQoT28sZT0+e2xldCB0PWU+LWVTLG49ZTxlUyxhPU1hdGguZXhwKGUpLHI7cmV0dXJuIG4/cj1hOnQ/cj1lOnI9TWF0aC5sb2coMSthKSxyfSksalo9e2tlcm5lbE5hbWU6T28sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOkhafTtmdW5jdGlvbiBxWihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7YmxvY2tTaGFwZTpzLHBhZGRpbmdzOml9PWE7Z2UoW3JdLFwic3BhY2VUb0JhdGNoTkRcIik7bGV0IG89dy5zaXplRnJvbVNoYXBlKHMpLGw9W1swLDBdXTtsLnB1c2goLi4uaSk7Zm9yKGxldCBnPTErcy5sZW5ndGg7ZzxyLnNoYXBlLmxlbmd0aDsrK2cpbC5wdXNoKFswLDBdKTtsZXQgdT1GXy5rZXJuZWxGdW5jKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntwYWRkaW5nczpsLGNvbnN0YW50VmFsdWU6MH19KSxwPVQuZ2V0UmVzaGFwZWQodS5zaGFwZSxzLG8sITEpLGQ9VC5nZXRQZXJtdXRlZChwLmxlbmd0aCxzLmxlbmd0aCwhMSksYz1ULmdldFJlc2hhcGVkUGVybXV0ZWQodS5zaGFwZSxzLG8sITEpLGg9eHQoe2lucHV0czp7eDp1fSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOnB9fSksbT1Wbih7aW5wdXRzOnt4Omh9LGJhY2tlbmQ6bixhdHRyczp7cGVybTpkfX0pLGY9eHQoe2lucHV0czp7eDptfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOmN9fSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odSksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhoKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG0pLGZ9dmFyIEtaPXtrZXJuZWxOYW1lOlZ1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpxWn07ZnVuY3Rpb24gWFooZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7aW5kaWNlczphLHZhbHVlczpyLGRlbnNlU2hhcGU6cyxkZWZhdWx0VmFsdWU6aX09dDtpZihzLnNoYXBlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKGBEZW5zZSBzaGFwZSBtdXN0IGJlIGEgdmVjdG9yLCBzYXc6XG4gICAgICAgICR7cy5zaGFwZX1gKTtpZihhLnNoYXBlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKGBJbmRpY2VzIG11c3QgYmUgYSBtYXRyaXgsIHNhdzpcbiAgICAgICAgJHthLnNoYXBlfWApO2lmKHIuc2hhcGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoYFZhbHVlcyBtdXN0IGJlIGEgdmVjdG9yLCBzYXc6XG4gICAgICAgICR7ci5zaGFwZX1gKTtpZihpLnNoYXBlLmxlbmd0aCE9PTApdGhyb3cgbmV3IEVycm9yKGBEZWZhdWx0IHZhbHVlIG11c3QgYmUgYSBzY2FsYXIsIHNhdzpcbiAgICAgICAgJHtpLnNoYXBlfWApO2xldCBvPW4uZGF0YS5nZXQoYS5kYXRhSWQpLnZhbHVlcyxsPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyx1PW4uZGF0YS5nZXQocy5kYXRhSWQpLnZhbHVlcyxwPW4uZGF0YS5nZXQoaS5kYXRhSWQpLnZhbHVlc1swXSxbZCxjLGgsbSxmXT1vXyhvLGEuc2hhcGUsYS5kdHlwZSxsLHIuZHR5cGUsdSxwKTtyZXR1cm5bbi5tYWtlVGVuc29ySW5mbyhjLGEuZHR5cGUsZCksbi5tYWtlVGVuc29ySW5mbyhbY1swXV0sci5kdHlwZSxoKSxuLm1ha2VUZW5zb3JJbmZvKFttLmxlbmd0aF0sXCJib29sXCIsbmV3IFVpbnQ4QXJyYXkobS5tYXAoZz0+TnVtYmVyKGcpKSkpLG4ubWFrZVRlbnNvckluZm8oW2YubGVuZ3RoXSxhLmR0eXBlLG5ldyBJbnQzMkFycmF5KGYpKV19dmFyIFlaPXtrZXJuZWxOYW1lOkdjLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpYWn07ZnVuY3Rpb24gWlooZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7aW5wdXRJbmRpY2VzOmEsaW5wdXRTaGFwZTpyLG5ld1NoYXBlOnN9PXQ7aWYoYS5zaGFwZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihgSW5wdXQgaW5kaWNlcyBzaG91bGQgYmUgYSBtYXRyaXggYnV0IHJlY2VpdmVkIHNoYXBlXG4gICAgICAgICR7YS5zaGFwZX1gKTtpZihyLnNoYXBlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBzaGFwZSBzaG91bGQgYmUgYSB2ZWN0b3IgYnV0IHJlY2VpdmVkIHNoYXBlXG4gICAgICAgICR7ci5zaGFwZX1gKTtpZihzLnNoYXBlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKGBUYXJnZXQgc2hhcGUgc2hvdWxkIGJlIGEgdmVjdG9yIGJ1dCByZWNlaXZlZCBzaGFwZSAke3Muc2hhcGV9YCk7bGV0IGk9QXJyYXkuZnJvbShuLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMpLG89bi5kYXRhLmdldChhLmRhdGFJZCkudmFsdWVzLGw9QXJyYXkuZnJvbShuLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMpLFt1LHAsZF09bF8obyxhLnNoYXBlLGEuZHR5cGUsaSxsKTtyZXR1cm5bbi5tYWtlVGVuc29ySW5mbyhwLGEuZHR5cGUsdSksbi5tYWtlVGVuc29ySW5mbyhbZC5sZW5ndGhdLHMuZHR5cGUsbmV3IEludDMyQXJyYXkoZCkpXX12YXIgSlo9e2tlcm5lbE5hbWU6R3UsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOlpafTtmdW5jdGlvbiBRWihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHtkYXRhOmEsaW5kaWNlczpyLHNlZ21lbnRJZHM6c309dDtpZihhLnNoYXBlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcIkRhdGEgc2hvdWxkIGJlIGF0IGxlYXN0IDEgZGltZW5zaW9uYWwgYnV0IHJlY2VpdmVkIHNjYWxhclwiKTtpZihyLnNoYXBlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKGBJbmRpY2VzIHNob3VsZCBiZSBhIHZlY3RvciBidXQgcmVjZWl2ZWQgc2hhcGVcbiAgICAgICAgICAke3Iuc2hhcGV9YCk7aWYocy5zaGFwZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihgU2VnbWVudCBpZHMgc2hvdWxkIGJlIGEgdmVjdG9yIGJ1dCByZWNlaXZlZCBzaGFwZVxuICAgICAgICAgICR7cy5zaGFwZX1gKTtpZihyLnNoYXBlWzBdIT09cy5zaGFwZVswXSl0aHJvdyBuZXcgRXJyb3IoXCJzZWdtZW50SWRzIGFuZCBpbmRpY2VzIHNob3VsZCBoYXZlIHNhbWUgc2l6ZS5cIik7bGV0IGk9bi5kYXRhLmdldChhLmRhdGFJZCkudmFsdWVzLG89bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLGw9bi5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzLFt1LHBdPVYxKGksYS5zaGFwZSxhLmR0eXBlLG8sbCwhMCk7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8ocCxhLmR0eXBlLHUpfXZhciBlSj17a2VybmVsTmFtZTpIYyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6UVp9O2Z1bmN0aW9uIHRKKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse2RhdGE6YSxpbmRpY2VzOnIsc2VnbWVudElkczpzfT10O2lmKGEuc2hhcGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBzaG91bGQgYmUgYXQgbGVhc3QgMSBkaW1lbnNpb25hbCBidXQgcmVjZWl2ZWQgc2NhbGFyXCIpO2lmKHIuc2hhcGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoYEluZGljZXMgc2hvdWxkIGJlIGEgdmVjdG9yIGJ1dCByZWNlaXZlZCBzaGFwZVxuICAgICAgICAgJHtyLnNoYXBlfWApO2lmKHMuc2hhcGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoYFNlZ21lbnQgaWRzIHNob3VsZCBiZSBhIHZlY3RvciBidXQgcmVjZWl2ZWQgc2hhcGVcbiAgICAgICAgICR7cy5zaGFwZX1gKTtpZihyLnNoYXBlWzBdIT09cy5zaGFwZVswXSl0aHJvdyBuZXcgRXJyb3IoXCJzZWdtZW50SWRzIGFuZCBpbmRpY2VzIHNob3VsZCBoYXZlIHNhbWUgc2l6ZS5cIik7bGV0IGk9bi5kYXRhLmdldChhLmRhdGFJZCkudmFsdWVzLG89bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLGw9bi5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzLFt1LHBdPVYxKGksYS5zaGFwZSxhLmR0eXBlLG8sbCk7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8ocCxhLmR0eXBlLHUpfXZhciBuSj17a2VybmVsTmFtZTpqYyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6dEp9O2Z1bmN0aW9uIGFKKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7c3BhcnNlSW5kaWNlczpyLHNwYXJzZVZhbHVlczpzLGRlZmF1bHRWYWx1ZTppfT10LHtvdXRwdXRTaGFwZTpvfT1hLHtzbGljZVJhbms6bCxudW1VcGRhdGVzOnUsc2xpY2VTaXplOnAsc3RyaWRlczpkLG91dHB1dFNpemU6Y309VC5jYWxjdWxhdGVTaGFwZXMocyxyLG8pLGg9ITEsbT1uLmJ1ZmZlclN5bmMociksZjtzd2l0Y2gocy5kdHlwZSl7Y2FzZVwiYm9vbFwiOntsZXQgZz1uLmJ1ZmZlclN5bmMocyksYj0hIW4uZGF0YS5nZXQoaS5kYXRhSWQpLnZhbHVlc1swXTtmPW5pKG0sZyxvLGMscCx1LGwsZCxiLGgpO2JyZWFrfWNhc2VcImZsb2F0MzJcIjp7bGV0IGc9bi5idWZmZXJTeW5jKHMpLGI9bi5kYXRhLmdldChpLmRhdGFJZCkudmFsdWVzWzBdO2Y9bmkobSxnLG8sYyxwLHUsbCxkLGIsaCk7YnJlYWt9Y2FzZVwiaW50MzJcIjp7bGV0IGc9bi5idWZmZXJTeW5jKHMpLGI9bi5kYXRhLmdldChpLmRhdGFJZCkudmFsdWVzWzBdO2Y9bmkobSxnLG8sYyxwLHUsbCxkLGIsaCk7YnJlYWt9Y2FzZVwic3RyaW5nXCI6e2xldCBnPW4uYnVmZmVyU3luYyhzKSxiPXcuZGVjb2RlU3RyaW5nKG4uZGF0YS5nZXQoaS5kYXRhSWQpLnZhbHVlc1swXSk7Zj1uaShtLGcsbyxjLHAsdSxsLGQsYixoKTticmVha31kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSAke3MuZHR5cGV9YCl9cmV0dXJuIG4ubWFrZVRlbnNvckluZm8obyxmLmR0eXBlLGYudmFsdWVzKX12YXIgcko9e2tlcm5lbE5hbWU6SHUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmFKfTtmdW5jdGlvbiBzSihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7bnVtT3JTaXplU3BsaXRzOnMsYXhpczppfT1hLG89dy5wYXJzZUF4aXNQYXJhbShpLHIuc2hhcGUpWzBdLGw9VC5wcmVwYXJlU3BsaXRTaXplKHIscyxvKSx1PW5ldyBBcnJheShyLnNoYXBlLmxlbmd0aCkuZmlsbCgwKSxwPXIuc2hhcGUuc2xpY2UoKTtyZXR1cm4gbC5tYXAoZD0+e2xldCBjPVsuLi5wXTtjW29dPWQ7bGV0IGg9eGkoe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e2JlZ2luOnUsc2l6ZTpjfX0pO3JldHVybiB1W29dKz1kLGh9KX12YXIgaUo9e2tlcm5lbE5hbWU6VXUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOnNKfSxvSj17a2VybmVsTmFtZTpxYyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6KHtpbnB1dHM6ZSxiYWNrZW5kOnR9KT0+e2xldHt4Om59PWUsYT10O2dlKG4sXCJzcXVhcmVcIik7bGV0IHI9YS5kYXRhLmdldChuLmRhdGFJZCkudmFsdWVzLHM9bmV3IEZsb2F0MzJBcnJheShyLmxlbmd0aCk7Zm9yKGxldCBpPTA7aTxyLmxlbmd0aDsrK2kpe2xldCBvPXJbaV07c1tpXT1vKm99cmV0dXJue2RhdGFJZDphLndyaXRlKHMsbi5zaGFwZSxuLmR0eXBlKSxzaGFwZTpuLnNoYXBlLGR0eXBlOm4uZHR5cGV9fX0sbEo9bHQoSXMsKGUsdCk9PntsZXQgbj10O3JldHVybiBpc05hTihlKT9OYU46ZT4wPzE6bi5hbHBoYX0pLHVKPXtrZXJuZWxOYW1lOklzLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpsSn07ZnVuY3Rpb24gcEooZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2JlZ2luOnMsZW5kOmksc3RyaWRlczpvLGJlZ2luTWFzazpsLGVuZE1hc2s6dSxlbGxpcHNpc01hc2s6cCxuZXdBeGlzTWFzazpkLHNocmlua0F4aXNNYXNrOmN9PWE7Z2UocixcInN0cmlkZWRTbGljZVwiKTtsZXR7ZmluYWxTaGFwZVNwYXJzZTpoLGZpbmFsU2hhcGU6bSxpc0lkZW50aXR5OmYsc2xpY2VEaW0wOmcsaXNTaW1wbGVTbGljZTpiLGJlZ2luOnksZW5kOngsc3RyaWRlczp2fT1LdC5zbGljZUluZm8oci5zaGFwZSxzLGksbyxsLHUscCxkLGMpLEk7aWYoZilJPXh0KHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTptfX0pO2Vsc2UgaWYoZ3x8Yil7dy5hc3NlcnQoci5zaGFwZS5sZW5ndGg+PTEsKCk9PmBJbnB1dCBtdXN0IGhhdmUgcmFuayBhdCBsZWFzdCAxLCBnb3Q6ICR7ci5zaGFwZS5sZW5ndGh9YCk7bGV0IE49S3QuY29tcHV0ZU91dFNoYXBlKHkseCx2KSxDPXhpKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntiZWdpbjp5LHNpemU6Tn19KTtJPXh0KHtpbnB1dHM6e3g6Q30sYmFja2VuZDpuLGF0dHJzOntzaGFwZTptfX0pLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oQyl9ZWxzZXtsZXQgTj1uLmJ1ZmZlclN5bmMociksQz1jXyhoLE4sdix5KTtJPW4ubWFrZVRlbnNvckluZm8obSxDLmR0eXBlLEMudmFsdWVzKX1yZXR1cm4gSX12YXIgY0o9e2tlcm5lbE5hbWU6anUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOnBKfTtmdW5jdGlvbiBkSihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3NlcGFyYXRvcjpyLG5HcmFtV2lkdGhzOnMsbGVmdFBhZDppLHJpZ2h0UGFkOm8scGFkV2lkdGg6bCxwcmVzZXJ2ZVNob3J0U2VxdWVuY2VzOnV9PWEse2RhdGE6cCxkYXRhU3BsaXRzOmR9PXQsYz1uLmRhdGEuZ2V0KHAuZGF0YUlkKS52YWx1ZXMsaD1uLmRhdGEuZ2V0KGQuZGF0YUlkKS52YWx1ZXMsW20sZl09VTEoYyxoLHIscyxpLG8sbCx1KTtyZXR1cm5bbi5tYWtlVGVuc29ySW5mbyhbbS5sZW5ndGhdLFwic3RyaW5nXCIsbSksbi5tYWtlVGVuc29ySW5mbyhkLnNoYXBlLFwiaW50MzJcIixmKV19dmFyIGhKPXtrZXJuZWxOYW1lOlhjLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpkSn07ZnVuY3Rpb24gbUooZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtza2lwRW1wdHk6cn09YSx7aW5wdXQ6cyxkZWxpbWl0ZXI6aX09dDtpZihzLmR0eXBlIT09XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBtdXN0IGJlIG9mIGRhdGF0eXBlIHN0cmluZ1wiKTtpZihzLnNoYXBlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBtdXN0IGJlIGEgdmVjdG9yLCBnb3Qgc2hhcGU6ICR7cy5zaGFwZX1gKTtpZihpLnNoYXBlLmxlbmd0aCE9PTApdGhyb3cgbmV3IEVycm9yKGBEZWxpbWl0ZXIgbXVzdCBiZSBhIHNjYWxhciwgZ290IHNoYXBlOiAke2kuc2hhcGV9YCk7bGV0IG89bi5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzLGw9bi5kYXRhLmdldChpLmRhdGFJZCkudmFsdWVzWzBdLFt1LHAsZF09RzEobyxsLHIpLGM9cC5sZW5ndGg7cmV0dXJuW24ubWFrZVRlbnNvckluZm8oW2MsMl0sXCJpbnQzMlwiLHUpLG4ubWFrZVRlbnNvckluZm8oW2NdLFwic3RyaW5nXCIscCksbi5tYWtlVGVuc29ySW5mbyhbMl0sXCJpbnQzMlwiLG5ldyBJbnQzMkFycmF5KGQpKV19dmFyIGZKPXtrZXJuZWxOYW1lOlljLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzptSn07ZnVuY3Rpb24gZ0ooZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtudW1CdWNrZXRzOnJ9PWEse2lucHV0OnN9PXQ7aWYocy5kdHlwZSE9PVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgbXVzdCBiZSBvZiBkYXRhdHlwZSBzdHJpbmdcIik7aWYocjw9MCl0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgb2YgYnVja2V0cyBtdXN0IGJlIGF0IGxlYXN0IDFcIik7bGV0IGk9bi5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzLG89SDEoaSxyKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhzLnNoYXBlLFwiaW50MzJcIixvKX12YXIgYko9e2tlcm5lbE5hbWU6WmMsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmdKfSx5Sj1sdChWbyxlPT5NYXRoLnRhbihlKSkseEo9e2tlcm5lbE5hbWU6Vm8sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOnlKfSx2Sj1sdChVbyxlPT5NYXRoLnRhbmgoZSkpLHdKPXtrZXJuZWxOYW1lOlVvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzp2Sn07ZnVuY3Rpb24ga0ooZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7dGVuc29yOmEsaW5kaWNlczpyLHVwZGF0ZXM6c309dCx7c2xpY2VSYW5rOmksbnVtVXBkYXRlczpvLHNsaWNlU2l6ZTpsLHN0cmlkZXM6dSxvdXRwdXRTaXplOnB9PVQuY2FsY3VsYXRlU2hhcGVzKHMscixhLnNoYXBlKSxkPSExLGM9bi5idWZmZXJTeW5jKHIpLGg9bi5idWZmZXJTeW5jKHMpLG09bi5idWZmZXJTeW5jKGEpLGY9bmkoYyxoLGEuc2hhcGUscCxsLG8saSx1LG0sZCk7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8oYS5zaGFwZSxmLmR0eXBlLGYudmFsdWVzKX12YXIgSUo9e2tlcm5lbE5hbWU6THUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmtKfTtmdW5jdGlvbiBTSihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7cmVwczpzfT1hO2dlKHIsXCJ0aWxlXCIpO2xldCBpPWhfKG4uYnVmZmVyU3luYyhyKSxzKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhpLnNoYXBlLGkuZHR5cGUsaS52YWx1ZXMpfXZhciBOSj17a2VybmVsTmFtZTprcyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6U0p9O2Z1bmN0aW9uIFRKKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtrOnMsc29ydGVkOml9PWE7Z2UocixcInRvcGtcIik7bGV0IG89bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLFtsLHVdPWZfKG8sci5zaGFwZSxyLmR0eXBlLHMsaSk7cmV0dXJuW24ubWFrZVRlbnNvckluZm8obC5zaGFwZSxsLmR0eXBlLGwudmFsdWVzKSxuLm1ha2VUZW5zb3JJbmZvKHUuc2hhcGUsdS5kdHlwZSx1LnZhbHVlcyldfXZhciBDSj17a2VybmVsTmFtZTpxdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6VEp9O2Z1bmN0aW9uIEVKKGUpe2xldHtpbnB1dHM6dCxhdHRyczpuLGJhY2tlbmQ6YX09ZSx7aW1hZ2U6cix0cmFuc2Zvcm1zOnN9PXQse2ludGVycG9sYXRpb246aSxmaWxsTW9kZTpvLGZpbGxWYWx1ZTpsLG91dHB1dFNoYXBlOnV9PW4sW3AsZCxjLGhdPXIuc2hhcGUsW20sZl09dSE9bnVsbD91OltkLGNdLGc9W3AsbSxmLGhdLGI9dy5jb21wdXRlU3RyaWRlcyhyLnNoYXBlKSx5PWJbMF0seD1iWzFdLHY9YlsyXSxJPXcuY29tcHV0ZVN0cmlkZXMoZyksTj1JWzBdLEM9SVsxXSxfPUlbMl0sRj13LmdldFR5cGVkQXJyYXlGcm9tRFR5cGUoci5kdHlwZSx3LnNpemVGcm9tU2hhcGUoZykpO0YuZmlsbChsKTtsZXQgRD1hLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsJD1hLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXM7Zm9yKGxldCBTPTA7UzxwOysrUyl7bGV0IE09cy5zaGFwZVswXT09PTE/JDokLnN1YmFycmF5KFMqOCxTKjgrOCk7Zm9yKGxldCBCPTA7QjxtOysrQilmb3IobGV0IFU9MDtVPGY7KytVKWZvcihsZXQgSD0wO0g8aDsrK0gpe2xldCBxLEs9TVs2XSpVK01bN10qQisxO2lmKEs9PT0wKWNvbnRpbnVlO2xldCBaPShNWzBdKlUrTVsxXSpCK01bMl0pL0ssSj0oTVszXSpVK01bNF0qQitNWzVdKS9LLGVlPXRTKFosYyxvKSxhZT10UyhKLGQsbyk7c3dpdGNoKGkpe2Nhc2VcIm5lYXJlc3RcIjpxPVJKKEQsZCxjLHkseCx2LFMsYWUsZWUsSCxsKTticmVhaztjYXNlXCJiaWxpbmVhclwiOnE9TUooRCxkLGMseSx4LHYsUyxhZSxlZSxILGwpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBFcnJvciBpbiBUcmFuc2Zvcm06IEV4cGVjdCAnbmVhcmVzdCcgb3IgJ2JpbGluZWFyJywgYnV0IGdvdCAke2l9YCl9bGV0IHRlPVMqTitCKkMrVSpfK0g7Rlt0ZV09cX1yZXR1cm4gYS5tYWtlVGVuc29ySW5mbyhnLHIuZHR5cGUsRil9cmV0dXJue2RhdGFJZDphLndyaXRlKEYsZyxyLmR0eXBlKSxzaGFwZTpyLnNoYXBlLGR0eXBlOnIuZHR5cGV9fXZhciBfSj17a2VybmVsTmFtZTpLdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6RUp9O2Z1bmN0aW9uIHRTKGUsdCxuKXtzd2l0Y2gobil7Y2FzZVwicmVmbGVjdFwiOnJldHVybiBBSihlLHQpO2Nhc2VcIndyYXBcIjpyZXR1cm4gRkooZSx0KTtjYXNlXCJuZWFyZXN0XCI6cmV0dXJuIERKKGUsdCk7Y2FzZVwiY29uc3RhbnRcIjpkZWZhdWx0OnJldHVybiAkSihlLHQpfX1mdW5jdGlvbiBBSihlLHQpe2xldCBuPWU7aWYobjwwKWlmKHQ8PTEpbj0wO2Vsc2V7bGV0IGE9Mip0O248YSYmKG49YSpNYXRoLnRydW5jKC1uL2EpK24pLG49bjwtdD9uK2E6LW4tMX1lbHNlIGlmKG4+dC0xKWlmKHQ8PTEpbj0wO2Vsc2V7bGV0IGE9Mip0O24tPWEqTWF0aC50cnVuYyhuL2EpLG4+PXQmJihuPWEtbi0xKX1yZXR1cm4gdy5jbGFtcCgwLG4sdC0xKX1mdW5jdGlvbiBGSihlLHQpe2xldCBuPWU7aWYobjwwKWlmKHQ8PTEpbj0wO2Vsc2V7bGV0IGE9dC0xO24rPXQqKE1hdGgudHJ1bmMoLW4vYSkrMSl9ZWxzZSBpZihuPnQtMSlpZih0PD0xKW49MDtlbHNle2xldCBhPXQtMTtuLT10Kk1hdGgudHJ1bmMobi9hKX1yZXR1cm4gdy5jbGFtcCgwLG4sdC0xKX1mdW5jdGlvbiAkSihlLHQpe3JldHVybiBlfWZ1bmN0aW9uIERKKGUsdCl7cmV0dXJuIHcuY2xhbXAoMCxlLHQtMSl9ZnVuY3Rpb24gYWMoZSx0LG4sYSxyLHMsaSxvLGwsdSxwKXtsZXQgZD1pKmErbypyK2wqcyt1O3JldHVybiAwPD1vJiZvPHQmJjA8PWwmJmw8bj9lW2RdOnB9ZnVuY3Rpb24gUkooZSx0LG4sYSxyLHMsaSxvLGwsdSxwKXtsZXQgZD1NYXRoLnJvdW5kKG8pLGM9TWF0aC5yb3VuZChsKTtyZXR1cm4gYWMoZSx0LG4sYSxyLHMsaSxkLGMsdSxwKX1mdW5jdGlvbiBNSihlLHQsbixhLHIscyxpLG8sbCx1LHApe2xldCBkPU1hdGguZmxvb3IobyksYz1NYXRoLmZsb29yKGwpLGg9ZCsxLG09YysxLGY9KG0tbCkqYWMoZSx0LG4sYSxyLHMsaSxkLGMsdSxwKSsobC1jKSphYyhlLHQsbixhLHIscyxpLGQsbSx1LHApLGc9KG0tbCkqYWMoZSx0LG4sYSxyLHMsaSxoLGMsdSxwKSsobC1jKSphYyhlLHQsbixhLHIscyxpLGgsbSx1LHApO3JldHVybihoLW8pKmYrKG8tZCkqZ31mdW5jdGlvbiBPSihlKXtsZXR7aW5wdXRzOnQsYXR0cnM6bixiYWNrZW5kOmF9PWUse2F4aXM6cn09bix7eDpzfT10O2dlKHMsXCJ1bmlxdWVcIik7bGV0IGk9YS5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzLHtvdXRwdXRWYWx1ZXM6byxvdXRwdXRTaGFwZTpsLGluZGljZXM6dX09cTEoaSxyLHMuc2hhcGUscy5kdHlwZSk7cmV0dXJuW2EubWFrZVRlbnNvckluZm8obCxzLmR0eXBlLG8pLGEubWFrZVRlbnNvckluZm8oW3UubGVuZ3RoXSxcImludDMyXCIsdSldfXZhciBQSj17a2VybmVsTmFtZTpKYyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6T0p9O2Z1bmN0aW9uIExKKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7dmFsdWU6cn09dCx7YXhpczpzfT1hO3M8MCYmKHMrPXIuc2hhcGUubGVuZ3RoKTtsZXQgaT1yLnNoYXBlLmxlbmd0aCxvPXIuc2hhcGVbc10sbD1uZXcgQXJyYXkoaS0xKSx1PTA7Zm9yKGxldCBoPTA7aDxpO2grKyloIT09cyYmKGxbdSsrXT1yLnNoYXBlW2hdKTtsZXQgcD1uZXcgQXJyYXkoaSkuZmlsbCgwKSxkPXIuc2hhcGUuc2xpY2UoKTtkW3NdPTE7bGV0IGM9bmV3IEFycmF5KG8pO2ZvcihsZXQgaD0wO2g8Yy5sZW5ndGg7aCsrKXtwW3NdPWg7bGV0IG09eGkoe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e2JlZ2luOnAsc2l6ZTpkfX0pO2NbaF09eHQoe2lucHV0czp7eDptfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOmx9fSksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhtKX1yZXR1cm4gY312YXIgeko9e2tlcm5lbE5hbWU6WHUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOkxKfTtmdW5jdGlvbiBXSihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cixzZWdtZW50SWRzOnN9PXQse251bVNlZ21lbnRzOml9PWE7Z2UocixcInVuc29ydGVkU2VnbWVudFN1bVwiKTtsZXQgbz1yLnNoYXBlLmxlbmd0aCxsPXMuc2hhcGUubGVuZ3RoLHU9W10scD1bXSxkPW8tbCxjPXM7Zm9yKGxldCBtPTA7bTxkOysrbSl7bGV0IGY9Y20oe2lucHV0czp7aW5wdXQ6Y30sYmFja2VuZDpuLGF0dHJzOntkaW06bSsxfX0pO2M9ZixwLnB1c2goZil9Zm9yKGxldCBtPTA7bTxpOysrbSl7bGV0IGY9dy5jcmVhdGVTY2FsYXJWYWx1ZShtLFwiaW50MzJcIiksZz1uLm1ha2VUZW5zb3JJbmZvKFtdLFwiaW50MzJcIixmKSxiPU9FKHtpbnB1dHM6e2E6ZyxiOmN9LGJhY2tlbmQ6bn0pLHk9YnMoe2lucHV0czp7eDpifSxiYWNrZW5kOm4sYXR0cnM6e2R0eXBlOlwiZmxvYXQzMlwifX0pLHg9emYoe2lucHV0czp7YTp5LGI6cn0sYmFja2VuZDpufSksdj1FZCh7aW5wdXRzOnt4fSxiYWNrZW5kOm4sYXR0cnM6e2F4aXM6MCxrZWVwRGltczohMX19KTt1LnB1c2godikscC5wdXNoKGcpLHAucHVzaChiKSxwLnB1c2goeSkscC5wdXNoKHgpLHAucHVzaCh2KX1sZXQgaD1BXyh7aW5wdXRzOnUsYmFja2VuZDpuLGF0dHJzOntheGlzOjB9fSk7cmV0dXJuIHAuZm9yRWFjaChtPT5uLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG0pKSxofXZhciBCSj17a2VybmVsTmFtZTpRYyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6V0p9LFZKPVtNSyxtOCxQSyx6Syx2OCxCSyxVSyxISyxxSyxYSyxaSyxRSyx0WCxyWCxpWCx1WCxjWCxoWCxmWCxESyxiWCx4WCx3WCxrOCxJWCx5OCxTOCxOWCxmOCxDWCxfWCxBWCwkWCxSWCxPWCxMWCxXWCxWWCxHWCxqWCxLWCxZWCxKWCxlWSx0WSxhWSxzWSxvWSxsWSx1WSxwWSxkWSxmWSxUSyxiWSxOOCxOWSxUOCxUWSxFOCwkWSxEWSxNWSxBOCwkOCxQWSx6WSxCWSxVWSxSOCxPOCxnOCxIWSxFWCxxWSxYWSxaWSxDSyxMOCxXOCxRWSxWOCx0NyxyNyxpNyx1NyxjNyxoNyxtNyxHOCxnNyx5Nyx2NyxrNyxTNyxUNyxFNyxqOCxBNyxENyxQNyxLOCxZOCxXNyxVNyxqNyxKOCxLNyxZNyxaNyxGXyx0WixfSyx0SyxhWixzWixvWix1WixiOCxsdixjWixBSyxGSywkSyxoWixmWixiWix4Wix3WixrWixTWixwSyxUWixGWixEWixQWixkSyx6WixCWixVWixoSyxNNyxqWixLWixZWixKWixlSixuSixySixpSixnSyxvSix5Syx2Syx1SixjSixoSixmSixiSixTSyxoWSx4Six3SixJSixOSixDSixfSixROCxQSix6SixCSixYN107Zm9yKGxldCBlIG9mIFZKKWVkKGUpO3ZhciAkXz17fTtfZSgkXyx7YXNzZXJ0Tm90Q29tcGxleDooKT0+bHAsYmluZENhbnZhc1RvRnJhbWVidWZmZXI6KCk9PlFKLGJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyOigpPT5QaCxiaW5kVGV4dHVyZVRvUHJvZ3JhbVVuaWZvcm1TYW1wbGVyOigpPT5LXyxiaW5kVGV4dHVyZVVuaXQ6KCk9PkhfLGJpbmRWZXJ0ZXhCdWZmZXJUb1Byb2dyYW1BdHRyaWJ1dGU6KCk9PnB2LGNhbGxBbmRDaGVjazooKT0+ZGUsY2FuQmVSZXByZXNlbnRlZDooKT0+Ul8sY3JlYXRlRnJhZ21lbnRTaGFkZXI6KCk9PlBfLGNyZWF0ZUZyYW1lYnVmZmVyOigpPT5HXyxjcmVhdGVQcm9ncmFtOigpPT5MXyxjcmVhdGVTdGF0aWNJbmRleEJ1ZmZlcjooKT0+Ql8sY3JlYXRlU3RhdGljVmVydGV4QnVmZmVyOigpPT5XXyxjcmVhdGVUZXh0dXJlOigpPT5WXyxjcmVhdGVWZXJ0ZXhTaGFkZXI6KCk9Pk9fLGdldEJhdGNoRGltOigpPT52aSxnZXRFeHRlbnNpb25PclRocm93OigpPT5yYyxnZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZTooKT0+WF8sZ2V0TWF4VGV4dHVyZXNJblNoYWRlcjooKT0+UV8sZ2V0TnVtQ2hhbm5lbHM6KCk9PlpKLGdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb246KCk9PnFfLGdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb25PclRocm93OigpPT5qXyxnZXRSb3dzQ29sczooKT0+d2ksZ2V0U2hhcGVBczNEOigpPT5pYyxnZXRUZXh0dXJlU2hhcGVGcm9tTG9naWNhbFNoYXBlOigpPT5aXyxnZXRXZWJHTERpc2pvaW50UXVlcnlUaW1lclZlcnNpb246KCk9PmVBLGdldFdlYkdMRXJyb3JNZXNzYWdlOigpPT5NXyxnZXRXZWJHTE1heFRleHR1cmVTaXplOigpPT5KXyxoYXNFeHRlbnNpb246KCk9PmRhLGlzQ2FwYWJsZU9mUmVuZGVyaW5nVG9GbG9hdFRleHR1cmU6KCk9PnRBLGlzRG93bmxvYWRGbG9hdFRleHR1cmVFbmFibGVkOigpPT5uQSxpc1Jlc2hhcGVGcmVlOigpPT5UYyxpc1dlYkdMRmVuY2VFbmFibGVkOigpPT5hQSxpc1dlYkdMVmVyc2lvbkVuYWJsZWQ6KCk9PmR2LGxpbmtQcm9ncmFtOigpPT56Xyxsb2dTaGFkZXJTb3VyY2VBbmRJbmZvTG9nOigpPT5KMSxyZXNldE1heFRleHR1cmVTaXplOigpPT5lOSxyZXNldE1heFRleHR1cmVzSW5TaGFkZXI6KCk9PnQ5LHVuYmluZENvbG9yVGV4dHVyZUZyb21GcmFtZWJ1ZmZlcjooKT0+Y3YsdW5iaW5kVGV4dHVyZVVuaXQ6KCk9PkpKLHZhbGlkYXRlRnJhbWVidWZmZXI6KCk9PnNjLHZhbGlkYXRlUHJvZ3JhbTooKT0+T2gsdmFsaWRhdGVUZXh0dXJlU2l6ZTooKT0+VV99KTt2YXIgZWk9e30sX2g9e2FscGhhOiExLGFudGlhbGlhczohMSxwcmVtdWx0aXBsaWVkQWxwaGE6ITEscHJlc2VydmVEcmF3aW5nQnVmZmVyOiExLGRlcHRoOiExLHN0ZW5jaWw6ITEsZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDohMH07ZnVuY3Rpb24gRF8oZSx0KXtlaVtlXT10fWZ1bmN0aW9uIGphKGUsdCl7aWYoIShlIGluIGVpKXx8dCE9bnVsbCl7bGV0IGE9R0ooZSx0KTtpZihhIT09bnVsbCllaVtlXT1hO2Vsc2UgcmV0dXJuIGNvbnNvbGUubG9nKFwiQ291bGQgbm90IGdldCBjb250ZXh0IGZvciBXZWJHTCB2ZXJzaW9uXCIsZSksbnVsbH1sZXQgbj1laVtlXTtyZXR1cm4gbj09bnVsbHx8bi5pc0NvbnRleHRMb3N0KCk/KGRlbGV0ZSBlaVtlXSxqYShlKSk6KG4uZGlzYWJsZShuLkRFUFRIX1RFU1QpLG4uZGlzYWJsZShuLlNURU5DSUxfVEVTVCksbi5kaXNhYmxlKG4uQkxFTkQpLG4uZGlzYWJsZShuLkRJVEhFUiksbi5kaXNhYmxlKG4uUE9MWUdPTl9PRkZTRVRfRklMTCksbi5kaXNhYmxlKG4uU0FNUExFX0NPVkVSQUdFKSxuLmVuYWJsZShuLlNDSVNTT1JfVEVTVCksbi5lbmFibGUobi5DVUxMX0ZBQ0UpLG4uY3VsbEZhY2Uobi5CQUNLKSxlaVtlXSl9ZnVuY3Rpb24gVUooZSl7aWYoIUcoKS5nZXRCb29sKFwiSVNfU0FGQVJJXCIpJiZ0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzIT1cInVuZGVmaW5lZFwiJiZlPT09MilyZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygzMDAsMTUwKTtpZih0eXBlb2YgZG9jdW1lbnQhPVwidW5kZWZpbmVkXCIpcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNyZWF0ZSBhIGNhbnZhcyBpbiB0aGlzIGNvbnRleHRcIil9ZnVuY3Rpb24gR0ooZSx0KXtpZihlIT09MSYmZSE9PTIpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBXZWJHTCByZW5kZXJpbmcgY29udGV4dCwgV2ViR0wgaXMgZGlzYWJsZWQuXCIpO2xldCBuPXQ9PW51bGw/VUooZSk6dDtyZXR1cm4gbi5hZGRFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0bG9zdFwiLGE9PnthLnByZXZlbnREZWZhdWx0KCksZGVsZXRlIGVpW2VdfSwhMSksRygpLmdldEJvb2woXCJTT0ZUV0FSRV9XRUJHTF9FTkFCTEVEXCIpJiYoX2guZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdD0hMSksZT09PTE/bi5nZXRDb250ZXh0KFwid2ViZ2xcIixfaCl8fG4uZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLF9oKTpuLmdldENvbnRleHQoXCJ3ZWJnbDJcIixfaCl9dmFyIE5jOyhmdW5jdGlvbihlKXtlW2UuREVOU0U9MF09XCJERU5TRVwiLGVbZS5TSEFSRURfQkFUQ0g9MV09XCJTSEFSRURfQkFUQ0hcIn0pKE5jfHwoTmM9e30pKTt2YXIgY2E7KGZ1bmN0aW9uKGUpe2VbZS5SRU5ERVI9MF09XCJSRU5ERVJcIixlW2UuVVBMT0FEPTFdPVwiVVBMT0FEXCIsZVtlLlBJWEVMUz0yXT1cIlBJWEVMU1wiLGVbZS5ET1dOTE9BRD0zXT1cIkRPV05MT0FEXCJ9KShjYXx8KGNhPXt9KSk7dmFyIGNuOyhmdW5jdGlvbihlKXtlW2UuVU5QQUNLRURfRkxPQVQxNj0wXT1cIlVOUEFDS0VEX0ZMT0FUMTZcIixlW2UuVU5QQUNLRURfRkxPQVQzMj0xXT1cIlVOUEFDS0VEX0ZMT0FUMzJcIixlW2UuUEFDS0VEXzRYMV9VTlNJR05FRF9CWVRFPTJdPVwiUEFDS0VEXzRYMV9VTlNJR05FRF9CWVRFXCIsZVtlLlBBQ0tFRF8yWDJfRkxPQVQzMj0zXT1cIlBBQ0tFRF8yWDJfRkxPQVQzMlwiLGVbZS5QQUNLRURfMlgyX0ZMT0FUMTY9NF09XCJQQUNLRURfMlgyX0ZMT0FUMTZcIn0pKGNufHwoY249e30pKTtmdW5jdGlvbiBfZChlLHQpe3JldHVyblt0LGVdfWZ1bmN0aW9uIEhKKGUsdCl7cmV0dXJuIGUqdH1mdW5jdGlvbiBBaChlKXtsZXQgdD13LnNpemVGcm9tU2hhcGUoZSksbj1NYXRoLmNlaWwodC80KTtyZXR1cm4gdy5zaXplVG9TcXVhcmlzaFNoYXBlKG4pfWZ1bmN0aW9uIG9wKGUsdCl7cmV0dXJuW01hdGgubWF4KDEsTWF0aC5jZWlsKHQvMikpLE1hdGgubWF4KDEsTWF0aC5jZWlsKGUvMikpXX1mdW5jdGlvbiBqSihlLHQpe2xldFtuLGFdPW9wKGUsdCk7cmV0dXJuIG4qYSo0fWZ1bmN0aW9uIFoxKGUsdCl7bGV0IG49ZSxhLHIscyxpLG8sbCx1LHAsZCxjO3JldHVybiBHKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKT09PTI/KGE9bi5SMzJGLHI9bi5SMTZGLHM9bi5SR0JBMTZGLGk9bi5SR0JBMzJGLG89bi5SRUQsdT00LHA9MSxkPW4uSEFMRl9GTE9BVCxjPW4uRkxPQVQsbD1uLlJHQkE4KTooYT1lLlJHQkEscj1lLlJHQkEscz1lLlJHQkEsaT1uLlJHQkEsbz1lLlJHQkEsdT00LHA9NCxkPXQhPW51bGw/dC5IQUxGX0ZMT0FUX09FUzpudWxsLGM9ZS5GTE9BVCxsPWUuUkdCQSkse2ludGVybmFsRm9ybWF0RmxvYXQ6YSxpbnRlcm5hbEZvcm1hdEhhbGZGbG9hdDpyLGludGVybmFsRm9ybWF0UGFja2VkSGFsZkZsb2F0OnMsaW50ZXJuYWxGb3JtYXRQYWNrZWRGbG9hdDppLHRleHR1cmVGb3JtYXRGbG9hdDpvLGRvd25sb2FkVGV4dHVyZUZvcm1hdDpsLGRvd25sb2FkVW5wYWNrTnVtQ2hhbm5lbHM6dSxkZWZhdWx0TnVtQ2hhbm5lbHM6cCx0ZXh0dXJlVHlwZUhhbGZGbG9hdDpkLHRleHR1cmVUeXBlRmxvYXQ6Y319ZnVuY3Rpb24gZGUoZSx0KXtsZXQgbj10KCk7cmV0dXJuIEcoKS5nZXRCb29sKFwiREVCVUdcIikmJnFKKGUpLG59ZnVuY3Rpb24gcUooZSl7bGV0IHQ9ZS5nZXRFcnJvcigpO2lmKHQhPT1lLk5PX0VSUk9SKXRocm93IG5ldyBFcnJvcihcIldlYkdMIEVycm9yOiBcIitNXyhlLHQpKX12YXIgS0o9NTk2ZS0xMCxYSj02NTUwNDtmdW5jdGlvbiBSXyhlKXtyZXR1cm4hIShHKCkuZ2V0Qm9vbChcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRURcIil8fGU9PT0wfHxLSjxNYXRoLmFicyhlKSYmTWF0aC5hYnMoZSk8WEopfWZ1bmN0aW9uIE1fKGUsdCl7c3dpdGNoKHQpe2Nhc2UgZS5OT19FUlJPUjpyZXR1cm5cIk5PX0VSUk9SXCI7Y2FzZSBlLklOVkFMSURfRU5VTTpyZXR1cm5cIklOVkFMSURfRU5VTVwiO2Nhc2UgZS5JTlZBTElEX1ZBTFVFOnJldHVyblwiSU5WQUxJRF9WQUxVRVwiO2Nhc2UgZS5JTlZBTElEX09QRVJBVElPTjpyZXR1cm5cIklOVkFMSURfT1BFUkFUSU9OXCI7Y2FzZSBlLklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OOnJldHVyblwiSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT05cIjtjYXNlIGUuT1VUX09GX01FTU9SWTpyZXR1cm5cIk9VVF9PRl9NRU1PUllcIjtjYXNlIGUuQ09OVEVYVF9MT1NUX1dFQkdMOnJldHVyblwiQ09OVEVYVF9MT1NUX1dFQkdMXCI7ZGVmYXVsdDpyZXR1cm5gVW5rbm93biBlcnJvciBjb2RlICR7dH1gfX1mdW5jdGlvbiByYyhlLHQpe3JldHVybiBPcihlLCgpPT5lLmdldEV4dGVuc2lvbih0KSwnRXh0ZW5zaW9uIFwiJyt0KydcIiBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlci4nKX1mdW5jdGlvbiBPXyhlLHQpe2xldCBuPU9yKGUsKCk9PmUuY3JlYXRlU2hhZGVyKGUuVkVSVEVYX1NIQURFUiksXCJVbmFibGUgdG8gY3JlYXRlIHZlcnRleCBXZWJHTFNoYWRlci5cIik7aWYoZGUoZSwoKT0+ZS5zaGFkZXJTb3VyY2Uobix0KSksZGUoZSwoKT0+ZS5jb21waWxlU2hhZGVyKG4pKSxlLmdldFNoYWRlclBhcmFtZXRlcihuLGUuQ09NUElMRV9TVEFUVVMpPT09ITEpdGhyb3cgY29uc29sZS5sb2coZS5nZXRTaGFkZXJJbmZvTG9nKG4pKSxuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY29tcGlsZSB2ZXJ0ZXggc2hhZGVyLlwiKTtyZXR1cm4gbn1mdW5jdGlvbiBQXyhlLHQpe2xldCBuPU9yKGUsKCk9PmUuY3JlYXRlU2hhZGVyKGUuRlJBR01FTlRfU0hBREVSKSxcIlVuYWJsZSB0byBjcmVhdGUgZnJhZ21lbnQgV2ViR0xTaGFkZXIuXCIpO2lmKGRlKGUsKCk9PmUuc2hhZGVyU291cmNlKG4sdCkpLGRlKGUsKCk9PmUuY29tcGlsZVNoYWRlcihuKSksRygpLmdldChcIkVOR0lORV9DT01QSUxFX09OTFlcIikpcmV0dXJuIG47aWYoZS5nZXRTaGFkZXJQYXJhbWV0ZXIobixlLkNPTVBJTEVfU1RBVFVTKT09PSExKXRocm93IEoxKHQsZS5nZXRTaGFkZXJJbmZvTG9nKG4pKSxuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY29tcGlsZSBmcmFnbWVudCBzaGFkZXIuXCIpO3JldHVybiBufXZhciBZSj0vRVJST1I6IFswLTldKzooWzAtOV0rKTovZztmdW5jdGlvbiBKMShlLHQpe2xldCBuPVlKLmV4ZWModCk7aWYobj09bnVsbCl7Y29uc29sZS5sb2coYENvdWxkbid0IHBhcnNlIGxpbmUgbnVtYmVyIGluIGVycm9yOiAke3R9YCksY29uc29sZS5sb2coZSk7cmV0dXJufWxldCBhPStuWzFdLHI9ZS5zcGxpdChgXG5gKSxzPXIubGVuZ3RoLnRvU3RyaW5nKCkubGVuZ3RoKzIsaT1yLm1hcCgoZCxjKT0+dy5yaWdodFBhZCgoYysxKS50b1N0cmluZygpLHMpK2QpLG89MDtmb3IobGV0IGQ9MDtkPGkubGVuZ3RoO2QrKylvPU1hdGgubWF4KGlbZF0ubGVuZ3RoLG8pO2xldCBsPWkuc2xpY2UoMCxhLTEpLHU9aS5zbGljZShhLTEsYSkscD1pLnNsaWNlKGEpO2NvbnNvbGUubG9nKGwuam9pbihgXG5gKSksY29uc29sZS5sb2codC5zcGxpdChgXG5gKVswXSksY29uc29sZS5sb2coYCVjICR7dy5yaWdodFBhZCh1WzBdLG8pfWAsXCJib3JkZXI6MXB4IHNvbGlkIHJlZDsgYmFja2dyb3VuZC1jb2xvcjojZTNkMmQyOyBjb2xvcjojYTYxNzE3XCIpLGNvbnNvbGUubG9nKHAuam9pbihgXG5gKSl9ZnVuY3Rpb24gTF8oZSl7cmV0dXJuIE9yKGUsKCk9PmUuY3JlYXRlUHJvZ3JhbSgpLFwiVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTFByb2dyYW0uXCIpfWZ1bmN0aW9uIHpfKGUsdCl7aWYoZGUoZSwoKT0+ZS5saW5rUHJvZ3JhbSh0KSksIUcoKS5nZXQoXCJFTkdJTkVfQ09NUElMRV9PTkxZXCIpJiZlLmdldFByb2dyYW1QYXJhbWV0ZXIodCxlLkxJTktfU1RBVFVTKT09PSExKXRocm93IGNvbnNvbGUubG9nKGUuZ2V0UHJvZ3JhbUluZm9Mb2codCkpLG5ldyBFcnJvcihcIkZhaWxlZCB0byBsaW5rIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVycy5cIil9ZnVuY3Rpb24gT2goZSx0KXtpZihkZShlLCgpPT5lLnZhbGlkYXRlUHJvZ3JhbSh0KSksZS5nZXRQcm9ncmFtUGFyYW1ldGVyKHQsZS5WQUxJREFURV9TVEFUVVMpPT09ITEpdGhyb3cgY29uc29sZS5sb2coZS5nZXRQcm9ncmFtSW5mb0xvZyh0KSksbmV3IEVycm9yKFwiU2hhZGVyIHByb2dyYW0gdmFsaWRhdGlvbiBmYWlsZWQuXCIpfWZ1bmN0aW9uIFdfKGUsdCl7bGV0IG49T3IoZSwoKT0+ZS5jcmVhdGVCdWZmZXIoKSxcIlVuYWJsZSB0byBjcmVhdGUgV2ViR0xCdWZmZXJcIik7cmV0dXJuIGRlKGUsKCk9PmUuYmluZEJ1ZmZlcihlLkFSUkFZX0JVRkZFUixuKSksZGUoZSwoKT0+ZS5idWZmZXJEYXRhKGUuQVJSQVlfQlVGRkVSLHQsZS5TVEFUSUNfRFJBVykpLG59ZnVuY3Rpb24gQl8oZSx0KXtsZXQgbj1PcihlLCgpPT5lLmNyZWF0ZUJ1ZmZlcigpLFwiVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEJ1ZmZlclwiKTtyZXR1cm4gZGUoZSwoKT0+ZS5iaW5kQnVmZmVyKGUuRUxFTUVOVF9BUlJBWV9CVUZGRVIsbikpLGRlKGUsKCk9PmUuYnVmZmVyRGF0YShlLkVMRU1FTlRfQVJSQVlfQlVGRkVSLHQsZS5TVEFUSUNfRFJBVykpLG59ZnVuY3Rpb24gWkooKXtyZXR1cm4gRygpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik9PT0yPzE6NH1mdW5jdGlvbiBWXyhlKXtyZXR1cm4gT3IoZSwoKT0+ZS5jcmVhdGVUZXh0dXJlKCksXCJVbmFibGUgdG8gY3JlYXRlIFdlYkdMVGV4dHVyZS5cIil9ZnVuY3Rpb24gVV8oZSx0KXtsZXQgbj1HKCkuZ2V0TnVtYmVyKFwiV0VCR0xfTUFYX1RFWFRVUkVfU0laRVwiKTtpZihlPD0wfHx0PD0wKXtsZXQgYT1gWyR7ZX14JHt0fV1gO3Rocm93IG5ldyBFcnJvcihcIlJlcXVlc3RlZCB0ZXh0dXJlIHNpemUgXCIrYStcIiBpcyBpbnZhbGlkLlwiKX1pZihlPm58fHQ+bil7bGV0IGE9YFske2V9eCR7dH1dYCxyPWBbJHtufXgke259XWA7dGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdGVkIHRleHR1cmUgc2l6ZSBcIithK1wiIGdyZWF0ZXIgdGhhbiBXZWJHTCBtYXhpbXVtIG9uIHRoaXMgYnJvd3NlciAvIEdQVSBcIityK1wiLlwiKX19ZnVuY3Rpb24gR18oZSl7cmV0dXJuIE9yKGUsKCk9PmUuY3JlYXRlRnJhbWVidWZmZXIoKSxcIlVuYWJsZSB0byBjcmVhdGUgV2ViR0xGcmFtZWJ1ZmZlci5cIil9ZnVuY3Rpb24gcHYoZSx0LG4sYSxyLHMsaSl7bGV0IG89ZS5nZXRBdHRyaWJMb2NhdGlvbih0LG4pO3JldHVybiBvPT09LTE/ITE6KGRlKGUsKCk9PmUuYmluZEJ1ZmZlcihlLkFSUkFZX0JVRkZFUixhKSksZGUoZSwoKT0+ZS52ZXJ0ZXhBdHRyaWJQb2ludGVyKG8scixlLkZMT0FULCExLHMsaSkpLGRlKGUsKCk9PmUuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobykpLCEwKX1mdW5jdGlvbiBIXyhlLHQsbil7WV8oZSxuKSxkZShlLCgpPT5lLmFjdGl2ZVRleHR1cmUoZS5URVhUVVJFMCtuKSksZGUoZSwoKT0+ZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsdCkpfWZ1bmN0aW9uIEpKKGUsdCl7WV8oZSx0KSxkZShlLCgpPT5lLmFjdGl2ZVRleHR1cmUoZS5URVhUVVJFMCt0KSksZGUoZSwoKT0+ZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsbnVsbCkpfWZ1bmN0aW9uIGpfKGUsdCxuKXtyZXR1cm4gT3IoZSwoKT0+ZS5nZXRVbmlmb3JtTG9jYXRpb24odCxuKSwndW5pZm9ybSBcIicrbisnXCIgbm90IHByZXNlbnQgaW4gcHJvZ3JhbS4nKX1mdW5jdGlvbiBxXyhlLHQsbil7cmV0dXJuIGUuZ2V0VW5pZm9ybUxvY2F0aW9uKHQsbil9ZnVuY3Rpb24gS18oZSx0LG4sYSl7ZGUoZSwoKT0+SF8oZSx0LGEpKSxkZShlLCgpPT5lLnVuaWZvcm0xaShuLGEpKX1mdW5jdGlvbiBRSihlKXtkZShlLCgpPT5lLmJpbmRGcmFtZWJ1ZmZlcihlLkZSQU1FQlVGRkVSLG51bGwpKSxkZShlLCgpPT5lLnZpZXdwb3J0KDAsMCxlLmNhbnZhcy53aWR0aCxlLmNhbnZhcy5oZWlnaHQpKSxkZShlLCgpPT5lLnNjaXNzb3IoMCwwLGUuY2FudmFzLndpZHRoLGUuY2FudmFzLmhlaWdodCkpfWZ1bmN0aW9uIFBoKGUsdCxuKXtkZShlLCgpPT5lLmJpbmRGcmFtZWJ1ZmZlcihlLkZSQU1FQlVGRkVSLG4pKSxkZShlLCgpPT5lLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGUuRlJBTUVCVUZGRVIsZS5DT0xPUl9BVFRBQ0hNRU5UMCxlLlRFWFRVUkVfMkQsdCwwKSl9ZnVuY3Rpb24gY3YoZSx0KXtkZShlLCgpPT5lLmJpbmRGcmFtZWJ1ZmZlcihlLkZSQU1FQlVGRkVSLHQpKSxkZShlLCgpPT5lLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGUuRlJBTUVCVUZGRVIsZS5DT0xPUl9BVFRBQ0hNRU5UMCxlLlRFWFRVUkVfMkQsbnVsbCwwKSl9ZnVuY3Rpb24gc2MoZSl7bGV0IHQ9ZS5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGUuRlJBTUVCVUZGRVIpO2lmKHQhPT1lLkZSQU1FQlVGRkVSX0NPTVBMRVRFKXRocm93IG5ldyBFcnJvcihcIkVycm9yIGJpbmRpbmcgZnJhbWVidWZmZXI6IFwiK1hfKGUsdCkpfWZ1bmN0aW9uIFhfKGUsdCl7c3dpdGNoKHQpe2Nhc2UgZS5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQ6cmV0dXJuXCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlRcIjtjYXNlIGUuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQ6cmV0dXJuXCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVFwiO2Nhc2UgZS5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlM6cmV0dXJuXCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlNcIjtjYXNlIGUuRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQ6cmV0dXJuXCJGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRFwiO2RlZmF1bHQ6cmV0dXJuYHVua25vd24gZXJyb3IgJHt0fWB9fWZ1bmN0aW9uIE9yKGUsdCxuKXtsZXQgYT1kZShlLCgpPT50KCkpO2lmKGE9PW51bGwpdGhyb3cgbmV3IEVycm9yKG4pO3JldHVybiBhfWZ1bmN0aW9uIFlfKGUsdCl7bGV0IG49ZS5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUy0xLGE9dCtlLlRFWFRVUkUwO2lmKGE8ZS5URVhUVVJFMHx8YT5uKXtsZXQgcj1gW2dsLlRFWFRVUkUwLCBnbC5URVhUVVJFJHtufV1gO3Rocm93IG5ldyBFcnJvcihgdGV4dHVyZVVuaXQgbXVzdCBiZSBpbiAke3J9LmApfX1mdW5jdGlvbiB2aShlLHQ9Mil7cmV0dXJuIHcuc2l6ZUZyb21TaGFwZShlLnNsaWNlKDAsZS5sZW5ndGgtdCkpfWZ1bmN0aW9uIHdpKGUpe2lmKGUubGVuZ3RoPT09MCl0aHJvdyBFcnJvcihcIkNhbm5vdCBnZXQgcm93cyBhbmQgY29sdW1ucyBvZiBhbiBlbXB0eSBzaGFwZSBhcnJheS5cIik7cmV0dXJuW2UubGVuZ3RoPjE/ZVtlLmxlbmd0aC0yXToxLGVbZS5sZW5ndGgtMV1dfWZ1bmN0aW9uIGljKGUpe2xldCB0PVsxLDEsMV07cmV0dXJuIGUubGVuZ3RoPT09MHx8ZS5sZW5ndGg9PT0xJiZlWzBdPT09MXx8KHQ9W3ZpKGUpLC4uLndpKGUpXSksdH1mdW5jdGlvbiBaXyhlLHQ9ITEpe2xldCBuPUcoKS5nZXROdW1iZXIoXCJXRUJHTF9NQVhfVEVYVFVSRV9TSVpFXCIpLGE9RygpLmdldE51bWJlcihcIldFQkdMX01BWF9TSVpFX0ZPUl9OQVJST1dfVEVYVFVSRVwiKTthPT09MS8wJiZHKCkuZ2V0Qm9vbChcIldFQkdMX0FVVE9fU1FVQVJJRllfTkFSUk9XX1RFWFRVUkVfU0hBUEVcIikmJihhPW4vMiksdCYmKG49bioyLGE9YSoyLGU9ZS5tYXAoKG8sbCk9Pmw+PWUubGVuZ3RoLTI/dy5uZWFyZXN0TGFyZ2VyRXZlbihlW2xdKTplW2xdKSxlLmxlbmd0aD09PTEmJihlPVsyLGVbMF1dKSksZS5sZW5ndGghPT0yJiYoZT13LnNxdWVlemVTaGFwZShlKS5uZXdTaGFwZSk7bGV0IHI9dy5zaXplRnJvbVNoYXBlKGUpLHM9bnVsbDtlLmxlbmd0aDw9MSYmcjw9bj9zPVsxLHJdOmUubGVuZ3RoPT09MiYmZVswXTw9biYmZVsxXTw9bj9zPWU6ZS5sZW5ndGg9PT0zJiZlWzBdKmVbMV08PW4mJmVbMl08PW4/cz1bZVswXSplWzFdLGVbMl1dOmUubGVuZ3RoPT09MyYmZVswXTw9biYmZVsxXSplWzJdPD1uP3M9W2VbMF0sZVsxXSplWzJdXTplLmxlbmd0aD09PTQmJmVbMF0qZVsxXSplWzJdPD1uJiZlWzNdPD1uP3M9W2VbMF0qZVsxXSplWzJdLGVbM11dOmUubGVuZ3RoPT09NCYmZVswXTw9biYmZVsxXSplWzJdKmVbM108PW4mJihzPVtlWzBdLGVbMV0qZVsyXSplWzNdXSk7bGV0IGk9cyE9bnVsbCYmTWF0aC5tYXgoLi4ucyk+YSYmTWF0aC5taW4oLi4ucyk8PSh0PzI6MSkmJk1hdGgubWluKC4uLnMpPjA7aWYocz09bnVsbHx8aSlpZih0KXtsZXQgbz12aShlKSxsPTIsdT0yO2UubGVuZ3RoJiYoW2wsdV09d2koZSkpLHI9byoobC8yKSoodS8yKSxzPXcuc2l6ZVRvU3F1YXJpc2hTaGFwZShyKS5tYXAocD0+cCoyKX1lbHNlIHM9dy5zaXplVG9TcXVhcmlzaFNoYXBlKHIpO3JldHVybiBzfWZ1bmN0aW9uIEZoKGUpe3JldHVybiBlJTI9PT0wfWZ1bmN0aW9uIFRjKGUsdCl7aWYoZT1lLnNsaWNlKC0yKSx0PXQuc2xpY2UoLTIpLHcuYXJyYXlzRXF1YWwoZSx0KXx8IWUubGVuZ3RofHwhdC5sZW5ndGh8fGVbMF09PT0wfHxlWzFdPT09MHx8dFswXT09PTB8fHRbMV09PT0wKXJldHVybiEwO2lmKGUubGVuZ3RoIT09dC5sZW5ndGgpe2xldCBuPWVbZS5sZW5ndGgtMV0sYT10W3QubGVuZ3RoLTFdO2lmKG49PT1hfHxGaChuKSYmRmgoYSkmJihlWzBdPT09MXx8dFswXT09PTEpKXJldHVybiEwfXJldHVybiBlWzFdPT09dFsxXSYmRmgoZVswXSkmJkZoKHRbMF0pfXZhciBMaCx6aDtmdW5jdGlvbiBKXyhlKXtpZihMaD09bnVsbCl7bGV0IHQ9amEoZSk7TGg9dC5nZXRQYXJhbWV0ZXIodC5NQVhfVEVYVFVSRV9TSVpFKX1yZXR1cm4gTGh9ZnVuY3Rpb24gZTkoKXtMaD1udWxsfWZ1bmN0aW9uIHQ5KCl7emg9bnVsbH1mdW5jdGlvbiBRXyhlKXtpZih6aD09bnVsbCl7bGV0IHQ9amEoZSk7emg9dC5nZXRQYXJhbWV0ZXIodC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyl9cmV0dXJuIE1hdGgubWluKDE2LHpoKX1mdW5jdGlvbiBlQShlKXtpZihlPT09MClyZXR1cm4gMDtsZXQgdCxuPWphKGUpO3JldHVybiBkYShuLFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMlwiKSYmZT09PTI/dD0yOmRhKG4sXCJFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlcIik/dD0xOnQ9MCx0fWZ1bmN0aW9uIGRhKGUsdCl7cmV0dXJuIGUuZ2V0RXh0ZW5zaW9uKHQpIT1udWxsfWZ1bmN0aW9uIGR2KGUpe3RyeXtpZihqYShlKSE9bnVsbClyZXR1cm4hMH1jYXRjaCh0KXtyZXR1cm4gY29uc29sZS5sb2coXCJFcnJvciB3aGVuIGdldHRpbmcgV2ViR0wgY29udGV4dDogXCIsdCksITF9cmV0dXJuITF9ZnVuY3Rpb24gdEEoZSl7aWYoZT09PTApcmV0dXJuITE7bGV0IHQ9amEoZSk7aWYoZT09PTEpe2lmKCFkYSh0LFwiT0VTX3RleHR1cmVfZmxvYXRcIikpcmV0dXJuITF9ZWxzZSBpZighZGEodCxcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIikpcmV0dXJuITE7cmV0dXJuIGh2KHQpfWZ1bmN0aW9uIG5BKGUpe2lmKGU9PT0wKXJldHVybiExO2xldCB0PWphKGUpO2lmKGU9PT0xKXtpZighZGEodCxcIk9FU190ZXh0dXJlX2Zsb2F0XCIpfHwhZGEodCxcIldFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKSlyZXR1cm4hMX1lbHNle2lmKGRhKHQsXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpKXJldHVybiBodih0KTtsZXQgbj1cIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdFwiO2lmKGRhKHQsbikpe2xldCBhPXQuZ2V0RXh0ZW5zaW9uKG4pO3JldHVybiBuOSh0LGEpfXJldHVybiExfXJldHVybiBodih0KX1mdW5jdGlvbiBodihlKXtsZXQgdD1aMShlKSxuPWUuY3JlYXRlVGV4dHVyZSgpO2UuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELG4pLGUudGV4SW1hZ2UyRChlLlRFWFRVUkVfMkQsMCx0LmludGVybmFsRm9ybWF0RmxvYXQsMSwxLDAsdC50ZXh0dXJlRm9ybWF0RmxvYXQsdC50ZXh0dXJlVHlwZUZsb2F0LG51bGwpO2xldCBhPWUuY3JlYXRlRnJhbWVidWZmZXIoKTtlLmJpbmRGcmFtZWJ1ZmZlcihlLkZSQU1FQlVGRkVSLGEpLGUuZnJhbWVidWZmZXJUZXh0dXJlMkQoZS5GUkFNRUJVRkZFUixlLkNPTE9SX0FUVEFDSE1FTlQwLGUuVEVYVFVSRV8yRCxuLDApO2xldCByPWUuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhlLkZSQU1FQlVGRkVSKT09PWUuRlJBTUVCVUZGRVJfQ09NUExFVEU7cmV0dXJuIGUuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELG51bGwpLGUuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsbnVsbCksZS5kZWxldGVUZXh0dXJlKG4pLGUuZGVsZXRlRnJhbWVidWZmZXIoYSkscn1mdW5jdGlvbiBuOShlLHQpe2xldCBuPVoxKGUsdCksYT1lLmNyZWF0ZVRleHR1cmUoKTtlLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCxhKSxlLnRleEltYWdlMkQoZS5URVhUVVJFXzJELDAsbi5pbnRlcm5hbEZvcm1hdEhhbGZGbG9hdCwxLDEsMCxuLnRleHR1cmVGb3JtYXRGbG9hdCxuLnRleHR1cmVUeXBlSGFsZkZsb2F0LG51bGwpO2xldCByPWUuY3JlYXRlRnJhbWVidWZmZXIoKTtlLmJpbmRGcmFtZWJ1ZmZlcihlLkZSQU1FQlVGRkVSLHIpLGUuZnJhbWVidWZmZXJUZXh0dXJlMkQoZS5GUkFNRUJVRkZFUixlLkNPTE9SX0FUVEFDSE1FTlQwLGUuVEVYVFVSRV8yRCxhLDApO2xldCBzPWUuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhlLkZSQU1FQlVGRkVSKT09PWUuRlJBTUVCVUZGRVJfQ09NUExFVEU7cmV0dXJuIGUuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELG51bGwpLGUuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsbnVsbCksZS5kZWxldGVUZXh0dXJlKGEpLGUuZGVsZXRlRnJhbWVidWZmZXIociksc31mdW5jdGlvbiBhQShlKXtyZXR1cm4gZSE9PTI/ITE6amEoZSkuZmVuY2VTeW5jIT1udWxsfWZ1bmN0aW9uIGxwKGUsdCl7QXJyYXkuaXNBcnJheShlKXx8KGU9W2VdKSxlLmZvckVhY2gobj0+e24hPW51bGwmJncuYXNzZXJ0KG4uZHR5cGUhPT1cImNvbXBsZXg2NFwiLCgpPT5gJHt0fSBkb2VzIG5vdCBzdXBwb3J0IGNvbXBsZXg2NCB0ZW5zb3JzIGluIHRoZSBXZWJHTCBiYWNrZW5kLmApfSl9dmFyIGJlPUcoKTtiZS5yZWdpc3RlckZsYWcoXCJIQVNfV0VCR0xcIiwoKT0+YmUuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKT4wKTtiZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9WRVJTSU9OXCIsKCk9PmR2KDIpPzI6ZHYoMSk/MTowKTtiZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9DSEVDS19OVU1FUklDQUxfUFJPQkxFTVNcIiwoKT0+ITEpO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0JVRkZFUl9TVVBQT1JURURcIiwoKT0+YmUuZ2V0KFwiV0VCR0xfVkVSU0lPTlwiKT09PTIpO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0NQVV9GT1JXQVJEXCIsKCk9PiEwKTtiZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9GT1JDRV9GMTZfVEVYVFVSRVNcIiwoKT0+ITEpO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tcIiwoKT0+YmUuZ2V0Qm9vbChcIkhBU19XRUJHTFwiKSk7YmUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19OT1JNQUxJWkFUSU9OXCIsKCk9PmJlLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpKTtiZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX0NMSVBcIiwoKT0+YmUuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIikpO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfREVQVEhXSVNFQ09OVlwiLCgpPT5iZS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKSk7YmUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiLCgpPT5iZS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKSk7YmUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19VTkFSWV9PUEVSQVRJT05TXCIsKCk9PmJlLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpKTtiZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX0FSUkFZX09QRVJBVElPTlNcIiwoKT0+YmUuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIikpO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfSU1BR0VfT1BFUkFUSU9OU1wiLCgpPT5iZS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKSk7YmUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19SRURVQ0VcIiwoKT0+YmUuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIikpO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0xBWklMWV9VTlBBQ0tcIiwoKT0+YmUuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIikpO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0NPTlZfSU0yQ09MXCIsKCk9PmJlLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpKTtiZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX0NPTlYyRFRSQU5TUE9TRVwiLCgpPT5iZS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKSk7YmUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfTUFYX1RFWFRVUkVfU0laRVwiLCgpPT5KXyhiZS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKSk7YmUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfTUFYX1RFWFRVUkVTX0lOX1NIQURFUlwiLCgpPT5RXyhiZS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKSk7YmUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIiwoKT0+e2xldCBlPWJlLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik7cmV0dXJuIGU9PT0wPzA6ZUEoZSl9KTtiZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fUkVMSUFCTEVcIiwoKT0+YmUuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIik+MCYmIWFkLmlzTW9iaWxlKCkpO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0NBUEFCTEVcIiwoKT0+dEEoYmUuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSkpO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRURcIiwoKT0+YmUuZ2V0Qm9vbChcIldFQkdMX0ZPUkNFX0YxNl9URVhUVVJFU1wiKT8hMTpiZS5nZXRCb29sKFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfQ0FQQUJMRVwiKSk7YmUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfRE9XTkxPQURfRkxPQVRfRU5BQkxFRFwiLCgpPT5uQShiZS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKSk7YmUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfRkVOQ0VfQVBJX0VOQUJMRURcIiwoKT0+YUEoYmUuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSkpO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1NJWkVfVVBMT0FEX1VOSUZPUk1cIiwoKT0+YmUuZ2V0Qm9vbChcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRURcIik/NDowKTtiZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9ERUxFVEVfVEVYVFVSRV9USFJFU0hPTERcIiwoKT0+LTEsZT0+e2lmKHR5cGVvZiBlIT1cIm51bWJlclwiKXRocm93IG5ldyBFcnJvcihgV0VCR0xfREVMRVRFX1RFWFRVUkVfVEhSRVNIT0xEIG11c3QgYmUgYSBudW1iZXIgYnV0IGdvdCAke2V9LmApO2lmKGU8MCYmZSE9PS0xKXRocm93IG5ldyBFcnJvcihgV0VCR0xfREVMRVRFX1RFWFRVUkVfVEhSRVNIT0xEIG11c3QgYmUgLTEgKGluZGljYXRpbmcgbmV2ZXIgZGVsZXRlKSBvciBhdCBsZWFzdCAwLCBidXQgZ290ICR7ZX0uYCl9KTtiZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9GTFVTSF9USFJFU0hPTERcIiwoKT0+YWQuaXNNb2JpbGUoKT8xOi0xLGU9PntpZih0eXBlb2YgZSE9XCJudW1iZXJcIil0aHJvdyBuZXcgRXJyb3IoYFdFQkdMX0ZMVVNIX1RIUkVTSE9MRCBtdXN0IGJlIGEgbnVtYmVyIGJ1dCBnb3QgJHtlfS5gKTtpZihlPDAmJmUhPT0tMSl0aHJvdyBuZXcgRXJyb3IoYFdFQkdMX0ZMVVNIX1RIUkVTSE9MRCBtdXN0IGJlIC0xIChpbmRpY2F0aW5nIG5ldmVyIG1hbnVhbCBmbHVzaCkgb3IgYXQgbGVhc3QgMCwgYnV0IGdvdCAke2V9LmApfSk7YmUucmVnaXN0ZXJGbGFnKFwiQ1BVX0hBTkRPRkZfU0laRV9USFJFU0hPTERcIiwoKT0+MTI4KTtiZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9VU0VfU0hBUEVTX1VOSUZPUk1TXCIsKCk9PiExKTtiZS5yZWdpc3RlckZsYWcoXCJUT1BLX0xBU1RfRElNX0NQVV9IQU5ET0ZGX1NJWkVfVEhSRVNIT0xEXCIsKCk9PjFlNSk7YmUucmVnaXN0ZXJGbGFnKFwiVE9QS19LX0NQVV9IQU5ET0ZGX1RIUkVTSE9MRFwiLCgpPT4xMjgpO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0VYUF9DT05WXCIsKCk9PiExKTtiZS5yZWdpc3RlckZsYWcoXCJTT0ZUV0FSRV9XRUJHTF9FTkFCTEVEXCIsKCk9PmJlLmdldEJvb2woXCJJU19URVNUXCIpKTtiZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9NQVhfU0laRV9GT1JfTkFSUk9XX1RFWFRVUkVcIiwoKT0+MS8wKTtiZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9BVVRPX1NRVUFSSUZZX05BUlJPV19URVhUVVJFX1NIQVBFXCIsKCk9PiExKTtiZS5yZWdpc3RlckZsYWcoXCJXRUJHTDJfSVNOQU5fQ1VTVE9NXCIsKCk9PiExKTtiZS5yZWdpc3RlckZsYWcoXCJFTkdJTkVfQ09NUElMRV9PTkxZXCIsKCk9PiExKTtmdW5jdGlvbiBFbigpe2xldCBlLHQsbixhLHIscyxpLG8sbCx1O3JldHVybiBHKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKT09PTI/KGU9XCIjdmVyc2lvbiAzMDAgZXNcIix0PVwiaW5cIixuPVwib3V0XCIsYT1cImluXCIscj1cInRleHR1cmVcIixzPVwib3V0cHV0Q29sb3JcIixpPVwib3V0IHZlYzQgb3V0cHV0Q29sb3I7XCIsbz1HKCkuZ2V0Qm9vbChcIldFQkdMMl9JU05BTl9DVVNUT01cIik/YFxuICAgICAgYm9vbCBpc25hbl9jdXN0b20oZmxvYXQgdmFsKSB7XG4gICAgICAgIHVpbnQgZmxvYXRUb1VpbnQgPSBmbG9hdEJpdHNUb1VpbnQodmFsKTtcbiAgICAgICAgcmV0dXJuIChmbG9hdFRvVWludCAmIDB4N2ZmZmZmZmZ1KSA+IDB4N2Y4MDAwMDB1O1xuICAgICAgfVxuXG4gICAgICBidmVjNCBpc25hbl9jdXN0b20odmVjNCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIGJ2ZWM0KGlzbmFuX2N1c3RvbSh2YWwueCksXG4gICAgICAgICAgaXNuYW5fY3VzdG9tKHZhbC55KSwgaXNuYW5fY3VzdG9tKHZhbC56KSwgaXNuYW5fY3VzdG9tKHZhbC53KSk7XG4gICAgICB9XG5cbiAgICAgICNkZWZpbmUgaXNuYW4odmFsdWUpIGlzbmFuX2N1c3RvbSh2YWx1ZSlcbiAgICBgOlwiXCIsbD1cIlwiLHU9YFxuICAgICAgI2RlZmluZSByb3VuZCh2YWx1ZSkgbmV3Um91bmQodmFsdWUpXG4gICAgICBpbnQgbmV3Um91bmQoZmxvYXQgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGludChmbG9vcih2YWx1ZSArIDAuNSkpO1xuICAgICAgfVxuXG4gICAgICBpdmVjNCBuZXdSb3VuZCh2ZWM0IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpdmVjNChmbG9vcih2YWx1ZSArIHZlYzQoMC41KSkpO1xuICAgICAgfVxuICAgIGApOihlPVwiXCIsdD1cImF0dHJpYnV0ZVwiLG49XCJ2YXJ5aW5nXCIsYT1cInZhcnlpbmdcIixyPVwidGV4dHVyZTJEXCIscz1cImdsX0ZyYWdDb2xvclwiLGk9XCJcIixvPWBcbiAgICAgICNkZWZpbmUgaXNuYW4odmFsdWUpIGlzbmFuX2N1c3RvbSh2YWx1ZSlcbiAgICAgIGJvb2wgaXNuYW5fY3VzdG9tKGZsb2F0IHZhbCkge1xuICAgICAgICByZXR1cm4gKHZhbCA+IDAuIHx8IHZhbCA8IDEuIHx8IHZhbCA9PSAwLikgPyBmYWxzZSA6IHRydWU7XG4gICAgICB9XG4gICAgICBidmVjNCBpc25hbl9jdXN0b20odmVjNCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIGJ2ZWM0KGlzbmFuKHZhbC54KSwgaXNuYW4odmFsLnkpLCBpc25hbih2YWwueiksIGlzbmFuKHZhbC53KSk7XG4gICAgICB9XG4gICAgYCxsPWBcbiAgICAgIHVuaWZvcm0gZmxvYXQgSU5GSU5JVFk7XG5cbiAgICAgIGJvb2wgaXNpbmYoZmxvYXQgdmFsKSB7XG4gICAgICAgIHJldHVybiBhYnModmFsKSA9PSBJTkZJTklUWTtcbiAgICAgIH1cbiAgICAgIGJ2ZWM0IGlzaW5mKHZlYzQgdmFsKSB7XG4gICAgICAgIHJldHVybiBlcXVhbChhYnModmFsKSwgdmVjNChJTkZJTklUWSkpO1xuICAgICAgfVxuICAgIGAsdT1gXG4gICAgICBpbnQgcm91bmQoZmxvYXQgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGludChmbG9vcih2YWx1ZSArIDAuNSkpO1xuICAgICAgfVxuXG4gICAgICBpdmVjNCByb3VuZCh2ZWM0IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpdmVjNChmbG9vcih2YWx1ZSArIHZlYzQoMC41KSkpO1xuICAgICAgfVxuICAgIGApLHt2ZXJzaW9uOmUsYXR0cmlidXRlOnQsdmFyeWluZ1ZzOm4sdmFyeWluZ0ZzOmEsdGV4dHVyZTJEOnIsb3V0cHV0OnMsZGVmaW5lT3V0cHV0OmksZGVmaW5lU3BlY2lhbE5hTjpvLGRlZmluZVNwZWNpYWxJbmY6bCxkZWZpbmVSb3VuZDp1fX1mdW5jdGlvbiBabyhlLHQsbj1cImluZGV4XCIpe2xldCBhPXcuY29tcHV0ZVN0cmlkZXModCk7cmV0dXJuIGEubWFwKChyLHMpPT57bGV0IGk9YGludCAke2Vbc119ID0gJHtufSAvICR7cn1gLG89cz09PWEubGVuZ3RoLTE/YGludCAke2VbcysxXX0gPSAke259IC0gJHtlW3NdfSAqICR7cn1gOmBpbmRleCAtPSAke2Vbc119ICogJHtyfWA7cmV0dXJuYCR7aX07ICR7b307YH0pLmpvaW4oXCJcIil9ZnVuY3Rpb24gV2YoZSx0LG49XCJpbmRleFwiKXtsZXQgYT13LmNvbXB1dGVTdHJpZGVzKHQpO3JldHVybiBhLm1hcCgocixzKT0+e2xldCBpPWBpbnQgJHtlW3NdfSA9ICR7bn0gLyBvdXRTaGFwZVN0cmlkZXNbJHtzfV1gLG89cz09PWEubGVuZ3RoLTE/YGludCAke2VbcysxXX0gPSAke259IC0gJHtlW3NdfSAqIG91dFNoYXBlU3RyaWRlc1ske3N9XWA6YGluZGV4IC09ICR7ZVtzXX0gKiBvdXRTaGFwZVN0cmlkZXNbJHtzfV1gO3JldHVybmAke2l9OyAke299O2B9KS5qb2luKFwiXCIpfWZ1bmN0aW9uIGE5KGUsdCl7bGV0IG49ZS5sZW5ndGgsYT1lLm1hcChzPT5gJHt0fVske3N9XWApLHI9bmV3IEFycmF5KG4tMSk7cltuLTJdPWFbbi0xXTtmb3IobGV0IHM9bi0zO3M+PTA7LS1zKXJbc109YCgke3JbcysxXX0gKiAke2FbcysxXX0pYDtyZXR1cm4gcn1mdW5jdGlvbiByOShlLHQsbj1cImluZGV4XCIpe2xldCBhPWUubWFwKChzLGkpPT5pKSxyPWE5KGEsdCk7cmV0dXJuIHIubWFwKChzLGkpPT57bGV0IG89YGludCAke2VbaV19ID0gJHtufSAvICR7cltpXX1gLGw9aT09PXIubGVuZ3RoLTE/YGludCAke2VbaSsxXX0gPSAke259IC0gJHtlW2ldfSAqICR7cltpXX1gOmBpbmRleCAtPSAke2VbaV19ICogJHtyW2ldfWA7cmV0dXJuYCR7b307ICR7bH07YH0pLmpvaW4oXCJcIil9ZnVuY3Rpb24gUTEoZSl7bGV0IHQ9dy5jb21wdXRlU3RyaWRlcyhlKS5tYXAobj0+bi50b1N0cmluZygpKTtyZXR1cm5gXG4gIGludCBnZXRGbGF0SW5kZXgoaXZlYzMgY29vcmRzKSB7XG4gICAgcmV0dXJuIGNvb3Jkcy54ICogJHt0WzBdfSArIGNvb3Jkcy55ICogJHt0WzFdfSArIGNvb3Jkcy56O1xuICB9XG5gfWZ1bmN0aW9uIGVrKCl7cmV0dXJuYFxuICBpbnQgZ2V0RmxhdEluZGV4KGl2ZWMzIGNvb3Jkcykge1xuICAgIHJldHVybiBjb29yZHMueCAqIG91dFNoYXBlU3RyaWRlc1swXSArIGNvb3Jkcy55ICogb3V0U2hhcGVTdHJpZGVzWzFdICsgY29vcmRzLno7XG4gIH1cbmB9dmFyIHJBPWBcbiAgY29uc3QgZmxvYXQgRkxPQVRfTUFYID0gMS43MDE0MTE4NGUzODtcbiAgY29uc3QgZmxvYXQgRkxPQVRfTUlOID0gMS4xNzU0OTQzNWUtMzg7XG5cbiAgbG93cCB2ZWM0IGVuY29kZV9mbG9hdChoaWdocCBmbG9hdCB2KSB7XG4gICAgaWYgKGlzbmFuKHYpKSB7XG4gICAgICByZXR1cm4gdmVjNCgyNTUsIDI1NSwgMjU1LCAyNTUpO1xuICAgIH1cblxuICAgIGhpZ2hwIGZsb2F0IGF2ID0gYWJzKHYpO1xuXG4gICAgaWYoYXYgPCBGTE9BVF9NSU4pIHtcbiAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgfSBlbHNlIGlmKHYgPiBGTE9BVF9NQVgpIHtcbiAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAxMjguMCwgMTI3LjApIC8gMjU1LjA7XG4gICAgfSBlbHNlIGlmKHYgPCAtRkxPQVRfTUFYKSB7XG4gICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgIDEyOC4wLCAyNTUuMCkgLyAyNTUuMDtcbiAgICB9XG5cbiAgICBoaWdocCB2ZWM0IGMgPSB2ZWM0KDAsMCwwLDApO1xuXG4gICAgaGlnaHAgZmxvYXQgZSA9IGZsb29yKGxvZzIoYXYpKTtcbiAgICBoaWdocCBmbG9hdCBtID0gZXhwMihmcmFjdChsb2cyKGF2KSkpIC0gMS4wO1xuXG4gICAgY1syXSA9IGZsb29yKDEyOC4wICogbSk7XG4gICAgbSAtPSBjWzJdIC8gMTI4LjA7XG4gICAgY1sxXSA9IGZsb29yKDMyNzY4LjAgKiBtKTtcbiAgICBtIC09IGNbMV0gLyAzMjc2OC4wO1xuICAgIGNbMF0gPSBmbG9vcig4Mzg4NjA4LjAgKiBtKTtcblxuICAgIGhpZ2hwIGZsb2F0IGViaWFzID0gZSArIDEyNy4wO1xuICAgIGNbM10gPSBmbG9vcihlYmlhcyAvIDIuMCk7XG4gICAgZWJpYXMgLT0gY1szXSAqIDIuMDtcbiAgICBjWzJdICs9IGZsb29yKGViaWFzKSAqIDEyOC4wO1xuXG4gICAgY1szXSArPSAxMjguMCAqIHN0ZXAoMC4wLCAtdik7XG5cbiAgICByZXR1cm4gYyAvIDI1NS4wO1xuICB9XG5gLHtnZXRCcm9hZGNhc3REaW1zOnNBfT1UO2Z1bmN0aW9uIHM5KGUsdCxuKXtsZXQgYT1bXTtpZihlLmZvckVhY2goYz0+e2xldCBoPXcuc2l6ZUZyb21TaGFwZShjLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUpO2lmKGMuc2hhcGVJbmZvLmlzVW5pZm9ybT9hLnB1c2goYHVuaWZvcm0gZmxvYXQgJHtjLm5hbWV9JHtoPjE/YFske2h9XWA6XCJcIn07YCk6KGEucHVzaChgdW5pZm9ybSBzYW1wbGVyMkQgJHtjLm5hbWV9O2ApLGEucHVzaChgdW5pZm9ybSBpbnQgb2Zmc2V0JHtjLm5hbWV9O2ApKSxuLmVuYWJsZVNoYXBlVW5pZm9ybXMpe2xldHt1bmlmb3JtU2hhcGU6bX09dGsobi5wYWNrZWRJbnB1dHMsYy5zaGFwZUluZm8ubG9naWNhbFNoYXBlLGMuc2hhcGVJbmZvLnRleFNoYXBlKTtzd2l0Y2gobS5sZW5ndGgpe2Nhc2UgMTphLnB1c2goYHVuaWZvcm0gaW50ICR7Yy5uYW1lfVNoYXBlO2ApO2JyZWFrO2Nhc2UgMjphLnB1c2goYHVuaWZvcm0gaXZlYzIgJHtjLm5hbWV9U2hhcGU7YCk7YnJlYWs7Y2FzZSAzOmEucHVzaChgdW5pZm9ybSBpdmVjMyAke2MubmFtZX1TaGFwZTtgKTticmVhaztjYXNlIDQ6YS5wdXNoKGB1bmlmb3JtIGl2ZWM0ICR7Yy5uYW1lfVNoYXBlO2ApO2JyZWFrO2RlZmF1bHQ6YnJlYWt9YS5wdXNoKGB1bmlmb3JtIGl2ZWMyICR7Yy5uYW1lfVRleFNoYXBlO2ApfX0pLG4uZW5hYmxlU2hhcGVVbmlmb3Jtcyl7c3dpdGNoKHQubG9naWNhbFNoYXBlLmxlbmd0aCl7Y2FzZSAxOmEucHVzaChcInVuaWZvcm0gaW50IG91dFNoYXBlO1wiKTticmVhaztjYXNlIDI6YS5wdXNoKFwidW5pZm9ybSBpdmVjMiBvdXRTaGFwZTtcIiksYS5wdXNoKFwidW5pZm9ybSBpbnQgb3V0U2hhcGVTdHJpZGVzO1wiKTticmVhaztjYXNlIDM6YS5wdXNoKFwidW5pZm9ybSBpdmVjMyBvdXRTaGFwZTtcIiksYS5wdXNoKFwidW5pZm9ybSBpdmVjMiBvdXRTaGFwZVN0cmlkZXM7XCIpO2JyZWFrO2Nhc2UgNDphLnB1c2goXCJ1bmlmb3JtIGl2ZWM0IG91dFNoYXBlO1wiKSxhLnB1c2goXCJ1bmlmb3JtIGl2ZWMzIG91dFNoYXBlU3RyaWRlcztcIik7YnJlYWs7ZGVmYXVsdDpicmVha31hLnB1c2goXCJ1bmlmb3JtIGl2ZWMyIG91dFRleFNoYXBlO1wiKX1uLmN1c3RvbVVuaWZvcm1zJiZuLmN1c3RvbVVuaWZvcm1zLmZvckVhY2goYz0+e2EucHVzaChgdW5pZm9ybSAke2MudHlwZX0gJHtjLm5hbWV9JHtjLmFycmF5SW5kZXg/YFske2MuYXJyYXlJbmRleH1dYDpcIlwifTtgKX0pO2xldCByPWEuam9pbihgXG5gKSxzPWUubWFwKGM9Pmk5KGMsdCxuLnBhY2tlZElucHV0cyxuLmVuYWJsZVNoYXBlVW5pZm9ybXMpKS5qb2luKGBcbmApLGk9dC50ZXhTaGFwZSxvPUVuKCksbD11OShvKSx1LHAsZD1kOShvKTtyZXR1cm4gdC5pc1BhY2tlZD8odT1vOSh0LmxvZ2ljYWxTaGFwZSxpLG4uZW5hYmxlU2hhcGVVbmlmb3JtcykscD1jOShvKSk6KHU9bDkodC5sb2dpY2FsU2hhcGUsaSxuLmVuYWJsZVNoYXBlVW5pZm9ybXMpLHA9cDkobykpLG4ucGFja2VkSW5wdXRzJiYoZCs9ZzkpLFtkLGwscCxyLHUscyxuLnVzZXJDb2RlXS5qb2luKGBcbmApfWZ1bmN0aW9uIHVwKGUsdD0hMSl7bGV0IG49ZS5zaGFwZUluZm8ubG9naWNhbFNoYXBlO3N3aXRjaChuLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBFOShlLHQpO2Nhc2UgMTpyZXR1cm4gQTkoZSx0KTtjYXNlIDI6cmV0dXJuICQ5KGUsdCk7Y2FzZSAzOnJldHVybiBSOShlLHQpO2Nhc2UgNDpyZXR1cm4gTzkoZSx0KTtjYXNlIDU6cmV0dXJuIFA5KGUpO2Nhc2UgNjpyZXR1cm4gTDkoZSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYCR7bi5sZW5ndGh9LUQgaW5wdXQgc2FtcGxpbmcgaXMgbm90IHlldCBzdXBwb3J0ZWRgKX19ZnVuY3Rpb24gaUEoZSx0KXtzd2l0Y2goZS5zaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBDOShlKTtjYXNlIDE6cmV0dXJuIF85KGUsdCk7Y2FzZSAyOnJldHVybiBGOShlLHQpO2Nhc2UgMzpyZXR1cm4gRDkoZSx0KTtkZWZhdWx0OnJldHVybiBNOShlLHQpfX1mdW5jdGlvbiBpOShlLHQsbj0hMSxhKXtsZXQgcj1cIlwiO24/cis9aUEoZSxhKTpyKz11cChlLGEpO2xldCBzPWUuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxpPXQubG9naWNhbFNoYXBlO3JldHVybiBzLmxlbmd0aDw9aS5sZW5ndGgmJihuP3IrPXo5KGUsdCk6cis9VzkoZSx0KSkscn1mdW5jdGlvbiBvOShlLHQsbil7c3dpdGNoKGUubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIG9BKCk7Y2FzZSAxOnJldHVybiBiOShlLHQsbik7Y2FzZSAyOnJldHVybiBOOShlLHQsbik7Y2FzZSAzOnJldHVybiB4OShlLHQsbik7ZGVmYXVsdDpyZXR1cm4gdzkoZSx0LG4pfX1mdW5jdGlvbiBsOShlLHQsbil7c3dpdGNoKGUubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIG9BKCk7Y2FzZSAxOnJldHVybiB5OShlLHQsbik7Y2FzZSAyOnJldHVybiBUOShlLHQsbik7Y2FzZSAzOnJldHVybiB2OShlLHQsbik7Y2FzZSA0OnJldHVybiBrOShlLHQsbik7Y2FzZSA1OnJldHVybiBJOShlLHQpO2Nhc2UgNjpyZXR1cm4gUzkoZSx0KTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgJHtlLmxlbmd0aH0tRCBvdXRwdXQgc2FtcGxpbmcgaXMgbm90IHlldCBzdXBwb3J0ZWRgKX19ZnVuY3Rpb24gdTkoZSl7cmV0dXJuYFxuICAgIGZsb2F0IHNhbXBsZVRleHR1cmUoc2FtcGxlcjJEIHRleHR1cmVTYW1wbGVyLCB2ZWMyIHV2KSB7XG4gICAgICByZXR1cm4gJHtlLnRleHR1cmUyRH0odGV4dHVyZVNhbXBsZXIsIHV2KS5yO1xuICAgIH1cbiAgYH1mdW5jdGlvbiBwOShlKXtyZXR1cm5gXG4gICAgdm9pZCBzZXRPdXRwdXQoZmxvYXQgdmFsKSB7XG4gICAgICAke2Uub3V0cHV0fSA9IHZlYzQodmFsLCAwLCAwLCAwKTtcbiAgICB9XG4gIGB9ZnVuY3Rpb24gYzkoZSl7cmV0dXJuYFxuICAgIHZvaWQgc2V0T3V0cHV0KHZlYzQgdmFsKSB7XG4gICAgICAke2Uub3V0cHV0fSA9IHZhbDtcbiAgICB9XG4gIGB9ZnVuY3Rpb24gZDkoZSl7cmV0dXJuYCR7ZS52ZXJzaW9ufVxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICBwcmVjaXNpb24gaGlnaHAgaW50O1xuICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XG4gICAgJHtlLnZhcnlpbmdGc30gdmVjMiByZXN1bHRVVjtcbiAgICAke2UuZGVmaW5lT3V0cHV0fVxuICAgIGNvbnN0IHZlYzIgaGFsZkNSID0gdmVjMigwLjUsIDAuNSk7XG5cbiAgICBzdHJ1Y3QgaXZlYzVcbiAgICB7XG4gICAgICBpbnQgeDtcbiAgICAgIGludCB5O1xuICAgICAgaW50IHo7XG4gICAgICBpbnQgdztcbiAgICAgIGludCB1O1xuICAgIH07XG5cbiAgICBzdHJ1Y3QgaXZlYzZcbiAgICB7XG4gICAgICBpbnQgeDtcbiAgICAgIGludCB5O1xuICAgICAgaW50IHo7XG4gICAgICBpbnQgdztcbiAgICAgIGludCB1O1xuICAgICAgaW50IHY7XG4gICAgfTtcblxuICAgIHVuaWZvcm0gZmxvYXQgTkFOO1xuICAgICR7ZS5kZWZpbmVTcGVjaWFsTmFOfVxuICAgICR7ZS5kZWZpbmVTcGVjaWFsSW5mfVxuICAgICR7ZS5kZWZpbmVSb3VuZH1cblxuICAgIGludCBpbW9kKGludCB4LCBpbnQgeSkge1xuICAgICAgcmV0dXJuIHggLSB5ICogKHggLyB5KTtcbiAgICB9XG5cbiAgICBpbnQgaWRpdihpbnQgYSwgaW50IGIsIGZsb2F0IHNpZ24pIHtcbiAgICAgIGludCByZXMgPSBhIC8gYjtcbiAgICAgIGludCBtb2QgPSBpbW9kKGEsIGIpO1xuICAgICAgaWYgKHNpZ24gPCAwLiAmJiBtb2QgIT0gMCkge1xuICAgICAgICByZXMgLT0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy9CYXNlZCBvbiB0aGUgd29yayBvZiBEYXZlIEhvc2tpbnNcbiAgICAvL2h0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy80ZGpTUldcbiAgICAjZGVmaW5lIEhBU0hTQ0FMRTEgNDQzLjg5NzVcbiAgICBmbG9hdCByYW5kb20oZmxvYXQgc2VlZCl7XG4gICAgICB2ZWMyIHAgPSByZXN1bHRVViAqIHNlZWQ7XG4gICAgICB2ZWMzIHAzICA9IGZyYWN0KHZlYzMocC54eXgpICogSEFTSFNDQUxFMSk7XG4gICAgICBwMyArPSBkb3QocDMsIHAzLnl6eCArIDE5LjE5KTtcbiAgICAgIHJldHVybiBmcmFjdCgocDMueCArIHAzLnkpICogcDMueik7XG4gICAgfVxuXG4gICAgJHtoOX1cbiAgICAke205fVxuICAgICR7Zjl9XG4gIGB9dmFyIGg5PWBcbnZlYzIgdXZGcm9tRmxhdChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcbn1cbnZlYzIgcGFja2VkVVZmcm9tMUQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgaW5kZXgpIHtcbiAgaW50IHRleGVsSW5kZXggPSBpbmRleCAvIDI7XG4gIGludCB0ZXhSID0gdGV4ZWxJbmRleCAvIHRleE51bUM7XG4gIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcbn1cbmAsbTk9YFxudmVjMiBwYWNrZWRVVmZyb20yRChpbnQgdGV4ZWxzSW5Mb2dpY2FsUm93LCBpbnQgdGV4TnVtUixcbiAgaW50IHRleE51bUMsIGludCByb3csIGludCBjb2wpIHtcbiAgaW50IHRleGVsSW5kZXggPSAocm93IC8gMikgKiB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyAoY29sIC8gMik7XG4gIGludCB0ZXhSID0gdGV4ZWxJbmRleCAvIHRleE51bUM7XG4gIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcbn1cbmAsZjk9YFxudmVjMiBwYWNrZWRVVmZyb20zRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsXG4gICAgaW50IHRleGVsc0luQmF0Y2gsIGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCBiLFxuICAgIGludCByb3csIGludCBjb2wpIHtcbiAgaW50IGluZGV4ID0gYiAqIHRleGVsc0luQmF0Y2ggKyAocm93IC8gMikgKiB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyAoY29sIC8gMik7XG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xuICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xufVxuYCxnOT1gXG4gIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCB2ZWMyIGlubmVyRGltcykge1xuICAgIHZlYzIgbW9kQ29vcmQgPSBtb2QoaW5uZXJEaW1zLCAyLik7XG4gICAgcmV0dXJuIG1vZENvb3JkLnggPT0gMC4gP1xuICAgICAgKG1vZENvb3JkLnkgPT0gMC4gPyBmcmFnLnIgOiBmcmFnLmcpIDpcbiAgICAgIChtb2RDb29yZC55ID09IDAuID8gZnJhZy5iIDogZnJhZy5hKTtcbiAgfVxuICBmbG9hdCBnZXRDaGFubmVsKHZlYzQgZnJhZywgaW50IGRpbSkge1xuICAgIGZsb2F0IG1vZENvb3JkID0gbW9kKGZsb2F0KGRpbSksIDIuKTtcbiAgICByZXR1cm4gbW9kQ29vcmQgPT0gMC4gPyBmcmFnLnIgOiBmcmFnLmc7XG4gIH1cbmA7ZnVuY3Rpb24gb0EoKXtyZXR1cm5gXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgYH1mdW5jdGlvbiBiOShlLHQsbil7bGV0IGE9W01hdGguY2VpbCh0WzBdLzIpLE1hdGguY2VpbCh0WzFdLzIpXTtyZXR1cm4gYVswXT09PTE/bj9gXG4gICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICByZXR1cm4gMiAqIGludChyZXN1bHRVVi54ICogY2VpbChmbG9hdChvdXRUZXhTaGFwZVsxXSkgLyAyLjApKTtcbiAgICAgIH1cbiAgICBgOmBcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgIHJldHVybiAyICogaW50KHJlc3VsdFVWLnggKiAke2FbMV19LjApO1xuICAgICAgfVxuICAgIGA6YVsxXT09PTE/bj9gXG4gICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICByZXR1cm4gMiAqIGludChyZXN1bHRVVi55ICogY2VpbChmbG9hdChvdXRUZXhTaGFwZVswXSkgLyAyLjApKTtcbiAgICAgIH1cbiAgICBgOmBcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgIHJldHVybiAyICogaW50KHJlc3VsdFVWLnkgKiAke2FbMF19LjApO1xuICAgICAgfVxuICAgIGA6bj9gXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgIGl2ZWMyIHBhY2tlZFRleFNoYXBlID0gaXZlYzIoY2VpbChmbG9hdChvdXRUZXhTaGFwZVswXSkgLyAyLjApLCBjZWlsKGZsb2F0KG91dFRleFNoYXBlWzFdKSAvIDIuMCkpO1xuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIocGFja2VkVGV4U2hhcGVbMF0sIHBhY2tlZFRleFNoYXBlWzFdKSk7XG4gICAgICByZXR1cm4gMiAqIChyZXNUZXhSQy54ICogcGFja2VkVGV4U2hhcGVbMV0gKyByZXNUZXhSQy55KTtcbiAgICB9XG4gIGA6YFxuICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2FbMF19LCAke2FbMV19KSk7XG4gICAgICByZXR1cm4gMiAqIChyZXNUZXhSQy54ICogJHthWzFdfSArIHJlc1RleFJDLnkpO1xuICAgIH1cbiAgYH1mdW5jdGlvbiB5OShlLHQsbil7cmV0dXJuIHRbMF09PT0xP24/YFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgcmV0dXJuIGludChyZXN1bHRVVi54ICogZmxvYXQob3V0VGV4U2hhcGVbMV0pKTtcbiAgICAgIH1cbiAgICBgOmBcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgIHJldHVybiBpbnQocmVzdWx0VVYueCAqICR7dFsxXX0uMCk7XG4gICAgICB9XG4gICAgYDp0WzFdPT09MT9uP2BcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgIHJldHVybiBpbnQocmVzdWx0VVYueSAqIGZsb2F0KG91dFRleFNoYXBlWzBdKSk7XG4gICAgICB9XG4gICAgYDpgXG4gICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICByZXR1cm4gaW50KHJlc3VsdFVWLnkgKiAke3RbMF19LjApO1xuICAgICAgfVxuICAgIGA6bj9gXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKG91dFRleFNoYXBlWzBdLCBvdXRUZXhTaGFwZVsxXSkpO1xuICAgICAgcmV0dXJuIHJlc1RleFJDLnggKiBvdXRUZXhTaGFwZVsxXSArIHJlc1RleFJDLnk7XG4gICAgfVxuICBgOmBcbiAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0WzBdfSwgJHt0WzFdfSkpO1xuICAgICAgcmV0dXJuIHJlc1RleFJDLnggKiAke3RbMV19ICsgcmVzVGV4UkMueTtcbiAgICB9XG4gIGB9ZnVuY3Rpb24geDkoZSx0LG4pe2lmKG4pcmV0dXJuYFxuICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgIGl2ZWMyIHBhY2tlZFRleFNoYXBlID0gaXZlYzIoY2VpbChmbG9hdChvdXRUZXhTaGFwZVswXSkgLyAyLjApLCBjZWlsKGZsb2F0KG91dFRleFNoYXBlWzFdKSAvIDIuMCkpO1xuICAgICAgaW50IHRleGVsc0luTG9naWNhbFJvdyA9IGludChjZWlsKGZsb2F0KG91dFNoYXBlWzJdKSAvIDIuMCkpO1xuICAgICAgaW50IHRleGVsc0luQmF0Y2ggPSB0ZXhlbHNJbkxvZ2ljYWxSb3cgKiBpbnQoY2VpbChmbG9hdChvdXRTaGFwZVsxXSkgLyAyLjApKTtcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKHBhY2tlZFRleFNoYXBlWzBdLCBwYWNrZWRUZXhTaGFwZVsxXSkpO1xuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIHBhY2tlZFRleFNoYXBlWzFdICsgcmVzVGV4UkMueTtcblxuICAgICAgaW50IGIgPSBpbmRleCAvIHRleGVsc0luQmF0Y2g7XG4gICAgICBpbmRleCAtPSBiICogdGV4ZWxzSW5CYXRjaDtcblxuICAgICAgaW50IHIgPSAyICogKGluZGV4IC8gdGV4ZWxzSW5Mb2dpY2FsUm93KTtcbiAgICAgIGludCBjID0gaW1vZChpbmRleCwgdGV4ZWxzSW5Mb2dpY2FsUm93KSAqIDI7XG5cbiAgICAgIHJldHVybiBpdmVjMyhiLCByLCBjKTtcbiAgICB9XG4gIGA7bGV0IGE9W01hdGguY2VpbCh0WzBdLzIpLE1hdGguY2VpbCh0WzFdLzIpXSxyPU1hdGguY2VpbChlWzJdLzIpLHM9cipNYXRoLmNlaWwoZVsxXS8yKTtyZXR1cm5gXG4gICAgaXZlYzMgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHthWzBdfSwgJHthWzFdfSkpO1xuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqICR7YVsxXX0gKyByZXNUZXhSQy55O1xuXG4gICAgICBpbnQgYiA9IGluZGV4IC8gJHtzfTtcbiAgICAgIGluZGV4IC09IGIgKiAke3N9O1xuXG4gICAgICBpbnQgciA9IDIgKiAoaW5kZXggLyAke3J9KTtcbiAgICAgIGludCBjID0gaW1vZChpbmRleCwgJHtyfSkgKiAyO1xuXG4gICAgICByZXR1cm4gaXZlYzMoYiwgciwgYyk7XG4gICAgfVxuICBgfWZ1bmN0aW9uIHY5KGUsdCxuKXtpZihuKXJldHVybmBcbiAgaXZlYzMgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihvdXRUZXhTaGFwZVswXSwgb3V0VGV4U2hhcGVbMV0pKTtcbiAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogb3V0VGV4U2hhcGVbMV0gKyByZXNUZXhSQy55O1xuICAgICR7V2YoW1wiclwiLFwiY1wiLFwiZFwiXSxlKX1cbiAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XG4gIH1cbmA7bGV0IGE9Wm8oW1wiclwiLFwiY1wiLFwiZFwiXSxlKTtyZXR1cm5gXG4gICAgaXZlYzMgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0WzBdfSwgJHt0WzFdfSkpO1xuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqICR7dFsxXX0gKyByZXNUZXhSQy55O1xuICAgICAgJHthfVxuICAgICAgcmV0dXJuIGl2ZWMzKHIsIGMsIGQpO1xuICAgIH1cbiAgYH1mdW5jdGlvbiB3OShlLHQsbil7aWYobilyZXR1cm5gXG4gICAgaXZlYzQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgaXZlYzIgcGFja2VkVGV4U2hhcGUgPSBpdmVjMihjZWlsKGZsb2F0KG91dFRleFNoYXBlWzBdKSAvIDIuMCksIGNlaWwoZmxvYXQob3V0VGV4U2hhcGVbMV0pIC8gMi4wKSk7XG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihwYWNrZWRUZXhTaGFwZVswXSwgcGFja2VkVGV4U2hhcGVbMV0pKTtcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBwYWNrZWRUZXhTaGFwZVsxXSArIHJlc1RleFJDLnk7XG5cbiAgICAgIGludCB0ZXhlbHNJbkxvZ2ljYWxSb3cgPSBpbnQoY2VpbChmbG9hdChvdXRTaGFwZVszXSkgLyAyLjApKTtcbiAgICAgIGludCB0ZXhlbHNJbkJhdGNoID0gdGV4ZWxzSW5Mb2dpY2FsUm93ICogaW50KGNlaWwoZmxvYXQob3V0U2hhcGVbMl0pIC8gMi4wKSk7XG4gICAgICBpbnQgdGV4ZWxzSW5CYXRjaE4gPSB0ZXhlbHNJbkJhdGNoICogb3V0U2hhcGVbMV07XG5cbiAgICAgIGludCBiMiA9IGluZGV4IC8gdGV4ZWxzSW5CYXRjaE47XG4gICAgICBpbmRleCAtPSBiMiAqIHRleGVsc0luQmF0Y2hOO1xuXG4gICAgICBpbnQgYiA9IGluZGV4IC8gdGV4ZWxzSW5CYXRjaDtcbiAgICAgIGluZGV4IC09IGIgKiB0ZXhlbHNJbkJhdGNoO1xuXG4gICAgICBpbnQgciA9IDIgKiAoaW5kZXggLyB0ZXhlbHNJbkxvZ2ljYWxSb3cpO1xuICAgICAgaW50IGMgPSBpbW9kKGluZGV4LCB0ZXhlbHNJbkxvZ2ljYWxSb3cpICogMjtcblxuICAgICAgcmV0dXJuIGl2ZWM0KGIyLCBiLCByLCBjKTtcbiAgICB9XG4gIGA7bGV0IGE9W01hdGguY2VpbCh0WzBdLzIpLE1hdGguY2VpbCh0WzFdLzIpXSxyPU1hdGguY2VpbChlW2UubGVuZ3RoLTFdLzIpLHM9cipNYXRoLmNlaWwoZVtlLmxlbmd0aC0yXS8yKSxpPXMsbz1cIlwiLGw9XCJiLCByLCBjXCI7Zm9yKGxldCB1PTI7dTxlLmxlbmd0aC0xO3UrKylpKj1lW2UubGVuZ3RoLXUtMV0sbz1gXG4gICAgICBpbnQgYiR7dX0gPSBpbmRleCAvICR7aX07XG4gICAgICBpbmRleCAtPSBiJHt1fSAqICR7aX07XG4gICAgYCtvLGw9YGIke3V9LCBgK2w7cmV0dXJuYFxuICAgIGl2ZWMke2UubGVuZ3RofSBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2FbMF19LCAke2FbMV19KSk7XG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogJHthWzFdfSArIHJlc1RleFJDLnk7XG5cbiAgICAgICR7b31cblxuICAgICAgaW50IGIgPSBpbmRleCAvICR7c307XG4gICAgICBpbmRleCAtPSBiICogJHtzfTtcblxuICAgICAgaW50IHIgPSAyICogKGluZGV4IC8gJHtyfSk7XG4gICAgICBpbnQgYyA9IGltb2QoaW5kZXgsICR7cn0pICogMjtcblxuICAgICAgcmV0dXJuIGl2ZWMke2UubGVuZ3RofSgke2x9KTtcbiAgICB9XG4gIGB9ZnVuY3Rpb24gazkoZSx0LG4pe2lmKG4pcmV0dXJuYFxuICAgIGl2ZWM0IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxuICAgICAgICB2ZWMyKG91dFRleFNoYXBlWzBdLCBvdXRUZXhTaGFwZVsxXSkpO1xuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIG91dFRleFNoYXBlWzFdICsgcmVzVGV4UkMueTtcbiAgICAgICR7V2YoW1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIl0sZSl9XG4gICAgICByZXR1cm4gaXZlYzQociwgYywgZCwgZDIpO1xuICAgIH1cbiAgYDtsZXQgYT1abyhbXCJyXCIsXCJjXCIsXCJkXCIsXCJkMlwiXSxlKTtyZXR1cm5gXG4gICAgaXZlYzQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXG4gICAgICAgIHZlYzIoJHt0WzBdfSwgJHt0WzFdfSkpO1xuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqICR7dFsxXX0gKyByZXNUZXhSQy55O1xuICAgICAgJHthfVxuICAgICAgcmV0dXJuIGl2ZWM0KHIsIGMsIGQsIGQyKTtcbiAgICB9XG4gIGB9ZnVuY3Rpb24gSTkoZSx0KXtsZXQgbj1abyhbXCJyXCIsXCJjXCIsXCJkXCIsXCJkMlwiLFwiZDNcIl0sZSk7cmV0dXJuYFxuICAgIGl2ZWM1IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKiB2ZWMyKCR7dFswXX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7dFsxXX0pKTtcblxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqICR7dFsxXX0gKyByZXNUZXhSQy55O1xuXG4gICAgICAke259XG5cbiAgICAgIGl2ZWM1IG91dFNoYXBlID0gaXZlYzUociwgYywgZCwgZDIsIGQzKTtcbiAgICAgIHJldHVybiBvdXRTaGFwZTtcbiAgICB9XG4gIGB9ZnVuY3Rpb24gUzkoZSx0KXtsZXQgbj1abyhbXCJyXCIsXCJjXCIsXCJkXCIsXCJkMlwiLFwiZDNcIixcImQ0XCJdLGUpO3JldHVybmBcbiAgICBpdmVjNiBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcbiAgICAgICAgdmVjMigke3RbMF19LCAke3RbMV19KSk7XG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogJHt0WzFdfSArIHJlc1RleFJDLnk7XG5cbiAgICAgICR7bn1cblxuICAgICAgaXZlYzYgcmVzdWx0ID0gaXZlYzYociwgYywgZCwgZDIsIGQzLCBkNCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgYH1mdW5jdGlvbiBOOShlLHQsbil7bGV0IGE9W01hdGguY2VpbCh0WzBdLzIpLE1hdGguY2VpbCh0WzFdLzIpXTtpZih3LmFycmF5c0VxdWFsKGUsdCkpcmV0dXJuIG4/YFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICBpdmVjMiBwYWNrZWRUZXhTaGFwZSA9IGl2ZWMyKGNlaWwoZmxvYXQob3V0VGV4U2hhcGVbMF0pIC8gMi4wKSwgY2VpbChmbG9hdChvdXRUZXhTaGFwZVsxXSkgLyAyLjApKTtcbiAgICAgICAgcmV0dXJuIDIgKiBpdmVjMihyZXN1bHRVVi55eCAqIHZlYzIocGFja2VkVGV4U2hhcGVbMF0sIHBhY2tlZFRleFNoYXBlWzFdKSk7XG4gICAgICB9XG4gICAgYDpgXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgIHJldHVybiAyICogaXZlYzIocmVzdWx0VVYueXggKiB2ZWMyKCR7YVswXX0sICR7YVsxXX0pKTtcbiAgICAgIH1cbiAgICBgO2xldCByPU1hdGguY2VpbChlWzFdLzIpO3JldHVybiBuP2BcbiAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICBpdmVjMiBwYWNrZWRUZXhTaGFwZSA9IGl2ZWMyKGNlaWwoZmxvYXQob3V0VGV4U2hhcGVbMF0pIC8gMi4wKSwgY2VpbChmbG9hdChvdXRUZXhTaGFwZVsxXSkgLyAyLjApKTtcbiAgICAgIGludCB0ZXhlbHNJbkxvZ2ljYWxSb3cgPSBpbnQoY2VpbChmbG9hdChvdXRTaGFwZVsxXSkgLyAyLjApKTtcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKHBhY2tlZFRleFNoYXBlWzBdLCBwYWNrZWRUZXhTaGFwZVsxXSkpO1xuXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogcGFja2VkVGV4U2hhcGVbMV0gKyByZXNUZXhSQy55O1xuICAgICAgaW50IHIgPSAyICogKGluZGV4IC8gdGV4ZWxzSW5Mb2dpY2FsUm93KTtcbiAgICAgIGludCBjID0gaW1vZChpbmRleCwgdGV4ZWxzSW5Mb2dpY2FsUm93KSAqIDI7XG5cbiAgICAgIHJldHVybiBpdmVjMihyLCBjKTtcbiAgICB9XG4gIGA6YFxuICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7YVswXX0sICR7YVsxXX0pKTtcblxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqICR7YVsxXX0gKyByZXNUZXhSQy55O1xuICAgICAgaW50IHIgPSAyICogKGluZGV4IC8gJHtyfSk7XG4gICAgICBpbnQgYyA9IGltb2QoaW5kZXgsICR7cn0pICogMjtcblxuICAgICAgcmV0dXJuIGl2ZWMyKHIsIGMpO1xuICAgIH1cbiAgYH1mdW5jdGlvbiBUOShlLHQsbil7cmV0dXJuIHcuYXJyYXlzRXF1YWwoZSx0KT9uP2BcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgcmV0dXJuIGl2ZWMyKHJlc3VsdFVWLnl4ICogdmVjMihvdXRUZXhTaGFwZVswXSwgb3V0VGV4U2hhcGVbMV0pKTtcbiAgICAgIH1cbiAgICBgOmBcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgcmV0dXJuIGl2ZWMyKHJlc3VsdFVWLnl4ICogdmVjMigke3RbMF19LCAke3RbMV19KSk7XG4gICAgICB9XG4gICAgYDplWzFdPT09MT9uP2BcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihvdXRUZXhTaGFwZVswXSwgb3V0VGV4U2hhcGVbMV0pKTtcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIG91dFRleFNoYXBlWzFdICsgcmVzVGV4UkMueTtcbiAgICAgICAgcmV0dXJuIGl2ZWMyKGluZGV4LCAwKTtcbiAgICAgIH1cbiAgICBgOmBcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3RbMF19LCAke3RbMV19KSk7XG4gICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiAke3RbMV19ICsgcmVzVGV4UkMueTtcbiAgICAgICAgcmV0dXJuIGl2ZWMyKGluZGV4LCAwKTtcbiAgICAgIH1cbiAgICBgOmVbMF09PT0xP24/YFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKG91dFRleFNoYXBlWzBdLCBvdXRUZXhTaGFwZVsxXSkpO1xuICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogb3V0VGV4U2hhcGVbMV0gKyByZXNUZXhSQy55O1xuICAgICAgICByZXR1cm4gaXZlYzIoMCwgaW5kZXgpO1xuICAgICAgfVxuICAgIGA6YFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7dFswXX0sICR7dFsxXX0pKTtcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqICR7dFsxXX0gKyByZXNUZXhSQy55O1xuICAgICAgICByZXR1cm4gaXZlYzIoMCwgaW5kZXgpO1xuICAgICAgfVxuICAgIGA6bj9gXG4gICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIob3V0VGV4U2hhcGVbMF0sIG91dFRleFNoYXBlWzFdKSk7XG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogb3V0VGV4U2hhcGVbMV0gKyByZXNUZXhSQy55O1xuICAgICAgaW50IHIgPSBpbmRleCAvIG91dFNoYXBlWzFdO1xuICAgICAgaW50IGMgPSBpbmRleCAtIHIgKiBvdXRTaGFwZVsxXTtcbiAgICAgIHJldHVybiBpdmVjMihyLCBjKTtcbiAgICB9XG4gIGA6YFxuICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7dFswXX0sICR7dFsxXX0pKTtcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiAke3RbMV19ICsgcmVzVGV4UkMueTtcbiAgICAgIGludCByID0gaW5kZXggLyAke2VbMV19O1xuICAgICAgaW50IGMgPSBpbmRleCAtIHIgKiAke2VbMV19O1xuICAgICAgcmV0dXJuIGl2ZWMyKHIsIGMpO1xuICAgIH1cbiAgYH1mdW5jdGlvbiBKbyhlKXtyZXR1cm5gb2Zmc2V0JHtlfWB9ZnVuY3Rpb24gQzkoZSl7bGV0IHQ9ZS5uYW1lLG49XCJnZXRcIit0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSksYT1FbigpO3JldHVybmBcbiAgICB2ZWM0ICR7bn0oKSB7XG4gICAgICByZXR1cm4gJHthLnRleHR1cmUyRH0oJHt0fSwgaGFsZkNSKTtcbiAgICB9XG4gIGB9ZnVuY3Rpb24gRTkoZSx0KXtsZXQgbj1lLm5hbWUsYT1cImdldFwiK24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKTtpZihlLnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuYGZsb2F0ICR7YX0oKSB7cmV0dXJuICR7bn07fWA7bGV0W3Isc109ZS5zaGFwZUluZm8udGV4U2hhcGU7aWYocj09PTEmJnM9PT0xKXJldHVybmBcbiAgICAgIGZsb2F0ICR7YX0oKSB7XG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bn0sIGhhbGZDUik7XG4gICAgICB9XG4gICAgYDtsZXQgaT1KbyhuKTtpZih0KXJldHVybmBcbiAgICBmbG9hdCAke2F9KCkge1xuICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtufVRleFNoYXBlWzBdLCAke259VGV4U2hhcGVbMV0sICR7aX0pO1xuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtufSwgdXYpO1xuICAgIH1cbiAgYDtsZXRbbyxsXT1lLnNoYXBlSW5mby50ZXhTaGFwZTtyZXR1cm5gXG4gICAgZmxvYXQgJHthfSgpIHtcbiAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7b30sICR7bH0sICR7aX0pO1xuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtufSwgdXYpO1xuICAgIH1cbiAgYH1mdW5jdGlvbiBfOShlLHQpe2xldCBuPWUubmFtZSxhPVwiZ2V0XCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLHI9ZS5zaGFwZUluZm8udGV4U2hhcGUscz1FbigpO2lmKHQpcmV0dXJuYFxuICAgIHZlYzQgJHthfShpbnQgaW5kZXgpIHtcbiAgICAgIGl2ZWMyIHBhY2tlZFRleFNoYXBlID0gaXZlYzIoY2VpbChmbG9hdCgke259VGV4U2hhcGVbMF0pIC8gMi4wKSwgY2VpbChmbG9hdCgke259VGV4U2hhcGVbMV0pIC8gMi4wKSk7XG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tMUQoXG4gICAgICAgIHBhY2tlZFRleFNoYXBlWzBdLCBwYWNrZWRUZXhTaGFwZVsxXSwgaW5kZXgpO1xuICAgICAgcmV0dXJuICR7cy50ZXh0dXJlMkR9KCR7bn0sIHV2KTtcbiAgICB9XG4gIGA7bGV0IGk9W01hdGguY2VpbChyWzBdLzIpLE1hdGguY2VpbChyWzFdLzIpXTtyZXR1cm5gXG4gICAgdmVjNCAke2F9KGludCBpbmRleCkge1xuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTFEKFxuICAgICAgICAke2lbMF19LCAke2lbMV19LCBpbmRleCk7XG4gICAgICByZXR1cm4gJHtzLnRleHR1cmUyRH0oJHtufSwgdXYpO1xuICAgIH1cbiAgYH1mdW5jdGlvbiBBOShlLHQpe2xldCBuPWUubmFtZSxhPVwiZ2V0XCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpO2lmKGUuc2hhcGVJbmZvLmlzVW5pZm9ybSlyZXR1cm5gXG4gICAgICBmbG9hdCAke2F9KGludCBpbmRleCkge1xuICAgICAgICAke3BwKGUpfVxuICAgICAgfVxuICAgIGA7bGV0IHI9ZS5zaGFwZUluZm8udGV4U2hhcGUscz1yWzBdLGk9clsxXTtpZihpPT09MSYmcz09PTEpcmV0dXJuYFxuICAgICAgZmxvYXQgJHthfShpbnQgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtufSwgaGFsZkNSKTtcbiAgICAgIH1cbiAgICBgO2xldCBvPUpvKG4pO3JldHVybiBpPT09MT90P2BcbiAgICAgIGZsb2F0ICR7YX0oaW50IGluZGV4KSB7XG4gICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGZsb2F0KGluZGV4ICsgJHtvfSkgKyAwLjUpIC8gZmxvYXQoJHtufVRleFNoYXBlWzBdKSk7XG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bn0sIHV2KTtcbiAgICAgIH1cbiAgICBgOmBcbiAgICAgIGZsb2F0ICR7YX0oaW50IGluZGV4KSB7XG4gICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGZsb2F0KGluZGV4ICsgJHtvfSkgKyAwLjUpIC8gJHtzfS4wKTtcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtufSwgdXYpO1xuICAgICAgfVxuICAgIGA6cz09PTE/dD9gXG4gICAgICBmbG9hdCAke2F9KGludCBpbmRleCkge1xuICAgICAgICB2ZWMyIHV2ID0gdmVjMigoZmxvYXQoaW5kZXggKyAke299KSArIDAuNSkgLyBmbG9hdCgke259VGV4U2hhcGVbMV0pLCAwLjUpO1xuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke259LCB1dik7XG4gICAgICB9XG4gICAgYDpgXG4gICAgICBmbG9hdCAke2F9KGludCBpbmRleCkge1xuICAgICAgICB2ZWMyIHV2ID0gdmVjMigoZmxvYXQoaW5kZXggKyAke299KSArIDAuNSkgLyAke2l9LjAsIDAuNSk7XG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bn0sIHV2KTtcbiAgICAgIH1cbiAgICBgOnQ/YFxuICAgIGZsb2F0ICR7YX0oaW50IGluZGV4KSB7XG4gICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke259VGV4U2hhcGVbMF0sICR7bn1UZXhTaGFwZVsxXSwgaW5kZXggKyAke299KTtcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bn0sIHV2KTtcbiAgICB9XG4gIGA6YFxuICAgIGZsb2F0ICR7YX0oaW50IGluZGV4KSB7XG4gICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke3N9LCAke2l9LCBpbmRleCArICR7b30pO1xuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtufSwgdXYpO1xuICAgIH1cbiAgYH1mdW5jdGlvbiBGOShlLHQpe2xldCBuPWUuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxhPWUubmFtZSxyPVwiZ2V0XCIrYS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSthLnNsaWNlKDEpLHM9ZS5zaGFwZUluZm8udGV4U2hhcGUsaT1zWzBdLG89c1sxXSxsPUVuKCk7aWYocyE9bnVsbCYmdy5hcnJheXNFcXVhbChuLHMpKXJldHVybiB0P2BcbiAgICAgIHZlYzQgJHtyfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgIHZlYzIgdXYgPSAodmVjMihjb2wsIHJvdykgKyBoYWxmQ1IpIC8gdmVjMigke2F9VGV4U2hhcGVbMV0sICR7YX1UZXhTaGFwZVswXSk7XG5cbiAgICAgICAgcmV0dXJuICR7bC50ZXh0dXJlMkR9KCR7YX0sIHV2KTtcbiAgICAgIH1cbiAgICBgOmBcbiAgICAgIHZlYzQgJHtyfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgIHZlYzIgdXYgPSAodmVjMihjb2wsIHJvdykgKyBoYWxmQ1IpIC8gdmVjMigke299LjAsICR7aX0uMCk7XG5cbiAgICAgICAgcmV0dXJuICR7bC50ZXh0dXJlMkR9KCR7YX0sIHV2KTtcbiAgICAgIH1cbiAgICBgO2lmKHQpcmV0dXJuYFxuICAgIHZlYzQgJHtyfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICBpdmVjMiBwYWNrZWRUZXhTaGFwZSA9IGl2ZWMyKGNlaWwoZmxvYXQoJHthfVRleFNoYXBlWzBdKSAvIDIuMCksIGNlaWwoZmxvYXQoJHthfVRleFNoYXBlWzFdKSAvIDIuMCkpO1xuICAgICAgaW50IHZhbHVlc1BlclJvdyA9IGludChjZWlsKGZsb2F0KCR7YX1TaGFwZVsxXSkgLyAyLjApKTtcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20yRCh2YWx1ZXNQZXJSb3csIHBhY2tlZFRleFNoYXBlWzBdLCBwYWNrZWRUZXhTaGFwZVsxXSwgcm93LCBjb2wpO1xuICAgICAgcmV0dXJuICR7bC50ZXh0dXJlMkR9KCR7YX0sIHV2KTtcbiAgICB9XG4gIGA7bGV0IHU9W01hdGguY2VpbChzWzBdLzIpLE1hdGguY2VpbChzWzFdLzIpXSxwPU1hdGguY2VpbChuWzFdLzIpO3JldHVybmBcbiAgICB2ZWM0ICR7cn0oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTJEKCR7cH0sICR7dVswXX0sICR7dVsxXX0sIHJvdywgY29sKTtcbiAgICAgIHJldHVybiAke2wudGV4dHVyZTJEfSgke2F9LCB1dik7XG4gICAgfVxuICBgfWZ1bmN0aW9uICQ5KGUsdCl7bGV0IG49ZS5zaGFwZUluZm8ubG9naWNhbFNoYXBlLGE9ZS5uYW1lLHI9XCJnZXRcIithLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Euc2xpY2UoMSkscz1lLnNoYXBlSW5mby50ZXhTaGFwZTtpZihzIT1udWxsJiZ3LmFycmF5c0VxdWFsKG4scykpe2lmKHQpcmV0dXJuYFxuICAgICAgZmxvYXQgJHtyfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgIHZlYzIgdXYgPSAodmVjMihjb2wsIHJvdykgKyBoYWxmQ1IpIC8gdmVjMigke2F9VGV4U2hhcGVbMV0sICR7YX1UZXhTaGFwZVswXSk7XG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7YX0sIHV2KTtcbiAgICAgIH1cbiAgICBgO2xldCBjPXNbMF0saD1zWzFdO3JldHVybmBcbiAgICBmbG9hdCAke3J9KGludCByb3csIGludCBjb2wpIHtcbiAgICAgIHZlYzIgdXYgPSAodmVjMihjb2wsIHJvdykgKyBoYWxmQ1IpIC8gdmVjMigke2h9LjAsICR7Y30uMCk7XG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2F9LCB1dik7XG4gICAgfVxuICBgfWxldHtuZXdTaGFwZTppLGtlcHREaW1zOm99PXcuc3F1ZWV6ZVNoYXBlKG4pLGw9aTtpZihsLmxlbmd0aDxuLmxlbmd0aCl7bGV0IGM9Y3AoZSxsKSxoPVtcInJvd1wiLFwiY29sXCJdO3JldHVybmBcbiAgICAgICR7dXAoYyx0KX1cbiAgICAgIGZsb2F0ICR7cn0oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICByZXR1cm4gJHtyfSgke2RwKGgsbyl9KTtcbiAgICAgIH1cbiAgICBgfWlmKGUuc2hhcGVJbmZvLmlzVW5pZm9ybSlyZXR1cm5gXG4gICAgICBmbG9hdCAke3J9KGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZG90KHZlYzIocm93LCBjb2wpLCB2ZWMyKCR7blsxXX0sIDEpKSk7XG4gICAgICAgICR7cHAoZSl9XG4gICAgICB9XG4gICAgYDtsZXQgdT1zWzBdLHA9c1sxXSxkPUpvKGEpO3JldHVybiBwPT09MT90P2BcbiAgICAgIGZsb2F0ICR7cn0oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICBmbG9hdCBpbmRleCA9IGRvdCh2ZWMzKHJvdywgY29sLCAke2R9KSwgdmVjMygke2F9U2hhcGVbMV0sIDEsIDEpKTtcbiAgICAgICAgdmVjMiB1diA9IHZlYzIoMC41LCAoaW5kZXggKyAwLjUpIC8gZmxvYXQoJHthfVRleFNoYXBlWzBdKSk7XG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7YX0sIHV2KTtcbiAgICAgIH1cbiAgICBgOmBcbiAgICBmbG9hdCAke3J9KGludCByb3csIGludCBjb2wpIHtcbiAgICAgIGZsb2F0IGluZGV4ID0gZG90KHZlYzMocm93LCBjb2wsICR7ZH0pLCB2ZWMzKCR7blsxXX0sIDEsIDEpKTtcbiAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGluZGV4ICsgMC41KSAvICR7dX0uMCk7XG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2F9LCB1dik7XG4gICAgfVxuICBgOnU9PT0xP3Q/YFxuICAgICAgZmxvYXQgJHtyfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgIGZsb2F0IGluZGV4ID0gZG90KHZlYzMocm93LCBjb2wsICR7ZH0pLCB2ZWMzKCR7YX1TaGFwZVsxXSwgMSwgMSkpO1xuICAgICAgICB2ZWMyIHV2ID0gdmVjMigoaW5kZXggKyAwLjUpIC8gZmxvYXQoJHthfVRleFNoYXBlWzFdKSwgMC41KTtcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHthfSwgdXYpO1xuICAgICAgfVxuICAgIGA6YFxuICAgIGZsb2F0ICR7cn0oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgJHtkfSksIHZlYzMoJHtuWzFdfSwgMSwgMSkpO1xuICAgICAgdmVjMiB1diA9IHZlYzIoKGluZGV4ICsgMC41KSAvICR7cH0uMCwgMC41KTtcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7YX0sIHV2KTtcbiAgICB9XG4gIGA6dD9gXG4gICAgICBmbG9hdCAke3J9KGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxuICAgICAgICBpbnQgaW5kZXggPSByb3cgKiAke2F9U2hhcGVbMV0gKyBjb2wgKyAke2R9O1xuICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke2F9VGV4U2hhcGVbMF0sICR7YX1UZXhTaGFwZVsxXSwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2F9LCB1dik7XG4gICAgICB9XG4gICAgYDpgXG4gIGZsb2F0ICR7cn0oaW50IHJvdywgaW50IGNvbCkge1xuICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cbiAgICBpbnQgaW5kZXggPSByb3cgKiAke25bMV19ICsgY29sICsgJHtkfTtcbiAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke3V9LCAke3B9LCBpbmRleCk7XG4gICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHthfSwgdXYpO1xuICB9XG5gfWZ1bmN0aW9uIEQ5KGUsdCl7bGV0IG49ZS5zaGFwZUluZm8ubG9naWNhbFNoYXBlLGE9ZS5uYW1lLHI9XCJnZXRcIithLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Euc2xpY2UoMSkscz1lLnNoYXBlSW5mby50ZXhTaGFwZSxpPVtNYXRoLmNlaWwoc1swXS8yKSxNYXRoLmNlaWwoc1sxXS8yKV07aWYoblswXT09PTEpe2xldCBjPW4uc2xpY2UoMSksaD1bMSwyXSxtPWNwKGUsYyksZj1bXCJiXCIsXCJyb3dcIixcImNvbFwiXTtyZXR1cm5gXG4gICAgICAgICR7aUEobSx0KX1cbiAgICAgICAgdmVjNCAke3J9KGludCBiLCBpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgcmV0dXJuICR7cn0oJHtkcChmLGgpfSk7XG4gICAgICAgIH1cbiAgICAgIGB9bGV0IG89RW4oKTtpZih0KXJldHVybmBcbiAgICB2ZWM0ICR7cn0oaW50IGIsIGludCByb3csIGludCBjb2wpIHtcbiAgICAgIGl2ZWMyIHBhY2tlZFRleFNoYXBlID0gaXZlYzIoY2VpbChmbG9hdCgke2F9VGV4U2hhcGVbMF0pIC8gMi4wKSwgY2VpbChmbG9hdCgke2F9VGV4U2hhcGVbMV0pIC8gMi4wKSk7XG4gICAgICBpbnQgdmFsdWVzUGVyUm93ID0gaW50KGNlaWwoZmxvYXQoJHthfVNoYXBlWzJdKSAvIDIuMCkpO1xuICAgICAgaW50IHRleGVsc0luQmF0Y2ggPSB2YWx1ZXNQZXJSb3cgKiBpbnQoY2VpbChmbG9hdCgke2F9U2hhcGVbMV0pIC8gMi4wKSk7XG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tM0QoXG4gICAgICAgIHBhY2tlZFRleFNoYXBlWzBdLCBwYWNrZWRUZXhTaGFwZVsxXSwgdGV4ZWxzSW5CYXRjaCwgdmFsdWVzUGVyUm93LCBiLCByb3csIGNvbCk7XG4gICAgICByZXR1cm4gJHtvLnRleHR1cmUyRH0oJHthfSwgdXYpO1xuICAgIH1cbiAgYDtsZXQgbD1pWzBdLHU9aVsxXSxwPU1hdGguY2VpbChuWzJdLzIpLGQ9cCpNYXRoLmNlaWwoblsxXS8yKTtyZXR1cm5gXG4gICAgdmVjNCAke3J9KGludCBiLCBpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tM0QoXG4gICAgICAgICR7bH0sICR7dX0sICR7ZH0sICR7cH0sIGIsIHJvdywgY29sKTtcbiAgICAgIHJldHVybiAke28udGV4dHVyZTJEfSgke2F9LCB1dik7XG4gICAgfVxuICBgfWZ1bmN0aW9uIFI5KGUsdCl7bGV0IG49ZS5zaGFwZUluZm8ubG9naWNhbFNoYXBlLGE9ZS5uYW1lLHI9XCJnZXRcIithLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Euc2xpY2UoMSkscz1uWzFdKm5bMl0saT1uWzJdLHtuZXdTaGFwZTpvLGtlcHREaW1zOmx9PXcuc3F1ZWV6ZVNoYXBlKG4pLHU9bztpZih1Lmxlbmd0aDxuLmxlbmd0aCl7bGV0IGY9Y3AoZSx1KSxnPVtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiXTtyZXR1cm5gXG4gICAgICAgICR7dXAoZix0KX1cbiAgICAgICAgZmxvYXQgJHtyfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcbiAgICAgICAgICByZXR1cm4gJHtyfSgke2RwKGcsbCl9KTtcbiAgICAgICAgfVxuICAgICAgYH1pZihlLnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuYFxuICAgICAgZmxvYXQgJHtyfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZG90KHZlYzMocm93LCBjb2wsIGRlcHRoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMygke3N9LCAke2l9LCAxKSkpO1xuICAgICAgICAke3BwKGUpfVxuICAgICAgfVxuICAgIGA7bGV0IHA9ZS5zaGFwZUluZm8udGV4U2hhcGUsZD1wWzBdLGM9cFsxXSxoPWUuc2hhcGVJbmZvLmZsYXRPZmZzZXQ7aWYoYz09PXMmJmg9PW51bGwpcmV0dXJuIHQ/YFxuICAgICAgZmxvYXQgJHtyfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcbiAgICAgICAgaW50IHN0cmlkZTEgPSAke2F9U2hhcGVbMl07XG4gICAgICAgIGZsb2F0IHRleFIgPSBmbG9hdChyb3cpO1xuICAgICAgICBmbG9hdCB0ZXhDID0gZG90KHZlYzIoY29sLCBkZXB0aCksIHZlYzIoc3RyaWRlMSwgMSkpO1xuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cbiAgICAgICAgICAgICAgICAgICB2ZWMyKCR7YX1UZXhTaGFwZVsxXSwgJHthfVRleFNoYXBlWzBdKTtcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHthfSwgdXYpO1xuICAgICAgfVxuICAgIGA6YFxuICAgICAgICBmbG9hdCAke3J9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xuICAgICAgICAgIGZsb2F0IHRleFIgPSBmbG9hdChyb3cpO1xuICAgICAgICAgIGZsb2F0IHRleEMgPSBkb3QodmVjMihjb2wsIGRlcHRoKSwgdmVjMigke2l9LCAxKSk7XG4gICAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXG4gICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7Y30uMCwgJHtkfS4wKTtcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2F9LCB1dik7XG4gICAgICAgIH1cbiAgICAgIGA7aWYoYz09PWkmJmg9PW51bGwpcmV0dXJuIHQ/YFxuICAgICAgZmxvYXQgJHtyfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcbiAgICAgICAgZmxvYXQgdGV4UiA9IGRvdCh2ZWMyKHJvdywgY29sKSwgdmVjMigke2F9U2hhcGVbMV0sIDEpKTtcbiAgICAgICAgZmxvYXQgdGV4QyA9IGZsb2F0KGRlcHRoKTtcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoJHthfVRleFNoYXBlWzFdLCAke2F9VGV4U2hhcGVbMF0pO1xuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2F9LCB1dik7XG4gICAgICB9XG4gICAgYDpgXG4gICAgZmxvYXQgJHtyfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcbiAgICAgIGZsb2F0IHRleFIgPSBkb3QodmVjMihyb3csIGNvbCksIHZlYzIoJHtuWzFdfSwgMSkpO1xuICAgICAgZmxvYXQgdGV4QyA9IGZsb2F0KGRlcHRoKTtcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKCR7Y30uMCwgJHtkfS4wKTtcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7YX0sIHV2KTtcbiAgICB9XG4gIGA7bGV0IG09Sm8oYSk7cmV0dXJuIHQ/YFxuICAgIGZsb2F0ICR7cn0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XG4gICAgICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXG4gICAgICBpbnQgc3RyaWRlMCA9ICR7YX1TaGFwZVsxXSAqICR7YX1TaGFwZVsyXTtcbiAgICAgIGludCBzdHJpZGUxID0gJHthfVNoYXBlWzJdO1xuICAgICAgaW50IGluZGV4ID0gcm93ICogc3RyaWRlMCArIGNvbCAqIHN0cmlkZTEgKyBkZXB0aCArICR7bX07XG4gICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke2F9VGV4U2hhcGVbMF0sICR7YX1UZXhTaGFwZVsxXSwgaW5kZXgpO1xuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHthfSwgdXYpO1xuICAgIH1cbiAgICBgOmBcbiAgICAgIGZsb2F0ICR7cn0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XG4gICAgICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cbiAgICAgICAgaW50IGluZGV4ID0gcm93ICogJHtzfSArIGNvbCAqICR7aX0gKyBkZXB0aCArICR7bX07XG4gICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7ZH0sICR7Y30sIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHthfSwgdXYpO1xuICAgICAgfVxuICBgfWZ1bmN0aW9uIE05KGUsdCl7bGV0IG49ZS5uYW1lLGE9XCJnZXRcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSkscj1FbigpO2lmKHQpcmV0dXJuYFxuICAgIHZlYzQgJHthfShpbnQgYjIsIGludCBiLCBpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICBpbnQgdmFsdWVzUGVyUm93ID0gaW50KGNlaWwoZmxvYXQoJHtufVNoYXBlWzNdKSAvIDIuMCkpO1xuICAgICAgaW50IHRleGVsc0luQmF0Y2ggPSB2YWx1ZXNQZXJSb3cgKiBpbnQoY2VpbChmbG9hdCgke259U2hhcGVbMl0pIC8gMi4wKSk7XG4gICAgICBpbnQgaW5kZXggPSBiICogdGV4ZWxzSW5CYXRjaCArIChyb3cgLyAyKSAqIHZhbHVlc1BlclJvdyArIChjb2wgLyAyKTtcbiAgICAgIHRleGVsc0luQmF0Y2ggKj0gJHtufVNoYXBlWzFdO1xuICAgICAgaW5kZXggPSBiMiAqIHRleGVsc0luQmF0Y2ggKyBpbmRleDtcbiAgICAgIGl2ZWMyIHBhY2tlZFRleFNoYXBlID0gaXZlYzIoY2VpbChmbG9hdCgke259VGV4U2hhcGVbMF0pIC8gMi4wKSwgY2VpbChmbG9hdCgke259VGV4U2hhcGVbMV0pIC8gMi4wKSk7XG4gICAgICBpbnQgdGV4UiA9IGluZGV4IC8gcGFja2VkVGV4U2hhcGVbMV07XG4gICAgICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHBhY2tlZFRleFNoYXBlWzFdO1xuICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIocGFja2VkVGV4U2hhcGVbMV0sIHBhY2tlZFRleFNoYXBlWzBdKTsgcmV0dXJuICR7ci50ZXh0dXJlMkR9KCR7bn0sIHV2KTtcbiAgICB9XG4gIGA7bGV0IHM9ZS5zaGFwZUluZm8ubG9naWNhbFNoYXBlLGk9cy5sZW5ndGgsbz1lLnNoYXBlSW5mby50ZXhTaGFwZSxsPVtNYXRoLmNlaWwob1swXS8yKSxNYXRoLmNlaWwob1sxXS8yKV0sdT1sWzBdLHA9bFsxXSxkPU1hdGguY2VpbChzW2ktMV0vMiksYz1kKk1hdGguY2VpbChzW2ktMl0vMiksaD1cImludCBiLCBpbnQgcm93LCBpbnQgY29sXCIsbT1gYiAqICR7Y30gKyAocm93IC8gMikgKiAke2R9ICsgKGNvbCAvIDIpYDtmb3IobGV0IGY9MjtmPGktMTtmKyspaD1gaW50IGIke2Z9LCBgK2gsYyo9c1tpLWYtMV0sbT1gYiR7Zn0gKiAke2N9ICsgYCttO3JldHVybmBcbiAgICB2ZWM0ICR7YX0oJHtofSkge1xuICAgICAgaW50IGluZGV4ID0gJHttfTtcbiAgICAgIGludCB0ZXhSID0gaW5kZXggLyAke3B9O1xuICAgICAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiAke3B9O1xuICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoJHtwfSwgJHt1fSk7XG4gICAgICByZXR1cm4gJHtyLnRleHR1cmUyRH0oJHtufSwgdXYpO1xuICAgIH1cbiAgYH1mdW5jdGlvbiBPOShlLHQpe2xldCBuPWUuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxhPWUubmFtZSxyPVwiZ2V0XCIrYS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSthLnNsaWNlKDEpLHM9blszXSxpPW5bMl0qcyxvPW5bMV0qaSx7bmV3U2hhcGU6bCxrZXB0RGltczp1fT13LnNxdWVlemVTaGFwZShuKTtpZihsLmxlbmd0aDxuLmxlbmd0aCl7bGV0IHk9Y3AoZSxsKSx4PVtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiLFwiZGVwdGgyXCJdO3JldHVybmBcbiAgICAgICR7dXAoeSx0KX1cbiAgICAgIGZsb2F0ICR7cn0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XG4gICAgICAgIHJldHVybiAke3J9KCR7ZHAoeCx1KX0pO1xuICAgICAgfVxuICAgIGB9aWYoZS5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVybmBcbiAgICAgIGZsb2F0ICR7cn0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XG4gICAgICAgIGludCBpbmRleCA9IHJvdW5kKGRvdCh2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCgke299LCAke2l9LCAke3N9LCAxKSkpO1xuICAgICAgICAke3BwKGUpfVxuICAgICAgfVxuICAgIGA7bGV0IHA9ZS5zaGFwZUluZm8uZmxhdE9mZnNldCxkPWUuc2hhcGVJbmZvLnRleFNoYXBlLGM9ZFswXSxoPWRbMV0sbT1gaW50IHN0cmlkZTIgPSAke2F9U2hhcGVbM107YCxmPWBpbnQgc3RyaWRlMSA9ICR7YX1TaGFwZVsyXSAqIHN0cmlkZTI7YCxnPWBpbnQgc3RyaWRlMCA9ICR7YX1TaGFwZVsxXSAqIHN0cmlkZTE7YDtpZihoPT09byYmcD09bnVsbClyZXR1cm4gdD9gXG4gICAgICBmbG9hdCAke3J9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xuICAgICAgICAke219XG4gICAgICAgICR7Zn1cbiAgICAgICAgZmxvYXQgdGV4UiA9IGZsb2F0KHJvdyk7XG4gICAgICAgIGZsb2F0IHRleEMgPVxuICAgICAgICAgICAgZG90KHZlYzMoY29sLCBkZXB0aCwgZGVwdGgyKSxcbiAgICAgICAgICAgICAgICB2ZWMzKHN0cmlkZTEsIHN0cmlkZTIsIDEpKTtcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXG4gICAgICAgICAgICAgICAgICAgdmVjMigke2F9VGV4U2hhcGVbMV0sICR7YX1UZXhTaGFwZVswXSk7XG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7YX0sIHV2KTtcbiAgICAgIH1cbiAgICBgOmBcbiAgICAgIGZsb2F0ICR7cn0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XG4gICAgICAgIGZsb2F0IHRleFIgPSBmbG9hdChyb3cpO1xuICAgICAgICBmbG9hdCB0ZXhDID1cbiAgICAgICAgICAgIGRvdCh2ZWMzKGNvbCwgZGVwdGgsIGRlcHRoMiksXG4gICAgICAgICAgICAgICAgdmVjMygke2l9LCAke3N9LCAxKSk7XG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xuICAgICAgICAgICAgICAgICAgIHZlYzIoJHtofS4wLCAke2N9LjApO1xuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2F9LCB1dik7XG4gICAgICB9XG4gICAgYDtpZihoPT09cyYmcD09bnVsbClyZXR1cm4gdD9gXG4gICAgICBmbG9hdCAke3J9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xuICAgICAgICBmbG9hdCB0ZXhSID0gZG90KHZlYzMocm93LCBjb2wsIGRlcHRoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMzKCR7YX1TaGFwZVsxXSAqICR7YX1TaGFwZVsyXSwgJHthfVNoYXBlWzJdLCAxKSk7XG4gICAgICAgIGZsb2F0IHRleEMgPSBmbG9hdChkZXB0aDIpO1xuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cbiAgICAgICAgICAgICAgICAgIHZlYzIoJHthfVRleFNoYXBlWzFdLCAke2F9VGV4U2hhcGVbMF0pO1xuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2F9LCB1dik7XG4gICAgICB9XG4gICAgYDpgXG4gICAgICBmbG9hdCAke3J9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xuICAgICAgICBmbG9hdCB0ZXhSID0gZG90KHZlYzMocm93LCBjb2wsIGRlcHRoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMzKCR7blsxXSpuWzJdfSwgJHtuWzJdfSwgMSkpO1xuICAgICAgICBmbG9hdCB0ZXhDID0gZmxvYXQoZGVwdGgyKTtcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXG4gICAgICAgICAgICAgICAgICB2ZWMyKCR7aH0uMCwgJHtjfS4wKTtcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHthfSwgdXYpO1xuICAgICAgfVxuICAgIGA7bGV0IGI9Sm8oYSk7cmV0dXJuIHQ/YFxuICAgIGZsb2F0ICR7cn0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XG4gICAgICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXG4gICAgICAke219XG4gICAgICAke2Z9XG4gICAgICAke2d9XG4gICAgICBpbnQgaW5kZXggPSByb3cgKiBzdHJpZGUwICsgY29sICogc3RyaWRlMSArXG4gICAgICAgICAgZGVwdGggKiBzdHJpZGUyICsgZGVwdGgyO1xuICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHthfVRleFNoYXBlWzBdLCAke2F9VGV4U2hhcGVbMV0sIGluZGV4ICsgJHtifSk7XG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2F9LCB1dik7XG4gICAgfVxuICBgOmBcbiAgICBmbG9hdCAke3J9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xuICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxuICAgICAgaW50IGluZGV4ID0gcm93ICogJHtvfSArIGNvbCAqICR7aX0gK1xuICAgICAgICAgIGRlcHRoICogJHtzfSArIGRlcHRoMjtcbiAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7Y30sICR7aH0sIGluZGV4ICsgJHtifSk7XG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2F9LCB1dik7XG4gICAgfVxuICBgfWZ1bmN0aW9uIFA5KGUpe2xldCB0PWUuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxuPWUubmFtZSxhPVwiZ2V0XCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLHI9dFs0XSxzPXRbM10qcixpPXRbMl0qcyxvPXRbMV0qaSx7bmV3U2hhcGU6bCxrZXB0RGltczp1fT13LnNxdWVlemVTaGFwZSh0KTtpZihsLmxlbmd0aDx0Lmxlbmd0aCl7bGV0IGY9Y3AoZSxsKSxnPVtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiLFwiZGVwdGgyXCIsXCJkZXB0aDNcIl07cmV0dXJuYFxuICAgICAgJHt1cChmKX1cbiAgICAgIGZsb2F0ICR7YX0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XG4gICAgICAgIHJldHVybiAke2F9KCR7ZHAoZyx1KX0pO1xuICAgICAgfVxuICAgIGB9aWYoZS5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVybmBcbiAgICAgIGZsb2F0ICR7YX0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XG4gICAgICAgIGZsb2F0IGluZGV4ID0gZG90KFxuICAgICAgICAgIHZlYzQocm93LCBjb2wsIGRlcHRoLCBkZXB0aDIpLFxuICAgICAgICAgIHZlYzQoJHtvfSwgJHtpfSwgJHtzfSwgJHtyfSkpICtcbiAgICAgICAgICBkZXB0aDM7XG4gICAgICAgICR7cHAoZSl9XG4gICAgICB9XG4gICAgYDtsZXQgcD1lLnNoYXBlSW5mby5mbGF0T2Zmc2V0LGQ9ZS5zaGFwZUluZm8udGV4U2hhcGUsYz1kWzBdLGg9ZFsxXTtpZihoPT09byYmcD09bnVsbClyZXR1cm5gXG4gICAgICBmbG9hdCAke2F9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xuICAgICAgICBpbnQgdGV4UiA9IHJvdztcbiAgICAgICAgZmxvYXQgdGV4QyA9IGRvdCh2ZWM0KGNvbCwgZGVwdGgsIGRlcHRoMiwgZGVwdGgzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICB2ZWM0KCR7aX0sICR7c30sICR7cn0sIDEpKTtcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXG4gICAgICAgICAgICAgICAgICAgdmVjMigke2h9LjAsICR7Y30uMCk7XG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bn0sIHV2KTtcbiAgICAgIH1cbiAgICBgO2lmKGg9PT1yJiZwPT1udWxsKXJldHVybmBcbiAgICAgIGZsb2F0ICR7YX0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XG4gICAgICAgIGZsb2F0IHRleFIgPSBkb3QoXG4gICAgICAgICAgdmVjNChyb3csIGNvbCwgZGVwdGgsIGRlcHRoMiksXG4gICAgICAgICAgdmVjNCgke3RbMV0qdFsyXSp0WzNdfSxcbiAgICAgICAgICAgICAgICR7dFsyXSp0WzNdfSwgJHt0WzNdfSwgMSkpO1xuICAgICAgICBpbnQgdGV4QyA9IGRlcHRoMztcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXG4gICAgICAgICAgICAgICAgICB2ZWMyKCR7aH0uMCwgJHtjfS4wKTtcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtufSwgdXYpO1xuICAgICAgfVxuICAgIGA7bGV0IG09Sm8obik7cmV0dXJuYFxuICAgIGZsb2F0ICR7YX0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XG4gICAgICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXG4gICAgICBpbnQgaW5kZXggPSByb3cgKiAke299ICsgY29sICogJHtpfSArIGRlcHRoICogJHtzfSArXG4gICAgICAgICAgZGVwdGgyICogJHtyfSArIGRlcHRoMyArICR7bX07XG4gICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke2N9LCAke2h9LCBpbmRleCk7XG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke259LCB1dik7XG4gICAgfVxuICBgfWZ1bmN0aW9uIEw5KGUpe2xldCB0PWUuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxuPWUubmFtZSxhPVwiZ2V0XCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLHtuZXdTaGFwZTpyLGtlcHREaW1zOnN9PXcuc3F1ZWV6ZVNoYXBlKHQpO2lmKHIubGVuZ3RoPHQubGVuZ3RoKXtsZXQgZz1jcChlLHIpLGI9W1wicm93XCIsXCJjb2xcIixcImRlcHRoXCIsXCJkZXB0aDJcIixcImRlcHRoM1wiLFwiZGVwdGg0XCJdO3JldHVybmBcbiAgICAgICR7dXAoZyl9XG4gICAgICBmbG9hdCAke2F9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcbiAgICAgICAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xuICAgICAgICByZXR1cm4gJHthfSgke2RwKGIscyl9KTtcbiAgICAgIH1cbiAgICBgfWxldCBpPXRbNV0sbz10WzRdKmksbD10WzNdKm8sdT10WzJdKmwscD10WzFdKnU7aWYoZS5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVybmBcbiAgICAgIGZsb2F0ICR7YX0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxuICAgICAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xuICAgICAgICBpbnQgaW5kZXggPSByb3VuZChkb3QoXG4gICAgICAgICAgdmVjNChyb3csIGNvbCwgZGVwdGgsIGRlcHRoMiksXG4gICAgICAgICAgdmVjNCgke3B9LCAke3V9LCAke2x9LCAke299KSkgK1xuICAgICAgICAgIGRvdChcbiAgICAgICAgICAgIHZlYzIoZGVwdGgzLCBkZXB0aDQpLFxuICAgICAgICAgICAgdmVjMigke2l9LCAxKSkpO1xuICAgICAgICAke3BwKGUpfVxuICAgICAgfVxuICAgIGA7bGV0IGQ9ZS5zaGFwZUluZm8uZmxhdE9mZnNldCxjPWUuc2hhcGVJbmZvLnRleFNoYXBlLGg9Y1swXSxtPWNbMV07aWYobT09PXAmJmQ9PW51bGwpcmV0dXJuYFxuICAgICAgZmxvYXQgJHthfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXG4gICAgICAgICAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcbiAgICAgICAgaW50IHRleFIgPSByb3c7XG4gICAgICAgIGZsb2F0IHRleEMgPSBkb3QodmVjNChjb2wsIGRlcHRoLCBkZXB0aDIsIGRlcHRoMyksXG4gICAgICAgICAgdmVjNCgke3V9LCAke2x9LCAke299LCAke2l9KSkgK1xuICAgICAgICAgICAgICAgZmxvYXQoZGVwdGg0KTtcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXG4gICAgICAgICAgICAgICAgICAgdmVjMigke219LjAsICR7aH0uMCk7XG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bn0sIHV2KTtcbiAgICAgIH1cbiAgICBgO2lmKG09PT1pJiZkPT1udWxsKXJldHVybmBcbiAgICAgIGZsb2F0ICR7YX0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxuICAgICAgICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XG4gICAgICAgIGZsb2F0IHRleFIgPSBkb3QodmVjNChyb3csIGNvbCwgZGVwdGgsIGRlcHRoMiksXG4gICAgICAgICAgdmVjNCgke3RbMV0qdFsyXSp0WzNdKnRbNF19LFxuICAgICAgICAgICAgICAgJHt0WzJdKnRbM10qdFs0XX0sXG4gICAgICAgICAgICAgICAke3RbM10qdFs0XX0sXG4gICAgICAgICAgICAgICAke3RbNF19KSkgKyBmbG9hdChkZXB0aDMpO1xuICAgICAgICBpbnQgdGV4QyA9IGRlcHRoNDtcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXG4gICAgICAgICAgICAgICAgICB2ZWMyKCR7bX0uMCwgJHtofS4wKTtcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtufSwgdXYpO1xuICAgICAgfVxuICAgIGA7bGV0IGY9Sm8obik7cmV0dXJuYFxuICAgIGZsb2F0ICR7YX0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxuICAgICAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xuICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxuICAgICAgaW50IGluZGV4ID0gcm93ICogJHtwfSArIGNvbCAqICR7dX0gKyBkZXB0aCAqICR7bH0gK1xuICAgICAgICAgIGRlcHRoMiAqICR7b30gKyBkZXB0aDMgKiAke2l9ICsgZGVwdGg0ICsgJHtmfTtcbiAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7aH0sICR7bX0sIGluZGV4KTtcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bn0sIHV2KTtcbiAgICB9XG4gIGB9ZnVuY3Rpb24gcHAoZSl7bGV0IHQ9ZS5uYW1lLG49dy5zaXplRnJvbVNoYXBlKGUuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSk7cmV0dXJuIG48Mj9gcmV0dXJuICR7dH07YDpgXG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke259OyBpKyspIHtcbiAgICAgIGlmIChpID09IGluZGV4KSB7XG4gICAgICAgIHJldHVybiAke3R9W2ldO1xuICAgICAgfVxuICAgIH1cbiAgYH1mdW5jdGlvbiB6OShlLHQpe2xldCBuPWUubmFtZSxhPW4uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxyPVwiZ2V0XCIrYStcIkF0T3V0Q29vcmRzXCIscz1lLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUubGVuZ3RoLGk9dC5sb2dpY2FsU2hhcGUubGVuZ3RoLG89c0EoZS5zaGFwZUluZm8ubG9naWNhbFNoYXBlLHQubG9naWNhbFNoYXBlKSxsPWh0KGkpLHU9aS1zLHAsZD1bXCJ4XCIsXCJ5XCIsXCJ6XCIsXCJ3XCIsXCJ1XCIsXCJ2XCJdO3M9PT0wP3A9XCJcIjppPDImJm8ubGVuZ3RoPj0xP3A9XCJjb29yZHMgPSAwO1wiOnA9by5tYXAoZz0+YGNvb3Jkcy4ke2RbZyt1XX0gPSAwO2ApLmpvaW4oYFxuYCk7bGV0IGM9XCJcIjtpPDImJnM+MD9jPVwiY29vcmRzXCI6Yz1lLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUubWFwKChnLGIpPT5gY29vcmRzLiR7ZFtiK3VdfWApLmpvaW4oXCIsIFwiKTtsZXQgaD1cInJldHVybiBvdXRwdXRWYWx1ZTtcIixtPXcuc2l6ZUZyb21TaGFwZShlLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUpPT09MSxmPXcuc2l6ZUZyb21TaGFwZSh0LmxvZ2ljYWxTaGFwZSk9PT0xO2lmKHM9PT0xJiYhbSYmIWYpaD1gXG4gICAgICByZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54eSwgb3V0cHV0VmFsdWUueHkpO1xuICAgIGA7ZWxzZSBpZihtJiYhZilpPT09MT9oPWBcbiAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueCwgMC4sIDAuKTtcbiAgICAgIGA6aD1gXG4gICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngpO1xuICAgICAgYDtlbHNlIGlmKG8ubGVuZ3RoKXtsZXQgZz1zLTIsYj1zLTE7by5pbmRleE9mKGcpPi0xJiZvLmluZGV4T2YoYik+LTE/aD1cInJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngpO1wiOm8uaW5kZXhPZihnKT4tMT9oPVwicmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSwgb3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSk7XCI6by5pbmRleE9mKGIpPi0xJiYoaD1cInJldHVybiB2ZWM0KG91dHB1dFZhbHVlLnh4LCBvdXRwdXRWYWx1ZS56eik7XCIpfXJldHVybmBcbiAgICB2ZWM0ICR7cn0oKSB7XG4gICAgICAke2x9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgJHtwfVxuICAgICAgdmVjNCBvdXRwdXRWYWx1ZSA9IGdldCR7YX0oJHtjfSk7XG4gICAgICAke2h9XG4gICAgfVxuICBgfWZ1bmN0aW9uIFc5KGUsdCl7bGV0IG49ZS5uYW1lLGE9bi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLHI9XCJnZXRcIithK1wiQXRPdXRDb29yZHNcIixzPXQudGV4U2hhcGUsaT1lLnNoYXBlSW5mby50ZXhTaGFwZSxvPWUuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5sZW5ndGgsbD10LmxvZ2ljYWxTaGFwZS5sZW5ndGg7aWYoIWUuc2hhcGVJbmZvLmlzVW5pZm9ybSYmbz09PWwmJmUuc2hhcGVJbmZvLmZsYXRPZmZzZXQ9PW51bGwmJncuYXJyYXlzRXF1YWwoaSxzKSlyZXR1cm5gXG4gICAgICBmbG9hdCAke3J9KCkge1xuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke259LCByZXN1bHRVVik7XG4gICAgICB9XG4gICAgYDtsZXQgdT1odChsKSxwPXNBKGUuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSx0LmxvZ2ljYWxTaGFwZSksZD1sLW8sYyxoPVtcInhcIixcInlcIixcInpcIixcIndcIixcInVcIixcInZcIl07bz09PTA/Yz1cIlwiOmw8MiYmcC5sZW5ndGg+PTE/Yz1cImNvb3JkcyA9IDA7XCI6Yz1wLm1hcChmPT5gY29vcmRzLiR7aFtmK2RdfSA9IDA7YCkuam9pbihgXG5gKTtsZXQgbT1cIlwiO3JldHVybiBsPDImJm8+MD9tPVwiY29vcmRzXCI6bT1lLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUubWFwKChmLGcpPT5gY29vcmRzLiR7aFtnK2RdfWApLmpvaW4oXCIsIFwiKSxgXG4gICAgZmxvYXQgJHtyfSgpIHtcbiAgICAgICR7dX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAke2N9XG4gICAgICByZXR1cm4gZ2V0JHthfSgke219KTtcbiAgICB9XG4gIGB9ZnVuY3Rpb24gaHQoZSl7aWYoZTw9MSlyZXR1cm5cImludFwiO2lmKGU9PT0yKXJldHVyblwiaXZlYzJcIjtpZihlPT09MylyZXR1cm5cIml2ZWMzXCI7aWYoZT09PTQpcmV0dXJuXCJpdmVjNFwiO2lmKGU9PT01KXJldHVyblwiaXZlYzVcIjtpZihlPT09NilyZXR1cm5cIml2ZWM2XCI7dGhyb3cgRXJyb3IoYEdQVSBmb3IgcmFuayAke2V9IGlzIG5vdCB5ZXQgc3VwcG9ydGVkYCl9ZnVuY3Rpb24gdGsoZSx0LG4pe2xldHtuZXdTaGFwZTphLGtlcHREaW1zOnJ9PXcuc3F1ZWV6ZVNoYXBlKHQpLHM9dC5sZW5ndGgsaT1lJiZzPT09MyYmdFswXT09PTEsbz1pP3Quc2xpY2UoMSk6YSxsPSFlJiZzPjEmJiF3LmFycmF5c0VxdWFsKHQsbikmJmEubGVuZ3RoPHN8fGk7cmV0dXJue3VzZVNxdWVlemVTaGFwZTpsLHVuaWZvcm1TaGFwZTpsP286dCxrZXB0RGltczpyfX1mdW5jdGlvbiBjcChlLHQpe2xldCBuPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZSkpO3JldHVybiBuLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU9dCxufWZ1bmN0aW9uIGRwKGUsdCl7cmV0dXJuIHQubWFwKG49PmVbbl0pLmpvaW4oXCIsIFwiKX1mdW5jdGlvbiBCOShlLHQsbixhKXtsZXQgcj1uLm1hcCgocCxkKT0+e2xldCBjPXtsb2dpY2FsU2hhcGU6cC5zaGFwZSx0ZXhTaGFwZTpwLmlzVW5pZm9ybT9udWxsOnAudGV4RGF0YS50ZXhTaGFwZSxpc1VuaWZvcm06cC5pc1VuaWZvcm0saXNQYWNrZWQ6cC5pc1VuaWZvcm0/ITE6cC50ZXhEYXRhLmlzUGFja2VkLGZsYXRPZmZzZXQ6bnVsbH07cmV0dXJuIHAudGV4RGF0YSE9bnVsbCYmcC50ZXhEYXRhLnNsaWNlIT1udWxsJiZwLnRleERhdGEuc2xpY2UuZmxhdE9mZnNldD4wJiYoYy5mbGF0T2Zmc2V0PXAudGV4RGF0YS5zbGljZS5mbGF0T2Zmc2V0KSx7bmFtZTp0LnZhcmlhYmxlTmFtZXNbZF0sc2hhcGVJbmZvOmN9fSkscz1yLm1hcChwPT5wLnNoYXBlSW5mbyksaT17bG9naWNhbFNoYXBlOmEuc2hhcGUsdGV4U2hhcGU6YS50ZXhEYXRhLnRleFNoYXBlLGlzVW5pZm9ybTohMSxpc1BhY2tlZDphLnRleERhdGEuaXNQYWNrZWQsZmxhdE9mZnNldDpudWxsfSxvPXM5KHIsaSx0KSxsPVBfKGUuZ2wsbyksdT1lLmNyZWF0ZVByb2dyYW0obCk7cmV0dXJuIEcoKS5nZXQoXCJFTkdJTkVfQ09NUElMRV9PTkxZXCIpP3twcm9ncmFtOnQsZnJhZ21lbnRTaGFkZXI6bCxzb3VyY2U6byx3ZWJHTFByb2dyYW06dSxpblNoYXBlSW5mb3M6cyxvdXRTaGFwZUluZm86aSx2YXJpYWJsZXNMb2NhdGlvbnM6bnVsbCxjdXN0b21Vbmlmb3JtTG9jYXRpb25zOm51bGwsaW5mTG9jOm51bGwsbmFuTG9jOm51bGwsb3V0U2hhcGVMb2NhdGlvbjpudWxsLG91dFNoYXBlU3RyaWRlc0xvY2F0aW9uOm51bGwsb3V0VGV4U2hhcGVMb2NhdGlvbjpudWxsfTooZS5idWlsZFZhbyh1KSxPYmplY3QuYXNzaWduKHtwcm9ncmFtOnQsZnJhZ21lbnRTaGFkZXI6bCxzb3VyY2U6byx3ZWJHTFByb2dyYW06dSxpblNoYXBlSW5mb3M6cyxvdXRTaGFwZUluZm86aX0sbEEoZSx0LHUpKSl9ZnVuY3Rpb24gbEEoZSx0LG4pe2xldCBhPVtdLHI9W10scyxpLG8sbD1udWxsLHU9bnVsbDt1PWUuZ2V0VW5pZm9ybUxvY2F0aW9uKG4sXCJOQU5cIiwhMSksRygpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik9PT0xJiYobD1lLmdldFVuaWZvcm1Mb2NhdGlvbihuLFwiSU5GSU5JVFlcIiwhMSkpO2xldCBwPSExO2ZvcihsZXQgZCBvZiB0LnZhcmlhYmxlTmFtZXMpe2xldCBjPXtuYW1lOmQsdW5pZm9ybTplLmdldFVuaWZvcm1Mb2NhdGlvbihuLGQscCksb2Zmc2V0OmUuZ2V0VW5pZm9ybUxvY2F0aW9uKG4sYG9mZnNldCR7ZH1gLHApfTt0LmVuYWJsZVNoYXBlVW5pZm9ybXMmJihjLnNoYXBlPWUuZ2V0VW5pZm9ybUxvY2F0aW9uKG4sYCR7ZH1TaGFwZWAscCksYy50ZXhTaGFwZT1lLmdldFVuaWZvcm1Mb2NhdGlvbihuLGAke2R9VGV4U2hhcGVgLHApKSxhLnB1c2goYyl9aWYodC5lbmFibGVTaGFwZVVuaWZvcm1zJiYocz1lLmdldFVuaWZvcm1Mb2NhdGlvbihuLFwib3V0U2hhcGVcIixwKSxvPWUuZ2V0VW5pZm9ybUxvY2F0aW9uKG4sXCJvdXRTaGFwZVN0cmlkZXNcIixwKSxpPWUuZ2V0VW5pZm9ybUxvY2F0aW9uKG4sXCJvdXRUZXhTaGFwZVwiLHApKSx0LmN1c3RvbVVuaWZvcm1zKWZvcihsZXQgZCBvZiB0LmN1c3RvbVVuaWZvcm1zKXIucHVzaChlLmdldFVuaWZvcm1Mb2NhdGlvbihuLGQubmFtZSxwKSk7cmV0dXJue3ZhcmlhYmxlc0xvY2F0aW9uczphLGN1c3RvbVVuaWZvcm1Mb2NhdGlvbnM6cixpbmZMb2M6bCxuYW5Mb2M6dSxvdXRTaGFwZUxvY2F0aW9uOnMsb3V0U2hhcGVTdHJpZGVzTG9jYXRpb246byxvdXRUZXhTaGFwZUxvY2F0aW9uOml9fWZ1bmN0aW9uIG5TKGUsdCl7aWYoZS5sZW5ndGghPT10Lmxlbmd0aCl0aHJvdyBFcnJvcihgQmluYXJ5IHdhcyBjb21waWxlZCB3aXRoICR7ZS5sZW5ndGh9IGlucHV0cywgYnV0IHdhcyBleGVjdXRlZCB3aXRoICR7dC5sZW5ndGh9IGlucHV0c2ApO2UuZm9yRWFjaCgobixhKT0+e2xldCByPW4ubG9naWNhbFNoYXBlLHM9dFthXSxpPXMuc2hhcGU7aWYoIXcuYXJyYXlzRXF1YWwocixpKSl0aHJvdyBFcnJvcihgQmluYXJ5IHdhcyBjb21waWxlZCB3aXRoIGRpZmZlcmVudCBzaGFwZXMgdGhhbiB0aGUgY3VycmVudCBhcmdzLiBTaGFwZXMgJHtyfSBhbmQgJHtpfSBtdXN0IG1hdGNoYCk7aWYobi5pc1VuaWZvcm0mJnMuaXNVbmlmb3JtKXJldHVybjtsZXQgbz1uLnRleFNoYXBlLGw9cy5pc1VuaWZvcm0/bnVsbDpzLnRleERhdGEudGV4U2hhcGU7aWYoIXcuYXJyYXlzRXF1YWwobyxsKSl0aHJvdyBFcnJvcihgQmluYXJ5IHdhcyBjb21waWxlZCB3aXRoIGRpZmZlcmVudCB0ZXh0dXJlIHNoYXBlcyB0aGFuIHRoZSBjdXJyZW50IGFyZ3MuIFNoYXBlICR7b30gYW5kICR7bH0gbXVzdCBtYXRjaGApfSl9ZnVuY3Rpb24gVjkoZSx0LG4sYSxyKXt0LnByb2dyYW0uZW5hYmxlU2hhcGVVbmlmb3Jtc3x8KG5TKHQuaW5TaGFwZUluZm9zLG4pLG5TKFt0Lm91dFNoYXBlSW5mb10sW2FdKSk7bGV0IHM9YS50ZXhEYXRhLnRleHR1cmUsaT1hLnRleERhdGEudGV4U2hhcGU7YS50ZXhEYXRhLmlzUGFja2VkP2Uuc2V0T3V0cHV0UGFja2VkTWF0cml4VGV4dHVyZShzLnRleHR1cmUsaVswXSxpWzFdKTplLnNldE91dHB1dE1hdHJpeFRleHR1cmUocy50ZXh0dXJlLGlbMF0saVsxXSksZS5zZXRQcm9ncmFtKHQud2ViR0xQcm9ncmFtKSxlLmJpbmRWZXJ0ZXhBcnJheSh0LndlYkdMUHJvZ3JhbS52YW8pLEcoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpPT09MSYmdC5pbmZMb2MhPT1udWxsJiZlLmdsLnVuaWZvcm0xZih0LmluZkxvYywxLzApLHQubmFuTG9jIT09bnVsbCYmZS5nbC51bmlmb3JtMWYodC5uYW5Mb2MsTmFOKTtmb3IobGV0IGw9MDtsPG4ubGVuZ3RoOysrbCl7bGV0IHU9bltsXSx7dW5pZm9ybTpwLG9mZnNldDpkLHNoYXBlOmMsdGV4U2hhcGU6aH09dC52YXJpYWJsZXNMb2NhdGlvbnNbbF07aWYoYyl7bGV0e3VuaWZvcm1TaGFwZTptfT10ayh0LnByb2dyYW0ucGFja2VkSW5wdXRzLHUuc2hhcGUsdS50ZXhEYXRhLnRleFNoYXBlKTtzd2l0Y2gobS5sZW5ndGgpe2Nhc2UgMTplLmdsLnVuaWZvcm0xaXYoYyxuZXcgSW50MzJBcnJheShtKSk7YnJlYWs7Y2FzZSAyOmUuZ2wudW5pZm9ybTJpdihjLG5ldyBJbnQzMkFycmF5KG0pKTticmVhaztjYXNlIDM6ZS5nbC51bmlmb3JtM2l2KGMsbmV3IEludDMyQXJyYXkobSkpO2JyZWFrO2Nhc2UgNDplLmdsLnVuaWZvcm00aXYoYyxuZXcgSW50MzJBcnJheShtKSk7YnJlYWs7ZGVmYXVsdDpicmVha319aWYoaCYmZS5nbC51bmlmb3JtMmkoaCx1LnRleERhdGEudGV4U2hhcGVbMF0sdS50ZXhEYXRhLnRleFNoYXBlWzFdKSxwIT1udWxsKXtpZih1LmlzVW5pZm9ybSl7aWYody5zaXplRnJvbVNoYXBlKHUuc2hhcGUpPDIpZS5nbC51bmlmb3JtMWYocCx1LnVuaWZvcm1WYWx1ZXNbMF0pO2Vsc2V7bGV0IG09dS51bmlmb3JtVmFsdWVzO20gaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXl8fChtPW5ldyBGbG9hdDMyQXJyYXkobSkpLGUuZ2wudW5pZm9ybTFmdihwLG0pfWNvbnRpbnVlfXUudGV4RGF0YS5zbGljZSE9bnVsbCYmZCE9bnVsbCYmZS5nbC51bmlmb3JtMWkoZCx1LnRleERhdGEuc2xpY2UuZmxhdE9mZnNldCksZS5zZXRJbnB1dE1hdHJpeFRleHR1cmUodS50ZXhEYXRhLnRleHR1cmUudGV4dHVyZSxwLGwpfX1sZXQgbz10Lm91dFNoYXBlTG9jYXRpb247aWYobylzd2l0Y2goYS5zaGFwZS5sZW5ndGgpe2Nhc2UgMTplLmdsLnVuaWZvcm0xaXYobyxuZXcgSW50MzJBcnJheShhLnNoYXBlKSk7YnJlYWs7Y2FzZSAyOmUuZ2wudW5pZm9ybTJpdihvLG5ldyBJbnQzMkFycmF5KGEuc2hhcGUpKTticmVhaztjYXNlIDM6ZS5nbC51bmlmb3JtM2l2KG8sbmV3IEludDMyQXJyYXkoYS5zaGFwZSkpO2JyZWFrO2Nhc2UgNDplLmdsLnVuaWZvcm00aXYobyxuZXcgSW50MzJBcnJheShhLnNoYXBlKSk7YnJlYWs7ZGVmYXVsdDpicmVha31pZih0Lm91dFNoYXBlU3RyaWRlc0xvY2F0aW9uKXtsZXQgbD13LmNvbXB1dGVTdHJpZGVzKGEuc2hhcGUpO3N3aXRjaChhLnNoYXBlLmxlbmd0aCl7Y2FzZSAyOmUuZ2wudW5pZm9ybTFpdih0Lm91dFNoYXBlU3RyaWRlc0xvY2F0aW9uLG5ldyBJbnQzMkFycmF5KGwpKTticmVhaztjYXNlIDM6ZS5nbC51bmlmb3JtMml2KHQub3V0U2hhcGVTdHJpZGVzTG9jYXRpb24sbmV3IEludDMyQXJyYXkobCkpO2JyZWFrO2Nhc2UgNDplLmdsLnVuaWZvcm0zaXYodC5vdXRTaGFwZVN0cmlkZXNMb2NhdGlvbixuZXcgSW50MzJBcnJheShsKSk7YnJlYWs7ZGVmYXVsdDpicmVha319aWYodC5vdXRUZXhTaGFwZUxvY2F0aW9uJiZlLmdsLnVuaWZvcm0yaSh0Lm91dFRleFNoYXBlTG9jYXRpb24sYS50ZXhEYXRhLnRleFNoYXBlWzBdLGEudGV4RGF0YS50ZXhTaGFwZVsxXSksdC5wcm9ncmFtLmN1c3RvbVVuaWZvcm1zJiZyKWZvcihsZXQgbD0wO2w8dC5wcm9ncmFtLmN1c3RvbVVuaWZvcm1zLmxlbmd0aDsrK2wpe2xldCB1PXQucHJvZ3JhbS5jdXN0b21Vbmlmb3Jtc1tsXSxwPXQuY3VzdG9tVW5pZm9ybUxvY2F0aW9uc1tsXSxkPXJbbF07aWYodS50eXBlPT09XCJmbG9hdFwiKWUuZ2wudW5pZm9ybTFmdihwLGQpO2Vsc2UgaWYodS50eXBlPT09XCJ2ZWMyXCIpZS5nbC51bmlmb3JtMmZ2KHAsZCk7ZWxzZSBpZih1LnR5cGU9PT1cInZlYzNcIillLmdsLnVuaWZvcm0zZnYocCxkKTtlbHNlIGlmKHUudHlwZT09PVwidmVjNFwiKWUuZ2wudW5pZm9ybTRmdihwLGQpO2Vsc2UgaWYodS50eXBlPT09XCJpbnRcIillLmdsLnVuaWZvcm0xaXYocCxkKTtlbHNlIGlmKHUudHlwZT09PVwiaXZlYzJcIillLmdsLnVuaWZvcm0yaXYocCxkKTtlbHNlIGlmKHUudHlwZT09PVwiaXZlYzNcIillLmdsLnVuaWZvcm0zaXYocCxkKTtlbHNlIGlmKHUudHlwZT09PVwiaXZlYzRcIillLmdsLnVuaWZvcm00aXYocCxkKTtlbHNlIHRocm93IEVycm9yKGB1bmlmb3JtIHR5cGUgJHt1LnR5cGV9IGlzIG5vdCBzdXBwb3J0ZWQgeWV0LmApfWUuZXhlY3V0ZVByb2dyYW0oKX1mdW5jdGlvbiBVOShlLHQsbil7bGV0IGE9XCJcIjt0LmNvbmNhdChuKS5mb3JFYWNoKGk9PntsZXQgbz1pLnRleERhdGEhPW51bGwmJmkudGV4RGF0YS5zbGljZSE9bnVsbCYmaS50ZXhEYXRhLnNsaWNlLmZsYXRPZmZzZXQ+MDtpZihlLmVuYWJsZVNoYXBlVW5pZm9ybXMmJiFpLmlzVW5pZm9ybSl7bGV0IGw9aS50ZXhEYXRhLnRleFNoYXBlLHt1c2VTcXVlZXplU2hhcGU6dSx1bmlmb3JtU2hhcGU6cCxrZXB0RGltczpkfT10ayhlLnBhY2tlZElucHV0cyxpLnNoYXBlLGwpLGM9XCJcIixoPVwiXCIsbT1cIlwiO2lmKHAubGVuZ3RoPT09MSYmZS5wYWNrZWRJbnB1dHMpe2xldCBJPVtNYXRoLmNlaWwobFswXS8yKSxNYXRoLmNlaWwobFsxXS8yKV07Yz1gJHtJWzBdPjF9XyR7SVsxXT4xfWB9ZWxzZSBpZihwLmxlbmd0aD09PTImJiFlLnBhY2tlZElucHV0cyloPWAke3BbMF0+MX1fJHtwWzFdPjF9YDtlbHNlIGlmKHAubGVuZ3RoPjImJiFlLnBhY2tlZElucHV0cyl7bGV0IEk9dy5jb21wdXRlU3RyaWRlcyhwKTttPWAke0lbMF09PT1sWzFdfV8ke0lbSS5sZW5ndGgtMV09PT1sWzFdfWB9bGV0IGY9aS5zaGFwZS5sZW5ndGgsZz1wLmxlbmd0aD09PTImJncuYXJyYXlzRXF1YWwoaS5zaGFwZSxsKSxiPXcuc2l6ZUZyb21TaGFwZShpLnNoYXBlKT09PTEseT1ULmdldEJyb2FkY2FzdERpbXMoaS5zaGFwZSxuLnNoYXBlKSx4PSFlLnBhY2tlZElucHV0cyYmZj09PW4uc2hhcGUubGVuZ3RoJiZ3LmFycmF5c0VxdWFsKGwsbi50ZXhEYXRhLnRleFNoYXBlKSx2PWUucGFja2VkSW5wdXRzfHxwLmxlbmd0aD4yP1wiXCI6YCR7bFswXT4xfV8ke2xbMV0+MX1gO2ErPWAke2Z9XyR7eH1fJHt1P2Q6XCJcIn1fJHtwLmxlbmd0aH1fJHtifV8ke3l9XyR7Z31fJHtjfV8ke2h9XyR7bX1fJHt2fV8ke299YH1lbHNle2xldCBsPWkuaXNVbmlmb3JtP1widW5pZm9ybVwiOmkudGV4RGF0YS50ZXhTaGFwZTthKz1gJHtpLnNoYXBlfV8ke2x9XyR7b31gfX0pO2xldCByPWUudXNlckNvZGUscz1lLmNvbnN0cnVjdG9yLm5hbWU7cmV0dXJuIHMrPVwiX1wiK2ErXCJfXCIrcitgJHtHKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKX1gLHN9ZnVuY3Rpb24gdm4oZSl7cmV0dXJuIEcoKS5nZXRCb29sKFwiV0VCR0xfVVNFX1NIQVBFU19VTklGT1JNU1wiKSYmZTw9NH12YXIgRzk9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITEsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRQYWNraW5nU2NoZW1lPU5jLkRFTlNFLHRoaXMuY3VzdG9tVW5pZm9ybXM9W3tuYW1lOlwidGV4U2hhcGVcIix0eXBlOlwiaXZlYzJcIn1dO2xldCB0PUVuKCk7dGhpcy5vdXRwdXRTaGFwZT1lLHRoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz12bih0aGlzLm91dHB1dFNoYXBlLmxlbmd0aCksdGhpcy51c2VyQ29kZT1gXG4gICAgICBpdmVjMyBvdXRDb29yZHNGcm9tRmxhdEluZGV4KGludCBpbmRleCkge1xuICAgICAgICAke3RoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz9XZihbXCJyXCIsXCJjXCIsXCJkXCJdLGUpOlpvKFtcInJcIixcImNcIixcImRcIl0sZSl9XG4gICAgICAgIHJldHVybiBpdmVjMyhyLCBjLCBkKTtcbiAgICAgIH1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICogdmVjMih0ZXhTaGFwZVswXSwgdGV4U2hhcGVbMV0pKTtcbiAgICAgICAgaW50IGluZGV4ID0gNCAqIChyZXNUZXhSQy54ICogdGV4U2hhcGVbMV0gKyByZXNUZXhSQy55KTtcblxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xuXG4gICAgICAgIGZvciAoaW50IGk9MDsgaTw0OyBpKyspIHtcbiAgICAgICAgICBpbnQgZmxhdEluZGV4ID0gaW5kZXggKyBpO1xuICAgICAgICAgIGl2ZWMzIHJjID0gb3V0Q29vcmRzRnJvbUZsYXRJbmRleChmbGF0SW5kZXgpO1xuICAgICAgICAgIHJlc3VsdFtpXSA9IGdldEEocmMueCwgcmMueSwgcmMueik7XG4gICAgICAgIH1cblxuICAgICAgICAke3Qub3V0cHV0fSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICBgfX0sSDk9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRQYWNraW5nU2NoZW1lPU5jLkRFTlNFLHRoaXMuY3VzdG9tVW5pZm9ybXM9W3tuYW1lOlwidGV4U2hhcGVcIix0eXBlOlwiaXZlYzJcIn1dO2xldCB0PUVuKCk7dGhpcy5vdXRwdXRTaGFwZT1lLHRoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz12bih0aGlzLm91dHB1dFNoYXBlLmxlbmd0aCksdGhpcy51c2VyQ29kZT1gXG4gICAgICBpdmVjMyBvdXRDb29yZHNGcm9tRmxhdEluZGV4KGludCBpbmRleCkge1xuICAgICAgICAke3RoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz9XZihbXCJyXCIsXCJjXCIsXCJkXCJdLGUpOlpvKFtcInJcIixcImNcIixcImRcIl0sZSl9XG4gICAgICAgIHJldHVybiBpdmVjMyhyLCBjLCBkKTtcbiAgICAgIH1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICogdmVjMih0ZXhTaGFwZVswXSwgdGV4U2hhcGVbMV0pKTtcbiAgICAgICAgaW50IGluZGV4ID0gNCAqIChyZXNUZXhSQy54ICogdGV4U2hhcGVbMV0gKyByZXNUZXhSQy55KTtcblxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xuXG4gICAgICAgIGZvciAoaW50IGk9MDsgaTw0OyBpKyspIHtcbiAgICAgICAgICBpbnQgZmxhdEluZGV4ID0gaW5kZXggKyBpO1xuICAgICAgICAgIGl2ZWMzIHJjID0gb3V0Q29vcmRzRnJvbUZsYXRJbmRleChmbGF0SW5kZXgpO1xuICAgICAgICAgIHJlc3VsdFtpXSA9IGdldENoYW5uZWwoZ2V0QShyYy54LCByYy55LCByYy56KSwgdmVjMihyYy55LCByYy56KSk7XG4gICAgICAgIH1cblxuICAgICAgICAke3Qub3V0cHV0fSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICBgfX0sajk9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5vdXRUZXhVc2FnZT1jYS5ET1dOTE9BRDtsZXQgdD1FbigpO3RoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLnVzZXJDb2RlPWBcbiAgICAgICR7ckF9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZmxvYXQgeCA9IGdldEFBdE91dENvb3JkcygpO1xuICAgICAgICAke3Qub3V0cHV0fSA9IGVuY29kZV9mbG9hdCh4KTtcbiAgICAgIH1cbiAgICBgfX0scTk9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITEsdGhpcy5vdXRUZXhVc2FnZT1jYS5ET1dOTE9BRDtsZXQgdD1FbigpO3RoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLnVzZXJDb2RlPWBcbiAgICAgICR7ckF9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGZsb2F0IHggPSBnZXRDaGFubmVsKGdldEFBdE91dENvb3JkcygpLCB2ZWMyKGNvb3Jkcy55LCBjb29yZHMueikpO1xuICAgICAgICAke3Qub3V0cHV0fSA9IGVuY29kZV9mbG9hdCh4KTtcbiAgICAgIH1cbiAgICBgfX0sSzk9e1I6MCxHOjEsQjoyLEE6M30sYVM9Y2xhc3N7Y29uc3RydWN0b3IoZSx0PSExLG49XCJSR0JBXCIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMuY3VzdG9tVW5pZm9ybXM9W3tuYW1lOlwidGV4U2hhcGVcIix0eXBlOlwiaXZlYzJcIn1dO2xldCBhPUVuKCk7dGhpcy5vdXRwdXRTaGFwZT1lLHRoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz12bih0aGlzLm91dHB1dFNoYXBlLmxlbmd0aCk7bGV0IHI9XCJyZXN1bHRcIjt0JiYocj1cImZsb29yKHJlc3VsdCAqIDI1NS4gKyAwLjUpXCIpO2xldCBzPVwiXCI7Zm9yKGxldCBpPTA7aTxuLmxlbmd0aDtpKyspe2xldCBvPW5baV07cys9YFxuICAgICAgICAgIGlmKG9mZnNldCA9PSAke2l9KSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZXNbJHtLOVtvXX1dO1xuICAgICAgICAgIH1gfXRoaXMudXNlckNvZGU9YFxuICAgICAgJHt0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXM/ZWsoKTpRMShlKX1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjMyBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGZsYXRJbmRleCA9IGdldEZsYXRJbmRleChjb29yZHMpO1xuICAgICAgICBmbG9hdCByZXN1bHQgPSAwLjtcbiAgICAgICAgaW50IG9mZnNldCA9IGltb2QoZmxhdEluZGV4LCAke24ubGVuZ3RofSk7XG5cbiAgICAgICAgZmxhdEluZGV4ID0gaWRpdihmbGF0SW5kZXgsICR7bi5sZW5ndGh9LCAxLik7XG5cbiAgICAgICAgaW50IHIgPSBmbGF0SW5kZXggLyB0ZXhTaGFwZVsxXTtcbiAgICAgICAgaWYgKHIgPCB0ZXhTaGFwZVswXSkge1xuICAgICAgICAgIGludCBjID0gaW1vZChmbGF0SW5kZXgsIHRleFNoYXBlWzFdKTtcbiAgICAgICAgICB2ZWMyIHV2ID0gKHZlYzIoYywgcikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhTaGFwZVsxXSwgdGV4U2hhcGVbMF0pO1xuICAgICAgICAgIHZlYzQgdmFsdWVzID0gJHthLnRleHR1cmUyRH0oQSwgdXYpO1xuICAgICAgICAgICR7c31cbiAgICAgICAgfVxuICAgICAgICAke2Eub3V0cHV0fSA9IHZlYzQoJHtyfSwgMC4sIDAuLCAwLik7XG4gICAgICB9XG4gICAgYH19LFg5PWNsYXNze2NvbnN0cnVjdG9yKGUsdD0hMSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITEsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5jdXN0b21Vbmlmb3Jtcz1be25hbWU6XCJ0ZXhTaGFwZVwiLHR5cGU6XCJpdmVjMlwifV07bGV0IG49RW4oKTt0aGlzLm91dHB1dFNoYXBlPWUsdGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zPXZuKHRoaXMub3V0cHV0U2hhcGUubGVuZ3RoKTtsZXQgYT1cIlwiLHI9XCJyZXN1bHRcIjt0JiYocj1cImZsb29yKHJlc3VsdCAqIDI1NS4gKyAwLjUpXCIpO2ZvcihsZXQgcz0wO3M8PTE7cysrKWZvcihsZXQgaT0wO2k8PTE7aSsrKXtsZXQgbz1zKjIraTthKz1gXG4gICAgICAgICAgbG9jYWxDb29yZHMgPSBjb29yZHM7XG4gICAgICAgICAgaWYobG9jYWxDb29yZHNbMl0gKyAke2l9IDwgJHt0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXM/XCJvdXRTaGFwZVsyXVwiOmAke2VbMl19YH0pIHtcbiAgICAgICAgICBsb2NhbENvb3Jkc1syXSArPSAke2l9O1xuICAgICAgICAgIGlmIChsb2NhbENvb3Jkc1sxXSArICR7c30gPCAke3RoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz9cIm91dFNoYXBlWzFdXCI6YCR7ZVsxXX1gfSkge1xuICAgICAgICAgICAgbG9jYWxDb29yZHNbMV0gKz0gJHtzfTtcblxuICAgICAgICAgICAgZmxhdEluZGV4ID0gZ2V0RmxhdEluZGV4KGxvY2FsQ29vcmRzKTtcbiAgICAgICAgICAgIG9mZnNldCA9IGltb2QoZmxhdEluZGV4LCA0KTtcblxuICAgICAgICAgICAgZmxhdEluZGV4ID0gaWRpdihmbGF0SW5kZXgsIDQsIDEuKTtcblxuICAgICAgICAgICAgaW50IHIgPSBmbGF0SW5kZXggLyB0ZXhTaGFwZVsxXTtcbiAgICAgICAgICAgIGludCBjID0gaW1vZChmbGF0SW5kZXgsIHRleFNoYXBlWzFdKTtcbiAgICAgICAgICAgIHZlYzIgdXYgPSAodmVjMihjLCByKSArIGhhbGZDUikgLyB2ZWMyKHRleFNoYXBlWzFdLCB0ZXhTaGFwZVswXSk7XG4gICAgICAgICAgICB2YWx1ZXMgPSAke24udGV4dHVyZTJEfShBLCB1dik7XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gMCkge1xuICAgICAgICAgICAgICByZXN1bHRbJHtvfV0gPSB2YWx1ZXNbMF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9mZnNldCA9PSAxKSB7XG4gICAgICAgICAgICAgIHJlc3VsdFske299XSA9IHZhbHVlc1sxXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ID09IDIpIHtcbiAgICAgICAgICAgICAgcmVzdWx0WyR7b31dID0gdmFsdWVzWzJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0WyR7b31dID0gdmFsdWVzWzNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBgfXRoaXMudXNlckNvZGU9YFxuICAgICAgICAke3RoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz9laygpOlExKGUpfVxuXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICBpdmVjMyBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcblxuICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XG4gICAgICAgICAgaW50IGZsYXRJbmRleCwgciwgYywgb2Zmc2V0O1xuICAgICAgICAgIGl2ZWMzIGxvY2FsQ29vcmRzO1xuICAgICAgICAgIHZlYzIgdXY7XG4gICAgICAgICAgdmVjNCB2YWx1ZXM7XG5cbiAgICAgICAgICAke2F9XG5cbiAgICAgICAgICAke24ub3V0cHV0fSA9ICR7cn07XG4gICAgICAgIH1cbiAgICBgfX0sdUE9e307X2UodUEse2JpbmRWZXJ0ZXhQcm9ncmFtQXR0cmlidXRlU3RyZWFtczooKT0+eUEsY3JlYXRlQnVmZmVyRnJvbU91dHB1dFRleHR1cmU6KCk9PndBLGNyZWF0ZUZsb2F0MTZNYXRyaXhUZXh0dXJlOigpPT5tQSxjcmVhdGVGbG9hdDE2UGFja2VkTWF0cml4VGV4dHVyZTooKT0+YkEsY3JlYXRlRmxvYXQzMk1hdHJpeFRleHR1cmU6KCk9PmhBLGNyZWF0ZUluZGV4QnVmZmVyOigpPT5kQSxjcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlOigpPT5nQSxjcmVhdGVVbnNpZ25lZEJ5dGVzTWF0cml4VGV4dHVyZTooKT0+ZkEsY3JlYXRlVmVydGV4QnVmZmVyOigpPT5jQSxjcmVhdGVWZXJ0ZXhTaGFkZXI6KCk9PnBBLGRvd25sb2FkQnl0ZUVuY29kZWRGbG9hdE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlOigpPT5JQSxkb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tQnVmZmVyOigpPT5rQSxkb3dubG9hZE1hdHJpeEZyb21QYWNrZWRPdXRwdXRUZXh0dXJlOigpPT5OQSxkb3dubG9hZFBhY2tlZE1hdHJpeEZyb21CdWZmZXI6KCk9PlNBLGdldEludGVybmFsRm9ybWF0Rm9yRmxvYXQxNk1hdHJpeFRleHR1cmU6KCk9PmFrLGdldEludGVybmFsRm9ybWF0Rm9yRmxvYXQxNlBhY2tlZE1hdHJpeFRleHR1cmU6KCk9PmlrLGdldEludGVybmFsRm9ybWF0Rm9yRmxvYXQzMk1hdHJpeFRleHR1cmU6KCk9Pm5rLGdldEludGVybmFsRm9ybWF0Rm9yUGFja2VkTWF0cml4VGV4dHVyZTooKT0+c2ssZ2V0SW50ZXJuYWxGb3JtYXRGb3JVbnNpZ25lZEJ5dGVzTWF0cml4VGV4dHVyZTooKT0+cmssdXBsb2FkRGVuc2VNYXRyaXhUb1RleHR1cmU6KCk9PnhBLHVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZTooKT0+dkF9KTtmdW5jdGlvbiBwQShlKXtsZXQgdD1FbigpLG49YCR7dC52ZXJzaW9ufVxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAke3QuYXR0cmlidXRlfSB2ZWMzIGNsaXBTcGFjZVBvcztcbiAgICAke3QuYXR0cmlidXRlfSB2ZWMyIHV2O1xuICAgICR7dC52YXJ5aW5nVnN9IHZlYzIgcmVzdWx0VVY7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoY2xpcFNwYWNlUG9zLCAxKTtcbiAgICAgIHJlc3VsdFVWID0gdXY7XG4gICAgfWA7cmV0dXJuIE9fKGUsbil9ZnVuY3Rpb24gY0EoZSl7bGV0IHQ9bmV3IEZsb2F0MzJBcnJheShbLTEsMSwwLDAsMSwtMSwtMSwwLDAsMCwxLDEsMCwxLDEsMSwtMSwwLDEsMF0pO3JldHVybiBXXyhlLHQpfWZ1bmN0aW9uIGRBKGUpe2xldCB0PW5ldyBVaW50MTZBcnJheShbMCwxLDIsMiwxLDNdKTtyZXR1cm4gQl8oZSx0KX1mdW5jdGlvbiBBZChlLHQsbixhLHIscyl7VV8odCxuKTtsZXQgaT1WXyhlKSxvPWUuVEVYVFVSRV8yRDtyZXR1cm4gZGUoZSwoKT0+ZS5iaW5kVGV4dHVyZShvLGkpKSxkZShlLCgpPT5lLnRleFBhcmFtZXRlcmkobyxlLlRFWFRVUkVfV1JBUF9TLGUuQ0xBTVBfVE9fRURHRSkpLGRlKGUsKCk9PmUudGV4UGFyYW1ldGVyaShvLGUuVEVYVFVSRV9XUkFQX1QsZS5DTEFNUF9UT19FREdFKSksZGUoZSwoKT0+ZS50ZXhQYXJhbWV0ZXJpKG8sZS5URVhUVVJFX01JTl9GSUxURVIsZS5ORUFSRVNUKSksZGUoZSwoKT0+ZS50ZXhQYXJhbWV0ZXJpKG8sZS5URVhUVVJFX01BR19GSUxURVIsZS5ORUFSRVNUKSksRygpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik9PT0xP2RlKGUsKCk9PmUudGV4SW1hZ2UyRChvLDAsYSx0LG4sMCxyLHMsbnVsbCkpOmRlKGUsKCk9PmUudGV4U3RvcmFnZTJEKG8sMSxhLHQsbikpLGRlKGUsKCk9PmUuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELG51bGwpKSx7dGV4dHVyZTppLHRleFNoYXBlOltuLHRdfX1mdW5jdGlvbiBuayhlKXtyZXR1cm4gZS5pbnRlcm5hbEZvcm1hdEZsb2F0fWZ1bmN0aW9uIGhBKGUsdCxuLGEpe2xldFtyLHNdPV9kKHQsbik7cmV0dXJuIEFkKGUscixzLG5rKGEpLGEudGV4dHVyZUZvcm1hdEZsb2F0LGUuRkxPQVQpfWZ1bmN0aW9uIGFrKGUpe3JldHVybiBlLmludGVybmFsRm9ybWF0SGFsZkZsb2F0fWZ1bmN0aW9uIG1BKGUsdCxuLGEpe2xldFtyLHNdPV9kKHQsbik7cmV0dXJuIEFkKGUscixzLGFrKGEpLGEudGV4dHVyZUZvcm1hdEZsb2F0LGEudGV4dHVyZVR5cGVIYWxmRmxvYXQpfWZ1bmN0aW9uIHJrKGUpe3JldHVybiBlLmRvd25sb2FkVGV4dHVyZUZvcm1hdH1mdW5jdGlvbiBmQShlLHQsbixhKXtsZXRbcixzXT1fZCh0LG4pO3JldHVybiBBZChlLHIscyxyayhhKSxlLlJHQkEsZS5VTlNJR05FRF9CWVRFKX1mdW5jdGlvbiBzayhlKXtyZXR1cm4gZS5pbnRlcm5hbEZvcm1hdFBhY2tlZEZsb2F0fWZ1bmN0aW9uIGdBKGUsdCxuLGEpe2xldFtyLHNdPW9wKHQsbik7cmV0dXJuIEFkKGUscixzLHNrKGEpLGUuUkdCQSxlLkZMT0FUKX1mdW5jdGlvbiBpayhlKXtyZXR1cm4gZS5pbnRlcm5hbEZvcm1hdFBhY2tlZEhhbGZGbG9hdH1mdW5jdGlvbiBiQShlLHQsbixhKXtsZXRbcixzXT1vcCh0LG4pO3JldHVybiBBZChlLHIscyxpayhhKSxlLlJHQkEsYS50ZXh0dXJlVHlwZUhhbGZGbG9hdCl9ZnVuY3Rpb24geUEoZSx0LG4pe3JldHVybiBkZShlLCgpPT5lLmJpbmRCdWZmZXIoZS5BUlJBWV9CVUZGRVIsbikpLHB2KGUsdCxcImNsaXBTcGFjZVBvc1wiLG4sMywyMCwwKSYmcHYoZSx0LFwidXZcIixuLDIsMjAsMTIpfWZ1bmN0aW9uIHhBKGUsdCxuLGEscixzKXtkZShlLCgpPT5lLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCx0KSk7bGV0IGksbyxsO3IgaW5zdGFuY2VvZiBVaW50OEFycmF5PyhpPW5ldyBVaW50OEFycmF5KG4qYSo0KSxvPWUuVU5TSUdORURfQllURSxsPWUuUkdCQSk6KGk9bmV3IEZsb2F0MzJBcnJheShuKmEqNCksbz1lLkZMT0FULGw9cy5pbnRlcm5hbEZvcm1hdFBhY2tlZEZsb2F0KSxpLnNldChyKSxHKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKT09PTI/ZGUoZSwoKT0+ZS50ZXhTdWJJbWFnZTJEKGUuVEVYVFVSRV8yRCwwLDAsMCxuLGEsZS5SR0JBLG8saSkpOmRlKGUsKCk9PmUudGV4SW1hZ2UyRChlLlRFWFRVUkVfMkQsMCxsLG4sYSwwLGUuUkdCQSxvLGkpKSxkZShlLCgpPT5lLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCxudWxsKSl9ZnVuY3Rpb24gdkEoZSx0LG4pe2RlKGUsKCk9PmUuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELHQpKSxuLmRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5P0coKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpPT09Mj9kZShlLCgpPT5lLnRleFN1YkltYWdlMkQoZS5URVhUVVJFXzJELDAsMCwwLG4ud2lkdGgsbi5oZWlnaHQsZS5SR0JBLGUuVU5TSUdORURfQllURSxuLmRhdGEpKTpkZShlLCgpPT5lLnRleEltYWdlMkQoZS5URVhUVVJFXzJELDAsZS5SR0JBLG4ud2lkdGgsbi5oZWlnaHQsMCxlLlJHQkEsZS5VTlNJR05FRF9CWVRFLG4uZGF0YSkpOkcoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpPT09Mj9kZShlLCgpPT5lLnRleFN1YkltYWdlMkQoZS5URVhUVVJFXzJELDAsMCwwLGUuUkdCQSxlLlVOU0lHTkVEX0JZVEUsbikpOmRlKGUsKCk9PmUudGV4SW1hZ2UyRChlLlRFWFRVUkVfMkQsMCxlLlJHQkEsZS5SR0JBLGUuVU5TSUdORURfQllURSxuKSksZGUoZSwoKT0+ZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsbnVsbCkpfWZ1bmN0aW9uIHdBKGUsdCxuLGEpe2xldCByPWUuY3JlYXRlQnVmZmVyKCk7ZGUoZSwoKT0+ZS5iaW5kQnVmZmVyKGUuUElYRUxfUEFDS19CVUZGRVIscikpO2xldCBzPTQqNCp0Km47cmV0dXJuIGRlKGUsKCk9PmUuYnVmZmVyRGF0YShlLlBJWEVMX1BBQ0tfQlVGRkVSLHMsZS5TVFJFQU1fUkVBRCkpLGRlKGUsKCk9PmUucmVhZFBpeGVscygwLDAsbix0LGUuUkdCQSxlLkZMT0FULDApKSxkZShlLCgpPT5lLmJpbmRCdWZmZXIoZS5QSVhFTF9QQUNLX0JVRkZFUixudWxsKSkscn1mdW5jdGlvbiBrQShlLHQsbil7bGV0IGE9ZSxyPW5ldyBGbG9hdDMyQXJyYXkobik7cmV0dXJuIGEuYmluZEJ1ZmZlcihhLlBJWEVMX1BBQ0tfQlVGRkVSLHQpLGEuZ2V0QnVmZmVyU3ViRGF0YShhLlBJWEVMX1BBQ0tfQlVGRkVSLDAsciksYS5iaW5kQnVmZmVyKGEuUElYRUxfUEFDS19CVUZGRVIsbnVsbCkscn1mdW5jdGlvbiBJQShlLHQsbixhKXtsZXRbcixzXT1fZCh0LG4pLGk9NCxvPW5ldyBVaW50OEFycmF5KEhKKHQqbixpKSk7cmV0dXJuIGRlKGUsKCk9PmUucmVhZFBpeGVscygwLDAscixzLGEuZG93bmxvYWRUZXh0dXJlRm9ybWF0LGUuVU5TSUdORURfQllURSxvKSksbmV3IEZsb2F0MzJBcnJheShvLmJ1ZmZlcil9ZnVuY3Rpb24gU0EoZSx0LG4sYSxyLHMsaSxvKXtsZXQgbD1lLHU9bmV3IEZsb2F0MzJBcnJheShqSihzLGkpKTtyZXR1cm4gbC5iaW5kQnVmZmVyKGwuUElYRUxfUEFDS19CVUZGRVIsdCksbC5nZXRCdWZmZXJTdWJEYXRhKGwuUElYRUxfUEFDS19CVUZGRVIsMCx1KSxsLmJpbmRCdWZmZXIobC5QSVhFTF9QQUNLX0JVRkZFUixudWxsKSx1fWZ1bmN0aW9uIE5BKGUsdCxuKXtsZXQgYT1uZXcgRmxvYXQzMkFycmF5KHQqbio0KTtyZXR1cm4gZGUoZSwoKT0+ZS5yZWFkUGl4ZWxzKDAsMCxuLHQsZS5SR0JBLGUuRkxPQVQsYSkpLGF9dmFyIFdoPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMub3V0cHV0VGV4dHVyZT1udWxsLHRoaXMucHJvZ3JhbT1udWxsLHRoaXMuZGlzcG9zZWQ9ITEsdGhpcy5pdGVtc1RvUG9sbD1bXTtsZXQgdD1HKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKTtpZihlIT1udWxsPyh0aGlzLmdsPWUsRF8odCxlKSk6dGhpcy5nbD1qYSh0KSxlPXRoaXMuZ2wsRygpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik9PT0yKXtsZXQgcj1lO3RoaXMuY3JlYXRlVmVydGV4QXJyYXk9KCk9PmRlKHIsKCk9PnIuY3JlYXRlVmVydGV4QXJyYXkoKSksdGhpcy5iaW5kVmVydGV4QXJyYXk9cz0+ZGUociwoKT0+ci5iaW5kVmVydGV4QXJyYXkocykpLHRoaXMuZGVsZXRlVmVydGV4QXJyYXk9cz0+ZGUociwoKT0+ci5kZWxldGVWZXJ0ZXhBcnJheShzKSksdGhpcy5nZXRWZXJ0ZXhBcnJheT0oKT0+ZGUociwoKT0+ci5nZXRQYXJhbWV0ZXIoci5WRVJURVhfQVJSQVlfQklORElORykpfWVsc2UgaWYoZSE9bnVsbCl7bGV0IHI9ZS5nZXRFeHRlbnNpb24oXCJPRVNfdmVydGV4X2FycmF5X29iamVjdFwiKTtpZihyPT1udWxsKXRocm93IG5ldyBFcnJvcihcIkFsbCBXZWJHTDEgaW1wbGVtZW50YXRpb25zIGFyZSBleHBlY3RlZCB0byBvZmZlciBPRVNfdmVydGV4X2FycmF5X29iamVjdC5cIik7dGhpcy5jcmVhdGVWZXJ0ZXhBcnJheT0oKT0+ZGUoZSwoKT0+ci5jcmVhdGVWZXJ0ZXhBcnJheU9FUygpKSx0aGlzLmJpbmRWZXJ0ZXhBcnJheT1zPT5kZShlLCgpPT5yLmJpbmRWZXJ0ZXhBcnJheU9FUyhzKSksdGhpcy5kZWxldGVWZXJ0ZXhBcnJheT1zPT5kZShlLCgpPT5yLmRlbGV0ZVZlcnRleEFycmF5T0VTKHMpKSx0aGlzLmdldFZlcnRleEFycmF5PSgpPT5kZShlLCgpPT5lLmdldFBhcmFtZXRlcihyLlZFUlRFWF9BUlJBWV9CSU5ESU5HX09FUykpfWxldCBuPVwiV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0XCIsYT1cIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdFwiO2lmKHRoaXMucGFyYWxsZWxDb21waWxhdGlvbkV4dGVuc2lvbj10aGlzLmdsLmdldEV4dGVuc2lvbihcIktIUl9wYXJhbGxlbF9zaGFkZXJfY29tcGlsZVwiKSxHKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKT09PTEpe2xldCByPVwiT0VTX3RleHR1cmVfZmxvYXRcIixzPVwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiO2lmKHRoaXMudGV4dHVyZUZsb2F0RXh0ZW5zaW9uPXJjKHRoaXMuZ2wsciksZGEodGhpcy5nbCxzKSl0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb249cmModGhpcy5nbCxzKTtlbHNlIGlmKEcoKS5nZXQoXCJXRUJHTF9GT1JDRV9GMTZfVEVYVFVSRVNcIikpdGhyb3cgbmV3IEVycm9yKFwiR0wgY29udGV4dCBkb2VzIG5vdCBzdXBwb3J0IGhhbGYgZmxvYXQgdGV4dHVyZXMsIHlldCB0aGUgZW52aXJvbm1lbnQgZmxhZyBXRUJHTF9GT1JDRV9GMTZfVEVYVFVSRVMgaXMgc2V0IHRvIHRydWUuXCIpO2lmKHRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbj10aGlzLmdsLmdldEV4dGVuc2lvbihuKSxkYSh0aGlzLmdsLGEpKXRoaXMuY29sb3JCdWZmZXJIYWxmRmxvYXRFeHRlbnNpb249cmModGhpcy5nbCxhKTtlbHNlIGlmKEcoKS5nZXQoXCJXRUJHTF9GT1JDRV9GMTZfVEVYVFVSRVNcIikpdGhyb3cgbmV3IEVycm9yKFwiR0wgY29udGV4dCBkb2VzIG5vdCBzdXBwb3J0IGNvbG9yIHJlbmRlcmFibGUgaGFsZiBmbG9hdHMsIHlldCB0aGUgZW52aXJvbm1lbnQgZmxhZyBXRUJHTF9GT1JDRV9GMTZfVEVYVFVSRVMgaXMgc2V0IHRvIHRydWUuXCIpfWVsc2UgaWYobj1cIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIixkYSh0aGlzLmdsLG4pKXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbj10aGlzLmdsLmdldEV4dGVuc2lvbihuKTtlbHNlIGlmKGRhKHRoaXMuZ2wsYSkpdGhpcy5jb2xvckJ1ZmZlckhhbGZGbG9hdEV4dGVuc2lvbj10aGlzLmdsLmdldEV4dGVuc2lvbihhKTtlbHNlIHRocm93IG5ldyBFcnJvcihcIkdMIGNvbnRleHQgZG9lcyBub3Qgc3VwcG9ydCBjb2xvciByZW5kZXJhYmxlIGZsb2F0c1wiKTt0aGlzLnZlcnRleEJ1ZmZlcj1jQSh0aGlzLmdsKSx0aGlzLmluZGV4QnVmZmVyPWRBKHRoaXMuZ2wpLHRoaXMuZnJhbWVidWZmZXI9R18odGhpcy5nbCksdGhpcy50ZXh0dXJlQ29uZmlnPVoxKHRoaXMuZ2wsdGhpcy50ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uKX1nZXQgZGVidWcoKXtyZXR1cm4gRygpLmdldEJvb2woXCJERUJVR1wiKX1kaXNwb3NlKCl7aWYodGhpcy5kaXNwb3NlZClyZXR1cm47dGhpcy5wcm9ncmFtIT1udWxsJiZjb25zb2xlLndhcm4oXCJEaXNwb3NpbmcgYSBHUEdQVUNvbnRleHQgdGhhdCBzdGlsbCBoYXMgYSBib3VuZCBXZWJHTFByb2dyYW0uIFRoaXMgaXMgcHJvYmFibHkgYSByZXNvdXJjZSBsZWFrLCBkZWxldGUgdGhlIHByb2dyYW0gd2l0aCBHUEdQVUNvbnRleHQuZGVsZXRlUHJvZ3JhbSBiZWZvcmUgZGlzcG9zaW5nLlwiKSx0aGlzLm91dHB1dFRleHR1cmUhPW51bGwmJmNvbnNvbGUud2FybihcIkRpc3Bvc2luZyBhIEdQR1BVQ29udGV4dCB0aGF0IHN0aWxsIGhhcyBhIGJvdW5kIG91dHB1dCBtYXRyaXggdGV4dHVyZS4gIFRoaXMgaXMgcHJvYmFibHkgYSByZXNvdXJjZSBsZWFrLCBkZWxldGUgdGhlIG91dHB1dCBtYXRyaXggdGV4dHVyZSB3aXRoIEdQR1BVQ29udGV4dC5kZWxldGVNYXRyaXhUZXh0dXJlIGJlZm9yZSBkaXNwb3NpbmcuXCIpO2xldCBlPXRoaXMuZ2w7ZGUoZSwoKT0+ZS5maW5pc2goKSksZGUoZSwoKT0+ZS5iaW5kRnJhbWVidWZmZXIoZS5GUkFNRUJVRkZFUixudWxsKSksZGUoZSwoKT0+ZS5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLmZyYW1lYnVmZmVyKSksZGUoZSwoKT0+ZS5iaW5kQnVmZmVyKGUuQVJSQVlfQlVGRkVSLG51bGwpKSxkZShlLCgpPT5lLmJpbmRCdWZmZXIoZS5FTEVNRU5UX0FSUkFZX0JVRkZFUixudWxsKSksZGUoZSwoKT0+ZS5kZWxldGVCdWZmZXIodGhpcy5pbmRleEJ1ZmZlcikpLHRoaXMuZGlzcG9zZWQ9ITB9Y3JlYXRlRmxvYXQzMk1hdHJpeFRleHR1cmUoZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxoQSh0aGlzLmdsLGUsdCx0aGlzLnRleHR1cmVDb25maWcpfWNyZWF0ZUZsb2F0MTZNYXRyaXhUZXh0dXJlKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksbUEodGhpcy5nbCxlLHQsdGhpcy50ZXh0dXJlQ29uZmlnKX1jcmVhdGVVbnNpZ25lZEJ5dGVzTWF0cml4VGV4dHVyZShlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGZBKHRoaXMuZ2wsZSx0LHRoaXMudGV4dHVyZUNvbmZpZyl9dXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlKGUsdCl7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSx2QSh0aGlzLmdsLGUsdCl9dXBsb2FkRGVuc2VNYXRyaXhUb1RleHR1cmUoZSx0LG4sYSl7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4QSh0aGlzLmdsLGUsdCxuLGEsdGhpcy50ZXh0dXJlQ29uZmlnKX1jcmVhdGVGbG9hdDE2UGFja2VkTWF0cml4VGV4dHVyZShlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGJBKHRoaXMuZ2wsZSx0LHRoaXMudGV4dHVyZUNvbmZpZyl9Y3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZShlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGdBKHRoaXMuZ2wsZSx0LHRoaXMudGV4dHVyZUNvbmZpZyl9ZGVsZXRlTWF0cml4VGV4dHVyZShlKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMub3V0cHV0VGV4dHVyZT09PWUmJihjdih0aGlzLmdsLHRoaXMuZnJhbWVidWZmZXIpLHRoaXMub3V0cHV0VGV4dHVyZT1udWxsKSxkZSh0aGlzLmdsLCgpPT50aGlzLmdsLmRlbGV0ZVRleHR1cmUoZSkpfWRvd25sb2FkQnl0ZUVuY29kZWRGbG9hdE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlKGUsdCxuKXtyZXR1cm4gdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlcihlLCgpPT5JQSh0aGlzLmdsLHQsbix0aGlzLnRleHR1cmVDb25maWcpKX1kb3dubG9hZFBhY2tlZE1hdHJpeEZyb21CdWZmZXIoZSx0LG4sYSxyLHMpe3JldHVybiBTQSh0aGlzLmdsLGUsdCxuLGEscixzLHRoaXMudGV4dHVyZUNvbmZpZyl9ZG93bmxvYWRGbG9hdDMyTWF0cml4RnJvbUJ1ZmZlcihlLHQpe3JldHVybiBrQSh0aGlzLmdsLGUsdCl9Y3JlYXRlQnVmZmVyRnJvbVRleHR1cmUoZSx0LG4pe3RoaXMuYmluZFRleHR1cmVUb0ZyYW1lQnVmZmVyKGUpO2xldCBhPXdBKHRoaXMuZ2wsdCxuLHRoaXMudGV4dHVyZUNvbmZpZyk7cmV0dXJuIHRoaXMudW5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIoKSxhfWNyZWF0ZUFuZFdhaXRGb3JGZW5jZSgpe2xldCBlPXRoaXMuY3JlYXRlRmVuY2UodGhpcy5nbCk7cmV0dXJuIHRoaXMucG9sbEZlbmNlKGUpfWNyZWF0ZUZlbmNlKGUpe2xldCB0LG47aWYoRygpLmdldEJvb2woXCJXRUJHTF9GRU5DRV9BUElfRU5BQkxFRFwiKSl7bGV0IGE9ZSxyPWEuZmVuY2VTeW5jKGEuU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEUsMCk7ZS5mbHVzaCgpLG49KCk9PntsZXQgcz1hLmNsaWVudFdhaXRTeW5jKHIsMCwwKTtyZXR1cm4gcz09PWEuQUxSRUFEWV9TSUdOQUxFRHx8cz09PWEuQ09ORElUSU9OX1NBVElTRklFRH0sdD1yfWVsc2UgRygpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpPjA/KHQ9dGhpcy5iZWdpblF1ZXJ5KCksdGhpcy5lbmRRdWVyeSgpLG49KCk9PnRoaXMuaXNRdWVyeUF2YWlsYWJsZSh0LEcoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKSkpOm49KCk9PiEwO3JldHVybntxdWVyeTp0LGlzRmVuY2VQYXNzZWQ6bn19ZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkVGV4dHVyZShlLHQsbil7cmV0dXJuIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXIoZSwoKT0+TkEodGhpcy5nbCx0LG4pKX1jcmVhdGVQcm9ncmFtKGUpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCk7bGV0IHQ9dGhpcy5nbDt0aGlzLnZlcnRleFNoYWRlcj09bnVsbCYmKHRoaXMudmVydGV4U2hhZGVyPXBBKHQpKTtsZXQgbj1MXyh0KTtkZSh0LCgpPT50LmF0dGFjaFNoYWRlcihuLHRoaXMudmVydGV4U2hhZGVyKSksZGUodCwoKT0+dC5hdHRhY2hTaGFkZXIobixlKSksel8odCxuKTtsZXQgYT1PYmplY3QuYXNzaWduKG4se3Zhbzp0aGlzLmNyZWF0ZVZlcnRleEFycmF5KCl9KTtyZXR1cm4gdGhpcy5kZWJ1ZyYmT2godCxhKSxhfWJ1aWxkVmFvKGUpe3RoaXMuc2V0UHJvZ3JhbShlKSx0aGlzLmJpbmRWZXJ0ZXhBcnJheShlLnZhbyk7bGV0IHQ9dGhpcy5nbDtkZSh0LCgpPT50LmJpbmRCdWZmZXIodC5FTEVNRU5UX0FSUkFZX0JVRkZFUix0aGlzLmluZGV4QnVmZmVyKSkseUEodCxlLHRoaXMudmVydGV4QnVmZmVyKX1kZWxldGVQcm9ncmFtKGUpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksZT09PXRoaXMucHJvZ3JhbSYmKHRoaXMucHJvZ3JhbT1udWxsKSxlIT1udWxsJiYoZGUodGhpcy5nbCwoKT0+dGhpcy5nbC5kZWxldGVQcm9ncmFtKGUpKSx0aGlzLmRlbGV0ZVZlcnRleEFycmF5KGUudmFvKSl9c2V0UHJvZ3JhbShlKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMucHJvZ3JhbT1lLHRoaXMucHJvZ3JhbSE9bnVsbCYmdGhpcy5kZWJ1ZyYmT2godGhpcy5nbCx0aGlzLnByb2dyYW0pLGRlKHRoaXMuZ2wsKCk9PnRoaXMuZ2wudXNlUHJvZ3JhbShlKSl9Z2V0VW5pZm9ybUxvY2F0aW9uKGUsdCxuPSEwKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxuP2pfKHRoaXMuZ2wsZSx0KTpxXyh0aGlzLmdsLGUsdCl9Z2V0QXR0cmlidXRlTG9jYXRpb24oZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxkZSh0aGlzLmdsLCgpPT50aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKGUsdCkpfWdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3coZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbihlLHQpfXNldElucHV0TWF0cml4VGV4dHVyZShlLHQsbil7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnRocm93SWZOb1Byb2dyYW0oKSxLXyh0aGlzLmdsLGUsdCxuKX1zZXRPdXRwdXRNYXRyaXhUZXh0dXJlKGUsdCxuKXt0aGlzLnNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXIoZSxuLHQpfXNldE91dHB1dFBhY2tlZE1hdHJpeFRleHR1cmUoZSx0LG4pe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCk7bGV0W2Escl09b3AodCxuKTt0aGlzLnNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXIoZSxhLHIpfXNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uKGUsdCxuLGEpe3RoaXMuc2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb25Ecml2ZXIobixlLGEsdCl9c2V0T3V0cHV0UGFja2VkTWF0cml4V3JpdGVSZWdpb24oZSx0LG4sYSl7dGhyb3cgbmV3IEVycm9yKFwic2V0T3V0cHV0UGFja2VkTWF0cml4V3JpdGVSZWdpb24gbm90IGltcGxlbWVudGVkLlwiKX1kZWJ1Z1ZhbGlkYXRlKCl7dGhpcy5wcm9ncmFtIT1udWxsJiZPaCh0aGlzLmdsLHRoaXMucHJvZ3JhbSksc2ModGhpcy5nbCl9ZXhlY3V0ZVByb2dyYW0oKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMudGhyb3dJZk5vUHJvZ3JhbSgpO2xldCBlPXRoaXMuZ2w7aWYodGhpcy5kZWJ1Zyl7bGV0IHQ9dGhpcy5nZXRWZXJ0ZXhBcnJheSgpO2NvbnNvbGUuYXNzZXJ0KHQ9PT10aGlzLnByb2dyYW0udmFvLFwiVkFPIGNoYW5nZWQgYmV0d2VlbiBzZXRQcm9ncmFtIGFuZCBleGVjdXRlUHJvZ3JhbSFcIiksdGhpcy5kZWJ1Z1ZhbGlkYXRlKCl9ZGUoZSwoKT0+ZS5kcmF3RWxlbWVudHMoZS5UUklBTkdMRVMsNixlLlVOU0lHTkVEX1NIT1JULDApKX1ibG9ja1VudGlsQWxsUHJvZ3JhbXNDb21wbGV0ZWQoKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLGRlKHRoaXMuZ2wsKCk9PnRoaXMuZ2wuZmluaXNoKCkpfWdldFF1ZXJ5VGltZXJFeHRlbnNpb24oKXtyZXR1cm4gdGhpcy5kaXNqb2ludFF1ZXJ5VGltZXJFeHRlbnNpb249PW51bGwmJih0aGlzLmRpc2pvaW50UXVlcnlUaW1lckV4dGVuc2lvbj1yYyh0aGlzLmdsLEcoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKT09PTI/XCJFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyXCI6XCJFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlcIikpLHRoaXMuZGlzam9pbnRRdWVyeVRpbWVyRXh0ZW5zaW9ufWdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDIoKXtyZXR1cm4gdGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uKCl9Z2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpe3JldHVybiB0aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb24oKX1iZWdpblF1ZXJ5KCl7aWYoRygpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpPT09Mil7bGV0IG49dGhpcy5nbCxhPXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMigpLHI9bi5jcmVhdGVRdWVyeSgpO3JldHVybiBuLmJlZ2luUXVlcnkoYS5USU1FX0VMQVBTRURfRVhULHIpLHJ9bGV0IGU9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxKCksdD1lLmNyZWF0ZVF1ZXJ5RVhUKCk7cmV0dXJuIGUuYmVnaW5RdWVyeUVYVChlLlRJTUVfRUxBUFNFRF9FWFQsdCksdH1lbmRRdWVyeSgpe2lmKEcoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKT09PTIpe2xldCB0PXRoaXMuZ2wsbj10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDIoKTt0LmVuZFF1ZXJ5KG4uVElNRV9FTEFQU0VEX0VYVCk7cmV0dXJufWxldCBlPXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpO2UuZW5kUXVlcnlFWFQoZS5USU1FX0VMQVBTRURfRVhUKX1hc3luYyB3YWl0Rm9yUXVlcnlBbmRHZXRUaW1lKGUpe3JldHVybiBhd2FpdCB3LnJlcGVhdGVkVHJ5KCgpPT50aGlzLmRpc3Bvc2VkfHx0aGlzLmlzUXVlcnlBdmFpbGFibGUoZSxHKCkuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIikpKSx0aGlzLmdldFF1ZXJ5VGltZShlLEcoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKSl9Z2V0UXVlcnlUaW1lKGUsdCl7aWYodD09PTApcmV0dXJuIG51bGw7aWYodD09PTIpe2xldCBuPXRoaXMuZ2w7cmV0dXJuIG4uZ2V0UXVlcnlQYXJhbWV0ZXIoZSxuLlFVRVJZX1JFU1VMVCkvMWU2fWVsc2V7bGV0IG49dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxKCk7cmV0dXJuIG4uZ2V0UXVlcnlPYmplY3RFWFQoZSxuLlFVRVJZX1JFU1VMVF9FWFQpLzFlNn19aXNRdWVyeUF2YWlsYWJsZShlLHQpe2lmKHQ9PT0wKXJldHVybiEwO2lmKHQ9PT0yKXtsZXQgbj10aGlzLmdsLGE9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wyKCkscj1uLmdldFF1ZXJ5UGFyYW1ldGVyKGUsbi5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFKTtyZXR1cm4gdGhpcy5kaXNqb2ludD09bnVsbCYmKHRoaXMuZGlzam9pbnQ9dGhpcy5nbC5nZXRQYXJhbWV0ZXIoYS5HUFVfRElTSk9JTlRfRVhUKSksciYmIXRoaXMuZGlzam9pbnR9ZWxzZXtsZXQgbj10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDEoKSxhPW4uZ2V0UXVlcnlPYmplY3RFWFQoZSxuLlFVRVJZX1JFU1VMVF9BVkFJTEFCTEVfRVhUKTtyZXR1cm4gdGhpcy5kaXNqb2ludD09bnVsbCYmKHRoaXMuZGlzam9pbnQ9dGhpcy5nbC5nZXRQYXJhbWV0ZXIobi5HUFVfRElTSk9JTlRfRVhUKSksYSYmIXRoaXMuZGlzam9pbnR9fXBvbGxGZW5jZShlKXtyZXR1cm4gbmV3IFByb21pc2UodD0+e3RoaXMuYWRkSXRlbVRvUG9sbCgoKT0+ZS5pc0ZlbmNlUGFzc2VkKCksKCk9PnQoKSl9KX1wb2xsSXRlbXMoKXtsZXQgZT1ZOSh0aGlzLml0ZW1zVG9Qb2xsLm1hcCh0PT50LmlzRG9uZUZuKSk7Zm9yKGxldCB0PTA7dDw9ZTsrK3Qpe2xldHtyZXNvbHZlRm46bn09dGhpcy5pdGVtc1RvUG9sbFt0XTtuKCl9dGhpcy5pdGVtc1RvUG9sbD10aGlzLml0ZW1zVG9Qb2xsLnNsaWNlKGUrMSl9YWRkSXRlbVRvUG9sbChlLHQpe2lmKHRoaXMuaXRlbXNUb1BvbGwucHVzaCh7aXNEb25lRm46ZSxyZXNvbHZlRm46dH0pLHRoaXMuaXRlbXNUb1BvbGwubGVuZ3RoPjEpcmV0dXJuO2xldCBuO1wic2V0VGltZW91dEN1c3RvbVwiaW4gRygpLnBsYXRmb3JtJiYobj1HKCkucGxhdGZvcm0uc2V0VGltZW91dEN1c3RvbS5iaW5kKEcoKS5wbGF0Zm9ybSkpLHcucmVwZWF0ZWRUcnkoKCk9Pih0aGlzLnBvbGxJdGVtcygpLHRoaXMuaXRlbXNUb1BvbGwubGVuZ3RoPT09MCksKCk9PjAsbnVsbCxuKX1iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIoZSl7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSxQaCh0aGlzLmdsLGUsdGhpcy5mcmFtZWJ1ZmZlciksdGhpcy5kZWJ1ZyYmc2ModGhpcy5nbCl9dW5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIoKXt0aGlzLm91dHB1dFRleHR1cmUhPW51bGw/KFBoKHRoaXMuZ2wsdGhpcy5vdXRwdXRUZXh0dXJlLHRoaXMuZnJhbWVidWZmZXIpLHRoaXMuZGVidWcmJnNjKHRoaXMuZ2wpKTpjdih0aGlzLmdsLHRoaXMuZnJhbWVidWZmZXIpfWRvd25sb2FkTWF0cml4RHJpdmVyKGUsdCl7dGhpcy5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIoZSk7bGV0IG49dCgpO3JldHVybiB0aGlzLnVuYmluZFRleHR1cmVUb0ZyYW1lQnVmZmVyKCksbn1zZXRPdXRwdXRNYXRyaXhUZXh0dXJlRHJpdmVyKGUsdCxuKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpO2xldCBhPXRoaXMuZ2w7UGgoYSxlLHRoaXMuZnJhbWVidWZmZXIpLHRoaXMuZGVidWcmJnNjKGEpLHRoaXMub3V0cHV0VGV4dHVyZT1lLGRlKGEsKCk9PmEudmlld3BvcnQoMCwwLHQsbikpLGRlKGEsKCk9PmEuc2Npc3NvcigwLDAsdCxuKSl9c2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb25Ecml2ZXIoZSx0LG4sYSl7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSxkZSh0aGlzLmdsLCgpPT50aGlzLmdsLnNjaXNzb3IoZSx0LG4sYSkpfXRocm93SWZEaXNwb3NlZCgpe2lmKHRoaXMuZGlzcG9zZWQpdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIHVzZSBkaXNwb3NlZCBHUEdQVUNvbnRleHQuXCIpfXRocm93SWZOb1Byb2dyYW0oKXtpZih0aGlzLnByb2dyYW09PW51bGwpdGhyb3cgbmV3IEVycm9yKFwiTm8gR1BVIHByb2dyYW0gaXMgY3VycmVudGx5IHNldC5cIil9fTtmdW5jdGlvbiBZOShlKXtsZXQgdD0wO2Zvcig7dDxlLmxlbmd0aCYmZVt0XSgpOysrdCk7cmV0dXJuIHQtMX12YXJ7YWRkSW1wbDpaOSxiaW5jb3VudEltcGw6VEEsYmluY291bnRSZWR1Y2VJbXBsOko5LGJpdHdpc2VBbmRJbXBsOlE5LGNhc3RJbXBsOmVRLGNlaWxJbXBsOnRRLGNvbmNhdEltcGw6blEsZXF1YWxJbXBsOmFRLGV4cEltcGw6clEsZXhwbTFJbXBsOnNRLGZsb29ySW1wbDppUSxnYXRoZXJOZEltcGw6b1EsZ2F0aGVyVjJJbXBsOmxRLGdyZWF0ZXJJbXBsOnVRLGdyZWF0ZXJFcXVhbEltcGw6cFEsbGVzc0ltcGw6Y1EsbGVzc0VxdWFsSW1wbDpkUSxsaW5TcGFjZUltcGw6aFEsbG9nSW1wbDptUSxtYXhJbXBsOmZRLG1heGltdW1JbXBsOmdRLG1pbmltdW1JbXBsOmJRLG11bHRpcGx5SW1wbDp5USxuZWdJbXBsOnhRLG5vdEVxdWFsSW1wbDp2USxwcm9kSW1wbDp3USxyYWdnZWRHYXRoZXJJbXBsOmtRLHJhZ2dlZFJhbmdlSW1wbDpJUSxyYWdnZWRUZW5zb3JUb1RlbnNvckltcGw6U1EscmFuZ2VJbXBsOk5RLHJzcXJ0SW1wbDpUUSxzY2F0dGVySW1wbDpDUSxzaWdtb2lkSW1wbDpFUSxzaW1wbGVBYnNJbXBsOkNBLHNsaWNlSW1wbDpfUSxzcGFyc2VGaWxsRW1wdHlSb3dzSW1wbDpBUSxzcGFyc2VSZXNoYXBlSW1wbDpGUSxzcGFyc2VTZWdtZW50UmVkdWN0aW9uSW1wbDpFQSxzcXJ0SW1wbDokUSxzdGF0aWNSZWdleFJlcGxhY2VJbXBsOkRRLHN0cmlkZWRTbGljZUltcGw6UlEsc3RyaW5nTkdyYW1zSW1wbDpNUSxzdHJpbmdTcGxpdEltcGw6T1Esc3RyaW5nVG9IYXNoQnVja2V0RmFzdEltcGw6UFEsc3ViSW1wbDpMUSx0aWxlSW1wbDp6USx0b3BLSW1wbDpXUSx0cmFuc3Bvc2VJbXBsOm9rLHVuaXF1ZUltcGw6QlF9PU0xO2Z1bmN0aW9uIF9BKGUsdCl7cmV0dXJuW1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXS5zbGljZSgwLHQpLm1hcChuPT5gJHtlfS4ke259YCl9ZnVuY3Rpb24gSW4oZSx0KXtyZXR1cm4gdD09PTE/W2VdOl9BKGUsdCl9ZnVuY3Rpb24gVlEoZSx0KXtpZihlPT09MSlyZXR1cm5cInJjXCI7bGV0IG49XCJcIjtmb3IobGV0IGE9MDthPGU7YSsrKW4rPXRbYV0sYTxlLTEmJihuKz1cIixcIik7cmV0dXJuIG59dmFyIFVRPWNsYXNze2NvbnN0cnVjdG9yKGUpe2lmKHRoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSExLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLnJhbms9ZS5sZW5ndGgsdGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zPXZuKHRoaXMub3V0cHV0U2hhcGUubGVuZ3RoKSx0aGlzLnJhbms9PT0wKXRoaXMudXNlckNvZGU9YFxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgc2V0T3V0cHV0KHZlYzQoZ2V0QSgpLCAwLiwgMC4sIDAuKSk7XG4gICAgICAgIH1cbiAgICAgIGA7ZWxzZXtsZXQgdD1JbihcInJjXCIsdGhpcy5yYW5rKSxuPWh0KHRoaXMucmFuayksYT10aGlzLmdldE91dE9mQm91bmRzQ29uZGl0aW9uKHQpLHI9dGhpcy5nZXRTZXR1cCh0KSxzPXRoaXMuZ2V0T3V0cHV0KHQpO3RoaXMudXNlckNvZGU9YFxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgJHtufSByYyA9IGdldE91dHB1dENvb3JkcygpO1xuXG4gICAgICAgICAgaWYoJHthfSkge1xuICAgICAgICAgICAgc2V0T3V0cHV0KHZlYzQoMCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAke3J9XG5cbiAgICAgICAgICAgIHNldE91dHB1dCh2ZWM0KCR7c30pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGB9fWdldFNvdXJjZUNvb3Jkc0FycihlKXtsZXQgdD1bXTtmb3IobGV0IG49MDtuPD0xO24rKylmb3IobGV0IGE9MDthPD0xO2ErKyl7bGV0IHI9YCR7bj09PTA/XCJyXCI6XCJycDFcIn0sICR7YT09PTA/XCJjXCI6XCJjcDFcIn1gO2ZvcihsZXQgcz0yO3M8dGhpcy5yYW5rO3MrKylyPWAke2VbZS5sZW5ndGgtMS1zXX0sYCtyO3QucHVzaChyKX1yZXR1cm4gdH1nZXRPdXRPZkJvdW5kc0NvbmRpdGlvbihlKXtpZih0aGlzLnJhbms9PT0xKXJldHVybmByYyA+ICR7dGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zP1wib3V0U2hhcGVcIjp0aGlzLm91dHB1dFNoYXBlWzBdfWA7bGV0IHQ9XCJcIjtmb3IobGV0IG49dGhpcy5yYW5rLTI7bjx0aGlzLnJhbms7bisrKXQrPWAke2Vbbl19ID49ICR7dGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zP2BvdXRTaGFwZVske259XWA6dGhpcy5vdXRwdXRTaGFwZVtuXX1gLG48dGhpcy5yYW5rLTEmJih0Kz1cInx8XCIpO3JldHVybiB0fWdldFNldHVwKGUpe2lmKHRoaXMucmFuaz09PTEpcmV0dXJuXCJcIjtsZXQgdD1lLnNsaWNlKC0yKSxuPXRoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz9gb3V0U2hhcGVbJHt0aGlzLnJhbmt9IC0gMV1gOnRoaXMub3V0cHV0U2hhcGVbdGhpcy5yYW5rLTFdLGE9dGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zP2BvdXRTaGFwZVske3RoaXMucmFua30gLSAyXWA6dGhpcy5vdXRwdXRTaGFwZVt0aGlzLnJhbmstMl07cmV0dXJuYFxuICAgICAgaW50IHIgPSAke3RbMF19O1xuICAgICAgaW50IGMgPSAke3RbMV19O1xuICAgICAgaW50IHJwMSA9IHIgKyAxO1xuICAgICAgaW50IGNwMSA9IGMgKyAxO1xuXG4gICAgICBib29sIGNFZGdlID0gY3AxID49ICR7bn07XG4gICAgICBib29sIHJFZGdlID0gcnAxID49ICR7YX07XG4gICAgYH1nZXRPdXRwdXQoZSl7bGV0IHQ9dGhpcy5nZXRTb3VyY2VDb29yZHNBcnIoZSk7cmV0dXJuIHRoaXMucmFuaz09PTE/YGdldEEocmMpLCAocmMgKyAxID49ICR7dGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zP1wib3V0U2hhcGVcIjp0aGlzLm91dHB1dFNoYXBlWzBdfSA/IDAuIDogZ2V0QShyYyArIDEpKSwgMCwgMGA6YGdldEEoJHt0WzBdfSksXG4gICAgICAgICAgICBjRWRnZSA/IDAuIDogZ2V0QSgke3RbMV19KSxcbiAgICAgICAgICAgIHJFZGdlID8gMC4gOiBnZXRBKCR7dFsyXX0pLFxuICAgICAgICAgICAgckVkZ2UgfHwgY0VkZ2UgPyAwLiA6IGdldEEoJHt0WzNdfSlgfX0sQUE9Y2xhc3N7Y29uc3RydWN0b3IoZSx0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLmN1c3RvbVVuaWZvcm1zPVt7bmFtZTpcImlucHV0U2hhcGVcIix0eXBlOlwiaXZlYzNcIn1dLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXM9dm4odGhpcy5vdXRwdXRTaGFwZS5sZW5ndGgpO2xldCBuPVwiXCI7Zm9yKGxldCBhPTA7YTw0O2ErKyl7bGV0IHI9XCJ0aGlzUkMgPSByYztcIjthJTI9PT0xJiYocis9XCJ0aGlzUkMueiArPSAxO1wiKSxhPjEmJihyKz1cInRoaXNSQy55ICs9IDE7XCIpLG4rPWBcbiAgICAgICAgJHtyfVxuICAgICAgICAke2E+MD9cImlmKHRoaXNSQy55IDwgcm93cyAmJiB0aGlzUkMueiA8IGNvbHMpe1wiOlwiXCJ9XG4gICAgICAgICAgaW50IGZsYXRJbmRleCA9IGdldEZsYXRJbmRleCh0aGlzUkMpO1xuXG4gICAgICAgICAgaXZlYzMgaW5wdXRSQyA9IGlucHV0Q29vcmRzRnJvbVJlc2hhcGVkT3V0Q29vcmRzKGZsYXRJbmRleCk7XG4gICAgICAgICAgdmVjMiBpbnB1dFJDSW5uZXJEaW1zID0gdmVjMihmbG9hdChpbnB1dFJDLnkpLGZsb2F0KGlucHV0UkMueikpO1xuXG4gICAgICAgICAgcmVzdWx0WyR7YX1dID1cbiAgICAgICAgICAgIGdldENoYW5uZWwoZ2V0QShpbnB1dFJDLngsIGlucHV0UkMueSwgaW5wdXRSQy56KSwgaW5wdXRSQ0lubmVyRGltcyk7XG4gICAgICAgICR7YT4wP1wifVwiOlwiXCJ9XG4gICAgICBgfXRoaXMudXNlckNvZGU9YFxuICAgICAgJHtHUSh0LHRoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcyl9XG4gICAgICAke3RoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz9laygpOlExKGUpfVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWMzIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG5cbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcblxuICAgICAgICBpdmVjMyB0aGlzUkM7XG4gICAgICAgIGludCByb3dzID0gJHt0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXM/XCJvdXRTaGFwZVsxXVwiOmVbMV19O1xuICAgICAgICBpbnQgY29scyA9ICR7dGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zP1wib3V0U2hhcGVbMl1cIjplWzJdfTtcblxuICAgICAgICAke259XG5cbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgYH19O2Z1bmN0aW9uIEdRKGUsdCl7cmV0dXJuYFxuICAgIGl2ZWMzIGlucHV0Q29vcmRzRnJvbVJlc2hhcGVkT3V0Q29vcmRzKGludCBpbmRleCkge1xuICAgICAgJHt0P3I5KFtcInJcIixcImNcIixcImRcIl0sXCJpbnB1dFNoYXBlXCIpOlpvKFtcInJcIixcImNcIixcImRcIl0sZSl9XG4gICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XG4gICAgfVxuICBgfXZhciBIUT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLmdwZ3B1PWUsdGhpcy5udW1Vc2VkVGV4dHVyZXM9MCx0aGlzLm51bUZyZWVUZXh0dXJlcz0wLHRoaXMuX251bUJ5dGVzQWxsb2NhdGVkPTAsdGhpcy5fbnVtQnl0ZXNGcmVlPTAsdGhpcy5mcmVlVGV4dHVyZXM9e30sdGhpcy51c2VkVGV4dHVyZXM9e30sdGhpcy5sb2dFbmFibGVkPSExfWFjcXVpcmVUZXh0dXJlKGUsdCxuKXtsZXQgYT1zUyh0LG4pLHI9aVMoZSxhLG4pO3IgaW4gdGhpcy5mcmVlVGV4dHVyZXN8fCh0aGlzLmZyZWVUZXh0dXJlc1tyXT1bXSksciBpbiB0aGlzLnVzZWRUZXh0dXJlc3x8KHRoaXMudXNlZFRleHR1cmVzW3JdPVtdKTtsZXQgcz1yUyhlLGEsdGhpcy5ncGdwdS5nbCx0aGlzLmdwZ3B1LnRleHR1cmVDb25maWcsbik7aWYodGhpcy5mcmVlVGV4dHVyZXNbcl0ubGVuZ3RoPjApe3RoaXMubnVtRnJlZVRleHR1cmVzLS0sdGhpcy5udW1Vc2VkVGV4dHVyZXMrKyx0aGlzLl9udW1CeXRlc0ZyZWUtPXMsdGhpcy5sb2coKTtsZXQgbz10aGlzLmZyZWVUZXh0dXJlc1tyXS5wb3AoKTtyZXR1cm4gdGhpcy51c2VkVGV4dHVyZXNbcl0ucHVzaChvKSxvfWxldCBpO3JldHVybiBhPT09Y24uUEFDS0VEXzJYMl9GTE9BVDMyP2k9dGhpcy5ncGdwdS5jcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlKGVbMF0sZVsxXSk6YT09PWNuLlBBQ0tFRF8yWDJfRkxPQVQxNj9pPXRoaXMuZ3BncHUuY3JlYXRlRmxvYXQxNlBhY2tlZE1hdHJpeFRleHR1cmUoZVswXSxlWzFdKTphPT09Y24uVU5QQUNLRURfRkxPQVQzMj9pPXRoaXMuZ3BncHUuY3JlYXRlRmxvYXQzMk1hdHJpeFRleHR1cmUoZVswXSxlWzFdKTphPT09Y24uVU5QQUNLRURfRkxPQVQxNj9pPXRoaXMuZ3BncHUuY3JlYXRlRmxvYXQxNk1hdHJpeFRleHR1cmUoZVswXSxlWzFdKTphPT09Y24uUEFDS0VEXzRYMV9VTlNJR05FRF9CWVRFJiYoaT10aGlzLmdwZ3B1LmNyZWF0ZVVuc2lnbmVkQnl0ZXNNYXRyaXhUZXh0dXJlKGVbMF0sZVsxXSkpLHRoaXMudXNlZFRleHR1cmVzW3JdLnB1c2goaSksdGhpcy5udW1Vc2VkVGV4dHVyZXMrKyx0aGlzLl9udW1CeXRlc0FsbG9jYXRlZCs9cyx0aGlzLmxvZygpLGl9cmVsZWFzZVRleHR1cmUoZSx0LG4sYSl7aWYodGhpcy5mcmVlVGV4dHVyZXM9PW51bGwpcmV0dXJuO2xldCByPXNTKG4sYSkscz1pUyh0LHIsYSk7cyBpbiB0aGlzLmZyZWVUZXh0dXJlc3x8KHRoaXMuZnJlZVRleHR1cmVzW3NdPVtdKTtsZXQgaT1yUyh0LHIsdGhpcy5ncGdwdS5nbCx0aGlzLmdwZ3B1LnRleHR1cmVDb25maWcsYSksbz1HKCkuZ2V0TnVtYmVyKFwiV0VCR0xfREVMRVRFX1RFWFRVUkVfVEhSRVNIT0xEXCIpO28hPT0tMSYmdGhpcy5fbnVtQnl0ZXNBbGxvY2F0ZWQ+bz8odGhpcy5ncGdwdS5kZWxldGVNYXRyaXhUZXh0dXJlKGUudGV4dHVyZSksdGhpcy5fbnVtQnl0ZXNBbGxvY2F0ZWQtPWkpOih0aGlzLmZyZWVUZXh0dXJlc1tzXS5wdXNoKGUpLHRoaXMubnVtRnJlZVRleHR1cmVzKyssdGhpcy5fbnVtQnl0ZXNGcmVlKz1pKSx0aGlzLm51bVVzZWRUZXh0dXJlcy0tO2xldCBsPXRoaXMudXNlZFRleHR1cmVzW3NdLHU9bCYmbC5pbmRleE9mKGUpO2lmKHU9PW51bGx8fHU8MCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVsZWFzZSBhIHRleHR1cmUgdGhhdCB3YXMgbmV2ZXIgcHJvdmlkZWQgYnkgdGhpcyB0ZXh0dXJlIG1hbmFnZXJcIik7bFt1XT1sW2wubGVuZ3RoLTFdLGwucG9wKCksdGhpcy5sb2coKX1sb2coKXtpZighdGhpcy5sb2dFbmFibGVkKXJldHVybjtsZXQgZT10aGlzLm51bUZyZWVUZXh0dXJlcyt0aGlzLm51bVVzZWRUZXh0dXJlcztjb25zb2xlLmxvZyhcIkZyZWUvVXNlZFwiLGAke3RoaXMubnVtRnJlZVRleHR1cmVzfSAvICR7dGhpcy5udW1Vc2VkVGV4dHVyZXN9YCxgKCR7ZX0pYCk7bGV0IHQ9dGhpcy5fbnVtQnl0ZXNGcmVlL3RoaXMuX251bUJ5dGVzQWxsb2NhdGVkO2NvbnNvbGUubG9nKGBCeXRlcyBhbGxvY2F0ZWQ6ICR7dGhpcy5fbnVtQnl0ZXNBbGxvY2F0ZWR9YCksY29uc29sZS5sb2coYEJ5dGVzIHVudXNlZDogJHt0aGlzLl9udW1CeXRlc0ZyZWV9ICgke01hdGgucm91bmQoMTAwKnQpfSUpYCl9Z2V0IG51bUJ5dGVzQWxsb2NhdGVkKCl7cmV0dXJuIHRoaXMuX251bUJ5dGVzQWxsb2NhdGVkfWdldCBudW1CeXRlc0ZyZWUoKXtyZXR1cm4gdGhpcy5fbnVtQnl0ZXNGcmVlfWdldE51bVVzZWRUZXh0dXJlcygpe3JldHVybiB0aGlzLm51bVVzZWRUZXh0dXJlc31nZXROdW1GcmVlVGV4dHVyZXMoKXtyZXR1cm4gdGhpcy5udW1GcmVlVGV4dHVyZXN9ZGlzcG9zZSgpe2lmKHRoaXMuZnJlZVRleHR1cmVzIT1udWxsKXtmb3IobGV0IGUgaW4gdGhpcy5mcmVlVGV4dHVyZXMpdGhpcy5mcmVlVGV4dHVyZXNbZV0uZm9yRWFjaCh0PT57dGhpcy5ncGdwdS5kZWxldGVNYXRyaXhUZXh0dXJlKHQudGV4dHVyZSl9KTtmb3IobGV0IGUgaW4gdGhpcy51c2VkVGV4dHVyZXMpdGhpcy51c2VkVGV4dHVyZXNbZV0uZm9yRWFjaCh0PT57dGhpcy5ncGdwdS5kZWxldGVNYXRyaXhUZXh0dXJlKHQudGV4dHVyZSl9KTt0aGlzLmZyZWVUZXh0dXJlcz1udWxsLHRoaXMudXNlZFRleHR1cmVzPW51bGwsdGhpcy5udW1Vc2VkVGV4dHVyZXM9MCx0aGlzLm51bUZyZWVUZXh0dXJlcz0wLHRoaXMuX251bUJ5dGVzQWxsb2NhdGVkPTAsdGhpcy5fbnVtQnl0ZXNGcmVlPTB9fX07ZnVuY3Rpb24galEoZSx0KXtsZXQgbj1lO2lmKHQ9PT1uLlIzMkYpcmV0dXJuIDQ7aWYodD09PW4uUjE2RilyZXR1cm4gMjtpZih0PT09bi5SR0JBMzJGfHx0PT09ZS5SR0JBKXJldHVybiAxNjtpZih0PT09bi5SR0JBMTZGKXJldHVybiA4O2lmKHQ9PT1uLlJHQkE4KXJldHVybiA0O3Rocm93IG5ldyBFcnJvcihgVW5rbm93biBpbnRlcm5hbCBmb3JtYXQgJHt0fWApfWZ1bmN0aW9uIHJTKGUsdCxuLGEscil7bGV0IHM9cVEodCxhKSxpO2lmKHIpe2xldFtsLHVdPW9wKGVbMF0sZVsxXSk7aT1sKnV9ZWxzZXtsZXRbbCx1XT1fZChlWzBdLGVbMV0pO2k9bCp1fWxldCBvPWpRKG4scyk7cmV0dXJuIGkqb31mdW5jdGlvbiBxUShlLHQpe3N3aXRjaChlKXtjYXNlIGNuLlBBQ0tFRF8yWDJfRkxPQVQzMjpyZXR1cm4gc2sodCk7Y2FzZSBjbi5QQUNLRURfMlgyX0ZMT0FUMTY6cmV0dXJuIGlrKHQpO2Nhc2UgY24uVU5QQUNLRURfRkxPQVQzMjpyZXR1cm4gbmsodCk7Y2FzZSBjbi5VTlBBQ0tFRF9GTE9BVDE2OnJldHVybiBhayh0KTtjYXNlIGNuLlBBQ0tFRF80WDFfVU5TSUdORURfQllURTpyZXR1cm4gcmsodCk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcGh5c2ljYWwgdGV4dHVyZSB0eXBlICR7ZX1gKX19ZnVuY3Rpb24gS1EoZSl7cmV0dXJuIEcoKS5nZXRCb29sKFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRFwiKT9lP2NuLlBBQ0tFRF8yWDJfRkxPQVQzMjpjbi5VTlBBQ0tFRF9GTE9BVDMyOmU/Y24uUEFDS0VEXzJYMl9GTE9BVDE2OmNuLlVOUEFDS0VEX0ZMT0FUMTZ9ZnVuY3Rpb24gc1MoZSx0KXtpZihlPT09Y2EuVVBMT0FEKXJldHVybiBjbi5QQUNLRURfMlgyX0ZMT0FUMzI7aWYoZT09PWNhLlJFTkRFUnx8ZT09bnVsbClyZXR1cm4gS1EodCk7aWYoZT09PWNhLkRPV05MT0FEfHxlPT09Y2EuUElYRUxTKXJldHVybiBjbi5QQUNLRURfNFgxX1VOU0lHTkVEX0JZVEU7dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxvZ2ljYWwgdGV4dHVyZSB0eXBlICR7ZX1gKX1mdW5jdGlvbiBpUyhlLHQsbil7cmV0dXJuYCR7ZVswXX1fJHtlWzFdfV8ke3R9XyR7bn1gfXZhciBycj1jbGFzc3tjb25zdHJ1Y3RvcihlLHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXM9dm4odGhpcy5vdXRwdXRTaGFwZS5sZW5ndGgpLHRoaXMudXNlckNvZGU9YFxuICAgICAgZmxvYXQgdW5hcnlPcGVyYXRpb24oZmxvYXQgeCkge1xuICAgICAgICAke3R9XG4gICAgICB9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZmxvYXQgeCA9IGdldEFBdE91dENvb3JkcygpO1xuICAgICAgICBmbG9hdCB5ID0gdW5hcnlPcGVyYXRpb24oeCk7XG5cbiAgICAgICAgc2V0T3V0cHV0KHkpO1xuICAgICAgfVxuICAgIGB9fSxEYT1cImlmIChpc25hbih4KSkgcmV0dXJuIHg7XCIsWFE9XCJyZXR1cm4geDtcIixvUz1cInJldHVybiBhYnMoeCk7XCIsWVE9XCJyZXR1cm4gKHggPj0gMC4wKSA/IHggOiAoZXhwKHgpIC0gMS4wKTtcIixaUT1EYStgXG4gIHJldHVybiAoeCA8IDAuMCkgPyAwLjAgOiB4O1xuYCxKUT1EYStgXG4gIHJldHVybiAoeCA8IDAuMCkgPyAwLjAgOiBtaW4oNi4wLCB4KTtcbmAsWXI9XCJyZXR1cm4geDtcIixRUT1cInJldHVybiAxLjAgLyAoMS4wICsgZXhwKC0xLjAgKiB4KSk7XCIsZWVlPVwicmV0dXJuIHg7XCIsdGVlPWBcbiAgdmVjNCByZXN1bHQ7XG5cbiAgcmVzdWx0LnIgPSAoeC5yID49IDAuMCkgPyB4LnIgOiAoZXhwKHgucikgLSAxLjApO1xuICByZXN1bHQuZyA9ICh4LmcgPj0gMC4wKSA/IHguZyA6IChleHAoeC5nKSAtIDEuMCk7XG4gIHJlc3VsdC5iID0gKHguYiA+PSAwLjApID8geC5iIDogKGV4cCh4LmIpIC0gMS4wKTtcbiAgcmVzdWx0LmEgPSAoeC5hID49IDAuMCkgPyB4LmEgOiAoZXhwKHguYSkgLSAxLjApO1xuXG4gIHJldHVybiByZXN1bHQ7XG5gLG5lZT1gXG4gIHZlYzQgcmVzdWx0ID0geCAqIHZlYzQoZ3JlYXRlclRoYW5FcXVhbCh4LCB2ZWM0KDAuMCkpKTtcbiAgYnZlYzQgaXNOYU4gPSBpc25hbih4KTtcblxuICByZXN1bHQuciA9IGlzTmFOLnIgPyB4LnIgOiByZXN1bHQucjtcbiAgcmVzdWx0LmcgPSBpc05hTi5nID8geC5nIDogcmVzdWx0Lmc7XG4gIHJlc3VsdC5iID0gaXNOYU4uYiA/IHguYiA6IHJlc3VsdC5iO1xuICByZXN1bHQuYSA9IGlzTmFOLmEgPyB4LmEgOiByZXN1bHQuYTtcblxuICByZXR1cm4gcmVzdWx0O1xuYCxhZWU9YFxuICB2ZWM0IHJlc3VsdCA9IG1pbih4LCB2ZWM0KDYuKSkgKiB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoeCwgdmVjNCgwLjApKSk7XG4gIGJ2ZWM0IGlzTmFOID0gaXNuYW4oeCk7XG5cbiAgcmVzdWx0LnIgPSBpc05hTi5yID8geC5yIDogcmVzdWx0LnI7XG4gIHJlc3VsdC5nID0gaXNOYU4uZyA/IHguZyA6IHJlc3VsdC5nO1xuICByZXN1bHQuYiA9IGlzTmFOLmIgPyB4LmIgOiByZXN1bHQuYjtcbiAgcmVzdWx0LmEgPSBpc05hTi5hID8geC5hIDogcmVzdWx0LmE7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbmAscmVlPVwicmV0dXJuIDEuMCAvICgxLjAgKyBleHAoLTEuMCAqIHgpKTtcIix0cz1jbGFzc3tjb25zdHJ1Y3RvcihlLHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXM9dm4odGhpcy5vdXRwdXRTaGFwZS5sZW5ndGgpLHRoaXMudXNlckNvZGU9YFxuICAgICAgdmVjNCB1bmFyeU9wZXJhdGlvbih2ZWM0IHgpIHtcbiAgICAgICAgJHt0fVxuICAgICAgfVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZlYzQgeCA9IGdldEFBdE91dENvb3JkcygpO1xuICAgICAgICB2ZWM0IHkgPSB1bmFyeU9wZXJhdGlvbih4KTtcblxuICAgICAgICBzZXRPdXRwdXQoeSk7XG4gICAgICB9XG4gICAgYH19LHNlZT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMSx0aGlzLm91dHB1dFNoYXBlPWUsdGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zPXZuKHRoaXMub3V0cHV0U2hhcGUubGVuZ3RoKTtsZXQgdD1lLmxlbmd0aCxuPUluKFwicmNcIix0KSxhPWh0KHQpLHI9VlEodCxuKSxzPW4uc2xpY2UoLTIpLGk9dDw9MT9cInJjXCI6YHZlYzIoJHtzLmpvaW4oXCIsXCIpfSlgO3RoaXMudXNlckNvZGU9YFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAke2F9IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIHZlYzQgcGFja2VkSW5wdXQgPSBnZXRBKCR7cn0pO1xuXG4gICAgICAgIHNldE91dHB1dChnZXRDaGFubmVsKHBhY2tlZElucHV0LCAke2l9KSk7XG4gICAgICB9XG4gICAgYH19LGllZT1tci53aGVyZUltcGwsb2VlPTFlLTcsbGVlPTFlLTQseXg9e307ZnVuY3Rpb24gdWVlKGUpe3JldHVybiBlIGluIHl4fHwoeXhbZV09e30pLHl4W2VdfXZhciBwZWU9RygpLmdldE51bWJlcihcIkNQVV9IQU5ET0ZGX1NJWkVfVEhSRVNIT0xEXCIpLGNlZT02MDA7ZnVuY3Rpb24gZGVlKCl7cmV0dXJuIEcoKS5nbG9iYWwuc2NyZWVuPT1udWxsPzEwMjQ6RygpLmdsb2JhbC5zY3JlZW4uaGVpZ2h0KkcoKS5nbG9iYWwuc2NyZWVuLndpZHRoKndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKmNlZS8xMDI0LzEwMjR9dmFyIGxrPWNsYXNzIEZBIGV4dGVuZHMgRmN7bmV4dERhdGFJZCgpe3JldHVybiBGQS5uZXh0RGF0YUlkKyt9Y29uc3RydWN0b3IodCl7aWYoc3VwZXIoKSx0aGlzLnBlbmRpbmdSZWFkPW5ldyBXZWFrTWFwLHRoaXMucGVuZGluZ0Rpc3Bvc2FsPW5ldyBXZWFrU2V0LHRoaXMuZGF0YVJlZkNvdW50PW5ldyBXZWFrTWFwLHRoaXMubnVtQnl0ZXNJbkdQVT0wLHRoaXMudXBsb2FkV2FpdE1zPTAsdGhpcy5kb3dubG9hZFdhaXRNcz0wLHRoaXMubGFzdEdsRmx1c2hUaW1lPTAsdGhpcy53YXJuZWRBYm91dE1lbW9yeT0hMSx0aGlzLnBlbmRpbmdEZWxldGVzPTAsdGhpcy5kaXNwb3NlZD0hMSwhRygpLmdldEJvb2woXCJIQVNfV0VCR0xcIikpdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZVwiKTtsZXQgbjtpZih0IT1udWxsKXtpZih0IGluc3RhbmNlb2YgV2gpbj10O2Vsc2V7bGV0IGE9amEoRygpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIiksdCk7bj1uZXcgV2goYSl9dGhpcy5iaW5hcnlDYWNoZT17fSx0aGlzLmdwZ3B1Q3JlYXRlZExvY2FsbHk9ITF9ZWxzZXtsZXQgYT1qYShHKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSk7bj1uZXcgV2goYSksdGhpcy5iaW5hcnlDYWNoZT11ZWUoRygpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpLHRoaXMuZ3BncHVDcmVhdGVkTG9jYWxseT0hMH10aGlzLmdwZ3B1PW4sdGhpcy5jYW52YXM9dGhpcy5ncGdwdS5nbC5jYW52YXMsdGhpcy50ZXh0dXJlTWFuYWdlcj1uZXcgSFEodGhpcy5ncGdwdSksdGhpcy5udW1NQkJlZm9yZVdhcm5pbmc9ZGVlKCksdGhpcy50ZXhEYXRhPW5ldyB5bSh0aGlzLFRhKCkpfW51bURhdGFJZHMoKXtyZXR1cm4gdGhpcy50ZXhEYXRhLm51bURhdGFJZHMoKS10aGlzLnBlbmRpbmdEZWxldGVzfXdyaXRlVGV4dHVyZSh0LG4sYSxyLHMsaSl7bGV0IG89dGhpcy5tYWtlVGVuc29ySW5mbyhuLGEpLGw9dGhpcy50ZXhEYXRhLmdldChvLmRhdGFJZCk7bC5pc1BhY2tlZD0hMSxsLnRleHR1cmU9e3RleHR1cmU6dCx0ZXhTaGFwZTpbcixzXX0sbC50ZXhTaGFwZT1bcixzXTtsZXQgdT1pYyhuKSxwPW5ldyBhUyh1LCExLGkpLGQ9dGhpcy5ydW5XZWJHTFByb2dyYW0ocCxbb10sYSxbW3Isc11dKTtyZXR1cm4gZC5zaGFwZT1uLGwudGV4dHVyZT1udWxsLHRoaXMuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obyksZC5kYXRhSWR9d3JpdGUodCxuLGEpe2lmKChHKCkuZ2V0Qm9vbChcIldFQkdMX0NIRUNLX05VTUVSSUNBTF9QUk9CTEVNU1wiKXx8RygpLmdldEJvb2woXCJERUJVR1wiKSkmJnRoaXMuY2hlY2tOdW1lcmljYWxQcm9ibGVtcyh0KSxhPT09XCJjb21wbGV4NjRcIiYmdCE9bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgd3JpdGUgdG8gYSBjb21wbGV4NjQgZHR5cGUuIFBsZWFzZSB1c2UgdGYuY29tcGxleChyZWFsLCBpbWFnKS5cIik7bGV0IHI9e2lkOnRoaXMubmV4dERhdGFJZCgpfTtyZXR1cm4gdGhpcy50ZXhEYXRhLnNldChyLHtzaGFwZTpuLGR0eXBlOmEsdmFsdWVzOnQsdXNhZ2U6Y2EuVVBMT0FELHJlZkNvdW50OjF9KSxyfXJlZkNvdW50KHQpe3JldHVybiB0aGlzLnRleERhdGEuaGFzKHQpP3RoaXMudGV4RGF0YS5nZXQodCkucmVmQ291bnQ6MH1pbmNSZWYodCl7bGV0IG49dGhpcy50ZXhEYXRhLmdldCh0KTtuLnJlZkNvdW50Kyt9ZGVjUmVmKHQpe2lmKHRoaXMudGV4RGF0YS5oYXModCkpe2xldCBuPXRoaXMudGV4RGF0YS5nZXQodCk7bi5yZWZDb3VudC0tfX1tb3ZlKHQsbixhLHIscyl7aWYoRygpLmdldEJvb2woXCJERUJVR1wiKSYmdGhpcy5jaGVja051bWVyaWNhbFByb2JsZW1zKG4pLHI9PT1cImNvbXBsZXg2NFwiKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB3cml0ZSB0byBhIGNvbXBsZXg2NCBkdHlwZS4gUGxlYXNlIHVzZSB0Zi5jb21wbGV4KHJlYWwsIGltYWcpLlwiKTt0aGlzLnRleERhdGEuc2V0KHQse3NoYXBlOmEsZHR5cGU6cix2YWx1ZXM6bix1c2FnZTpjYS5VUExPQUQscmVmQ291bnQ6c30pfWRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHQpe3RoaXMuZGlzcG9zZURhdGEodC5kYXRhSWQpfXJlYWRTeW5jKHQpe2xldCBuPXRoaXMudGV4RGF0YS5nZXQodCkse3ZhbHVlczphLGR0eXBlOnIsY29tcGxleFRlbnNvckluZm9zOnMsc2xpY2U6aSxzaGFwZTpvLGlzUGFja2VkOmx9PW47aWYoaSE9bnVsbCl7bGV0IGM7bD9jPW5ldyB0cyhvLFlyKTpjPW5ldyBycihvLFlyKTtsZXQgaD10aGlzLnJ1bldlYkdMUHJvZ3JhbShjLFt7ZGF0YUlkOnQsc2hhcGU6byxkdHlwZTpyfV0sciksbT10aGlzLnJlYWRTeW5jKGguZGF0YUlkKTtyZXR1cm4gdGhpcy5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhoKSxtfWlmKGEhPW51bGwpcmV0dXJuIHRoaXMuY29udmVydEFuZENhY2hlT25DUFUodCk7aWYocj09PVwic3RyaW5nXCIpcmV0dXJuIGE7bGV0IHU9dGhpcy5hY3RpdmVUaW1lcnMhPW51bGwscDt1JiYocD13Lm5vdygpKTtsZXQgZDtpZihyPT09XCJjb21wbGV4NjRcIil7bGV0IGM9dGhpcy5yZWFkU3luYyhzLnJlYWwuZGF0YUlkKSxoPXRoaXMucmVhZFN5bmMocy5pbWFnLmRhdGFJZCk7ZD1ULm1lcmdlUmVhbEFuZEltYWdBcnJheXMoYyxoKX1lbHNlIGQ9dGhpcy5nZXRWYWx1ZXNGcm9tVGV4dHVyZSh0KTtyZXR1cm4gdSYmKHRoaXMuZG93bmxvYWRXYWl0TXMrPXcubm93KCktcCksdGhpcy5jb252ZXJ0QW5kQ2FjaGVPbkNQVSh0LGQpfWFzeW5jIHJlYWQodCl7aWYodGhpcy5wZW5kaW5nUmVhZC5oYXModCkpe2xldCBtPXRoaXMucGVuZGluZ1JlYWQuZ2V0KHQpO3JldHVybiBuZXcgUHJvbWlzZShmPT5tLnB1c2goZikpfWxldCBuPXRoaXMudGV4RGF0YS5nZXQodCkse3ZhbHVlczphLHNoYXBlOnIsc2xpY2U6cyxkdHlwZTppLGNvbXBsZXhUZW5zb3JJbmZvczpvLGlzUGFja2VkOmx9PW47aWYocyE9bnVsbCl7bGV0IG07bD9tPW5ldyB0cyhyLFlyKTptPW5ldyBycihyLFlyKTtsZXQgZj10aGlzLnJ1bldlYkdMUHJvZ3JhbShtLFt7ZGF0YUlkOnQsc2hhcGU6cixkdHlwZTppfV0saSksZz10aGlzLnJlYWQoZi5kYXRhSWQpO3JldHVybiB0aGlzLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGYpLGd9aWYoYSE9bnVsbClyZXR1cm4gdGhpcy5jb252ZXJ0QW5kQ2FjaGVPbkNQVSh0KTtpZihHKCkuZ2V0Qm9vbChcIkRFQlVHXCIpJiYhRygpLmdldEJvb2woXCJXRUJHTF9ET1dOTE9BRF9GTE9BVF9FTkFCTEVEXCIpJiZHKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKT09PTIpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yLmRhdGEoKSB3aXRoIFdFQkdMX0RPV05MT0FEX0ZMT0FUX0VOQUJMRUQ9ZmFsc2UgYW5kIFdFQkdMX1ZFUlNJT049MiBub3QgeWV0IHN1cHBvcnRlZC5cIik7bGV0IHU9bnVsbCxwO2lmKGkhPT1cImNvbXBsZXg2NFwiJiZHKCkuZ2V0KFwiV0VCR0xfQlVGRkVSX1NVUFBPUlRFRFwiKSl7cD10aGlzLmRlY29kZSh0KTtsZXQgbT10aGlzLnRleERhdGEuZ2V0KHAuZGF0YUlkKTt1PXRoaXMuZ3BncHUuY3JlYXRlQnVmZmVyRnJvbVRleHR1cmUobS50ZXh0dXJlLnRleHR1cmUsLi4uQWgocikpfXRoaXMucGVuZGluZ1JlYWQuc2V0KHQsW10pLGkhPT1cImNvbXBsZXg2NFwiJiZhd2FpdCB0aGlzLmdwZ3B1LmNyZWF0ZUFuZFdhaXRGb3JGZW5jZSgpO2xldCBkO2lmKGk9PT1cImNvbXBsZXg2NFwiKXtsZXQgbT1hd2FpdCBQcm9taXNlLmFsbChbdGhpcy5yZWFkKG8ucmVhbC5kYXRhSWQpLHRoaXMucmVhZChvLmltYWcuZGF0YUlkKV0pLGY9bVswXSxnPW1bMV07ZD1ULm1lcmdlUmVhbEFuZEltYWdBcnJheXMoZixnKX1lbHNlIGlmKHU9PW51bGwpZD10aGlzLmdldFZhbHVlc0Zyb21UZXh0dXJlKHQpO2Vsc2V7bGV0IG09dy5zaXplRnJvbVNoYXBlKHIpO2Q9dGhpcy5ncGdwdS5kb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tQnVmZmVyKHUsbSl9aWYocCE9bnVsbCYmdGhpcy5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhwKSx1IT1udWxsKXtsZXQgbT10aGlzLmdwZ3B1LmdsO2RlKG0sKCk9Pm0uZGVsZXRlQnVmZmVyKHUpKX1sZXQgYz10aGlzLmNvbnZlcnRBbmRDYWNoZU9uQ1BVKHQsZCksaD10aGlzLnBlbmRpbmdSZWFkLmdldCh0KTtyZXR1cm4gdGhpcy5wZW5kaW5nUmVhZC5kZWxldGUodCksaC5mb3JFYWNoKG09Pm0oYykpLHRoaXMucGVuZGluZ0Rpc3Bvc2FsLmhhcyh0KSYmKHRoaXMucGVuZGluZ0Rpc3Bvc2FsLmRlbGV0ZSh0KSx0aGlzLmRpc3Bvc2VEYXRhKHQpJiZUYSgpLnJlbW92ZURhdGFJZCh0LHRoaXMpLHRoaXMucGVuZGluZ0RlbGV0ZXMtLSksY31yZWFkVG9HUFUodCxuPXt9KXtsZXQgYT10aGlzLnRleERhdGEuZ2V0KHQpLHt2YWx1ZXM6cixzaGFwZTpzLHNsaWNlOmksZHR5cGU6byxpc1BhY2tlZDpsLHRleHR1cmU6dX09YTtpZihvPT09XCJjb21wbGV4NjRcIil0aHJvdyBuZXcgRXJyb3IoXCJEb2VzIG5vdCBzdXBwb3J0IHJlYWRpbmcgdGV4dHVyZSBmb3IgY29tcGxleDY0IGR0eXBlLlwiKTtpZihpIT1udWxsKXtsZXQgaDtsP2g9bmV3IHRzKHMsWXIpOmg9bmV3IHJyKHMsWXIpO2xldCBtPXRoaXMucnVuV2ViR0xQcm9ncmFtKGgsW3tkYXRhSWQ6dCxzaGFwZTpzLGR0eXBlOm99XSxvKSxmPXRoaXMucmVhZFRvR1BVKG0sbik7cmV0dXJuIHRoaXMuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obSksZn1pZih1PT1udWxsKXRocm93IHIhPW51bGw/bmV3IEVycm9yKFwiRGF0YSBpcyBub3Qgb24gR1BVIGJ1dCBvbiBDUFUuXCIpOm5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIGRhdGEgb24gR1BVIG9yIENQVS5cIik7bGV0IHA9dGhpcy5kZWNvZGUodCxuLmN1c3RvbVRleFNoYXBlKSxkPVRhKCkubWFrZVRlbnNvckZyb21UZW5zb3JJbmZvKHApLGM9dGhpcy50ZXhEYXRhLmdldChwLmRhdGFJZCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oe3RlbnNvclJlZjpkfSxjLnRleHR1cmUpfWJ1ZmZlclN5bmModCl7bGV0IG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCk7aWYodC5kdHlwZT09PVwic3RyaW5nXCIpdHJ5e2xldCBhPW4ubWFwKHI9PncuZGVjb2RlU3RyaW5nKHIpKTtyZXR1cm4gT2UodC5zaGFwZSx0LmR0eXBlLGEpfWNhdGNoKGEpe3Rocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZWNvZGUgZW5jb2RlZCBzdHJpbmcgYnl0ZXMgaW50byB1dGYtOFwiKX1yZXR1cm4gT2UodC5zaGFwZSx0LmR0eXBlLG4pfWNoZWNrTnVtZXJpY2FsUHJvYmxlbXModCl7aWYodCE9bnVsbClmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyl7bGV0IGE9dFtuXTtpZighUl8oYSkpdGhyb3cgRygpLmdldEJvb2woXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9DQVBBQkxFXCIpP0Vycm9yKGBUaGUgdmFsdWUgJHthfSBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgd2l0aCB5b3VyIGN1cnJlbnQgc2V0dGluZ3MuIENvbnNpZGVyIGVuYWJsaW5nIGZsb2F0MzIgcmVuZGVyaW5nOiAndGYuZW52KCkuc2V0KCdXRUJHTF9SRU5ERVJfRkxPQVQzMl9FTkFCTEVEJywgdHJ1ZSk7J2ApOkVycm9yKGBUaGUgdmFsdWUgJHthfSBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgb24gdGhpcyBkZXZpY2UuYCl9fWdldFZhbHVlc0Zyb21UZXh0dXJlKHQpe2xldHtzaGFwZTpuLGR0eXBlOmEsaXNQYWNrZWQ6cn09dGhpcy50ZXhEYXRhLmdldCh0KSxzPXcuc2l6ZUZyb21TaGFwZShuKTtpZihHKCkuZ2V0Qm9vbChcIldFQkdMX0RPV05MT0FEX0ZMT0FUX0VOQUJMRURcIikpe2xldCBjPXRoaXMuZGVjb2RlKHQpLGg9dGhpcy50ZXhEYXRhLmdldChjLmRhdGFJZCksbT10aGlzLmdwZ3B1LmRvd25sb2FkTWF0cml4RnJvbVBhY2tlZFRleHR1cmUoaC50ZXh0dXJlLnRleHR1cmUsLi4uQWgobikpLnN1YmFycmF5KDAscyk7cmV0dXJuIHRoaXMuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oYyksbX1sZXQgaT1HKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIikmJnI9PT0hMCxvPWk/aWMobik6bixsPWk/bmV3IHE5KG8pOm5ldyBqOShvKSx1PXRoaXMucnVuV2ViR0xQcm9ncmFtKGwsW3tzaGFwZTpvLGR0eXBlOmEsZGF0YUlkOnR9XSxcImZsb2F0MzJcIikscD10aGlzLnRleERhdGEuZ2V0KHUuZGF0YUlkKSxkPXRoaXMuZ3BncHUuZG93bmxvYWRCeXRlRW5jb2RlZEZsb2F0TWF0cml4RnJvbU91dHB1dFRleHR1cmUocC50ZXh0dXJlLnRleHR1cmUscC50ZXhTaGFwZVswXSxwLnRleFNoYXBlWzFdKS5zdWJhcnJheSgwLHMpO3JldHVybiB0aGlzLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHUpLGR9dGltZXJBdmFpbGFibGUoKXtyZXR1cm4gRygpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9SRUxJQUJMRVwiKT4wfXRpbWUodCl7bGV0IG49dGhpcy5hY3RpdmVUaW1lcnMsYT1bXSxyPSExO3RoaXMucHJvZ3JhbVRpbWVyc1N0YWNrPT1udWxsPyh0aGlzLnByb2dyYW1UaW1lcnNTdGFjaz1hLHI9ITApOnRoaXMuYWN0aXZlVGltZXJzLnB1c2goYSksdGhpcy5hY3RpdmVUaW1lcnM9YSx0KCk7bGV0IHM9dy5mbGF0dGVuKHRoaXMuYWN0aXZlVGltZXJzLm1hcChsPT5sLnF1ZXJ5KSkuZmlsdGVyKGw9PmwhPW51bGwpLGk9dy5mbGF0dGVuKHRoaXMuYWN0aXZlVGltZXJzLm1hcChsPT5sLm5hbWUpKS5maWx0ZXIobD0+bCE9bnVsbCk7dGhpcy5hY3RpdmVUaW1lcnM9bixyJiYodGhpcy5wcm9ncmFtVGltZXJzU3RhY2s9bnVsbCk7bGV0IG89e3VwbG9hZFdhaXRNczp0aGlzLnVwbG9hZFdhaXRNcyxkb3dubG9hZFdhaXRNczp0aGlzLmRvd25sb2FkV2FpdE1zLGtlcm5lbE1zOm51bGwsd2FsbE1zOm51bGx9O3JldHVybihhc3luYygpPT57aWYoRygpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9SRUxJQUJMRVwiKT4wKXtsZXQgbD1hd2FpdCBQcm9taXNlLmFsbChzKTtvLmtlcm5lbE1zPXcuc3VtKGwpLG8uZ2V0RXh0cmFQcm9maWxlSW5mbz0oKT0+bC5tYXAoKHUscCk9Pih7bmFtZTppW3BdLG1zOnV9KSkubWFwKHU9PmAke3UubmFtZX06ICR7dS5tc31gKS5qb2luKFwiLCBcIil9ZWxzZSBvLmtlcm5lbE1zPXtlcnJvcjpcIldlYkdMIHF1ZXJ5IHRpbWVycyBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LlwifTtyZXR1cm4gdGhpcy51cGxvYWRXYWl0TXM9MCx0aGlzLmRvd25sb2FkV2FpdE1zPTAsb30pKCl9bWVtb3J5KCl7cmV0dXJue3VucmVsaWFibGU6ITEsbnVtQnl0ZXNJbkdQVTp0aGlzLm51bUJ5dGVzSW5HUFUsbnVtQnl0ZXNJbkdQVUFsbG9jYXRlZDp0aGlzLnRleHR1cmVNYW5hZ2VyLm51bUJ5dGVzQWxsb2NhdGVkLG51bUJ5dGVzSW5HUFVGcmVlOnRoaXMudGV4dHVyZU1hbmFnZXIubnVtQnl0ZXNGcmVlfX1zdGFydFRpbWVyKCl7cmV0dXJuIEcoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fUkVMSUFCTEVcIik+MD90aGlzLmdwZ3B1LmJlZ2luUXVlcnkoKTp7c3RhcnRNczp3Lm5vdygpLGVuZE1zOm51bGx9fWVuZFRpbWVyKHQpe3JldHVybiBHKCkuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFXCIpPjA/KHRoaXMuZ3BncHUuZW5kUXVlcnkoKSx0KToodC5lbmRNcz13Lm5vdygpLHQpfWFzeW5jIGdldFF1ZXJ5VGltZSh0KXtpZihHKCkuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFXCIpPjApcmV0dXJuIHRoaXMuZ3BncHUud2FpdEZvclF1ZXJ5QW5kR2V0VGltZSh0KTtsZXQgbj10O3JldHVybiBuLmVuZE1zLW4uc3RhcnRNc31kaXNwb3NlRGF0YSh0LG49ITEpe2lmKHRoaXMucGVuZGluZ0Rpc3Bvc2FsLmhhcyh0KSlyZXR1cm4hMTtpZighdGhpcy50ZXhEYXRhLmhhcyh0KSlyZXR1cm4hMDtpZihuP3RoaXMudGV4RGF0YS5nZXQodCkucmVmQ291bnQ9MDp0aGlzLnRleERhdGEuZ2V0KHQpLnJlZkNvdW50LS0sIW4mJnRoaXMudGV4RGF0YS5nZXQodCkucmVmQ291bnQ+MClyZXR1cm4hMTtpZih0aGlzLnBlbmRpbmdSZWFkLmhhcyh0KSlyZXR1cm4gdGhpcy5wZW5kaW5nRGlzcG9zYWwuYWRkKHQpLHRoaXMucGVuZGluZ0RlbGV0ZXMrKywhMTt0aGlzLnJlbGVhc2VHUFVEYXRhKHQpO2xldHtjb21wbGV4VGVuc29ySW5mb3M6YX09dGhpcy50ZXhEYXRhLmdldCh0KTtyZXR1cm4gYSE9bnVsbCYmKHRoaXMuZGlzcG9zZURhdGEoYS5yZWFsLmRhdGFJZCxuKSx0aGlzLmRpc3Bvc2VEYXRhKGEuaW1hZy5kYXRhSWQsbikpLHRoaXMudGV4RGF0YS5kZWxldGUodCksITB9cmVsZWFzZUdQVURhdGEodCl7bGV0e3RleHR1cmU6bixkdHlwZTphLHRleFNoYXBlOnIsdXNhZ2U6cyxpc1BhY2tlZDppLHNsaWNlOm99PXRoaXMudGV4RGF0YS5nZXQodCksbD1vJiZvLm9yaWdEYXRhSWR8fHQsdT10aGlzLmRhdGFSZWZDb3VudC5nZXQobCk7dT4xP3RoaXMuZGF0YVJlZkNvdW50LnNldChsLHUtMSk6KHRoaXMuZGF0YVJlZkNvdW50LmRlbGV0ZShsKSxuIT1udWxsJiYodGhpcy5udW1CeXRlc0luR1BVLT10aGlzLmNvbXB1dGVCeXRlcyhyLGEpLHRoaXMudGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUobixyLHMsaSkpKTtsZXQgcD10aGlzLnRleERhdGEuZ2V0KHQpO3AudGV4dHVyZT1udWxsLHAudGV4U2hhcGU9bnVsbCxwLmlzUGFja2VkPSExLHAuc2xpY2U9bnVsbH1nZXRUZXh0dXJlKHQpe3JldHVybiB0aGlzLnVwbG9hZFRvR1BVKHQpLHRoaXMudGV4RGF0YS5nZXQodCkudGV4dHVyZS50ZXh0dXJlfWdldERhdGFJbmZvKHQpe3JldHVybiB0aGlzLnRleERhdGEuZ2V0KHQpfXNob3VsZEV4ZWN1dGVPbkNQVSh0LG49cGVlKXtyZXR1cm4gRygpLmdldEJvb2woXCJXRUJHTF9DUFVfRk9SV0FSRFwiKSYmdC5ldmVyeShhPT50aGlzLnRleERhdGEuZ2V0KGEuZGF0YUlkKS50ZXh0dXJlPT1udWxsJiZ3LnNpemVGcm9tU2hhcGUoYS5zaGFwZSk8bil9Z2V0R1BHUFVDb250ZXh0KCl7cmV0dXJuIHRoaXMuZ3BncHV9d2hlcmUodCl7VC53YXJuKFwidGYud2hlcmUoKSBpbiB3ZWJnbCBsb2NrcyB0aGUgVUkgdGhyZWFkLiBDYWxsIHRmLndoZXJlQXN5bmMoKSBpbnN0ZWFkXCIpO2xldCBuPXQuZGF0YVN5bmMoKTtyZXR1cm4gaWVlKHQuc2hhcGUsbil9cGFja2VkVW5hcnlPcCh0LG4sYSl7bGV0IHI9bmV3IHRzKHQuc2hhcGUsbikscz10aGlzLmNvbXBpbGVBbmRSdW4ocixbdF0sYSk7cmV0dXJuIFRhKCkubWFrZVRlbnNvckZyb21UZW5zb3JJbmZvKHMpfWFicyh0KXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pJiZ0LmR0eXBlIT09XCJjb21wbGV4NjRcIil7bGV0IHI9Q0EodGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCkudmFsdWVzKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KHQuc2hhcGUsdC5kdHlwZSxyKX1pZihHKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfVU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRVbmFyeU9wKHQsb1MsdC5kdHlwZSk7bGV0IG49bmV3IHJyKHQuc2hhcGUsb1MpLGE9dGhpcy5jb21waWxlQW5kUnVuKG4sW3RdKTtyZXR1cm4gVGEoKS5tYWtlVGVuc29yRnJvbVRlbnNvckluZm8oYSl9bWFrZVRlbnNvckluZm8odCxuLGEpe2xldCByO2lmKG49PT1cInN0cmluZ1wiJiZhIT1udWxsJiZhLmxlbmd0aD4wJiZ3LmlzU3RyaW5nKGFbMF0pKXtsZXQgcz1hLm1hcChpPT53LmVuY29kZVN0cmluZyhpKSk7cj10aGlzLndyaXRlKHMsdCxuKX1lbHNlIHI9dGhpcy53cml0ZShhLHQsbik7cmV0dXJuIHRoaXMudGV4RGF0YS5nZXQocikudXNhZ2U9bnVsbCx7ZGF0YUlkOnIsc2hhcGU6dCxkdHlwZTpufX1tYWtlT3V0cHV0KHQsbixhKXtyZXR1cm4gVGEoKS5tYWtlVGVuc29yRnJvbVRlbnNvckluZm8odGhpcy5tYWtlVGVuc29ySW5mbyh0LG4sYSksdGhpcyl9dW5wYWNrVGVuc29yKHQpe2xldCBuPW5ldyBzZWUodC5zaGFwZSk7cmV0dXJuIHRoaXMucnVuV2ViR0xQcm9ncmFtKG4sW3RdLHQuZHR5cGUpfXBhY2tUZW5zb3IodCl7bGV0IG49bmV3IFVRKHQuc2hhcGUpO3JldHVybiB0aGlzLnJ1bldlYkdMUHJvZ3JhbShuLFt0XSx0LmR0eXBlLG51bGwsITApfXBhY2tlZFJlc2hhcGUodCxuKXtsZXQgYT1bdmkodC5zaGFwZSksLi4ud2kodC5zaGFwZSldLHI9e2R0eXBlOnQuZHR5cGUsc2hhcGU6YSxkYXRhSWQ6dC5kYXRhSWR9LHM9W3ZpKG4pLC4uLndpKG4pXSxpPW5ldyBBQShzLGEpLG89ITAsbD1bYV0sdT10aGlzLnJ1bldlYkdMUHJvZ3JhbShpLFtyXSx0LmR0eXBlLGwsbyk7cmV0dXJue2RhdGFJZDp1LmRhdGFJZCxzaGFwZTpuLGR0eXBlOnUuZHR5cGV9fWRlY29kZSh0LG4pe2xldCBhPXRoaXMudGV4RGF0YS5nZXQodCkse2lzUGFja2VkOnIsc2hhcGU6cyxkdHlwZTppfT1hO2lmKG4hPW51bGwpe2xldCBjPXcuc2l6ZUZyb21TaGFwZShzKSxoPW5bMF0qblsxXSo0O3cuYXNzZXJ0KGM8PWgsKCk9PlwiY3VzdG9tVGV4U2hhcGUgaXMgdG9vIHNtYWxsLiBSb3cgKiBDb2x1bW4gKiA0IHNob3VsZCBiZSBlcXVhbCBvciBsYXJnZXIgdGhhbiB0aGUgc2l6ZSBvZiB0aGUgdGVuc29yIGRhdGEuXCIpfWxldCBvPWljKHMpLGw7cj9sPW5ldyBIOShvKTpsPW5ldyBHOShvKTtsZXQgdT0hMCxwPVtuIT1udWxsP246QWgobyldLGQ9dGhpcy5ydW5XZWJHTFByb2dyYW0obCxbe3NoYXBlOm8sZHR5cGU6aSxkYXRhSWQ6dH1dLGkscCx1LG4pO3JldHVybntkdHlwZTppLHNoYXBlOnMsZGF0YUlkOmQuZGF0YUlkfX1ydW5XZWJHTFByb2dyYW0odCxuLGEscixzPSExLGkpe2xldCBvPXRoaXMubWFrZVRlbnNvckluZm8odC5vdXRwdXRTaGFwZSxhKSxsPXRoaXMudGV4RGF0YS5nZXQoby5kYXRhSWQpO2lmKHQucGFja2VkT3V0cHV0JiYobC5pc1BhY2tlZD0hMCksdC5vdXRQYWNraW5nU2NoZW1lPT09TmMuREVOU0Upe2xldCBiPWkhPW51bGw/aTpBaCh0Lm91dHB1dFNoYXBlKTtsLnRleFNoYXBlPWIubWFwKHk9PnkqMil9aWYodC5vdXRUZXhVc2FnZSE9bnVsbCYmKGwudXNhZ2U9dC5vdXRUZXhVc2FnZSksdy5zaXplRnJvbVNoYXBlKG8uc2hhcGUpPT09MClyZXR1cm4gbC52YWx1ZXM9dy5nZXRUeXBlZEFycmF5RnJvbURUeXBlKG8uZHR5cGUsMCksbztsZXQgdT1bXSxwPW4ubWFwKGI9PntpZihiLmR0eXBlPT09XCJjb21wbGV4NjRcIil0aHJvdyBuZXcgRXJyb3IoXCJHUEdQVVByb2dyYW0gZG9lcyBub3Qgc3VwcG9ydCBjb21wbGV4NjQgaW5wdXQuIEZvciBjb21wbGV4NjQgZHR5cGVzLCBwbGVhc2Ugc2VwYXJhdGUgdGhlIHByb2dyYW0gaW50byByZWFsIGFuZCBpbWFnaW5hcnkgcGFydHMuXCIpO2xldCB5PXRoaXMudGV4RGF0YS5nZXQoYi5kYXRhSWQpO2lmKHkudGV4dHVyZT09bnVsbCl7aWYoIXQucGFja2VkSW5wdXRzJiZ3LnNpemVGcm9tU2hhcGUoYi5zaGFwZSk8PUcoKS5nZXROdW1iZXIoXCJXRUJHTF9TSVpFX1VQTE9BRF9VTklGT1JNXCIpKXJldHVybntzaGFwZTpiLnNoYXBlLHRleERhdGE6bnVsbCxpc1VuaWZvcm06ITAsdW5pZm9ybVZhbHVlczp5LnZhbHVlc307dC5wYWNrZWRJbnB1dHMmJih5LmlzUGFja2VkPSEwLHkuc2hhcGU9Yi5zaGFwZSl9aWYodGhpcy51cGxvYWRUb0dQVShiLmRhdGFJZCksISF5LmlzUGFja2VkIT0hIXQucGFja2VkSW5wdXRzKWI9eS5pc1BhY2tlZD90aGlzLnVucGFja1RlbnNvcihiKTp0aGlzLnBhY2tUZW5zb3IoYiksdS5wdXNoKGIpLHk9dGhpcy50ZXhEYXRhLmdldChiLmRhdGFJZCk7ZWxzZSBpZih5LmlzUGFja2VkJiYhVGMoeS5zaGFwZSxiLnNoYXBlKSl7bGV0IHg9Yix2PWIuc2hhcGU7Yi5zaGFwZT15LnNoYXBlLGI9dGhpcy5wYWNrZWRSZXNoYXBlKGIsdiksdS5wdXNoKGIpLHk9dGhpcy50ZXhEYXRhLmdldChiLmRhdGFJZCkseC5zaGFwZT12fXJldHVybntzaGFwZTpiLnNoYXBlLHRleERhdGE6eSxpc1VuaWZvcm06ITF9fSk7dGhpcy51cGxvYWRUb0dQVShvLmRhdGFJZCk7bGV0IGQ9e3NoYXBlOm8uc2hhcGUsdGV4RGF0YTpsLGlzVW5pZm9ybTohMX0sYz1VOSh0LHAsZCksaD10aGlzLmdldEFuZFNhdmVCaW5hcnkoYywoKT0+QjkodGhpcy5ncGdwdSx0LHAsZCkpLG09dGhpcy5hY3RpdmVUaW1lcnMhPW51bGwsZjttJiYoZj10aGlzLnN0YXJ0VGltZXIoKSksRygpLmdldChcIkVOR0lORV9DT01QSUxFX09OTFlcIil8fFY5KHRoaXMuZ3BncHUsaCxwLGQsciksdS5mb3JFYWNoKGI9PnRoaXMuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oYikpLG0mJihmPXRoaXMuZW5kVGltZXIoZiksdGhpcy5hY3RpdmVUaW1lcnMucHVzaCh7bmFtZTp0LmNvbnN0cnVjdG9yLm5hbWUscXVlcnk6dGhpcy5nZXRRdWVyeVRpbWUoZil9KSk7bGV0IGc9RygpLmdldE51bWJlcihcIldFQkdMX0ZMVVNIX1RIUkVTSE9MRFwiKTtpZihnPjApe2xldCBiPXcubm93KCk7Yi10aGlzLmxhc3RHbEZsdXNoVGltZT5nJiYodGhpcy5ncGdwdS5nbC5mbHVzaCgpLHRoaXMubGFzdEdsRmx1c2hUaW1lPWIpfWlmKCFHKCkuZ2V0Qm9vbChcIldFQkdMX0xBWklMWV9VTlBBQ0tcIikmJmwuaXNQYWNrZWQmJnM9PT0hMSl7bGV0IGI9dGhpcy51bnBhY2tUZW5zb3Iobyk7cmV0dXJuIHRoaXMuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obyksYn1yZXR1cm4gb31jb21waWxlQW5kUnVuKHQsbixhLHIscz0hMSl7cmV0dXJuIGE9YXx8blswXS5kdHlwZSx0aGlzLnJ1bldlYkdMUHJvZ3JhbSh0LG4sYSxyLHMpfWdldEFuZFNhdmVCaW5hcnkodCxuKXtyZXR1cm4gdCBpbiB0aGlzLmJpbmFyeUNhY2hlfHwodGhpcy5iaW5hcnlDYWNoZVt0XT1uKCkpLHRoaXMuYmluYXJ5Q2FjaGVbdF19Z2V0VGV4dHVyZU1hbmFnZXIoKXtyZXR1cm4gdGhpcy50ZXh0dXJlTWFuYWdlcn1kaXNwb3NlKCl7dGhpcy5kaXNwb3NlZHx8KEcoKS5nZXRCb29sKFwiSVNfVEVTVFwiKXx8T2JqZWN0LmtleXModGhpcy5iaW5hcnlDYWNoZSkuZm9yRWFjaCh0PT57dGhpcy5ncGdwdS5kZWxldGVQcm9ncmFtKHRoaXMuYmluYXJ5Q2FjaGVbdF0ud2ViR0xQcm9ncmFtKSxkZWxldGUgdGhpcy5iaW5hcnlDYWNoZVt0XX0pLHRoaXMudGV4dHVyZU1hbmFnZXIuZGlzcG9zZSgpLHRoaXMuY2FudmFzIT1udWxsJiZ0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQhPVwidW5kZWZpbmVkXCImJnRoaXMuY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQ/dGhpcy5jYW52YXMucmVtb3ZlKCk6dGhpcy5jYW52YXM9bnVsbCx0aGlzLmdwZ3B1Q3JlYXRlZExvY2FsbHkmJih0aGlzLmdwZ3B1LnByb2dyYW09bnVsbCx0aGlzLmdwZ3B1LmRpc3Bvc2UoKSksdGhpcy5kaXNwb3NlZD0hMCl9ZmxvYXRQcmVjaXNpb24oKXtyZXR1cm4gdGhpcy5mbG9hdFByZWNpc2lvblZhbHVlPT1udWxsJiYodGhpcy5mbG9hdFByZWNpc2lvblZhbHVlPU8oKCk9PntpZighRygpLmdldChcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRURcIikpe2xldCB0PUcoKS5nZXRCb29sKFwiREVCVUdcIik7RygpLnNldChcIkRFQlVHXCIsITEpO2xldCBuPXRoaXMuYWJzKHhlKDFlLTgpKS5kYXRhU3luYygpWzBdO2lmKEcoKS5zZXQoXCJERUJVR1wiLHQpLG4+MClyZXR1cm4gMzJ9cmV0dXJuIDE2fSkpLHRoaXMuZmxvYXRQcmVjaXNpb25WYWx1ZX1lcHNpbG9uKCl7cmV0dXJuIHRoaXMuZmxvYXRQcmVjaXNpb24oKT09PTMyP29lZTpsZWV9dXBsb2FkVG9HUFUodCl7bGV0IG49dGhpcy50ZXhEYXRhLmdldCh0KSx7c2hhcGU6YSxkdHlwZTpyLHZhbHVlczpzLHRleHR1cmU6aSx1c2FnZTpvLGlzUGFja2VkOmx9PW47aWYoaSE9bnVsbClyZXR1cm47bGV0IHU9dGhpcy5hY3RpdmVUaW1lcnMhPW51bGwscDt1JiYocD13Lm5vdygpKTtsZXQgZD1uLnRleFNoYXBlO2lmKGQ9PW51bGwmJihkPVpfKGEsbCksbi50ZXhTaGFwZT1kKSxzIT1udWxsKXtsZXQgYz1pYyhhKSxoLG09ZFsxXSxmPWRbMF0sZz1zIGluc3RhbmNlb2YgVWludDhBcnJheXx8cyBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5OyhsfHwhZykmJihbbSxmXT1vcChkWzBdLGRbMV0pKSxsP2g9bmV3IFg5KGMsZyk6aD1uZXcgYVMoYyxnKTtsZXQgYj1nP1tmLG1dOmQseT10aGlzLm1ha2VUZW5zb3JJbmZvKGIscikseD10aGlzLnRleERhdGEuZ2V0KHkuZGF0YUlkKTtnP3gudXNhZ2U9Y2EuUElYRUxTOngudXNhZ2U9Y2EuVVBMT0FELHgudGV4U2hhcGU9Yix0aGlzLmdwZ3B1LnVwbG9hZERlbnNlTWF0cml4VG9UZXh0dXJlKHRoaXMuZ2V0VGV4dHVyZSh5LmRhdGFJZCksbSxmLHMpO2xldCB2PVtbZixtXV0sST10aGlzLnJ1bldlYkdMUHJvZ3JhbShoLFt5XSxyLHYsITApLE49dGhpcy50ZXhEYXRhLmdldChJLmRhdGFJZCk7bi50ZXhTaGFwZT1OLnRleFNoYXBlLG4uaXNQYWNrZWQ9Ti5pc1BhY2tlZCxuLnVzYWdlPU4udXNhZ2UsRygpLmdldChcIkVOR0lORV9DT01QSUxFX09OTFlcIik/dGhpcy5kaXNwb3NlRGF0YShJLmRhdGFJZCk6KG4udGV4dHVyZT1OLnRleHR1cmUsbi52YWx1ZXM9bnVsbCx0aGlzLnRleERhdGEuZGVsZXRlKEkuZGF0YUlkKSksdGhpcy5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh5KSx1JiYodGhpcy51cGxvYWRXYWl0TXMrPXcubm93KCktcCl9ZWxzZXtsZXQgYz10aGlzLmFjcXVpcmVUZXh0dXJlKGQsbyxyLGwpO24udGV4dHVyZT1jfX1jb252ZXJ0QW5kQ2FjaGVPbkNQVSh0LG4pe2xldCBhPXRoaXMudGV4RGF0YS5nZXQodCkse2R0eXBlOnJ9PWE7cmV0dXJuIG4hPW51bGwmJihhLnZhbHVlcz1oZWUobixyKSksYS52YWx1ZXN9YWNxdWlyZVRleHR1cmUodCxuLGEscil7aWYodGhpcy5udW1CeXRlc0luR1BVKz10aGlzLmNvbXB1dGVCeXRlcyh0LGEpLCF0aGlzLndhcm5lZEFib3V0TWVtb3J5JiZ0aGlzLm51bUJ5dGVzSW5HUFU+dGhpcy5udW1NQkJlZm9yZVdhcm5pbmcqMTAyNCoxMDI0KXtsZXQgcz0odGhpcy5udW1CeXRlc0luR1BVLzEwMjQvMTAyNCkudG9GaXhlZCgyKTt0aGlzLndhcm5lZEFib3V0TWVtb3J5PSEwLGNvbnNvbGUud2FybihgSGlnaCBtZW1vcnkgdXNhZ2UgaW4gR1BVOiAke3N9IE1CLCBtb3N0IGxpa2VseSBkdWUgdG8gYSBtZW1vcnkgbGVha2ApfXJldHVybiB0aGlzLnRleHR1cmVNYW5hZ2VyLmFjcXVpcmVUZXh0dXJlKHQsbixyKX1jb21wdXRlQnl0ZXModCxuKXtyZXR1cm4gdFswXSp0WzFdKncuYnl0ZXNQZXJFbGVtZW50KG4pfWNoZWNrQ29tcGlsZUNvbXBsZXRpb24oKXtmb3IobGV0Wyx0XW9mIE9iamVjdC5lbnRyaWVzKHRoaXMuYmluYXJ5Q2FjaGUpKXRoaXMuY2hlY2tDb21wbGV0aW9uXyh0KX1hc3luYyBjaGVja0NvbXBpbGVDb21wbGV0aW9uQXN5bmMoKXtsZXQgdD1bXTtpZih0aGlzLmdwZ3B1LnBhcmFsbGVsQ29tcGlsYXRpb25FeHRlbnNpb24pe2ZvcihsZXRbLG5db2YgT2JqZWN0LmVudHJpZXModGhpcy5iaW5hcnlDYWNoZSkpdC5wdXNoKHRoaXMuY2hlY2tDb21wbGV0aW9uQXN5bmNfKG4pKTtyZXR1cm4gUHJvbWlzZS5hbGwodCl9ZWxzZXtmb3IobGV0WyxuXW9mIE9iamVjdC5lbnRyaWVzKHRoaXMuYmluYXJ5Q2FjaGUpKXtsZXQgYT1uZXcgUHJvbWlzZShyPT57dHJ5e3RoaXMuY2hlY2tDb21wbGV0aW9uXyhuKSxyKCEwKX1jYXRjaChzKXt0aHJvdyBzfX0pO3QucHVzaChhKX1yZXR1cm4gUHJvbWlzZS5hbGwodCl9fWFzeW5jIGNoZWNrQ29tcGxldGlvbkFzeW5jXyh0KXtyZXR1cm4gdGhpcy5ncGdwdS5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHQud2ViR0xQcm9ncmFtLHRoaXMuZ3BncHUucGFyYWxsZWxDb21waWxhdGlvbkV4dGVuc2lvbi5DT01QTEVUSU9OX1NUQVRVU19LSFIpP3RoaXMuY2hlY2tDb21wbGV0aW9uXyh0KTooYXdhaXQgWncoKSx0aGlzLmNoZWNrQ29tcGxldGlvbkFzeW5jXyh0KSl9Y2hlY2tDb21wbGV0aW9uXyh0KXtpZih0aGlzLmdwZ3B1LmdsLmdldFByb2dyYW1QYXJhbWV0ZXIodC53ZWJHTFByb2dyYW0sdGhpcy5ncGdwdS5nbC5MSU5LX1NUQVRVUyk9PT0hMSl0aHJvdyBjb25zb2xlLmxvZyh0aGlzLmdwZ3B1LmdsLmdldFByb2dyYW1JbmZvTG9nKHQud2ViR0xQcm9ncmFtKSksdGhpcy5ncGdwdS5nbC5nZXRTaGFkZXJQYXJhbWV0ZXIodC5mcmFnbWVudFNoYWRlcix0aGlzLmdwZ3B1LmdsLkNPTVBJTEVfU1RBVFVTKT09PSExPyhKMSh0LnNvdXJjZSx0aGlzLmdwZ3B1LmdsLmdldFNoYWRlckluZm9Mb2codC5mcmFnbWVudFNoYWRlcikpLG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb21waWxlIGZyYWdtZW50IHNoYWRlci5cIikpOm5ldyBFcnJvcihcIkZhaWxlZCB0byBsaW5rIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVycy5cIik7cmV0dXJuITB9Z2V0VW5pZm9ybUxvY2F0aW9ucygpe2ZvcihsZXQgdCBvZiBPYmplY3QudmFsdWVzKHRoaXMuYmluYXJ5Q2FjaGUpKXt0aGlzLmdwZ3B1LmJ1aWxkVmFvKHQud2ViR0xQcm9ncmFtKTtsZXR7dmFyaWFibGVzTG9jYXRpb25zOm4sY3VzdG9tVW5pZm9ybUxvY2F0aW9uczphLGluZkxvYzpyLG5hbkxvYzpzLG91dFNoYXBlTG9jYXRpb246aSxvdXRTaGFwZVN0cmlkZXNMb2NhdGlvbjpvLG91dFRleFNoYXBlTG9jYXRpb246bH09bEEodGhpcy5ncGdwdSx0LnByb2dyYW0sdC53ZWJHTFByb2dyYW0pO3QudmFyaWFibGVzTG9jYXRpb25zPW4sdC5jdXN0b21Vbmlmb3JtTG9jYXRpb25zPWEsdC5pbmZMb2M9cix0Lm5hbkxvYz1zLHQub3V0U2hhcGVMb2NhdGlvbj1pLHQub3V0U2hhcGVTdHJpZGVzTG9jYXRpb249byx0Lm91dFRleFNoYXBlTG9jYXRpb249bH19Y3JlYXRlVGVuc29yRnJvbUdQVURhdGEodCxuLGEpe3QuY2hhbm5lbHM9dC5jaGFubmVsc3x8XCJSR0JBXCI7bGV0e3RleHR1cmU6cixoZWlnaHQ6cyx3aWR0aDppLGNoYW5uZWxzOm99PXQsbD1UYSgpLmJhY2tlbmQ7aWYoIWwuZ3BncHUuZ2wuaXNUZXh0dXJlKHIpKXRocm93IG5ldyBFcnJvcihcIlRoZSB0ZXh0dXJlIGlzIGludmFsaWQuIEFsc28sIHBsZWFzZSBtYWtlIHN1cmUgdGhlIHRleHR1cmUgYW5kIHRoZSBURkpTIFdlYkdMIGJhY2tlbmQgYXJlIHVzaW5nIHRoZSBzYW1lIGNhbnZhcy4gSWYgeW91IHdhbnQgdG8gdXNlIHlvdXIgb3duIGN1c3RvbSBjYW52YXMsIHlvdSBoYXZlIHRvIGNyZWF0ZSBhbmQgdXNlIHRoZSBjdXN0b20gVEZKUyBXZWJHTCBiYWNrZW5kIGNyZWF0ZWQgZnJvbSB0aGUgY2FudmFzIHRocm91Z2ggJ25ldyB0Zi5NYXRoQmFja2VuZFdlYkdMKGN1c3RvbUNhbnZhcyknLlwiKTtsZXQgdT1sLndyaXRlVGV4dHVyZShyLG4sYSxzLGksbyk7cmV0dXJuIFRhKCkubWFrZVRlbnNvckZyb21EYXRhSWQodSxuLGEsbCl9fTtsay5uZXh0RGF0YUlkPTA7ZnVuY3Rpb24gaGVlKGUsdCl7aWYodD09PVwiZmxvYXQzMlwifHx0PT09XCJjb21wbGV4NjRcIilyZXR1cm4gZTtpZih0PT09XCJpbnQzMlwifHx0PT09XCJib29sXCIpe2xldCBuPXQ9PT1cImludDMyXCI/bmV3IEludDMyQXJyYXkoZS5sZW5ndGgpOm5ldyBVaW50OEFycmF5KGUubGVuZ3RoKTtmb3IobGV0IGE9MDthPG4ubGVuZ3RoOysrYSluW2FdPU1hdGgucm91bmQoZVthXSk7cmV0dXJuIG59ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZHR5cGUgJHt0fWApfXZhciBtZWU9XCI0LjIyLjBcIjtmdW5jdGlvbiAkQSgpe0coKS5zZXQoXCJXRUJHTF9GT1JDRV9GMTZfVEVYVFVSRVNcIiwhMCl9YWQuaXNCcm93c2VyKCkmJk9tKFwid2ViZ2xcIiwoKT0+bmV3IGxrLDIpO3ZhciBmZWU9e2ZvcmNlSGFsZkZsb2F0OiRBfSx1az1gXG4gIGlmIChpc25hbihhKSkgcmV0dXJuIGE7XG4gIGlmIChpc25hbihiKSkgcmV0dXJuIGI7XG5gLGtpPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiLFwiQlwiXSx0aGlzLm91dHB1dFNoYXBlPVQuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUodCxuKSx0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXM9dm4odGhpcy5vdXRwdXRTaGFwZS5sZW5ndGgpLHRoaXMudXNlckNvZGU9YFxuICAgICAgZmxvYXQgYmluYXJ5T3BlcmF0aW9uKGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICAgICAgJHtlfVxuICAgICAgfVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGZsb2F0IGEgPSBnZXRBQXRPdXRDb29yZHMoKTtcbiAgICAgICAgZmxvYXQgYiA9IGdldEJBdE91dENvb3JkcygpO1xuICAgICAgICBzZXRPdXRwdXQoYmluYXJ5T3BlcmF0aW9uKGEsIGIpKTtcbiAgICAgIH1cbiAgICBgfX0sUW89YFxuICByZXN1bHQuciA9IGlzTmFOLnIgPyBOQU4gOiByZXN1bHQucjtcbiAgcmVzdWx0LmcgPSBpc05hTi5nID8gTkFOIDogcmVzdWx0Lmc7XG4gIHJlc3VsdC5iID0gaXNOYU4uYiA/IE5BTiA6IHJlc3VsdC5iO1xuICByZXN1bHQuYSA9IGlzTmFOLmEgPyBOQU4gOiByZXN1bHQuYTtcbmAsaHA9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4sYT0hMSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIixcIkJcIl0sdGhpcy5zdXBwb3J0c0Jyb2FkY2FzdGluZz0hMCx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dHB1dFNoYXBlPVQuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUodCxuKTtsZXQgcj10aGlzLm91dHB1dFNoYXBlLmxlbmd0aDt0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXM9dm4ocik7bGV0IHM9XCJcIjtpZihhKWlmKHI9PT0wfHx3LnNpemVGcm9tU2hhcGUodGhpcy5vdXRwdXRTaGFwZSk9PT0xKXM9YFxuICAgICAgICAgIHJlc3VsdC55ID0gMC47XG4gICAgICAgICAgcmVzdWx0LnogPSAwLjtcbiAgICAgICAgICByZXN1bHQudyA9IDAuO1xuICAgICAgICBgO2Vsc2UgaWYocz1gXG4gICAgICAgICAgJHtodChyKX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGAscj09PTEpdGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zP3MrPWBcbiAgICAgICAgICAgIHJlc3VsdC55ID0gKGNvb3JkcyArIDEpID49IG91dFNoYXBlID8gMC4gOiByZXN1bHQueTtcbiAgICAgICAgICAgIHJlc3VsdC56ID0gMC47XG4gICAgICAgICAgICByZXN1bHQudyA9IDAuO1xuICAgICAgICAgIGA6cys9YFxuICAgICAgICAgICAgcmVzdWx0LnkgPSAoY29vcmRzICsgMSkgPj0gJHt0aGlzLm91dHB1dFNoYXBlWzBdfSA/IDAuIDogcmVzdWx0Lnk7XG4gICAgICAgICAgICByZXN1bHQueiA9IDAuO1xuICAgICAgICAgICAgcmVzdWx0LncgPSAwLjtcbiAgICAgICAgICBgO2Vsc2V7bGV0IGk9SW4oXCJjb29yZHNcIixyKTt0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXM/cys9YFxuICAgICAgICAgICAgYm9vbCBuZXh0Um93T3V0T2ZCb3VuZHMgPVxuICAgICAgICAgICAgICAoJHtpW3ItMl19ICsgMSkgPj0gb3V0U2hhcGVbJHtyfSAtIDJdO1xuICAgICAgICAgICAgYm9vbCBuZXh0Q29sT3V0T2ZCb3VuZHMgPVxuICAgICAgICAgICAgICAoJHtpW3ItMV19ICsgMSkgPj0gb3V0U2hhcGVbJHtyfSAtIDFdO1xuICAgICAgICAgICAgcmVzdWx0LnkgPSBuZXh0Q29sT3V0T2ZCb3VuZHMgPyAwLiA6IHJlc3VsdC55O1xuICAgICAgICAgICAgcmVzdWx0LnogPSBuZXh0Um93T3V0T2ZCb3VuZHMgPyAwLiA6IHJlc3VsdC56O1xuICAgICAgICAgICAgcmVzdWx0LncgPSBuZXh0Q29sT3V0T2ZCb3VuZHMgfHwgbmV4dFJvd091dE9mQm91bmRzID8gMC4gOiByZXN1bHQudztcbiAgICAgICAgICBgOnMrPWBcbiAgICAgICAgICAgIGJvb2wgbmV4dFJvd091dE9mQm91bmRzID1cbiAgICAgICAgICAgICAgKCR7aVtyLTJdfSArIDEpID49ICR7dGhpcy5vdXRwdXRTaGFwZVtyLTJdfTtcbiAgICAgICAgICAgIGJvb2wgbmV4dENvbE91dE9mQm91bmRzID1cbiAgICAgICAgICAgICAgKCR7aVtyLTFdfSArIDEpID49ICR7dGhpcy5vdXRwdXRTaGFwZVtyLTFdfTtcbiAgICAgICAgICAgIHJlc3VsdC55ID0gbmV4dENvbE91dE9mQm91bmRzID8gMC4gOiByZXN1bHQueTtcbiAgICAgICAgICAgIHJlc3VsdC56ID0gbmV4dFJvd091dE9mQm91bmRzID8gMC4gOiByZXN1bHQuejtcbiAgICAgICAgICAgIHJlc3VsdC53ID0gbmV4dENvbE91dE9mQm91bmRzIHx8IG5leHRSb3dPdXRPZkJvdW5kcyA/IDAuIDogcmVzdWx0Lnc7XG4gICAgICAgICAgYH10aGlzLnVzZXJDb2RlPWBcbiAgICAgIHZlYzQgYmluYXJ5T3BlcmF0aW9uKHZlYzQgYSwgdmVjNCBiKSB7XG4gICAgICAgICR7ZX1cbiAgICAgIH1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2ZWM0IGEgPSBnZXRBQXRPdXRDb29yZHMoKTtcbiAgICAgICAgdmVjNCBiID0gZ2V0QkF0T3V0Q29vcmRzKCk7XG5cbiAgICAgICAgdmVjNCByZXN1bHQgPSBiaW5hcnlPcGVyYXRpb24oYSwgYik7XG4gICAgICAgICR7c31cblxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24gdGEoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7eDphfT10O3JldHVybiBuLmluY1JlZihhLmRhdGFJZCkse2RhdGFJZDphLmRhdGFJZCxzaGFwZTphLnNoYXBlLGR0eXBlOmEuZHR5cGV9fXZhciBnZWU9e2tlcm5lbE5hbWU6ZW8sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6dGF9O2Z1bmN0aW9uICRzKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse3JlYWw6YSxpbWFnOnJ9PXQscz1uLm1ha2VUZW5zb3JJbmZvKGEuc2hhcGUsXCJjb21wbGV4NjRcIiksaT1uLnRleERhdGEuZ2V0KHMuZGF0YUlkKSxvPXRhKHtpbnB1dHM6e3g6YX0sYmFja2VuZDpufSksbD10YSh7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bn0pO3JldHVybiBpLmNvbXBsZXhUZW5zb3JJbmZvcz17cmVhbDpvLGltYWc6bH0sc312YXIgYmVlPXtrZXJuZWxOYW1lOndtLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOiRzfSxEQT1cInJldHVybiAoYSA8IDAuKSA/IGIgKiBhIDogYTtcIixSQT1gXG4gIHZlYzQgYUxlc3NUaGFuWmVybyA9IHZlYzQobGVzc1RoYW4oYSwgdmVjNCgwLikpKTtcbiAgcmV0dXJuIChhTGVzc1RoYW5aZXJvICogKGIgKiBhKSkgKyAoKHZlYzQoMS4wKSAtIGFMZXNzVGhhblplcm8pICogYSk7XG5gO2Z1bmN0aW9uIHllZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7YWxwaGE6c309YSxpPW4ubWFrZVRlbnNvckluZm8oW10sXCJmbG9hdDMyXCIsdy5jcmVhdGVTY2FsYXJWYWx1ZShzLFwiZmxvYXQzMlwiKSksbz1HKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIik/bmV3IGhwKFJBLHIuc2hhcGUsaS5zaGFwZSk6bmV3IGtpKERBLHIuc2hhcGUsaS5zaGFwZSksbD1uLnJ1bldlYkdMUHJvZ3JhbShvLFtyLGldLFwiZmxvYXQzMlwiKTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhpKSxsfXZhciB4ZWU9e2tlcm5lbE5hbWU6cm8sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6eWVlfSxNQT1cInJldHVybiAoYSA8IDAuKSA/IGIgKiBhIDogYTtcIixPQT1gXG4gIHZlYzQgYUxlc3NUaGFuWmVybyA9IHZlYzQobGVzc1RoYW4oYSwgdmVjNCgwLikpKTtcbiAgcmV0dXJuIChhTGVzc1RoYW5aZXJvICogKGIgKiBhKSkgKyAoKHZlYzQoMS4wKSAtIGFMZXNzVGhhblplcm8pICogYSk7XG5gO2Z1bmN0aW9uIHZlZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHt4OmEsYWxwaGE6cn09dCxzPUcoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKT9uZXcgaHAoT0EsYS5zaGFwZSxyLnNoYXBlKTpuZXcga2koTUEsYS5zaGFwZSxyLnNoYXBlKTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0ocyxbYSxyXSxcImZsb2F0MzJcIil9dmFyIHdlZT17a2VybmVsTmFtZTp3byxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzp2ZWV9LG1wPVwiaWYgKGlzbmFuKHgpKSByZXR1cm4geDtcIjtmdW5jdGlvbiBaZSh7b3BTbmlwcGV0OmUscGFja2VkT3BTbmlwcGV0OnQsY3B1S2VybmVsSW1wbDpuLGR0eXBlOmF9KXtyZXR1cm4oe2lucHV0czpyLGJhY2tlbmQ6c30pPT57bGV0e3g6aX09cixvPXMsbD1hfHxpLmR0eXBlO2lmKG8uc2hvdWxkRXhlY3V0ZU9uQ1BVKFtpXSkmJm4hPW51bGwpe2xldCBkPW8udGV4RGF0YS5nZXQoaS5kYXRhSWQpLGM9bihkLnZhbHVlcyxsKTtyZXR1cm4gby5tYWtlVGVuc29ySW5mbyhpLnNoYXBlLGwsYyl9bGV0IHU9RygpLmdldEJvb2woXCJXRUJHTF9QQUNLX1VOQVJZX09QRVJBVElPTlNcIikmJnQhPW51bGwscDtyZXR1cm4gdT9wPW5ldyB0cyhpLnNoYXBlLHQpOnA9bmV3IHJyKGkuc2hhcGUsZSksby5ydW5XZWJHTFByb2dyYW0ocCxbaV0sbCl9fWZ1bmN0aW9uIGhuKHtvcFNuaXBwZXQ6ZSxwYWNrZWRPcFNuaXBwZXQ6dCxjaGVja091dE9mQm91bmRzOm49ITEsc3VwcG9ydHNDb21wbGV4OmE9ITEsY3B1S2VybmVsSW1wbDpyLGR0eXBlOnN9KXtyZXR1cm4oe2lucHV0czppLGJhY2tlbmQ6b30pPT57bGV0e2E6bCxiOnV9PWkscD1vO2lmKGEmJmwuZHR5cGU9PT1cImNvbXBsZXg2NFwiKXtsZXQgbT1wLnRleERhdGEuZ2V0KGwuZGF0YUlkKSxmPXAudGV4RGF0YS5nZXQodS5kYXRhSWQpLFtnLGJdPVtbbS5jb21wbGV4VGVuc29ySW5mb3MucmVhbCxmLmNvbXBsZXhUZW5zb3JJbmZvcy5yZWFsXSxbbS5jb21wbGV4VGVuc29ySW5mb3MuaW1hZyxmLmNvbXBsZXhUZW5zb3JJbmZvcy5pbWFnXV0ubWFwKHg9PntsZXRbdixJXT14LE49e2RhdGFJZDp2LmRhdGFJZCxkdHlwZTp2LmR0eXBlLHNoYXBlOmwuc2hhcGV9LEM9e2RhdGFJZDpJLmRhdGFJZCxkdHlwZTpJLmR0eXBlLHNoYXBlOnUuc2hhcGV9LF89bmV3IGtpKGUsbC5zaGFwZSx1LnNoYXBlKTtyZXR1cm4gcC5ydW5XZWJHTFByb2dyYW0oXyxbTixDXSxmYSh2LmR0eXBlLEkuZHR5cGUpKX0pLHk9JHMoe2lucHV0czp7cmVhbDpnLGltYWc6Yn0sYmFja2VuZDpwfSk7cmV0dXJuIHAuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZykscC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhiKSx5fWxldCBkPXN8fGZhKGwuZHR5cGUsdS5kdHlwZSk7aWYoKGwuZHR5cGU9PT1cInN0cmluZ1wifHx1LmR0eXBlPT09XCJzdHJpbmdcInx8cC5zaG91bGRFeGVjdXRlT25DUFUoW2wsdV0pKSYmciE9bnVsbCl7bGV0IG09cC50ZXhEYXRhLmdldChsLmRhdGFJZCkudmFsdWVzLGY9cC50ZXhEYXRhLmdldCh1LmRhdGFJZCkudmFsdWVzLGc9bC5kdHlwZT09PVwic3RyaW5nXCI/VC5mcm9tVWludDhUb1N0cmluZ0FycmF5KG0pOm0sYj1sLmR0eXBlPT09XCJzdHJpbmdcIj9ULmZyb21VaW50OFRvU3RyaW5nQXJyYXkoZik6ZixbeSx4XT1yKGwuc2hhcGUsdS5zaGFwZSxnLGIsZCksdj1wLm1ha2VUZW5zb3JJbmZvKHgsZCksST1wLnRleERhdGEuZ2V0KHYuZGF0YUlkKTtyZXR1cm4gSS52YWx1ZXM9eSx2fWxldCBjPUcoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSYmdCE9bnVsbCxoO3JldHVybiBjP2g9bmV3IGhwKHQsbC5zaGFwZSx1LnNoYXBlLG4pOmg9bmV3IGtpKGUsbC5zaGFwZSx1LnNoYXBlKSxwLnJ1bldlYkdMUHJvZ3JhbShoLFtsLHVdLGQpfX1mdW5jdGlvbiBDYyhlLHQ9ITEpe2lmKGU9PT1cImxpbmVhclwiKXJldHVybiB0P2VlZTpYUTtpZihlPT09XCJyZWx1XCIpcmV0dXJuIHQ/bmVlOlpRO2lmKGU9PT1cImVsdVwiKXJldHVybiB0P3RlZTpZUTtpZihlPT09XCJyZWx1NlwiKXJldHVybiB0P2FlZTpKUTtpZihlPT09XCJwcmVsdVwiKXJldHVybiB0P09BOk1BO2lmKGU9PT1cImxlYWt5cmVsdVwiKXJldHVybiB0P1JBOkRBO2lmKGU9PT1cInNpZ21vaWRcIilyZXR1cm4gdD9yZWU6UVE7dGhyb3cgbmV3IEVycm9yKGBBY3RpdmF0aW9uICR7ZX0gaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIGZvciB0aGUgV2ViR0wgYmFja2VuZC5gKX12YXIgUEE9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4sYT0hMSxyPSExLHM9ITEsaT1udWxsLG89ITEsbD0hMSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIm1hdHJpeEFcIixcIm1hdHJpeEJcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT1uLHRoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz12bih0aGlzLm91dHB1dFNoYXBlLmxlbmd0aCk7bGV0IHU9YT9lWzFdOmVbMl0scD1NYXRoLmNlaWwodS8yKSxkPWE/XCJpICogMiwgcmMueVwiOlwicmMueSwgaSAqIDJcIixjPXI/XCJyYy56LCBpICogMlwiOlwiaSAqIDIsIHJjLnpcIixoPWE/W1wiYS54eHl5XCIsXCJhLnp6d3dcIl06W1wiYS54eHp6XCIsXCJhLnl5d3dcIl0sbT1yP1tcImIueHp4elwiLFwiYi55d3l3XCJdOltcImIueHl4eVwiLFwiYi56d3p3XCJdLGY9XCJcIixnPVwiXCI7aSYmKG8/Zj1gdmVjNCBhY3RpdmF0aW9uKHZlYzQgYSkge1xuICAgICAgICAgIHZlYzQgYiA9IGdldFByZWx1QWN0aXZhdGlvbldlaWdodHNBdE91dENvb3JkcygpO1xuICAgICAgICAgICR7aX1cbiAgICAgICAgfWA6bD9mPWB2ZWM0IGFjdGl2YXRpb24odmVjNCBhKSB7XG4gICAgICAgICAgdmVjNCBiID0gZ2V0TGVha3lyZWx1QWxwaGFBdE91dENvb3JkcygpO1xuICAgICAgICAgICR7aX1cbiAgICAgICAgfWA6Zj1gdmVjNCBhY3RpdmF0aW9uKHZlYzQgeCkge1xuICAgICAgICAgICR7aX1cbiAgICAgICAgfWAsZz1cInJlc3VsdCA9IGFjdGl2YXRpb24ocmVzdWx0KTtcIik7bGV0IGI9cz9cInJlc3VsdCArPSBnZXRCaWFzQXRPdXRDb29yZHMoKTtcIjpcIlwiO3MmJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwiYmlhc1wiKSxvJiZ0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcInByZWx1QWN0aXZhdGlvbldlaWdodHNcIiksbCYmdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJsZWFreXJlbHVBbHBoYVwiKTtsZXQgeT1cInJjLnhcIix4PVwicmMueFwiO2VbMF08dFswXT95PWBpbW9kKHJjLngsICR7ZVswXX0pYDp0WzBdPGVbMF0mJih4PWBpbW9kKHJjLngsICR7dFswXX0pYCksdGhpcy51c2VyQ29kZT1gXG4gICAgICAke2Z9XG4gICAgICAvLyBEb24ndCB1c2UgdW5pZm9ybSBmb3Igc2hhcmVkRGltZW5zaW9uUGFja2VkIGZvciBwZXJmb3JtYW5jZS5cbiAgICAgIGNvbnN0IGZsb2F0IHNoYXJlZERpbWVuc2lvbiA9ICR7cH0uMDtcblxuICAgICAgdmVjNCBkb3QyeDJBUm93QkNvbChpdmVjMyByYykge1xuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMCk7XG4gICAgICAgIGludCBiYXRjaEEgPSAke3l9O1xuICAgICAgICBpbnQgYmF0Y2hCID0gJHt4fTtcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke3B9OyBpKyspIHtcbiAgICAgICAgICB2ZWM0IGEgPSBnZXRNYXRyaXhBKGJhdGNoQSwgJHtkfSk7XG4gICAgICAgICAgdmVjNCBiID0gZ2V0TWF0cml4QihiYXRjaEIsICR7Y30pO1xuXG4gICAgICAgICAgLy8gVGhlc2Ugc3dpenpsZWQgcHJvZHVjdHMgbmVlZCB0byBiZSBzZXBhcmF0ZWx5IGFkZGVkLlxuICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGZqcy9pc3N1ZXMvMTczNVxuICAgICAgICAgIHJlc3VsdCArPSAoJHtoWzBdfSAqICR7bVswXX0pO1xuICAgICAgICAgIHJlc3VsdCArPSAoJHtoWzFdfSAqICR7bVsxXX0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzMgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgdmVjNCByZXN1bHQgPSBkb3QyeDJBUm93QkNvbChyYyk7XG5cbiAgICAgICAgJHtifVxuXG4gICAgICAgICR7Z31cblxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcbiAgICAgIH1cbiAgICBgfX0sbFM9e1JFQUw6XCJyZXR1cm4gYXJlYWwgKiBicmVhbCAtIGFpbWFnICogYmltYWc7XCIsSU1BRzpcInJldHVybiBhcmVhbCAqIGJpbWFnICsgYWltYWcgKiBicmVhbDtcIn0sdVM9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBUmVhbFwiLFwiQUltYWdcIixcIkJSZWFsXCIsXCJCSW1hZ1wiXSx0aGlzLm91dHB1dFNoYXBlPVQuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUodCxuKSx0aGlzLnVzZXJDb2RlPWBcbiAgICAgIGZsb2F0IGJpbmFyeU9wQ29tcGxleChcbiAgICAgICAgICBmbG9hdCBhcmVhbCwgZmxvYXQgYWltYWcsIGZsb2F0IGJyZWFsLCBmbG9hdCBiaW1hZykge1xuICAgICAgICAke2V9XG4gICAgICB9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZmxvYXQgYXJlYWwgPSBnZXRBUmVhbEF0T3V0Q29vcmRzKCk7XG4gICAgICAgIGZsb2F0IGFpbWFnID0gZ2V0QUltYWdBdE91dENvb3JkcygpO1xuICAgICAgICBmbG9hdCBicmVhbCA9IGdldEJSZWFsQXRPdXRDb29yZHMoKTtcbiAgICAgICAgZmxvYXQgYmltYWcgPSBnZXRCSW1hZ0F0T3V0Q29vcmRzKCk7XG4gICAgICAgIHNldE91dHB1dChiaW5hcnlPcENvbXBsZXgoYXJlYWwsIGFpbWFnLCBicmVhbCwgYmltYWcpKTtcbiAgICAgIH1cbiAgICBgfX0scFM9XCJyZXR1cm4gYSAqIGI7XCI7ZnVuY3Rpb24gcGsoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7YSxiOnJ9PXQscz1ULnVwY2FzdFR5cGUoYS5kdHlwZSxyLmR0eXBlKTtpZihhLmR0eXBlPT09XCJjb21wbGV4NjRcIil7bGV0IG89bi50ZXhEYXRhLmdldChhLmRhdGFJZCksbD1uLnRleERhdGEuZ2V0KHIuZGF0YUlkKSx1PW5ldyB1UyhsUy5SRUFMLGEuc2hhcGUsci5zaGFwZSkscD1uZXcgdVMobFMuSU1BRyxhLnNoYXBlLHIuc2hhcGUpLGQ9W3tkYXRhSWQ6by5jb21wbGV4VGVuc29ySW5mb3MucmVhbC5kYXRhSWQsZHR5cGU6by5jb21wbGV4VGVuc29ySW5mb3MucmVhbC5kdHlwZSxzaGFwZTphLnNoYXBlfSx7ZGF0YUlkOm8uY29tcGxleFRlbnNvckluZm9zLmltYWcuZGF0YUlkLGR0eXBlOm8uY29tcGxleFRlbnNvckluZm9zLmltYWcuZHR5cGUsc2hhcGU6YS5zaGFwZX0se2RhdGFJZDpsLmNvbXBsZXhUZW5zb3JJbmZvcy5yZWFsLmRhdGFJZCxkdHlwZTpsLmNvbXBsZXhUZW5zb3JJbmZvcy5yZWFsLmR0eXBlLHNoYXBlOnIuc2hhcGV9LHtkYXRhSWQ6bC5jb21wbGV4VGVuc29ySW5mb3MuaW1hZy5kYXRhSWQsZHR5cGU6bC5jb21wbGV4VGVuc29ySW5mb3MuaW1hZy5kdHlwZSxzaGFwZTpyLnNoYXBlfV0sYz1uLnJ1bldlYkdMUHJvZ3JhbSh1LGQsXCJmbG9hdDMyXCIpLGg9bi5ydW5XZWJHTFByb2dyYW0ocCxkLFwiZmxvYXQzMlwiKSxtPSRzKHtpbnB1dHM6e3JlYWw6YyxpbWFnOmh9LGJhY2tlbmQ6bn0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGMpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaCksbX1pZihuLnNob3VsZEV4ZWN1dGVPbkNQVShbYSxyXSkpe2xldCBvPW4udGV4RGF0YS5nZXQoYS5kYXRhSWQpLGw9bi50ZXhEYXRhLmdldChyLmRhdGFJZCksW3UscF09eVEoYS5zaGFwZSxyLnNoYXBlLG8udmFsdWVzLGwudmFsdWVzLHMpLGQ9bi5tYWtlVGVuc29ySW5mbyhwLHMpLGM9bi50ZXhEYXRhLmdldChkLmRhdGFJZCk7cmV0dXJuIGMudmFsdWVzPXUsZH1sZXQgaTtyZXR1cm4gRygpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpP2k9bmV3IGhwKHBTLGEuc2hhcGUsci5zaGFwZSk6aT1uZXcga2kocFMsYS5zaGFwZSxyLnNoYXBlKSxuLnJ1bldlYkdMUHJvZ3JhbShpLFthLHJdLHMpfXZhciBrZWU9e2tlcm5lbE5hbWU6Ym8sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6cGt9O2Z1bmN0aW9uIEllZShlLHQsbil7bGV0IGE9W3ZpKGUuc2hhcGUpLC4uLndpKGUuc2hhcGUpXSxyPXtkdHlwZTplLmR0eXBlLHNoYXBlOmEsZGF0YUlkOmUuZGF0YUlkfSxzPVt2aSh0KSwuLi53aSh0KV0saT1uZXcgQUEocyxhKSxvPSEwLGw9W2FdLHU9bi5ydW5XZWJHTFByb2dyYW0oaSxbcl0sZS5kdHlwZSxsLG8pO3JldHVybntkYXRhSWQ6dS5kYXRhSWQsc2hhcGU6dCxkdHlwZTp1LmR0eXBlfX1mdW5jdGlvbiBjZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7c2hhcGU6c309YSxpPW4sbz13LnNpemVGcm9tU2hhcGUoci5zaGFwZSksbD13LmluZmVyRnJvbUltcGxpY2l0U2hhcGUocyxvKSx1PXcuc2l6ZUZyb21TaGFwZShsKTt3LmFzc2VydChvPT09dSwoKT0+YFRoZSBuZXcgc2hhcGUgKCR7bH0pIGhhcyAke3V9IGVsZW1lbnRzIGFuZCB0aGUgb2xkIHNoYXBlICgke3Iuc2hhcGV9KSBoYXMgJHtvfSBlbGVtZW50cy4gVGhlIG5ldyBzaGFwZSBhbmQgb2xkIHNoYXBlIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuYCk7bGV0IHA9aS50ZXhEYXRhLmdldChyLmRhdGFJZCk7cmV0dXJuIHAuaXNQYWNrZWQmJiFUYyhyLnNoYXBlLGwpJiYhKHAudGV4dHVyZSE9PW51bGwmJlRjKHAuc2hhcGUsbCkpP0llZShyLGwsaSk6KGkuaW5jUmVmKHIuZGF0YUlkKSx7ZGF0YUlkOnIuZGF0YUlkLHNoYXBlOmwsZHR5cGU6ci5kdHlwZX0pfXZhciBTZWU9e2tlcm5lbE5hbWU6UnUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6Y2V9LGNTPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl07bGV0e3dpbmRvd1NpemU6bixiYXRjaFNpemU6YSxpblNpemU6cixvdXRTaXplOnN9PWU7dGhpcy5vdXRwdXRTaGFwZT1bYSxzXTtsZXQgaT1NYXRoLmZsb29yKG4vNCkqNCxvPW4lNCxsPVwic3VtVmFsdWUgKz0gZG90KHZhbHVlcywgb25lcyk7XCI7aWYodCE9bnVsbCl7bGV0IHA9MS90O2w9YHN1bVZhbHVlICs9IGRvdCh2YWx1ZXMgKiAke3cuaXNJbnQocCk/cC50b1ByZWNpc2lvbigyKTpwfSwgb25lcyk7YH1sZXQgdT1cIlwiO3Ilbj4wJiYodT1gXG4gICAgICAgIGlmIChpbklkeCA8IDAgfHwgaW5JZHggPj0gJHtyfSkge1xuICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgIH1cbiAgICAgIGApLHRoaXMudXNlckNvZGU9YFxuICAgICAgY29uc3QgdmVjNCBvbmVzID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAxLjApO1xuXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgYmF0Y2gsIGludCBpbklkeCkge1xuICAgICAgICAke3V9XG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCBpbklkeCk7XG4gICAgICB9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcbiAgICAgICAgaW50IG91dElkeCA9IGNvb3Jkc1sxXTtcbiAgICAgICAgaW50IGluT2Zmc2V0ID0gb3V0SWR4ICogJHtufTtcblxuICAgICAgICBmbG9hdCBzdW1WYWx1ZSA9IDAuMDtcblxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7aX07IGkgKz0gNCkge1xuICAgICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgaTtcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAyKSxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDMpXG4gICAgICAgICAgKTtcblxuICAgICAgICAgICR7bH1cbiAgICAgICAgfVxuXG4gICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgJHtpfTtcbiAgICAgICAgaWYgKCR7bz09PTF9KSB7XG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KGdldFZhbHVlKGJhdGNoLCBpbklkeCksIDAuMCwgMC4wLCAwLjApO1xuXG4gICAgICAgICAgJHtsfVxuICAgICAgICB9IGVsc2UgaWYgKCR7bz09PTJ9KSB7XG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLCAwLjAsIDAuMCk7XG5cbiAgICAgICAgICAke2x9XG4gICAgICAgIH0gZWxzZSBpZiAoJHtvPT09M30pIHtcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAyKSwgMC4wKTtcblxuICAgICAgICAgICR7bH1cbiAgICAgICAgfVxuICAgICAgICBzZXRPdXRwdXQoc3VtVmFsdWUpO1xuICAgICAgfVxuICAgIGB9fSxOZWU9Y2xhc3N7Y29uc3RydWN0b3IoZSx0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXTtsZXR7d2luZG93U2l6ZTpuLGJhdGNoU2l6ZTphLGluU2l6ZTpyLG91dFNpemU6c309ZTt0aGlzLm91dHB1dFNoYXBlPVthLHNdO2xldCBpPVwiMC4wXCIsbz1cIlwiO3Q9PT1cInByb2RcIj9pPVwiMS4wXCI6dD09PVwibWluXCI/KGk9XCIxLjAgLyAxZS0yMFwiLG89XCJtaW5cIik6dD09PVwibWF4XCImJihpPVwiLTEuMCAvIDFlLTIwXCIsbz1cIm1heFwiKTtsZXQgbD1gJHt0fSgke3R9KCR7dH0obWluTWF4VmFsdWVbMF0sIG1pbk1heFZhbHVlWzFdKSwgbWluTWF4VmFsdWVbMl0pLCBtaW5NYXhWYWx1ZVszXSlgO3Q9PT1cInN1bVwiP2w9XCJzdW1WYWx1ZVwiOnQ9PT1cInByb2RcIj9sPVwicHJvZFZhbHVlXCI6dD09PVwiYWxsXCI/bD1cImFsbFZhbHVlXCI6dD09PVwiYW55XCImJihsPVwiYW55VmFsdWVcIik7bGV0IHU9TWF0aC5mbG9vcihuLzQpKjQscD1uJTQsZD1gXG4gICAgICBpZiAoJHt0PT09XCJzdW1cIn0pIHtcbiAgICAgICAgc3VtVmFsdWUgKz0gZG90KHZhbHVlcywgb25lcyk7XG4gICAgICB9IGVsc2UgaWYgKCR7dD09PVwicHJvZFwifSkge1xuICAgICAgICB2ZWMyIHRtcCA9IHZlYzIodmFsdWVzWzBdLCB2YWx1ZXNbMV0pICogdmVjMih2YWx1ZXNbMl0sIHZhbHVlc1szXSk7XG4gICAgICAgIHByb2RWYWx1ZSAqPSB0bXBbMF0gKiB0bXBbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5NYXhWYWx1ZSA9ICR7b30odmFsdWVzLCBtaW5NYXhWYWx1ZSk7XG4gICAgICAgIGlmICgke3Q9PT1cIm1pblwifSB8fCAke3Q9PT1cIm1heFwifSkge1xuICAgICAgICAgIG1pbk1heFZhbHVlID0gJHtvfSh2YWx1ZXMsIG1pbk1heFZhbHVlKTtcbiAgICAgICAgICBidmVjNCBpc05hTiA9IGlzbmFuKHZhbHVlcyk7XG4gICAgICAgICAgaWYgKGlzTmFOLnIgfHwgaXNOYU4uZyB8fCBpc05hTi5iIHx8IGlzTmFOLmEpIHtcbiAgICAgICAgICAgIG1pbk1heFZhbHVlID0gdmVjNChOQU4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIGAsYz1cInZlYzRcIjt0PT09XCJhbGxcIj8oaT1cIjEuMFwiLGQ9YFxuICAgICAgICBib29sIHJlZHVjZWRBbGxWYWx1ZSA9IGFsbCh2YWx1ZXMpO1xuICAgICAgICBmbG9hdCBmbG9hdGVkUmVkdWNlZEFsbFZhbHVlID0gZmxvYXQocmVkdWNlZEFsbFZhbHVlKTtcbiAgICAgICAgYWxsVmFsdWUgPSBmbG9hdChhbGxWYWx1ZSA+PSAxLjAgJiYgZmxvYXRlZFJlZHVjZWRBbGxWYWx1ZSA+PSAxLjApO1xuICAgICAgYCxjPVwiYnZlYzRcIik6dD09PVwiYW55XCImJihpPVwiMC4wXCIsZD1gXG4gICAgICAgIGJvb2wgcmVkdWNlZEFueVZhbHVlID0gYW55KHZhbHVlcyk7XG4gICAgICAgIGZsb2F0IGZsb2F0ZWRSZWR1Y2VkQW55VmFsdWUgPSBmbG9hdChyZWR1Y2VkQW55VmFsdWUpO1xuICAgICAgICBhbnlWYWx1ZSA9IGZsb2F0KGFueVZhbHVlID49IDEuMCB8fCBmbG9hdGVkUmVkdWNlZEFueVZhbHVlID49IDEuMCk7XG4gICAgICBgLGM9XCJidmVjNFwiKTtsZXQgaD1cIlwiO3Ilbj4wJiYoaD1gXG4gICAgICAgIGlmIChpbklkeCA8IDAgfHwgaW5JZHggPj0gJHtyfSkge1xuICAgICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblZhbHVlO1xuICAgICAgICB9XG4gICAgICBgKSx0aGlzLnVzZXJDb2RlPWBcbiAgICAgIGNvbnN0IGZsb2F0IGluaXRpYWxpemF0aW9uVmFsdWUgPSAke2l9O1xuICAgICAgY29uc3QgdmVjNCBvbmVzID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAxLjApO1xuXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgYmF0Y2gsIGludCBpbklkeCkge1xuICAgICAgICAke2h9XG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCBpbklkeCk7XG4gICAgICB9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcbiAgICAgICAgaW50IG91dElkeCA9IGNvb3Jkc1sxXTtcbiAgICAgICAgaW50IGluT2Zmc2V0ID0gb3V0SWR4ICogJHtufTtcblxuICAgICAgICB2ZWM0IG1pbk1heFZhbHVlID0gdmVjNCgke2l9KTtcbiAgICAgICAgZmxvYXQgcHJvZFZhbHVlID0gMS4wO1xuICAgICAgICBmbG9hdCBzdW1WYWx1ZSA9IDAuMDtcbiAgICAgICAgZmxvYXQgYWxsVmFsdWUgPSAxLjA7XG4gICAgICAgIGZsb2F0IGFueVZhbHVlID0gMC4wO1xuXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHt1fTsgaSArPSA0KSB7XG4gICAgICAgICAgaW50IGluSWR4ID0gaW5PZmZzZXQgKyBpO1xuICAgICAgICAgICR7Y30gdmFsdWVzID0gJHtjfShcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMylcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgJHtkfVxuICAgICAgICB9XG5cbiAgICAgICAgaW50IGluSWR4ID0gaW5PZmZzZXQgKyAke3V9O1xuICAgICAgICBpZiAoJHtwPT09MX0pIHtcbiAgICAgICAgICAke2N9IHZhbHVlcyA9ICR7Y30oXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgICR7ZH1cbiAgICAgICAgfSBlbHNlIGlmICgke3A9PT0yfSkge1xuICAgICAgICAgICR7Y30gdmFsdWVzID0gJHtjfShcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgICR7ZH1cbiAgICAgICAgfSBlbHNlIGlmICgke3A9PT0zfSkge1xuICAgICAgICAgICR7Y30gdmFsdWVzID0gJHtjfShcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAke2R9XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KCR7bH0pO1xuICAgICAgfVxuICAgIGB9fTtmdW5jdGlvbiBUZWUoZSl7bGV0IHQ9W107Zm9yKDt0Lmxlbmd0aD09PTB8fHRbdC5sZW5ndGgtMV0ub3V0U2l6ZSE9PTE7KXtsZXQgbj10Lmxlbmd0aD90W3QubGVuZ3RoLTFdLm91dFNpemU6ZVsxXSxhPVQuY29tcHV0ZU9wdGltYWxXaW5kb3dTaXplKG4pO3QucHVzaCh7aW5TaXplOm4sd2luZG93U2l6ZTphLG91dFNpemU6TWF0aC5jZWlsKG4vYSl9KX1yZXR1cm4gdH1mdW5jdGlvbiBlbChlLHQsbixhKXtsZXQgcj1UZWUoZS5zaGFwZSkscz1lO2ZvcihsZXQgaT0wO2k8ci5sZW5ndGg7aSsrKXtsZXR7aW5TaXplOm8sd2luZG93U2l6ZTpsLG91dFNpemU6dX09cltpXSxwLGQ7bj09PVwibWVhblwiP3A9aT09PTA/bmV3IGNTKHt3aW5kb3dTaXplOmwsaW5TaXplOm8sYmF0Y2hTaXplOmUuc2hhcGVbMF0sb3V0U2l6ZTp1fSxvKTpuZXcgY1Moe3dpbmRvd1NpemU6bCxpblNpemU6byxiYXRjaFNpemU6ZS5zaGFwZVswXSxvdXRTaXplOnV9KTpwPW5ldyBOZWUoe3dpbmRvd1NpemU6bCxpblNpemU6byxiYXRjaFNpemU6ZS5zaGFwZVswXSxvdXRTaXplOnV9LG4pLGQ9cyxzPWEucnVuV2ViR0xQcm9ncmFtKHAsW3NdLHQpLGQuZGF0YUlkIT09ZS5kYXRhSWQmJmEuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZCl9cmV0dXJuIHN9dmFyIENlZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdO2xldCBuPW5ldyBBcnJheShlLmxlbmd0aCk7Zm9yKGxldCBzPTA7czxuLmxlbmd0aDtzKyspbltzXT1lW3Rbc11dO3RoaXMub3V0cHV0U2hhcGU9bix0aGlzLnJhbms9bi5sZW5ndGg7bGV0IGE9aHQodGhpcy5yYW5rKSxyPUVlZSh0KTt0aGlzLnVzZXJDb2RlPWBcbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAke2F9IHJlc1JDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICBzZXRPdXRwdXQoZ2V0QSgke3J9KSk7XG4gICAgfVxuICAgIGB9fTtmdW5jdGlvbiBFZWUoZSl7bGV0IHQ9ZS5sZW5ndGg7aWYodD42KXRocm93IEVycm9yKGBUcmFuc3Bvc2UgZm9yIHJhbmsgJHt0fSBpcyBub3QgeWV0IHN1cHBvcnRlZGApO2xldCBuPVtcInJlc1JDLnhcIixcInJlc1JDLnlcIixcInJlc1JDLnpcIixcInJlc1JDLndcIixcInJlc1JDLnVcIixcInJlc1JDLnZcIl0sYT1uZXcgQXJyYXkodCk7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspYVtlW3JdXT1uW3JdO3JldHVybiBhLmpvaW4oKX12YXIgX2VlPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITA7bGV0IG49bmV3IEFycmF5KGUubGVuZ3RoKTtmb3IobGV0IHU9MDt1PG4ubGVuZ3RoO3UrKyluW3VdPWVbdFt1XV07aWYodGhpcy5vdXRwdXRTaGFwZT1uLHRoaXMucmFuaz1uLmxlbmd0aCx0aGlzLnJhbms+Nil0aHJvdyBFcnJvcihgUGFja2VkIHRyYW5zcG9zZSBmb3IgcmFuayAke3RoaXMucmFua30gaXMgbm90IHlldCBzdXBwb3J0ZWQuYCk7bGV0IGE9aHQodGhpcy5yYW5rKSxyPV9BKFwicmNcIix0aGlzLnJhbmspLHM9bmV3IEFycmF5KHRoaXMucmFuayk7Zm9yKGxldCB1PTA7dTx0Lmxlbmd0aDt1Kyspc1t0W3VdXT1yW3VdO2xldCBpPWB2ZWMyKCR7cy5zbGljZSgtMikuam9pbigpfSlgLG89YCsrJHtyW3RoaXMucmFuay0xXX0gPCAke25bdGhpcy5yYW5rLTFdfWAsbD1gZ2V0Q2hhbm5lbChnZXRBKCR7cy5qb2luKCl9KSwgJHtpfSlgO3RoaXMudXNlckNvZGU9YFxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICR7YX0gcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XG4gICAgICByZXN1bHRbMF0gPSAke2x9O1xuICAgICAgaWYoJHtvfSkge1xuICAgICAgICByZXN1bHRbMV0gPSAke2x9O1xuICAgICAgfVxuICAgICAgLS0ke3JbdGhpcy5yYW5rLTFdfTtcbiAgICAgIGlmKCsrJHtyW3RoaXMucmFuay0yXX0gPCAke25bdGhpcy5yYW5rLTJdfSkge1xuICAgICAgICByZXN1bHRbMl0gPSAke2x9O1xuICAgICAgICBpZigke299KSB7XG4gICAgICAgICAgcmVzdWx0WzNdID0gJHtsfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XG4gICAgfVxuICAgIGB9fTtmdW5jdGlvbiBCZihlLHQsbil7bGV0IGE9RygpLmdldEJvb2woXCJXRUJHTF9QQUNLX0FSUkFZX09QRVJBVElPTlNcIik/bmV3IF9lZShlLnNoYXBlLHQpOm5ldyBDZWUoZS5zaGFwZSx0KTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0oYSxbZV0sZS5kdHlwZSl9ZnVuY3Rpb24gQWVlKGUsdCxuLGEpe2xldCByPXQscz1lLnNoYXBlLmxlbmd0aCxpPXcucGFyc2VBeGlzUGFyYW0ocixlLnNoYXBlKSxvPWksbD1ULmdldEF4ZXNQZXJtdXRhdGlvbihvLHMpLHU9bCE9bnVsbCxwPWU7dSYmKHA9QmYoZSxsLGEpLG89VC5nZXRJbm5lck1vc3RBeGVzKG8ubGVuZ3RoLHMpKSxULmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwic3VtXCIsbyxzKTtsZXRbZCxjXT1ULmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMocC5zaGFwZSxvKSxoPWQ7biYmKGg9VC5leHBhbmRTaGFwZVRvS2VlcERpbShkLGkpKTtsZXQgbT13LnNpemVGcm9tU2hhcGUoYyksZj13LnNpemVGcm9tU2hhcGUoZS5zaGFwZSkvbSxnPWNlKHtpbnB1dHM6e3g6cH0sYXR0cnM6e3NoYXBlOltmLG1dfSxiYWNrZW5kOmF9KSxiPU1tKGUuZHR5cGUpLHk9ZWwoZyxiLFwic3VtXCIsYSkseD1jZSh7aW5wdXRzOnt4Onl9LGF0dHJzOntzaGFwZTpofSxiYWNrZW5kOmF9KTtyZXR1cm4gYS5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhnKSxhLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHkpLHUmJmEuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocCkseH1mdW5jdGlvbiBWZihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7YXhpczpzLGtlZXBEaW1zOml9PWE7cmV0dXJuIEFlZShyLHMsaSxuKX12YXIgRmVlPXtrZXJuZWxOYW1lOkxvLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlZmfTtmdW5jdGlvbiBTbihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7cGVybTpzfT1hLGk9bixvPXIuc2hhcGUubGVuZ3RoLGw9bmV3IEFycmF5KG8pO2ZvcihsZXQgcD0wO3A8bC5sZW5ndGg7cCsrKWxbcF09ci5zaGFwZVtzW3BdXTtsZXQgdTtpZihpLnNob3VsZEV4ZWN1dGVPbkNQVShbcl0pKXtsZXQgcD1pLnRleERhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsZD1vayhwLHIuc2hhcGUsci5kdHlwZSxzLGwpO3U9aS5tYWtlVGVuc29ySW5mbyhsLHIuZHR5cGUpO2xldCBjPWkudGV4RGF0YS5nZXQodS5kYXRhSWQpO2MudmFsdWVzPWR9ZWxzZSB1PUJmKHIscyxpKTtyZXR1cm4gdX12YXIgJGVlPXtrZXJuZWxOYW1lOkNyLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlNufSxMQT0xZTM7ZnVuY3Rpb24gaG0oe2E6ZSxiOnQsdHJhbnNwb3NlQTpuLHRyYW5zcG9zZUI6YSxiYWNrZW5kOnIsYmlhczpzPW51bGwscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czppPW51bGwsbGVha3lyZWx1QWxwaGE6bz0wLGFjdGl2YXRpb246bD1udWxsfSl7bGV0IHU9ZS5zaGFwZS5sZW5ndGgscD10LnNoYXBlLmxlbmd0aCxkPW4/ZS5zaGFwZVt1LTJdOmUuc2hhcGVbdS0xXSxjPWE/dC5zaGFwZVtwLTFdOnQuc2hhcGVbcC0yXSxoPW4/ZS5zaGFwZVt1LTFdOmUuc2hhcGVbdS0yXSxtPWE/dC5zaGFwZVtwLTJdOnQuc2hhcGVbcC0xXSxmPWUuc2hhcGUuc2xpY2UoMCwtMiksZz10LnNoYXBlLnNsaWNlKDAsLTIpLGI9dy5zaXplRnJvbVNoYXBlKGYpLHk9dy5zaXplRnJvbVNoYXBlKGcpLHg9SnUuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoZS5zaGFwZS5zbGljZSgwLC0yKSx0LnNoYXBlLnNsaWNlKDAsLTIpKS5jb25jYXQoW2gsbV0pO3cuYXNzZXJ0KGQ9PT1jLCgpPT5gRXJyb3IgaW4gbWF0TXVsOiBpbm5lciBzaGFwZXMgKCR7ZH0pIGFuZCAoJHtjfSkgb2YgVGVuc29ycyB3aXRoIHNoYXBlcyAke2Uuc2hhcGV9IGFuZCAke3Quc2hhcGV9IGFuZCB0cmFuc3Bvc2VBPSR7bn0gYW5kIHRyYW5zcG9zZUI9JHthfSBtdXN0IG1hdGNoLmApO2xldCB2PW4/W2IsZCxoXTpbYixoLGRdLEk9YT9beSxtLGNdOlt5LGMsbV0sTj1jZSh7aW5wdXRzOnt4OmV9LGJhY2tlbmQ6cixhdHRyczp7c2hhcGU6dn19KSxDPWNlKHtpbnB1dHM6e3g6dH0sYmFja2VuZDpyLGF0dHJzOntzaGFwZTpJfX0pLF89W04sQ10sRj1NYXRoLm1heChiLHkpLEQ9bj9OLnNoYXBlWzFdOk4uc2hhcGVbMl0sJD1zIT1udWxsLFM9aSE9bnVsbCxNPWw9PT1cImxlYWt5cmVsdVwiLEI9bCE9bnVsbD9DYyhsLCEwKTpudWxsLFU9JHx8U3x8TXx8QiE9bnVsbCxIO2lmKChoPT09MXx8bT09PTEpJiZEPkxBJiZVPT09ITEpe2xldCBLPU4sWj1DO24mJihLPVNuKHtpbnB1dHM6e3g6Tn0sYmFja2VuZDpyLGF0dHJzOntwZXJtOlswLDIsMV19fSksXy5wdXNoKEspKSxhJiYoWj1Tbih7aW5wdXRzOnt4OkN9LGJhY2tlbmQ6cixhdHRyczp7cGVybTpbMCwyLDFdfX0pLF8ucHVzaChaKSk7bGV0IEo9bSE9PTEsZWU9bT09PTEsYWU9SztKJiYoYWU9Y2Uoe2lucHV0czp7eDpLfSxiYWNrZW5kOnIsYXR0cnM6e3NoYXBlOltGLEQsMV19fSksXy5wdXNoKGFlKSk7bGV0IHRlPW09PT0xPzI6MSxzZT1aO2VlJiYoc2U9Y2Uoe2lucHV0czp7eDpafSxiYWNrZW5kOnIsYXR0cnM6e3NoYXBlOltGLDEsRF19fSksXy5wdXNoKHNlKSk7bGV0IGllPXBrKHtpbnB1dHM6e2E6YWUsYjpzZX0sYmFja2VuZDpyfSk7SD1WZih7aW5wdXRzOnt4OmllfSxiYWNrZW5kOnIsYXR0cnM6e2F4aXM6dGUsa2VlcERpbXM6ITB9fSksXy5wdXNoKGllKX1lbHNle2xldCBLPWZhKGUuZHR5cGUsdC5kdHlwZSksWj1uZXcgUEEodixJLFtGLGgsbV0sbixhLCQsQixTLE0pLEo9W04sQ107aWYocyE9bnVsbCYmSi5wdXNoKHMpLFMmJkoucHVzaChpKSxNKXtsZXQgZWU9ci5tYWtlVGVuc29ySW5mbyhbXSxcImZsb2F0MzJcIix3LmNyZWF0ZVNjYWxhclZhbHVlKG8sXCJmbG9hdDMyXCIpKTtKLnB1c2goZWUpLF8ucHVzaChlZSl9SD1yLnJ1bldlYkdMUHJvZ3JhbShaLEosSyl9bGV0IHE9Y2Uoe2lucHV0czp7eDpIfSxiYWNrZW5kOnIsYXR0cnM6e3NoYXBlOnh9fSk7Xy5wdXNoKEgpO2ZvcihsZXQgSyBvZiBfKXIuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oSyk7cmV0dXJuIHF9ZnVuY3Rpb24gRGVlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7YTpyLGI6cyxiaWFzOmkscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czpvfT10LHt0cmFuc3Bvc2VBOmwsdHJhbnNwb3NlQjp1LGFjdGl2YXRpb246cCxsZWFreXJlbHVBbHBoYTpkfT1hO3JldHVybiBobSh7YTpyLGI6cyx0cmFuc3Bvc2VBOmwsdHJhbnNwb3NlQjp1LGJhY2tlbmQ6bixiaWFzOmkscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czpvLGxlYWt5cmVsdUFscGhhOmQsYWN0aXZhdGlvbjpwfSl9dmFyIFJlZT17a2VybmVsTmFtZTppaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpEZWV9LGRTPVwicmV0dXJuIGFicyh4KTtcIjtmdW5jdGlvbiBNZWUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7eDphfT10O2lmKG4uc2hvdWxkRXhlY3V0ZU9uQ1BVKFthXSkmJmEuZHR5cGUhPT1cImNvbXBsZXg2NFwiKXtsZXQgcz1uLnRleERhdGEuZ2V0KGEuZGF0YUlkKSxpPUNBKHMudmFsdWVzKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhhLnNoYXBlLGEuZHR5cGUsaSl9bGV0IHI7cmV0dXJuIEcoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19VTkFSWV9PUEVSQVRJT05TXCIpP3I9bmV3IHRzKGEuc2hhcGUsZFMpOnI9bmV3IHJyKGEuc2hhcGUsZFMpLG4ucnVuV2ViR0xQcm9ncmFtKHIsW2FdLGEuZHR5cGUpfXZhciBPZWU9e2tlcm5lbE5hbWU6WWwsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6TWVlfSxQZWU9RGErYFxuICBpZiAoYWJzKHgpID4gMS4pIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIHJldHVybiBhY29zKHgpO1xuYCxMZWU9WmUoe29wU25pcHBldDpQZWV9KSx6ZWU9e2tlcm5lbE5hbWU6TmksYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6TGVlfSxXZWU9RGErYFxuICBpZiAoeCA8IDEuMCkgcmV0dXJuIE5BTjtcbnJldHVybiBsb2coeCArIHNxcnQoeCAqIHggLSAxLjApKTtgLEJlZT1aZSh7b3BTbmlwcGV0OldlZX0pLFZlZT17a2VybmVsTmFtZTpUaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpCZWV9LGhTPVwicmV0dXJuIGEgKyBiO1wiLFVlZT1obih7b3BTbmlwcGV0OmhTLHBhY2tlZE9wU25pcHBldDpoUyxzdXBwb3J0c0NvbXBsZXg6ITAsY3B1S2VybmVsSW1wbDpaOX0pLEdlZT17a2VybmVsTmFtZTp2cyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpVZWV9LEhlZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQpe3RoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT1lLHRoaXMudmFyaWFibGVOYW1lcz10Lm1hcCgocixzKT0+YFQke3N9YCk7bGV0IG49W107dGhpcy52YXJpYWJsZU5hbWVzLmZvckVhY2gocj0+e24ucHVzaChgZmxvYXQgdiR7cn0gPSBnZXQke3J9QXRPdXRDb29yZHMoKTtgKX0pO2xldCBhPXRoaXMudmFyaWFibGVOYW1lcy5tYXAocj0+YHYke3J9YCkuam9pbihcIiArIFwiKTt0aGlzLnVzZXJDb2RlPWBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgJHtuLmpvaW4oYFxuICAgICAgICBgKX1cblxuICAgICAgICBmbG9hdCByZXN1bHQgPSAke2F9O1xuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcbiAgICAgIH1cbiAgICBgfX0samVlPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dHB1dFNoYXBlPWUsdGhpcy52YXJpYWJsZU5hbWVzPXQubWFwKChyLHMpPT5gVCR7c31gKTtsZXQgbj1bXTt0aGlzLnZhcmlhYmxlTmFtZXMuZm9yRWFjaChyPT57bi5wdXNoKGB2ZWM0IHYke3J9ID0gZ2V0JHtyfUF0T3V0Q29vcmRzKCk7YCl9KTtsZXQgYT10aGlzLnZhcmlhYmxlTmFtZXMubWFwKHI9PmB2JHtyfWApLmpvaW4oXCIgKyBcIik7dGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICR7bi5qb2luKGBcbiAgICAgICAgYCl9XG5cbiAgICAgICAgdmVjNCByZXN1bHQgPSAke2F9O1xuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24gQmgoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSxhPXQ7aWYoYS5sZW5ndGg9PT0xKXJldHVybiB0YSh7aW5wdXRzOnt4OmFbMF19LGJhY2tlbmQ6bn0pO2lmKGEubGVuZ3RoPkcoKS5nZXROdW1iZXIoXCJXRUJHTF9NQVhfVEVYVFVSRVNfSU5fU0hBREVSXCIpKXtsZXQgbz1NYXRoLmZsb29yKGEubGVuZ3RoLzIpLGw9Qmgoe2lucHV0czphLnNsaWNlKDAsbyksYmFja2VuZDpufSksdT1CaCh7aW5wdXRzOmEuc2xpY2UobyksYmFja2VuZDpufSk7cmV0dXJuIEJoKHtpbnB1dHM6W2wsdV0sYmFja2VuZDpufSl9bGV0IHI9YS5tYXAobz0+by5kdHlwZSkucmVkdWNlKChvLGwpPT5mYShvLGwpKSxzPWEubWFwKG89Pm8uc2hhcGUpLGk9RygpLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpP25ldyBqZWUoYVswXS5zaGFwZSxzKTpuZXcgSGVlKGFbMF0uc2hhcGUscyk7cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKGksYSxyKX12YXIgcWVlPXtrZXJuZWxOYW1lOkNpLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkJofTtmdW5jdGlvbiBLZWUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2F4aXM6cyxrZWVwRGltczppfT1hLG89ci5zaGFwZS5sZW5ndGgsbD13LnBhcnNlQXhpc1BhcmFtKHMsci5zaGFwZSksdT1sLHA9VC5nZXRBeGVzUGVybXV0YXRpb24odSxvKSxkPXI7cCE9bnVsbCYmKGQ9U24oe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3Blcm06cH19KSx1PVQuZ2V0SW5uZXJNb3N0QXhlcyh1Lmxlbmd0aCxvKSksVC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcImFsbFwiLHUsbyk7bGV0W2MsaF09VC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGQuc2hhcGUsdSksbT13LnNpemVGcm9tU2hhcGUoaCksZj1jZSh7aW5wdXRzOnt4OmR9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6Wy0xLG1dfX0pLGc9ZWwoZixmLmR0eXBlLFwiYWxsXCIsbiksYjtpZihpKXtsZXQgeT1ULmV4cGFuZFNoYXBlVG9LZWVwRGltKGMsbCk7Yj1jZSh7aW5wdXRzOnt4Omd9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6eX19KX1lbHNlIGI9Y2Uoe2lucHV0czp7eDpnfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOmN9fSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZiksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhnKSxwIT1udWxsJiZuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGQpLGJ9dmFyIFhlZT17a2VybmVsTmFtZTpabCxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpLZWV9O2Z1bmN0aW9uIFllZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7YXhpczpzLGtlZXBEaW1zOml9PWEsbz1yLnNoYXBlLmxlbmd0aCxsPXcucGFyc2VBeGlzUGFyYW0ocyxyLnNoYXBlKSx1PWwscD1ULmdldEF4ZXNQZXJtdXRhdGlvbih1LG8pLGQ9cjtwIT1udWxsJiYoZD1Tbih7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bixhdHRyczp7cGVybTpwfX0pLHU9VC5nZXRJbm5lck1vc3RBeGVzKHUubGVuZ3RoLG8pKSxULmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwiYW55XCIsdSxvKTtsZXRbYyxoXT1ULmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoZC5zaGFwZSx1KSxtPXcuc2l6ZUZyb21TaGFwZShoKSxmPWNlKHtpbnB1dHM6e3g6ZH0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpbLTEsbV19fSksZz1lbChmLGYuZHR5cGUsXCJhbnlcIixuKSxiO2lmKGkpe2xldCB5PVQuZXhwYW5kU2hhcGVUb0tlZXBEaW0oYyxsKTtiPWNlKHtpbnB1dHM6e3g6Z30sYmFja2VuZDpuLGF0dHJzOntzaGFwZTp5fX0pfWVsc2UgYj1jZSh7aW5wdXRzOnt4Omd9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6Y319KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhmKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGcpLHAhPW51bGwmJm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZCksYn12YXIgWmVlPXtrZXJuZWxOYW1lOkpsLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlllZX0sSmVlPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXTtsZXR7d2luZG93U2l6ZTphLGJhdGNoU2l6ZTpyLG91dFNpemU6c309ZTtufHx0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcImJlc3RJbmRpY2VzQVwiKSx0aGlzLm91dHB1dFNoYXBlPVtyLHNdO2xldCBpPXQ9PT1cIm1heFwiP1wiPlwiOlwiPFwiLG89bj9cImluT2Zmc2V0ICsgaTtcIjpcInJvdW5kKGdldEJlc3RJbmRpY2VzQShiYXRjaCwgaW5PZmZzZXQgKyBpKSk7XCI7dGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XG4gICAgICAgIGludCBvdXRJZHggPSBjb29yZHNbMV07XG4gICAgICAgIGludCBpbk9mZnNldCA9IG91dElkeCAqICR7YX07XG5cbiAgICAgICAgaW50IGJlc3RJbmRleCA9IGluT2Zmc2V0O1xuICAgICAgICBmbG9hdCBiZXN0VmFsdWUgPSBnZXRBKGJhdGNoLCBiZXN0SW5kZXgpO1xuXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHthfTsgaSsrKSB7XG4gICAgICAgICAgaW50IGluSWR4ID0gJHtvfTtcbiAgICAgICAgICBmbG9hdCBjYW5kaWRhdGUgPSBnZXRBKGJhdGNoLCBpbklkeCk7XG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZSAke2l9IGJlc3RWYWx1ZSkge1xuICAgICAgICAgICAgYmVzdFZhbHVlID0gY2FuZGlkYXRlO1xuICAgICAgICAgICAgYmVzdEluZGV4ID0gaW5JZHg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dChmbG9hdChiZXN0SW5kZXgpKTtcbiAgICAgIH1cbiAgICBgfX0sUWVlPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuLGEpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHcuYXNzZXJ0KGUubGVuZ3RoPjIsKCk9PmBQYWNrZWQgYXJnJHtuLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSl9IHN1cHBvcnRzIG9ubHkgaW5wdXRzIHdpdGggcmFuayBhYm92ZSAyLmApO2xldCByPWVbZS5sZW5ndGgtMV0scz1NYXRoLmNlaWwoci90KTt0aGlzLm91dHB1dFNoYXBlPWUuc2xpY2UoMCwtMSkscz4xJiZ0aGlzLm91dHB1dFNoYXBlLnB1c2gocyksYXx8dGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJiZXN0SW5kaWNlc0FcIik7bGV0IGk9dGhpcy5vdXRwdXRTaGFwZSxvPWkubGVuZ3RoLGw9aHQobyksdT1JbihcImNvb3Jkc1wiLG8pLHAsZDtpZihzPT09MSl7ZD1vKzE7bGV0IEM9aHQoZCk7cD1gXG4gICAgICAgICR7Q30gc291cmNlTG9jUiA9ICR7Q30oJHt1LmpvaW4oKX0sIDApO1xuICAgICAgICArKyR7dVtvLTFdfTtcbiAgICAgICAgJHtDfSBzb3VyY2VMb2NHID0gJHtDfSgke3Uuam9pbigpfSwgMCk7XG4gICAgICAgICsrJHt1W28tMl19O1xuICAgICAgICAke0N9IHNvdXJjZUxvY0EgPSAke0N9KCR7dS5qb2luKCl9LCAwKTtcbiAgICAgICAgLS0ke3Vbby0xXX07XG4gICAgICAgICR7Q30gc291cmNlTG9jQiA9ICR7Q30oJHt1LmpvaW4oKX0sIDApO1xuICAgICAgICAtLSR7dVtvLTJdfTtgfWVsc2UgZD1vLHA9YFxuICAgICAgICAke2x9IHNvdXJjZUxvY1IgPSBjb29yZHM7XG4gICAgICAgICsrJHt1W28tMV19O1xuICAgICAgICAke2x9IHNvdXJjZUxvY0cgPSBjb29yZHM7XG4gICAgICAgICsrJHt1W28tMl19O1xuICAgICAgICAke2x9IHNvdXJjZUxvY0EgPSBjb29yZHM7XG4gICAgICAgIC0tJHt1W28tMV19O1xuICAgICAgICAke2x9IHNvdXJjZUxvY0IgPSBjb29yZHM7XG4gICAgICAgIC0tJHt1W28tMl19O2A7bGV0IGM9W1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXS5zbGljZSgwLGQpLGg9XCIuXCIrY1tkLTFdLG09Yy5tYXAoQz0+XCJpbnQgXCIrQyksZj1JbihcInNvdXJjZUxvY1JcIixkLTEpLmNvbmNhdChcImluSWR4LnJcIiksZz1JbihcInNvdXJjZUxvY0dcIixkLTEpLmNvbmNhdChcImluSWR4LmdcIiksYj1JbihcInNvdXJjZUxvY0JcIixkLTEpLmNvbmNhdChcImluSWR4LmJcIikseT1JbihcInNvdXJjZUxvY0FcIixkLTEpLmNvbmNhdChcImluSWR4LmFcIikseD1uPT09XCJtYXhcIj9cImdyZWF0ZXJUaGFuXCI6XCJsZXNzVGhhblwiLHY9YT9cIlwiOmBcbiAgICAgICAgICBpbklkeCA9IHJvdW5kKHZlYzQoZ2V0QmVzdEluZGljZXNBQ2hhbm5lbCgke2Yuam9pbigpfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEJlc3RJbmRpY2VzQUNoYW5uZWwoJHtnLmpvaW4oKX0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRCZXN0SW5kaWNlc0FDaGFubmVsKCR7Yi5qb2luKCl9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QmVzdEluZGljZXNBQ2hhbm5lbCgke3kuam9pbigpfSkpKTtgLEk9YHZlYzQoXG4gICAgICAgICAgICBnZXRBQ2hhbm5lbCgke2Yuam9pbigpfSksXG4gICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QUNoYW5uZWwoJHtnLmpvaW4oKX0pIDogMC4sXG4gICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QUNoYW5uZWwoJHtiLmpvaW4oKX0pIDogMC4sXG4gICAgICAgICAgICBoYXNOZXh0Um93ICYmIGhhc05leHRDb2wgPyBnZXRBQ2hhbm5lbCgke3kuam9pbigpfSkgOiAwLilgLE49YT9cIlwiOmBcbiAgICAgIGZsb2F0IGdldEJlc3RJbmRpY2VzQUNoYW5uZWwoJHttLmpvaW4oKX0pIHtcbiAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoZ2V0QmVzdEluZGljZXNBKCR7Yy5qb2luKCl9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtjLnNsaWNlKC0yKS5qb2luKCl9KSk7XG4gICAgICB9YDt0aGlzLnVzZXJDb2RlPWBcbiAgICAgIGZsb2F0IGdldEFDaGFubmVsKCR7bS5qb2luKCl9KSB7XG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKGdldEEoJHtjLmpvaW4oKX0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtjLnNsaWNlKC0yKS5qb2luKCl9KSk7XG4gICAgICB9XG4gICAgICAke059XG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICR7bH0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGJvb2wgaGFzTmV4dENvbCA9ICR7dVtvLTFdfSA8ICR7aVtvLTFdLTF9O1xuICAgICAgICBib29sIGhhc05leHRSb3cgPSAke3Vbby0yXX0gPCAke2lbby0yXS0xfTtcbiAgICAgICAgJHtwfVxuICAgICAgICBpdmVjNCBzcmNJZHggPSBpdmVjNChzb3VyY2VMb2NSJHtofSwgc291cmNlTG9jRyR7aH0sXG4gICAgICAgICAgc291cmNlTG9jQiR7aH0sIHNvdXJjZUxvY0Eke2h9KSAqICR7dH07XG4gICAgICAgIGl2ZWM0IGluSWR4ID0gc3JjSWR4O1xuICAgICAgICB2ZWM0IGJlc3RJbmRleCA9IHZlYzQoaW5JZHgpO1xuICAgICAgICB2ZWM0IGJlc3RWYWx1ZSA9ICR7SX07XG5cbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke3R9OyBpKyspIHtcbiAgICAgICAgICBpbklkeCA9IHNyY0lkeDtcbiAgICAgICAgICAke3Z9XG4gICAgICAgICAgdmVjNCBjYW5kaWRhdGUgPSAke0l9O1xuICAgICAgICAgIGJ2ZWM0IG5hbiA9IGlzbmFuKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgYnZlYzQgcmVwbGFjZSA9IGJ2ZWM0KFxuICAgICAgICAgICAgdmVjNCgke3h9KGNhbmRpZGF0ZSwgYmVzdFZhbHVlKSkgKiAodmVjNCgxLjApIC0gdmVjNChuYW4pKSk7XG5cbiAgICAgICAgICBiZXN0VmFsdWUgPSB2ZWM0KHJlcGxhY2UueCAgPyBjYW5kaWRhdGUueCA6IGJlc3RWYWx1ZS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZS55ICA/IGNhbmRpZGF0ZS55IDogYmVzdFZhbHVlLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlLnogID8gY2FuZGlkYXRlLnogOiBiZXN0VmFsdWUueixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2UudyAgPyBjYW5kaWRhdGUudyA6IGJlc3RWYWx1ZS53KTtcbiAgICAgICAgICBiZXN0SW5kZXggPSBtaXgoYmVzdEluZGV4LCB2ZWM0KGluSWR4KSwgdmVjNChyZXBsYWNlKSk7XG4gICAgICAgICAgc3JjSWR4Kys7XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KGJlc3RJbmRleCk7XG4gICAgICB9XG4gICAgYH19O2Z1bmN0aW9uIHpBKGUsdCxuLGE9bnVsbCl7bGV0IHI9dC5zaGFwZVswXSxzPXQuc2hhcGVbMV07YSE9bnVsbCYmKHI9YS5zaGFwZVswXSxzPWEuc2hhcGVbMV0pO2xldCBpPVQuY29tcHV0ZU9wdGltYWxXaW5kb3dTaXplKHMpLG89e3dpbmRvd1NpemU6aSxpblNpemU6cyxiYXRjaFNpemU6cixvdXRTaXplOk1hdGguY2VpbChzL2kpfSxsPW5ldyBKZWUobyxuLGE9PW51bGwpLHU9W3RdO2EhPW51bGwmJnUucHVzaChhKTtsZXQgcD1lLnJ1bldlYkdMUHJvZ3JhbShsLHUsXCJpbnQzMlwiKTtpZihwLnNoYXBlWzFdPT09MSlyZXR1cm4gcDtsZXQgZD16QShlLHQsbixwKTtyZXR1cm4gZS5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhwKSxkfWZ1bmN0aW9uIFdBKGUsdCxuLGE9bnVsbCl7bGV0IHI9YSE9bnVsbD9hLnNoYXBlOnQuc2hhcGUscz1yW3IubGVuZ3RoLTFdLGk9VC5jb21wdXRlT3B0aW1hbFdpbmRvd1NpemUocyksbz1uZXcgUWVlKHIsaSxuLGE9PW51bGwpLGw9YT09bnVsbD9bdF06W3QsYV0sdT1lLnJ1bldlYkdMUHJvZ3JhbShvLGwsXCJpbnQzMlwiKTtpZih1LnNoYXBlLmxlbmd0aD09PXQuc2hhcGUubGVuZ3RoKXtsZXQgcD1XQShlLHQsbix1KTtyZXR1cm4gZS5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh1KSxwfXJldHVybiB1fWZ1bmN0aW9uIEJBKGUsdCxuLGEpe2xldCByPVtuXTtpZihULmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwiYXJnXCIrYS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSthLnNsaWNlKDEpLHIsdC5zaGFwZS5sZW5ndGgpLCFHKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfUkVEVUNFXCIpfHx0LnNoYXBlLmxlbmd0aDw9Mil7bGV0IHM9W10saT1lLnRleERhdGEuZ2V0KHQuZGF0YUlkKSxvPWkhPT1udWxsJiZpLmlzUGFja2VkLGw9dDtvJiYobD1lLnVucGFja1RlbnNvcih0KSxzLnB1c2gobCkpO2xldFt1LHBdPVQuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhsLnNoYXBlLHIpLGQ9dy5zaXplRnJvbVNoYXBlKHApLGM9Y2Uoe2lucHV0czp7eDpsfSxiYWNrZW5kOmUsYXR0cnM6e3NoYXBlOlstMSxkXX19KTtzLnB1c2goYyk7bGV0IGg9ekEoZSxjLGEpO3MucHVzaChoKTtsZXQgbT1jZSh7aW5wdXRzOnt4Omh9LGJhY2tlbmQ6ZSxhdHRyczp7c2hhcGU6dX19KTtyZXR1cm4gcy5mb3JFYWNoKGY9PmUuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZikpLG19cmV0dXJuIFdBKGUsdCxhKX1mdW5jdGlvbiBldGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2F4aXM6c309YSxpPXcucGFyc2VBeGlzUGFyYW0ocyxyLnNoYXBlKSxvPVQuZ2V0QXhlc1Blcm11dGF0aW9uKGksci5zaGFwZS5sZW5ndGgpLGw9cix1PVtdO28hPW51bGwmJihsPVNuKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntwZXJtOm99fSksdS5wdXNoKGwpLGk9VC5nZXRJbm5lck1vc3RBeGVzKGkubGVuZ3RoLGwuc2hhcGUubGVuZ3RoKSksVC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcImFyZ01heFwiLFtpWzBdXSxsLnNoYXBlLmxlbmd0aCk7bGV0IHA9QkEobixsLGlbMF0sXCJtYXhcIik7cmV0dXJuIHUuZm9yRWFjaChkPT5uLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGQpKSxwfXZhciB0dGU9e2tlcm5lbE5hbWU6UWwsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6ZXRlfTtmdW5jdGlvbiBudGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2F4aXM6c309YSxpPXcucGFyc2VBeGlzUGFyYW0ocyxyLnNoYXBlKSxvPVQuZ2V0QXhlc1Blcm11dGF0aW9uKGksci5zaGFwZS5sZW5ndGgpLGw9cix1PVtdO28hPW51bGwmJihsPVNuKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntwZXJtOm99fSksdS5wdXNoKGwpLGk9VC5nZXRJbm5lck1vc3RBeGVzKGkubGVuZ3RoLGwuc2hhcGUubGVuZ3RoKSksVC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcImFyZ01pblwiLFtpWzBdXSxsLnNoYXBlLmxlbmd0aCk7bGV0IHA9QkEobixsLGlbMF0sXCJtaW5cIik7cmV0dXJuIHUuZm9yRWFjaChkPT5uLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGQpKSxwfXZhciBhdGU9e2tlcm5lbE5hbWU6ZXUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6bnRlfSxydGU9RGErYFxuICBpZiAoYWJzKHgpID4gMS4pIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIHJldHVybiBhc2luKHgpO1xuYCxzdGU9WmUoe29wU25pcHBldDpydGV9KSxpdGU9e2tlcm5lbE5hbWU6RWksYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6c3RlfSxvdGU9RGErXCJyZXR1cm4gbG9nKHggKyBzcXJ0KHggKiB4ICsgMS4wKSk7XCIsbHRlPVplKHtvcFNuaXBwZXQ6b3RlfSksdXRlPXtrZXJuZWxOYW1lOl9pLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmx0ZX0scHRlPURhK2BcbiAgcmV0dXJuIGF0YW4oeCk7XG5gLGN0ZT1aZSh7b3BTbmlwcGV0OnB0ZX0pLGR0ZT17a2VybmVsTmFtZTpBaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpjdGV9LGh0ZT11aytgXG4gIHJldHVybiBhdGFuKGEsIGIpO1xuYCxtdGU9YFxuICB2ZWM0IHJlc3VsdCA9IGF0YW4oYSwgYik7XG4gIGJ2ZWM0IGlzTmFOQSA9IGlzbmFuKGEpO1xuICBidmVjNCBpc05hTkIgPSBpc25hbihiKTtcbiAgYnZlYzQgaXNOYU4gPSBidmVjNChpc05hTkEueCB8fCBpc05hTkIueCwgaXNOYU5BLnkgfHwgaXNOYU5CLnksIGlzTmFOQS56IHx8IGlzTmFOQi56LCBpc05hTkEudyB8fCBpc05hTkIudyk7XG4gIGArUW8rYFxuICByZXR1cm4gcmVzdWx0O1xuYCxmdGU9aG4oe29wU25pcHBldDpodGUscGFja2VkT3BTbmlwcGV0Om10ZX0pLGd0ZT17a2VybmVsTmFtZTokaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpmdGV9LGJ0ZT1EYStgXG4gIGlmICgoeCA8IC0xLjApIHx8ICh4ID4gMS4wKSkgcmV0dXJuIE5BTjtcbnJldHVybiAobG9nKDEuMCArIHgpIC0gbG9nKDEuMCAtIHgpKSAvIDIuMDtgLHl0ZT1aZSh7b3BTbmlwcGV0OmJ0ZX0pLHh0ZT17a2VybmVsTmFtZTpGaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzp5dGV9LEVjPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuLGE9ITEscj0hMSl7aWYodGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdD09PVwiYXZnXCImJm4pdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgcG9zaXRpb25zIGZvciBhdmVyYWdlIHBvb2wuXCIpO2xldCBzPWUuZmlsdGVyV2lkdGgsaT1lLnN0cmlkZUhlaWdodCxvPWUuc3RyaWRlV2lkdGgsbD1lLmRpbGF0aW9uSGVpZ2h0LHU9ZS5kaWxhdGlvbldpZHRoLHA9ZS5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsZD1lLmVmZmVjdGl2ZUZpbHRlcldpZHRoLGM9ZS5wYWRJbmZvLnRvcCxoPWUucGFkSW5mby5sZWZ0O3RoaXMub3V0cHV0U2hhcGU9ZS5vdXRTaGFwZTtsZXQgbT10PT09XCJhdmdcIixmPWAoKGJhdGNoICAqICR7ZS5pbkhlaWdodH0gKyB4UikgKiAke2UuaW5XaWR0aH0gKyB4QykgKiAke2UuaW5DaGFubmVsc30gKyBkYCxnPWAoeFIgKiAke2UuaW5XaWR0aH0gKyB4QykgKiAke2UuaW5DaGFubmVsc30gKyBkYCxiPVwiMC4wXCI7aWYobXx8KGI9XCItMS4wIC8gMWUtMjBcIiksbil7bGV0IEM9XCI+PVwiO3RoaXMudXNlckNvZGU9YFxuICAgICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoJHtpfSwgJHtvfSk7XG4gICAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke2N9LCAke2h9KTtcblxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xuICAgICAgICAgIGludCBkID0gY29vcmRzWzNdO1xuXG4gICAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XG4gICAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XG4gICAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XG5cbiAgICAgICAgICAvLyBtYXgvbWluIHgoPywgPywgZCkgdG8gZ2V0IHkoeVIsIHlDLCBkKS5cbiAgICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlID0gMC4wO1xuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlRm91bmQgPSAwLjA7XG4gICAgICAgICAgaW50IG1pbk1heFBvc2l0aW9uID0gMDtcbiAgICAgICAgICBmbG9hdCBhdmdWYWx1ZSA9IDAuMDtcblxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCAke3B9O1xuICAgICAgICAgICAgICB3UiArPSAke2x9KSB7XG4gICAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xuXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49ICR7ZS5pbkhlaWdodH0pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCAke2R9O1xuICAgICAgICAgICAgICAgIHdDICs9ICR7dX0pIHtcbiAgICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QztcblxuICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49ICR7ZS5pbldpZHRofSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRYKGJhdGNoLCB4UiwgeEMsIGQpO1xuXG4gICAgICAgICAgICAgIC8vIElmIGEgbWluIC8gbWF4IHZhbHVlIGhhcyBhbHJlYWR5IGJlZW4gZm91bmQsIHVzZSBpdC4gSWYgbm90LFxuICAgICAgICAgICAgICAvLyB1c2UgdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICAgICAgICAgIGZsb2F0IGN1cnJNaW5NYXhWYWx1ZSA9IG1peChcbiAgICAgICAgICAgICAgICAgIHZhbHVlLCBtaW5NYXhWYWx1ZSwgbWluTWF4VmFsdWVGb3VuZCk7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSAke0N9IGN1cnJNaW5NYXhWYWx1ZSkge1xuICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgbWluTWF4VmFsdWVGb3VuZCA9IDEuMDtcbiAgICAgICAgICAgICAgICBtaW5NYXhQb3NpdGlvbiA9ICR7YT9yP2Y6Zzpgd1IgKiAke2R9ICsgd0NgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQobWluTWF4UG9zaXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgYDtyZXR1cm59bGV0IHk9XCJtYXhcIix4PWAke3R9KCR7dH0oJHt0fShtaW5NYXhWYWx1ZVswXSwgbWluTWF4VmFsdWVbMV0pLCBtaW5NYXhWYWx1ZVsyXSksIG1pbk1heFZhbHVlWzNdKWA7dD09PVwiYXZnXCImJih4PVwiYXZnVmFsdWUgLyBtYXgoY291bnQsIDEuMClcIik7bGV0IHY9TWF0aC5mbG9vcihzLzQpKjQsST1zJTQsTj1gXG4gICAgICBpZiAoJHttfSkge1xuICAgICAgICBhdmdWYWx1ZSArPSBkb3QodmFsdWVzLCBvbmVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pbk1heFZhbHVlID0gJHt5fSh2YWx1ZXMsIG1pbk1heFZhbHVlKTtcbiAgICAgIH1cbiAgICBgO3RoaXMudXNlckNvZGU9YFxuICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKCR7aX0sICR7b30pO1xuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKCR7Y30sICR7aH0pO1xuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9ICR7Yn07XG4gICAgICBjb25zdCB2ZWM0IG9uZXMgPSB2ZWM0KDEuMCwgMS4wLCAxLjAsIDEuMCk7XG5cbiAgICAgIGZsb2F0IGNvdW50ID0gMC4wO1xuXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgYmF0Y2gsIGludCB4UiwgaW50IHhDLCBpbnQgZCkge1xuICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49ICR7ZS5pbldpZHRofSkge1xuICAgICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50ICs9IDEuMDtcbiAgICAgICAgcmV0dXJuIGdldFgoYmF0Y2gsIHhSLCB4QywgZCk7XG4gICAgICB9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XG5cbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xuICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcblxuICAgICAgICAvLyBtYXgvbWluIHgoPywgPywgZCkgdG8gZ2V0IHkoeVIsIHlDLCBkKS5cbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWRcbiAgICAgICAgdmVjNCBtaW5NYXhWYWx1ZSA9IHZlYzQoJHtifSk7XG4gICAgICAgIGZsb2F0IGF2Z1ZhbHVlID0gMC4wO1xuICAgICAgICBjb3VudCA9IDAuMDtcblxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgJHtwfTtcbiAgICAgICAgICAgIHdSICs9ICR7bH0pIHtcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xuXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSAke2UuaW5IZWlnaHR9KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgJHt2fTsgd0MgKz0gNCkge1xuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqICR7dX07XG5cbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyAke3V9LCBkKSxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIDIgKiAke3V9LCBkKSxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIDMgKiAke3V9LCBkKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgJHtOfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgJHt2fTtcbiAgICAgICAgICBpZiAoJHtJPT09MX0pIHtcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICR7Tn1cbiAgICAgICAgICB9IGVsc2UgaWYgKCR7ST09PTJ9KSB7XG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgJHt1fSwgZCksXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICR7Tn1cbiAgICAgICAgICB9IGVsc2UgaWYgKCR7ST09PTN9KSB7XG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgJHt1fSwgZCksXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyAyICogJHt1fSwgZCksXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICR7Tn1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KCR7eH0pO1xuICAgICAgfVxuICAgIGB9fSxjaz1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixhPSExLHI9ITEpe2lmKHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHQ9PT1cImF2Z1wiJiZuKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21wdXRlIHBvc2l0aW9ucyBmb3IgYXZlcmFnZSBwb29sLlwiKTtsZXQgcz1lLmZpbHRlcldpZHRoLGk9ZS5zdHJpZGVEZXB0aCxvPWUuc3RyaWRlSGVpZ2h0LGw9ZS5zdHJpZGVXaWR0aCx1PWUuZGlsYXRpb25EZXB0aCxwPWUuZGlsYXRpb25IZWlnaHQsZD1lLmRpbGF0aW9uV2lkdGgsYz1lLmVmZmVjdGl2ZUZpbHRlckRlcHRoLGg9ZS5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsbT1lLmVmZmVjdGl2ZUZpbHRlcldpZHRoLGY9ZS5wYWRJbmZvLmZyb250LGc9ZS5wYWRJbmZvLnRvcCxiPWUucGFkSW5mby5sZWZ0O3RoaXMub3V0cHV0U2hhcGU9ZS5vdXRTaGFwZTtsZXQgeT10PT09XCJhdmdcIix4PVwiMC4wXCI7aWYoeXx8KHg9XCItMS4wIC8gMWUtMjBcIiksbil7bGV0IEY9XCI+PVwiO3RoaXMudXNlckNvZGU9YFxuICAgICAgICBjb25zdCBpdmVjMyBzdHJpZGVzID1cbiAgICAgICAgICAgIGl2ZWMzKCR7aX0sICR7b30sICR7bH0pO1xuICAgICAgICBjb25zdCBpdmVjMyBwYWRzID0gaXZlYzMoJHtmfSwgJHtnfSwgJHtifSk7XG5cbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xuICAgICAgICAgIGludCBjaCA9IGNvb3Jkcy51O1xuXG4gICAgICAgICAgaXZlYzMgeENvcm5lciA9IGl2ZWMzKGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLncpICogc3RyaWRlcyAtIHBhZHM7XG4gICAgICAgICAgaW50IHhEQ29ybmVyID0geENvcm5lci54O1xuICAgICAgICAgIGludCB4UkNvcm5lciA9IHhDb3JuZXIueTtcbiAgICAgICAgICBpbnQgeENDb3JuZXIgPSB4Q29ybmVyLno7XG5cbiAgICAgICAgICAvLyBtYXgvbWluIHgoPywgPywgPywgY2gpIHRvIGdldCB5KHlELCB5UiwgeUMsIGNoKS5cbiAgICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlID0gMC4wO1xuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlRm91bmQgPSAwLjA7XG4gICAgICAgICAgaW50IG1pbk1heFBvc2l0aW9uID0gMDtcblxuICAgICAgICAgIGZvciAoaW50IHdEID0gMDsgd0QgPCAke2N9O1xuICAgICAgICAgICAgICB3RCArPSAke3V9KSB7XG4gICAgICAgICAgICBpbnQgeEQgPSB4RENvcm5lciArIHdEO1xuXG4gICAgICAgICAgICBpZiAoeEQgPCAwIHx8IHhEID49ICR7ZS5pbkRlcHRofSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8ICR7aH07XG4gICAgICAgICAgICAgICAgd1IgKz0gJHtwfSkge1xuICAgICAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xuXG4gICAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gJHtlLmluSGVpZ2h0fSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7bX07XG4gICAgICAgICAgICAgICAgICB3QyArPSAke2R9KSB7XG4gICAgICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QztcblxuICAgICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gJHtlLmluV2lkdGh9KSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldFgoYmF0Y2gsIHhELCB4UiwgeEMsIGNoKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIGEgbWluIC8gbWF4IHZhbHVlIGhhcyBhbHJlYWR5IGJlZW4gZm91bmQsIHVzZSBpdC4gSWYgbm90LFxuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBmbG9hdCBjdXJyTWluTWF4VmFsdWUgPSBtaXgoXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLCBtaW5NYXhWYWx1ZSwgbWluTWF4VmFsdWVGb3VuZCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICR7Rn0gY3Vyck1pbk1heFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgbWluTWF4VmFsdWVGb3VuZCA9IDEuMDtcbiAgICAgICAgICAgICAgICAgIG1pbk1heFBvc2l0aW9uID0gJHthP3I/YCgoKGJhdGNoICogJHtlLmluRGVwdGh9ICsgeEQpICogJHtlLmluSGVpZ2h0fSArIHhSKSAqICR7ZS5pbldpZHRofSArIHhDKSAqICR7ZS5pbkNoYW5uZWxzfSArIGNoYDpgKCh4RCAqICR7ZS5pbkhlaWdodH0gKyB4UikgKiAke2UuaW5XaWR0aH0gKyB4QykgKiAke2UuaW5DaGFubmVsc30gKyBjaGA6YHdEICogJHtofSAqICR7bX0gK1xuICAgICAgICAgICAgICAgICAgICAgIHdSICogJHttfSArIHdDYH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChtaW5NYXhQb3NpdGlvbikpO1xuICAgICAgICB9XG4gICAgICBgO3JldHVybn1sZXQgdj1cIm1heFwiLEk9YCR7dH0oJHt0fSgke3R9KG1pbk1heFZhbHVlWzBdLCBtaW5NYXhWYWx1ZVsxXSksIG1pbk1heFZhbHVlWzJdKSwgbWluTWF4VmFsdWVbM10pYDt0PT09XCJhdmdcIiYmKEk9XCJhdmdWYWx1ZSAvIG1heChjb3VudCwgMS4wKVwiKTtsZXQgTj1NYXRoLmZsb29yKHMvNCkqNCxDPXMlNCxfPWBcbiAgICAgIGlmICgke3l9KSB7XG4gICAgICAgIGF2Z1ZhbHVlICs9IGRvdCh2YWx1ZXMsIG9uZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluTWF4VmFsdWUgPSAke3Z9KHZhbHVlcywgbWluTWF4VmFsdWUpO1xuICAgICAgfVxuICAgIGA7dGhpcy51c2VyQ29kZT1gXG4gICAgICBjb25zdCBpdmVjMyBzdHJpZGVzID1cbiAgICAgICAgaXZlYzMoJHtpfSwgJHtvfSwgJHtsfSk7XG4gICAgICBjb25zdCBpdmVjMyBwYWRzID0gaXZlYzMoJHtmfSwgJHtnfSwgJHtifSk7XG4gICAgICBjb25zdCBmbG9hdCBpbml0aWFsaXphdGlvblZhbHVlID0gJHt4fTtcbiAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcblxuICAgICAgZmxvYXQgY291bnQgPSAwLjA7XG5cbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IHhELCBpbnQgeFIsIGludCB4QywgaW50IGNoKSB7XG4gICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gJHtlLmluV2lkdGh9KSB7XG4gICAgICAgICAgcmV0dXJuIGluaXRpYWxpemF0aW9uVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY291bnQgKz0gMS4wO1xuICAgICAgICByZXR1cm4gZ2V0WChiYXRjaCwgeEQsIHhSLCB4QywgY2gpO1xuICAgICAgfVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcbiAgICAgICAgaW50IGNoID0gY29vcmRzLnU7XG5cbiAgICAgICAgaXZlYzMgeENvcm5lciA9IGl2ZWMzKGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLncpICogc3RyaWRlcyAtIHBhZHM7XG4gICAgICAgIGludCB4RENvcm5lciA9IHhDb3JuZXIueDtcbiAgICAgICAgaW50IHhSQ29ybmVyID0geENvcm5lci55O1xuICAgICAgICBpbnQgeENDb3JuZXIgPSB4Q29ybmVyLno7XG5cbiAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sID8sIGQpIHRvIGdldCB5KHlELCB5UiwgeUMsIGNoKS5cbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWRcbiAgICAgICAgdmVjNCBtaW5NYXhWYWx1ZSA9IHZlYzQoJHt4fSk7XG4gICAgICAgIGZsb2F0IGF2Z1ZhbHVlID0gMC4wO1xuICAgICAgICBjb3VudCA9IDAuMDtcblxuICAgICAgICBmb3IgKGludCB3RCA9IDA7IHdEIDwgJHtjfTtcbiAgICAgICAgICAgIHdEICs9ICR7dX0pIHtcbiAgICAgICAgICBpbnQgeEQgPSB4RENvcm5lciArIHdEO1xuXG4gICAgICAgICAgaWYgKHhEIDwgMCB8fCB4RCA+PSAke2UuaW5EZXB0aH0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCAke2h9O1xuICAgICAgICAgICAgd1IgKz0gJHtwfSkge1xuICAgICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UjtcblxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSAke2UuaW5IZWlnaHR9KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgJHtOfTsgd0MgKz0gNCkge1xuICAgICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogJHtkfTtcblxuICAgICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMsIGNoKSxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QyArICR7ZH0sIGNoKSxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QyArIDIgKiAke2R9LCBjaCksXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMgKyAzICogJHtkfSwgY2gpXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgJHtffVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArICR7Tn07XG4gICAgICAgICAgICBpZiAoJHtDPT09MX0pIHtcbiAgICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDLCBjaCksXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAke199XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCR7Qz09PTJ9KSB7XG4gICAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QywgY2gpLFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDICsgJHtkfSwgY2gpLFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICR7X31cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJHtDPT09M30pIHtcbiAgICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDLCBjaCksXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMgKyAke2R9LCBjaCksXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMgKyAyICogJHtkfSwgY2gpLFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAke199XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dCgke0l9KTtcbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24gdnRlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10O2xwKHIsXCJhdmdQb29sXCIpO2xldHtmaWx0ZXJTaXplOnMsc3RyaWRlczppLHBhZDpvLGRpbVJvdW5kaW5nTW9kZTpsfT1hLHU9MTt3LmFzc2VydChULmVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShpLHUpLCgpPT5gRXJyb3IgaW4gYXZnUG9vbDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgJHtpfSBhbmQgZGlsYXRpb25zICcke3V9J2ApO2xldCBwPVQuY29tcHV0ZVBvb2wyREluZm8oci5zaGFwZSxzLGksdSxvLGwpO2lmKHAuZmlsdGVyV2lkdGg9PT0xJiZwLmZpbHRlckhlaWdodD09PTEmJncuYXJyYXlzRXF1YWwocC5pblNoYXBlLHAub3V0U2hhcGUpKXJldHVybiB0YSh7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bn0pO2xldCBkPW5ldyBFYyhwLFwiYXZnXCIsITEpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShkLFtyXSxcImZsb2F0MzJcIil9dmFyIHd0ZT17a2VybmVsTmFtZTpEaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzp2dGV9O2Z1bmN0aW9uIGt0ZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7ZmlsdGVyU2l6ZTpzLHN0cmlkZXM6aSxwYWQ6byxkaW1Sb3VuZGluZ01vZGU6bCxkYXRhRm9ybWF0OnV9PWEscD1bMSwxLDFdLGQ9VC5jb21wdXRlUG9vbDNESW5mbyhyLnNoYXBlLHMsaSxwLG8sbCx1KSxjPW5ldyBjayhkLFwiYXZnXCIsITEpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShjLFtyXSxcImZsb2F0MzJcIil9dmFyIEl0ZT17a2VybmVsTmFtZTp0dSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzprdGV9LFN0ZT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT1lLmluU2hhcGU7bGV0IHQ9ZS5maWx0ZXJIZWlnaHQsbj1lLmZpbHRlcldpZHRoLGE9ZS5zdHJpZGVIZWlnaHQscj1lLnN0cmlkZVdpZHRoLHM9ZS5kaWxhdGlvbkhlaWdodCxpPWUuZGlsYXRpb25XaWR0aCxvPWUuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LGw9ZS5lZmZlY3RpdmVGaWx0ZXJXaWR0aCx1PW8tMS1lLnBhZEluZm8udG9wLHA9bC0xLWUucGFkSW5mby5sZWZ0LGQ9MS8odCpuKTt0aGlzLnVzZXJDb2RlPWBcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3V9LCAke3B9KTtcbiAgICAgIGNvbnN0IGZsb2F0IGF2Z011bHRpcGxpZXIgPSBmbG9hdCgke2R9KTtcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xuXG4gICAgICAgIGl2ZWMyIGR5UkNDb3JuZXIgPSBjb29yZHMueXogLSBwYWRzO1xuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlSQ0Nvcm5lci54O1xuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlSQ0Nvcm5lci55O1xuXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQpIHdpdGggcG9zIG1hc2soOiwgOiwgZCkgdG8gZ2V0IGR4KHhSLCB4QywgZCkuXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgJHtvfTtcbiAgICAgICAgICAgIHdSICs9ICR7c30pIHtcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyAke2F9LjA7XG5cbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke2Uub3V0SGVpZ2h0fS4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xuXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7bH07XG4gICAgICAgICAgICB3Qys9ICR7aX0pIHtcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvICR7cn0uMDtcblxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gJHtlLm91dFdpZHRofS4wIHx8XG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XG5cbiAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCBpZHlSLCBpZHlDLCBkKTtcblxuICAgICAgICAgICAgZG90UHJvZCArPSBkeVZhbHVlICogYXZnTXVsdGlwbGllcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xuICAgICAgfVxuICAgIGB9fSxOdGU9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9ZS5pblNoYXBlO2xldCB0PWUuZmlsdGVyRGVwdGgsbj1lLmZpbHRlckhlaWdodCxhPWUuZmlsdGVyV2lkdGgscj1lLnN0cmlkZURlcHRoLHM9ZS5zdHJpZGVIZWlnaHQsaT1lLnN0cmlkZVdpZHRoLG89ZS5kaWxhdGlvbkRlcHRoLGw9ZS5kaWxhdGlvbkhlaWdodCx1PWUuZGlsYXRpb25XaWR0aCxwPWUuZWZmZWN0aXZlRmlsdGVyRGVwdGgsZD1lLmVmZmVjdGl2ZUZpbHRlckhlaWdodCxjPWUuZWZmZWN0aXZlRmlsdGVyV2lkdGgsaD1wLTEtZS5wYWRJbmZvLmZyb250LG09ZC0xLWUucGFkSW5mby50b3AsZj1jLTEtZS5wYWRJbmZvLmxlZnQsZz0xLyh0Km4qYSk7dGhpcy51c2VyQ29kZT1gXG4gICAgICBjb25zdCBpdmVjMyBwYWRzID0gaXZlYzMoJHtofSwgJHttfSwgJHtmfSk7XG4gICAgICBjb25zdCBmbG9hdCBhdmdNdWx0aXBsaWVyID0gZmxvYXQoJHtnfSk7XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzUgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xuICAgICAgICBpbnQgY2ggPSBjb29yZHMudTtcblxuICAgICAgICBpdmVjMyBkeUNvcm5lciA9IGl2ZWMzKGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLncpIC0gcGFkcztcbiAgICAgICAgaW50IGR5RENvcm5lciA9IGR5Q29ybmVyLng7XG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci55O1xuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlDb3JuZXIuejtcblxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCA/LCBkKSB3aXRoIHBvcyBtYXNrKDosIDosIDosIGNoKSB0byBnZXRcbiAgICAgICAgLy8gZHgoeEQsIHhSLCB4QywgY2gpLlxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcblxuICAgICAgICBmb3IgKGludCB3RCA9IDA7IHdEIDwgJHtwfTtcbiAgICAgICAgICAgIHdEICs9ICR7b30pIHtcbiAgICAgICAgICBmbG9hdCBkeUQgPSBmbG9hdChkeURDb3JuZXIgKyB3RCkgLyAke3J9LjA7XG5cbiAgICAgICAgICBpZiAoZHlEIDwgMC4wIHx8IGR5RCA+PSAke2Uub3V0RGVwdGh9LjAgfHwgZnJhY3QoZHlEKSA+IDAuMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGludCBpZHlEID0gaW50KGR5RCk7XG5cbiAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgJHtkfTtcbiAgICAgICAgICAgICAgd1IgKz0gJHtsfSkge1xuICAgICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gJHtzfS4wO1xuXG4gICAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke2Uub3V0SGVpZ2h0fS4wIHx8XG4gICAgICAgICAgICAgICAgZnJhY3QoZHlSKSA+IDAuMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XG5cbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCAke2N9O1xuICAgICAgICAgICAgICAgIHdDICs9ICR7dX0pIHtcbiAgICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gJHtpfS4wO1xuXG4gICAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49ICR7ZS5vdXRXaWR0aH0uMCB8fFxuICAgICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XG5cbiAgICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGJhdGNoLCBpZHlELCBpZHlSLCBpZHlDLCBjaCk7XG5cbiAgICAgICAgICAgICAgZG90UHJvZCArPSBkeVZhbHVlICogYXZnTXVsdGlwbGllcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xuICAgICAgfVxuICAgIGB9fTtmdW5jdGlvbiBUdGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtkeTpyLGlucHV0OnN9PXQsaT1zLHtmaWx0ZXJTaXplOm8sc3RyaWRlczpsLHBhZDp1LGRpbVJvdW5kaW5nTW9kZTpwfT1hLGQ9WzEsMSwxXSxjPVQuY29tcHV0ZVBvb2wzREluZm8oaS5zaGFwZSxvLGwsZCx1LHApLGg9bmV3IE50ZShjKTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0oaCxbcl0saS5kdHlwZSl9dmFyIEN0ZT17a2VybmVsTmFtZTpSYyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpUdGV9O2Z1bmN0aW9uIEV0ZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2R5OnIsaW5wdXQ6c309dCxpPXM7bHAoW3Isc10sXCJhdmdQb29sR3JhZFwiKTtsZXR7ZmlsdGVyU2l6ZTpvLHN0cmlkZXM6bCxwYWQ6dX09YSxwPVQuY29tcHV0ZVBvb2wyREluZm8oaS5zaGFwZSxvLGwsMSx1KSxkPW5ldyBTdGUocCk7cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKGQsW3JdLGkuZHR5cGUpfXZhciBfdGU9e2tlcm5lbE5hbWU6RGMsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6RXRlfTtmdW5jdGlvbiBBdGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHthOnIsYjpzfT10LHt0cmFuc3Bvc2VBOmksdHJhbnNwb3NlQjpvfT1hO3JldHVybiBobSh7YTpyLGI6cyx0cmFuc3Bvc2VBOmksdHJhbnNwb3NlQjpvLGJhY2tlbmQ6bn0pfXZhciBGdGU9e2tlcm5lbE5hbWU6UmksYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6QXRlfSwkdGU9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4sYSxyLHMpe3RoaXMub3V0cHV0U2hhcGU9W10sdGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIm1lYW5cIixcInZhcmlhbmNlXCJdLFQuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoZSx0KSxULmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGUsbik7bGV0IGk9XCIwLjBcIjthIT1udWxsJiYoVC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShlLGEpLHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwib2Zmc2V0XCIpLGk9XCJnZXRPZmZzZXRBdE91dENvb3JkcygpXCIpO2xldCBvPVwiMS4wXCI7ciE9bnVsbCYmKFQuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoZSxyKSx0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcInNjYWxlXCIpLG89XCJnZXRTY2FsZUF0T3V0Q29vcmRzKClcIiksdGhpcy5vdXRwdXRTaGFwZT1lLHRoaXMudXNlckNvZGU9YFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBmbG9hdCB4ID0gZ2V0WEF0T3V0Q29vcmRzKCk7XG4gICAgICAgIGZsb2F0IG1lYW4gPSBnZXRNZWFuQXRPdXRDb29yZHMoKTtcbiAgICAgICAgZmxvYXQgdmFyaWFuY2UgPSBnZXRWYXJpYW5jZUF0T3V0Q29vcmRzKCk7XG4gICAgICAgIGZsb2F0IG9mZnNldCA9ICR7aX07XG4gICAgICAgIGZsb2F0IHNjYWxlID0gJHtvfTtcbiAgICAgICAgZmxvYXQgaW52ID0gc2NhbGUgKiBpbnZlcnNlc3FydCh2YXJpYW5jZSArIGZsb2F0KCR7c30pKTtcbiAgICAgICAgc2V0T3V0cHV0KGRvdCh2ZWMzKHgsIC1tZWFuLCBvZmZzZXQpLCB2ZWMzKGludiwgaW52LCAxKSkpO1xuICAgICAgfVxuICAgIGB9fSxEdGU9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4sYSxyLHMpe3RoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJtZWFuXCIsXCJ2YXJpYW5jZVwiXSxULmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGUsdCksVC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShlLG4pO2xldCBpPVwidmVjNCgwLjApXCI7YSE9bnVsbCYmKFQuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoZSxhKSx0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcIm9mZnNldFwiKSxpPVwiZ2V0T2Zmc2V0QXRPdXRDb29yZHMoKVwiKTtsZXQgbz1cInZlYzQoMS4wKVwiO3IhPW51bGwmJihULmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGUsciksdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJzY2FsZVwiKSxvPVwiZ2V0U2NhbGVBdE91dENvb3JkcygpXCIpLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLnVzZXJDb2RlPWBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjNCBvZmZzZXQgPSAke2l9O1xuICAgICAgICB2ZWM0IHNjYWxlID0gJHtvfTtcblxuICAgICAgICB2ZWM0IHggPSBnZXRYQXRPdXRDb29yZHMoKTtcbiAgICAgICAgdmVjNCBtZWFuID0gZ2V0TWVhbkF0T3V0Q29vcmRzKCk7XG4gICAgICAgIHZlYzQgdmFyaWFuY2UgPSBnZXRWYXJpYW5jZUF0T3V0Q29vcmRzKCk7XG5cbiAgICAgICAgdmVjNCBpbnYgPSBzY2FsZSAqIGludmVyc2VzcXJ0KHZhcmlhbmNlICsgdmVjNCgke3N9KSk7XG5cbiAgICAgICAgc2V0T3V0cHV0KCh4IC0gbWVhbikgKiBpbnYgKyBvZmZzZXQpO1xuICAgICAgfVxuICAgIGB9fSxSdGU9KHtpbnB1dHM6ZSxiYWNrZW5kOnQsYXR0cnM6bn0pPT57bGV0e3g6YSxtZWFuOnIsdmFyaWFuY2U6cyxvZmZzZXQ6aSxzY2FsZTpvfT1lO3cuYXNzZXJ0KHIuc2hhcGUubGVuZ3RoPT09cy5zaGFwZS5sZW5ndGgsKCk9PlwiQmF0Y2ggbm9ybWFsaXphdGlvbiBncmFkaWVudCByZXF1aXJlcyBtZWFuIGFuZCB2YXJpYW5jZSB0byBoYXZlIGVxdWFsIHJhbmtzLlwiKSx3LmFzc2VydChpPT1udWxsfHxyLnNoYXBlLmxlbmd0aD09PWkuc2hhcGUubGVuZ3RoLCgpPT5cIkJhdGNoIG5vcm1hbGl6YXRpb24gZ3JhZGllbnQgcmVxdWlyZXMgbWVhbiBhbmQgb2Zmc2V0IHRvIGhhdmUgZXF1YWwgcmFua3MuXCIpLHcuYXNzZXJ0KG89PW51bGx8fHIuc2hhcGUubGVuZ3RoPT09by5zaGFwZS5sZW5ndGgsKCk9PlwiQmF0Y2ggbm9ybWFsaXphdGlvbiBncmFkaWVudCByZXF1aXJlcyBtZWFuIGFuZCBzY2FsZSB0byBoYXZlIGVxdWFsIHJhbmtzLlwiKTtsZXR7dmFyaWFuY2VFcHNpbG9uOmx9PW47bD09bnVsbCYmKGw9LjAwMSk7bGV0IHU9W2EscixzXSxwPW51bGw7aSE9bnVsbCYmKHA9aS5zaGFwZSx1LnB1c2goaSkpO2xldCBkPW51bGw7byE9bnVsbCYmKGQ9by5zaGFwZSx1LnB1c2gobykpO2xldCBjPUcoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19OT1JNQUxJWkFUSU9OXCIpP25ldyBEdGUoYS5zaGFwZSxyLnNoYXBlLHMuc2hhcGUscCxkLGwpOm5ldyAkdGUoYS5zaGFwZSxyLnNoYXBlLHMuc2hhcGUscCxkLGwpO3JldHVybiB0LnJ1bldlYkdMUHJvZ3JhbShjLHUsdVswXS5kdHlwZSl9LE10ZT17a2VybmVsTmFtZTpKaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpSdGV9LE90ZT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wic291cmNlXCJdLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLnJhbms9ZS5sZW5ndGg7bGV0IHQ9aHQodGhpcy5yYW5rKTt0aGlzLmN1c3RvbVVuaWZvcm1zPVt7bmFtZTpcInN0YXJ0XCIsYXJyYXlJbmRleDp0aGlzLnJhbmssdHlwZTpcImludFwifV07bGV0IG49UHRlKHRoaXMucmFuayksYSxyPWUubWFwKChzLGkpPT5gc291cmNlTG9jLiR7bXZbaV19ID0gc3RhcnRbJHtpfV0gKyBjb29yZHMuJHttdltpXX07YCk7YT1gXG4gICAgICAgICR7dH0gc291cmNlTG9jO1xuICAgICAgICAke3R9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAke3Iuam9pbihgXG5gKX1cbiAgICAgIGAsdGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICR7YX1cbiAgICAgICAgc2V0T3V0cHV0KGdldFNvdXJjZSgke259KSk7XG4gICAgICB9XG4gICAgYH19LG12PVtcInhcIixcInlcIixcInpcIixcIndcIixcInVcIixcInZcIl07ZnVuY3Rpb24gUHRlKGUpe2lmKGU9PT0xKXJldHVyblwic291cmNlTG9jXCI7aWYoZTw9NilyZXR1cm4gbXYuc2xpY2UoMCxlKS5tYXAodD0+XCJzb3VyY2VMb2MuXCIrdCkuam9pbihcIixcIik7dGhyb3cgRXJyb3IoYFNsaWNpbmcgZm9yIHJhbmsgJHtlfSBpcyBub3QgeWV0IHN1cHBvcnRlZGApfXZhciBMdGU9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInNvdXJjZVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dHB1dFNoYXBlPWUsdGhpcy5yYW5rPWUubGVuZ3RoLHRoaXMuY3VzdG9tVW5pZm9ybXM9W3tuYW1lOlwic3RhcnRcIixhcnJheUluZGV4OnRoaXMucmFuayx0eXBlOlwiaW50XCJ9XTtsZXQgdD1odCh0aGlzLnJhbmspLG49SW4oXCJjb29yZHNcIix0aGlzLnJhbmspLGE9SW4oXCJzb3VyY2VMb2NcIix0aGlzLnJhbmspLHI9dGhpcy5yYW5rPT09MT9cInNvdXJjZUxvY1wiOmB2ZWMyKCR7YS5zbGljZSgtMikuam9pbigpfSlgLHM9YGdldENoYW5uZWwoZ2V0U291cmNlKCR7YS5qb2luKCl9KSwgJHtyfSlgLGk9YFxuICAgICAgcmVzdWx0LnggPSAke3N9O1xuICAgICAgaWYgKCsrJHtuW3RoaXMucmFuay0xXX0gPCAke2VbdGhpcy5yYW5rLTFdfSkge1xuICAgICAgICArKyR7YVt0aGlzLnJhbmstMV19O1xuICAgICAgICByZXN1bHQueSA9ICR7c307XG4gICAgICAgIC0tJHthW3RoaXMucmFuay0xXX07XG4gICAgICB9XG4gICAgYCxvPXRoaXMucmFuaz09PTE/XCJcIjpgXG4gICAgICAtLSR7blt0aGlzLnJhbmstMV19O1xuICAgICAgaWYgKCsrJHtuW3RoaXMucmFuay0yXX0gPCAke2VbdGhpcy5yYW5rLTJdfSkge1xuICAgICAgICArKyR7YVt0aGlzLnJhbmstMl19O1xuICAgICAgICByZXN1bHQueiA9ICR7c307XG4gICAgICAgIGlmICgrKyR7blt0aGlzLnJhbmstMV19IDwgJHtlW3RoaXMucmFuay0xXX0pIHtcbiAgICAgICAgICArKyR7YVt0aGlzLnJhbmstMV19O1xuICAgICAgICAgIHJlc3VsdC53ID0gJHtzfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGAsbD10aGlzLnJhbms8PTQ/YHNvdXJjZUxvYyA9IGNvb3JkcyArXG4gICAgICAgICAgICAke3R9KCR7ZS5tYXAoKHUscCk9PmBzdGFydFske3B9XWApLmpvaW4oKX0pO2A6ZS5tYXAoKHUscCk9PmAke2FbcF19ID0gJHtuW3BdfSArIHN0YXJ0WyR7cH1dO2ApLmpvaW4oYFxuYCk7dGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICR7dH0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICR7dH0gc291cmNlTG9jO1xuICAgICAgICAke2x9XG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XG4gICAgICAgICR7aX1cbiAgICAgICAgJHtvfVxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24genRlKGUsdCxuLGEpe2xldCByPWEudGV4RGF0YS5nZXQoZS5kYXRhSWQpLHM9YS5tYWtlVGVuc29ySW5mbyhuLGUuZHR5cGUpLGk9YS50ZXhEYXRhLmdldChzLmRhdGFJZCk7T2JqZWN0LmFzc2lnbihpLHIpLGkucmVmQ291bnQ9MSxpLnNoYXBlPW4saS5kdHlwZT1lLmR0eXBlO2xldCBvPUt0LmNvbXB1dGVGbGF0T2Zmc2V0KHQsdy5jb21wdXRlU3RyaWRlcyhlLnNoYXBlKSk7ci5zbGljZSYmKG8rPXIuc2xpY2UuZmxhdE9mZnNldCksaS5zbGljZT17ZmxhdE9mZnNldDpvLG9yaWdEYXRhSWQ6ci5zbGljZSYmci5zbGljZS5vcmlnRGF0YUlkfHxlLmRhdGFJZH07bGV0IGw9YS5kYXRhUmVmQ291bnQuZ2V0KGkuc2xpY2Uub3JpZ0RhdGFJZCl8fDE7cmV0dXJuIGEuZGF0YVJlZkNvdW50LnNldChpLnNsaWNlLm9yaWdEYXRhSWQsbCsxKSxzfWZ1bmN0aW9uIGZwKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtiZWdpbjpzLHNpemU6aX09YSxbbyxsXT1LdC5wYXJzZVNsaWNlUGFyYW1zKHIscyxpKTtpZihLdC5hc3NlcnRQYXJhbXNWYWxpZChyLG8sbCksdy5zaXplRnJvbVNoYXBlKGwpPT09MClyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhsLHIuZHR5cGUsW10pO2lmKG4uc2hvdWxkRXhlY3V0ZU9uQ1BVKFtyXSl8fHIuZHR5cGU9PT1cInN0cmluZ1wiKXtsZXQgZD1uLnRleERhdGEuZ2V0KHIuZGF0YUlkKSxjPV9RKGQudmFsdWVzLG8sbCxyLnNoYXBlLHIuZHR5cGUpO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKGwsci5kdHlwZSxjKX1sZXR7aXNQYWNrZWQ6dX09bi50ZXhEYXRhLmdldChyLmRhdGFJZCkscD1LdC5pc1NsaWNlQ29udGlub3VzKHIuc2hhcGUsbyxsKTtpZih1fHwhcCl7bGV0IGQ9RygpLmdldEJvb2woXCJXRUJHTF9QQUNLX0FSUkFZX09QRVJBVElPTlNcIik/bmV3IEx0ZShsKTpuZXcgT3RlKGwpLGM9W29dO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShkLFtyXSxyLmR0eXBlLGMpfXJldHVybiBuLnVwbG9hZFRvR1BVKHIuZGF0YUlkKSx6dGUocixvLGwsbil9dmFyIFd0ZT17a2VybmVsTmFtZTpCdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpmcH0sQnRlPWU9PntsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7YmxvY2tTaGFwZTpzLGNyb3BzOml9PWE7dy5hc3NlcnQoci5zaGFwZS5sZW5ndGg8PTQsKCk9PlwiYmF0Y2hUb1NwYWNlTkQgZm9yIHJhbmsgPiA0IHdpdGggYSBXZWJHTCBiYWNrZW5kIG5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7bGV0IG89cy5yZWR1Y2UoKHkseCk9PnkqeCksbD1ULmdldFJlc2hhcGVkKHIuc2hhcGUscyxvKSx1PVQuZ2V0UGVybXV0ZWQobC5sZW5ndGgscy5sZW5ndGgpLHA9VC5nZXRSZXNoYXBlZFBlcm11dGVkKHIuc2hhcGUscyxvKSxkPVQuZ2V0U2xpY2VCZWdpbkNvb3JkcyhpLHMubGVuZ3RoKSxjPVQuZ2V0U2xpY2VTaXplKHAsaSxzLmxlbmd0aCksaD1bXSxtPWNlKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpsfX0pLGY9U24oe2lucHV0czp7eDptfSxiYWNrZW5kOm4sYXR0cnM6e3Blcm06dX19KSxnPWNlKHtpbnB1dHM6e3g6Zn0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpwfX0pLGI9ZnAoe2lucHV0czp7eDpnfSxiYWNrZW5kOm4sYXR0cnM6e2JlZ2luOmQsc2l6ZTpjfX0pO3JldHVybiBoLnB1c2gobSksaC5wdXNoKGYpLGgucHVzaChnKSxoLmZvckVhY2goeT0+bi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh5KSksYn0sVnRlPXtrZXJuZWxOYW1lOm51LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkJ0ZX07ZnVuY3Rpb24gVXRlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyLHdlaWdodHM6c309dCx7c2l6ZTppfT1hLG89bi5yZWFkU3luYyhyLmRhdGFJZCksbD1uLnJlYWRTeW5jKHMuZGF0YUlkKSx1PVRBKG8sbCxzLmR0eXBlLHMuc2hhcGUsaSk7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8oW2ldLHMuZHR5cGUsdSl9dmFyIEd0ZT17a2VybmVsTmFtZTphdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpVdGV9LEh0ZT1gXG4gIGludCByID0gaW50KGEucikgJiBpbnQoYi5yKTtcbiAgaW50IGcgPSBpbnQoYS5nKSAmIGludChiLmcpO1xuICBpbnQgcmIgPSBpbnQoYS5iKSAmIGludChiLmIpO1xuICBpbnQgcmEgPSBpbnQoYS5hKSAmIGludChiLmEpO1xuICByZXR1cm4gdmVjNChyLCBnLCByYiwgcmEpO1xuYCxqdGU9YFxuICByZXR1cm4gZmxvYXQoaW50KGEucikgJiBpbnQoYi5yKSk7XG5gO2Z1bmN0aW9uIHF0ZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHthLGI6cn09dCxzPUcoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSxpPUcoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpO2lmKG4uc2hvdWxkRXhlY3V0ZU9uQ1BVKFthLHJdKXx8aT09PTEpe2xldCBsPW4udGV4RGF0YS5nZXQoYS5kYXRhSWQpLnZhbHVlcyx1PW4udGV4RGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxbcCxkXT1ROShhLnNoYXBlLHIuc2hhcGUsbCx1LGEuZHR5cGUpLGM9bi5tYWtlVGVuc29ySW5mbyhkLGEuZHR5cGUpLGg9bi50ZXhEYXRhLmdldChjLmRhdGFJZCk7cmV0dXJuIGgudmFsdWVzPXAsY31sZXQgbztyZXR1cm4gcz9vPW5ldyBocChIdGUsYS5zaGFwZSxyLnNoYXBlLCExKTpvPW5ldyBraShqdGUsYS5zaGFwZSxyLnNoYXBlKSxuLnJ1bldlYkdMUHJvZ3JhbShvLFthLHJdLGEuZHR5cGUpfXZhciBLdGU9e2tlcm5lbE5hbWU6cnUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6cXRlfTtmdW5jdGlvbiBYdGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7czA6YSxzMTpyfT10LHM9bi5yZWFkU3luYyhhLmRhdGFJZCksaT1uLnJlYWRTeW5jKHIuZGF0YUlkKSxvPVQuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoQXJyYXkuZnJvbShzKSxBcnJheS5mcm9tKGkpKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhbby5sZW5ndGhdLFwiaW50MzJcIixJbnQzMkFycmF5LmZyb20obykpfXZhciBZdGU9e2tlcm5lbE5hbWU6TWMsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6WHRlfSxadGU9XCJyZXR1cm4gZmxvYXQoYSAhPSBiKTtcIixWQT1obih7b3BTbmlwcGV0Olp0ZSxjcHVLZXJuZWxJbXBsOnZRLGR0eXBlOlwiYm9vbFwifSksSnRlPXtrZXJuZWxOYW1lOkV1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlZBfTtmdW5jdGlvbiBGZChlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHtpbnB1dDphfT10LHI9bi50ZXhEYXRhLmdldChhLmRhdGFJZCk7cmV0dXJuIHRhKHtpbnB1dHM6e3g6ci5jb21wbGV4VGVuc29ySW5mb3MucmVhbH0sYmFja2VuZDpufSl9dmFyIFF0ZT17a2VybmVsTmFtZTpEbSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpGZH0sZW5lPVwicmV0dXJuIGZsb2F0KGludCh4KSk7XCI7ZnVuY3Rpb24gdG5lKGUsdCl7bGV0IG49bmV3IHJyKGUuc2hhcGUsZW5lKSxhPXQucnVuV2ViR0xQcm9ncmFtKG4sW2VdLFwiaW50MzJcIik7cmV0dXJue2RhdGFJZDphLmRhdGFJZCxzaGFwZTphLnNoYXBlLGR0eXBlOmEuZHR5cGV9fWZ1bmN0aW9uIGZ2KGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtkdHlwZTpzfT1hO2lmKHM9PT1cImNvbXBsZXg2NFwiKXtpZihyLmR0eXBlPT09XCJjb21wbGV4NjRcIilyZXR1cm4gdGEoe2lucHV0czp7eDpyfSxiYWNrZW5kOm59KTtsZXQgaT1JdChyLnNoYXBlKSxvPWZ2KHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntkdHlwZTpcImZsb2F0MzJcIn19KSxsPSRzKHtpbnB1dHM6e3JlYWw6byxpbWFnOml9LGJhY2tlbmQ6bn0pO3JldHVybiBpLmRpc3Bvc2UoKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG8pLGx9aWYoci5kdHlwZT09PVwiY29tcGxleDY0XCIpe2xldCBpPUZkKHtpbnB1dHM6e2lucHV0OnJ9LGJhY2tlbmQ6bn0pLG89ZnYoe2lucHV0czp7eDppfSxiYWNrZW5kOm4sYXR0cnM6e2R0eXBlOnN9fSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaSksb31pZighdy5oYXNFbmNvZGluZ0xvc3Moci5kdHlwZSxzKSl7bGV0IGk9dGEoe2lucHV0czp7eDpyfSxiYWNrZW5kOm59KTtyZXR1cm57ZGF0YUlkOmkuZGF0YUlkLHNoYXBlOmkuc2hhcGUsZHR5cGU6c319aWYobi5zaG91bGRFeGVjdXRlT25DUFUoW3JdKSl7bGV0IGk9bi50ZXhEYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLFtvLGwsdV09ZVEoaSxyLnNoYXBlLHIuZHR5cGUscyk7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8obyxsLHUpfWlmKHM9PT1cImludDMyXCIpcmV0dXJuIHRuZShyLG4pO2lmKHM9PT1cImJvb2xcIil7bGV0IGk9bi5tYWtlVGVuc29ySW5mbyhbXSxcImJvb2xcIix3LmdldFR5cGVkQXJyYXlGcm9tRFR5cGUoXCJib29sXCIsMSkpLG89VkEoe2lucHV0czp7YTpyLGI6aX0sYmFja2VuZDpufSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaSksb310aHJvdyBuZXcgRXJyb3IoYEVycm9yIGluIENhc3Q6IGZhaWxlZCB0byBjYXN0ICR7ci5kdHlwZX0gdG8gJHtzfWApfXZhciBubmU9e2tlcm5lbE5hbWU6TWksYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6ZnZ9LG1TPVwicmV0dXJuIGNlaWwoeCk7XCIsYW5lPVplKHtvcFNuaXBwZXQ6bVMscGFja2VkT3BTbmlwcGV0Om1TLGNwdUtlcm5lbEltcGw6dFF9KSxybmU9e2tlcm5lbE5hbWU6T2ksYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6YW5lfSxzbmU9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5jdXN0b21Vbmlmb3Jtcz1be25hbWU6XCJtaW5WYWxcIix0eXBlOlwiZmxvYXRcIn0se25hbWU6XCJtYXhWYWxcIix0eXBlOlwiZmxvYXRcIn1dLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLnVzZXJDb2RlPWBcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldEFBdE91dENvb3JkcygpO1xuICAgICAgICBpZiAoaXNuYW4odmFsdWUpKSB7XG4gICAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZXRPdXRwdXQoY2xhbXAodmFsdWUsIG1pblZhbCwgbWF4VmFsKSk7XG4gICAgICB9XG4gICAgYH19LGluZT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLmN1c3RvbVVuaWZvcm1zPVt7bmFtZTpcIm1pblZhbFwiLHR5cGU6XCJmbG9hdFwifSx7bmFtZTpcIm1heFZhbFwiLHR5cGU6XCJmbG9hdFwifV0sdGhpcy5vdXRwdXRTaGFwZT1lLHRoaXMudXNlckNvZGU9YFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2ZWM0IHZhbHVlID0gZ2V0QUF0T3V0Q29vcmRzKCk7XG5cbiAgICAgICAgaWYgKGFueShpc25hbih2YWx1ZSkpKSB7XG4gICAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZXRPdXRwdXQoY2xhbXAodmFsdWUsIHZlYzQobWluVmFsKSwgdmVjNChtYXhWYWwpKSk7XG4gICAgICB9XG4gICAgYH19O2Z1bmN0aW9uIG9uZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7Y2xpcFZhbHVlTWluOnMsY2xpcFZhbHVlTWF4Oml9PWEsbztHKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQ0xJUFwiKT9vPW5ldyBpbmUoci5zaGFwZSk6bz1uZXcgc25lKHIuc2hhcGUpO2xldCBsPVtbc10sW2ldXTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0obyxbcl0sci5kdHlwZSxsKX12YXIgbG5lPXtrZXJuZWxOYW1lOndzLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOm9uZX0sdW5lPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJyZWFsXCIsXCJpbWFnXCJdLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLnVzZXJDb2RlPWBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZmxvYXQgcmUgPSBhYnMoZ2V0UmVhbEF0T3V0Q29vcmRzKCkpO1xuICAgICAgICBmbG9hdCBpbSA9IGFicyhnZXRJbWFnQXRPdXRDb29yZHMoKSk7XG4gICAgICAgIGZsb2F0IG14ID0gbWF4KHJlLCBpbSk7XG5cbiAgICAgICAgLy8gc2FkbHkgdGhlIGxlbmd0aCBmdW5jdGlvbiBpbiBnbHNsIGlzIG5vdCB1bmRlcmZsb3ctc2FmZVxuICAgICAgICAvLyAoYXQgbGVhc3Qgbm90IG9uIEludGVsIEdQVXMpLiBTbyB0aGUgc2FmZSBzb2x1dGlvbiBpc1xuICAgICAgICAvLyB0byBlbnN1cmUgdW5kZXJmbG93LXNhZmV0eSBpbiBhbGwgY2FzZXMuXG4gICAgICAgIHNldE91dHB1dChcbiAgICAgICAgICBteCA9PSAwLjAgPyAwLjAgOiBteCAqIGxlbmd0aCh2ZWMyKDEsIG1pbihyZSwgaW0pL214KSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24gZlMoZSx0KXtyZXR1cm57ZGF0YUlkOnQuZGF0YUlkLGR0eXBlOnQuZHR5cGUsc2hhcGU6ZS5zaGFwZX19ZnVuY3Rpb24gcG5lKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse3g6YX09dCxyPW4udGV4RGF0YS5nZXQoYS5kYXRhSWQpLHM9bmV3IHVuZShhLnNoYXBlKSxpPVtmUyhhLHIuY29tcGxleFRlbnNvckluZm9zLnJlYWwpLGZTKGEsci5jb21wbGV4VGVuc29ySW5mb3MuaW1hZyldO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShzLGksaVswXS5kdHlwZSl9dmFyIGNuZT17a2VybmVsTmFtZTpPYyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpwbmV9LGRuZT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9VC5jb21wdXRlT3V0U2hhcGUoZSwxKSx0aGlzLnZhcmlhYmxlTmFtZXM9ZS5tYXAoKHMsaSk9PmBUJHtpfWApO2xldCB0PW5ldyBBcnJheShlLmxlbmd0aC0xKTt0WzBdPWVbMF1bMV07Zm9yKGxldCBzPTE7czx0Lmxlbmd0aDtzKyspdFtzXT10W3MtMV0rZVtzXVsxXTtsZXQgbj1bYGlmICh5QyA8ICR7dFswXX0pIHNldE91dHB1dChnZXRUMCh5UiwgeUMpKTtgXTtmb3IobGV0IHM9MTtzPHQubGVuZ3RoO3MrKyl7bGV0IGk9dFtzLTFdO24ucHVzaChgZWxzZSBpZiAoeUMgPCAke3Rbc119KSBzZXRPdXRwdXQoZ2V0VCR7c30oeVIsIHlDLSR7aX0pKTtgKX1sZXQgYT10Lmxlbmd0aCxyPXRbdC5sZW5ndGgtMV07bi5wdXNoKGBlbHNlIHNldE91dHB1dChnZXRUJHthfSh5UiwgeUMtJHtyfSkpO2ApLHRoaXMudXNlckNvZGU9YFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IHlSID0gY29vcmRzLng7XG4gICAgICAgIGludCB5QyA9IGNvb3Jkcy55O1xuXG4gICAgICAgICR7bi5qb2luKGBcbiAgICAgICAgYCl9XG4gICAgICB9XG4gICAgYH19LGhuZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQpe3RoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT1ULmNvbXB1dGVPdXRTaGFwZShlLHQpO2xldCBuPXRoaXMub3V0cHV0U2hhcGUsYT1uLmxlbmd0aCxyPWh0KGEpLHM9SW4oXCJjb29yZHNcIixhKSxpPVtcInhcIixcInlcIixcInpcIixcIndcIixcInVcIixcInZcIl0uc2xpY2UoMCxhKTt0aGlzLnZhcmlhYmxlTmFtZXM9ZS5tYXAoKG0sZik9PmBUJHtmfWApO2xldCBvPW5ldyBBcnJheShlLmxlbmd0aC0xKTtvWzBdPWVbMF1bdF07Zm9yKGxldCBtPTE7bTxvLmxlbmd0aDttKyspb1ttXT1vW20tMV0rZVttXVt0XTtsZXQgbD1pW3RdLHU9aS5zbGljZSgtMikscD1pLmpvaW4oKSxkPWBpZiAoJHtsfSA8ICR7b1swXX0pIHtcbiAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoXG4gICAgICAgICAgICBnZXRUMCgke3B9KSwgdmVjMigke3Uuam9pbigpfSkpO1xuICAgICAgICB9YDtmb3IobGV0IG09MTttPG8ubGVuZ3RoO20rKyl7bGV0IGY9b1ttLTFdO2QrPWBcbiAgICAgICAgaWYgKCR7bH0gPCAke29bbV19ICAmJiAke2x9ID49ICR7b1ttLTFdfSkge1xuICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxuICAgICAgICAgICAgZ2V0VCR7bX0oJHskaChpLGwsZil9KSxcbiAgICAgICAgICAgIHZlYzIoJHskaCh1LGwsZil9KSk7XG4gICAgICAgIH1gfWxldCBjPW8ubGVuZ3RoLGg9b1tvLmxlbmd0aC0xXTtkKz1gXG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxuICAgICAgICAgIGdldFQke2N9KCR7JGgoaSxsLGgpfSksXG4gICAgICAgICAgdmVjMigkeyRoKHUsbCxoKX0pKTtgLHRoaXMudXNlckNvZGU9YFxuICAgICAgZmxvYXQgZ2V0VmFsdWUoJHtpLm1hcChtPT5cImludCBcIittKX0pIHtcbiAgICAgICAgJHtkfVxuICAgICAgfVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICR7cn0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNChnZXRWYWx1ZSgke3N9KSwgMC4sIDAuLCAwLik7XG5cbiAgICAgICAgJHtzW2EtMV19ID0gJHtzW2EtMV19ICsgMTtcbiAgICAgICAgaWYgKCR7c1thLTFdfSA8ICR7blthLTFdfSkge1xuICAgICAgICAgIHJlc3VsdC5nID0gZ2V0VmFsdWUoJHtzfSk7XG4gICAgICAgIH1cblxuICAgICAgICAke3NbYS0yXX0gPSAke3NbYS0yXX0gKyAxO1xuICAgICAgICBpZiAoJHtzW2EtMl19IDwgJHtuW2EtMl19KSB7XG4gICAgICAgICAgcmVzdWx0LmEgPSBnZXRWYWx1ZSgke3N9KTtcbiAgICAgICAgfVxuXG4gICAgICAgICR7c1thLTFdfSA9ICR7c1thLTFdfSAtIDE7XG4gICAgICAgIGlmICgke3NbYS0yXX0gPCAke25bYS0yXX0gJiZcbiAgICAgICAgICAgICR7c1thLTFdfSA8ICR7blthLTFdfSkge1xuICAgICAgICAgIHJlc3VsdC5iID0gZ2V0VmFsdWUoJHtzfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgYH19O2Z1bmN0aW9uICRoKGUsdCxuKXtsZXQgYT1lLmluZGV4T2YodCk7cmV0dXJuIGUubWFwKChyLHMpPT5zPT09YT9gJHtyfSAtICR7bn1gOnIpLmpvaW4oKX1mdW5jdGlvbiBVZihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHtpbnB1dDphfT10LHI9bi50ZXhEYXRhLmdldChhLmRhdGFJZCk7cmV0dXJuIHRhKHtpbnB1dHM6e3g6ci5jb21wbGV4VGVuc29ySW5mb3MuaW1hZ30sYmFja2VuZDpufSl9dmFyIG1uZT17a2VybmVsTmFtZTpfbSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpVZn07ZnVuY3Rpb24gb2MoZSx0LG4pe2xldCBhPWVbMF0uZHR5cGU7aWYoYT09PVwiY29tcGxleDY0XCIpe2xldCBoPWUubWFwKHk9PkZkKHtpbnB1dHM6e2lucHV0Onl9LGJhY2tlbmQ6bn0pKSxtPWUubWFwKHk9PlVmKHtpbnB1dHM6e2lucHV0Onl9LGJhY2tlbmQ6bn0pKSxmPW9jKGgsdCxuKSxnPW9jKG0sdCxuKSxiPSRzKHtpbnB1dHM6e3JlYWw6ZixpbWFnOmd9LGJhY2tlbmQ6bn0pO3JldHVybiBoLmZvckVhY2goeT0+bi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh5KSksbS5mb3JFYWNoKHk9Pm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oeSkpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZiksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhnKSxifWxldCByPW4uc2hvdWxkRXhlY3V0ZU9uQ1BVKGUpO2lmKGE9PT1cInN0cmluZ1wiJiYocj0hMCkscil7bGV0IGg9ZS5tYXAodj0+e2xldCBJPVstMSx3LnNpemVGcm9tU2hhcGUodi5zaGFwZS5zbGljZSh0KSldO3JldHVybiBjZSh7aW5wdXRzOnt4OnZ9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6SX19KX0pLG09aC5tYXAodj0+KHt2YWxzOm4ucmVhZFN5bmModi5kYXRhSWQpLHNoYXBlOnYuc2hhcGV9KSksZj1ULmNvbXB1dGVPdXRTaGFwZShoLm1hcCh2PT52LnNoYXBlKSwxKSxnPWhbMF0uc2hhcGVbMF09PT0xLGI9blEobSxmLGEsZykseT1ULmNvbXB1dGVPdXRTaGFwZShlLm1hcCh2PT52LnNoYXBlKSx0KSx4PW4ubWFrZVRlbnNvckluZm8oeSxhLGIpO3JldHVybiBoLmZvckVhY2godj0+bi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh2KSkseH1sZXQgcz1lLmZpbHRlcihoPT53LnNpemVGcm9tU2hhcGUoaC5zaGFwZSk+MCksaT1HKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OU1wiKSYmc1swXS5zaGFwZS5sZW5ndGg+MTtpZihzLmxlbmd0aD09PTEpe2xldCBoPWk/bmV3IHJyKGVbMF0uc2hhcGUsWXIpOm5ldyB0cyhlWzBdLnNoYXBlLFlyKTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0oaCxlLGEpfWxldCBvPUcoKS5nZXROdW1iZXIoXCJXRUJHTF9NQVhfVEVYVFVSRVNfSU5fU0hBREVSXCIpO2lmKHMubGVuZ3RoPm8pe2xldCBoPVtdO2ZvcihsZXQgZj0wO2Y8cy5sZW5ndGg7Zis9byl7bGV0IGc9cy5zbGljZShmLGYrbyk7aC5wdXNoKG9jKGcsdCxuKSl9bGV0IG09b2MoaCx0LG4pO2ZvcihsZXQgZiBvZiBoKW4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZik7cmV0dXJuIG19aWYoaSl7bGV0IGg9bmV3IGhuZShzLm1hcChtPT5tLnNoYXBlKSx0KTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0oaCxzLGEpfWxldHt0ZW5zb3JzMkQ6bCxvdXRTaGFwZTp1fT1mbmUocyx0LG4pLHA9bmV3IGRuZShsLm1hcChoPT5oLnNoYXBlKSksZD1uLnJ1bldlYkdMUHJvZ3JhbShwLGwsYSk7bC5mb3JFYWNoKGg9Pm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaCkpO2xldCBjPWNlKHtpbnB1dHM6e3g6ZH0sYXR0cnM6e3NoYXBlOnV9LGJhY2tlbmQ6bn0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGQpLGN9ZnVuY3Rpb24gZm5lKGUsdCxuKXtsZXQgYT1ULmNvbXB1dGVPdXRTaGFwZShlLm1hcChyPT5yLnNoYXBlKSx0KTtyZXR1cm57dGVuc29yczJEOmUubWFwKHI9PmNlKHtpbnB1dHM6e3g6cn0sYXR0cnM6e3NoYXBlOlstMSx3LnNpemVGcm9tU2hhcGUoci5zaGFwZS5zbGljZSh0KSldfSxiYWNrZW5kOm59KSksb3V0U2hhcGU6YX19ZnVuY3Rpb24gVUEoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtheGlzOnJ9PWEscz13LnBhcnNlQXhpc1BhcmFtKHIsdFswXS5zaGFwZSlbMF0saT10Lm1hcCh1PT51LnNoYXBlKTtULmFzc2VydFBhcmFtc0NvbnNpc3RlbnQoaSxzKTtsZXQgbz1ULmNvbXB1dGVPdXRTaGFwZSh0Lm1hcCh1PT51LnNoYXBlKSxzKTtpZih3LnNpemVGcm9tU2hhcGUobyk9PT0wKXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKG8sdFswXS5kdHlwZSxbXSk7bGV0IGw9dC5maWx0ZXIodT0+dy5zaXplRnJvbVNoYXBlKHUuc2hhcGUpPjApO3JldHVybiBsLmxlbmd0aD09PTE/dGEoe2lucHV0czp7eDpsWzBdfSxiYWNrZW5kOm59KTpvYyhsLHMsbil9dmFyIGduZT17a2VybmVsTmFtZTpzdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpVQX0sR0E9Y2xhc3N7Y29uc3RydWN0b3IoZSx0PSExLG49bnVsbCxhPSExLHI9ITEpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJXXCJdLHRoaXMub3V0cHV0U2hhcGU9ZS5vdXRTaGFwZTtsZXQgcz1lLnBhZEluZm8udG9wLGk9ZS5wYWRJbmZvLmxlZnQsbz1lLnN0cmlkZUhlaWdodCxsPWUuc3RyaWRlV2lkdGgsdT1lLmRpbGF0aW9uSGVpZ2h0LHA9ZS5kaWxhdGlvbldpZHRoLGQ9ZS5maWx0ZXJIZWlnaHQsYz1lLmZpbHRlcldpZHRoLGg9TWF0aC5mbG9vcihlLmluQ2hhbm5lbHMvNCkqNCxtPWUuaW5DaGFubmVscyU0LGY9ZS5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0xhc3RcIixnPWY/MToyLGI9Zj8yOjMseT1mPzM6MSx4PVwiXCIsdj1cIlwiO24mJihhP3g9YGZsb2F0IGFjdGl2YXRpb24oZmxvYXQgYSkge1xuICAgICAgICAgIGZsb2F0IGIgPSBnZXRQcmVsdUFjdGl2YXRpb25XZWlnaHRzQXRPdXRDb29yZHMoKTtcbiAgICAgICAgICAke259XG4gICAgICAgIH1gOnI/eD1gZmxvYXQgYWN0aXZhdGlvbihmbG9hdCBhKSB7XG4gICAgICAgICAgZmxvYXQgYiA9IGdldExlYWt5cmVsdUFscGhhQXRPdXRDb29yZHMoKTtcbiAgICAgICAgICAke259XG4gICAgICAgIH1gOng9YFxuICAgICAgICAgIGZsb2F0IGFjdGl2YXRpb24oZmxvYXQgeCkge1xuICAgICAgICAgICAgJHtufVxuICAgICAgICAgIH1cbiAgICAgICAgYCx2PVwicmVzdWx0ID0gYWN0aXZhdGlvbihyZXN1bHQpO1wiKTtsZXQgST10P1wicmVzdWx0ICs9IGdldEJpYXNBdE91dENvb3JkcygpO1wiOlwiXCI7dCYmdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJiaWFzXCIpLGEmJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwicHJlbHVBY3RpdmF0aW9uV2VpZ2h0c1wiKSxyJiZ0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcImxlYWt5cmVsdUFscGhhXCIpLHRoaXMudXNlckNvZGU9YFxuICAgICAgJHt4fVxuXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoJHtvfSwgJHtsfSk7XG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoJHtzfSwgJHtpfSk7XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcbiAgICAgICAgaW50IGQyID0gY29vcmRzWyR7eX1dO1xuXG4gICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9XG4gICAgICAgICAgICBpdmVjMihjb29yZHNbJHtnfV0sIGNvb3Jkc1ske2J9XSkgKiBzdHJpZGVzIC0gcGFkcztcbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xuXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGdldCB5KHlSLCB5QywgZDIpLlxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8ICR7ZH07IHdSKyspIHtcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSICogJHt1fTtcblxuICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gJHtlLmluSGVpZ2h0fSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7Y307IHdDKyspIHtcbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0MgKiAke3B9O1xuXG4gICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49ICR7ZS5pbldpZHRofSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpbnQgZDEgPSAwOyBkMSA8ICR7aH07IGQxICs9IDQpIHtcbiAgICAgICAgICAgICAgdmVjNCB3VmFsdWVzID0gdmVjNChcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEsIGQyKSxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEgKyAxLCBkMiksXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxICsgMiwgZDIpLFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSArIDMsIGQyKVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIGlmICgke2Z9KSB7XG4gICAgICAgICAgICAgICAgdmVjNCB4VmFsdWVzID0gdmVjNChcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgZDEpLFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSArIDEpLFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSArIDIpLFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSArIDMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2ZWM0IHhWYWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDEsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDIsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDMsIHhSLCB4QylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgke209PT0xfSkge1xuXG4gICAgICAgICAgICAgIGlmICgke2Z9KSB7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPVxuICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsICR7aH0pICpcbiAgICAgICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsICR7aH0sIGQyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9XG4gICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsICR7aH0sIHhSLCB4QykgKlxuICAgICAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgJHtofSwgZDIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJHttPT09Mn0pIHtcbiAgICAgICAgICAgICAgdmVjMiB3VmFsdWVzID0gdmVjMihcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgJHtofSwgZDIpLFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCAke2h9ICsgMSwgZDIpXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgaWYgKCR7Zn0pIHtcbiAgICAgICAgICAgICAgICB2ZWMyIHhWYWx1ZXMgPSB2ZWMyKFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCAke2h9KSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgJHtofSArIDEpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2ZWMyIHhWYWx1ZXMgPSB2ZWMyKFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgJHtofSwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsICR7aH0gKyAxLCB4UiwgeEMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCR7bT09PTN9KSB7XG4gICAgICAgICAgICAgIHZlYzMgd1ZhbHVlcyA9IHZlYzMoXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsICR7aH0sIGQyKSxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgJHtofSArIDEsIGQyKSxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgJHtofSArIDIsIGQyKVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIGlmICgke2Z9KSB7XG4gICAgICAgICAgICAgICAgdmVjMyB4VmFsdWVzID0gdmVjMyhcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgJHtofSksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsICR7aH0gKyAxKSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgJHtofSArIDIpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2ZWMzIHhWYWx1ZXMgPSB2ZWMzKFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgJHtofSwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsICR7aH0gKyAxLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgJHtofSArIDIsIHhSLCB4QylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmbG9hdCByZXN1bHQgPSBkb3RQcm9kO1xuICAgICAgICAke0l9XG4gICAgICAgICR7dn1cbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgYH19LGJuZT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPWUub3V0U2hhcGU7bGV0IHQ9ZS5wYWRJbmZvLmZyb250LG49ZS5wYWRJbmZvLnRvcCxhPWUucGFkSW5mby5sZWZ0LHI9ZS5zdHJpZGVEZXB0aCxzPWUuc3RyaWRlSGVpZ2h0LGk9ZS5zdHJpZGVXaWR0aCxvPWUuZGlsYXRpb25EZXB0aCxsPWUuZGlsYXRpb25IZWlnaHQsdT1lLmRpbGF0aW9uV2lkdGgscD1lLmZpbHRlckRlcHRoLGQ9ZS5maWx0ZXJIZWlnaHQsYz1lLmZpbHRlcldpZHRoLGg9TWF0aC5mbG9vcihlLmluQ2hhbm5lbHMvNCkqNCxtPWUuaW5DaGFubmVscyU0O3RoaXMudXNlckNvZGU9YFxuICAgICAgY29uc3QgaXZlYzMgc3RyaWRlcyA9IGl2ZWMzKCR7cn0sICR7c30sICR7aX0pO1xuICAgICAgY29uc3QgaXZlYzMgcGFkcyA9IGl2ZWMzKCR7dH0sICR7bn0sICR7YX0pO1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnU7XG5cbiAgICAgICAgaXZlYzMgeEZSQ0Nvcm5lciA9IGl2ZWMzKGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLncpICogc3RyaWRlcyAtIHBhZHM7XG4gICAgICAgIGludCB4RkNvcm5lciA9IHhGUkNDb3JuZXIueDtcbiAgICAgICAgaW50IHhSQ29ybmVyID0geEZSQ0Nvcm5lci55O1xuICAgICAgICBpbnQgeENDb3JuZXIgPSB4RlJDQ29ybmVyLno7XG5cbiAgICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCA/LCBkMSkgd2l0aCB3KDosIDosIDosIGQxLCBkMikgdG8gZ2V0XG4gICAgICAgIC8vIHkoeUYsIHlSLCB5QywgZDIpLiA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGxcbiAgICAgICAgLy8gdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcbiAgICAgICAgZm9yIChpbnQgd0YgPSAwOyB3RiA8ICR7cH07IHdGKyspIHtcbiAgICAgICAgICBpbnQgeEYgPSB4RkNvcm5lciArIHdGICogJHtvfTtcblxuICAgICAgICAgIGlmICh4RiA8IDAgfHwgeEYgPj0gJHtlLmluRGVwdGh9KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgJHtkfTsgd1IrKykge1xuICAgICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UiAqICR7bH07XG5cbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gJHtlLmluSGVpZ2h0fSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7Y307IHdDKyspIHtcbiAgICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqICR7dX07XG5cbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSAke2UuaW5XaWR0aH0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAoaW50IGQxID0gMDsgZDEgPCAke2h9OyBkMSArPSA0KSB7XG4gICAgICAgICAgICAgICAgdmVjNCB4VmFsdWVzID0gdmVjNChcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxKSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMSksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDIpLFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAzKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdmVjNCB3VmFsdWVzID0gdmVjNChcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgZDEsIGQyKSxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgZDEgKyAxLCBkMiksXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIGQxICsgMiwgZDIpLFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBkMSArIDMsIGQyKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICgke209PT0xfSkge1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz1cbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsICR7aH0pICpcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgJHtofSwgZDIpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCR7bT09PTJ9KSB7XG4gICAgICAgICAgICAgICAgdmVjMiB4VmFsdWVzID0gdmVjMihcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsICR7aH0pLFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgJHtofSArIDEpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2ZWMyIHdWYWx1ZXMgPSB2ZWMyKFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCAke2h9LCBkMiksXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsICR7aH0gKyAxLCBkMilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCR7bT09PTN9KSB7XG4gICAgICAgICAgICAgICAgdmVjMyB4VmFsdWVzID0gdmVjMyhcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsICR7aH0pLFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgJHtofSArIDEpLFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgJHtofSArIDIpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2ZWMzIHdWYWx1ZXMgPSB2ZWMzKFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCAke2h9LCBkMiksXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsICR7aH0gKyAxLCBkMiksXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsICR7aH0gKyAyLCBkMilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcbiAgICAgIH1cbiAgICBgfX0sSEE9Y2xhc3N7Y29uc3RydWN0b3IoZSx0PSExLG49bnVsbCxhPSExLHI9ITEpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJXXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMuY3VzdG9tVW5pZm9ybXM9W3tuYW1lOlwicGFkc1wiLHR5cGU6XCJpdmVjMlwifSx7bmFtZTpcInN0cmlkZXNcIix0eXBlOlwiaXZlYzJcIn0se25hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwiaXZlYzJcIn0se25hbWU6XCJpbkRpbXNcIix0eXBlOlwiaXZlYzJcIn1dLHRoaXMub3V0cHV0U2hhcGU9ZS5vdXRTaGFwZSx0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXM9dm4odGhpcy5vdXRwdXRTaGFwZS5sZW5ndGgpO2xldCBzPWUucGFkSW5mby5sZWZ0LGk9ZS5zdHJpZGVXaWR0aCxvPWUuZGlsYXRpb25XaWR0aCxsPWUuZmlsdGVySGVpZ2h0LHU9ZS5maWx0ZXJXaWR0aCxwPXUsZD1gXG4gICAgICAgaW50IHhSOyBpbnQgeEM7IGludCB4Q09mZnNldDtcbiAgICAgICB2ZWM0IHdUZXhlbDsgdmVjNCBwcmV2aW91czsgdmVjNCBmaW5hbDtgO2ZvcihsZXQgZj0wO2Y8dTtmKyspZCs9YFxuICAgICAgICAgICB2ZWM0IHhUZXhlbEMke2YqMn07XG4gICAgICAgICAgIGludCB4VGV4ZWxDJHtmKjJ9UmVhZHk7XG4gICAgICAgICAgIHZlYzQgeFRleGVsQyR7ZioyKzF9O1xuICAgICAgICAgICBpbnQgeFRleGVsQyR7ZioyKzF9UmVhZHk7XG4gICAgICAgICAgIHZlYzQgeEMke2Z9O2A7ZCs9YFxuICAgICBmb3IgKGludCByID0gMDsgciA8ICR7bH07IHIrKykge1xuICAgICAgZm9yIChpbnQgZDEgPSAwOyBkMSA8ICR7ZS5pbkNoYW5uZWxzfTsgZDEgKz0gMikge1xuICAgICAgIGA7Zm9yKGxldCBmPTA7Zjx1O2YrKylkKz1gXG4gICAgICAgICAgIHhUZXhlbEMke2YqMn0gPSB2ZWM0KDAuMCk7XG4gICAgICAgICAgIHhUZXhlbEMke2YqMn1SZWFkeSA9IDA7XG4gICAgICAgICAgIHhUZXhlbEMke2YqMisxfSA9IHZlYzQoMC4wKTtcbiAgICAgICAgICAgeFRleGVsQyR7ZioyKzF9UmVhZHkgPSAwO1xuICAgICAgICAgICB4QyR7Zn0gPSB2ZWM0KDAuMCk7YDtkKz1gXG4gICAgICAgICB4UiA9IHhSQ29ybmVyICsgciAqIGRpbGF0aW9uc1swXTtcbiAgICAgICAgIGlmICh4UiA+PTAgJiYgeFIgPCBpbkRpbXNbMF0pIHtcbiAgICAgICBgO2ZvcihsZXQgZj0wO2Y8KHArMSkvMjtmKyspe2xldCBnPWYqMjtpZihkKz1gXG4gICAgICAgICAgIHhDID0geENDb3JuZXIgKyAke2cqb307XG4gICAgICAgICAgIGAsaT09PTEpe2lmKGc8dSYmKHMlMj09PTE/KGQrPWBcbiAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIDE7XG4gICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgaW5EaW1zWzFdICYmIHhUZXhlbEMke2d9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2d9ID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XG5cbiAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIG1hbnVhbGx5IGNsZWFyIHVudXNlZCBjaGFubmVscyBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAgLy8gd2UncmUgcmVhZGluZyBmcm9tIHJlY3ljbGVkIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ICsgMSA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2d9Lnp3ID0gdmVjMigwLjApO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtnfVJlYWR5ID0gMTtcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgYCxvPT09MSYmZz4wP2QrPWBcbiAgICAgICAgICAgICAgICAgeEMke2d9ID0gdmVjNCh4VGV4ZWxDJHtnLTJ9Lnp3LCB4VGV4ZWxDJHtnfS54eSk7XG4gICAgICAgICAgICAgICAgIGA6ZCs9YFxuICAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAxIC0gMjtcblxuICAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIG1hbnVhbGx5IGNsZWFyIHVudXNlZCBjaGFubmVscyBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSByZWFkaW5nIGZyb20gcmVjeWNsZWQgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCArIDEgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLnp3ID0gdmVjMigwLjApO1xuICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICB4QyR7Z30gPSB2ZWM0KHByZXZpb3VzLnp3LCB4VGV4ZWxDJHtnfS54eSk7XG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgIHhDJHtnfSA9IHZlYzQoMC4wLCAwLjAsIHhUZXhlbEMke2d9Lnh5KTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgYCk6ZCs9YFxuICAgICAgICAgICAgICAgICBpZiAoeEMgPj0gMCAmJiB4QyA8IGluRGltc1sxXSAmJiB4VGV4ZWxDJHtnfVJlYWR5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtnfSA9IGdldFgoYmF0Y2gsIHhSLCB4QywgZDEpO1xuICAgICAgICAgICAgICAgICAgIGlmICh4QyArIDEgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtnfS56dyA9IHZlYzIoMC4wKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Z31SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICB4QyR7Z30gPSB4VGV4ZWxDJHtnfTtcbiAgICAgICAgICAgICAgICAgYCxnKzE8dSkpe2xldCBiPXMlMj09PTA/dy5uZWFyZXN0TGFyZ2VyRXZlbihvKTpvO28lMj09PTAmJnMlMj09PTF8fG8lMiE9PTAmJnMlMiE9PTE/KGQrPWBcbiAgICAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgaW1vZChwYWRzWzFdLCAyKSArICR7Yn07XG5cbiAgICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IGluRGltc1sxXSAmJiB4VGV4ZWxDJHtnKzF9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7ZysxfSA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIG1hbnVhbGx5IGNsZWFyIHVudXNlZCBjaGFubmVscyBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSByZWFkaW5nIGZyb20gcmVjeWNsZWQgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCArIDEgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2crMX0uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtnKzF9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICBgLG8+MT9kKz1gXG4gICAgICAgICAgICAgICAgICAgICB4Q09mZnNldCAtPSAyO1xuICAgICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuICAgICAgICAgICAgICAgICAgICAgIHhDJHtnKzF9ID0gdmVjNChwcmV2aW91cy56dywgeFRleGVsQyR7ZysxfS54eSk7XG4gICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHhDJHtnKzF9ID0gdmVjNCgwLjAsIDAuMCwgeFRleGVsQyR7ZysxfS54eSk7XG4gICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICBgOmQrPWBcbiAgICAgICAgICAgICAgICAgICAgIHhDJHtnKzF9ID0gdmVjNCh4VGV4ZWxDJHtnfS56dywgeFRleGVsQyR7ZysxfS54eSk7XG4gICAgICAgICAgICAgICAgICAgICBgKTpiPT09MT9kKz1gXG4gICAgICAgICAgICAgICAgICAgICB4QyR7ZysxfSA9IHhUZXhlbEMke2d9O1xuICAgICAgICAgICAgICAgICAgICAgYDpkKz1gXG4gICAgICAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgJHtifTtcblxuICAgICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7ZysxfVJlYWR5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7ZysxfSA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuICAgICAgICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2crMX0uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7ZysxfVJlYWR5ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgeEMke2crMX0gPSB4VGV4ZWxDJHtnKzF9O1xuICAgICAgICAgICAgICAgICAgICAgYH19ZWxzZSBnPHUmJihzJTI9PT0xPyhkKz1gXG4gICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAxIC0gc3RyaWRlc1sxXTtcbiAgICAgICAgICAgICAgICAgaWYoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IGluRGltc1sxXSAmJiB4VGV4ZWxDJHtnfVJlYWR5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtnfSA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgY2xlYXIgdW51c2VkIGNoYW5uZWxzIGluIGNhc2VcbiAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSByZWFkaW5nIGZyb20gcmVjeWNsZWQgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Z30uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2d9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgaWYoeEMgKyAxID49IDAgJiYgeEMgKyAxIDwgaW5EaW1zWzFdICYmIHhUZXhlbEMke2crMX1SZWFkeSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgeFRleGVsQyR7ZysxfSA9IGdldFgoYmF0Y2gsIHhSLCB4QyArIDEsIGQxKTtcbiAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIG1hbnVhbGx5IGNsZWFyIHVudXNlZCBjaGFubmVscyBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAgLy8gd2UncmUgcmVhZGluZyBmcm9tIHJlY3ljbGVkIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgICAgaWYgKHhDICsgMiA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2crMX0uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2crMX1SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICB4QyR7Z30gPSB2ZWM0KHhUZXhlbEMke2d9Lnp3LCB4VGV4ZWxDJHtnKzF9Lnp3KTtcbiAgICAgICAgICAgICAgIGAsZysxPHUmJihkKz1gXG4gICAgICAgICAgICAgICAgICAgZmluYWwgPSB2ZWM0KDAuMCk7XG4gICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIDEgKyBzdHJpZGVzWzFdO1xuICAgICAgICAgICAgICAgICAgIGlmKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgIGZpbmFsID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIHhDJHtnKzF9ID0gdmVjNCh4VGV4ZWxDJHtnKzF9Lnh5LCBmaW5hbC54eSk7XG4gICAgICAgICAgICAgICAgIGApKTooZCs9YFxuICAgICAgICAgICAgICAgICBpZih4QyA+PSAwICYmIHhDIDwgaW5EaW1zWzFdICYmIHhUZXhlbEMke2d9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2d9ID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICAgICAgICAgaWYgKHhDICsgMSA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2d9Lnp3ID0gdmVjMigwLjApO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtnfVJlYWR5ID0gMTtcbiAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyBzdHJpZGVzWzFdO1xuICAgICAgICAgICAgICAgICBpZih4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgaW5EaW1zWzFdICYmIHhUZXhlbEMke2crMX1SZWFkeSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgeFRleGVsQyR7ZysxfSA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuICAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCArIDEgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtnKzF9Lnp3ID0gdmVjMigwLik7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2crMX1SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICB4QyR7Z30gPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2d9Lnh5LCB4VGV4ZWxDJHtnKzF9Lnh5KTtcbiAgICAgICAgICAgICAgIGAsZysxPHUmJihkKz1gXG4gICAgICAgICAgICAgICAgICAgeEMke2crMX0gPSB2ZWM0KHhUZXhlbEMke2d9Lnp3LCB4VGV4ZWxDJHtnKzF9Lnp3KTtcbiAgICAgICAgICAgICAgICAgYCkpKTtnPHUmJihkKz1gXG4gICAgICAgICAgICAgd1RleGVsID0gZ2V0VyhyLCAke2d9LCBkMSwgZDIpO1xuICAgICAgICAgICAgIGRvdFByb2QgKz0geEMke2d9Lnh4enogKiB2ZWM0KHdUZXhlbC54eSwgd1RleGVsLnh5KTtcbiAgICAgICAgICAgICBpZihkMSArIDEgPCAke2UuaW5DaGFubmVsc30pIHtcbiAgICAgICAgICAgICAgIGRvdFByb2QgKz0geEMke2d9Lnl5d3cgKiB2ZWM0KHdUZXhlbC56dywgd1RleGVsLnp3KTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgIGAsZysxPHUmJihkKz1gXG4gICAgICAgICAgICAgICB3VGV4ZWwgPSBnZXRXKHIsICR7ZysxfSwgZDEsIGQyKTtcbiAgICAgICAgICAgICAgIGRvdFByb2QgKz0geEMke2crMX0ueHh6eiAqIHZlYzQod1RleGVsLnh5LCB3VGV4ZWwueHkpO1xuICAgICAgICAgICAgICAgaWYoZDEgKyAxIDwgJHtlLmluQ2hhbm5lbHN9KSB7XG4gICAgICAgICAgICAgICAgIGRvdFByb2QgKz0geEMke2crMX0ueXl3dyAqIHZlYzQod1RleGVsLnp3LCB3VGV4ZWwuencpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIGApKX1kKz1gXG4gICAgIH1cbiAgIGAsZCs9YFxuICAgICB9XG4gICBgLGQrPWBcbiAgICAgfVxuICAgYDtsZXQgYz1cIlwiLGg9XCJcIjtuJiYoYT9jPWB2ZWM0IGFjdGl2YXRpb24odmVjNCBhKSB7XG4gICAgICAgICAgIHZlYzQgYiA9IGdldFByZWx1QWN0aXZhdGlvbldlaWdodHNBdE91dENvb3JkcygpO1xuICAgICAgICAgICAke259XG4gICAgICAgICB9YDpyP2M9YHZlYzQgYWN0aXZhdGlvbih2ZWM0IGEpIHtcbiAgICAgICAgICAgdmVjNCBiID0gZ2V0TGVha3lyZWx1QWxwaGFBdE91dENvb3JkcygpO1xuICAgICAgICAgICAke259XG4gICAgICAgICB9YDpjPWB2ZWM0IGFjdGl2YXRpb24odmVjNCB4KSB7XG4gICAgICAgICAgICR7bn1cbiAgICAgICAgIH1gLGg9XCJyZXN1bHQgPSBhY3RpdmF0aW9uKHJlc3VsdCk7XCIpO2xldCBtPXQ/XCJyZXN1bHQgKz0gZ2V0Qmlhc0F0T3V0Q29vcmRzKCk7XCI6XCJcIjt0JiZ0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcImJpYXNcIiksYSYmdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJwcmVsdUFjdGl2YXRpb25XZWlnaHRzXCIpLHImJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwibGVha3lyZWx1QWxwaGFcIiksdGhpcy51c2VyQ29kZT1gXG4gICAgICAgJHtjfVxuXG4gICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcbiAgICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy55eiAqIHN0cmlkZXMgLSBwYWRzO1xuICAgICAgICAgaW50IGQyID0gY29vcmRzLnc7XG4gICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcbiAgICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xuXG4gICAgICAgICAvL2ludGlhbGl6ZSBkb3RQcm9kIHdpdGggYSBzbWFsbCBlcHNpbG9uIHNlZW1zIHRvIHJlZHVjZSBHUFUgYWNjdXJhY3kgbG9zcy5cbiAgICAgICAgIHZlYzQgZG90UHJvZCA9IHZlYzQoMC4wMDAwMDAwMDAwMDAwMDEpO1xuXG4gICAgICAgICAke2R9XG5cbiAgICAgICAgIHZlYzQgcmVzdWx0ID0gZG90UHJvZCAtIHZlYzQoMC4wMDAwMDAwMDAwMDAwMDEpO1xuICAgICAgICAgJHttfVxuICAgICAgICAgJHtofVxuICAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XG4gICAgICAgfVxuICAgICBgfX0seW5lPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5jdXN0b21Vbmlmb3Jtcz1be25hbWU6XCJpbnB1dFNoYXBlXCIsdHlwZTpcIml2ZWM0XCJ9LHtuYW1lOlwicGFkXCIsdHlwZTpcIml2ZWMyXCJ9LHtuYW1lOlwic3RyaWRlXCIsdHlwZTpcIml2ZWMyXCJ9LHtuYW1lOlwiZGlsYXRpb25cIix0eXBlOlwiaXZlYzJcIn0se25hbWU6XCJpbkNoYW5uZWxzXCIsdHlwZTpcImludFwifSx7bmFtZTpcIml0ZW1zUGVyQmxvY2tSb3dcIix0eXBlOlwiaW50XCJ9LHtuYW1lOlwib3V0V2lkdGhcIix0eXBlOlwiaW50XCJ9XSx0aGlzLm91dHB1dFNoYXBlPWUsdGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zPXZuKHRoaXMub3V0cHV0U2hhcGUubGVuZ3RoKTtsZXR7ZGF0YUZvcm1hdDpufT10LGE9RW4oKSxyPW49PT1cImNoYW5uZWxzTGFzdFwiLHM9cj8xOjIsaT1yPzI6MyxvPXRoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz9cImlmKGJsb2NrSW5kZXggPCBvdXRTaGFwZVsyXSAmJiBwb3MgPCBvdXRTaGFwZVsxXSkge1wiOmBpZihibG9ja0luZGV4IDwgJHtlWzJdfSAmJiBwb3MgPCAke2VbMV19KSB7YCxsPVwiXCI7Zm9yKGxldCB1PTA7dTw9MTt1KyspZm9yKGxldCBwPTA7cDw9MTtwKyspbCs9YFxuICAgICAgICAgIGJsb2NrSW5kZXggPSByYy56ICsgJHtwfTtcbiAgICAgICAgICBwb3MgPSByYy55ICsgJHt1fTtcblxuICAgICAgICAgICR7b31cbiAgICAgICAgICAgIG9mZnNldFkgPSBpbnQoYmxvY2tJbmRleCAvIG91dFdpZHRoKSAqIHN0cmlkZVswXSAtIHBhZFswXTtcbiAgICAgICAgICAgIGQwID0gb2Zmc2V0WSArIGRpbGF0aW9uWzBdICogKHBvcyAvIGl0ZW1zUGVyQmxvY2tSb3cpO1xuXG4gICAgICAgICAgICBpZihkMCA8IGlucHV0U2hhcGVbJHtzfV0gJiYgZDAgPj0gMCkge1xuICAgICAgICAgICAgICAvLyBVc2UgY3VzdG9tIGltb2QgaW5zdGVhZCBtb2QuIE9uIEludGVsIEdQVSwgbW9kIG1heSBnZW5lcmF0ZVxuICAgICAgICAgICAgICAvLyB1bmV4cGVjdGVkIHZhbHVlLlxuICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzL2lzc3Vlcy81NDQ3XG4gICAgICAgICAgICAgIG9mZnNldFggPSBpbW9kKGJsb2NrSW5kZXgsIG91dFdpZHRoKSAqIHN0cmlkZVsxXSAtIHBhZFsxXTtcbiAgICAgICAgICAgICAgZDEgPSBvZmZzZXRYICsgZGlsYXRpb25bMV0gKiAoaW1vZChwb3MsIGl0ZW1zUGVyQmxvY2tSb3cpIC9cbiAgICAgICAgICAgICAgICAgIGluQ2hhbm5lbHMpO1xuXG4gICAgICAgICAgICAgIGlmKGQxIDwgaW5wdXRTaGFwZVske2l9XSAmJiBkMSA+PSAwKSB7XG5cbiAgICAgICAgICAgICAgICBjaCA9IGltb2QocG9zLCBpbkNoYW5uZWxzKTtcblxuICAgICAgICAgICAgICAgIGlmICgke3J9KSB7XG4gICAgICAgICAgICAgICAgICBpbm5lckRpbXMgPSB2ZWMyKGQxLCBjaCk7XG4gICAgICAgICAgICAgICAgICByZXN1bHRbJHt1KjIrcH1dID0gZ2V0Q2hhbm5lbChcbiAgICAgICAgICAgICAgICAgICAgZ2V0QShyYy54LCBkMCwgaW50KGlubmVyRGltcy54KSxcbiAgICAgICAgICAgICAgICAgICAgaW50KGlubmVyRGltcy55KSksIGlubmVyRGltcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlubmVyRGltcyA9IHZlYzIoZDAsIGQxKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFske3UqMitwfV0gPSBnZXRDaGFubmVsKFxuICAgICAgICAgICAgICAgICAgICBnZXRBKHJjLngsIGNoLCBpbnQoaW5uZXJEaW1zLngpLFxuICAgICAgICAgICAgICAgICAgICBpbnQoaW5uZXJEaW1zLnkpKSwgaW5uZXJEaW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGA7dGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWMzIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG5cbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDApO1xuXG4gICAgICAgIGludCBibG9ja0luZGV4LCBwb3MsIG9mZnNldFksIGQwLCBvZmZzZXRYLCBkMSwgY2g7XG4gICAgICAgIHZlYzIgaW5uZXJEaW1zO1xuXG4gICAgICAgICR7bH1cblxuICAgICAgICAke2Eub3V0cHV0fSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24gbW0oZSx0KXtsZXQgbj1lLmxlbmd0aDtyZXR1cm4gbj49Mz90P1suLi5lLnNsaWNlKDAsLTMpLGVbbi0zXSplW24tMl0sZVtuLTFdXTpbLi4uZS5zbGljZSgwLC0zKSxlW24tM10sZVtuLTJdKmVbbi0xXV06IXQmJm49PT0xJiZlWzBdPjE/W2VbMF0sMV06bnVsbH1mdW5jdGlvbiBqQSh7eDplLGZpbHRlcjp0LGNvbnZJbmZvOm4sYmFja2VuZDphLGJpYXM6cj1udWxsLHByZWx1QWN0aXZhdGlvbldlaWdodHM6cz1udWxsLGxlYWt5cmVsdUFscGhhOmk9MCxhY3RpdmF0aW9uOm89bnVsbH0pe2xldCBsPWUuc2hhcGUsdT1hLnRleERhdGEuZ2V0KGUuZGF0YUlkKSxwPW4uaW5DaGFubmVscyxkPWxbMF0qbFsxXSpsWzJdLGM9bi5vdXRDaGFubmVscyxoPW4uZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNMYXN0XCIsbT0hMSxmPSExLGcsYj1bXTtpZihzIT1udWxsKXtsZXQgeT1tbShzLnNoYXBlLGgpO3khPW51bGwmJihzPWNlKHtpbnB1dHM6e3g6c30sYmFja2VuZDphLGF0dHJzOntzaGFwZTp5fX0pLGIucHVzaChzKSl9aWYociE9bnVsbCl7bGV0IHk9bW0oci5zaGFwZSxoKTt5IT1udWxsJiYocj1jZSh7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6YSxhdHRyczp7c2hhcGU6eX19KSxiLnB1c2gocikpfWlmKCEoKGQ9PT0xfHxjPT09MSkmJnA+TEEpJiZ1LmlzUGFja2VkJiZoJiZ1LnRleHR1cmUhPW51bGwmJmxbMl0lMiE9PTAmJncuYXJyYXlzRXF1YWwodS5zaGFwZS5zbGljZSgtMyksbC5zbGljZSgtMykpKXtsZXQgeT1sWzBdKmxbMV0qKGxbMl0rMSkseD17ZGF0YUlkOmUuZGF0YUlkLHNoYXBlOlsxLHksbi5pbkNoYW5uZWxzXSxkdHlwZTplLmR0eXBlfSx2PXUuc2hhcGU7dS5zaGFwZT11LnNoYXBlLnNsaWNlKCksdS5zaGFwZVt1LnNoYXBlLmxlbmd0aC0yXSsrLHcuYXNzZXJ0KFRjKHUuc2hhcGUseC5zaGFwZSksKCk9PmBwYWNrZWQgcmVzaGFwZSAke3Uuc2hhcGV9IHRvICR7eC5zaGFwZX0gaXNuJ3QgZnJlZWApO2xldCBJPWNlKHtpbnB1dHM6e3g6dH0sYmFja2VuZDphLGF0dHJzOntzaGFwZTpbMSxuLmluQ2hhbm5lbHMsbi5vdXRDaGFubmVsc119fSk7Yi5wdXNoKEkpO2xldCBOPWhtKHthOngsYjpJLGJhY2tlbmQ6YSx0cmFuc3Bvc2VBOm0sdHJhbnNwb3NlQjpmLGJpYXM6cixhY3RpdmF0aW9uOm8scHJlbHVBY3RpdmF0aW9uV2VpZ2h0czpzLGxlYWt5cmVsdUFscGhhOml9KSxDPWEudGV4RGF0YS5nZXQoTi5kYXRhSWQpO3cuYXNzZXJ0KEMuaXNQYWNrZWQsKCk9PlwiYmF0Y2hNYXRNdWwgcmVzdWx0IGlzIGV4cGVjdGVkIHRvIGJlIHBhY2tlZFwiKSx1LnNoYXBlPXYsQy5zaGFwZT1uLm91dFNoYXBlLGc9dGEoe2lucHV0czp7eDpOfSxiYWNrZW5kOmF9KSxnLnNoYXBlPW4ub3V0U2hhcGUsYi5wdXNoKE4pfWVsc2V7bGV0IHk9bi5vdXRIZWlnaHQqbi5vdXRXaWR0aCx4PWNlKHtpbnB1dHM6e3g6ZX0sYmFja2VuZDphLGF0dHJzOntzaGFwZTpoP1tuLmJhdGNoU2l6ZSx5LG4uaW5DaGFubmVsc106W24uYmF0Y2hTaXplLG4uaW5DaGFubmVscyx5XX19KSx2PWNlKHtpbnB1dHM6e3g6dH0sYmFja2VuZDphLGF0dHJzOntzaGFwZTpbMSxuLmluQ2hhbm5lbHMsbi5vdXRDaGFubmVsc119fSksST1obSh7YTpoP3g6dixiOmg/djp4LHRyYW5zcG9zZUE6IWgsdHJhbnNwb3NlQjpmLGJhY2tlbmQ6YSxiaWFzOnIsYWN0aXZhdGlvbjpvLHByZWx1QWN0aXZhdGlvbldlaWdodHM6cyxsZWFreXJlbHVBbHBoYTppfSk7Zz1jZSh7aW5wdXRzOnt4Okl9LGJhY2tlbmQ6YSxhdHRyczp7c2hhcGU6bi5vdXRTaGFwZX19KSxiLnB1c2goeCksYi5wdXNoKHYpLGIucHVzaChJKX1mb3IobGV0IHkgb2YgYilhLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHkpO3JldHVybiBnfWZ1bmN0aW9uIHFBKHt4OmUsZmlsdGVyOnQsY29udkluZm86bixiYWNrZW5kOmEsYmlhczpyPW51bGwscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czpzPW51bGwsbGVha3lyZWx1QWxwaGE6aT0wLGFjdGl2YXRpb246bz1udWxsfSl7bGV0e2ZpbHRlcldpZHRoOmwsZmlsdGVySGVpZ2h0OnUsaW5DaGFubmVsczpwLG91dFdpZHRoOmQsb3V0SGVpZ2h0OmMsZGF0YUZvcm1hdDpofT1uLG09aD09PVwiY2hhbm5lbHNMYXN0XCIsZj1sKnUqcCxnPWMqZCxiPVtuLmJhdGNoU2l6ZSxmLGddLHk9ITAseD0hMSx2PVtdO2lmKHMhPW51bGwpe2xldCBLPW1tKHMuc2hhcGUsbSk7SyE9bnVsbCYmKHM9Y2Uoe2lucHV0czp7eDpzfSxiYWNrZW5kOmEsYXR0cnM6e3NoYXBlOkt9fSksdi5wdXNoKHMpKX1pZihyIT1udWxsKXtsZXQgSz1tbShyLnNoYXBlLG0pO0shPW51bGwmJihyPWNlKHtpbnB1dHM6e3g6cn0sYmFja2VuZDphLGF0dHJzOntzaGFwZTpLfX0pLHYucHVzaChyKSl9bGV0IEk9Y2Uoe2lucHV0czp7eDp0fSxiYWNrZW5kOmEsYXR0cnM6e3NoYXBlOlsxLGYsdy5zaXplRnJvbVNoYXBlKHQuc2hhcGUpL2ZdfX0pO3YucHVzaChJKTtsZXQgTj1uZXcgeW5lKGIsbiksQz1bZS5zaGFwZSxbbi5wYWRJbmZvLnRvcCxuLnBhZEluZm8ubGVmdF0sW24uc3RyaWRlSGVpZ2h0LG4uc3RyaWRlV2lkdGhdLFtuLmRpbGF0aW9uSGVpZ2h0LG4uZGlsYXRpb25XaWR0aF0sW24uaW5DaGFubmVsc10sW24uZmlsdGVyV2lkdGgqbi5pbkNoYW5uZWxzXSxbbi5vdXRXaWR0aF1dLF89YS5ydW5XZWJHTFByb2dyYW0oTixbZV0sXCJmbG9hdDMyXCIsQyksRj1jZSh7aW5wdXRzOnt4Ol99LGJhY2tlbmQ6YSxhdHRyczp7c2hhcGU6Yn19KTt2LnB1c2goXyksdi5wdXNoKEYpO2xldCBEPXIhPW51bGwsJD1zIT1udWxsLFM9bz09PVwibGVha3lyZWx1XCIsTT1vP0NjKG8sITApOm51bGwsQj1uZXcgUEEobT9GLnNoYXBlOkkuc2hhcGUsbT9JLnNoYXBlOkYuc2hhcGUsbT9bbi5iYXRjaFNpemUsZyxuLm91dENoYW5uZWxzXTpbbi5iYXRjaFNpemUsbi5vdXRDaGFubmVscyxnXSx5LHgsRCxNLCQsUyksVT1tP1tGLEldOltJLEZdO2lmKHImJlUucHVzaChyKSwkJiZVLnB1c2gocyksUyl7bGV0IEs9YS5tYWtlVGVuc29ySW5mbyhbXSxcImZsb2F0MzJcIix3LmNyZWF0ZVNjYWxhclZhbHVlKGksXCJmbG9hdDMyXCIpKTtVLnB1c2goSyksdi5wdXNoKEspfWxldCBIPWEucnVuV2ViR0xQcm9ncmFtKEIsVSxcImZsb2F0MzJcIikscT1jZSh7aW5wdXRzOnt4Okh9LGJhY2tlbmQ6YSxhdHRyczp7c2hhcGU6bi5vdXRTaGFwZX19KTt2LnB1c2goSCk7Zm9yKGxldCBLIG9mIHYpYS5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhLKTtyZXR1cm4gcX1mdW5jdGlvbiB4bmUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsZmlsdGVyOnN9PXQse3N0cmlkZXM6aSxwYWQ6byxkYXRhRm9ybWF0OmwsZGlsYXRpb25zOnUsZGltUm91bmRpbmdNb2RlOnB9PWEsZD1ULmNvbnZlcnRDb252MkREYXRhRm9ybWF0KGwpLGM9VC5jb21wdXRlQ29udjJESW5mbyhyLnNoYXBlLHMuc2hhcGUsaSx1LG8scCwhMSxkKSxoO2lmKGMuZmlsdGVySGVpZ2h0PT09MSYmYy5maWx0ZXJXaWR0aD09PTEmJmMuZGlsYXRpb25IZWlnaHQ9PT0xJiZjLmRpbGF0aW9uV2lkdGg9PT0xJiZjLnN0cmlkZUhlaWdodD09PTEmJmMuc3RyaWRlV2lkdGg9PT0xJiYoYy5wYWRJbmZvLnR5cGU9PT1cIlNBTUVcInx8Yy5wYWRJbmZvLnR5cGU9PT1cIlZBTElEXCIpKWg9akEoe3g6cixmaWx0ZXI6cyxjb252SW5mbzpjLGJhY2tlbmQ6bn0pO2Vsc2UgaWYoYy5zdHJpZGVXaWR0aDw9MiYmZD09PVwiY2hhbm5lbHNMYXN0XCImJkcoKS5nZXRCb29sKFwiV0VCR0xfRVhQX0NPTlZcIikpe2xldCBmPW5ldyBIQShjKSxnPVtbYy5wYWRJbmZvLnRvcCxjLnBhZEluZm8ubGVmdF0sW2Muc3RyaWRlSGVpZ2h0LGMuc3RyaWRlV2lkdGhdLFtjLmRpbGF0aW9uSGVpZ2h0LGMuZGlsYXRpb25XaWR0aF0sW2MuaW5IZWlnaHQsYy5pbldpZHRoXV07aD1uLnJ1bldlYkdMUHJvZ3JhbShmLFtyLHNdLFwiZmxvYXQzMlwiLGcpfWVsc2UgaWYoRygpLmdldEJvb2woXCJXRUJHTF9DT05WX0lNMkNPTFwiKSloPXFBKHt4OnIsZmlsdGVyOnMsY29udkluZm86YyxiYWNrZW5kOm59KTtlbHNle2xldCBmPW5ldyBHQShjKTtoPW4ucnVuV2ViR0xQcm9ncmFtKGYsW3Isc10sXCJmbG9hdDMyXCIpfWxldCBtPWNlKHtpbnB1dHM6e3g6aH0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpjLm91dFNoYXBlfX0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGgpLG19dmFyIHZuZT17a2VybmVsTmFtZTpQaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzp4bmV9LHduZT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT1lLmZpbHRlclNoYXBlO2xldCB0PWUuc3RyaWRlSGVpZ2h0LG49ZS5zdHJpZGVXaWR0aCxhPWUucGFkSW5mby50b3Ascj1lLnBhZEluZm8ubGVmdCxzPWUuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNMYXN0XCI7dGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgd1IgPSBjb29yZHMueDtcbiAgICAgICAgaW50IHdDID0gY29vcmRzLnk7XG4gICAgICAgIGludCBkMSA9IGNvb3Jkcy56O1xuICAgICAgICBpbnQgZDIgPSBjb29yZHMudztcblxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIGR5KDosIDosIGQyKSB0byBnZXQgZHcod1IsIHdDLCBkMSwgZDIpLlxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcblxuICAgICAgICBmb3IgKGludCBiID0gMDsgYiA8ICR7ZS5iYXRjaFNpemV9OyBiKyspIHtcbiAgICAgICAgICBmb3IgKGludCB5UiA9IDA7IHlSIDwgJHtlLm91dEhlaWdodH07IHlSKyspIHtcbiAgICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiAke3R9IC0gJHthfTtcblxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSAke2UuaW5IZWlnaHR9KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGludCB5QyA9IDA7IHlDIDwgJHtlLm91dFdpZHRofTsgeUMrKykge1xuICAgICAgICAgICAgICBpbnQgeEMgPSB3QyArIHlDICogJHtufSAtICR7cn07XG5cbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSAke2UuaW5XaWR0aH0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICR7cz9gZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIHlSLCB5QywgZDIpO1xuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIHhSLCB4QywgZDEpO1xuICAgICAgICAgICAgICBkb3RQcm9kICs9ICh4VmFsdWUgKiBkeVZhbHVlKTtgOmBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgZDIsIHlSLCB5Qyk7XG4gICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldFgoYiwgZDEsIHhSLCB4Qyk7XG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gKHhWYWx1ZSAqIGR5VmFsdWUpO2B9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcbiAgICAgIH1cbiAgICBgfX0sa25lPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPWUuaW5TaGFwZTtsZXQgdD1lLmZpbHRlckhlaWdodCxuPWUuZmlsdGVyV2lkdGgsYT1lLnN0cmlkZUhlaWdodCxyPWUuc3RyaWRlV2lkdGgscz1lLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzTGFzdFwiLGk9dC0xLWUucGFkSW5mby50b3Asbz1uLTEtZS5wYWRJbmZvLmxlZnQsbD1zPzE6Mix1PXM/MjozLHA9cz8zOjE7dGhpcy51c2VyQ29kZT1gXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoJHtpfSwgJHtvfSk7XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcbiAgICAgICAgaW50IGQxID0gY29vcmRzWyR7cH1dO1xuXG4gICAgICAgIGl2ZWMyIGR5Q29ybmVyID0gaXZlYzIoY29vcmRzWyR7bH1dLCBjb29yZHNbJHt1fV0pIC0gcGFkcztcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5Q29ybmVyLng7XG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xuXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQyKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBjb21wdXRlIGR4KHhSLCB4QywgZDEpLlxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8ICR7dH07IHdSKyspIHtcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyAke2F9LjA7XG5cbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke2Uub3V0SGVpZ2h0fS4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xuXG4gICAgICAgICAgaW50IHdSUGVybSA9ICR7dH0gLSAxIC0gd1I7XG5cbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgJHtufTsgd0MrKykge1xuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gJHtyfS4wO1xuXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke2Uub3V0V2lkdGh9LjAgfHxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcblxuICAgICAgICAgICAgaW50IHdDUGVybSA9ICR7bn0gLSAxIC0gd0M7XG5cbiAgICAgICAgICAgIGZvciAoaW50IGQyID0gMDsgZDIgPCAke2Uub3V0Q2hhbm5lbHN9OyBkMisrKSB7XG5cbiAgICAgICAgICAgICAgaWYgKCR7c30pIHtcbiAgICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXREeShiYXRjaCwgaWR5UiwgaWR5QywgZDIpO1xuICAgICAgICAgICAgICAgIGZsb2F0IHdWYWx1ZSA9IGdldFcod1JQZXJtLCB3Q1Blcm0sIGQxLCBkMik7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0RHkoYmF0Y2gsIGQyLCBpZHlSLCBpZHlDKTtcbiAgICAgICAgICAgICAgICBmbG9hdCB3VmFsdWUgPSBnZXRXKHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbHVlICogd1ZhbHVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xuICAgICAgfVxuICAgIGB9fSxJbmU9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9ZS5maWx0ZXJTaGFwZTtsZXQgdD1lLnN0cmlkZURlcHRoLG49ZS5zdHJpZGVIZWlnaHQsYT1lLnN0cmlkZVdpZHRoLHI9ZS5wYWRJbmZvLmZyb250LHM9ZS5wYWRJbmZvLnRvcCxpPWUucGFkSW5mby5sZWZ0O3RoaXMudXNlckNvZGU9YFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IHdGID0gY29vcmRzLng7XG4gICAgICAgIGludCB3UiA9IGNvb3Jkcy55O1xuICAgICAgICBpbnQgd0MgPSBjb29yZHMuejtcbiAgICAgICAgaW50IGQxID0gY29vcmRzLnc7XG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy51O1xuXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XG5cbiAgICAgICAgZm9yIChpbnQgYiA9IDA7IGIgPCAke2UuYmF0Y2hTaXplfTsgYisrKSB7XG4gICAgICAgICAgZm9yIChpbnQgeUYgPSAwOyB5RiA8ICR7ZS5vdXREZXB0aH07IHlGKyspIHtcbiAgICAgICAgICAgIGludCB4RiA9IHdGICsgeUYgKiAke3R9IC0gJHtyfTtcblxuICAgICAgICAgICAgaWYgKHhGIDwgMCB8fCB4RiA+PSAke2UuaW5EZXB0aH0pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaW50IHlSID0gMDsgeVIgPCAke2Uub3V0SGVpZ2h0fTsgeVIrKykge1xuICAgICAgICAgICAgICBpbnQgeFIgPSB3UiArIHlSICogJHtufSAtICR7c307XG5cbiAgICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSAke2UuaW5IZWlnaHR9KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3IgKGludCB5QyA9IDA7IHlDIDwgJHtlLm91dFdpZHRofTsgeUMrKykge1xuICAgICAgICAgICAgICAgIGludCB4QyA9IHdDICsgeUMgKiAke2F9IC0gJHtpfTtcblxuICAgICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gJHtlLmluV2lkdGh9KSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgeUYsIHlSLCB5QywgZDIpO1xuICAgICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldFgoYiwgeEYsIHhSLCB4QywgZDEpO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gKHhWYWx1ZSAqIGR5VmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcbiAgICAgIH1cbiAgICBgfX0sU25lPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPWUuaW5TaGFwZTtsZXQgdD1lLmZpbHRlckRlcHRoLG49ZS5maWx0ZXJIZWlnaHQsYT1lLmZpbHRlcldpZHRoLHI9ZS5zdHJpZGVEZXB0aCxzPWUuc3RyaWRlSGVpZ2h0LGk9ZS5zdHJpZGVXaWR0aCxvPXQtMS1lLnBhZEluZm8uZnJvbnQsbD1uLTEtZS5wYWRJbmZvLnRvcCx1PWEtMS1lLnBhZEluZm8ubGVmdDt0aGlzLnVzZXJDb2RlPWBcbiAgICAgIGNvbnN0IGl2ZWMzIHBhZHMgPSBpdmVjMygke299LCAke2x9LCAke3V9KTtcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XG4gICAgICAgIGludCBkMSA9IGNvb3Jkcy51O1xuXG5cbiAgICAgICAgaXZlYzMgZHlDb3JuZXIgPSBpdmVjMyhjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy53KSAtIHBhZHM7XG4gICAgICAgIGludCBkeUZDb3JuZXIgPSBkeUNvcm5lci54O1xuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueTtcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLno7XG5cbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcbiAgICAgICAgZm9yIChpbnQgd0YgPSAwOyB3RiA8ICR7dH07IHdGKyspIHtcbiAgICAgICAgICBmbG9hdCBkeUYgPSBmbG9hdChkeUZDb3JuZXIgKyB3RikgLyAke3J9LjA7XG5cbiAgICAgICAgICBpZiAoZHlGIDwgMC4wIHx8IGR5RiA+PSAke2Uub3V0RGVwdGh9LjAgfHwgZnJhY3QoZHlGKSA+IDAuMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGludCBpZHlGID0gaW50KGR5Rik7XG5cbiAgICAgICAgICBpbnQgd0ZQZXJtID0gJHt0fSAtIDEgLSB3RjtcblxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCAke259OyB3UisrKSB7XG4gICAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyAke3N9LjA7XG5cbiAgICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7ZS5vdXRIZWlnaHR9LjAgfHxcbiAgICAgICAgICAgICAgZnJhY3QoZHlSKSA+IDAuMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XG5cbiAgICAgICAgICAgIGludCB3UlBlcm0gPSAke259IC0gMSAtIHdSO1xuXG4gICAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgJHthfTsgd0MrKykge1xuICAgICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyAke2l9LjA7XG5cbiAgICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gJHtlLm91dFdpZHRofS4wIHx8XG4gICAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcblxuICAgICAgICAgICAgICBpbnQgd0NQZXJtID0gJHthfSAtIDEgLSB3QztcblxuICAgICAgICAgICAgICBmb3IgKGludCBkMiA9IDA7IGQyIDwgJHtlLm91dENoYW5uZWxzfTsgZDIrKykge1xuICAgICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldER5KGJhdGNoLCBpZHlGLCBpZHlSLCBpZHlDLCBkMik7XG4gICAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3RlBlcm0sIHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbHVlICogd1ZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24gTm5lKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyLGR5OnN9PXQse3N0cmlkZXM6aSxwYWQ6byxkYXRhRm9ybWF0OmwsZGltUm91bmRpbmdNb2RlOnUsZmlsdGVyU2hhcGU6cH09YSxkPVQuY29udmVydENvbnYyRERhdGFGb3JtYXQobCksYz1ULmNvbXB1dGVDb252MkRJbmZvKHIuc2hhcGUscCxpLDEsbyx1LCExLGQpLGg9bmV3IHduZShjKTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0oaCxbcixzXSxcImZsb2F0MzJcIil9dmFyIFRuZT17a2VybmVsTmFtZTprbSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpObmV9LENuZT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIixcIldcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5jdXN0b21Vbmlmb3Jtcz1be25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInZlYzJcIn1dLHRoaXMub3V0cHV0U2hhcGU9ZS5pblNoYXBlLHRoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz12bih0aGlzLm91dHB1dFNoYXBlLmxlbmd0aCk7bGV0IHQ9ZS5maWx0ZXJIZWlnaHQsbj1lLmZpbHRlcldpZHRoLGE9dC0xLWUucGFkSW5mby50b3Ascj1uLTEtZS5wYWRJbmZvLmxlZnQ7dGhpcy51c2VyQ29kZT1gXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoJHthfSwgJHtyfSk7XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcbiAgICAgICAgaW50IGQxID0gY29vcmRzWzNdO1xuXG4gICAgICAgIGl2ZWMyIGR5Q29ybmVyID0gaXZlYzIoY29vcmRzWzFdLCBjb29yZHNbMl0pIC0gcGFkcztcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5Q29ybmVyLng7XG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xuXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCAke3R9OyB3UisrKSB7XG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gc3RyaWRlc1swXTtcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke2Uub3V0SGVpZ2h0fS4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xuICAgICAgICAgIGludCB3UlBlcm0gPSAke3R9IC0gMSAtIHdSO1xuXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7bn07IHdDKyspIHtcbiAgICAgICAgICAgIGludCB3Q1Blcm0gPSAke259IC0gMSAtIHdDO1xuXG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBzdHJpZGVzWzFdO1xuICAgICAgICAgICAgYm9vbCBpZHlDVmFsID0gKGR5QyA+PSAwLjApICYmIChkeUMgPCAke2Uub3V0V2lkdGh9LjApXG4gICAgICAgICAgICAgICYmIChmcmFjdChkeUMpID09IDAuMCk7XG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xuXG4gICAgICAgICAgICBmbG9hdCBkeUMyID0gZmxvYXQoZHlDQ29ybmVyICsgd0MgKyAxKSAvIHN0cmlkZXNbMV07XG4gICAgICAgICAgICBib29sIGlkeUNWYWwyID0gKGR5QzIgPj0gMC4wKSAmJiAoZHlDMiA8ICR7ZS5vdXRXaWR0aH0uMClcbiAgICAgICAgICAgICAgJiYgKGZyYWN0KGR5QzIpID09IDAuMCk7XG4gICAgICAgICAgICBpbnQgaWR5QzIgPSBpbnQoZHlDMik7XG5cbiAgICAgICAgICAgIGlmIChpZHlDVmFsICYmIGlkeUNWYWwyKSB7XG4gICAgICAgICAgICAgIGZvciAoaW50IGQyID0gMDsgZDIgPCAke2Uub3V0Q2hhbm5lbHN9OyBkMiArPSAyKSB7XG4gICAgICAgICAgICAgICAgdmVjNCB3VmFsdWUgPSBnZXRXKHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgIHZlYzQgZHlTYW1wbGUgPSBnZXREeShiYXRjaCwgaWR5UiwgaWR5QywgZDIpO1xuICAgICAgICAgICAgICAgIHZlYzQgZHlTYW1wbGUyID0gKGlkeUMgLyAyID09IGlkeUMyIC8gMikgP1xuICAgICAgICAgICAgICAgICAgZHlTYW1wbGUgOiBnZXREeShiYXRjaCwgaWR5UiwgaWR5QzIsIGQyKTtcblxuICAgICAgICAgICAgICAgIHZlYzIgZHlWYWx1ZSA9IG1vZChmbG9hdChpZHlDKSwgMi4pID09IDAuID9cbiAgICAgICAgICAgICAgICAgIGR5U2FtcGxlLnh5IDogZHlTYW1wbGUuenc7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lnh5ICs9IHZlYzIoZG90KGR5VmFsdWUsIHdWYWx1ZS54eSksXG4gICAgICAgICAgICAgICAgICBkb3QoZHlWYWx1ZSwgd1ZhbHVlLnp3KSk7XG5cbiAgICAgICAgICAgICAgICBkeVZhbHVlID0gbW9kKGZsb2F0KGlkeUMyKSwgMi4pID09IDAuID9cbiAgICAgICAgICAgICAgICAgIGR5U2FtcGxlMi54eSA6IGR5U2FtcGxlMi56dztcbiAgICAgICAgICAgICAgICByZXN1bHQuencgKz0gdmVjMihkb3QoZHlWYWx1ZSwgd1ZhbHVlLnh5KSxcbiAgICAgICAgICAgICAgICAgIGRvdChkeVZhbHVlLCB3VmFsdWUuencpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpZHlDVmFsKSB7XG4gICAgICAgICAgICAgIGZvciAoaW50IGQyID0gMDsgZDIgPCAke2Uub3V0Q2hhbm5lbHN9OyBkMiArPSAyKSB7XG4gICAgICAgICAgICAgICAgdmVjNCB3VmFsdWUgPSBnZXRXKHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgIHZlYzQgZHlTYW1wbGUgPSBnZXREeShiYXRjaCwgaWR5UiwgaWR5QywgZDIpO1xuICAgICAgICAgICAgICAgIHZlYzIgZHlWYWx1ZSA9IG1vZChmbG9hdChpZHlDKSwgMi4pID09IDAuID9cbiAgICAgICAgICAgICAgICAgIGR5U2FtcGxlLnh5IDogZHlTYW1wbGUuenc7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lnh5ICs9IHZlYzIoZG90KGR5VmFsdWUsIHdWYWx1ZS54eSksXG4gICAgICAgICAgICAgICAgICBkb3QoZHlWYWx1ZSwgd1ZhbHVlLnp3KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWR5Q1ZhbDIpIHtcbiAgICAgICAgICAgICAgZm9yIChpbnQgZDIgPSAwOyBkMiA8ICR7ZS5vdXRDaGFubmVsc307IGQyICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2ZWM0IHdWYWx1ZSA9IGdldFcod1JQZXJtLCB3Q1Blcm0sIGQxLCBkMik7XG4gICAgICAgICAgICAgICAgdmVjNCBkeVNhbXBsZSA9IGdldER5KGJhdGNoLCBpZHlSLCBpZHlDMiwgZDIpO1xuICAgICAgICAgICAgICAgIHZlYzIgZHlWYWx1ZSA9IG1vZChmbG9hdChpZHlDMiksIDIuKSA9PSAwLiA/XG4gICAgICAgICAgICAgICAgICBkeVNhbXBsZS54eSA6IGR5U2FtcGxlLnp3O1xuICAgICAgICAgICAgICAgIHJlc3VsdC56dyArPSB2ZWMyKGRvdChkeVZhbHVlLCB3VmFsdWUueHkpLFxuICAgICAgICAgICAgICAgICAgZG90KGR5VmFsdWUsIHdWYWx1ZS56dykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xuICAgICAgfVxuICAgIGB9fTtmdW5jdGlvbiBFbmUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtkeTpyLGZpbHRlcjpzfT10LHtpbnB1dFNoYXBlOmksc3RyaWRlczpvLHBhZDpsLGRhdGFGb3JtYXQ6dSxkaW1Sb3VuZGluZ01vZGU6cH09YSxkPVQuY29udmVydENvbnYyRERhdGFGb3JtYXQodSksYz1ULmNvbXB1dGVDb252MkRJbmZvKGkscy5zaGFwZSxvLDEsbCxwLCExLGQpO2lmKEcoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19DT05WMkRUUkFOU1BPU0VcIikmJmQ9PT1cImNoYW5uZWxzTGFzdFwiKXtsZXQgaD1bW2Muc3RyaWRlSGVpZ2h0LGMuc3RyaWRlV2lkdGhdXSxtPW5ldyBDbmUoYyk7cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKG0sW3Isc10sXCJmbG9hdDMyXCIsaCl9ZWxzZXtsZXQgaD1uZXcga25lKGMpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShoLFtyLHNdLFwiZmxvYXQzMlwiKX19dmFyIF9uZT17a2VybmVsTmFtZTpMaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpFbmV9O2Z1bmN0aW9uIEFuZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cixmaWx0ZXI6c309dCx7c3RyaWRlczppLHBhZDpvLGRpbGF0aW9uczpsfT1hLHU9VC5jb21wdXRlQ29udjNESW5mbyhyLnNoYXBlLHMuc2hhcGUsaSxsLG8pLHA9bmV3IGJuZSh1KTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0ocCxbcixzXSxcImZsb2F0MzJcIil9dmFyIEZuZT17a2VybmVsTmFtZTp6aSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpBbmV9O2Z1bmN0aW9uICRuZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cixkeTpzfT10LHtzdHJpZGVzOmkscGFkOm8sZmlsdGVyU2hhcGU6bH09YSx1PVQuY29tcHV0ZUNvbnYzREluZm8oci5zaGFwZSxsLGksMSxvKSxwPW5ldyBJbmUodSk7cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKHAsW3Isc10sXCJmbG9hdDMyXCIpfXZhciBEbmU9e2tlcm5lbE5hbWU6aXUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6JG5lfTtmdW5jdGlvbiBSbmUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtkeTpyLGZpbHRlcjpzfT10LHtwYWQ6aSxzdHJpZGVzOm8saW5wdXRTaGFwZTpsfT1hLHU9VC5jb21wdXRlQ29udjNESW5mbyhsLHMuc2hhcGUsbywxLGkpLHA9bmV3IFNuZSh1KTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0ocCxbcixzXSxcImZsb2F0MzJcIil9dmFyIE1uZT17a2VybmVsTmFtZTpvdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpSbmV9LE9uZT1tcCtgXG4gIHJldHVybiBjb3MoeCk7XG5gLFBuZT1gXG4gIHZlYzQgcmVzdWx0ID0gY29zKHgpO1xuICBidmVjNCBpc05hTiA9IGlzbmFuKHgpO1xuICAke1FvfVxuICByZXR1cm4gcmVzdWx0O1xuYCxMbmU9WmUoe29wU25pcHBldDpPbmUscGFja2VkT3BTbmlwcGV0OlBuZX0pLHpuZT17a2VybmVsTmFtZTpXaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpMbmV9LFduZT1gXG4gIGZsb2F0IGUyeCA9IGV4cCgteCk7XG4gIHJldHVybiAoZTJ4ICsgMS4wIC8gZTJ4KSAvIDIuMDtcbmAsQm5lPVplKHtvcFNuaXBwZXQ6V25lfSksVm5lPXtrZXJuZWxOYW1lOkJpLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkJuZX0sVW5lPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuLGEscil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkltYWdlXCIsXCJCb3hlc1wiLFwiQm94SW5kXCJdLHRoaXMub3V0cHV0U2hhcGU9W107bGV0W3MsaSxvLGxdPWUsW3VdPXQsW3AsZF09bjt0aGlzLm91dHB1dFNoYXBlPVt1LHAsZCxsXTtsZXQgYz1hPT09XCJiaWxpbmVhclwiPzE6MCxbaCxtXT1bYCR7aS0xfS4wYCxgJHtvLTF9LjBgXSxbZixnLGJdPXA+MT9bYCR7KGktMSkvKHAtMSl9YCxcIih5Mi15MSkgKiBoZWlnaHRfcmF0aW9cIixgeTEqJHtofSArIGZsb2F0KHkpKihoZWlnaHRfc2NhbGUpYF06W1wiMC4wXCIsXCIwLjBcIixgMC41ICogKHkxK3kyKSAqICR7aH1gXSxbeSx4LHZdPWQ+MT9bYCR7KG8tMSkvKGQtMSl9YCxcIih4Mi14MSkgKiB3aWR0aF9yYXRpb1wiLGB4MSoke219ICsgZmxvYXQoeCkqKHdpZHRoX3NjYWxlKWBdOltcIjAuMFwiLFwiMC4wXCIsYDAuNSAqICh4MSt4MikgKiAke219YF07dGhpcy51c2VyQ29kZT1gXG4gICAgICBjb25zdCBmbG9hdCBoZWlnaHRfcmF0aW8gPSBmbG9hdCgke2Z9KTtcbiAgICAgIGNvbnN0IGZsb2F0IHdpZHRoX3JhdGlvID0gZmxvYXQoJHt5fSk7XG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcbiAgICAgICAgaW50IHkgPSBjb29yZHNbMV07XG4gICAgICAgIGludCB4ID0gY29vcmRzWzJdO1xuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcblxuICAgICAgICAvLyBnZXQgYm94IHZhbHNcbiAgICAgICAgZmxvYXQgeTEgPSBnZXRCb3hlcyhiLDApO1xuICAgICAgICBmbG9hdCB4MSA9IGdldEJveGVzKGIsMSk7XG4gICAgICAgIGZsb2F0IHkyID0gZ2V0Qm94ZXMoYiwyKTtcbiAgICAgICAgZmxvYXQgeDIgPSBnZXRCb3hlcyhiLDMpO1xuXG4gICAgICAgIC8vIGdldCBpbWFnZSBpbiBiYXRjaCBpbmRleFxuICAgICAgICBpbnQgYkluZCA9IHJvdW5kKGdldEJveEluZChiKSk7XG4gICAgICAgIGlmKGJJbmQgPCAwIHx8IGJJbmQgPj0gJHtzfSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsb2F0IGhlaWdodF9zY2FsZSA9ICR7Z307XG4gICAgICAgIGZsb2F0IHdpZHRoX3NjYWxlID0gJHt4fTtcblxuICAgICAgICBmbG9hdCBpbl95ID0gJHtifTtcbiAgICAgICAgaWYoIGluX3kgPCAwLjAgfHwgaW5feSA+ICR7aH0gKSB7XG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KCR7cn0pKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmxvYXQgaW5feCA9ICR7dn07XG4gICAgICAgIGlmKCBpbl94IDwgMC4wIHx8IGluX3ggPiAke219ICkge1xuICAgICAgICAgIHNldE91dHB1dChmbG9hdCgke3J9KSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmVjMiBzb3VyY2VGcmFjSW5kZXhDUiA9IHZlYzIoaW5feCxpbl95KTtcbiAgICAgICAgaWYoJHtjfSA9PSAxKSB7XG4gICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZm91ciBpbnRlZ2VyIGluZGljZXMuXG4gICAgICAgICAgaXZlYzIgc291cmNlRmxvb3JDUiA9IGl2ZWMyKHNvdXJjZUZyYWNJbmRleENSKTtcbiAgICAgICAgICBpdmVjMiBzb3VyY2VDZWlsQ1IgPSBpdmVjMihjZWlsKHNvdXJjZUZyYWNJbmRleENSKSk7XG5cbiAgICAgICAgICBmbG9hdCB0b3BMZWZ0ID0gZ2V0SW1hZ2UoYiwgc291cmNlRmxvb3JDUi55LCBzb3VyY2VGbG9vckNSLngsIGQpO1xuICAgICAgICAgIGZsb2F0IGJvdHRvbUxlZnQgPSBnZXRJbWFnZShiLCBzb3VyY2VDZWlsQ1IueSwgc291cmNlRmxvb3JDUi54LCBkKTtcbiAgICAgICAgICBmbG9hdCB0b3BSaWdodCA9IGdldEltYWdlKGIsIHNvdXJjZUZsb29yQ1IueSwgc291cmNlQ2VpbENSLngsIGQpO1xuICAgICAgICAgIGZsb2F0IGJvdHRvbVJpZ2h0ID0gZ2V0SW1hZ2UoYiwgc291cmNlQ2VpbENSLnksIHNvdXJjZUNlaWxDUi54LCBkKTtcblxuICAgICAgICAgIHZlYzIgZnJhY0NSID0gc291cmNlRnJhY0luZGV4Q1IgLSB2ZWMyKHNvdXJjZUZsb29yQ1IpO1xuXG4gICAgICAgICAgZmxvYXQgdG9wID0gdG9wTGVmdCArICh0b3BSaWdodCAtIHRvcExlZnQpICogZnJhY0NSLng7XG4gICAgICAgICAgZmxvYXQgYm90dG9tID0gYm90dG9tTGVmdCArIChib3R0b21SaWdodCAtIGJvdHRvbUxlZnQpICogZnJhY0NSLng7XG4gICAgICAgICAgZmxvYXQgbmV3VmFsdWUgPSB0b3AgKyAoYm90dG9tIC0gdG9wKSAqIGZyYWNDUi55O1xuICAgICAgICAgIHNldE91dHB1dChuZXdWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29vcmRpbmF0b3JzIG9mIG5lYXJlc3QgbmVpZ2hib3IgcG9pbnQuXG4gICAgICAgICAgaXZlYzIgc291cmNlTmVhcmVzdENSID0gaXZlYzIoZmxvb3IoXG4gICAgICAgICAgICBzb3VyY2VGcmFjSW5kZXhDUiArIHZlYzIoMC41LDAuNSkpKTtcbiAgICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IGdldEltYWdlKGIsIHNvdXJjZU5lYXJlc3RDUi55LCBzb3VyY2VOZWFyZXN0Q1IueCwgZCk7XG4gICAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGB9fSxHbmU9ZT0+e2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7aW1hZ2U6cixib3hlczpzLGJveEluZDppfT10LHtjcm9wU2l6ZTpvLG1ldGhvZDpsLGV4dHJhcG9sYXRpb25WYWx1ZTp1fT1hLHA9bmV3IFVuZShyLnNoYXBlLHMuc2hhcGUsbyxsLHUpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShwLFtyLHMsaV0sXCJmbG9hdDMyXCIpfSxIbmU9e2tlcm5lbE5hbWU6dXUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6R25lfSxfYzsoZnVuY3Rpb24oZSl7ZS5Qcm9kPVwiKlwiLGUuU3VtPVwiK1wifSkoX2N8fChfYz17fSkpO3ZhciBnUz1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixhKXt0aGlzLm9wPWUsdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMuY3VzdG9tVW5pZm9ybXM9W3tuYW1lOlwiaW5kZXhcIix0eXBlOlwiZmxvYXRcIn1dO2xldCByPXRoaXMub3V0cHV0U2hhcGUubGVuZ3RoLHM9dGhpcy5vcD09PV9jLlByb2Q/XCIxLjBcIjpcIjAuMFwiLGk9bj9zOmBnZXRYKCR7YlMocixcImNvb3Jkc1wiLHRoaXMub3ApfSlgLG89dGhpcy5vdXRwdXRTaGFwZVt0aGlzLm91dHB1dFNoYXBlLmxlbmd0aC0xXSxsPVwiXCIsdT1cIlwiO24/KGw9YT9gZW5kICE9ICR7by0xfWA6XCJlbmQgIT0gMFwiLHU9YT9cImVuZCArIDFcIjpcImVuZCAtIDFcIik6KGw9YT9gZW5kICsgcG93MiA8ICR7b31gOlwiZW5kID49IHBvdzJcIix1PWE/XCJlbmQgKyBwb3cyXCI6XCJlbmQgLSBwb3cyXCIpLHRoaXMudXNlckNvZGU9YFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAke2h0KHIpfSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGVuZCA9ICR7eVMocixcImNvb3Jkc1wiLHRoaXMub3ApfTtcbiAgICAgICAgZmxvYXQgdmFsID0gJHtpfTtcbiAgICAgICAgaW50IHBvdzIgPSBpbnQocG93KDIuMCwgaW5kZXgpKTtcbiAgICAgICAgaWYgKCR7bH0pIHtcbiAgICAgICAgICBpbnQgaWR4ID0gJHt1fTtcbiAgICAgICAgICAke3lTKHIsXCJjb29yZHNcIix0aGlzLm9wKX0gPSBpZHg7XG4gICAgICAgICAgdmFsICR7dGhpcy5vcH09IGdldFgoJHtiUyhyLFwiY29vcmRzXCIsdGhpcy5vcCl9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRPdXRwdXQodmFsKTtcbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24gYlMoZSx0LG4pe2lmKGU9PT0xKXJldHVybmAke3R9YDtpZihlPT09MilyZXR1cm5gJHt0fS54LCAke3R9LnlgO2lmKGU9PT0zKXJldHVybmAke3R9LngsICR7dH0ueSwgJHt0fS56YDtpZihlPT09NClyZXR1cm5gJHt0fS54LCAke3R9LnksICR7dH0ueiwgJHt0fS53YDt0aHJvdyBuZXcgRXJyb3IoYEN1bXVsYXRpdmUgJHtufSBmb3IgcmFuayAke2V9IGlzIG5vdCB5ZXQgc3VwcG9ydGVkYCl9ZnVuY3Rpb24geVMoZSx0LG4pe2lmKGU9PT0xKXJldHVybmAke3R9YDtpZihlPT09MilyZXR1cm5gJHt0fS55YDtpZihlPT09MylyZXR1cm5gJHt0fS56YDtpZihlPT09NClyZXR1cm5gJHt0fS53YDt0aHJvdyBuZXcgRXJyb3IoYEN1bXVsYXRpdmUgJHtufSBmb3IgcmFuayAke2V9IGlzIG5vdCB5ZXQgc3VwcG9ydGVkYCl9ZnVuY3Rpb24gS0EoZSx0LG4sYSxyLHMpe2xldCBpPXQuc2hhcGUubGVuZ3RoLG89VC5nZXRBeGVzUGVybXV0YXRpb24oW2FdLGkpLGw9dDtvIT1udWxsJiYobD1Tbih7aW5wdXRzOnt4OnR9LGJhY2tlbmQ6bixhdHRyczp7cGVybTpvfX0pKTtsZXQgdT1ULmdldElubmVyTW9zdEF4ZXMoMSxpKVswXTtpZih1IT09aS0xKXRocm93IG5ldyBFcnJvcihgV2ViR0wgY3VtcHJvZCBzaGFkZXIgZXhwZWN0cyBhbiBpbm5lci1tb3N0IGF4aXM9JHt0LnNoYXBlLmxlbmd0aC0xfSBidXQgZ290IGF4aXM9JHthfWApO2xldCBwPWwuc2hhcGVbdV0sZD10YSh7aW5wdXRzOnt4Omx9LGJhY2tlbmQ6bn0pO2ZvcihsZXQgYz0wO2M8PU1hdGguY2VpbChNYXRoLmxvZzIocCkpLTE7YysrKXtsZXQgaD1uZXcgZ1MoZSxsLnNoYXBlLCExLHMpLG09W1tjXV0sZj1kO2Q9bi5ydW5XZWJHTFByb2dyYW0oaCxbZF0sZC5kdHlwZSxtKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGYpfWlmKHIpe2xldCBjPW5ldyBnUyhlLGwuc2hhcGUscixzKSxoPWQ7ZD1uLnJ1bldlYkdMUHJvZ3JhbShjLFtkXSxkLmR0eXBlKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGgpfWlmKG8hPW51bGwpe2xldCBjPVQuZ2V0VW5kb0F4ZXNQZXJtdXRhdGlvbihvKSxoPVNuKHtpbnB1dHM6e3g6ZH0sYmFja2VuZDpuLGF0dHJzOntwZXJtOmN9fSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZCksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhsKSxofXJldHVybiBkfWZ1bmN0aW9uIGpuZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7YXhpczpzLGV4Y2x1c2l2ZTppLHJldmVyc2U6b309YTtyZXR1cm4gS0EoX2MuUHJvZCxyLG4scyxpLG8pfXZhciBxbmU9e2tlcm5lbE5hbWU6bHUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6am5lfTtmdW5jdGlvbiBLbmUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2F4aXM6cyxleGNsdXNpdmU6aSxyZXZlcnNlOm99PWE7cmV0dXJuIEtBKF9jLlN1bSxyLG4scyxpLG8pfXZhciBYbmU9e2tlcm5lbE5hbWU6VmksYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6S25lfTtmdW5jdGlvbiBZbmUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsd2VpZ2h0czpzfT10LHtzaXplOmksYmluYXJ5T3V0cHV0Om99PWE7aWYoci5zaGFwZS5sZW5ndGg9PT0xKXtsZXQgbD1uLnJlYWRTeW5jKHIuZGF0YUlkKSx1PW4ucmVhZFN5bmMocy5kYXRhSWQpLHA9VEEobCx1LHMuZHR5cGUscy5zaGFwZSxpKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhbaV0scy5kdHlwZSxwKX1lbHNlIGlmKHIuc2hhcGUubGVuZ3RoPT09Mil7bGV0IGw9bi5idWZmZXJTeW5jKHIpLHU9bi5idWZmZXJTeW5jKHMpLHA9SjkobCx1LGksbyk7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8ocC5zaGFwZSxzLmR0eXBlLHAudmFsdWVzKX10aHJvdyBuZXcgRXJyb3IoYEVycm9yIGluIGRlbnNlQmluY291bnQ6IGlucHV0IG11c3QgYmUgYXQgbW9zdCByYW5rIDIsIGJ1dCBnb3QgcmFuayR7ci5zaGFwZS5sZW5ndGh9LmApfXZhciBabmU9e2tlcm5lbE5hbWU6UGMsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6WW5lfSxKbmU9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT1lLHRoaXMuYmxvY2tTaXplPXQsdGhpcy5kYXRhRm9ybWF0PW4sdGhpcy51c2VyQ29kZT1gXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcbiAgICAgIGludCBoID0gJHt0aGlzLmdldEhlaWdodENvb3JkU3RyaW5nKCl9O1xuICAgICAgaW50IHcgPSAke3RoaXMuZ2V0V2lkdGhDb29yZFN0cmluZygpfTtcbiAgICAgIGludCBkID0gJHt0aGlzLmdldERlcHRoQ29vcmRTdHJpbmcoKX07XG5cbiAgICAgIGludCBpbl9oID0gaCAvICR7dH07XG4gICAgICBpbnQgb2Zmc2V0X2ggPSBpbW9kKGgsICR7dH0pO1xuICAgICAgaW50IGluX3cgPSB3IC8gJHt0fTtcbiAgICAgIGludCBvZmZzZXRfdyA9IGltb2QodywgJHt0fSk7XG4gICAgICBpbnQgb2Zmc2V0X2QgPSAob2Zmc2V0X2ggKiAke3R9ICsgb2Zmc2V0X3cpICpcbiAgICAgICAgJHt0aGlzLmdldE91dHB1dERlcHRoU2l6ZSgpfTtcbiAgICAgIGludCBpbl9kID0gZCArIG9mZnNldF9kO1xuXG4gICAgICBmbG9hdCByZXN1bHQgPSAke3RoaXMuZ2V0SW5wdXRTYW1wbGluZ1N0cmluZygpfTtcbiAgICAgIHNldE91dHB1dChyZXN1bHQpO1xuICAgIH1cbiAgYH1nZXRIZWlnaHRDb29yZFN0cmluZygpe3JldHVybiB0aGlzLmRhdGFGb3JtYXQ9PT1cIk5IV0NcIj9cImNvb3Jkc1sxXVwiOlwiY29vcmRzWzJdXCJ9Z2V0V2lkdGhDb29yZFN0cmluZygpe3JldHVybiB0aGlzLmRhdGFGb3JtYXQ9PT1cIk5IV0NcIj9cImNvb3Jkc1syXVwiOlwiY29vcmRzWzNdXCJ9Z2V0RGVwdGhDb29yZFN0cmluZygpe3JldHVybiB0aGlzLmRhdGFGb3JtYXQ9PT1cIk5IV0NcIj9cImNvb3Jkc1szXVwiOlwiY29vcmRzWzFdXCJ9Z2V0T3V0cHV0RGVwdGhTaXplKCl7cmV0dXJuIHRoaXMuZGF0YUZvcm1hdD09PVwiTkhXQ1wiP3RoaXMub3V0cHV0U2hhcGVbM106dGhpcy5vdXRwdXRTaGFwZVsxXX1nZXRJbnB1dFNhbXBsaW5nU3RyaW5nKCl7cmV0dXJuIHRoaXMuZGF0YUZvcm1hdD09PVwiTkhXQ1wiP1wiZ2V0WChiLCBpbl9oLCBpbl93LCBpbl9kKVwiOlwiZ2V0WChiLCBpbl9kLCBpbl9oLCBpbl93KVwifX07ZnVuY3Rpb24gUW5lKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtibG9ja1NpemU6cyxkYXRhRm9ybWF0Oml9PWEsbz1yLnNoYXBlWzBdLGw9aT09PVwiTkhXQ1wiP3Iuc2hhcGVbMV06ci5zaGFwZVsyXSx1PWk9PT1cIk5IV0NcIj9yLnNoYXBlWzJdOnIuc2hhcGVbM10scD1pPT09XCJOSFdDXCI/ci5zaGFwZVszXTpyLnNoYXBlWzFdLGQ9bCpzLGM9dSpzLGg9cC8ocypzKSxtPWk9PT1cIk5IV0NcIj9bbyxkLGMsaF06W28saCxkLGNdLGY9bmV3IEpuZShtLHMsaSk7cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKGYsW3JdLHIuZHR5cGUpfXZhciBlYWU9e2tlcm5lbE5hbWU6cHUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6UW5lfSxYQT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQ9ITEsbj1udWxsLGE9ITEscj0hMSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIldcIl0sdGhpcy5jdXN0b21Vbmlmb3Jtcz1be25hbWU6XCJwYWRzXCIsdHlwZTpcIml2ZWMyXCJ9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJpdmVjMlwifSx7bmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJpdmVjMlwifSx7bmFtZTpcImluRGltc1wiLHR5cGU6XCJpdmVjMlwifV0sdGhpcy5vdXRwdXRTaGFwZT1lLm91dFNoYXBlLHRoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz12bih0aGlzLm91dHB1dFNoYXBlLmxlbmd0aCk7bGV0IHM9ZS5maWx0ZXJIZWlnaHQsaT1lLmZpbHRlcldpZHRoLG89ZS5vdXRDaGFubmVscy9lLmluQ2hhbm5lbHMsbD1cIlwiLHU9XCJcIjtuJiYoYT9sPWBmbG9hdCBhY3RpdmF0aW9uKGZsb2F0IGEpIHtcbiAgICAgICAgICBmbG9hdCBiID0gZ2V0UHJlbHVBY3RpdmF0aW9uV2VpZ2h0c0F0T3V0Q29vcmRzKCk7XG4gICAgICAgICAgJHtufVxuICAgICAgICB9YDpyP2w9YGZsb2F0IGFjdGl2YXRpb24oZmxvYXQgYSkge1xuICAgICAgICAgIGZsb2F0IGIgPSBnZXRMZWFreXJlbHVBbHBoYUF0T3V0Q29vcmRzKCk7XG4gICAgICAgICAgJHtufVxuICAgICAgICB9YDpsPWBcbiAgICAgICAgICBmbG9hdCBhY3RpdmF0aW9uKGZsb2F0IHgpIHtcbiAgICAgICAgICAgICR7bn1cbiAgICAgICAgICB9XG4gICAgICAgIGAsdT1cInJlc3VsdCA9IGFjdGl2YXRpb24ocmVzdWx0KTtcIik7bGV0IHA9dD9cInJlc3VsdCArPSBnZXRCaWFzQXRPdXRDb29yZHMoKTtcIjpcIlwiO3QmJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwiYmlhc1wiKSxhJiZ0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcInByZWx1QWN0aXZhdGlvbldlaWdodHNcIiksciYmdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJsZWFreXJlbHVBbHBoYVwiKSx0aGlzLnVzZXJDb2RlPWBcbiAgICAgICR7bH1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XG4gICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy55eiAqIHN0cmlkZXMgLSBwYWRzO1xuICAgICAgICBpbnQgZDIgPSBjb29yZHMudztcbiAgICAgICAgaW50IGQxID0gZDIgLyAke299O1xuICAgICAgICBpbnQgcSA9IGQyIC0gZDEgKiAke299O1xuXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xuICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcblxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIHcoOiwgOiwgZDEsIHEpIHRvIGdldCB5KHlSLCB5QywgZDIpLlxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcbiAgICAgICAgLy8gVE8gRE8oZHNtaWxrb3YpOiBGbGF0dGVuIHRoZSB0d28gZm9yIGxvb3BzIGFuZCB2ZWM0IHRoZSBvcGVyYXRpb25zLlxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgJHtzfTsgd1IrKykge1xuICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1IgKiBkaWxhdGlvbnNbMF07XG5cbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IGluRGltc1swXSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7aX07IHdDKyspIHtcbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0MgKiBkaWxhdGlvbnNbMV07XG5cbiAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmbG9hdCB4VmFsID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICBmbG9hdCB3VmFsID0gZ2V0Vyh3Uiwgd0MsIGQxLCBxKTtcbiAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbCAqIHdWYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gZG90UHJvZDtcbiAgICAgICAgJHtwfVxuICAgICAgICAke3V9XG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xuICAgICAgfVxuICAgIGB9fSxZQT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQ9ITEsbj1udWxsLGE9ITEscj0hMSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIldcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5jdXN0b21Vbmlmb3Jtcz1be25hbWU6XCJwYWRzXCIsdHlwZTpcIml2ZWMyXCJ9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJpdmVjMlwifSx7bmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJpdmVjMlwifSx7bmFtZTpcImluRGltc1wiLHR5cGU6XCJpdmVjMlwifV0sdGhpcy5vdXRwdXRTaGFwZT1lLm91dFNoYXBlLHRoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz12bih0aGlzLm91dHB1dFNoYXBlLmxlbmd0aCk7bGV0IHM9ZS5vdXRDaGFubmVscy9lLmluQ2hhbm5lbHMsaT1lLnBhZEluZm8ubGVmdCxvPWUuc3RyaWRlV2lkdGgsbD1lLmRpbGF0aW9uV2lkdGgsdT1lLmZpbHRlckhlaWdodCxwPWUuZmlsdGVyV2lkdGgsZD1wLGM9YFxuICAgICAgaW50IHhSOyBpbnQgeEM7IGludCB4Q09mZnNldDtcbiAgICAgIHZlYzQgd1RleGVsOyB2ZWM0IHByZXZpb3VzOyB2ZWM0IGZpbmFsO2A7Zm9yKGxldCBnPTA7ZzxwO2crKyljKz1gXG4gICAgICAgICAgdmVjNCB4VGV4ZWxDJHtnKjJ9O1xuICAgICAgICAgIGludCB4VGV4ZWxDJHtnKjJ9UmVhZHk7XG4gICAgICAgICAgdmVjNCB4VGV4ZWxDJHtnKjIrMX07XG4gICAgICAgICAgaW50IHhUZXhlbEMke2cqMisxfVJlYWR5O1xuICAgICAgICAgIHZlYzQgeEMke2d9O2A7Yys9YFxuICAgIGZvciAoaW50IHIgPSAwOyByIDwgJHt1fTsgcisrKSB7XG4gICAgICBgO2ZvcihsZXQgZz0wO2c8cDtnKyspYys9YFxuICAgICAgICAgIHhUZXhlbEMke2cqMn0gPSB2ZWM0KDAuMCk7XG4gICAgICAgICAgeFRleGVsQyR7ZyoyfVJlYWR5ID0gMDtcbiAgICAgICAgICB4VGV4ZWxDJHtnKjIrMX0gPSB2ZWM0KDAuMCk7XG4gICAgICAgICAgeFRleGVsQyR7ZyoyKzF9UmVhZHkgPSAwO1xuICAgICAgICAgIHhDJHtnfSA9IHZlYzQoMC4wKTtgO2MrPWBcbiAgICAgICAgeFIgPSB4UkNvcm5lciArIHIgKiBkaWxhdGlvbnNbMF07XG4gICAgICAgIGlmICh4UiA+PTAgJiYgeFIgPCBpbkRpbXNbMF0pIHtcbiAgICAgIGA7Zm9yKGxldCBnPTA7ZzwoZCsxKS8yO2crKyl7bGV0IGI9ZyoyO2lmKGMrPWBcbiAgICAgICAgICB4QyA9IHhDQ29ybmVyICsgJHtiKmx9O1xuICAgICAgICAgIGAsbz09PTEpe2lmKGI8cCYmKGklMj09PTE/KGMrPWBcbiAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgMTtcbiAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IGluRGltc1sxXSAmJiB4VGV4ZWxDJHtifVJlYWR5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2J9ID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgY2xlYXIgdW51c2VkIGNoYW5uZWxzIGluIGNhc2VcbiAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIHJlYWRpbmcgZnJvbSByZWN5Y2xlZCB0ZXh0dXJlLlxuICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ICsgMSA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Yn0uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtifVJlYWR5ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGAsbD09PTEmJmI+MD9jKz1gXG4gICAgICAgICAgICAgICAgeEMke2J9ID0gdmVjNCh4VGV4ZWxDJHtiLTJ9Lnp3LCB4VGV4ZWxDJHtifS54eSk7XG4gICAgICAgICAgICAgICAgYDpjKz1gXG4gICAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgMSAtIDI7XG5cbiAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBtYW51YWxseSBjbGVhciB1bnVzZWQgY2hhbm5lbHMgaW4gY2FzZVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSByZWFkaW5nIGZyb20gcmVjeWNsZWQgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ICsgMSA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91cy56dyA9IHZlYzIoMC4wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHhDJHtifSA9IHZlYzQocHJldmlvdXMuencsIHhUZXhlbEMke2J9Lnh5KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHhDJHtifSA9IHZlYzQoMC4wLCAwLjAsIHhUZXhlbEMke2J9Lnh5KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGApOmMrPWBcbiAgICAgICAgICAgICAgICBpZiAoeEMgPj0gMCAmJiB4QyA8IGluRGltc1sxXSAmJiB4VGV4ZWxDJHtifVJlYWR5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2J9ID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICAgICAgICBpZiAoeEMgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtifS56dyA9IHZlYzIoMC4wKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2J9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHhDJHtifSA9IHhUZXhlbEMke2J9O1xuICAgICAgICAgICAgICAgIGAsYisxPHApKXtsZXQgeT1pJTI9PT0wP3cubmVhcmVzdExhcmdlckV2ZW4obCk6bDtsJTI9PT0wJiZpJTI9PT0xfHxsJTIhPT0wJiZpJTIhPT0xPyhjKz1gXG4gICAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgaW1vZChwYWRzWzFdLCAyKSArICR7eX07XG5cbiAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgaW5EaW1zWzFdICYmIHhUZXhlbEMke2IrMX1SZWFkeSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2IrMX0gPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIG1hbnVhbGx5IGNsZWFyIHVudXNlZCBjaGFubmVscyBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIHJlYWRpbmcgZnJvbSByZWN5Y2xlZCB0ZXh0dXJlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2IrMX0uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7YisxfVJlYWR5ID0gMTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGAsbD4xP2MrPWBcbiAgICAgICAgICAgICAgICAgICAgeENPZmZzZXQgLT0gMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XG4gICAgICAgICAgICAgICAgICAgICB4QyR7YisxfSA9IHZlYzQocHJldmlvdXMuencsIHhUZXhlbEMke2IrMX0ueHkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgeEMke2IrMX0gPSB2ZWM0KDAuMCwgMC4wLCB4VGV4ZWxDJHtiKzF9Lnh5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBgOmMrPWBcbiAgICAgICAgICAgICAgICAgICAgeEMke2IrMX0gPSB2ZWM0KHhUZXhlbEMke2J9Lnp3LCB4VGV4ZWxDJHtiKzF9Lnh5KTtcbiAgICAgICAgICAgICAgICAgICAgYCk6eT09PTE/Yys9YFxuICAgICAgICAgICAgICAgICAgICB4QyR7YisxfSA9IHhUZXhlbEMke2J9O1xuICAgICAgICAgICAgICAgICAgICBgOmMrPWBcbiAgICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArICR7eX07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7YisxfVJlYWR5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtiKzF9ID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ICsgMSA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2IrMX0uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2IrMX1SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB4QyR7YisxfSA9IHhUZXhlbEMke2IrMX07XG4gICAgICAgICAgICAgICAgICAgIGB9fWVsc2UgYjxwJiYoaSUyPT09MT8oYys9YFxuICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAxIC0gc3RyaWRlc1sxXTtcbiAgICAgICAgICAgICAgICBpZih4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgaW5EaW1zWzFdICYmIHhUZXhlbEMke2J9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Yn0gPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcbiAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgY2xlYXIgdW51c2VkIGNoYW5uZWxzIGluIGNhc2VcbiAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIHJlYWRpbmcgZnJvbSByZWN5Y2xlZCB0ZXh0dXJlLlxuICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ICsgMSA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Yn0uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtifVJlYWR5ID0gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZih4QyArIDEgPj0gMCAmJiB4QyArIDEgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7YisxfVJlYWR5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2IrMX0gPSBnZXRYKGJhdGNoLCB4UiwgeEMgKyAxLCBkMSk7XG4gICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIG1hbnVhbGx5IGNsZWFyIHVudXNlZCBjaGFubmVscyBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAvLyB3ZSdyZSByZWFkaW5nIGZyb20gcmVjeWNsZWQgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgIGlmICh4QyArIDIgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2IrMX0uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtiKzF9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHhDJHtifSA9IHZlYzQoeFRleGVsQyR7Yn0uencsIHhUZXhlbEMke2IrMX0uencpO1xuICAgICAgICAgICAgICBgLGIrMTxwJiYoYys9YFxuICAgICAgICAgICAgICAgICAgZmluYWwgPSB2ZWM0KDAuMCk7XG4gICAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgMSArIHN0cmlkZXNbMV07XG4gICAgICAgICAgICAgICAgICBpZih4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB4QyR7YisxfSA9IHZlYzQoeFRleGVsQyR7YisxfS54eSwgZmluYWwueHkpO1xuICAgICAgICAgICAgICAgIGApKTooYys9YFxuICAgICAgICAgICAgICAgIGlmKHhDID49IDAgJiYgeEMgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7Yn1SZWFkeSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtifSA9IGdldFgoYmF0Y2gsIHhSLCB4QywgZDEpO1xuICAgICAgICAgICAgICAgICAgaWYgKHhDICsgMSA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Yn0uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtifVJlYWR5ID0gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgc3RyaWRlc1sxXTtcbiAgICAgICAgICAgICAgICBpZih4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgaW5EaW1zWzFdICYmIHhUZXhlbEMke2IrMX1SZWFkeSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtiKzF9ID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XG4gICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtiKzF9Lnp3ID0gdmVjMigwLik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtiKzF9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHhDJHtifSA9IHZlYzQoXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtifS54eSwgeFRleGVsQyR7YisxfS54eSk7XG4gICAgICAgICAgICAgIGAsYisxPHAmJihjKz1gXG4gICAgICAgICAgICAgICAgICB4QyR7YisxfSA9IHZlYzQoeFRleGVsQyR7Yn0uencsIHhUZXhlbEMke2IrMX0uencpO1xuICAgICAgICAgICAgICAgIGApKSk7YjxwJiYoYys9YFxuICAgICAgICAgICAgd1RleGVsID0gZ2V0VyhyLCAke2J9LCBkMSwgcSk7XG4gICAgICAgICAgICBkb3RQcm9kICs9IHhDJHtifSAqIHZlYzQod1RleGVsLnh6LCB3VGV4ZWwueHopO1xuICAgICAgICAgIGAsYisxPHAmJihjKz1gXG4gICAgICAgICAgICAgIHdUZXhlbCA9IGdldFcociwgJHtiKzF9LCBkMSwgcSk7XG4gICAgICAgICAgICAgIGRvdFByb2QgKz0geEMke2IrMX0gKiB2ZWM0KHdUZXhlbC54eiwgd1RleGVsLnh6KTtcbiAgICAgICAgICAgIGApKX1jKz1gXG4gICAgfVxuICBgLGMrPWBcbiAgICAgIH1cbiAgICBgO2xldCBoPVwiXCIsbT1cIlwiO24mJihhP2g9YHZlYzQgYWN0aXZhdGlvbih2ZWM0IGEpIHtcbiAgICAgICAgICB2ZWM0IGIgPSBnZXRQcmVsdUFjdGl2YXRpb25XZWlnaHRzQXRPdXRDb29yZHMoKTtcbiAgICAgICAgICAke259XG4gICAgICAgIH1gOnI/aD1gdmVjNCBhY3RpdmF0aW9uKHZlYzQgYSkge1xuICAgICAgICAgIHZlYzQgYiA9IGdldExlYWt5cmVsdUFscGhhQXRPdXRDb29yZHMoKTtcbiAgICAgICAgICAke259XG4gICAgICAgIH1gOmg9YHZlYzQgYWN0aXZhdGlvbih2ZWM0IHgpIHtcbiAgICAgICAgICAke259XG4gICAgICAgIH1gLG09XCJyZXN1bHQgPSBhY3RpdmF0aW9uKHJlc3VsdCk7XCIpO2xldCBmPXQ/XCJyZXN1bHQgKz0gZ2V0Qmlhc0F0T3V0Q29vcmRzKCk7XCI6XCJcIjt0JiZ0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcImJpYXNcIiksYSYmdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJwcmVsdUFjdGl2YXRpb25XZWlnaHRzXCIpLHImJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwibGVha3lyZWx1QWxwaGFcIiksdGhpcy51c2VyQ29kZT1gXG4gICAgICAke2h9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnc7XG4gICAgICAgIGludCBkMSA9IGQyIC8gJHtzfTtcbiAgICAgICAgaW50IHEgPSBkMiAtIGQxICogJHtzfTtcbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xuXG4gICAgICAgIC8vaW50aWFsaXplIGRvdFByb2Qgd2l0aCBhIHNtYWxsIGVwc2lsb24gc2VlbXMgdG8gcmVkdWNlIEdQVSBhY2N1cmFjeSBsb3NzLlxuICAgICAgICB2ZWM0IGRvdFByb2QgPSB2ZWM0KDAuMDAwMDAwMDAwMDAwMDAxKTtcblxuICAgICAgICAke2N9XG5cbiAgICAgICAgdmVjNCByZXN1bHQgPSBkb3RQcm9kIC0gdmVjNCgwLjAwMDAwMDAwMDAwMDAwMSk7XG4gICAgICAgICR7Zn1cbiAgICAgICAgJHttfVxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24gdGFlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyLGZpbHRlcjpzfT10LHtzdHJpZGVzOmkscGFkOm8sZGlsYXRpb25zOmwsZGltUm91bmRpbmdNb2RlOnV9PWEscD1sO3A9PW51bGwmJihwPVsxLDFdKSx3LmFzc2VydChULmVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShpLHApLCgpPT5gRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyAke2l9IGFuZCBkaWxhdGlvbnMgJyR7cH0nYCk7bGV0IGQ9VC5jb21wdXRlQ29udjJESW5mbyhyLnNoYXBlLHMuc2hhcGUsaSxwLG8sdSwhMCksYztHKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfREVQVEhXSVNFQ09OVlwiKSYmZC5zdHJpZGVXaWR0aDw9MiYmZC5vdXRDaGFubmVscy9kLmluQ2hhbm5lbHM9PT0xP2M9bmV3IFlBKGQpOmM9bmV3IFhBKGQpO2xldCBoPVtbZC5wYWRJbmZvLnRvcCxkLnBhZEluZm8ubGVmdF0sW2Quc3RyaWRlSGVpZ2h0LGQuc3RyaWRlV2lkdGhdLFtkLmRpbGF0aW9uSGVpZ2h0LGQuZGlsYXRpb25XaWR0aF0sW2QuaW5IZWlnaHQsZC5pbldpZHRoXV07cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKGMsW3Isc10sXCJmbG9hdDMyXCIsaCl9dmFyIG5hZT17a2VybmVsTmFtZTpVaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzp0YWV9LGFhZT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT1lLmZpbHRlclNoYXBlO2xldCB0PWUuc3RyaWRlSGVpZ2h0LG49ZS5zdHJpZGVXaWR0aCxhPWUucGFkSW5mby50b3Ascj1lLnBhZEluZm8ubGVmdCxzPWUub3V0Q2hhbm5lbHMvZS5pbkNoYW5uZWxzO3RoaXMudXNlckNvZGU9YFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IHdSID0gY29vcmRzLng7XG4gICAgICAgIGludCB3QyA9IGNvb3Jkcy55O1xuICAgICAgICBpbnQgZDEgPSBjb29yZHMuejtcbiAgICAgICAgaW50IGRtID0gY29vcmRzLnc7XG4gICAgICAgIGludCBkMiA9IGQxICogJHtzfSArIGRtO1xuXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XG5cbiAgICAgICAgLy8gVE8gRE86IFZlYzQgb3ZlciB0aGUgYmF0Y2ggc2l6ZVxuICAgICAgICBmb3IgKGludCBiID0gMDsgYiA8ICR7ZS5iYXRjaFNpemV9OyBiKyspIHtcbiAgICAgICAgICBmb3IgKGludCB5UiA9IDA7IHlSIDwgJHtlLm91dEhlaWdodH07IHlSKyspIHtcbiAgICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiAke3R9IC0gJHthfTtcblxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSAke2UuaW5IZWlnaHR9KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGludCB5QyA9IDA7IHlDIDwgJHtlLm91dFdpZHRofTsgeUMrKykge1xuICAgICAgICAgICAgICBpbnQgeEMgPSB3QyArIHlDICogJHtufSAtICR7cn07XG5cbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSAke2UuaW5XaWR0aH0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCB5UiwgeUMsIGQyKTtcbiAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0WChiLCB4UiwgeEMsIGQxKTtcbiAgICAgICAgICAgICAgZG90UHJvZCArPSAoeFZhbHVlICogZHlWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcbiAgICAgIH1cbiAgICBgfX0scmFlPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPWUuaW5TaGFwZTtsZXQgdD1lLmZpbHRlckhlaWdodCxuPWUuZmlsdGVyV2lkdGgsYT1lLnN0cmlkZUhlaWdodCxyPWUuc3RyaWRlV2lkdGgscz10LTEtZS5wYWRJbmZvLnRvcCxpPW4tMS1lLnBhZEluZm8ubGVmdCxvPWUub3V0Q2hhbm5lbHMvZS5pbkNoYW5uZWxzO3RoaXMudXNlckNvZGU9YFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKCR7c30sICR7aX0pO1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XG4gICAgICAgIGludCBkMSA9IGNvb3Jkc1szXTtcbiAgICAgICAgaXZlYzIgZHlDb3JuZXIgPSBjb29yZHMueXogLSBwYWRzO1xuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XG5cbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcblxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgJHt0fTsgd1IrKykge1xuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvICR7YX0uMDtcblxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7ZS5vdXRIZWlnaHR9LjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XG5cbiAgICAgICAgICBpbnQgd1JQZXJtID0gJHt0fSAtIDEgLSB3UjtcblxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCAke259OyB3QysrKSB7XG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyAke3J9LjA7XG5cbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49ICR7ZS5vdXRXaWR0aH0uMCB8fFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xuXG4gICAgICAgICAgICBpbnQgd0NQZXJtID0gJHtufSAtIDEgLSB3QztcblxuICAgICAgICAgICAgLy8gVE8gRE86IFZlYzQgb3ZlciB0aGUgY2hhbm5lbE11bFxuICAgICAgICAgICAgZm9yIChpbnQgZG0gPSAwOyBkbSA8ICR7b307IGRtKyspIHtcbiAgICAgICAgICAgICAgaW50IGQyID0gZDEgKiAke299ICsgZG07XG4gICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldER5KGJhdGNoLCBpZHlSLCBpZHlDLCBkMik7XG4gICAgICAgICAgICAgIGZsb2F0IHdWYWx1ZSA9IGdldFcod1JQZXJtLCB3Q1Blcm0sIGQxLCBkbSk7XG4gICAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbHVlICogd1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XG4gICAgICB9XG4gICAgYH19O2Z1bmN0aW9uIHNhZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cixkeTpzfT10LHtzdHJpZGVzOmksZGlsYXRpb25zOm8scGFkOmwsZGltUm91bmRpbmdNb2RlOnUsZmlsdGVyU2hhcGU6cH09YSxkPVQuY29tcHV0ZUNvbnYyREluZm8oci5zaGFwZSxwLGksbyxsLHUsITApLGM9bmV3IGFhZShkKTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0oYyxbcixzXSxcImZsb2F0MzJcIil9dmFyIGlhZT17a2VybmVsTmFtZTpJbSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpzYWV9O2Z1bmN0aW9uIG9hZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2R5OnIsZmlsdGVyOnN9PXQse3N0cmlkZXM6aSxkaWxhdGlvbnM6byxwYWQ6bCxkaW1Sb3VuZGluZ01vZGU6dSxpbnB1dFNoYXBlOnB9PWEsZD1ULmNvbXB1dGVDb252MkRJbmZvKHAscy5zaGFwZSxpLG8sbCx1LCEwKSxjPW5ldyByYWUoZCk7cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKGMsW3Isc10sXCJmbG9hdDMyXCIpfXZhciBsYWU9e2tlcm5lbE5hbWU6U20sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6b2FlfSx1YWU9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIlhcIl0sdGhpcy5vdXRwdXRTaGFwZT1bZSxlXSx0aGlzLnVzZXJDb2RlPWBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgICBmbG9hdCB2YWwgPSBjb29yZHNbMF0gPT0gY29vcmRzWzFdID8gZ2V0WChjb29yZHNbMF0pIDogMC4wO1xuICAgICAgICAgIHNldE91dHB1dCh2YWwpO1xuICAgICAgfVxuICAgIGB9fTtmdW5jdGlvbiBwYWUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7eDphfT10LHI9Wy4uLmEuc2hhcGUsLi4uYS5zaGFwZV0scz13LnNpemVGcm9tU2hhcGUoYS5zaGFwZSksaT1jZSh7aW5wdXRzOnt4OmF9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6W3NdfX0pLG89bmV3IHVhZShzKSxsPW4ucnVuV2ViR0xQcm9ncmFtKG8sW2ldLGkuZHR5cGUpLHU9Y2Uoe2lucHV0czp7eDpsfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOnJ9fSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaSksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhsKSx1fXZhciBjYWU9e2tlcm5lbE5hbWU6TGMsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6cGFlfSxkYWU9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIldcIl0sdGhpcy5vdXRwdXRTaGFwZT1lLm91dFNoYXBlO2xldHtpbkhlaWdodDp0LGluV2lkdGg6bixwYWRJbmZvOmEsc3RyaWRlSGVpZ2h0OnIsc3RyaWRlV2lkdGg6cyxmaWx0ZXJIZWlnaHQ6aSxmaWx0ZXJXaWR0aDpvLGRpbGF0aW9uSGVpZ2h0OmwsZGlsYXRpb25XaWR0aDp1fT1lLHt0b3A6cCxsZWZ0OmR9PWE7dGhpcy51c2VyQ29kZT1gXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoJHtyfSwgJHtzfSk7XG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoJHtwfSwgJHtkfSk7XG4gICAgICBjb25zdCBmbG9hdCBuZWdfaW5maW5pdHkgPSAtMy40ZTM4O1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcbiAgICAgICAgaW50IGQxID0gY29vcmRzLnc7XG4gICAgICAgIGl2ZWMyIG91dFRvcExlZnRDb3JuZXIgPVxuICAgICAgICAgICAgY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XG4gICAgICAgIGludCBoQmVnID0gb3V0VG9wTGVmdENvcm5lci54O1xuICAgICAgICBpbnQgd0JlZyA9IG91dFRvcExlZnRDb3JuZXIueTtcblxuICAgICAgICBmbG9hdCBjdXJWYWwgPSBuZWdfaW5maW5pdHk7XG4gICAgICAgIGZvciAoaW50IGggPSAwOyBoIDwgJHtpfTsgaCsrKSB7XG4gICAgICAgICAgaW50IGhJbiA9IGhCZWcgKyBoICogJHtsfTtcblxuICAgICAgICAgIGlmIChoSW4gPj0gMCAmJiBoSW4gPCAke3R9KSB7XG4gICAgICAgICAgICBmb3IgKGludCB3ID0gMDsgdyA8ICR7b307IHcrKykge1xuICAgICAgICAgICAgICBpbnQgd0luID0gd0JlZyArIHcgKiAke3V9O1xuXG4gICAgICAgICAgICAgIGlmICh3SW4gPj0gMCAmJiB3SW4gPCAke259KSB7XG4gICAgICAgICAgICAgICAgZmxvYXQgeFZhbCA9IGdldFgoYmF0Y2gsIGhJbiwgd0luLCBkMSk7XG4gICAgICAgICAgICAgICAgZmxvYXQgd1ZhbCA9IGdldFcoaCwgdywgZDEpO1xuXG4gICAgICAgICAgICAgICAgZmxvYXQgdmFsID0geFZhbCArIHdWYWw7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCA+IGN1clZhbCkge1xuICAgICAgICAgICAgICAgICAgY3VyVmFsID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZsb2F0IHJlc3VsdCA9IGN1clZhbDtcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgYH19O2Z1bmN0aW9uIGhhZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cixmaWx0ZXI6c309dCx7c3RyaWRlczppLHBhZDpvLGRpbGF0aW9uczpsfT1hLHU9VC5jb21wdXRlRGlsYXRpb24yREluZm8oci5zaGFwZSxzLnNoYXBlLGksbyxcIk5IV0NcIixsKSxwLGQ9bmV3IGRhZSh1KTtwPW4ucnVuV2ViR0xQcm9ncmFtKGQsW3Isc10sXCJmbG9hdDMyXCIpO2xldCBjPWNlKHtpbnB1dHM6e3g6cH0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTp1Lm91dFNoYXBlfX0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHApLGN9dmFyIG1hZT17a2VybmVsTmFtZTpHaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpoYWV9O2Z1bmN0aW9uIGZhZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2VxdWF0aW9uOnJ9PWEscz10LHthbGxEaW1zOmksc3VtbWVkRGltczpvLGlkRGltczpsfT1ULmRlY29kZUVpbnN1bUVxdWF0aW9uKHIscy5sZW5ndGgpO1QuY2hlY2tFaW5zdW1EaW1TaXplcyhpLmxlbmd0aCxsLHMpO2xldHtwYXRoOnUsc3RlcHM6cH09VC5nZXRFaW5zdW1Db21wdXRlUGF0aChvLGwpLGQ9cC5sZW5ndGgsYz1udWxsLGg9aS5sZW5ndGgsbT1bXTtmb3IobGV0IGY9MDtmPGQ7KytmKXtmb3IobGV0IGcgb2YgcFtmXSl7bGV0e3Blcm11dGF0aW9uSW5kaWNlczpiLGV4cGFuZERpbXM6eX09VC5nZXRFaW5zdW1QZXJtdXRhdGlvbihoLGxbZ10pLHg7VC5pc0lkZW50aXR5UGVybXV0YXRpb24oYik/eD1zW2ddOih4PVNuKHtpbnB1dHM6e3g6c1tnXX0sYmFja2VuZDpuLGF0dHJzOntwZXJtOmJ9fSksbS5wdXNoKHgpKTtsZXQgdj14LnNoYXBlLnNsaWNlKCk7Zm9yKGxldCBJPTA7STx5Lmxlbmd0aDsrK0kpdi5zcGxpY2UoeVtJXSwwLDEpO3cuYXJyYXlzRXF1YWwoeC5zaGFwZSx2KXx8KHg9Y2Uoe2lucHV0czp7eH0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTp2fX0pLG0ucHVzaCh4KSksYz09PW51bGw/Yz14OihjPXBrKHtpbnB1dHM6e2E6eCxiOmN9LGJhY2tlbmQ6bn0pLG0ucHVzaChjKSl9ZjxkLTEmJih1W2ZdPj0wJiYoYz1WZih7aW5wdXRzOnt4OmN9LGJhY2tlbmQ6bixhdHRyczp7YXhpczp1W2ZdLShpLmxlbmd0aC1oKSxrZWVwRGltczohMX19KSxtLnB1c2goYykpLGgtLSl9Zm9yKGxldCBmIG9mIG0pZiE9PWMmJm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZik7cmV0dXJuIGN9dmFyIGdhZT17a2VybmVsTmFtZTpUbSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpmYWV9LGJhZT1cInJldHVybiAoeCA+PSAwLjApID8geCA6IChleHAoeCkgLSAxLjApO1wiLHlhZT1gXG4gIHZlYzQgcmVzdWx0O1xuXG4gIHJlc3VsdC5yID0gKHguciA+PSAwLjApID8geC5yIDogKGV4cCh4LnIpIC0gMS4wKTtcbiAgcmVzdWx0LmcgPSAoeC5nID49IDAuMCkgPyB4LmcgOiAoZXhwKHguZykgLSAxLjApO1xuICByZXN1bHQuYiA9ICh4LmIgPj0gMC4wKSA/IHguYiA6IChleHAoeC5iKSAtIDEuMCk7XG4gIHJlc3VsdC5hID0gKHguYSA+PSAwLjApID8geC5hIDogKGV4cCh4LmEpIC0gMS4wKTtcblxuICByZXR1cm4gcmVzdWx0O1xuYCx4YWU9WmUoe29wU25pcHBldDpiYWUscGFja2VkT3BTbmlwcGV0OnlhZX0pLHZhZT17a2VybmVsTmFtZTpqaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzp4YWV9LHdhZT1cInJldHVybiAoYiA+PSAwLjApID8gYSA6IGEgKiAoYiArIDEuMCk7XCIsa2FlPWBcbiAgdmVjNCBiR1RFWmVybyA9IHZlYzQoZ3JlYXRlclRoYW5FcXVhbChiLCB2ZWM0KDAuKSkpO1xuICByZXR1cm4gKGJHVEVaZXJvICogYSkgKyAoKHZlYzQoMS4wKSAtIGJHVEVaZXJvKSAqIChhICogKGIgKyB2ZWM0KDEuMCkpKSk7XG5gLElhZT1lPT57bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7ZHk6YSx5OnJ9PXQscz1HKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIik/bmV3IGhwKGthZSxhLnNoYXBlLHIuc2hhcGUpOm5ldyBraSh3YWUsYS5zaGFwZSxyLnNoYXBlKTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0ocyxbYSxyXSxhLmR0eXBlKX0sU2FlPXtrZXJuZWxOYW1lOmN1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOklhZX0sTmFlPWBcbiAgcmV0dXJuIHZlYzQoZXF1YWwoYSwgYikpO1xuYCxUYWU9XCJyZXR1cm4gZmxvYXQoYSA9PSBiKTtcIixDYWU9aG4oe29wU25pcHBldDpUYWUscGFja2VkT3BTbmlwcGV0Ok5hZSxkdHlwZTpcImJvb2xcIixjcHVLZXJuZWxJbXBsOmFRfSksRWFlPXtrZXJuZWxOYW1lOmR1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkNhZX0sX2FlPWBcbiAgLy8gRXJyb3IgZnVuY3Rpb24gaXMgY2FsY3VsYXRlZCBhcHByb3hpbWF0ZWx5IHdpdGggZWxlbWVudGFyeSBmdW5jdGlvbi5cbiAgLy8gU2VlIFwiSGFuZGJvb2sgb2YgTWF0aGVtYXRpY2FsIEZ1bmN0aW9ucyB3aXRoIEZvcm11bGFzLFxuICAvLyBHcmFwaHMsIGFuZCBNYXRoZW1hdGljYWwgVGFibGVzXCIsIEFicmFtb3dpdHogYW5kIFN0ZWd1bi5cbiAgZmxvYXQgcCA9ICR7VC5FUkZfUH07XG4gIGZsb2F0IGExID0gJHtULkVSRl9BMX07XG4gIGZsb2F0IGEyID0gJHtULkVSRl9BMn07XG4gIGZsb2F0IGEzID0gJHtULkVSRl9BM307XG4gIGZsb2F0IGE0ID0gJHtULkVSRl9BNH07XG4gIGZsb2F0IGE1ID0gJHtULkVSRl9BNX07XG5cbiAgZmxvYXQgc2lnbiA9IHNpZ24oeCk7XG4gIHggPSBhYnMoeCk7XG4gIGZsb2F0IHQgPSAxLjAgLyAoMS4wICsgcCAqIHgpO1xuICByZXR1cm4gc2lnbiAqICgxLjAgLSAoKCgoKGE1KnQgKyBhNCkqdCkgKyBhMykqdCArIGEyKSp0ICsgYTEpKnQqZXhwKC14KngpKTtcbmAsQWFlPVplKHtvcFNuaXBwZXQ6X2FlfSksRmFlPXtrZXJuZWxOYW1lOnFpLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkFhZX0sJGFlPW1wK2BcbiAgcmV0dXJuIGV4cCh4KTtcbmAsRGFlPWBcbiAgdmVjNCByZXN1bHQgPSBleHAoeCk7XG4gIGJ2ZWM0IGlzTmFOID0gaXNuYW4oeCk7XG4gIHJlc3VsdC5yID0gaXNOYU4uciA/IHguciA6IHJlc3VsdC5yO1xuICByZXN1bHQuZyA9IGlzTmFOLmcgPyB4LmcgOiByZXN1bHQuZztcbiAgcmVzdWx0LmIgPSBpc05hTi5iID8geC5iIDogcmVzdWx0LmI7XG4gIHJlc3VsdC5hID0gaXNOYU4uYSA/IHguYSA6IHJlc3VsdC5hO1xuXG4gIHJldHVybiByZXN1bHQ7XG5gLFpBPVplKHtvcFNuaXBwZXQ6JGFlLHBhY2tlZE9wU25pcHBldDpEYWUsY3B1S2VybmVsSW1wbDpyUSxkdHlwZTpcImZsb2F0MzJcIn0pLFJhZT17a2VybmVsTmFtZTpLaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpaQX07ZnVuY3Rpb24gZ3YoZSl7bGV0e2lucHV0czp0LGF0dHJzOm4sYmFja2VuZDphfT1lLHtkaW06cn09bix7aW5wdXQ6c309dCxpPXMuc2hhcGUubGVuZ3RoLG89cy5zaGFwZS5zbGljZSgpLGw9cjtyZXR1cm4gcjwwJiYody5hc3NlcnQoLShpKzEpPD1yLCgpPT5gQXhpcyBtdXN0IGJlIGluIHRoZSBpbnRlcnZhbCBbJHstKGkrMSl9LCAke2l9XWApLGw9aStyKzEpLG8uc3BsaWNlKGwsMCwxKSxjZSh7aW5wdXRzOnt4OnN9LGJhY2tlbmQ6YSxhdHRyczp7c2hhcGU6b319KX12YXIgTWFlPXtrZXJuZWxOYW1lOmh1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmd2fSx4Uz1cInJldHVybiBleHAoeCkgLSAxLjA7XCIsT2FlPVplKHtvcFNuaXBwZXQ6eFMscGFja2VkT3BTbmlwcGV0OnhTLGNwdUtlcm5lbEltcGw6c1F9KSxQYWU9e2tlcm5lbE5hbWU6WGksYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6T2FlfSx2Uz1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInJlYWxcIixcImltYWdcIl07bGV0IGE9dFsxXTt0aGlzLm91dHB1dFNoYXBlPXQ7bGV0IHI9bj9gMi4wICogJHtNYXRoLlBJfWA6YC0yLjAgKiAke01hdGguUEl9YCxzPW4/YCR7YX0uMGA6XCIxLjBcIixpO2lmKGU9PT1cInJlYWxcIilpPVwicmV0dXJuIHJlYWwgKiBleHBSIC0gaW1hZyAqIGV4cEk7XCI7ZWxzZSBpZihlPT09XCJpbWFnXCIpaT1cInJldHVybiByZWFsICogZXhwSSArIGltYWcgKiBleHBSO1wiO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBGRlQgY29tcG9uZW50IG11c3QgYmUgZWl0aGVyIFwicmVhbFwiIG9yIFwiaW1hZ1wiLCBnb3QgJHtlfS5gKTt0aGlzLnVzZXJDb2RlPWBcbiAgICAgIGNvbnN0IGZsb2F0IGV4cG9uZW50TXVsdGlwbGllciA9ICR7cn07XG5cbiAgICAgIGZsb2F0IHVuYXJ5T3BDb21wbGV4KGZsb2F0IHJlYWwsIGZsb2F0IGV4cFIsIGZsb2F0IGltYWcsIGZsb2F0IGV4cEkpIHtcbiAgICAgICAgJHtpfVxuICAgICAgfVxuXG4gICAgICBmbG9hdCBtdWxNYXRERlQoaW50IGJhdGNoLCBpbnQgaW5kZXgpIHtcbiAgICAgICAgZmxvYXQgaW5kZXhSYXRpbyA9IGZsb2F0KGluZGV4KSAvIGZsb2F0KCR7YX0pO1xuICAgICAgICBmbG9hdCBleHBvbmVudE11bHRpcGxpZXJUaW1lc0luZGV4UmF0aW8gPVxuICAgICAgICAgICAgZXhwb25lbnRNdWx0aXBsaWVyICogaW5kZXhSYXRpbztcblxuICAgICAgICBmbG9hdCByZXN1bHQgPSAwLjA7XG5cbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke2F9OyBpKyspIHtcbiAgICAgICAgICAvLyB4ID0gKC0yfDIgKiBQSSAvIE4pICogaW5kZXggKiBpO1xuICAgICAgICAgIGZsb2F0IHggPSBleHBvbmVudE11bHRpcGxpZXJUaW1lc0luZGV4UmF0aW8gKiBmbG9hdChpKTtcbiAgICAgICAgICBmbG9hdCBleHBSID0gY29zKHgpO1xuICAgICAgICAgIGZsb2F0IGV4cEkgPSBzaW4oeCk7XG4gICAgICAgICAgZmxvYXQgcmVhbCA9IGdldFJlYWwoYmF0Y2gsIGkpO1xuICAgICAgICAgIGZsb2F0IGltYWcgPSBnZXRJbWFnKGJhdGNoLCBpKTtcblxuICAgICAgICAgIHJlc3VsdCArPVxuICAgICAgICAgICAgICB1bmFyeU9wQ29tcGxleChyZWFsLCBleHBSLCBpbWFnLCBleHBJKSAvICR7c307XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBzZXRPdXRwdXQobXVsTWF0REZUKGNvb3Jkc1swXSwgY29vcmRzWzFdKSk7XG4gICAgICB9XG4gICAgYH19O2Z1bmN0aW9uIEpBKGUsdCxuKXtsZXQgYT1uLnRleERhdGEuZ2V0KGUuZGF0YUlkKSxyPXcuc2l6ZUZyb21TaGFwZShlLnNoYXBlKSxzPWUuc2hhcGVbZS5zaGFwZS5sZW5ndGgtMV0saT1yL3Msbz1jZSh7aW5wdXRzOnt4OmV9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6W2ksc119fSksbD1vLnNoYXBlLHU9bmV3IHZTKFwicmVhbFwiLGwsdCkscD1uZXcgdlMoXCJpbWFnXCIsbCx0KSxkPVt7ZGF0YUlkOmEuY29tcGxleFRlbnNvckluZm9zLnJlYWwuZGF0YUlkLGR0eXBlOmEuY29tcGxleFRlbnNvckluZm9zLnJlYWwuZHR5cGUsc2hhcGU6bH0se2RhdGFJZDphLmNvbXBsZXhUZW5zb3JJbmZvcy5pbWFnLmRhdGFJZCxkdHlwZTphLmNvbXBsZXhUZW5zb3JJbmZvcy5pbWFnLmR0eXBlLHNoYXBlOmx9XSxjPW4ucnVuV2ViR0xQcm9ncmFtKHUsZCxcImZsb2F0MzJcIiksaD1uLnJ1bldlYkdMUHJvZ3JhbShwLGQsXCJmbG9hdDMyXCIpLG09JHMoe2lucHV0czp7cmVhbDpjLGltYWc6aH0sYmFja2VuZDpufSk7bi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhjKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGgpO2xldCBmPWNlKHtpbnB1dHM6e3g6bX0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTplLnNoYXBlfX0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG8pLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obSksZn1mdW5jdGlvbiBMYWUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7aW5wdXQ6YX09dDtyZXR1cm4gSkEoYSwhMSxuKX12YXIgemFlPXtrZXJuZWxOYW1lOkNtLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkxhZX0sV2FlPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLmN1c3RvbVVuaWZvcm1zPVt7bmFtZTpcInZhbHVlXCIsdHlwZTpcImZsb2F0XCJ9XSx0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLm91dHB1dFNoYXBlPWUsdGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIC8vIElucHV0IGNhbiBiZSBvYnRhaW5lZCBmcm9tIHVuaWZvcm0gdmFsdWUuXG4gICAgICAgIHNldE91dHB1dCh2YWx1ZSk7XG4gICAgICB9XG4gICAgYH19O2Z1bmN0aW9uICRkKGUpe2xldHtiYWNrZW5kOnQsYXR0cnM6bn09ZSx7c2hhcGU6YSx2YWx1ZTpyfT1uLHtkdHlwZTpzfT1uO2lmKHM9c3x8dy5pbmZlckR0eXBlKHIpLHM9PT1cInN0cmluZ1wiKXtsZXQgaT13LmdldEFycmF5RnJvbURUeXBlKHMsdy5zaXplRnJvbVNoYXBlKGEpKTtyZXR1cm4gaS5maWxsKHIpLHQubWFrZVRlbnNvckluZm8oYSxzLGkpfWVsc2V7bGV0IGk9bmV3IFdhZShhLHIpLG89W1tyXV07cmV0dXJuIHQucnVuV2ViR0xQcm9ncmFtKGksW10scyxvKX19dmFyIEJhZT17a2VybmVsTmFtZTp6YyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzokZH0sVmFlPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJJbWFnZVwiXSx0aGlzLm91dHB1dFNoYXBlPVtdO2xldCB0PWVbMl07dGhpcy5vdXRwdXRTaGFwZT1lLHRoaXMudXNlckNvZGU9YFxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICAgaW50IHggPSBjb29yZHNbMl07XG5cbiAgICAgICAgICBpbnQgY29vcmRYID0gJHt0fSAtIHggLSAxO1xuICAgICAgICAgIGZsb2F0IG91dHB1dFZhbHVlO1xuICAgICAgICAgIGlmKGNvb3JkWCA+PSAwICYmIGNvb3JkWCA8ICR7dH0pIHtcbiAgICAgICAgICAgIG91dHB1dFZhbHVlID0gZ2V0SW1hZ2UoY29vcmRzWzBdLCBjb29yZHNbMV0sIGNvb3JkWCwgY29vcmRzWzNdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0VmFsdWUgPSBnZXRJbWFnZShjb29yZHNbMF0sIGNvb3Jkc1sxXSwgY29vcmRzWzJdLCBjb29yZHNbM10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRPdXRwdXQob3V0cHV0VmFsdWUpO1xuICAgICAgICB9XG4gICAgYH19LFVhZT17a2VybmVsTmFtZTptdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzooe2lucHV0czplLGJhY2tlbmQ6dH0pPT57bGV0e2ltYWdlOm59PWUsYT10LHI9bmV3IFZhZShuLnNoYXBlKTtyZXR1cm4gYS5ydW5XZWJHTFByb2dyYW0ocixbbl0sbi5kdHlwZSl9fSx3Uz1cInJldHVybiBmbG9vcih4KTtcIixHYWU9WmUoe29wU25pcHBldDp3UyxwYWNrZWRPcFNuaXBwZXQ6d1MsY3B1S2VybmVsSW1wbDppUX0pLEhhZT17a2VybmVsTmFtZTpZaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpHYWV9LGphZT1gXG4gIGZsb2F0IHMgPSBzaWduKGEpICogc2lnbihiKTtcbiAgaW50IGlhID0gcm91bmQoYSk7XG4gIGludCBpYiA9IHJvdW5kKGIpO1xuICBpZiAoaWIgIT0gMCkge1xuICAgIC8vIFdpbmRvd3MgKEQzRCkgd2FudHMgZ3VhcmFudGVlZCBub24temVybyBpbnQgZGl2aXNpb24gYXQgY29tcGlsZS10aW1lLlxuICAgIHJldHVybiBmbG9hdChpZGl2KGlhLCBpYiwgcykpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBOQU47XG4gIH1cbmAscWFlPWBcbiAgaXZlYzQgaWEgPSByb3VuZChhKTtcbiAgaXZlYzQgaWIgPSByb3VuZChiKTtcbiAgYnZlYzQgY29uZCA9IG5vdEVxdWFsKGliLCBpdmVjNCgwKSk7XG4gIGl2ZWM0IHJlc3VsdCA9IGl2ZWM0KDApO1xuICB2ZWM0IHMgPSBzaWduKGEpICogc2lnbihiKTtcblxuICAvLyBXaW5kb3dzIChEM0QpIHdhbnRzIGd1YXJhbnRlZWQgbm9uLXplcm8gaW50IGRpdmlzaW9uIGF0IGNvbXBpbGUtdGltZS5cbiAgaWYgKGNvbmRbMF0pIHtcbiAgICByZXN1bHRbMF0gPSBpZGl2KGlhWzBdLCBpYlswXSwgc1swXSk7XG4gIH1cbiAgaWYgKGNvbmRbMV0pIHtcbiAgICByZXN1bHRbMV0gPSBpZGl2KGlhWzFdLCBpYlsxXSwgc1sxXSk7XG4gIH1cbiAgaWYgKGNvbmRbMl0pIHtcbiAgICByZXN1bHRbMl0gPSBpZGl2KGlhWzJdLCBpYlsyXSwgc1syXSk7XG4gIH1cbiAgaWYgKGNvbmRbM10pIHtcbiAgICByZXN1bHRbM10gPSBpZGl2KGlhWzNdLCBpYlszXSwgc1szXSk7XG4gIH1cbiAgcmV0dXJuIHZlYzQocmVzdWx0KTtcbmAsS2FlPWhuKHtvcFNuaXBwZXQ6amFlLHBhY2tlZE9wU25pcHBldDpxYWUsZHR5cGU6XCJpbnQzMlwifSksWGFlPXtrZXJuZWxOYW1lOlppLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkthZX0sWWFlPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdO2xldCB0PUVuKCksW24sYV09ZTt0aGlzLm91dHB1dFNoYXBlPWUsdGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgdGV4UiA9IGNvb3Jkc1swXTtcbiAgICAgICAgaW50IHRleEMgPSBjb29yZHNbMV07XG4gICAgICAgIGludCBkZXB0aCA9IGNvb3Jkc1syXTtcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoJHthfS4wLCAke259LjApO1xuXG4gICAgICAgIHZlYzQgdmFsdWVzID0gJHt0LnRleHR1cmUyRH0oQSwgdXYpO1xuICAgICAgICBmbG9hdCB2YWx1ZTtcbiAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5yO1xuICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDEpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5nO1xuICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDIpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5iO1xuICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDMpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5hO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0T3V0cHV0KGZsb29yKHZhbHVlICogMjU1LjAgKyAwLjUpKTtcbiAgICAgIH1cbiAgICBgfX0sWmFlPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSExLHRoaXMucGFja2VkT3V0cHV0PSEwO2xldCB0PUVuKCksW24sYV09ZTt0aGlzLm91dHB1dFNoYXBlPWUsdGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgdGV4UiA9IGNvb3Jkc1swXTtcbiAgICAgICAgaW50IHRleEMgPSBjb29yZHNbMV07XG4gICAgICAgIGludCBkZXB0aCA9IGNvb3Jkc1syXTtcblxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xuXG4gICAgICAgIGZvcihpbnQgcm93PTA7IHJvdzw9MTsgcm93KyspIHtcbiAgICAgICAgICBmb3IoaW50IGNvbD0wOyBjb2w8PTE7IGNvbCsrKSB7XG4gICAgICAgICAgICB0ZXhDID0gY29vcmRzWzFdICsgcm93O1xuICAgICAgICAgICAgZGVwdGggPSBjb29yZHNbMl0gKyBjb2w7XG5cbiAgICAgICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xuICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7YX0uMCwgJHtufS4wKTtcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gJHt0LnRleHR1cmUyRH0oQSwgdXYpO1xuICAgICAgICAgICAgZmxvYXQgdmFsdWU7XG4gICAgICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5yO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkZXB0aCA9PSAxKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDIpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuYjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5hO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRbcm93ICogMiArIGNvbF0gPSBmbG9vcih2YWx1ZSAqIDI1NS4wICsgMC41KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAke3Qub3V0cHV0fSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICBgfX0sSmFlPXtrZXJuZWxOYW1lOkhoLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlFhZX0sSWwseHg9RygpLmdldEJvb2woXCJDQU5WQVMyRF9XSUxMX1JFQURfRlJFUVVFTlRMWV9GT1JfR1BVXCIpO2Z1bmN0aW9uIFFhZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3BpeGVsczpyfT10LHtudW1DaGFubmVsczpzfT1hLGk9dHlwZW9mIEhUTUxWaWRlb0VsZW1lbnQhPVwidW5kZWZpbmVkXCImJnIgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50LG89dHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQhPVwidW5kZWZpbmVkXCImJnIgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50LFtsLHVdPWk/W3IudmlkZW9XaWR0aCxyLnZpZGVvSGVpZ2h0XTpbci53aWR0aCxyLmhlaWdodF0scD1bdSxsXSxkPVt1LGwsc107aWYob3x8aSl7bGV0IGY9RygpLmdldEJvb2woXCJDQU5WQVMyRF9XSUxMX1JFQURfRlJFUVVFTlRMWV9GT1JfR1BVXCIpOyhJbD09bnVsbHx8ZiE9PXh4KSYmKHh4PWYsSWw9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwiMmRcIix7d2lsbFJlYWRGcmVxdWVudGx5Onh4fSkpLElsLmNhbnZhcy53aWR0aD1sLElsLmNhbnZhcy5oZWlnaHQ9dSxJbC5kcmF3SW1hZ2UociwwLDAsbCx1KSxyPUlsLmNhbnZhc31sZXQgYz1uLm1ha2VUZW5zb3JJbmZvKHAsXCJpbnQzMlwiKTtuLnRleERhdGEuZ2V0KGMuZGF0YUlkKS51c2FnZT1jYS5QSVhFTFMsbi5ncGdwdS51cGxvYWRQaXhlbERhdGFUb1RleHR1cmUobi5nZXRUZXh0dXJlKGMuZGF0YUlkKSxyKTtsZXQgaD1HKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIik/bmV3IFphZShkKTpuZXcgWWFlKGQpLG09bi5ydW5XZWJHTFByb2dyYW0oaCxbY10sXCJpbnQzMlwiKTtyZXR1cm4gbi5kaXNwb3NlRGF0YShjLmRhdGFJZCksbX1mdW5jdGlvbiBlcmUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsZmlsdGVyOnMsYmlhczppLHByZWx1QWN0aXZhdGlvbldlaWdodHM6b309dCx7c3RyaWRlczpsLHBhZDp1LGRhdGFGb3JtYXQ6cCxkaWxhdGlvbnM6ZCxkaW1Sb3VuZGluZ01vZGU6YyxhY3RpdmF0aW9uOmgsbGVha3lyZWx1QWxwaGE6bX09YSxmPVQuY29udmVydENvbnYyRERhdGFGb3JtYXQocCksZz1ULmNvbXB1dGVDb252MkRJbmZvKHIuc2hhcGUscy5zaGFwZSxsLGQsdSxjLCExLGYpLGIseT1bXSx4PWkhPW51bGwsdj1vIT1udWxsLEk9aD09PVwibGVha3lyZWx1XCIsTj0oKT0+e2xldCBfPVtyLHNdLEY9KEQsJCk9PntpZigkPT09XCJOQ0hXXCImJkQuc2hhcGUubGVuZ3RoPT09MSYmRC5zaGFwZVswXSE9PTEpe2xldCBTPWNlKHtpbnB1dHM6e3g6RH0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpbRC5zaGFwZVswXSwxLDFdfX0pO3JldHVybiB5LnB1c2goUyksU31yZXR1cm4gRH07aWYoeCYmXy5wdXNoKEYoaSxwKSksdiYmXy5wdXNoKEYobyxwKSksSSl7bGV0IEQ9bi5tYWtlVGVuc29ySW5mbyhbXSxcImZsb2F0MzJcIix3LmNyZWF0ZVNjYWxhclZhbHVlKG0sXCJmbG9hdDMyXCIpKTtfLnB1c2goRCkseS5wdXNoKEQpfXJldHVybiBffTtpZihnLmZpbHRlckhlaWdodD09PTEmJmcuZmlsdGVyV2lkdGg9PT0xJiZnLmRpbGF0aW9uSGVpZ2h0PT09MSYmZy5kaWxhdGlvbldpZHRoPT09MSYmZy5zdHJpZGVIZWlnaHQ9PT0xJiZnLnN0cmlkZVdpZHRoPT09MSYmKGcucGFkSW5mby50eXBlPT09XCJTQU1FXCJ8fGcucGFkSW5mby50eXBlPT09XCJWQUxJRFwiKSliPWpBKHt4OnIsZmlsdGVyOnMsY29udkluZm86ZyxiYWNrZW5kOm4sYmlhczppLGFjdGl2YXRpb246aCxwcmVsdUFjdGl2YXRpb25XZWlnaHRzOm8sbGVha3lyZWx1QWxwaGE6bX0pO2Vsc2UgaWYoZy5zdHJpZGVXaWR0aDw9MiYmZj09PVwiY2hhbm5lbHNMYXN0XCImJkcoKS5nZXRCb29sKFwiV0VCR0xfRVhQX0NPTlZcIikpe2xldCBfPWg/Q2MoaCwhMCk6bnVsbCxGPW5ldyBIQShnLHgsXyx2LEkpLEQ9W1tnLnBhZEluZm8udG9wLGcucGFkSW5mby5sZWZ0XSxbZy5zdHJpZGVIZWlnaHQsZy5zdHJpZGVXaWR0aF0sW2cuZGlsYXRpb25IZWlnaHQsZy5kaWxhdGlvbldpZHRoXSxbZy5pbkhlaWdodCxnLmluV2lkdGhdXSwkPU4oKTtiPW4ucnVuV2ViR0xQcm9ncmFtKEYsJCxcImZsb2F0MzJcIixEKX1lbHNlIGlmKEcoKS5nZXRCb29sKFwiV0VCR0xfQ09OVl9JTTJDT0xcIikpYj1xQSh7eDpyLGZpbHRlcjpzLGNvbnZJbmZvOmcsYmFja2VuZDpuLGJpYXM6aSxhY3RpdmF0aW9uOmgscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czpvLGxlYWt5cmVsdUFscGhhOm19KTtlbHNle2xldCBfPWg/Q2MoaCwhMSk6bnVsbCxGPW5ldyBHQShnLHgsXyx2LEkpLEQ9TigpO2I9bi5ydW5XZWJHTFByb2dyYW0oRixELFwiZmxvYXQzMlwiKX1sZXQgQz1jZSh7aW5wdXRzOnt4OmJ9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6Zy5vdXRTaGFwZX19KTtyZXR1cm4geS5wdXNoKGIpLHkuZm9yRWFjaChfPT5uLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKF8pKSxDfXZhciB0cmU9e2tlcm5lbE5hbWU6b2ksYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6ZXJlfTtmdW5jdGlvbiBucmUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsZmlsdGVyOnMsYmlhczppLHByZWx1QWN0aXZhdGlvbldlaWdodHM6b309dCx7c3RyaWRlczpsLHBhZDp1LGRpbGF0aW9uczpwLGRpbVJvdW5kaW5nTW9kZTpkLGFjdGl2YXRpb246YyxsZWFreXJlbHVBbHBoYTpofT1hLG09W10sZj1wO2Y9PW51bGwmJihmPVsxLDFdKSx3LmFzc2VydChULmVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShsLGYpLCgpPT5gRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyAke2x9IGFuZCBkaWxhdGlvbnMgJyR7Zn0nYCk7bGV0IGc9VC5jb21wdXRlQ29udjJESW5mbyhyLnNoYXBlLHMuc2hhcGUsbCxmLHUsZCwhMCksYj1HKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfREVQVEhXSVNFQ09OVlwiKSYmZy5zdHJpZGVXaWR0aDw9MiYmZy5vdXRDaGFubmVscy9nLmluQ2hhbm5lbHM9PT0xLHk9Yz9DYyhjLGIpOm51bGwseD1bcixzXSx2PWkhPW51bGwsST1vIT1udWxsLE49Yz09PVwibGVha3lyZWx1XCI7aWYodiYmeC5wdXNoKGkpLEkmJngucHVzaChvKSxOKXtsZXQgRD1uLm1ha2VUZW5zb3JJbmZvKFtdLFwiZmxvYXQzMlwiLHcuY3JlYXRlU2NhbGFyVmFsdWUoaCxcImZsb2F0MzJcIikpO3gucHVzaChEKSxtLnB1c2goRCl9bGV0IEM7Yj9DPW5ldyBZQShnLHYseSxJLE4pOkM9bmV3IFhBKGcsdix5LEksTik7bGV0IF89W1tnLnBhZEluZm8udG9wLGcucGFkSW5mby5sZWZ0XSxbZy5zdHJpZGVIZWlnaHQsZy5zdHJpZGVXaWR0aF0sW2cuZGlsYXRpb25IZWlnaHQsZy5kaWxhdGlvbldpZHRoXSxbZy5pbkhlaWdodCxnLmluV2lkdGhdXSxGPW4ucnVuV2ViR0xQcm9ncmFtKEMseCxcImZsb2F0MzJcIixfKTtyZXR1cm4gbS5mb3JFYWNoKEQ9Pm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oRCkpLEZ9dmFyIGFyZT17a2VybmVsTmFtZTpsaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpucmV9LHJyZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixhKXt0aGlzLnNsaWNlRGltPWUsdGhpcy5zdHJpZGVzPXQsdGhpcy5wYXJhbXNTaGFwZT1hLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJpbmRpY2VzXCJdLHRoaXMub3V0cHV0U2hhcGU9bjtsZXQgcj1odChuLmxlbmd0aCkscz1gXG4gICAgaW50IGluZGV4O2A7Zm9yKGxldCBpPTA7aTx0aGlzLnNsaWNlRGltO2krKylzKz1gXG4gICAgICAgICAgaW5kZXggPSByb3VuZChnZXRJbmRpY2VzKGNvb3Jkc1swXSwgJHtpfSkpO1xuICAgICAgICAgIG91dF9vZl9ib3VuZHMgPSBvdXRfb2ZfYm91bmRzIHx8IGluZGV4IDwgMDtcbiAgICAgICAgICBvdXRfb2ZfYm91bmRzID0gb3V0X29mX2JvdW5kcyB8fCBpbmRleCA+PSAke3RoaXMucGFyYW1zU2hhcGVbaV19O1xuICAgICAgICAgIGZsYXR0ZW5JbmRleCArPSBpbmRleCAqICR7dGhpcy5zdHJpZGVzW2ldfTtgO3RoaXMudXNlckNvZGU9YFxuICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICR7cn0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICAgaW50IGZsYXR0ZW5JbmRleCA9IDA7XG4gICAgICAgICAgYm9vbCBvdXRfb2ZfYm91bmRzID0gZmFsc2U7XG5cbiAgICAgICAgICAke3N9XG5cbiAgICAgICAgICBzZXRPdXRwdXQob3V0X29mX2JvdW5kcyA/IDAuMCA6IGdldFgoZmxhdHRlbkluZGV4LCBjb29yZHNbMV0pKTtcbiAgICAgICAgfVxuICAgICAgYH19O2Z1bmN0aW9uIHNyZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHtwYXJhbXM6YSxpbmRpY2VzOnJ9PXQscz1yLnNoYXBlLGk9c1tzLmxlbmd0aC0xXSxvPXcuc2l6ZUZyb21TaGFwZShhLnNoYXBlKSxbbCx1LHAsZF09VC5wcmVwYXJlQW5kVmFsaWRhdGUoYSxyKSxjPWNlKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpbdSxpXX19KSxoPWNlKHtpbnB1dHM6e3g6YX0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpbdy5zaXplRnJvbVNoYXBlKGEuc2hhcGUpL3AscF19fSk7aWYobi5zaG91bGRFeGVjdXRlT25DUFUoW2Escl0pfHxhLmR0eXBlPT09XCJzdHJpbmdcIil7bGV0IGI9bi5yZWFkU3luYyhyLmRhdGFJZCkseT1uLmJ1ZmZlclN5bmMoYSkseD1vUShiLHksYS5kdHlwZSx1LGkscCxkLGEuc2hhcGUsbyk7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8obCxhLmR0eXBlLHgudmFsdWVzKX1sZXQgbT1uZXcgcnJlKGksZCxbdSxwXSxhLnNoYXBlKSxmPW4ucnVuV2ViR0xQcm9ncmFtKG0sW2gsY10saC5kdHlwZSksZz1jZSh7aW5wdXRzOnt4OmZ9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6bH19KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhjKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGgpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZiksZ312YXIgaXJlPXtrZXJuZWxOYW1lOmd1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOnNyZX0sb3JlPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIixcImluZGljZXNcIl0sdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMucmFuaz10Lmxlbmd0aDtsZXQgbj1odCh0aGlzLnJhbmspLGE9bHJlKGUsMik7dGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICR7bn0gcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGluZGV4ID0gaW50KGdldEluZGljZXMocmVzUkMueCwgcmVzUkMueikpO1xuICAgICAgICBmbG9hdCBpbkJvdW5kcyA9IChpbmRleCA+PSAwKSAmJiAoaW5kZXggPCAke2VbMl19KSA/IDEuMCA6IDAuMDtcbiAgICAgICAgc2V0T3V0cHV0KGluQm91bmRzICogZ2V0QSgke2F9KSk7XG4gICAgICB9XG4gICAgYH19O2Z1bmN0aW9uIGxyZShlLHQpe2xldCBuPVtcInJlc1JDLnhcIixcInJlc1JDLnlcIixcInJlc1JDLnpcIixcInJlc1JDLndcIl0sYT1bXTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKylyPT09Mj9hLnB1c2goXCJpbmRleFwiKTphLnB1c2goYCR7bltyXX1gKTtyZXR1cm4gYS5qb2luKCl9ZnVuY3Rpb24gUUEoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsaW5kaWNlczpzfT10LHtheGlzOmksYmF0Y2hEaW1zOm99PWEsbD13LnBhcnNlQXhpc1BhcmFtKGksci5zaGFwZSlbMF07aWYoRygpLmdldChcIkRFQlVHXCIpKXtsZXQgeT1uLnJlYWRTeW5jKHMuZGF0YUlkKSx4PXIuc2hhcGVbbF07Zm9yKGxldCB2PTA7djx5Lmxlbmd0aDsrK3Ype2xldCBJPXlbdl07dy5hc3NlcnQoSTw9eC0xJiZJPj0wLCgpPT5gR2F0aGVyVjI6IHRoZSBpbmRleCB2YWx1ZSAke0l9IGlzIG5vdCBpbiBbMCwgJHt4LTF9XWApfX1sZXQgdT1ULnNlZ21lbnRfdXRpbC5jb2xsZWN0R2F0aGVyT3BTaGFwZUluZm8ocixzLGwsbykscD13LnNpemVGcm9tU2hhcGUocy5zaGFwZSksZD1bXSxjPWNlKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpbdS5iYXRjaFNpemUsdS5vdXRlclNpemUsdS5kaW1TaXplLHUuc2xpY2VTaXplXX19KSxoPWNlKHtpbnB1dHM6e3g6c30sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpbdS5iYXRjaFNpemUscC91LmJhdGNoU2l6ZV19fSk7ZC5wdXNoKGMpLGQucHVzaChoKTtsZXQgbT1bdS5iYXRjaFNpemUsdS5vdXRlclNpemUscC91LmJhdGNoU2l6ZSx1LnNsaWNlU2l6ZV07aWYobi5zaG91bGRFeGVjdXRlT25DUFUoW3Isc10pfHxyLmR0eXBlPT09XCJzdHJpbmdcIil7bGV0IHk9bi5idWZmZXJTeW5jKGgpLHg9bi5idWZmZXJTeW5jKGMpLHY9bFEoeCx5LG0pO3JldHVybiBkLmZvckVhY2goST0+bi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhJKSksbi5tYWtlVGVuc29ySW5mbyh1Lm91dHB1dFNoYXBlLHYuZHR5cGUsdi52YWx1ZXMpfWxldCBmPW5ldyBvcmUoYy5zaGFwZSxtKSxnPW4ucnVuV2ViR0xQcm9ncmFtKGYsW2MsaF0sYy5kdHlwZSk7ZC5wdXNoKGcpO2xldCBiPWNlKHtpbnB1dHM6e3g6Z30sYmFja2VuZDpuLGF0dHJzOntzaGFwZTp1Lm91dHB1dFNoYXBlfX0pO3JldHVybiBkLmZvckVhY2goeT0+bi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh5KSksYn12YXIgdXJlPXtrZXJuZWxOYW1lOmZ1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlFBfSxwcmU9XCJyZXR1cm4gZmxvYXQoYSA+IGIpO1wiLGNyZT1gXG4gIHJldHVybiB2ZWM0KGdyZWF0ZXJUaGFuKGEsIGIpKTtcbmAsZHJlPWhuKHtvcFNuaXBwZXQ6cHJlLHBhY2tlZE9wU25pcHBldDpjcmUsY3B1S2VybmVsSW1wbDp1USxkdHlwZTpcImJvb2xcIn0pLGhyZT17a2VybmVsTmFtZTpidSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpkcmV9LG1yZT1cInJldHVybiBmbG9hdChhID49IGIpO1wiLGZyZT1gXG4gIHJldHVybiB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoYSwgYikpO1xuYCxncmU9aG4oe29wU25pcHBldDptcmUscGFja2VkT3BTbmlwcGV0OmZyZSxkdHlwZTpcImJvb2xcIixjcHVLZXJuZWxJbXBsOnBRfSksYnJlPXtrZXJuZWxOYW1lOlFpLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmdyZX07ZnVuY3Rpb24geXJlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse2lucHV0OmF9PXQ7cmV0dXJuIEpBKGEsITAsbil9dmFyIHhyZT17a2VybmVsTmFtZTpFbSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzp5cmV9LHZyZT1cInJldHVybiBmbG9hdCghaXNuYW4oeCkgJiYgIWlzaW5mKHgpKTtcIix3cmU9WmUoe29wU25pcHBldDp2cmUsZHR5cGU6XCJib29sXCJ9KSxrcmU9e2tlcm5lbE5hbWU6dG8sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6d3JlfSxJcmU9XCJyZXR1cm4gZmxvYXQoaXNpbmYoeCkpO1wiLFNyZT1aZSh7b3BTbmlwcGV0OklyZSxkdHlwZTpcImJvb2xcIn0pLE5yZT17a2VybmVsTmFtZTpubyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpTcmV9LFRyZT1cInJldHVybiBmbG9hdChpc25hbih4KSk7XCIsQ3JlPVplKHtvcFNuaXBwZXQ6VHJlLGR0eXBlOlwiYm9vbFwifSksRXJlPXtrZXJuZWxOYW1lOmFvLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkNyZX0sX3JlPVwicmV0dXJuIGZsb2F0KGEgPCBiKTtcIixBcmU9YFxuICByZXR1cm4gdmVjNChsZXNzVGhhbihhLCBiKSk7XG5gLEZyZT1obih7b3BTbmlwcGV0Ol9yZSxwYWNrZWRPcFNuaXBwZXQ6QXJlLGNwdUtlcm5lbEltcGw6Y1EsZHR5cGU6XCJib29sXCJ9KSwkcmU9e2tlcm5lbE5hbWU6eXUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6RnJlfSxEcmU9XCJyZXR1cm4gZmxvYXQoYSA8PSBiKTtcIixScmU9YFxuICByZXR1cm4gdmVjNChsZXNzVGhhbkVxdWFsKGEsIGIpKTtcbmAsTXJlPWhuKHtvcFNuaXBwZXQ6RHJlLHBhY2tlZE9wU25pcHBldDpScmUsY3B1S2VybmVsSW1wbDpkUSxkdHlwZTpcImJvb2xcIn0pLE9yZT17a2VybmVsTmFtZTp4dSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpNcmV9O2Z1bmN0aW9uIFByZShlKXtsZXR7YmFja2VuZDp0LGF0dHJzOm59PWUse3N0YXJ0OmEsc3RvcDpyLG51bTpzfT1uLGk9aFEoYSxyLHMpO3JldHVybiB0Lm1ha2VUZW5zb3JJbmZvKFtpLmxlbmd0aF0sXCJmbG9hdDMyXCIsaSl9dmFyIExyZT17a2VybmVsTmFtZTp2dSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpQcmV9LHpyZT1tcCtgXG4gIHJldHVybiB4IDwgMC4wID8gMC4vMC4gOiBsb2coeCk7XG5gLFdyZT1gXG4gIHZlYzQgcmVzdWx0ID0gbG9nKHgpO1xuICBidmVjNCBpc05hTiA9IGlzbmFuKHgpO1xuICByZXN1bHQuciA9IGlzTmFOLnIgPyB4LnIgOiAoeC5yIDwgMC4wID8gMC4vMC4gOiByZXN1bHQucik7XG4gIHJlc3VsdC5nID0gaXNOYU4uZyA/IHguZyA6ICh4LmcgPCAwLjAgPyAwLi8wLiA6IHJlc3VsdC5nKTtcbiAgcmVzdWx0LmIgPSBpc05hTi5iID8geC5iIDogKHguYiA8IDAuMCA/IDAuLzAuIDogcmVzdWx0LmIpO1xuICByZXN1bHQuYSA9IGlzTmFOLmEgPyB4LmEgOiAoeC5hIDwgMC4wID8gMC4vMC4gOiByZXN1bHQuYSk7XG4gIHJldHVybiByZXN1bHQ7XG5gLEJyZT1aZSh7b3BTbmlwcGV0OnpyZSxwYWNrZWRPcFNuaXBwZXQ6V3JlLGNwdUtlcm5lbEltcGw6bVF9KSxWcmU9e2tlcm5lbE5hbWU6c28sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6QnJlfSxVcmU9bXArYFxuICByZXR1cm4gbG9nKDEuMCArIHgpO1xuYCxHcmU9WmUoe29wU25pcHBldDpVcmV9KSxIcmU9e2tlcm5lbE5hbWU6aW8sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6R3JlfSxqcmU9XCJyZXR1cm4gZmxvYXQoYSA+PSAxLjAgJiYgYiA+PSAxLjApO1wiLHFyZT1gXG4gIHJldHVybiB2ZWM0KFxuICAgIHZlYzQoZ3JlYXRlclRoYW5FcXVhbChhLCB2ZWM0KDEuMCkpKSAqXG4gICAgdmVjNChncmVhdGVyVGhhbkVxdWFsKGIsIHZlYzQoMS4wKSkpKTtcbmAsS3JlPWhuKHtvcFNuaXBwZXQ6anJlLHBhY2tlZE9wU25pcHBldDpxcmUsZHR5cGU6XCJib29sXCJ9KSxYcmU9e2tlcm5lbE5hbWU6d3UsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6S3JlfSxZcmU9XCJyZXR1cm4gZmxvYXQoISh4ID49IDEuMCkpO1wiLFpyZT1aZSh7b3BTbmlwcGV0OllyZX0pLEpyZT17a2VybmVsTmFtZTprdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpacmV9LFFyZT1cInJldHVybiBmbG9hdChhID49IDEuMCB8fCBiID49IDEuMCk7XCIsZXNlPWBcbiAgcmV0dXJuIG1pbihcbiAgICB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoYSwgdmVjNCgxLjApKSkgK1xuICAgIHZlYzQoZ3JlYXRlclRoYW5FcXVhbChiLCB2ZWM0KDEuMCkpKSxcbiAgICB2ZWM0KDEuMCkpO1xuYCx0c2U9aG4oe29wU25pcHBldDpRcmUscGFja2VkT3BTbmlwcGV0OmVzZSxkdHlwZTpcImJvb2xcIn0pLG5zZT17a2VybmVsTmFtZTpJdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzp0c2V9LGFzZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixhLHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMub3V0cHV0U2hhcGU9W107bGV0IHM9dCxpPWVbM10tMTt0aGlzLm91dHB1dFNoYXBlPWU7bGV0IG8sbD1gZmxvYXQoJHtufSkgKyBmbG9hdCgke2F9KSAqIHN1bWA7cj09PS41P289YGludmVyc2VzcXJ0KCR7bH0pYDpyPT09MT9vPWAxLjAvKCR7bH0pYDpvPWBleHAobG9nKCR7bH0pICogZmxvYXQoLSR7cn0pKTtgLHRoaXMudXNlckNvZGU9YFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xuICAgICAgICBpbnQgYyA9IGNvb3Jkc1syXTtcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XG4gICAgICAgIGZsb2F0IHggPSBnZXRYKGIsIHIsIGMsIGQpO1xuICAgICAgICBmbG9hdCBzdW0gPSAwLjA7XG4gICAgICAgIGZvciAoaW50IGogPSAtJHtzfTsgaiA8PSAke3N9OyBqKyspIHtcbiAgICAgICAgICBpbnQgaWR4ID0gZCArIGo7XG4gICAgICAgICAgaWYgKGlkeCA+PSAwICYmIGlkeCA8PSAgJHtpfSkge1xuICAgICAgICAgICAgZmxvYXQgeiA9IGdldFgoYiwgciwgYywgaWR4KTtcbiAgICAgICAgICAgIHN1bSArPSB6ICogejtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmxvYXQgdmFsID0geCAqICR7b307XG4gICAgICAgIHNldE91dHB1dCh2YWwpO1xuICAgICAgfVxuICAgIGB9fSxyc2U9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4sYSxyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwO2xldCBzPXQsaT1lWzNdLTE7dGhpcy5vdXRwdXRTaGFwZT1lO2xldCBvLGw9YGZsb2F0KCR7bn0pICsgZmxvYXQoJHthfSkgKiBzdW1gO3I9PT0uNT9vPWBpbnZlcnNlc3FydCgke2x9KWA6cj09PTE/bz1gMS4wLygke2x9KWA6bz1gZXhwKGxvZygke2x9KSAqIGZsb2F0KC0ke3J9KSk7YCx0aGlzLnVzZXJDb2RlPWBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiID0gY29vcmRzLng7XG4gICAgICAgIGludCByID0gY29vcmRzLnk7XG4gICAgICAgIGludCBjID0gY29vcmRzLno7XG4gICAgICAgIGludCBkID0gY29vcmRzLnc7XG5cbiAgICAgICAgYm9vbCBoYXNOZXh0Q29sID0gZCA8ICR7dGhpcy5vdXRwdXRTaGFwZVszXX07XG4gICAgICAgIGJvb2wgaGFzTmV4dFJvdyA9IGMgPCAke3RoaXMub3V0cHV0U2hhcGVbMl19O1xuXG4gICAgICAgIHZlYzQgc3VtID0gdmVjNCgwLik7XG4gICAgICAgIHZlYzQgeEZyYWdBdE91dHB1dENvb3JkcyA9IGdldFgoYiwgciwgYywgZCk7XG5cbiAgICAgICAgdmVjNCB4QXRPdXRwdXRDb29yZHMgPSB2ZWM0KFxuICAgICAgICAgIGdldENoYW5uZWwoeEZyYWdBdE91dHB1dENvb3JkcywgdmVjMihjLCBkKSksXG4gICAgICAgICAgaGFzTmV4dENvbCA/XG4gICAgICAgICAgICBnZXRDaGFubmVsKHhGcmFnQXRPdXRwdXRDb29yZHMsIHZlYzIoYywgZCArIDEpKSA6IDAuMCxcbiAgICAgICAgICBoYXNOZXh0Um93ID9cbiAgICAgICAgICAgIGdldENoYW5uZWwoeEZyYWdBdE91dHB1dENvb3JkcyAsIHZlYzIoYyArIDEsIGQpKSA6IDAuMCxcbiAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/XG4gICAgICAgICAgICBnZXRDaGFubmVsKHhGcmFnQXRPdXRwdXRDb29yZHMsIHZlYzIoYyArIDEsIGQgKyAxKSkgOiAwLjBcbiAgICAgICAgKTtcblxuICAgICAgICBpbnQgZmlyc3RDaGFubmVsID0gZCAtICR7c307XG4gICAgICAgIHZlYzIgY2FjaGUgPSB2ZWMyKDAuKTtcbiAgICAgICAgaWYoZmlyc3RDaGFubmVsID49IDApe1xuICAgICAgICAgIHZlYzQgZmlyc3RDaGFubmVsRnJhZyA9IGdldFgoYiwgciwgYywgZmlyc3RDaGFubmVsKTtcbiAgICAgICAgICBjYWNoZS54ID0gZ2V0Q2hhbm5lbChmaXJzdENoYW5uZWxGcmFnLCB2ZWMyKGMsIGZpcnN0Q2hhbm5lbCkpO1xuICAgICAgICAgICAgaWYoaGFzTmV4dFJvdyl7XG4gICAgICAgICAgICAgIGNhY2hlLnkgPSBnZXRDaGFubmVsKGZpcnN0Q2hhbm5lbEZyYWcsIHZlYzIoYyArIDEsIGZpcnN0Q2hhbm5lbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaXZlYzIgZGVwdGggPSBpdmVjMihkLCBkICsgMSk7XG4gICAgICAgIGZvciAoaW50IGogPSAtICR7c307IGogPD0gJHtzfTsgaisrKSB7XG4gICAgICAgICAgaXZlYzIgaWR4ID0gZGVwdGggKyBqO1xuICAgICAgICAgIGJ2ZWMyIGFib3ZlTG93ZXJCb3VuZCA9IGdyZWF0ZXJUaGFuRXF1YWwoaWR4LCBpdmVjMigwKSk7XG4gICAgICAgICAgYnZlYzIgYmVsb3dVcHBlckJvdW5kID0gbGVzc1RoYW5FcXVhbChpZHgsIGl2ZWMyKCR7aX0pKTtcblxuICAgICAgICAgIGJvb2wgZGVwdGhJblJhbmdlID0gYWJvdmVMb3dlckJvdW5kLnggJiYgYmVsb3dVcHBlckJvdW5kLng7XG4gICAgICAgICAgYm9vbCBkZXB0aFBsdXNPbmVJblJhbmdlID0gYWJvdmVMb3dlckJvdW5kLnkgJiYgYmVsb3dVcHBlckJvdW5kLnk7XG5cbiAgICAgICAgICBpZihkZXB0aEluUmFuZ2UgfHwgZGVwdGhQbHVzT25lSW5SYW5nZSl7XG4gICAgICAgICAgICB2ZWM0IHogPSB2ZWM0KDAuKTtcbiAgICAgICAgICAgIHZlYzQgeEZyYWdBdEN1cnJlbnREZXB0aDtcbiAgICAgICAgICAgIHoueHogPSBjYWNoZS54eTtcbiAgICAgICAgICAgIGlmKGRlcHRoUGx1c09uZUluUmFuZ2UgJiYgaGFzTmV4dENvbCl7XG4gICAgICAgICAgICAgIHhGcmFnQXRDdXJyZW50RGVwdGggPSBpZHgueSAhPSBkID9cbiAgICAgICAgICAgICAgICBnZXRYKGIsIHIsIGMsIGlkeC55KSA6IHhGcmFnQXRPdXRwdXRDb29yZHM7XG4gICAgICAgICAgICAgIHoueSA9IGdldENoYW5uZWwoeEZyYWdBdEN1cnJlbnREZXB0aCwgdmVjMihjLCBpZHgueSkpO1xuICAgICAgICAgICAgICBpZihoYXNOZXh0Um93KXtcbiAgICAgICAgICAgICAgICB6LncgPSBnZXRDaGFubmVsKHhGcmFnQXRDdXJyZW50RGVwdGgsIHZlYzIoYyArIDEsIGlkeC55KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhY2hlLnh5ID0gei55dztcbiAgICAgICAgICAgIHN1bSArPSB6ICogejtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmVjNCByZXN1bHQgPSB4QXRPdXRwdXRDb29yZHMgKiAke299O1xuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcbiAgICAgIH1cbiAgICBgfX0sc3NlPWU9PntsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7ZGVwdGhSYWRpdXM6cyxiaWFzOmksYWxwaGE6byxiZXRhOmx9PWEsdT1HKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfTk9STUFMSVpBVElPTlwiKT9uZXcgcnNlKHIuc2hhcGUscyxpLG8sbCk6bmV3IGFzZShyLnNoYXBlLHMsaSxvLGwpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbSh1LFtyXSxyLmR0eXBlKX0saXNlPXtrZXJuZWxOYW1lOm9vLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOnNzZX0sb3NlPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuLGEscil7dGhpcy52YXJpYWJsZU5hbWVzPVtcImlucHV0SW1hZ2VcIixcIm91dHB1dEltYWdlXCIsXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLmRlcHRoPWVbM10sdGhpcy5kZXB0aFJhZGl1cz10LHRoaXMuYmlhcz1uLHRoaXMuYWxwaGE9YSx0aGlzLmJldGE9cix0aGlzLnVzZXJDb2RlPWBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xuICAgICAgICBpbnQgciA9IGNvb3Jkc1sxXTtcbiAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XG5cbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gMC4wO1xuICAgICAgICBmb3IgKGludCBkID0gMDsgZCA8ICR7dGhpcy5kZXB0aH07ICsrZCkge1xuICAgICAgICAgIGludCBkZXB0aEJlZ2luID0gaW50KG1heCgwLjAsIGZsb2F0KGQgLSAke3R9KSkpO1xuICAgICAgICAgIGludCBkZXB0aEVuZCA9IGludChtaW4oZmxvYXQoJHt0aGlzLmRlcHRofSksXG4gICAgICAgICAgICAgIGZsb2F0KGQgKyAke3R9ICsgMSkpKTtcblxuICAgICAgICAgIGNvbnN0IGludCBNSU5fREVQVEhfQkVHSU4gPSAwO1xuICAgICAgICAgIGNvbnN0IGludCBNQVhfREVQVEhfRU5EID0gJHt0aGlzLmRlcHRofTtcblxuICAgICAgICAgIGZsb2F0IG5vcm0gPSAwLjA7XG4gICAgICAgICAgZm9yIChpbnQgayA9IE1JTl9ERVBUSF9CRUdJTjsgayA8IE1BWF9ERVBUSF9FTkQ7ICsraykge1xuICAgICAgICAgICAgaWYgKGsgPCBkZXB0aEJlZ2luKXtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrID49IGRlcHRoQmVnaW4gJiYgayA8IGRlcHRoRW5kKSB7XG4gICAgICAgICAgICAgIG5vcm0gKz0gZ2V0SW5wdXRJbWFnZShiLCByLCBjLCBrKSAqIGdldElucHV0SW1hZ2UoYiwgciwgYywgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9ybSA9IGZsb2F0KCR7YX0pICogbm9ybSArIGZsb2F0KCR7bn0pO1xuXG4gICAgICAgICAgZm9yKGludCBrID0gTUlOX0RFUFRIX0JFR0lOOyBrIDwgTUFYX0RFUFRIX0VORDsgKytrKXtcbiAgICAgICAgICAgIGlmIChrIDwgZGVwdGhCZWdpbil7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoayA+PSBkZXB0aEJlZ2luICYmIGsgPCBkZXB0aEVuZCl7XG4gICAgICAgICAgICAgIGZsb2F0IGR5aSA9IC0yLjAgKiBmbG9hdCgke2F9KVxuICAgICAgICAgICAgICAgICogZmxvYXQoJHtyfSlcbiAgICAgICAgICAgICAgICAqIGdldElucHV0SW1hZ2UoYiwgciwgYywgaykgKiBnZXRPdXRwdXRJbWFnZShiLCByLCBjLCBkKVxuICAgICAgICAgICAgICAgIC8gbm9ybTtcbiAgICAgICAgICAgICAgaWYgKGsgPT0gZCkge1xuICAgICAgICAgICAgICAgIGR5aSArPSBwb3cobm9ybSwgLTEuMCAqICR7cn0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChrID09IGNvb3Jkc1szXSkge1xuICAgICAgICAgICAgICAgIGR5aSAqPSBnZXREeShiLCByLCBjLCBkKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZHlpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgYH19LGxzZT1lPT57bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIseTpzLGR5Oml9PXQse2RlcHRoUmFkaXVzOm8sYmlhczpsLGFscGhhOnUsYmV0YTpwfT1hLGQ9bmV3IG9zZShyLnNoYXBlLG8sbCx1LHApO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShkLFtyLHMsaV0sci5kdHlwZSl9LHVzZT17a2VybmVsTmFtZTpTdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpsc2V9O2Z1bmN0aW9uIHBzZShlLHQsbixhKXtsZXQgcj13LnNpemVGcm9tU2hhcGUodCkscz13LnNpemVGcm9tU2hhcGUoZS5zaGFwZSkvcixpPWNlKHtpbnB1dHM6e3g6ZX0sYXR0cnM6e3NoYXBlOltzLHJdfSxiYWNrZW5kOmF9KSxvPWVsKGksZS5kdHlwZSxcIm1heFwiLGEpLGw9Y2Uoe2lucHV0czp7eDpvfSxhdHRyczp7c2hhcGU6bn0sYmFja2VuZDphfSk7cmV0dXJuIGEuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaSksYS5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhvKSxsfWZ1bmN0aW9uIGVGKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtyZWR1Y3Rpb25JbmRpY2VzOnMsa2VlcERpbXM6aX09YSxvPXIuc2hhcGUubGVuZ3RoLGw9dy5wYXJzZUF4aXNQYXJhbShzLHIuc2hhcGUpLHU9bCxwPVQuZ2V0QXhlc1Blcm11dGF0aW9uKHUsbyksZD1wIT1udWxsLGM9bi5zaG91bGRFeGVjdXRlT25DUFUoW3JdKSxoPXI7aWYoZCl7aWYoYyl7bGV0IHk9bi50ZXhEYXRhLmdldChoLmRhdGFJZCkudmFsdWVzLHg9bmV3IEFycmF5KG8pO2ZvcihsZXQgTj0wO048eC5sZW5ndGg7TisrKXhbTl09ci5zaGFwZVtwW05dXTtsZXQgdj1vayh5LHIuc2hhcGUsci5kdHlwZSxwLHgpO2g9bi5tYWtlVGVuc29ySW5mbyh4LHIuZHR5cGUpO2xldCBJPW4udGV4RGF0YS5nZXQoaC5kYXRhSWQpO0kudmFsdWVzPXZ9ZWxzZSBoPUJmKHIscCxuKTt1PVQuZ2V0SW5uZXJNb3N0QXhlcyh1Lmxlbmd0aCxvKX1ULmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwibWF4XCIsdSxvKTtsZXRbbSxmXT1ULmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoaC5zaGFwZSx1KSxnPW07aSYmKGc9VC5leHBhbmRTaGFwZVRvS2VlcERpbShtLGwpKTtsZXQgYjtpZihjKXtsZXQgeT1uLnRleERhdGEuZ2V0KGguZGF0YUlkKS52YWx1ZXMseD1mUSh5LHcuc2l6ZUZyb21TaGFwZShmKSxnLHIuZHR5cGUpO2I9bi5tYWtlVGVuc29ySW5mbyhnLHIuZHR5cGUpO2xldCB2PW4udGV4RGF0YS5nZXQoYi5kYXRhSWQpO3YudmFsdWVzPXh9ZWxzZSBiPXBzZShoLGYsZyxuKTtyZXR1cm4gZCYmbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhoKSxifXZhciBjc2U9e2tlcm5lbE5hbWU6bG8sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6ZUZ9LGRzZT11aytgXG4gIHJldHVybiBtYXgoYSwgYik7XG5gLGhzZT1gXG4gIHZlYzQgcmVzdWx0ID0gdmVjNChtYXgoYSwgYikpO1xuICBidmVjNCBpc05hTkEgPSBpc25hbihhKTtcbiAgYnZlYzQgaXNOYU5CID0gaXNuYW4oYik7XG4gIGJ2ZWM0IGlzTmFOID0gYnZlYzQoaXNOYU5BLnggfHwgaXNOYU5CLngsIGlzTmFOQS55IHx8IGlzTmFOQi55LCBpc05hTkEueiB8fCBpc05hTkIueiwgaXNOYU5BLncgfHwgaXNOYU5CLncpO1xuICBgK1FvK2BcbiAgcmV0dXJuIHJlc3VsdDtcbmAsbXNlPWhuKHtvcFNuaXBwZXQ6ZHNlLHBhY2tlZE9wU25pcHBldDpoc2UsY3B1S2VybmVsSW1wbDpnUX0pLGZzZT17a2VybmVsTmFtZTp1byxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzptc2V9O2Z1bmN0aW9uIGdzZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dDtscChyLFwibWF4UG9vbFwiKTtsZXR7ZmlsdGVyU2l6ZTpzLHN0cmlkZXM6aSxwYWQ6byxkaW1Sb3VuZGluZ01vZGU6bH09YSx1PTE7dy5hc3NlcnQoVC5laXRoZXJTdHJpZGVzT3JEaWxhdGlvbnNBcmVPbmUoaSx1KSwoKT0+YEVycm9yIGluIG1heFBvb2w6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzICR7aX0gYW5kIGRpbGF0aW9ucyAnJHt1fSdgKTtsZXQgcD1ULmNvbXB1dGVQb29sMkRJbmZvKHIuc2hhcGUscyxpLHUsbyxsKTtpZihwLmZpbHRlcldpZHRoPT09MSYmcC5maWx0ZXJIZWlnaHQ9PT0xJiZ3LmFycmF5c0VxdWFsKHAuaW5TaGFwZSxwLm91dFNoYXBlKSlyZXR1cm4gdGEoe2lucHV0czp7eDpyfSxiYWNrZW5kOm59KTtsZXQgZD1uZXcgRWMocCxcIm1heFwiLCExKTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0oZCxbcl0sci5kdHlwZSl9dmFyIGJzZT17a2VybmVsTmFtZTpwbyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpnc2V9O2Z1bmN0aW9uIHlzZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7ZmlsdGVyU2l6ZTpzLHN0cmlkZXM6aSxwYWQ6byxkYXRhRm9ybWF0OmwsZGltUm91bmRpbmdNb2RlOnV9PWEscD1bMSwxLDFdLGQ9VC5jb21wdXRlUG9vbDNESW5mbyhyLnNoYXBlLHMsaSxwLG8sdSxsKSxjPW5ldyBjayhkLFwibWF4XCIsITEpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShjLFtyXSxyLmR0eXBlKX12YXIgeHNlPXtrZXJuZWxOYW1lOk51LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOnlzZX0sdnNlPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwibWF4UG9zXCJdLHRoaXMub3V0cHV0U2hhcGU9ZS5pblNoYXBlO2xldCB0PWUuc3RyaWRlSGVpZ2h0LG49ZS5zdHJpZGVXaWR0aCxhPWUuZGlsYXRpb25IZWlnaHQscj1lLmVmZmVjdGl2ZUZpbHRlckhlaWdodCxzPWUuZWZmZWN0aXZlRmlsdGVyV2lkdGgsaT1yLTEtZS5wYWRJbmZvLnRvcCxvPXMtMS1lLnBhZEluZm8ubGVmdCxsPXIqcy0xO3RoaXMudXNlckNvZGU9YFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKCR7aX0sICR7b30pO1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XG5cbiAgICAgICAgaXZlYzIgZHlSQ0Nvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeVJDQ29ybmVyLng7XG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeVJDQ29ybmVyLnk7XG5cbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZCkgd2l0aCBwb3MgbWFzayg6LCA6LCBkKSB0byBnZXQgZHgoeFIsIHhDLCBkKS5cbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCAke3J9O1xuICAgICAgICAgIHdSICs9ICR7YX0pIHtcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyAke3R9LjA7XG5cbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke2Uub3V0SGVpZ2h0fS4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xuXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7c307IHdDKyspIHtcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvICR7bn0uMDtcblxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gJHtlLm91dFdpZHRofS4wIHx8XG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XG5cbiAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCBpZHlSLCBpZHlDLCBkKTtcbiAgICAgICAgICAgIGludCBtYXhQb3NWYWx1ZSA9ICR7bH0gLSBpbnQoZ2V0TWF4UG9zKGIsIGlkeVIsIGlkeUMsIGQpKTtcblxuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHZhbHVlLCBjaGVjayBpdCBhZ2FpbnN0IHRoZSB2YWx1ZSBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gcG9zaXRpb24gbWF0cml4LlxuICAgICAgICAgICAgaW50IGN1clBvc1ZhbHVlID0gd1IgKiAke3N9ICsgd0M7XG4gICAgICAgICAgICBmbG9hdCBtYXNrID0gZmxvYXQobWF4UG9zVmFsdWUgPT0gY3VyUG9zVmFsdWUgPyAxLjAgOiAwLjApO1xuXG4gICAgICAgICAgICBkb3RQcm9kICs9IGR5VmFsdWUgKiBtYXNrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XG4gICAgICB9XG4gICAgYH19LHdzZT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIixcIm1heFBvc1wiXSx0aGlzLm91dHB1dFNoYXBlPWUuaW5TaGFwZTtsZXQgdD1lLnN0cmlkZURlcHRoLG49ZS5zdHJpZGVIZWlnaHQsYT1lLnN0cmlkZVdpZHRoLHI9ZS5kaWxhdGlvbkRlcHRoLHM9ZS5kaWxhdGlvbkhlaWdodCxpPWUuZGlsYXRpb25XaWR0aCxvPWUuZWZmZWN0aXZlRmlsdGVyRGVwdGgsbD1lLmVmZmVjdGl2ZUZpbHRlckhlaWdodCx1PWUuZWZmZWN0aXZlRmlsdGVyV2lkdGgscD1vLTEtZS5wYWRJbmZvLmZyb250LGQ9bC0xLWUucGFkSW5mby50b3AsYz11LTEtZS5wYWRJbmZvLmxlZnQsaD1vKmwqdS0xO3RoaXMudXNlckNvZGU9YFxuICAgICAgY29uc3QgaXZlYzMgcGFkcyA9IGl2ZWMzKCR7cH0sICR7ZH0sICR7Y30pO1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcbiAgICAgICAgaW50IGNoID0gY29vcmRzLnU7XG5cbiAgICAgICAgaXZlYzMgZHlDb3JuZXIgPSBpdmVjMyhjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy53KSAtIHBhZHM7XG4gICAgICAgIGludCBkeURDb3JuZXIgPSBkeUNvcm5lci54O1xuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueTtcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLno7XG5cbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgPywgY2gpIHdpdGggcG9zIG1hc2soOiwgOiwgOiwgZCkgdG8gZ2V0XG4gICAgICAgIC8vIGR4KHhELCB4UiwgeEMsIGNoKS5cbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XG5cbiAgICAgICAgZm9yIChpbnQgd0QgPSAwOyB3RCA8ICR7b307XG4gICAgICAgICAgIHdEICs9ICR7cn0pIHtcbiAgICAgICAgICBmbG9hdCBkeUQgPSBmbG9hdChkeURDb3JuZXIgKyB3RCkgLyAke3R9LjA7XG5cbiAgICAgICAgICBpZiAoZHlEIDwgMC4wIHx8IGR5RCA+PSAke2Uub3V0RGVwdGh9LjAgfHwgZnJhY3QoZHlEKSA+IDAuMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGludCBpZHlEID0gaW50KGR5RCk7XG5cbiAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgJHtsfTtcbiAgICAgICAgICAgICAgd1IgKz0gJHtzfSkge1xuICAgICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gJHtufS4wO1xuXG4gICAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke2Uub3V0SGVpZ2h0fS4wIHx8XG4gICAgICAgICAgICAgICAgZnJhY3QoZHlSKSA+IDAuMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XG5cbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCAke3V9O1xuICAgICAgICAgICAgICAgIHdDICs9ICR7aX0pIHtcbiAgICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gJHthfS4wO1xuXG4gICAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49ICR7ZS5vdXRXaWR0aH0uMCB8fFxuICAgICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XG5cbiAgICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGJhdGNoLCBpZHlELCBpZHlSLCBpZHlDLCBjaCk7XG4gICAgICAgICAgICAgIGludCBtYXhQb3NWYWx1ZSA9ICR7aH0gLVxuICAgICAgICAgICAgICAgICAgaW50KGdldE1heFBvcyhiYXRjaCwgaWR5RCwgaWR5UiwgaWR5QywgY2gpKTtcblxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgdmFsdWUsIGNoZWNrIGl0IGFnYWluc3QgdGhlIHZhbHVlIGZyb20gdGhlXG4gICAgICAgICAgICAgIC8vIHBvc2l0aW9uIG1hdHJpeC5cbiAgICAgICAgICAgICAgaW50IGN1clBvc1ZhbHVlID1cbiAgICAgICAgICAgICAgICAgIHdEICogJHtsfSAqICR7dX0gK1xuICAgICAgICAgICAgICAgICAgd1IgKiAke3V9ICsgd0M7XG4gICAgICAgICAgICAgIGZsb2F0IG1hc2sgPSBmbG9hdChtYXhQb3NWYWx1ZSA9PSBjdXJQb3NWYWx1ZSA/IDEuMCA6IDAuMCk7XG5cbiAgICAgICAgICAgICAgZG90UHJvZCArPSBkeVZhbHVlICogbWFzaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xuICAgICAgfVxuICAgIGB9fTtmdW5jdGlvbiBrc2UoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtkeTpyLGlucHV0OnN9PXQsaT1zLHtmaWx0ZXJTaXplOm8sc3RyaWRlczpsLHBhZDp1LGRpbVJvdW5kaW5nTW9kZTpwfT1hLGQ9WzEsMSwxXSxjPVQuY29tcHV0ZVBvb2wzREluZm8oaS5zaGFwZSxvLGwsZCx1LHApLGg9bmV3IGNrKGMsXCJtYXhcIiwhMCksbT1uLnJ1bldlYkdMUHJvZ3JhbShoLFtpXSxpLmR0eXBlKSxmPW5ldyB3c2UoYyksZz1uLnJ1bldlYkdMUHJvZ3JhbShmLFtyLG1dLGkuZHR5cGUpO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG0pLGd9dmFyIElzZT17a2VybmVsTmFtZTpCYyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzprc2V9O2Z1bmN0aW9uIFNzZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2R5OnIsaW5wdXQ6cyxvdXRwdXQ6aX09dCxvPXM7bHAoW3MsaV0sXCJtYXhQb29sR3JhZFwiKTtsZXR7ZmlsdGVyU2l6ZTpsLHN0cmlkZXM6dSxwYWQ6cCxkaW1Sb3VuZGluZ01vZGU6ZH09YSxjPVQuY29tcHV0ZVBvb2wyREluZm8oby5zaGFwZSxsLHUsMSxwLGQpLGg9ITAsbT1uZXcgRWMoYyxcIm1heFwiLGgpLGY9bi5ydW5XZWJHTFByb2dyYW0obSxbb10sby5kdHlwZSksZz1uZXcgdnNlKGMpLGI9bi5ydW5XZWJHTFByb2dyYW0oZyxbcixmXSxvLmR0eXBlKTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhmKSxifXZhciBOc2U9e2tlcm5lbE5hbWU6V2MsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6U3NlfTtmdW5jdGlvbiBUc2UoZSx0LG4sYSl7bGV0IHI9bmV3IEVjKG4sXCJtYXhcIiwhMSkscz1hLnJ1bldlYkdMUHJvZ3JhbShyLFtlXSxcImZsb2F0MzJcIik7cj1uZXcgRWMobixcIm1heFwiLCEwLCEwLHQpO2xldCBpPWEucnVuV2ViR0xQcm9ncmFtKHIsW2VdLFwiZmxvYXQzMlwiKTtyZXR1cm5bcyxpXX12YXIgQ3NlPXtrZXJuZWxOYW1lOlZjLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOih7aW5wdXRzOmUsYXR0cnM6dCxiYWNrZW5kOm59KT0+e2xldHt4OmF9PWUse2ZpbHRlclNpemU6cixzdHJpZGVzOnMscGFkOmksaW5jbHVkZUJhdGNoSW5JbmRleDpvfT10LGw9bjt3LmFzc2VydChhLnNoYXBlLmxlbmd0aD09PTQsKCk9PmBFcnJvciBpbiBtYXhQb29sOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgJHthLnNoYXBlLmxlbmd0aH0uYCk7bGV0IHU9WzEsMV07dy5hc3NlcnQoVC5laXRoZXJTdHJpZGVzT3JEaWxhdGlvbnNBcmVPbmUocyx1KSwoKT0+YEVycm9yIGluIG1heFBvb2w6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzICR7c30gYW5kIGRpbGF0aW9ucyAnJHt1fSdgKTtsZXQgcD1ULmNvbXB1dGVQb29sMkRJbmZvKGEuc2hhcGUscixzLHUsaSksW2QsY109VHNlKGEsbyxwLGwpO3JldHVybltkLGNdfX07ZnVuY3Rpb24gRXNlKGUsdCxuLGEpe2xldCByPXcuc2l6ZUZyb21TaGFwZSh0KSxzPXcuc2l6ZUZyb21TaGFwZShlLnNoYXBlKS9yLGk9Y2Uoe2lucHV0czp7eDplfSxhdHRyczp7c2hhcGU6W3Mscl19LGJhY2tlbmQ6YX0pLG89ZWwoaSxcImZsb2F0MzJcIixcIm1lYW5cIixhKSxsPWNlKHtpbnB1dHM6e3g6b30sYXR0cnM6e3NoYXBlOm59LGJhY2tlbmQ6YX0pO3JldHVybiBhLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGkpLGEuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obyksbH12YXIgX3NlPXtrZXJuZWxOYW1lOmNvLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOih7aW5wdXRzOmUsYXR0cnM6dCxiYWNrZW5kOm59KT0+e2xldHt4OmF9PWUse2tlZXBEaW1zOnIsYXhpczpzfT10LGk9bixvPWEuc2hhcGUubGVuZ3RoLGw9dy5wYXJzZUF4aXNQYXJhbShzLGEuc2hhcGUpLHU9bCxwPVQuZ2V0QXhlc1Blcm11dGF0aW9uKHUsbyksZD1wIT1udWxsLGM9aS5zaG91bGRFeGVjdXRlT25DUFUoW2FdKSxoPVtdLG09YTtpZihkKXtpZihjKXtsZXQgeD1pLnRleERhdGEuZ2V0KG0uZGF0YUlkKS52YWx1ZXMsdj1uZXcgQXJyYXkobyk7Zm9yKGxldCBDPTA7Qzx2Lmxlbmd0aDtDKyspdltDXT1hLnNoYXBlW3BbQ11dO2xldCBJPW9rKHgsYS5zaGFwZSxhLmR0eXBlLHAsdik7bT1pLm1ha2VUZW5zb3JJbmZvKHYsYS5kdHlwZSk7bGV0IE49aS50ZXhEYXRhLmdldChtLmRhdGFJZCk7Ti52YWx1ZXM9SX1lbHNlIG09QmYoYSxwLGkpO2gucHVzaChtKSx1PVQuZ2V0SW5uZXJNb3N0QXhlcyh1Lmxlbmd0aCxvKX1ULmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwic3VtXCIsdSxvKTtsZXRbZixnXT1ULmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMobS5zaGFwZSx1KSxiPWY7ciYmKGI9VC5leHBhbmRTaGFwZVRvS2VlcERpbShmLGwpKTtsZXQgeT1Fc2UobSxnLGIsaSk7Zm9yKGxldCB4IG9mIGgpaS5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh4KTtyZXR1cm4geX19O2Z1bmN0aW9uIEFzZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7YXhpczpzLGtlZXBEaW1zOml9PWEsbz1yLnNoYXBlLmxlbmd0aCxsPXcucGFyc2VBeGlzUGFyYW0ocyxyLnNoYXBlKSx1PWwscD1ULmdldEF4ZXNQZXJtdXRhdGlvbih1LG8pLGQ9cjtwIT1udWxsJiYoZD1Tbih7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bixhdHRyczp7cGVybTpwfX0pLHU9VC5nZXRJbm5lck1vc3RBeGVzKHUubGVuZ3RoLHIuc2hhcGUubGVuZ3RoKSksVC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcIm1pblwiLHUsbyk7bGV0W2MsaF09VC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGQuc2hhcGUsdSksbT13LnNpemVGcm9tU2hhcGUoaCksZj1jZSh7aW5wdXRzOnt4OmR9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6Wy0xLG1dfX0pLGc9ZWwoZixmLmR0eXBlLFwibWluXCIsbiksYjtpZihpKXtsZXQgeT1ULmV4cGFuZFNoYXBlVG9LZWVwRGltKGMsbCk7Yj1jZSh7aW5wdXRzOnt4Omd9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6eX19KX1lbHNlIGI9Y2Uoe2lucHV0czp7eDpnfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOmN9fSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZiksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhnKSxwIT1udWxsJiZuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGQpLGJ9dmFyIEZzZT17a2VybmVsTmFtZTpobyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpBc2V9LCRzZT11aytgXG4gIHJldHVybiBtaW4oYSwgYik7XG5gLERzZT1gXG4gIHZlYzQgcmVzdWx0ID0gdmVjNChtaW4oYSwgYikpO1xuICBidmVjNCBpc05hTkEgPSBpc25hbihhKTtcbiAgYnZlYzQgaXNOYU5CID0gaXNuYW4oYik7XG4gIGJ2ZWM0IGlzTmFOID0gYnZlYzQoaXNOYU5BLnggfHwgaXNOYU5CLngsIGlzTmFOQS55IHx8IGlzTmFOQi55LCBpc05hTkEueiB8fCBpc05hTkIueiwgaXNOYU5BLncgfHwgaXNOYU5CLncpO1xuICBgK1FvK2BcbiAgcmV0dXJuIHJlc3VsdDtcbmAsUnNlPWhuKHtvcFNuaXBwZXQ6JHNlLHBhY2tlZE9wU25pcHBldDpEc2UsY3B1S2VybmVsSW1wbDpiUX0pLE1zZT17a2VybmVsTmFtZTptbyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpSc2V9LE9zZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT10Lm1hcCgodSxwKT0+dVswXStlW3BdK3VbMV0pO2xldCBhPWUubGVuZ3RoLHI9aHQoYSkscz10Lm1hcCh1PT51WzBdKS5qb2luKFwiLFwiKSxpPXQubWFwKCh1LHApPT51WzBdK2VbcF0pLmpvaW4oXCIsXCIpLG89W1wiY29vcmRzWzBdXCIsXCJjb29yZHNbMV1cIixcImNvb3Jkc1syXVwiLFwiY29vcmRzWzNdXCJdLnNsaWNlKDAsYSksbD1uPT09XCJyZWZsZWN0XCI/MDoxO2lmKGE9PT0xKXt0aGlzLnVzZXJDb2RlPWBcbiAgICAgICAgaW50IHN0YXJ0ID0gJHtzfTtcbiAgICAgICAgaW50IGVuZCA9ICR7aX07XG5cbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgIGludCBvdXRDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICAgaWYgKG91dEMgPCBzdGFydCkge1xuICAgICAgICAgICAgb3V0QyA9IHN0YXJ0ICogMiAtIG91dEMgLSAke2x9O1xuICAgICAgICAgIH0gZWxzZSBpZihvdXRDID49IGVuZCkge1xuICAgICAgICAgICAgb3V0QyA9IChlbmQgLSAxKSAqIDIgLSBvdXRDICsgJHtsfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0T3V0cHV0KGdldFgob3V0QyAtIHN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICAgIGA7cmV0dXJufXRoaXMudXNlckNvZGU9YFxuICAgICAgJHtyfSBzdGFydCA9ICR7cn0oJHtzfSk7XG4gICAgICAke3J9IGVuZCA9ICR7cn0oJHtpfSk7XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgJHtyfSBvdXRDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHthfTsgaSsrKSB7XG4gICAgICAgICAgaWYgKG91dENbaV0gPCBzdGFydFtpXSkge1xuICAgICAgICAgICAgb3V0Q1tpXSA9IHN0YXJ0W2ldICogMiAtIG91dENbaV0gLSAke2x9O1xuICAgICAgICAgIH0gZWxzZSBpZihvdXRDW2ldID49IGVuZFtpXSkge1xuICAgICAgICAgICAgb3V0Q1tpXSA9IChlbmRbaV0gLSAxKSAqIDIgLSBvdXRDW2ldICsgJHtsfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJHtyfSBjb29yZHMgPSBvdXRDIC0gc3RhcnQ7XG4gICAgICAgIHNldE91dHB1dChnZXRYKCR7b30pKTtcbiAgICAgIH1cbiAgICBgfX0sUHNlPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dHB1dFNoYXBlPXQubWFwKChoLG0pPT5oWzBdK2VbbV0raFsxXSk7bGV0IGE9ZS5sZW5ndGgscj1odChhKSxzPXQubWFwKGg9PmhbMF0pLmpvaW4oXCIsXCIpLGk9dC5tYXAoKGgsbSk9PmhbMF0rZVttXSkuam9pbihcIixcIiksbz1JbihcInJjXCIsYSksbD1JbihcInNvdXJjZVwiLGEpLHU9YCR7b1thLTFdfSA8ICR7dGhpcy5vdXRwdXRTaGFwZVthLTFdfWAscD1hPT09MT9cInNvdXJjZVwiOmB2ZWMyKCR7bC5zbGljZSgtMikuam9pbigpfSlgLGQ9bj09PVwicmVmbGVjdFwiPzA6MSxjPVwiXCI7aWYoYT09PTEpe2xldCBoPWBcbiAgICAgICAgJHtyfSBzb3VyY2UgPSByYztcbiAgICAgICAgaWYgKHNvdXJjZSA8IHN0YXJ0KSB7XG4gICAgICAgICAgc291cmNlID0gc3RhcnQgKiAyIC0gc291cmNlIC0gJHtkfTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UgPj0gZW5kKSB7XG4gICAgICAgICAgc291cmNlID0gKGVuZCAtIDEpICogMiAtIHNvdXJjZSArICR7ZH07XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlIC09IHN0YXJ0O1xuICAgICAgYDtjPWBcbiAgICAgICAgJHtyfSByYyA9IG91dHB1dExvYztcbiAgICAgICAgJHtofVxuICAgICAgICByZXN1bHRbMF0gPSBnZXRDaGFubmVsKGdldFgoJHtsLmpvaW4oKX0pLCAke3B9KTtcbiAgICAgICAgJHtvW2EtMV19ICs9IDE7XG4gICAgICAgIGlmKCR7dX0pIHtcbiAgICAgICAgICAke2h9XG4gICAgICAgICAgcmVzdWx0WzFdID0gZ2V0Q2hhbm5lbChnZXRYKCR7bC5qb2luKCl9KSwgJHtwfSk7XG4gICAgICAgIH1cbiAgICAgIGB9ZWxzZXtsZXQgaD1gXG4gICAgICAgICR7cn0gc291cmNlID0gcmM7XG4gICAgICAgICR7cn0gbHQgPSAke3J9KGxlc3NUaGFuKHNvdXJjZSwgc3RhcnQpKTtcbiAgICAgICAgJHtyfSBndGUgPSAke3J9KGdyZWF0ZXJUaGFuRXF1YWwoc291cmNlLCBlbmQpKTtcbiAgICAgICAgJHtyfSBvcmlnID0gMSAtIChsdCArIGd0ZSk7XG4gICAgICAgIHNvdXJjZSA9IG9yaWcgKiBzb3VyY2UgK1xuICAgICAgICAgICAgICAgIGx0ICogKHN0YXJ0ICogMiAtIHNvdXJjZSAtICR7ZH0pICtcbiAgICAgICAgICAgICAgICBndGUgKiAoKGVuZCAtIDEpICogMiAtIHNvdXJjZSArICR7ZH0pO1xuICAgICAgICBzb3VyY2UgLT0gc3RhcnQ7XG4gICAgICBgO2M9YFxuICAgICAgICAke3J9IHJjID0gb3V0cHV0TG9jO1xuICAgICAgICAke2h9XG4gICAgICAgIHJlc3VsdFswXSA9IGdldENoYW5uZWwoZ2V0WCgke2wuam9pbigpfSksICR7cH0pO1xuICAgICAgICAke29bYS0xXX0gKz0gMTtcbiAgICAgICAgaWYoJHt1fSkge1xuICAgICAgICAgICR7aH1cbiAgICAgICAgICByZXN1bHRbMV0gPSBnZXRDaGFubmVsKGdldFgoJHtsLmpvaW4oKX0pLCAke3B9KTtcbiAgICAgICAgfVxuICAgICAgICByYyA9IG91dHB1dExvYztcbiAgICAgICAgJHtvW2EtMl19ICs9IDE7XG4gICAgICAgIGlmKCR7b1thLTJdfSA8ICR7dGhpcy5vdXRwdXRTaGFwZVthLTJdfSkge1xuICAgICAgICAgICR7aH1cbiAgICAgICAgICByZXN1bHRbMl0gPSBnZXRDaGFubmVsKGdldFgoJHtsLmpvaW4oKX0pLCAke3B9KTtcbiAgICAgICAgICAke29bYS0xXX0gKz0gMTtcbiAgICAgICAgICBpZigke3V9KSB7XG4gICAgICAgICAgICAke2h9XG4gICAgICAgICAgICByZXN1bHRbM10gPSBnZXRDaGFubmVsKGdldFgoJHtsLmpvaW4oKX0pLCAke3B9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGB9dGhpcy51c2VyQ29kZT1gXG4gICAgICBjb25zdCAke3J9IHN0YXJ0ID0gJHtyfSgke3N9KTtcbiAgICAgIGNvbnN0ICR7cn0gZW5kID0gJHtyfSgke2l9KTtcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAke3J9IG91dHB1dExvYyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xuICAgICAgICAke2N9XG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xuICAgICAgfVxuICAgIGB9fSxMc2U9KHtpbnB1dHM6ZSxiYWNrZW5kOnQsYXR0cnM6bn0pPT57bGV0e3g6YX09ZSx7cGFkZGluZ3M6cixtb2RlOnN9PW4saT1HKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OU1wiKT9uZXcgUHNlKGEuc2hhcGUscixzKTpuZXcgT3NlKGEuc2hhcGUscixzKTtyZXR1cm4gdC5ydW5XZWJHTFByb2dyYW0oaSxbYV0sYS5kdHlwZSl9LHpzZT17a2VybmVsTmFtZTpmbyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpMc2V9LFdzZT1gaWYgKGIgPT0gMC4wKSByZXR1cm4gTkFOO1xuICByZXR1cm4gbW9kKGEsIGIpO2AsQnNlPWBcbiAgdmVjNCByZXN1bHQgPSBtb2QoYSwgYik7XG4gIGJ2ZWM0IGlzTmFOID0gZXF1YWwoYiwgdmVjNCgwLjApKTtcbiAgYCtRbytgXG4gIHJldHVybiByZXN1bHQ7XG5gLFZzZT1obih7b3BTbmlwcGV0OldzZSxwYWNrZWRPcFNuaXBwZXQ6QnNlfSksVXNlPXtrZXJuZWxOYW1lOmdvLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlZzZX0sR3NlPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wicHJvYnNcIl0sdGhpcy5jdXN0b21Vbmlmb3Jtcz1be25hbWU6XCJzZWVkXCIsdHlwZTpcImZsb2F0XCJ9XSx0aGlzLm91dHB1dFNoYXBlPVtlLG5dLHRoaXMudXNlckNvZGU9YFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xuXG4gICAgICAgIGZsb2F0IHIgPSByYW5kb20oc2VlZCk7XG4gICAgICAgIGZsb2F0IGNkZiA9IDAuMDtcblxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7dC0xfTsgaSsrKSB7XG4gICAgICAgICAgY2RmICs9IGdldFByb2JzKGJhdGNoLCBpKTtcblxuICAgICAgICAgIGlmIChyIDwgY2RmKSB7XG4gICAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoaSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5vIG90aGVyIGV2ZW50IGhhcHBlbmVkLCBsYXN0IGV2ZW50IGhhcHBlbmVkLlxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQoJHt0LTF9KSk7XG4gICAgICB9XG4gICAgYH19LEhzZT1gXG5pZiAoYSA9PSBiKSB7XG4gIHJldHVybiAxLjA7XG59O1xucmV0dXJuIGEgLyBiO2AsanNlPWBcbiAgLy8gdmVjNCBvbmUgPSB2ZWM0KGVxdWFsKGEsIGIpKTtcbiAgLy8gcmV0dXJuIG9uZSArICh2ZWM0KDEuMCkgLSBvbmUpICogYSAvIGI7XG4gIHZlYzQgcmVzdWx0ID0gYSAvIGI7XG4gIGlmKGEueCA9PSBiLngpIHtcbiAgICByZXN1bHQueCA9IDEuO1xuICB9XG4gIGlmKGEueSA9PSBiLnkpIHtcbiAgICByZXN1bHQueSA9IDEuO1xuICB9XG4gIGlmKGEueiA9PSBiLnopIHtcbiAgICByZXN1bHQueiA9IDEuO1xuICB9XG4gIGlmKGEudyA9PSBiLncpIHtcbiAgICByZXN1bHQudyA9IDEuO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbmAsdEY9aG4oe29wU25pcHBldDpIc2UscGFja2VkT3BTbmlwcGV0OmpzZSxjaGVja091dE9mQm91bmRzOiEwfSkscXNlPXtrZXJuZWxOYW1lOkhpLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOnRGfSxrUz1cInJldHVybiBhIC0gYjtcIixuRj1obih7b3BTbmlwcGV0OmtTLHBhY2tlZE9wU25pcHBldDprUyxzdXBwb3J0c0NvbXBsZXg6ITAsY3B1S2VybmVsSW1wbDpMUX0pLEtzZT17a2VybmVsTmFtZTpCbyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpuRn07ZnVuY3Rpb24gYUYoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtsb2dpdHM6cn09dCx7ZGltOnN9PWEsaT13LnBhcnNlQXhpc1BhcmFtKFtzXSxyLnNoYXBlKSxvPWVGKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntyZWR1Y3Rpb25JbmRpY2VzOmksa2VlcERpbXM6ITF9fSksbD1ULmV4cGFuZFNoYXBlVG9LZWVwRGltKG8uc2hhcGUsaSksdT1jZSh7aW5wdXRzOnt4Om99LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6bH19KSxwPW5GKHtpbnB1dHM6e2E6cixiOnV9LGJhY2tlbmQ6bn0pLGQ9WkEoe2lucHV0czp7eDpwfSxiYWNrZW5kOm59KSxjPVZmKHtpbnB1dHM6e3g6ZH0sYmFja2VuZDpuLGF0dHJzOntheGlzOmksa2VlcERpbXM6ITF9fSksaD1jZSh7aW5wdXRzOnt4OmN9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6bH19KSxtPXRGKHtpbnB1dHM6e2E6ZCxiOmh9LGJhY2tlbmQ6bn0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG8pLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odSksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhwKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGQpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oYyksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhoKSxtfXZhciBYc2U9e2tlcm5lbE5hbWU6em8sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6YUZ9O2Z1bmN0aW9uIFlzZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2xvZ2l0czpyfT10LHtudW1TYW1wbGVzOnMsc2VlZDppLG5vcm1hbGl6ZWQ6b309YSxsPW8/cjphRih7aW5wdXRzOntsb2dpdHM6cn0sYmFja2VuZDpuLGF0dHJzOntkaW06ci5zaGFwZS5sZW5ndGgtMX19KSx1PWwuc2hhcGVbMF0scD1sLnNoYXBlWzFdLGQ9bmV3IEdzZSh1LHAscyksYz1bW2ldXSxoPW4ucnVuV2ViR0xQcm9ncmFtKGQsW2xdLFwiaW50MzJcIixjKTtyZXR1cm4gb3x8bi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhsKSxofXZhciBac2U9e2tlcm5lbE5hbWU6VHUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6WXNlfSxKc2U9RGErYFxuICByZXR1cm4gLXg7XG5gLFFzZT1gXG4gIHZlYzQgcmVzdWx0ID0gLXg7XG4gIGJ2ZWM0IGlzTmFOID0gaXNuYW4oeCk7XG5cbiAgcmVzdWx0LnIgPSBpc05hTi5yID8geC5yIDogcmVzdWx0LnI7XG4gIHJlc3VsdC5nID0gaXNOYU4uZyA/IHguZyA6IHJlc3VsdC5nO1xuICByZXN1bHQuYiA9IGlzTmFOLmIgPyB4LmIgOiByZXN1bHQuYjtcbiAgcmVzdWx0LmEgPSBpc05hTi5hID8geC5hIDogcmVzdWx0LmE7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbmA7ZnVuY3Rpb24gZWllKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse3g6YX09dDtpZihuLnNob3VsZEV4ZWN1dGVPbkNQVShbYV0pKXtsZXQgcz1uLnRleERhdGEuZ2V0KGEuZGF0YUlkKSxbaSxvXT14UShzLnZhbHVlcyxhLnNoYXBlLGEuZHR5cGUpO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKG8sYS5kdHlwZSxpKX1sZXQgcjtyZXR1cm4gRygpLmdldEJvb2woXCJXRUJHTF9QQUNLX1VOQVJZX09QRVJBVElPTlNcIik/cj1uZXcgdHMoYS5zaGFwZSxRc2UpOnI9bmV3IHJyKGEuc2hhcGUsSnNlKSxuLnJ1bldlYkdMUHJvZ3JhbShyLFthXSxhLmR0eXBlKX12YXIgdGllPXtrZXJuZWxOYW1lOkN1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmVpZX0sbmllPW1yLm5vbk1heFN1cHByZXNzaW9uVjNJbXBsO2Z1bmN0aW9uIGFpZShlKXtULndhcm4oXCJ0Zi5ub25NYXhTdXBwcmVzc2lvbigpIGluIHdlYmdsIGxvY2tzIHRoZSBVSSB0aHJlYWQuIENhbGwgdGYubm9uTWF4U3VwcHJlc3Npb25Bc3luYygpIGluc3RlYWRcIik7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtib3hlczpyLHNjb3JlczpzfT10LHttYXhPdXRwdXRTaXplOmksaW91VGhyZXNob2xkOm8sc2NvcmVUaHJlc2hvbGQ6bH09YSx1PW4ucmVhZFN5bmMoci5kYXRhSWQpLHA9bi5yZWFkU3luYyhzLmRhdGFJZCkse3NlbGVjdGVkSW5kaWNlczpkfT1uaWUodSxwLGksbyxsKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhbZC5sZW5ndGhdLFwiaW50MzJcIixuZXcgSW50MzJBcnJheShkKSl9dmFyIHJpZT17a2VybmVsTmFtZTpfdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzphaWV9LHNpZT1tci5ub25NYXhTdXBwcmVzc2lvblY0SW1wbDtmdW5jdGlvbiBpaWUoZSl7VC53YXJuKFwidGYubm9uTWF4U3VwcHJlc3Npb24oKSBpbiB3ZWJnbCBsb2NrcyB0aGUgVUkgdGhyZWFkLiBDYWxsIHRmLm5vbk1heFN1cHByZXNzaW9uQXN5bmMoKSBpbnN0ZWFkXCIpO2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7Ym94ZXM6cixzY29yZXM6c309dCx7bWF4T3V0cHV0U2l6ZTppLGlvdVRocmVzaG9sZDpvLHNjb3JlVGhyZXNob2xkOmwscGFkVG9NYXhPdXRwdXRTaXplOnV9PWEscD1uLnJlYWRTeW5jKHIuZGF0YUlkKSxkPW4ucmVhZFN5bmMocy5kYXRhSWQpLHtzZWxlY3RlZEluZGljZXM6Yyx2YWxpZE91dHB1dHM6aH09c2llKHAsZCxpLG8sbCx1KTtyZXR1cm5bbi5tYWtlVGVuc29ySW5mbyhbYy5sZW5ndGhdLFwiaW50MzJcIixuZXcgSW50MzJBcnJheShjKSksbi5tYWtlVGVuc29ySW5mbyhbXSxcImludDMyXCIsbmV3IEludDMyQXJyYXkoW2hdKSldfXZhciBvaWU9e2tlcm5lbE5hbWU6QXUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6aWllfSxsaWU9bXIubm9uTWF4U3VwcHJlc3Npb25WNUltcGw7ZnVuY3Rpb24gdWllKGUpe1Qud2FybihcInRmLm5vbk1heFN1cHByZXNzaW9uKCkgaW4gd2ViZ2wgbG9ja3MgdGhlIFVJIHRocmVhZC4gQ2FsbCB0Zi5ub25NYXhTdXBwcmVzc2lvbkFzeW5jKCkgaW5zdGVhZFwiKTtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2JveGVzOnIsc2NvcmVzOnN9PXQse21heE91dHB1dFNpemU6aSxpb3VUaHJlc2hvbGQ6byxzY29yZVRocmVzaG9sZDpsLHNvZnRObXNTaWdtYTp1fT1hLHA9bi5yZWFkU3luYyhyLmRhdGFJZCksZD1uLnJlYWRTeW5jKHMuZGF0YUlkKSxjPWksaD1vLG09bCxmPXUse3NlbGVjdGVkSW5kaWNlczpnLHNlbGVjdGVkU2NvcmVzOmJ9PWxpZShwLGQsYyxoLG0sZik7cmV0dXJuW24ubWFrZVRlbnNvckluZm8oW2cubGVuZ3RoXSxcImludDMyXCIsbmV3IEludDMyQXJyYXkoZykpLG4ubWFrZVRlbnNvckluZm8oW2IubGVuZ3RoXSxcImZsb2F0MzJcIixuZXcgRmxvYXQzMkFycmF5KGIpKV19dmFyIHBpZT17a2VybmVsTmFtZTpGdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzp1aWV9LGNpZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixhKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiaW5kaWNlc1wiXSx0aGlzLm91dHB1dFNoYXBlPVtlLHRdLHRoaXMudXNlckNvZGU9YFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZ2V0SW5kaWNlcyhjb29yZHMueCkpO1xuICAgICAgICBzZXRPdXRwdXQobWl4KGZsb2F0KCR7YX0pLCBmbG9hdCgke259KSxcbiAgICAgICAgICAgICAgICAgICAgICBmbG9hdChpbmRleCA9PSBjb29yZHMueSkpKTtcbiAgICAgIH1cbiAgICBgfX0sZGllPWU9PntsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2luZGljZXM6cn09dCx7ZHR5cGU6cyxkZXB0aDppLG9uVmFsdWU6byxvZmZWYWx1ZTpsfT1hLHU9dy5zaXplRnJvbVNoYXBlKHIuc2hhcGUpLHA9bmV3IGNpZSh1LGksbyxsKSxkPWNlKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpbdV19fSksYz1uLnJ1bldlYkdMUHJvZ3JhbShwLFtkXSxzKTtuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGQpO2xldCBoPVsuLi5yLnNoYXBlLGldLG09Y2Uoe2lucHV0czp7eDpjfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOmh9fSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oYyksbX0saGllPXtrZXJuZWxOYW1lOnlvLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmRpZX07ZnVuY3Rpb24gZm0oZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7eDphfT10O2lmKGEuZHR5cGU9PT1cImNvbXBsZXg2NFwiKXtsZXQgcj1GZCh7aW5wdXRzOntpbnB1dDphfSxiYWNrZW5kOm59KSxzPWZtKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpufSksaT1VZih7aW5wdXRzOntpbnB1dDphfSxiYWNrZW5kOm59KSxvPWZtKHtpbnB1dHM6e3g6aX0sYmFja2VuZDpufSksbD0kcyh7aW5wdXRzOntyZWFsOnMsaW1hZzpvfSxiYWNrZW5kOm59KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhyKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHMpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaSksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhvKSxsfWVsc2UgcmV0dXJuICRkKHthdHRyczp7c2hhcGU6YS5zaGFwZSxkdHlwZTphLmR0eXBlLHZhbHVlOmEuZHR5cGU9PT1cInN0cmluZ1wiP1wiXCI6MH0sYmFja2VuZDpufSl9dmFyIG1pZT17a2VybmVsTmFtZTpZdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpmbX07ZnVuY3Rpb24gckYoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7eDphfT10O2lmKGEuZHR5cGU9PT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihcIm9uZXNMaWtlIGlzIG5vdCBzdXBwb3J0ZWQgdW5kZXIgc3RyaW5nIGR0eXBlXCIpO2lmKGEuZHR5cGU9PT1cImNvbXBsZXg2NFwiKXtsZXQgcj1GZCh7aW5wdXRzOntpbnB1dDphfSxiYWNrZW5kOm59KSxzPXJGKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpufSksaT1VZih7aW5wdXRzOntpbnB1dDphfSxiYWNrZW5kOm59KSxvPWZtKHtpbnB1dHM6e3g6aX0sYmFja2VuZDpufSksbD0kcyh7aW5wdXRzOntyZWFsOnMsaW1hZzpvfSxiYWNrZW5kOm59KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhyKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHMpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaSksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhvKSxsfWVsc2UgcmV0dXJuICRkKHthdHRyczp7c2hhcGU6YS5zaGFwZSxkdHlwZTphLmR0eXBlLHZhbHVlOjF9LGJhY2tlbmQ6bn0pfXZhciBmaWU9e2tlcm5lbE5hbWU6JHUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6ckZ9O2Z1bmN0aW9uIGdpZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2F4aXM6cn09YTtpZih0Lmxlbmd0aD09PTEpcmV0dXJuIGd2KHtpbnB1dHM6e2lucHV0OnRbMF19LGJhY2tlbmQ6bixhdHRyczp7ZGltOnJ9fSk7bGV0IHM9dFswXS5zaGFwZSxpPXRbMF0uZHR5cGU7dC5mb3JFYWNoKHA9Pnt3LmFzc2VydFNoYXBlc01hdGNoKHMscC5zaGFwZSxcIkFsbCB0ZW5zb3JzIHBhc3NlZCB0byBzdGFjayBtdXN0IGhhdmUgbWF0Y2hpbmcgc2hhcGVzXCIpLHcuYXNzZXJ0KGk9PT1wLmR0eXBlLCgpPT5cIkFsbCB0ZW5zb3JzIHBhc3NlZCB0byBzdGFjayBtdXN0IGhhdmUgbWF0Y2hpbmcgZHR5cGVzXCIpfSk7bGV0IG89W10sbD10Lm1hcChwPT57bGV0IGQ9Z3Yoe2lucHV0czp7aW5wdXQ6cH0sYmFja2VuZDpuLGF0dHJzOntkaW06cn19KTtyZXR1cm4gby5wdXNoKGQpLGR9KSx1PVVBKHtpbnB1dHM6bCxiYWNrZW5kOm4sYXR0cnM6e2F4aXM6cn19KTtyZXR1cm4gby5mb3JFYWNoKHA9Pm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocCkpLHV9dmFyIGJpZT17a2VybmVsTmFtZTpEdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpnaWV9LHlpZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5jdXN0b21Vbmlmb3Jtcz1be25hbWU6XCJ2YWx1ZVwiLHR5cGU6XCJmbG9hdFwifV0sdGhpcy5vdXRwdXRTaGFwZT10Lm1hcCgobCx1KT0+bFswXStlW3VdK2xbMV0pO2xldCBhPWUubGVuZ3RoLHI9aHQoYSkscz10Lm1hcChsPT5sWzBdKS5qb2luKFwiLFwiKSxpPXQubWFwKChsLHUpPT5sWzBdK2VbdV0pLmpvaW4oXCIsXCIpLG89W1wiY29vcmRzWzBdXCIsXCJjb29yZHNbMV1cIixcImNvb3Jkc1syXVwiLFwiY29vcmRzWzNdXCJdLnNsaWNlKDAsYSk7aWYoYT09PTEpe3RoaXMudXNlckNvZGU9YFxuICAgICAgICBpbnQgc3RhcnQgPSAke3N9O1xuICAgICAgICBpbnQgZW5kID0gJHtpfTtcblxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgaW50IG91dEMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgICBpZiAob3V0QyA8IHN0YXJ0IHx8IG91dEMgPj0gZW5kKSB7XG4gICAgICAgICAgICBzZXRPdXRwdXQodmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRPdXRwdXQoZ2V0WChvdXRDIC0gc3RhcnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGA7cmV0dXJufXRoaXMudXNlckNvZGU9YFxuICAgICAgJHtyfSBzdGFydCA9ICR7cn0oJHtzfSk7XG4gICAgICAke3J9IGVuZCA9ICR7cn0oJHtpfSk7XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgJHtyfSBvdXRDID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGlmIChhbnkobGVzc1RoYW4ob3V0Qywgc3RhcnQpKSB8fCBhbnkoZ3JlYXRlclRoYW5FcXVhbChvdXRDLCBlbmQpKSkge1xuICAgICAgICAgIHNldE91dHB1dCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHtyfSBjb29yZHMgPSBvdXRDIC0gc3RhcnQ7XG4gICAgICAgICAgc2V0T3V0cHV0KGdldFgoJHtvfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgYH19LHhpZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5jdXN0b21Vbmlmb3Jtcz1be25hbWU6XCJ2YWx1ZVwiLHR5cGU6XCJmbG9hdFwifV0sdGhpcy5vdXRwdXRTaGFwZT10Lm1hcCgobSxmKT0+bVswXStlW2ZdK21bMV0pO2xldCBhPWUubGVuZ3RoLHI9aHQoYSkscz10Lm1hcChtPT5tWzBdKS5qb2luKFwiLFwiKSxpPXQubWFwKChtLGYpPT5tWzBdK2VbZl0pLmpvaW4oXCIsXCIpLG89SW4oXCJyY1wiLGEpLGw9SW4oXCJzb3VyY2VcIixhKSx1PWAke29bYS0xXX0gPCAke3RoaXMub3V0cHV0U2hhcGVbYS0xXX1gLHA9YT09PTE/XCJzb3VyY2VcIjpgdmVjMigke2wuc2xpY2UoLTIpLmpvaW4oKX0pYCxkPVtgJHtyfSByYyA9IG91dHB1dExvYztgLGAke29bYS0xXX0gKz0gMTtcbiAgICAgICBpZigke3V9KSB7XG4gICAgICBgLGE9PT0xP1wiXCI6YH1cbiAgICAgICByYyA9IG91dHB1dExvYztcbiAgICAgICAke29bYS0yXX0gKz0gMTtcbiAgICAgICBpZigke29bYS0yXX0gPCAke3RoaXMub3V0cHV0U2hhcGVbYS0yXX0pIHtgLGE9PT0xP1wiXCI6YCAgJHtvW2EtMV19ICs9IDE7XG4gICAgICAgICBpZigke3V9KSB7YF0sYz1hPT09MT9cInJjIDwgc3RhcnQgfHwgcmMgPj0gZW5kXCI6XCJhbnkobGVzc1RoYW4ocmMsIHN0YXJ0KSkgfHwgYW55KGdyZWF0ZXJUaGFuRXF1YWwocmMsIGVuZCkpXCIsaD1cIlwiO2ZvcihsZXQgbT0wLGY9YT09PTE/Mjo0O208ZjttKyspaCs9YFxuICAgICAgICAke2RbbV19XG4gICAgICAgIGlmICgke2N9KSB7XG4gICAgICAgICAgcmVzdWx0WyR7bX1dID0gZmxvYXQodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICR7cn0gc291cmNlID0gcmMgLSBzdGFydDtcbiAgICAgICAgICByZXN1bHRbJHttfV0gPSBnZXRDaGFubmVsKGdldFgoJHtsLmpvaW4oKX0pLCAke3B9KTtcbiAgICAgICAgfVxuICAgICAgYDtoKz1hPT09MT9cIn0gXCI6XCJ9fVwiLHRoaXMudXNlckNvZGU9YFxuICAgICAgY29uc3QgJHtyfSBzdGFydCA9ICR7cn0oJHtzfSk7XG4gICAgICBjb25zdCAke3J9IGVuZCA9ICR7cn0oJHtpfSk7XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgJHtyfSBvdXRwdXRMb2MgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcbiAgICAgICAgJHtofVxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcbiAgICAgIH1cbiAgICBgfX0sc0Y9ZT0+e2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtwYWRkaW5nczpzLGNvbnN0YW50VmFsdWU6aX09YTtpZih3LnNpemVGcm9tU2hhcGUoci5zaGFwZSk9PT0wKXtsZXQgdT1zLm1hcCgocCxkKT0+cFswXStyLnNoYXBlW2RdK3BbMV0pO3JldHVybiAkZCh7YmFja2VuZDpuLGF0dHJzOntzaGFwZTp1LHZhbHVlOmksZHR5cGU6ci5kdHlwZX19KX1sZXQgbz1HKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OU1wiKT9uZXcgeGllKHIuc2hhcGUscyxpKTpuZXcgeWllKHIuc2hhcGUscyxpKSxsPVtbaV1dO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShvLFtyXSxyLmR0eXBlLGwpfSx2aWU9e2tlcm5lbE5hbWU6eG8sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6c0Z9LHdpZT1gXG4gIGlmKGEgPCAwLjAgJiYgZmxvb3IoYikgPCBiKXtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChiID09IDAuMCkge1xuICAgIHJldHVybiAxLjA7XG4gIH1cbiAgcmV0dXJuIChyb3VuZChtb2QoYiwgMi4wKSkgIT0gMSkgP1xuICAgICAgcG93KGFicyhhKSwgYikgOiBzaWduKGEpICogcG93KGFicyhhKSwgYik7XG5gLGtpZT1gXG4gIC8vIGlzTW9kUm91bmQxIGhhcyAxIGZvciBjb21wb25lbnRzIHdpdGggcm91bmQobW9kKGIsIDIuMCkpID09IDEsIDAgb3RoZXJ3aXNlLlxuICB2ZWM0IGlzTW9kUm91bmQxID0gdmVjNChlcXVhbChyb3VuZChtb2QoYiwgMi4wKSksIGl2ZWM0KDEpKSk7XG4gIHZlYzQgbXVsdGlwbGllciA9IHNpZ24oYSkgKiBpc01vZFJvdW5kMSArICh2ZWM0KDEuMCkgLSBpc01vZFJvdW5kMSk7XG4gIHZlYzQgcmVzdWx0ID0gbXVsdGlwbGllciAqIHBvdyhhYnMoYSksIGIpO1xuXG4gIC8vIEVuc3VyZSB0aGF0IGFeMCA9IDEsIGluY2x1ZGluZyAwXjAgPSAxIGFzIHRoaXMgY29ycmVzcG9uZCB0byBURiBhbmQgSlNcbiAgYnZlYzQgaXNFeHBaZXJvID0gZXF1YWwoYiwgdmVjNCgwLjApKTtcbiAgcmVzdWx0LnIgPSBpc0V4cFplcm8uciA/IDEuMCA6IHJlc3VsdC5yO1xuICByZXN1bHQuZyA9IGlzRXhwWmVyby5nID8gMS4wIDogcmVzdWx0Lmc7XG4gIHJlc3VsdC5iID0gaXNFeHBaZXJvLmIgPyAxLjAgOiByZXN1bHQuYjtcbiAgcmVzdWx0LmEgPSBpc0V4cFplcm8uYSA/IDEuMCA6IHJlc3VsdC5hO1xuXG4gIGJ2ZWM0IGlzTmFOMSA9IGxlc3NUaGFuKGEsIHZlYzQoMC4wKSk7XG4gIGJ2ZWM0IGlzTmFOMiA9IGxlc3NUaGFuKGZsb29yKGIpLCBiKTtcbiAgYnZlYzQgaXNOYU4gPSBidmVjNChpc05hTjEueCAmJiBpc05hTjIueCwgaXNOYU4xLnkgJiYgaXNOYU4yLnksIGlzTmFOMS56ICYmIGlzTmFOMi56LCBpc05hTjEudyAmJiBpc05hTjIudyk7XG4gIGArUW8rYFxuICByZXR1cm4gcmVzdWx0O1xuYCxJaWU9aG4oe29wU25pcHBldDp3aWUscGFja2VkT3BTbmlwcGV0OmtpZX0pLFNpZT17a2VybmVsTmFtZTp2byxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpJaWV9O2Z1bmN0aW9uIE5pZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7YXhpczpzLGtlZXBEaW1zOml9PWEsbz1yLnNoYXBlLmxlbmd0aCxsPVtdLHU9dy5wYXJzZUF4aXNQYXJhbShzLHIuc2hhcGUpLHA9dSxkPVQuZ2V0QXhlc1Blcm11dGF0aW9uKHAsbyksYz1yO2QhPW51bGwmJihjPVNuKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntwZXJtOmR9fSkscD1ULmdldElubmVyTW9zdEF4ZXMocC5sZW5ndGgsbyksbC5wdXNoKGMpKSxULmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwicHJvZFwiLHAsbyk7bGV0IGg7aWYobi5zaG91bGRFeGVjdXRlT25DUFUoW2NdKSl7bGV0IG09bi50ZXhEYXRhLmdldChjLmRhdGFJZCkudmFsdWVzLHtvdXRWYWxzOmYsb3V0U2hhcGU6ZyxvdXREdHlwZTpifT13UShjLnNoYXBlLGMuZHR5cGUsbSxwKTtoPW4ubWFrZVRlbnNvckluZm8oZyxiLGYpfWVsc2V7bGV0W20sZl09VC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGMuc2hhcGUscCksZz13LnNpemVGcm9tU2hhcGUoZiksYj1jZSh7aW5wdXRzOnt4OmN9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6Wy0xLGddfX0pLHk9TW0oci5kdHlwZSkseD1lbChiLHksXCJwcm9kXCIsbik7aD1jZSh7aW5wdXRzOnt4fSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOm19fSksbC5wdXNoKGIpLGwucHVzaCh4KX1pZihpKXtsLnB1c2goaCk7bGV0IG09VC5leHBhbmRTaGFwZVRvS2VlcERpbShoLnNoYXBlLHUpO2g9Y2Uoe2lucHV0czp7eDpofSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOm19fSl9cmV0dXJuIGwuZm9yRWFjaChtPT5uLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG0pKSxofXZhciBUaWU9e2tlcm5lbE5hbWU6a28sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6TmllfTtmdW5jdGlvbiBDaWUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtwYXJhbXNOZXN0ZWRTcGxpdHM6cixwYXJhbXNEZW5zZVZhbHVlczpzLGluZGljZXM6aX09dCx7b3V0cHV0UmFnZ2VkUmFuazpvfT1hLGw9ci5tYXAoYj0+bi5yZWFkU3luYyhiLmRhdGFJZCkpLHU9ci5tYXAoYj0+Yi5zaGFwZSkscD1uLnJlYWRTeW5jKHMuZGF0YUlkKSxkPW4ucmVhZFN5bmMoaS5kYXRhSWQpLFtjLGgsbV09a1EobCx1LHAscy5zaGFwZSxzLmR0eXBlLGQsaS5zaGFwZSxvKSxmPWMubWFwKGI9Pm4ubWFrZVRlbnNvckluZm8oW2IubGVuZ3RoXSxcImludDMyXCIsYikpLGc9bi5tYWtlVGVuc29ySW5mbyhtLHMuZHR5cGUsaCk7cmV0dXJuIGYuY29uY2F0KFtnXSl9dmFyIEVpZT17a2VybmVsTmFtZTpBbSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpDaWV9O2Z1bmN0aW9uIF9pZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHtzdGFydHM6YSxsaW1pdHM6cixkZWx0YXM6c309dCxpPW4ucmVhZFN5bmMoYS5kYXRhSWQpLG89bi5yZWFkU3luYyhyLmRhdGFJZCksbD1uLnJlYWRTeW5jKHMuZGF0YUlkKSxbdSxwXT1JUShpLGEuc2hhcGUsYS5kdHlwZSxvLHIuc2hhcGUsbCxzLnNoYXBlKSxkPW4ubWFrZVRlbnNvckluZm8oW3UubGVuZ3RoXSxcImludDMyXCIsdSksYz1uLm1ha2VUZW5zb3JJbmZvKFtwLmxlbmd0aF0sYS5kdHlwZSxwKTtyZXR1cm5bZCxjXX12YXIgQWllPXtrZXJuZWxOYW1lOkZtLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOl9pZX07ZnVuY3Rpb24gRmllKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7c2hhcGU6cix2YWx1ZXM6cyxkZWZhdWx0VmFsdWU6aSxyb3dQYXJ0aXRpb25UZW5zb3JzOm99PXQse3Jvd1BhcnRpdGlvblR5cGVzOmx9PWEsdT1uLnJlYWRTeW5jKHIuZGF0YUlkKSxwPW4ucmVhZFN5bmMocy5kYXRhSWQpLGQ9bi5yZWFkU3luYyhpLmRhdGFJZCksYz1vLm1hcChnPT5uLnJlYWRTeW5jKGcuZGF0YUlkKSksaD1vLm1hcChnPT5nLnNoYXBlKSxbbSxmXT1TUSh1LHIuc2hhcGUscCxzLnNoYXBlLHMuZHR5cGUsZCxpLnNoYXBlLGMsaCxsKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhtLHMuZHR5cGUsZil9dmFyICRpZT17a2VybmVsTmFtZTokbSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpGaWV9LGlGPWU9PntsZXR7YmFja2VuZDp0LGF0dHJzOm59PWUse3N0YXJ0OmEsc3RvcDpyLHN0ZXA6cyxkdHlwZTppfT1uLG89TlEoYSxyLHMsaSk7cmV0dXJuIHQubWFrZVRlbnNvckluZm8oW28ubGVuZ3RoXSxpLG8pfSxEaWU9e2tlcm5lbE5hbWU6VWMsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6aUZ9LFJpZT1cInJldHVybiAxLjAgLyB4O1wiLE1pZT1aZSh7b3BTbmlwcGV0OlJpZX0pLE9pZT17a2VybmVsTmFtZTpJbyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpNaWV9LFBpZT1EYStgXG4gIHJldHVybiAoeCA8IDAuMCkgPyAwLjAgOiB4O1xuYCxMaWU9YFxuICB2ZWM0IHJlc3VsdCA9IHggKiB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoeCwgdmVjNCgwLjApKSk7XG4gIGJ2ZWM0IGlzTmFOID0gaXNuYW4oeCk7XG5cbiAgcmVzdWx0LnIgPSBpc05hTi5yID8geC5yIDogcmVzdWx0LnI7XG4gIHJlc3VsdC5nID0gaXNOYU4uZyA/IHguZyA6IHJlc3VsdC5nO1xuICByZXN1bHQuYiA9IGlzTmFOLmIgPyB4LmIgOiByZXN1bHQuYjtcbiAgcmVzdWx0LmEgPSBpc05hTi5hID8geC5hIDogcmVzdWx0LmE7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbmAsemllPVplKHtvcFNuaXBwZXQ6UGllLHBhY2tlZE9wU25pcHBldDpMaWV9KSxXaWU9e2tlcm5lbE5hbWU6U28sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6emllfSxCaWU9RGErYFxuICByZXR1cm4gKHggPCAwLjApID8gMC4wIDogbWluKDYuMCwgeCk7XG5gLFZpZT1gXG4gIHZlYzQgcmVzdWx0ID0gbWluKHgsIHZlYzQoNi4pKSAqIHZlYzQoZ3JlYXRlclRoYW5FcXVhbCh4LCB2ZWM0KDAuMCkpKTtcbiAgYnZlYzQgaXNOYU4gPSBpc25hbih4KTtcblxuICByZXN1bHQuciA9IGlzTmFOLnIgPyB4LnIgOiByZXN1bHQucjtcbiAgcmVzdWx0LmcgPSBpc05hTi5nID8geC5nIDogcmVzdWx0Lmc7XG4gIHJlc3VsdC5iID0gaXNOYU4uYiA/IHguYiA6IHJlc3VsdC5iO1xuICByZXN1bHQuYSA9IGlzTmFOLmEgPyB4LmEgOiByZXN1bHQuYTtcblxuICByZXR1cm4gcmVzdWx0O1xuYCxVaWU9WmUoe29wU25pcHBldDpCaWUscGFja2VkT3BTbmlwcGV0OlZpZX0pLEdpZT17a2VybmVsTmFtZTpDbyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpVaWV9LEhpZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixhLHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMub3V0cHV0U2hhcGU9W107bGV0W3MsaSxvLGxdPWU7dGhpcy5vdXRwdXRTaGFwZT1bcyx0LG4sbF07bGV0IHU9W2EmJnQ+MT9pLTE6aSxhJiZuPjE/by0xOm9dLHA9W2EmJnQ+MT90LTE6dCxhJiZuPjE/bi0xOm5dLGQ7cj9kPVwiKHZlYzIoeVJDKSArIHZlYzIoMC41KSkgKiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDIC0gdmVjMigwLjUpXCI6ZD1cInZlYzIoeVJDKSAqIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkNcIix0aGlzLnVzZXJDb2RlPWBcbiAgICAgIGNvbnN0IHZlYzIgZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQyA9IHZlYzIoXG4gICAgICAgICAgJHt1WzBdL3BbMF19LFxuICAgICAgICAgICR7dVsxXS9wWzFdfSk7XG4gICAgICBjb25zdCB2ZWMyIGlucHV0U2hhcGVSQyA9IHZlYzIoJHtpfS4wLCAke299LjApO1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XG4gICAgICAgIGl2ZWMyIHlSQyA9IGNvb3Jkcy55ejtcblxuICAgICAgICAvLyBGcmFjdGlvbmFsIHNvdXJjZSBpbmRleC5cbiAgICAgICAgdmVjMiBzb3VyY2VGcmFjSW5kZXhSQyA9ICR7ZH07XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZm91ciBpbnRlZ2VyIGluZGljZXMuXG4gICAgICAgIGl2ZWMyIHNvdXJjZUZsb29yUkMgPSBpdmVjMihtYXgoc291cmNlRnJhY0luZGV4UkMsIHZlYzIoMC4wKSkpO1xuICAgICAgICBpdmVjMiBzb3VyY2VDZWlsUkMgPSBpdmVjMihcbiAgICAgICAgICBtaW4oaW5wdXRTaGFwZVJDIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWNJbmRleFJDKSkpO1xuXG4gICAgICAgIGZsb2F0IHRvcExlZnQgPSBnZXRBKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlRmxvb3JSQy55LCBkKTtcbiAgICAgICAgZmxvYXQgYm90dG9tTGVmdCA9IGdldEEoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUZsb29yUkMueSwgZCk7XG4gICAgICAgIGZsb2F0IHRvcFJpZ2h0ID0gZ2V0QShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUNlaWxSQy55LCBkKTtcbiAgICAgICAgZmxvYXQgYm90dG9tUmlnaHQgPSBnZXRBKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueSwgZCk7XG5cbiAgICAgICAgdmVjMiBmcmFjUkMgPSBzb3VyY2VGcmFjSW5kZXhSQyAtIHZlYzIoc291cmNlRmxvb3JSQyk7XG5cbiAgICAgICAgZmxvYXQgdG9wID0gdG9wTGVmdCArICh0b3BSaWdodCAtIHRvcExlZnQpICogZnJhY1JDLnk7XG4gICAgICAgIGZsb2F0IGJvdHRvbSA9IGJvdHRvbUxlZnQgKyAoYm90dG9tUmlnaHQgLSBib3R0b21MZWZ0KSAqIGZyYWNSQy55O1xuICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IHRvcCArIChib3R0b20gLSB0b3ApICogZnJhY1JDLng7XG5cbiAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICBgfX0samllPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuLGEscil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT1bXTtsZXRbcyxpLG8sbF09ZTt0aGlzLm91dHB1dFNoYXBlPVtzLHQsbixsXTtsZXQgdT1bYSYmdD4xP2ktMTppLGEmJm4+MT9vLTE6b10scD1bYSYmdD4xP3QtMTp0LGEmJm4+MT9uLTE6bl0sZDtyP2Q9XCIodmVjMyh5UkMpICsgdmVjMygwLjUpKSAqIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkMgLSB2ZWMzKDAuNSlcIjpkPVwidmVjMyh5UkMpICogZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQ1wiLHRoaXMudXNlckNvZGU9YFxuICAgICAgY29uc3QgdmVjMyBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDID0gdmVjMyhcbiAgICAgICAgICAke3VbMF0vcFswXX0sXG4gICAgICAgICAgJHt1WzFdL3BbMV19LFxuICAgICAgICAgICR7dVsxXS9wWzFdfSk7XG4gICAgICBjb25zdCB2ZWMzIGlucHV0U2hhcGVSQyA9IHZlYzMoJHtpfS4wLCAke299LjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtvfS4wKTtcblxuICAgICAgZmxvYXQgZ2V0QVZhbHVlKGludCBiLCBpbnQgciwgaW50IGMsIGludCBkKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKGdldEEoYiwgciwgYywgZCksIHZlYzIoYywgZCkpO1xuICAgICAgfVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XG4gICAgICAgIC8vIENhbGN1bGF0ZSB2YWx1ZXMgZm9yIG5leHQgY29sdW1uIGluIHlSQy56LlxuICAgICAgICBpdmVjMyB5UkMgPSBjb29yZHMueXp6ICsgaXZlYzMoMCwgMCwgMSk7XG5cbiAgICAgICAgLy8gRnJhY3Rpb25hbCBzb3VyY2UgaW5kZXguXG4gICAgICAgIHZlYzMgc291cmNlRnJhY0luZGV4UkMgPSAke2R9O1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGZvdXIgaW50ZWdlciBpbmRpY2VzLlxuICAgICAgICBpdmVjMyBzb3VyY2VGbG9vclJDID0gaXZlYzMobWF4KHNvdXJjZUZyYWNJbmRleFJDLCB2ZWMzKDAuMCkpKTtcbiAgICAgICAgaXZlYzMgc291cmNlQ2VpbFJDID0gaXZlYzMoXG4gICAgICAgICAgbWluKGlucHV0U2hhcGVSQyAtIDEuMCwgY2VpbChzb3VyY2VGcmFjSW5kZXhSQykpKTtcblxuICAgICAgICAvLyBTaG91bGQgd2UgY2FsY3VsYXRlIG5leHQgY29sdW1uIGFuZCByb3cgZWxlbWVudHMgaW4gMngyIHBhY2tlZCBjZWxsLlxuICAgICAgICBib29sIGhhc05leHRDb2wgPSBkIDwgJHtsLTF9O1xuICAgICAgICBib29sIGhhc05leHRSb3cgPSBjb29yZHMueiA8ICR7bi0xfTtcblxuICAgICAgICAvLyBJbiBwYXJhbGxlbCwgY29uc3RydWN0IGZvdXIgY29ybmVycyBmb3IgYWxsIGZvdXIgY29tcG9uZW50cyBpblxuICAgICAgICAvLyBwYWNrZWQgMngyIGNlbGwuXG4gICAgICAgIHZlYzQgdG9wTGVmdCA9IHZlYzQoXG4gICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlRmxvb3JSQy55LCBkKSxcbiAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlRmxvb3JSQy55LCBkICsgMSlcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxuICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VGbG9vclJDLnosIGQpXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcbiAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/XG4gICAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VGbG9vclJDLnosIGQgKyAxKSA6IDAuMCk7XG5cbiAgICAgICAgdmVjNCBib3R0b21MZWZ0ID0gdmVjNChcbiAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUZsb29yUkMueSwgZCksXG4gICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlRmxvb3JSQy55LCBkICsgMSlcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxuICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUZsb29yUkMueiwgZClcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxuICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID9cbiAgICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlRmxvb3JSQy56LCBkICsgMSkgOiAwLjApO1xuXG4gICAgICAgIHZlYzQgdG9wUmlnaHQgPSB2ZWM0KFxuICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUNlaWxSQy55LCBkKSxcbiAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlQ2VpbFJDLnksIGQgKyAxKVxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXG4gICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUNlaWxSQy56LCBkKVxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXG4gICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgP1xuICAgICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlQ2VpbFJDLnosIGQgKyAxKSA6IDAuMCk7XG5cbiAgICAgICAgdmVjNCBib3R0b21SaWdodCA9IHZlYzQoXG4gICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueSwgZCksXG4gICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlQ2VpbFJDLnksIGQgKyAxKVxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXG4gICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlQ2VpbFJDLnosIGQpXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcbiAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/XG4gICAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUNlaWxSQy56LCBkICsgMSkgOiAwLjApO1xuXG4gICAgICAgIHZlYzMgZnJhY1JDID0gc291cmNlRnJhY0luZGV4UkMgLSB2ZWMzKHNvdXJjZUZsb29yUkMpO1xuXG4gICAgICAgIHZlYzQgdG9wID0gbWl4KHRvcExlZnQsIHRvcFJpZ2h0LCBmcmFjUkMueXl6eik7XG4gICAgICAgIHZlYzQgYm90dG9tID0gbWl4KGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0LCBmcmFjUkMueXl6eik7XG4gICAgICAgIHZlYzQgbmV3VmFsdWUgPSBtaXgodG9wLCBib3R0b20sIGZyYWNSQy54KTtcblxuICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xuICAgICAgfVxuICAgIGB9fTtmdW5jdGlvbiBxaWUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtpbWFnZXM6cn09dCx7YWxpZ25Db3JuZXJzOnMsaGFsZlBpeGVsQ2VudGVyczppLHNpemU6b309YSxbbCx1XT1vLHA9RygpLmdldEJvb2woXCJXRUJHTF9QQUNLX0lNQUdFX09QRVJBVElPTlNcIik/bmV3IGppZShyLnNoYXBlLGwsdSxzLGkpOm5ldyBIaWUoci5zaGFwZSxsLHUscyxpKTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0ocCxbcl0sXCJmbG9hdDMyXCIpfXZhciBLaWU9e2tlcm5lbE5hbWU6VG8sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6cWllfSxYaWU9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9dDtsZXRbLGEscl09dCxbLHMsaV09ZSxvPVtuJiZzPjE/YS0xOmEsbiYmaT4xP3ItMTpyXSxsPVtuJiZzPjE/cy0xOnMsbiYmaT4xP2ktMTppXSx1PW9bMF0vbFswXSxwPW9bMV0vbFsxXSxkPTEvdSxjPTEvcCxoPU1hdGguY2VpbChkKSoyKzIsbT1NYXRoLmNlaWwoYykqMisyO3RoaXMudXNlckNvZGU9YFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xuICAgICAgICBpbnQgciA9IGNvb3Jkc1sxXTtcbiAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XG5cbiAgICAgICAgZmxvYXQgYWNjdW11bGF0b3IgPSAwLjA7XG5cbiAgICAgICAgY29uc3QgZmxvYXQgaGVpZ2h0U2NhbGUgPSBmbG9hdCgke3V9KTtcbiAgICAgICAgY29uc3QgZmxvYXQgd2lkdGhTY2FsZSA9IGZsb2F0KCR7cH0pO1xuXG4gICAgICAgIGNvbnN0IGZsb2F0IGludkhlaWdodFNjYWxlID0gZmxvYXQoJHtkfSk7XG4gICAgICAgIGNvbnN0IGZsb2F0IGludldpZHRoU2NhbGUgPSBmbG9hdCgke2N9KTtcblxuICAgICAgICBjb25zdCBpbnQgd2luSGVpZ2h0ID0gaW50KCR7aH0pO1xuICAgICAgICBjb25zdCBpbnQgd2luV2lkdGggPSBpbnQoJHttfSk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBib3VuZHMgZm9yIHdoZXJlIGluIGR5IHdlIHdpbGwgbG9va1xuICAgICAgICBmbG9hdCBzdGFydFJMZXJwID0gZmxvb3IoZmxvYXQocikgKiBpbnZIZWlnaHRTY2FsZSk7XG4gICAgICAgIGludCBzdGFydER5UiA9IGludChzdGFydFJMZXJwIC0gZmxvYXQod2luSGVpZ2h0IC8gMikpO1xuXG4gICAgICAgIGZsb2F0IHN0YXJ0Q0xlcnAgPSBmbG9vcihmbG9hdChjKSAqIGludldpZHRoU2NhbGUpO1xuICAgICAgICBpbnQgc3RhcnREeUMgPSBpbnQoc3RhcnRDTGVycCAtIGZsb2F0KHdpbldpZHRoIC8gMikpO1xuXG4gICAgICAgIC8vIExvb3Agb3ZlciBkeVxuICAgICAgICBmb3IgKGludCBkeVJPZmZzZXQgPSAwOyBkeVJPZmZzZXQgPCB3aW5IZWlnaHQ7IGR5Uk9mZnNldCsrKSB7XG4gICAgICAgICAgaW50IGR5UiA9IGR5Uk9mZnNldCArIHN0YXJ0RHlSO1xuXG4gICAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgd2luZG93IGV4Y2VlZGluZyB0aGUgYm91bmRzIG9mIGR5XG4gICAgICAgICAgaWYgKGR5UiA8IDAgfHwgZHlSID49ICR7c30pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoaW50IGR5Q09mZnNldCA9IDA7IGR5Q09mZnNldCA8IHdpbldpZHRoOyBkeUNPZmZzZXQrKykge1xuICAgICAgICAgICAgaW50IGR5QyA9IGR5Q09mZnNldCArIHN0YXJ0RHlDO1xuXG4gICAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHRoZSB3aW5kb3cgZXhjZWVkaW5nIHRoZSBib3VuZHMgb2YgZHlcbiAgICAgICAgICAgIGlmIChkeUMgPCAwIHx8IGR5QyA+PSAke2l9KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmbG9hdCBkeFIgPSBmbG9hdChkeVIpICogaGVpZ2h0U2NhbGU7XG4gICAgICAgICAgICBpbnQgdG9wRHhSSW5kZXggPSBpbnQoZmxvb3IoZHhSKSk7XG4gICAgICAgICAgICBpbnQgYm90dG9tRHhSSW5kZXggPSBpbnQobWluKGNlaWwoZHhSKSwgJHthLTF9LjApKTtcbiAgICAgICAgICAgIGZsb2F0IGR4UkxlcnAgPSBkeFIgLSBmbG9hdCh0b3BEeFJJbmRleCk7XG4gICAgICAgICAgICBmbG9hdCBpbnZlcnNlRHhSTGVycCA9IDEuMCAtIGR4UkxlcnA7XG5cbiAgICAgICAgICAgIGZsb2F0IGR4QyA9IGZsb2F0KGR5QykgKiB3aWR0aFNjYWxlO1xuICAgICAgICAgICAgaW50IGxlZnREeENJbmRleCA9IGludChmbG9vcihkeEMpKTtcbiAgICAgICAgICAgIGludCByaWdodER4Q0luZGV4ID0gaW50KG1pbihjZWlsKGR4QyksICR7ci0xfS4wKSk7XG4gICAgICAgICAgICBmbG9hdCBkeENMZXJwID0gZHhDIC0gZmxvYXQobGVmdER4Q0luZGV4KTtcbiAgICAgICAgICAgIGZsb2F0IGludmVyc2VEeENMZXJwID0gMS4wIC0gZHhDTGVycDtcblxuICAgICAgICAgICAgaWYgKHIgPT0gdG9wRHhSSW5kZXggJiYgYyA9PSBsZWZ0RHhDSW5kZXgpIHtcbiAgICAgICAgICAgICAgLy8gdG9wTGVmdFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPVxuICAgICAgICAgICAgICAgIGdldER5KGIsIGR5UiwgZHlDLCBkKSAqIGludmVyc2VEeFJMZXJwICogaW52ZXJzZUR4Q0xlcnA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyID09IHRvcER4UkluZGV4ICYmIGMgPT0gcmlnaHREeENJbmRleCkge1xuICAgICAgICAgICAgICAvLyB0b3BSaWdodFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPSBnZXREeShiLCBkeVIsIGR5QywgZCkgKiBpbnZlcnNlRHhSTGVycCAqIGR4Q0xlcnA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyID09IGJvdHRvbUR4UkluZGV4ICYmIGMgPT0gbGVmdER4Q0luZGV4KSB7XG4gICAgICAgICAgICAgIC8vIGJvdHRvbUxlZnRcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgKz0gZ2V0RHkoYiwgZHlSLCBkeUMsIGQpICogZHhSTGVycCAqIGludmVyc2VEeENMZXJwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAociA9PSBib3R0b21EeFJJbmRleCAmJiBjID09IHJpZ2h0RHhDSW5kZXgpIHtcbiAgICAgICAgICAgICAgLy8gYm90dG9tUmlnaHRcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgKz0gZ2V0RHkoYiwgZHlSLCBkeUMsIGQpICogZHhSTGVycCAqIGR4Q0xlcnA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEVuZCBsb29wIG92ZXIgZHlcblxuICAgICAgICBzZXRPdXRwdXQoYWNjdW11bGF0b3IpO1xuICAgICAgfVxuICAgIGB9fTtmdW5jdGlvbiBZaWUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtpbWFnZXM6cixkeTpzfT10LHthbGlnbkNvcm5lcnM6aX09YSxvPW5ldyBYaWUocy5zaGFwZSxyLnNoYXBlLGkpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShvLFtzXSxzLmR0eXBlKX12YXIgWmllPXtrZXJuZWxOYW1lOk91LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOllpZX0sSmllPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuLGEscil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXTtsZXRbcyxpLG8sbF09ZTt0aGlzLm91dHB1dFNoYXBlPVtzLHQsbixsXTtsZXQgdT1bYSYmdD4xP2ktMTppLGEmJm4+MT9vLTE6b10scD1bYSYmdD4xP3QtMTp0LGEmJm4+MT9uLTE6bl0sZD1hP1wiMC41XCI6XCIwLjBcIixjO3I/Yz1cIm1heCgodmVjMih5UkMpICsgdmVjMigwLjUpKSAqIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkMsIHZlYzIoMC4wKSlcIjpjPVwidmVjMih5UkMpICogZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQ1wiLHRoaXMudXNlckNvZGU9YFxuICAgICAgY29uc3QgdmVjMiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDID0gdmVjMihcbiAgICAgICAgICAke3VbMF0vcFswXX0sXG4gICAgICAgICAgJHt1WzFdL3BbMV19KTtcbiAgICAgIGNvbnN0IHZlYzIgaW5wdXRTaGFwZVJDID0gdmVjMigke2l9LjAsICR7b30uMCk7XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcbiAgICAgICAgaXZlYzIgeVJDID0gY29vcmRzLnl6O1xuXG4gICAgICAgIC8vIEZyYWN0aW9uYWwgc291cmNlIGluZGV4LlxuICAgICAgICB2ZWMyIHNvdXJjZUZyYWNJbmRleFJDID0gJHtjfTtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBjb29yZGluYXRvcnMgb2YgbmVhcmVzdCBuZWlnaGJvciBwb2ludC5cbiAgICAgICAgaXZlYzIgc291cmNlTmVhcmVzdFJDID0gaXZlYzIoXG4gICAgICAgICAgbWluKGlucHV0U2hhcGVSQyAtIDEuMCwgZmxvb3Ioc291cmNlRnJhY0luZGV4UkMgKyAke2R9KSkpO1xuICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IGdldEEoYiwgc291cmNlTmVhcmVzdFJDLngsIHNvdXJjZU5lYXJlc3RSQy55LCBkKTtcblxuICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xuICAgICAgfVxuICAgIGB9fSxRaWU9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4sYSxyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dHB1dFNoYXBlPVtdO2xldFtzLGksbyxsXT1lO3RoaXMub3V0cHV0U2hhcGU9W3MsdCxuLGxdO2xldCB1PVthJiZ0PjE/aS0xOmksYSYmbj4xP28tMTpvXSxwPVthJiZ0PjE/dC0xOnQsYSYmbj4xP24tMTpuXSxkPWE/XCIwLjVcIjpcIjAuMFwiLGM7cj9jPVwibWF4KCh2ZWMzKHlSQykgKyB2ZWMzKDAuNSkpICogZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQywgdmVjMygwLjApKVwiOmM9XCJ2ZWMzKHlSQykgKiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDXCIsdGhpcy51c2VyQ29kZT1gXG4gICAgICBjb25zdCB2ZWMzIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkMgPSB2ZWMzKFxuICAgICAgICAgICR7dVswXS9wWzBdfSxcbiAgICAgICAgICAke3VbMV0vcFsxXX0sXG4gICAgICAgICAgJHt1WzFdL3BbMV19KTtcbiAgICAgIGNvbnN0IHZlYzMgaW5wdXRTaGFwZVJDID0gdmVjMygke2l9LjAsICR7b30uMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAke299LjApO1xuXG4gICAgICBmbG9hdCBnZXRBVmFsdWUoaW50IGIsIGludCByLCBpbnQgYywgaW50IGQpIHtcbiAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoZ2V0QShiLCByLCBjLCBkKSwgdmVjMihjLCBkKSk7XG4gICAgICB9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHZhbHVlcyBmb3IgbmV4dCBjb2x1bW4gaW4geVJDLnouXG4gICAgICAgIGl2ZWMzIHlSQyA9IGNvb3Jkcy55enogKyBpdmVjMygwLCAwLCAxKTtcblxuICAgICAgICAvLyBGcmFjdGlvbmFsIHNvdXJjZSBpbmRleC5cbiAgICAgICAgdmVjMyBzb3VyY2VGcmFjSW5kZXhSQyA9ICR7Y307XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29vcmRpbmF0b3JzIG9mIG5lYXJlc3QgbmVpZ2hib3IgcG9pbnQuXG4gICAgICAgIGl2ZWMzIHNvdXJjZU5lYXJlc3RSQyA9IGl2ZWMzKFxuICAgICAgICAgIG1pbihpbnB1dFNoYXBlUkMgLSAxLjAsIGZsb29yKHNvdXJjZUZyYWNJbmRleFJDICsgJHtkfSkpKTtcblxuICAgICAgICAvLyBTaG91bGQgd2UgY2FsY3VsYXRlIG5leHQgY29sdW1uIGFuZCByb3cgZWxlbWVudHMgaW4gMngyIHBhY2tlZCBjZWxsLlxuICAgICAgICBib29sIGhhc05leHRDb2wgPSBkIDwgJHtsLTF9O1xuICAgICAgICBib29sIGhhc05leHRSb3cgPSBjb29yZHMueiA8ICR7bi0xfTtcblxuICAgICAgICB2ZWM0IG5ld1ZhbHVlID0gdmVjNChcbiAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlTmVhcmVzdFJDLngsIHNvdXJjZU5lYXJlc3RSQy55LCBkKSxcbiAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGIsIHNvdXJjZU5lYXJlc3RSQy54LCBzb3VyY2VOZWFyZXN0UkMueSwgZCArIDEpXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcbiAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGIsIHNvdXJjZU5lYXJlc3RSQy54LCBzb3VyY2VOZWFyZXN0UkMueiwgZClcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxuICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID9cbiAgICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VOZWFyZXN0UkMueCwgc291cmNlTmVhcmVzdFJDLnosIGQgKyAxKSA6IDAuMCk7XG5cbiAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24gZW9lKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7aW1hZ2VzOnJ9PXQse2FsaWduQ29ybmVyczpzLGhhbGZQaXhlbENlbnRlcnM6aSxzaXplOm99PWEsW2wsdV09byxwPUcoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19JTUFHRV9PUEVSQVRJT05TXCIpP25ldyBRaWUoci5zaGFwZSxsLHUscyxpKTpuZXcgSmllKHIuc2hhcGUsbCx1LHMsaSk7cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKHAsW3JdLHIuZHR5cGUpfXZhciB0b2U9e2tlcm5lbE5hbWU6Tm8sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6ZW9lfSxub2U9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9dDtsZXRbLGEscl09dCxbLHMsaV09ZSxvPVtuJiZzPjE/YS0xOmEsbiYmaT4xP3ItMTpyXSxsPVtuJiZzPjE/cy0xOnMsbiYmaT4xP2ktMTppXSx1PW9bMF0vbFswXSxwPW9bMV0vbFsxXSxkPTEvdSxjPTEvcCxoPU1hdGguY2VpbChkKSoyKzIsbT1NYXRoLmNlaWwoYykqMisyO3RoaXMudXNlckNvZGU9YFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xuICAgICAgICBpbnQgciA9IGNvb3Jkc1sxXTtcbiAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XG5cbiAgICAgICAgZmxvYXQgYWNjdW11bGF0b3IgPSAwLjA7XG5cbiAgICAgICAgY29uc3QgZmxvYXQgaGVpZ2h0U2NhbGUgPSBmbG9hdCgke3V9KTtcbiAgICAgICAgY29uc3QgZmxvYXQgd2lkdGhTY2FsZSA9IGZsb2F0KCR7cH0pO1xuXG4gICAgICAgIGNvbnN0IGZsb2F0IGludkhlaWdodFNjYWxlID0gZmxvYXQoJHtkfSk7XG4gICAgICAgIGNvbnN0IGZsb2F0IGludldpZHRoU2NhbGUgPSBmbG9hdCgke2N9KTtcblxuICAgICAgICBjb25zdCBpbnQgd2luSGVpZ2h0ID0gaW50KCR7aH0pO1xuICAgICAgICBjb25zdCBpbnQgd2luV2lkdGggPSBpbnQoJHttfSk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBib3VuZHMgZm9yIHdoZXJlIGluIGR5IHdlIHdpbGwgbG9va1xuICAgICAgICBmbG9hdCBzdGFydFJMZXJwID0gZmxvb3IoZmxvYXQocikgKiBpbnZIZWlnaHRTY2FsZSk7XG4gICAgICAgIGludCBzdGFydER5UiA9IGludChmbG9vcihzdGFydFJMZXJwIC0gZmxvYXQod2luSGVpZ2h0IC8gMikpKTtcblxuICAgICAgICBmbG9hdCBzdGFydENMZXJwID0gZmxvb3IoZmxvYXQoYykgKiBpbnZXaWR0aFNjYWxlKTtcbiAgICAgICAgaW50IHN0YXJ0RHlDID0gaW50KGZsb29yKHN0YXJ0Q0xlcnAgLSBmbG9hdCh3aW5XaWR0aCAvIDIpKSk7XG5cbiAgICAgICAgLy8gTG9vcCBvdmVyIGR5XG4gICAgICAgIGZvciAoaW50IGR5Uk9mZnNldCA9IDA7IGR5Uk9mZnNldCA8IHdpbkhlaWdodDsgZHlST2Zmc2V0KyspIHtcbiAgICAgICAgICBpbnQgZHlSID0gZHlST2Zmc2V0ICsgc3RhcnREeVI7XG5cbiAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHRoZSB3aW5kb3cgZXhjZWVkaW5nIHRoZSBib3VuZHMgb2YgZHlcbiAgICAgICAgICBpZiAoZHlSIDwgMCB8fCBkeVIgPj0gJHtzfSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChpbnQgZHlDT2Zmc2V0ID0gMDsgZHlDT2Zmc2V0IDwgd2luV2lkdGg7IGR5Q09mZnNldCsrKSB7XG4gICAgICAgICAgICBpbnQgZHlDID0gZHlDT2Zmc2V0ICsgc3RhcnREeUM7XG5cbiAgICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIHdpbmRvdyBleGNlZWRpbmcgdGhlIGJvdW5kcyBvZiBkeVxuICAgICAgICAgICAgaWYgKGR5QyA8IDAgfHwgZHlDID49ICR7aX0pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZsb2F0IHNvdXJjZUZyYWNSb3cgPVxuICAgICAgICAgICAgICBmbG9hdCgke29bMF19KSAqXG4gICAgICAgICAgICAgICAgKGZsb2F0KGR5UikgLyBmbG9hdCgke2xbMF19KSk7XG5cbiAgICAgICAgICAgIGZsb2F0IHNvdXJjZUZyYWNDb2wgPVxuICAgICAgICAgICAgICAgIGZsb2F0KCR7b1sxXX0pICpcbiAgICAgICAgICAgICAgICAgIChmbG9hdChkeUMpIC8gZmxvYXQoJHtsWzFdfSkpO1xuXG4gICAgICAgICAgICBpbnQgc291cmNlTmVhcmVzdFJvdyA9IGludChtaW4oXG4gICAgICAgICAgICAgICAgZmxvYXQoaW50KCR7YX0pIC0gMSksXG4gICAgICAgICAgICAgICAgJHtufSA/IGZsb2F0KHJvdW5kKHNvdXJjZUZyYWNSb3cpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQoZmxvb3Ioc291cmNlRnJhY1JvdykpKSk7XG5cbiAgICAgICAgICAgIGludCBzb3VyY2VOZWFyZXN0Q29sID0gaW50KG1pbihcbiAgICAgICAgICAgICAgICBmbG9hdChpbnQoJHtyfSkgLSAxKSxcbiAgICAgICAgICAgICAgICAke259ID8gZmxvYXQocm91bmQoc291cmNlRnJhY0NvbCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdChmbG9vcihzb3VyY2VGcmFjQ29sKSkpKTtcblxuICAgICAgICAgICAgaWYgKHIgPT0gc291cmNlTmVhcmVzdFJvdyAmJiBjID09IHNvdXJjZU5lYXJlc3RDb2wpIHtcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgKz0gZ2V0RHkoYiwgZHlSLCBkeUMsIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBFbmQgbG9vcCBvdmVyIGR5XG5cbiAgICAgICAgc2V0T3V0cHV0KGFjY3VtdWxhdG9yKTtcbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24gYW9lKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7aW1hZ2VzOnIsZHk6c309dCx7YWxpZ25Db3JuZXJzOml9PWEsbz1uZXcgbm9lKHMuc2hhcGUsci5zaGFwZSxpKTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0obyxbc10scy5kdHlwZSl9dmFyIHJvZT17a2VybmVsTmFtZTpNdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzphb2V9LHNvZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdO2xldCBuPWUubGVuZ3RoO2lmKG4+NCl0aHJvdyBuZXcgRXJyb3IoYFdlYkdMIGJhY2tlbmQ6IFJldmVyc2Ugb2YgcmFuay0ke259IHRlbnNvciBpcyBub3QgeWV0IHN1cHBvcnRlZGApO2lmKHRoaXMub3V0cHV0U2hhcGU9ZSxuPT09MSl7dGhpcy51c2VyQ29kZT1gXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICBpbnQgY29vcmQgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0WCgke2VbMF19IC0gY29vcmQgLSAxKSk7XG4gICAgICAgIH1cbiAgICAgIGA7cmV0dXJufWxldCBhPWk9PnQuaW5kZXhPZihpKSE9PS0xJiZlW2ldIT09MT9gJHtlW2ldfSAtIGNvb3Jkc1ske2l9XSAtIDFgOmBjb29yZHNbJHtpfV1gLHI9ZS5tYXAoKGksbyk9PmEobykpLmpvaW4oXCIsXCIpLHM9aHQobik7dGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICR7c30gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIHNldE91dHB1dChnZXRYKCR7cn0pKTtcbiAgICAgIH1cbiAgICBgfX0saW9lPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITA7bGV0IG49ZS5sZW5ndGg7aWYobj40KXRocm93IG5ldyBFcnJvcihgV2ViR0wgYmFja2VuZDogUmV2ZXJzZSBvZiByYW5rLSR7bn0gdGVuc29yIGlzIG5vdCB5ZXQgc3VwcG9ydGVkYCk7dGhpcy5vdXRwdXRTaGFwZT1lO2xldCBhPUluKFwicmNcIixuKSxyPWAke2Fbbi0xXX0gKyAxIDwgJHt0aGlzLm91dHB1dFNoYXBlW24tMV19YCxzPWAke2Fbbi0yXX0gKyAxIDwgJHt0aGlzLm91dHB1dFNoYXBlW24tMl19YCxpPWh0KG4pO249PT0xP3RoaXMudXNlckNvZGU9YFxuICAgICAgICB2b2lkIG1haW4oKXtcbiAgICAgICAgICBpbnQgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xuICAgICAgICAgIHJlc3VsdC5yID0gZ2V0Q2hhbm5lbChnZXRYKCR7ZVswXX0gLSByYyAtIDEpLFxuICAgICAgICAgICAgJHtlWzBdfSAtIHJjIC0gMSk7XG4gICAgICAgICAgaWYoJHtyfSl7XG4gICAgICAgICAgICAgIHJlc3VsdC5nID0gZ2V0Q2hhbm5lbChnZXRYKCR7ZVswXX0gLSAocmMgICsgMSkgLSAxKSxcbiAgICAgICAgICAgICAgICAke2VbMF19IC0gKHJjICArIDEpIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICBgOnRoaXMudXNlckNvZGU9YFxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgJHtpfSByYyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XG4gICAgICAgICAgcmVzdWx0LnIgPSAke28oYS5zbGljZSgpKX07XG4gICAgICAgICAgaWYoJHtyfSl7XG4gICAgICAgICAgICByZXN1bHQuZyA9ICR7bChhLnNsaWNlKCkpfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoJHtzfSkge1xuICAgICAgICAgICAgcmVzdWx0LmIgPSAke3UoYS5zbGljZSgpKX07XG4gICAgICAgICAgICBpZigke3J9KSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5hID0gJHtwKGEuc2xpY2UoKSl9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgIGA7ZnVuY3Rpb24gbyhoKXtyZXR1cm4gZChoKX1mdW5jdGlvbiBsKGgpe3JldHVybiBoW24tMV09XCIoXCIraFtuLTFdK1wiICsgMSlcIixkKGgpfWZ1bmN0aW9uIHUoaCl7cmV0dXJuIGhbbi0yXT1cIihcIitoW24tMl0rXCIgKyAxKVwiLGQoaCl9ZnVuY3Rpb24gcChoKXtyZXR1cm4gaFtuLTFdPVwiKFwiK2hbbi0xXStcIiArIDEpXCIsaFtuLTJdPVwiKFwiK2hbbi0yXStcIiArIDEpXCIsZChoKX1mdW5jdGlvbiBkKGgpe2xldCBtPWUubWFwKChiLHkpPT5jKHksaCkpLGY9bS5qb2luKFwiLFwiKSxnPW0uc2xpY2UoLTIpLmpvaW4oXCIsXCIpO3JldHVybmBnZXRDaGFubmVsKGdldFgoJHtmfSksIHZlYzIoJHtnfSkpYH1mdW5jdGlvbiBjKGgsbSl7cmV0dXJuIHQuaW5kZXhPZihoKSE9PS0xJiZlW2hdIT09MT9gJHtlW2hdfSAtICR7bVtoXX0gLSAxYDpgJHttW2hdfWB9fX07ZnVuY3Rpb24gb29lKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtkaW1zOnN9PWEsaT1yLnNoYXBlLmxlbmd0aCxvPXcucGFyc2VBeGlzUGFyYW0ocyxyLnNoYXBlKTtpZihpPT09MClyZXR1cm4gdGEoe2lucHV0czp7eDpyfSxiYWNrZW5kOm59KTtsZXQgbD1HKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OU1wiKT9uZXcgaW9lKHIuc2hhcGUsbyk6bmV3IHNvZShyLnNoYXBlLG8pO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShsLFtyXSxyLmR0eXBlKX12YXIgbG9lPXtrZXJuZWxOYW1lOkVvLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOm9vZX0sdW9lPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkltYWdlXCJdLHRoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5jdXN0b21Vbmlmb3Jtcz1be25hbWU6XCJwYXJhbXNcIix0eXBlOlwidmVjNFwifV07bGV0IG49ZVsxXSxhPWVbMl07dGhpcy5vdXRwdXRTaGFwZT1lO2xldCByPVwiXCI7dHlwZW9mIHQ9PVwibnVtYmVyXCI/cj1gZmxvYXQgb3V0cHV0VmFsdWUgPSAke3QudG9GaXhlZCgyKX07YDpyPWBcbiAgICAgICAgdmVjMyBmaWxsID0gdmVjMygke3Quam9pbihcIixcIil9KTtcbiAgICAgICAgZmxvYXQgb3V0cHV0VmFsdWUgPSBmaWxsW2Nvb3Jkc1szXV07YCx0aGlzLnVzZXJDb2RlPWBcbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAgIGludCB4ID0gY29vcmRzWzJdO1xuICAgICAgICAgIGludCB5ID0gY29vcmRzWzFdO1xuICAgICAgICAgIGZsb2F0IGNvb3JkWEZsb2F0ID0gKGZsb2F0KHgpIC0gcGFyYW1zWzBdKSAqIHBhcmFtc1szXSAtXG4gICAgICAgICAgICAoZmxvYXQoeSkgLSBwYXJhbXNbMV0pICogcGFyYW1zWzJdO1xuICAgICAgICAgIGZsb2F0IGNvb3JkWUZsb2F0ID0gKGZsb2F0KHgpIC0gcGFyYW1zWzBdKSAqIHBhcmFtc1syXSArXG4gICAgICAgICAgICAoZmxvYXQoeSkgLSBwYXJhbXNbMV0pICogcGFyYW1zWzNdO1xuICAgICAgICAgIGludCBjb29yZFggPSBpbnQocm91bmQoY29vcmRYRmxvYXQgKyBwYXJhbXNbMF0pKTtcbiAgICAgICAgICBpbnQgY29vcmRZID0gaW50KHJvdW5kKGNvb3JkWUZsb2F0ICsgcGFyYW1zWzFdKSk7XG4gICAgICAgICAgJHtyfVxuICAgICAgICAgIGlmKGNvb3JkWCA+PSAwICYmIGNvb3JkWCA8ICR7YX0gJiYgY29vcmRZID49IDAgJiYgY29vcmRZIDwgJHtufSkge1xuICAgICAgICAgICAgb3V0cHV0VmFsdWUgPSBnZXRJbWFnZShjb29yZHNbMF0sIGNvb3JkWSwgY29vcmRYLCBjb29yZHNbM10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRPdXRwdXQob3V0cHV0VmFsdWUpO1xuICAgICAgICB9XG4gICAgYH19LHBvZT17a2VybmVsTmFtZTpadSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzooe2lucHV0czplLGF0dHJzOnQsYmFja2VuZDpufSk9PntsZXR7aW1hZ2U6YX09ZSx7cmFkaWFuczpyLGZpbGxWYWx1ZTpzLGNlbnRlcjppfT10LG89bixsPW5ldyB1b2UoYS5zaGFwZSxzKSxbdSxwXT1ULmdldEltYWdlQ2VudGVyKGksYS5zaGFwZVsxXSxhLnNoYXBlWzJdKSxkPVtbdSxwLE1hdGguc2luKHIpLE1hdGguY29zKHIpXV07cmV0dXJuIG8ucnVuV2ViR0xQcm9ncmFtKGwsW2FdLGEuZHR5cGUsZCl9fSxjb2U9YFxuICAvLyBPcGVuR0wgRVMgZG9lcyBub3Qgc3VwcG9ydCByb3VuZCBmdW5jdGlvbi5cbiAgLy8gVGhlIGFsZ29yaXRobSBpcyBiYXNlZCBvbiBiYW5rZXIncyByb3VuZGluZy5cbiAgZmxvYXQgYmFzZSA9IGZsb29yKHgpO1xuICBpZiAoKHggLSBiYXNlKSA8IDAuNSkge1xuICAgIHJldHVybiBmbG9vcih4KTtcbiAgfSBlbHNlIGlmICgoeCAtIGJhc2UpID4gMC41KSB7XG4gICAgcmV0dXJuIGNlaWwoeCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG1vZChiYXNlLCAyLjApID09IDAuMCkge1xuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiYXNlICsgMS4wO1xuICAgIH1cbiAgfVxuYCxkb2U9WmUoe29wU25pcHBldDpjb2V9KSxob2U9e2tlcm5lbE5hbWU6X28sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6ZG9lfSxtb2U9XCJyZXR1cm4gaW52ZXJzZXNxcnQoeCk7XCIsZm9lPVplKHtvcFNuaXBwZXQ6bW9lLGNwdUtlcm5lbEltcGw6VFF9KSxnb2U9e2tlcm5lbE5hbWU6QW8sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6Zm9lfSxkaz1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixhLHIscyxpPSEwLG89ITEpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ1cGRhdGVzXCIsXCJpbmRpY2VzXCIsXCJkZWZhdWx0VmFsdWVcIl0sdGhpcy5vdXRwdXRTaGFwZT1zO2xldCBsPWh0KHIubGVuZ3RoKSx1PWh0KHMubGVuZ3RoKSxwPVwiXCI7bj09PTE/cD1cImlcIjpuPT09MiYmKHA9XCJpLCBqXCIpO2xldCBkPWBnZXRJbmRpY2VzKCR7cH0pYCxjPVwiXCI7YT09PTE/Yz1cImlcIjphPT09MiYmKGM9XCJpLCBjb29yZHNbMV1cIik7bGV0IGg9YGdldFVwZGF0ZXMoJHtjfSlgLG09XCJcIjtvJiYobT1cImNvb3Jkc1swXSwgY29vcmRzWzFdXCIpO2xldCBmPWBnZXREZWZhdWx0VmFsdWUoJHttfSlgLGc9dD4xP1wic3RyaWRlc1tqXVwiOlwic3RyaWRlc1wiO3RoaXMudXNlckNvZGU9YFxuICAgICAgICAke2x9IHN0cmlkZXMgPSAke2x9KCR7cn0pO1xuXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAke3V9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAgIGZsb2F0IHN1bSA9IDAuMDtcbiAgICAgICAgICBib29sIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke2V9OyBpKyspIHtcbiAgICAgICAgICAgIGludCBmbGF0dGVuZWRJbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8ICR7dH07IGorKykge1xuICAgICAgICAgICAgICBpbnQgaW5kZXggPSByb3VuZCgke2R9KTtcbiAgICAgICAgICAgICAgZmxhdHRlbmVkSW5kZXggKz0gaW5kZXggKiAke2d9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZsYXR0ZW5lZEluZGV4ID09IGNvb3Jkc1swXSkge1xuICAgICAgICAgICAgICBzdW0gKz0gJHtofTtcbiAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRPdXRwdXQobWl4KCR7Zn0sIHN1bSwgZmxvYXQoZm91bmQpKSk7XG4gICAgICAgIH1cbiAgICAgIGB9fSxib2U9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4sYSxyLHMsaT0hMCxvPSExKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1widXBkYXRlc1wiLFwiaW5kaWNlc1wiLFwiZGVmYXVsdFZhbHVlXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9cztsZXQgbD1odChyLmxlbmd0aCksdT1odChzLmxlbmd0aCkscD1cIlwiO249PT0xP3A9XCJpXCI6bj09PTImJihwPVwiaSwgalwiKTtsZXQgZD1gZ2V0SW5kaWNlcygke3B9KWAsYz1cIlwiO2E9PT0xP2M9XCJpXCI6YT09PTImJihjPVwiaSwgY29vcmRzWzFdXCIpO2xldCBoPWBnZXRVcGRhdGVzKCR7Y30pYCxtPVwiXCI7byYmKG09XCJjb29yZHNbMF0sIGNvb3Jkc1sxXVwiKTtsZXQgZj1gZ2V0RGVmYXVsdFZhbHVlKCR7bX0pYCxnPXQ+MT9cInN0cmlkZXNbal1cIjpcInN0cmlkZXNcIixiPXQ+MT9cInN0cmlkZXNbaiArIDFdXCI6XCJzdHJpZGVzXCI7dGhpcy51c2VyQ29kZT1gXG4gICAgICAgICR7bH0gc3RyaWRlcyA9ICR7bH0oJHtyfSk7XG5cbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICR7dX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICAgdmVjNCBzdW0gPSB2ZWM0KDAuKTtcbiAgICAgICAgICB2ZWM0IGZvdW5kID0gdmVjNCgwLik7XG4gICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke2V9OyBpKz0yKSB7XG4gICAgICAgICAgICBpdmVjMiBmbGF0dGVuZWRJbmRleCA9IGl2ZWMyKDApO1xuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCAke3R9OyBqKz0yKSB7XG4gICAgICAgICAgICAgIGl2ZWM0IGluZGV4ID0gcm91bmQoJHtkfSk7XG4gICAgICAgICAgICAgIGZsYXR0ZW5lZEluZGV4ICs9IGluZGV4Lnh6ICogJHtnfTtcbiAgICAgICAgICAgICAgaWYgKGogKyAxIDwgJHt0fSkge1xuICAgICAgICAgICAgICAgIGZsYXR0ZW5lZEluZGV4ICs9IGluZGV4Lnl3ICogJHtifTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZsYXR0ZW5lZEluZGV4WzBdID09IGNvb3Jkc1swXSB8fCBmbGF0dGVuZWRJbmRleFsxXSA9PSBjb29yZHNbMF0gfHxcbiAgICAgICAgICAgICAgICBmbGF0dGVuZWRJbmRleFswXSA9PSBjb29yZHNbMF0gKyAxIHx8IGZsYXR0ZW5lZEluZGV4WzFdID09IGNvb3Jkc1swXSArIDEpIHtcbiAgICAgICAgICAgICAgdmVjNCB1cGRWYWxzID0gJHtofTtcbiAgICAgICAgICAgICAgaWYgKGZsYXR0ZW5lZEluZGV4WzBdID09IGNvb3Jkc1swXSkge1xuICAgICAgICAgICAgICAgIHN1bS54eSArPSB1cGRWYWxzLnh5O1xuICAgICAgICAgICAgICAgIGZvdW5kLnh5ID0gdmVjMigxLik7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmxhdHRlbmVkSW5kZXhbMF0gPT0gY29vcmRzWzBdICsgMSkge1xuICAgICAgICAgICAgICAgIHN1bS56dyArPSB1cGRWYWxzLnh5O1xuICAgICAgICAgICAgICAgIGZvdW5kLnp3ID0gdmVjMigxLik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGZsYXR0ZW5lZEluZGV4WzFdID09IGNvb3Jkc1swXSkge1xuICAgICAgICAgICAgICAgIHN1bS54eSArPSB1cGRWYWxzLnp3O1xuICAgICAgICAgICAgICAgIGZvdW5kLnh5ID0gdmVjMigxLik7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmxhdHRlbmVkSW5kZXhbMV0gPT0gY29vcmRzWzBdICsgMSkge1xuICAgICAgICAgICAgICAgIHN1bS56dyArPSB1cGRWYWxzLnp3O1xuICAgICAgICAgICAgICAgIGZvdW5kLnp3ID0gdmVjMigxLik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0T3V0cHV0KG1peCgke2Z9LCBzdW0sIGZvdW5kKSk7XG4gICAgICAgIH1cbiAgICAgIGB9fTtmdW5jdGlvbiB5b2UoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtpbmRpY2VzOnIsdXBkYXRlczpzfT10LHtzaGFwZTppfT1hLHtzbGljZVJhbms6byxudW1VcGRhdGVzOmwsc2xpY2VTaXplOnUsc3RyaWRlczpwLG91dHB1dFNpemU6ZH09VC5jYWxjdWxhdGVTaGFwZXMocyxyLGkpLGM9W2QvdSx1XTtpZihkPT09MClyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhpLHIuZHR5cGUpO2xldCBoPWNlKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpbbCxvXX19KSxtPWNlKHtpbnB1dHM6e3g6c30sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpbbCx1XX19KSxmPW4ubWFrZVRlbnNvckluZm8oW10sXCJmbG9hdDMyXCIsbmV3IEZsb2F0MzJBcnJheShbMF0pKSxnO0coKS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKT9nPW5ldyBib2UobCxvLGguc2hhcGUubGVuZ3RoLG0uc2hhcGUubGVuZ3RoLHAsYyk6Zz1uZXcgZGsobCxvLGguc2hhcGUubGVuZ3RoLG0uc2hhcGUubGVuZ3RoLHAsYyk7bGV0IGI9bi5ydW5XZWJHTFByb2dyYW0oZyxbbSxoLGZdLG0uZHR5cGUpLHk9Y2Uoe2lucHV0czp7eDpifSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOml9fSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaCksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhtKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGIpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZikseX12YXIgeG9lPXtrZXJuZWxOYW1lOlB1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOnlvZX0sdm9lPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuLGEpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJzb3J0ZWRTZXF1ZW5jZVwiLFwidmFsdWVzXCJdLHRoaXMuY3VzdG9tVW5pZm9ybXM9W3tuYW1lOlwibnVtSW5wdXRzXCIsdHlwZTpcImludFwifV0sdGhpcy5vdXRwdXRTaGFwZT1bZSxuXTtsZXQgcj1cIndoaWxlIChsZWZ0IDwgcmlnaHQpIHtcIixzPWBmb3IgKGludCBpID0gMDsgaSA8ICR7TWF0aC5jZWlsKE1hdGgubG9nMih0KzEpKX07ICsraSkgeyBpZiAobGVmdCA+PSByaWdodCkgYnJlYWs7YCxpPUcoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpPT09Mj9yOnMsbz1hPT09XCJsZWZ0XCI/XCI8XCI6XCI8PVwiO3RoaXMudXNlckNvZGU9YFxuICAgICAgIGludCBmaW5kQm91bmQoaW50IGJhdGNoLCBmbG9hdCB2YWx1ZSkge1xuICAgICAgICAgaW50IGxlZnQgPSAwO1xuICAgICAgICAgaW50IHJpZ2h0ID0gbnVtSW5wdXRzO1xuICAgICAgICAgaW50IG1pZDtcbiAgICAgICAgICR7aX1cbiAgICAgICAgICAgbWlkID0gKGxlZnQgKyByaWdodCkgLyAyO1xuICAgICAgICAgICBpZiAoZ2V0U29ydGVkU2VxdWVuY2UoYmF0Y2gsIG1pZCkgJHtvfSB2YWx1ZSkge1xuICAgICAgICAgICAgIGxlZnQgPSBtaWQgKyAxO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIHJpZ2h0ID0gbWlkO1xuICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgICByZXR1cm4gcmlnaHQ7XG4gICAgICAgfVxuXG4gICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XG4gICAgICAgICBpbnQgdmFsdWVJbmRleCA9IGNvb3Jkc1sxXTtcblxuICAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRWYWx1ZXMoYmF0Y2gsIHZhbHVlSW5kZXgpO1xuXG4gICAgICAgICBzZXRPdXRwdXQoZmxvYXQoZmluZEJvdW5kKGJhdGNoLCB2YWx1ZSkpKTtcbiAgICAgICB9XG4gICAgIGB9fTtmdW5jdGlvbiB3b2UoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtzb3J0ZWRTZXF1ZW5jZTpyLHZhbHVlczpzfT10LHtzaWRlOml9PWEsbz1uZXcgdm9lKHIuc2hhcGVbMF0sci5zaGFwZVsxXSxzLnNoYXBlWzFdLGkpLGw9W1tyLnNoYXBlWzFdXV07cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKG8sW3Isc10sXCJpbnQzMlwiLGwpfXZhciBrb2U9e2tlcm5lbE5hbWU6enUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6d29lfSxJb2U9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJjXCIsXCJhXCIsXCJiXCJdLHRoaXMub3V0cHV0U2hhcGU9dDtsZXQgYSxyO2lmKG4+NCl0aHJvdyBFcnJvcihgV2hlcmUgZm9yIHJhbmsgJHtufSBpcyBub3QgeWV0IHN1cHBvcnRlZGApO2lmKG49PT0xKXI9XCJyZXNSQ1wiLGE9XCJyZXNSQ1wiO2Vsc2V7bGV0IGk9W1wicmVzUkMueFwiLFwicmVzUkMueVwiLFwicmVzUkMuelwiLFwicmVzUkMud1wiXSxvPVtdLGw9W107Zm9yKGxldCB1PTA7dTx0Lmxlbmd0aDt1KyspbC5wdXNoKGAke2lbdV19YCksdTxlJiZvLnB1c2goYCR7aVt1XX1gKTthPW8uam9pbigpLHI9bC5qb2luKCl9bGV0IHM9aHQobik7dGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICR7c30gcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgZmxvYXQgY1ZhbCA9IGdldEMoJHthfSk7XG4gICAgICAgIGlmIChjVmFsID49IDEuMCkge1xuICAgICAgICAgIHNldE91dHB1dChnZXRBKCR7cn0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0Qigke3J9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24gU29lKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse2NvbmRpdGlvbjphLHQ6cixlOnN9PXQsaT1uZXcgSW9lKGEuc2hhcGUubGVuZ3RoLHIuc2hhcGUsci5zaGFwZS5sZW5ndGgpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShpLFthLHIsc10sZmEoci5kdHlwZSxzLmR0eXBlKSl9dmFyIE5vZT17a2VybmVsTmFtZTpXdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpTb2V9LFRvZT1gXG4gIC8vIFN0YWJsZSBhbmQgQXR0cmFjdGluZyBGaXhlZCBQb2ludCAoMCwgMSkgZm9yIE5vcm1hbGl6ZWQgV2VpZ2h0cy5cbiAgLy8gc2VlOiBodHRwczovL2FyeGl2Lm9yZy9hYnMvMTcwNi4wMjUxNVxuICBmbG9hdCBzY2FsZUFscGhhID0gJHtULlNFTFVfU0NBTEVBTFBIQX07XG4gIGZsb2F0IHNjYWxlID0gJHtULlNFTFVfU0NBTEV9O1xuICByZXR1cm4gKHggPj0gMC4wKSA/IHNjYWxlICogeCA6IHNjYWxlQWxwaGEgKiAoZXhwKHgpIC0gMS4wKTtcbmAsQ29lPVplKHtvcFNuaXBwZXQ6VG9lfSksRW9lPXtrZXJuZWxOYW1lOkZvLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkNvZX0sX29lPW1wK2BcbiAgcmV0dXJuIDEuMCAvICgxLjAgKyBleHAoLTEuMCAqIHgpKTtcbmAsQW9lPWBcbiAgdmVjNCByZXN1bHQgPSAxLjAgLyAoMS4wICsgZXhwKC0xLjAgKiB4KSk7XG4gIGJ2ZWM0IGlzTmFOID0gaXNuYW4oeCk7XG5cbiAgcmVzdWx0LnIgPSBpc05hTi5yID8geC5yIDogcmVzdWx0LnI7XG4gIHJlc3VsdC5nID0gaXNOYU4uZyA/IHguZyA6IHJlc3VsdC5nO1xuICByZXN1bHQuYiA9IGlzTmFOLmIgPyB4LmIgOiByZXN1bHQuYjtcbiAgcmVzdWx0LmEgPSBpc05hTi5hID8geC5hIDogcmVzdWx0LmE7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbmAsRm9lPVplKHtvcFNuaXBwZXQ6X29lLHBhY2tlZE9wU25pcHBldDpBb2UsY3B1S2VybmVsSW1wbDpFUX0pLCRvZT17a2VybmVsTmFtZTpNbyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpGb2V9LERvZT1gXG4gIGlmIChpc25hbih4KSkgeyByZXR1cm4gMC4wOyB9XG4gIHJldHVybiBzaWduKHgpO1xuYCxSb2U9WmUoe29wU25pcHBldDpEb2V9KSxNb2U9e2tlcm5lbE5hbWU6Um8sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6Um9lfSxPb2U9bXArYFxuICByZXR1cm4gc2luKHgpO1xuYCxQb2U9YFxuICB2ZWM0IHJlc3VsdCA9IHNpbih4KTtcbiAgYnZlYzQgaXNOYU4gPSBpc25hbih4KTtcbiAgJHtRb31cbiAgcmV0dXJuIHJlc3VsdDtcbmAsTG9lPVplKHtvcFNuaXBwZXQ6T29lLHBhY2tlZE9wU25pcHBldDpQb2V9KSx6b2U9e2tlcm5lbE5hbWU6JG8sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6TG9lfSxXb2U9YFxuICBmbG9hdCBlMnggPSBleHAoeCk7XG4gIHJldHVybiAoZTJ4IC0gMS4wIC8gZTJ4KSAvIDIuMDtcbmAsQm9lPVplKHtvcFNuaXBwZXQ6V29lfSksVm9lPXtrZXJuZWxOYW1lOkRvLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkJvZX0sVW9lPWBcbiAgZmxvYXQgZXBzaWxvbiA9IDEuMTkyMDkyODk1NTA3ODEyNWUtNztcbiAgZmxvYXQgdGhyZXNob2xkID0gbG9nKGVwc2lsb24pICsgMi4wO1xuXG4gIGJvb2wgdG9vX2xhcmdlID0geCA+IC10aHJlc2hvbGQ7XG4gIGJvb2wgdG9vX3NtYWxsID0geCA8IHRocmVzaG9sZDtcblxuICBmbG9hdCByZXN1bHQ7XG4gIGZsb2F0IGV4cF94ID0gZXhwKHgpO1xuXG4gIGlmICh0b29fbGFyZ2Upe1xuICAgIHJlc3VsdCA9IHg7XG4gIH1cbiAgZWxzZSBpZiAodG9vX3NtYWxsKXtcbiAgICByZXN1bHQgPSBleHBfeDtcbiAgfVxuICBlbHNle1xuICAgIHJlc3VsdCA9IGxvZyhleHBfeCArIDEuMCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbmAsR29lPVplKHtvcFNuaXBwZXQ6VW9lfSksSG9lPXtrZXJuZWxOYW1lOk9vLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkdvZX0sam9lPWU9PntsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7YmxvY2tTaGFwZTpzLHBhZGRpbmdzOml9PWE7dy5hc3NlcnQoci5zaGFwZS5sZW5ndGg8PTQsKCk9Plwic3BhY2VUb0JhdGNoTkQgZm9yIHJhbmsgPiA0IHdpdGggYSBXZWJHTCBiYWNrZW5kIG5vdCBpbXBsZW1lbnRlZCB5ZXRcIik7bGV0IG89cy5yZWR1Y2UoKGIseSk9PmIqeSksbD1bWzAsMF1dO2wucHVzaCguLi5pKTtmb3IobGV0IGI9MStzLmxlbmd0aDtiPHIuc2hhcGUubGVuZ3RoOysrYilsLnB1c2goWzAsMF0pO2xldCB1PVtdLHA9c0Yoe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3BhZGRpbmdzOmwsY29uc3RhbnRWYWx1ZTowfX0pLGQ9VC5nZXRSZXNoYXBlZChwLnNoYXBlLHMsbywhMSksYz1ULmdldFBlcm11dGVkKGQubGVuZ3RoLHMubGVuZ3RoLCExKSxoPVQuZ2V0UmVzaGFwZWRQZXJtdXRlZChwLnNoYXBlLHMsbywhMSksbT1jZSh7aW5wdXRzOnt4OnB9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6ZH19KSxmPVNuKHtpbnB1dHM6e3g6bX0sYmFja2VuZDpuLGF0dHJzOntwZXJtOmN9fSksZz1jZSh7aW5wdXRzOnt4OmZ9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6aH19KTtyZXR1cm4gdS5wdXNoKHApLHUucHVzaChtKSx1LnB1c2goZiksdS5mb3JFYWNoKGI9Pm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oYikpLGd9LHFvZT17a2VybmVsTmFtZTpWdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpqb2V9O2Z1bmN0aW9uIEtvZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHtpbmRpY2VzOmEsdmFsdWVzOnIsZGVuc2VTaGFwZTpzLGRlZmF1bHRWYWx1ZTppfT10O2lmKHMuc2hhcGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoYERlbnNlIHNoYXBlIG11c3QgYmUgYSB2ZWN0b3IsIHNhdzpcbiAgICAgICAgICR7cy5zaGFwZX1gKTtpZihhLnNoYXBlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKGBJbmRpY2VzIG11c3QgYmUgYSBtYXRyaXgsIHNhdzpcbiAgICAgICAgICR7YS5zaGFwZX1gKTtpZihyLnNoYXBlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKGBWYWx1ZXMgbXVzdCBiZSBhIHZlY3Rvciwgc2F3OlxuICAgICAgICAgJHtyLnNoYXBlfWApO2lmKGkuc2hhcGUubGVuZ3RoIT09MCl0aHJvdyBuZXcgRXJyb3IoYERlZmF1bHQgdmFsdWUgbXVzdCBiZSBhIHNjYWxhciwgc2F3OlxuICAgICAgICAke2kuc2hhcGV9YCk7bGV0IG89bi5yZWFkU3luYyhhLmRhdGFJZCksbD1uLnJlYWRTeW5jKHIuZGF0YUlkKSx1PW4ucmVhZFN5bmMocy5kYXRhSWQpLHA9bi5yZWFkU3luYyhpLmRhdGFJZClbMF0sW2QsYyxoLG0sZl09QVEobyxhLnNoYXBlLGEuZHR5cGUsbCxyLmR0eXBlLHUscCk7cmV0dXJuW24ubWFrZVRlbnNvckluZm8oYyxhLmR0eXBlLGQpLG4ubWFrZVRlbnNvckluZm8oW2NbMF1dLHIuZHR5cGUsaCksbi5tYWtlVGVuc29ySW5mbyhbbS5sZW5ndGhdLFwiYm9vbFwiLG5ldyBVaW50OEFycmF5KG0ubWFwKGc9Pk51bWJlcihnKSkpKSxuLm1ha2VUZW5zb3JJbmZvKFtmLmxlbmd0aF0sYS5kdHlwZSxuZXcgSW50MzJBcnJheShmKSldfXZhciBYb2U9e2tlcm5lbE5hbWU6R2MsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6S29lfTtmdW5jdGlvbiBZb2UoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7aW5wdXRJbmRpY2VzOmEsaW5wdXRTaGFwZTpyLG5ld1NoYXBlOnN9PXQ7aWYoYS5zaGFwZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihgSW5wdXQgaW5kaWNlcyBzaG91bGQgYmUgYSBtYXRyaXggYnV0IHJlY2VpdmVkIHNoYXBlICR7YS5zaGFwZX1gKTtpZihyLnNoYXBlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBzaGFwZSBzaG91bGQgYmUgYSB2ZWN0b3IgYnV0IHJlY2VpdmVkIHNoYXBlICR7ci5zaGFwZX1gKTtpZihzLnNoYXBlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKGBUYXJnZXQgc2hhcGUgc2hvdWxkIGJlIGEgdmVjdG9yIGJ1dCByZWNlaXZlZCBzaGFwZSAke3Muc2hhcGV9YCk7bGV0IGk9QXJyYXkuZnJvbShuLnJlYWRTeW5jKHIuZGF0YUlkKSksbz1uLnJlYWRTeW5jKGEuZGF0YUlkKSxsPUFycmF5LmZyb20obi5yZWFkU3luYyhzLmRhdGFJZCkpLFt1LHAsZF09RlEobyxhLnNoYXBlLGEuZHR5cGUsaSxsKTtyZXR1cm5bbi5tYWtlVGVuc29ySW5mbyhwLGEuZHR5cGUsdSksbi5tYWtlVGVuc29ySW5mbyhbZC5sZW5ndGhdLHMuZHR5cGUsbmV3IEludDMyQXJyYXkoZCkpXX12YXIgWm9lPXtrZXJuZWxOYW1lOkd1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOllvZX07ZnVuY3Rpb24gSm9lKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse2RhdGE6YSxpbmRpY2VzOnIsc2VnbWVudElkczpzfT10O2lmKGEuc2hhcGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBzaG91bGQgYmUgYXQgbGVhc3QgMSBkaW1lbnNpb25hbCBidXQgcmVjZWl2ZWQgc2NhbGFyXCIpO2lmKHIuc2hhcGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoYEluZGljZXMgc2hvdWxkIGJlIGEgdmVjdG9yIGJ1dCByZWNlaXZlZCBzaGFwZVxuICAgICAgICAgICAgICAke3Iuc2hhcGV9YCk7aWYocy5zaGFwZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihgU2VnbWVudCBpZHMgc2hvdWxkIGJlIGEgdmVjdG9yIGJ1dCByZWNlaXZlZCBzaGFwZVxuICAgICAgICAgICAgICAke3Muc2hhcGV9YCk7bGV0IGk9bi5yZWFkU3luYyhhLmRhdGFJZCksbz1uLnJlYWRTeW5jKHIuZGF0YUlkKSxsPW4ucmVhZFN5bmMocy5kYXRhSWQpLFt1LHBdPUVBKGksYS5zaGFwZSxhLmR0eXBlLG8sbCwhMCk7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8ocCxhLmR0eXBlLHUpfXZhciBRb2U9e2tlcm5lbE5hbWU6SGMsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6Sm9lfTtmdW5jdGlvbiBlbGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7ZGF0YTphLGluZGljZXM6cixzZWdtZW50SWRzOnN9PXQ7aWYoYS5zaGFwZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIHNob3VsZCBiZSBhdCBsZWFzdCAxIGRpbWVuc2lvbmFsIGJ1dCByZWNlaXZlZCBzY2FsYXJcIik7aWYoci5zaGFwZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihgSW5kaWNlcyBzaG91bGQgYmUgYSB2ZWN0b3IgYnV0IHJlY2VpdmVkIHNoYXBlXG4gICAgICAgICAgICAgJHtyLnNoYXBlfWApO2lmKHMuc2hhcGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoYFNlZ21lbnQgaWRzIHNob3VsZCBiZSBhIHZlY3RvciBidXQgcmVjZWl2ZWQgc2hhcGVcbiAgICAgICAgICAgICAke3Muc2hhcGV9YCk7bGV0IGk9bi5yZWFkU3luYyhhLmRhdGFJZCksbz1uLnJlYWRTeW5jKHIuZGF0YUlkKSxsPW4ucmVhZFN5bmMocy5kYXRhSWQpLFt1LHBdPUVBKGksYS5zaGFwZSxhLmR0eXBlLG8sbCk7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8ocCxhLmR0eXBlLHUpfXZhciB0bGU9e2tlcm5lbE5hbWU6amMsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6ZWxlfTtmdW5jdGlvbiBubGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtzcGFyc2VJbmRpY2VzOnIsc3BhcnNlVmFsdWVzOnMsZGVmYXVsdFZhbHVlOml9PXQse291dHB1dFNoYXBlOm99PWEse3NsaWNlUmFuazpsLG51bVVwZGF0ZXM6dSxzbGljZVNpemU6cCxzdHJpZGVzOmQsb3V0cHV0U2l6ZTpjfT1ULmNhbGN1bGF0ZVNoYXBlcyhzLHIsbyksaD0hMTtpZihzLmR0eXBlPT09XCJzdHJpbmdcIil7bGV0IGI9bi5idWZmZXJTeW5jKHIpLHk9bi5idWZmZXJTeW5jKHMpLHg9dy5kZWNvZGVTdHJpbmcobi5yZWFkU3luYyhpLmRhdGFJZClbMF0pLHY9Q1EoYix5LG8sYyxwLHUsbCxkLHgsaCk7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8obyx2LmR0eXBlLHYudmFsdWVzKX1sZXQgbT1uZXcgZGsodSxsLHIuc2hhcGUubGVuZ3RoLHMuc2hhcGUubGVuZ3RoLGQsW2MsMV0saCksZj1uLnJ1bldlYkdMUHJvZ3JhbShtLFtzLHIsaV0scy5kdHlwZSksZz1jZSh7aW5wdXRzOnt4OmZ9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6b319KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhmKSxnfXZhciBhbGU9e2tlcm5lbE5hbWU6SHUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6bmxlfTtmdW5jdGlvbiBybGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse251bU9yU2l6ZVNwbGl0czpzLGF4aXM6aX09YSxvPXcucGFyc2VBeGlzUGFyYW0oaSxyLnNoYXBlKVswXSxsPVQucHJlcGFyZVNwbGl0U2l6ZShyLHMsbyksdT1yLnNoYXBlLmxlbmd0aCxwPW5ldyBBcnJheSh1KS5maWxsKDApLGQ9ci5zaGFwZS5zbGljZSgpO3JldHVybiBsLm1hcChjPT57bGV0IGg9Wy4uLmRdO2hbb109YztsZXQgbT1mcCh7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bixhdHRyczp7YmVnaW46cCxzaXplOmh9fSk7cmV0dXJuIHBbb10rPWMsbX0pfXZhciBzbGU9e2tlcm5lbE5hbWU6VXUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6cmxlfSxJUz1cInJldHVybiBzcXJ0KHgpO1wiLGlsZT1aZSh7b3BTbmlwcGV0OklTLHBhY2tlZE9wU25pcHBldDpJUyxjcHVLZXJuZWxJbXBsOiRRfSksb2xlPXtrZXJuZWxOYW1lOlBvLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmlsZX0sbGxlPVwicmV0dXJuIHggKiB4O1wiLHVsZT1aZSh7b3BTbmlwcGV0OmxsZX0pLHBsZT17a2VybmVsTmFtZTpxYyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzp1bGV9LFNTPVwicmV0dXJuIChhIC0gYikgKiAoYSAtIGIpO1wiLGNsZT1obih7b3BTbmlwcGV0OlNTLHBhY2tlZE9wU25pcHBldDpTU30pLGRsZT17a2VybmVsTmFtZTpXbyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpjbGV9O2Z1bmN0aW9uIGhsZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dDtpZihyLmR0eXBlIT09XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBtdXN0IGJlIG9mIGRhdGF0eXBlIHN0cmluZ1wiKTtsZXQgcz1uLnJlYWRTeW5jKHIuZGF0YUlkKSxpPVQuZnJvbVVpbnQ4VG9TdHJpbmdBcnJheShzKSxvPURRKGksXCJzdHJpbmdcIixhKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhyLnNoYXBlLFwic3RyaW5nXCIsbyl9dmFyIG1sZT17a2VybmVsTmFtZTpLYyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpobGV9O2Z1bmN0aW9uIGZsZSh7aW5wdXRzOmUsYXR0cnM6dCxiYWNrZW5kOm59KXtsZXR7eDphfT1lLHI9RGErYFxuICAgIHJldHVybiB4ID4gMC4wID8gMS4wIDogZmxvYXQoJHt0LmFscGhhfSk7XG4gIGAscz1uZXcgcnIoYS5zaGFwZSxyKTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0ocyxbYV0sYS5kdHlwZSl9dmFyIGdsZT17a2VybmVsTmFtZTpJcyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpmbGV9LGJsZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT1uO2xldCBhPW4ubGVuZ3RoLHI9aHQobi5sZW5ndGgpLHM9aHQobi5sZW5ndGgpLGk9XCJcIjtpZihhPT09MSlpPVwiY29vcmRzICogc3RyaWRlcyArIGJlZ2luXCI7ZWxzZXtsZXQgbz0wO2k9bi5tYXAoKGwsdSk9PihvKyssbi5sZW5ndGg9PT0xP2Bjb29yZHMgKiBzdHJpZGVzWyR7dX1dICsgYmVnaW5bJHt1fV1gOmBjb29yZHNbJHtvLTF9XSAqIHN0cmlkZXNbJHt1fV0gKyBiZWdpblske3V9XWApKS5qb2luKFwiLFwiKX10aGlzLnVzZXJDb2RlPWBcbiAgICAgICR7cn0gYmVnaW4gPSAke3J9KCR7ZX0pO1xuICAgICAgJHtyfSBzdHJpZGVzID0gJHtyfSgke3R9KTtcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAke3N9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBzZXRPdXRwdXQoZ2V0WCgke2l9KSk7XG4gICAgICB9XG4gICAgYH19O2Z1bmN0aW9uIHlsZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7YmVnaW46cyxlbmQ6aSxzdHJpZGVzOm8sYmVnaW5NYXNrOmwsZW5kTWFzazp1LGVsbGlwc2lzTWFzazpwLG5ld0F4aXNNYXNrOmQsc2hyaW5rQXhpc01hc2s6Y309YSx7ZmluYWxTaGFwZVNwYXJzZTpoLGZpbmFsU2hhcGU6bSxpc0lkZW50aXR5OmYsc2xpY2VEaW0wOmcsaXNTaW1wbGVTbGljZTpiLGJlZ2luOnksZW5kOngsc3RyaWRlczp2fT1LdC5zbGljZUluZm8oci5zaGFwZSxzLGksbyxsLHUscCxkLGMpLEk7aWYoZilJPWNlKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTptfX0pO2Vsc2UgaWYoZ3x8Yil7dy5hc3NlcnQoci5zaGFwZS5sZW5ndGg+PTEsKCk9PmBJbnB1dCBtdXN0IGhhdmUgcmFuayBhdCBsZWFzdCAxLCBnb3Q6ICR7ci5zaGFwZS5sZW5ndGh9YCk7bGV0IEM9S3QuY29tcHV0ZU91dFNoYXBlKHkseCx2KSxfPWZwKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntiZWdpbjp5LHNpemU6Q319KTtJPWNlKHtpbnB1dHM6e3g6X30sYmFja2VuZDpuLGF0dHJzOntzaGFwZTptfX0pLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oXyl9ZWxzZSBpZihuLnNob3VsZEV4ZWN1dGVPbkNQVShbcl0pKXtsZXQgQz1uLnJlYWRTeW5jKHIuZGF0YUlkKSxfPU9lKHIuc2hhcGUsci5kdHlwZSxDKSxGPVJRKGgsXyx2LHkpO0k9bi5tYWtlVGVuc29ySW5mbyhtLHIuZHR5cGUsRi52YWx1ZXMpfWVsc2V7bGV0IEM9bmV3IGJsZSh5LHYsaCk7ST1uLnJ1bldlYkdMUHJvZ3JhbShDLFtyXSxyLmR0eXBlKX1sZXQgTj1jZSh7aW5wdXRzOnt4Okl9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6bX19KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhJKSxOfXZhciB4bGU9e2tlcm5lbE5hbWU6anUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6eWxlfTtmdW5jdGlvbiB2bGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtzZXBhcmF0b3I6cixuR3JhbVdpZHRoczpzLGxlZnRQYWQ6aSxyaWdodFBhZDpvLHBhZFdpZHRoOmwscHJlc2VydmVTaG9ydFNlcXVlbmNlczp1fT1hLHtkYXRhOnAsZGF0YVNwbGl0czpkfT10LGM9bi5yZWFkU3luYyhwLmRhdGFJZCksaD1uLnJlYWRTeW5jKGQuZGF0YUlkKSxbbSxmXT1NUShjLGgscixzLGksbyxsLHUpO3JldHVybltuLm1ha2VUZW5zb3JJbmZvKFttLmxlbmd0aF0sXCJzdHJpbmdcIixtKSxuLm1ha2VUZW5zb3JJbmZvKGQuc2hhcGUsXCJpbnQzMlwiLGYpXX12YXIgd2xlPXtrZXJuZWxOYW1lOlhjLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOnZsZX07ZnVuY3Rpb24ga2xlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7c2tpcEVtcHR5OnJ9PWEse2lucHV0OnMsZGVsaW1pdGVyOml9PXQ7aWYocy5kdHlwZSE9PVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgbXVzdCBiZSBvZiBkYXRhdHlwZSBzdHJpbmdcIik7aWYocy5zaGFwZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihgSW5wdXQgbXVzdCBiZSBhIHZlY3RvciwgZ290IHNoYXBlOiAke3Muc2hhcGV9YCk7aWYoaS5zaGFwZS5sZW5ndGghPT0wKXRocm93IG5ldyBFcnJvcihgRGVsaW1pdGVyIG11c3QgYmUgYSBzY2FsYXIsIGdvdCBzaGFwZTogJHtpLnNoYXBlfWApO2xldCBvPW4ucmVhZFN5bmMocy5kYXRhSWQpLGw9bi5yZWFkU3luYyhpLmRhdGFJZClbMF0sW3UscCxkXT1PUShvLGwsciksYz1wLmxlbmd0aDtyZXR1cm5bbi5tYWtlVGVuc29ySW5mbyhbYywyXSxcImludDMyXCIsdSksbi5tYWtlVGVuc29ySW5mbyhbY10sXCJzdHJpbmdcIixwKSxuLm1ha2VUZW5zb3JJbmZvKFsyXSxcImludDMyXCIsbmV3IEludDMyQXJyYXkoZCkpXX12YXIgSWxlPXtrZXJuZWxOYW1lOlljLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmtsZX07ZnVuY3Rpb24gU2xlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7bnVtQnVja2V0czpyfT1hLHtpbnB1dDpzfT10O2lmKHMuZHR5cGUhPT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihcIklucHV0IG11c3QgYmUgb2YgZGF0YXR5cGUgc3RyaW5nXCIpO2lmKHI8PTApdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIG9mIGJ1Y2tldHMgbXVzdCBiZSBhdCBsZWFzdCAxXCIpO2xldCBpPW4ucmVhZFN5bmMocy5kYXRhSWQpLG89UFEoaSxyKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhzLnNoYXBlLFwiaW50MzJcIixvKX12YXIgTmxlPXtrZXJuZWxOYW1lOlpjLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlNsZX0sVGxlPVwicmV0dXJuIHRhbih4KTtcIixDbGU9WmUoe29wU25pcHBldDpUbGV9KSxFbGU9e2tlcm5lbE5hbWU6Vm8sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6Q2xlfSxfbGU9YFxuICBmbG9hdCBlMnggPSBleHAoLTIuMCAqIGFicyh4KSk7XG4gIHJldHVybiBzaWduKHgpICogKDEuMCAtIGUyeCkgLyAoMS4wICsgZTJ4KTtcbmAsQWxlPVplKHtvcFNuaXBwZXQ6X2xlfSksRmxlPXtrZXJuZWxOYW1lOlVvLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkFsZX07ZnVuY3Rpb24gJGxlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7dGVuc29yOnIsaW5kaWNlczpzLHVwZGF0ZXM6aX09dCx7fT1hLHtzbGljZVJhbms6byxudW1VcGRhdGVzOmwsc2xpY2VTaXplOnUsc3RyaWRlczpwLG91dHB1dFNpemU6ZH09VC5jYWxjdWxhdGVTaGFwZXMoaSxzLHIuc2hhcGUpLGM9W2QvdSx1XTtpZihkPT09MClyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhyLnNoYXBlLHMuZHR5cGUpO2xldCBoPWNlKHtpbnB1dHM6e3g6c30sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpbbCxvXX19KSxtPWNlKHtpbnB1dHM6e3g6aX0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpbbCx1XX19KSxmPWNlKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpjfX0pLGc9bmV3IGRrKGwsbyxoLnNoYXBlLmxlbmd0aCxtLnNoYXBlLmxlbmd0aCxwLGMsITEsITApLGI9bi5ydW5XZWJHTFByb2dyYW0oZyxbbSxoLGZdLGYuZHR5cGUpLHk9Y2Uoe2lucHV0czp7eDpifSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOnIuc2hhcGV9fSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaCksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhtKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGYpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oYikseX12YXIgRGxlPXtrZXJuZWxOYW1lOkx1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOiRsZX0sUmxlPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl07bGV0IG49bmV3IEFycmF5KGUubGVuZ3RoKTtmb3IobGV0IHM9MDtzPG4ubGVuZ3RoO3MrKyluW3NdPWVbc10qdFtzXTt0aGlzLm91dHB1dFNoYXBlPW4sdGhpcy5yYW5rPW4ubGVuZ3RoO2xldCBhPWh0KHRoaXMucmFuaykscj1NbGUoZSk7dGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICR7YX0gcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgc2V0T3V0cHV0KGdldEEoJHtyfSkpO1xuICAgICAgfVxuICAgIGB9fTtmdW5jdGlvbiBNbGUoZSl7bGV0IHQ9ZS5sZW5ndGg7aWYodD41KXRocm93IEVycm9yKGBUaWxlIGZvciByYW5rICR7dH0gaXMgbm90IHlldCBzdXBwb3J0ZWRgKTtpZih0PT09MSlyZXR1cm5gaW1vZChyZXNSQywgJHtlWzBdfSlgO2xldCBuPVtcInJlc1JDLnhcIixcInJlc1JDLnlcIixcInJlc1JDLnpcIixcInJlc1JDLndcIixcInJlc1JDLnVcIl0sYT1bXTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKylhLnB1c2goYGltb2QoJHtuW3JdfSwgJHtlW3JdfSlgKTtyZXR1cm4gYS5qb2luKCl9ZnVuY3Rpb24gb0YoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse3JlcHM6c309YTtpZihyLmR0eXBlPT09XCJzdHJpbmdcInx8ci5zaGFwZS5sZW5ndGg+NSl7bGV0IG89bi5yZWFkU3luYyhyLmRhdGFJZCksbD1yLmR0eXBlPT09XCJzdHJpbmdcIj9vLm1hcChkPT53LmRlY29kZVN0cmluZyhkKSk6byx1PU9lKHIuc2hhcGUsci5kdHlwZSxsKSxwPXpRKHUscyk7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8ocC5zaGFwZSxwLmR0eXBlLHAudmFsdWVzKX1sZXQgaT1uZXcgUmxlKHIuc2hhcGUscyk7cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKGksW3JdLHIuZHR5cGUpfXZhciBPbGU9e2tlcm5lbE5hbWU6a3MsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6b0Z9LFBsZT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiaW5kaWNlc1wiXSx0aGlzLmN1c3RvbVVuaWZvcm1zPVt7bmFtZTpcIm5cIix0eXBlOlwiaW50XCJ9LHtuYW1lOlwiZmlyc3RQYXNzXCIsdHlwZTpcImludFwifSx7bmFtZTpcIm5lZ2F0aXZlSW5mXCIsdHlwZTpcImZsb2F0XCJ9LHtuYW1lOlwiZGlyXCIsdHlwZTpcImludFwifSx7bmFtZTpcImluY1wiLHR5cGU6XCJpbnRcIn1dLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLnVzZXJDb2RlPWBcbiAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcbiAgICAgICAgIGludCBlbGVtSWR4ID0gY29vcmRzWzFdO1xuXG4gICAgICAgICAvLyBXZSBjb21wYXJlIGVsZW1lbnRzIHBhaXItd2lzZSB3aXRoaW4gYSBncm91cCBvZiBzaXplIDIgKiBpbmMuXG4gICAgICAgICAvLyBUaGUgY29tcGFyaW5nIHJ1bGUgZm9yIGVhY2ggZ3JvdXAgYWx0ZXJuYXRlcyBiZXR3ZWVuIGFzY2VuZGluZ1xuICAgICAgICAgLy8gYW5kIGRlc2NlbmRpbmcuIFdpdGhpbiBlYWNoIGdyb3VwLCB3ZSBjb21wYXJlIGVhY2ggcGFpciBhdFxuICAgICAgICAgLy8gcG9zaXRpb25zIGkgYW5kIGkraW5jLiBUbyBkZWNpZGUgd2hldGhlciBhbiBlbGVtZW50IGF0IHBvc2l0aW9uIGlcbiAgICAgICAgIC8vIGlzIHgwIG9yIHgxLCB3ZSBtb2QgaXQgYnkgMiAqIGluYywgaWYgdGhlIHJlc3VsdCBpcyBzbWFsbGVyIHRoYW5cbiAgICAgICAgIC8vIGluYywgaXQgaXMgaW4gdGhlIGZpcnN0IGhhbGYgb2YgdGhlIGdyb3VwLCB3ZSBkZW5vdGUgaXQgYXMgeDAsXG4gICAgICAgICAvLyBvdGhlcndpc2Ugd2UgZGVub3RlIGl0IGFzIHgxLlxuICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIGFzIHNob3duIGluIHRoZSBCaXRvbmljIHRvcCBLIHBhcGVyIHJlZmVyZW5jZWQgYWJvdmUsXG4gICAgICAgICAvLyBGaWd1cmU1KGEpIHNob3dzIHRoYXQgZWxlbWVudFsxXSBpcyBpbiB0aGVcbiAgICAgICAgIC8vIHNlY29uZCBoYWxmIG9mIHRoZSBncm91cCB3aGVuIGdyb3VwIHNpemUgaXMgMiwgYnV0IGl0IGlzIGluIHRoZVxuICAgICAgICAgLy8gZmlyc3QgaGFsZiBvZiB0aGUgZ3JvdXAgd2hlbiBncm91cCBzaXplIGlzIDQuXG5cbiAgICAgICAgIGJvb2wgaXNGaXJzdEluUGFpciA9IGltb2QoZWxlbUlkeCwgMiAqIGluYykgPCBpbmM7XG4gICAgICAgICBpbnQgaSA9IGlzRmlyc3RJblBhaXIgPyBlbGVtSWR4IDogZWxlbUlkeCAtIGluYztcblxuICAgICAgICAgaW50IGkwID0gZmlyc3RQYXNzID09IDEgPyBpIDogaW50KGdldEluZGljZXMoYmF0Y2gsIGkpKTtcbiAgICAgICAgIGludCBpMSA9IGZpcnN0UGFzcyA9PSAxID8gaSArIGluYyA6IGludChnZXRJbmRpY2VzKGJhdGNoLCBpICsgaW5jKSk7XG4gICAgICAgICBmbG9hdCB4MCA9IGkwIDwgbiA/IGdldFgoYmF0Y2gsIGkwKSA6IG5lZ2F0aXZlSW5mO1xuICAgICAgICAgZmxvYXQgeDEgPSBpMSA8IG4gPyBnZXRYKGJhdGNoLCBpMSkgOiBuZWdhdGl2ZUluZjtcblxuICAgICAgICAgLy8gRGVub3RlcyB3aGljaCBkaXJlY3Rpb24gaW5kaWNlcyBhcmUgaW4gKGFzY2VuZGluZyBvciBkZXNjZW5kaW5nKS5cbiAgICAgICAgIGJvb2wgcmV2ZXJzZSA9IGltb2QoZWxlbUlkeCwgMiAqIGRpcikgPj0gZGlyO1xuICAgICAgICAgYm9vbCBpc0dyZWF0ZXIgPSB4MCA+IHgxIHx8ICh4MCA9PSB4MSAmJiBpMSA+IGkwKTtcbiAgICAgICAgIGlmIChyZXZlcnNlID09IGlzR3JlYXRlcikgeyAvLyBFbGVtZW50cyBpbiBvcHBvc2l0ZSBvcmRlciBvZiBkaXJlY3Rpb25cbiAgICAgICAgICAgaW50IGlUZW1wID0gaTA7XG4gICAgICAgICAgIGkwID0gaTE7XG4gICAgICAgICAgIGkxID0gaVRlbXA7XG4gICAgICAgICB9XG4gICAgICAgICBpZiAoaXNGaXJzdEluUGFpcikge1xuICAgICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KGkwKSk7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KGkxKSk7XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICBgfX0sTGxlPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJpbmRpY2VzXCJdLHRoaXMuY3VzdG9tVW5pZm9ybXM9W3tuYW1lOlwiblwiLHR5cGU6XCJpbnRcIn0se25hbWU6XCJmaXJzdFBhc3NcIix0eXBlOlwiaW50XCJ9LHtuYW1lOlwia1wiLHR5cGU6XCJpbnRcIn1dLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLnVzZXJDb2RlPWBcbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAvLyBUYWtlcyBtYXggb2YgaW5kaWNlcyAoMCwgayksICgxLCBrICsgMSksICgyLCBrICsgMikgLi4uXG4gICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcbiAgICAgICAgIGludCBlbGVtSWR4ID0gY29vcmRzWzFdO1xuXG4gICAgICAgICAvLyBUaGUgb3V0cHV0IHNpemUgaXMgaGFsZiBvZiB0aGUgcHJldmlvdXMgc2l6ZS5cbiAgICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBzZXF1ZW5jZSBpcyB8IHwgfCB8IF8gXyBfIF8gIHwgfCB8IHwgIF8gXyBfIF8gKGs9NCksXG4gICAgICAgICAvLyB3ZSBvbmx5IG5lZWQgdG8gb3V0cHV0IHRoZSBpbmRpY2VzIGF0IHBvc2l0aW9ucyB8LCB0aGUgaW5kaWNlcyBhdFxuICAgICAgICAgLy8gcG9zaXRpb25zIF8gY2FuIGJlIHRocm93biBhd2F5LCBzZWUgRmlndXJlNShiKSBBZnRlciBQaGFzZSAyXG4gICAgICAgICAvLyAoTWVyZ2UgcGhhc2UpIGluIHRoZSBCaXRvbmljIFRvcCBLIHBhcGVyIHJlZmVyZW5jZWQgYWJvdmUuXG4gICAgICAgICAvLyBGb3IgZXhhbXBsZSwgdGhlIHBhcGVyIHNob3dzIHdlIG9ubHkgbmVlZCB0byBvdXRwdXQgdGhlIG9yYW5nZSBiYXJzLlxuICAgICAgICAgLy8gVGhlIG91dHB1dCBzZXF1ZW5jZSBzaG91bGQgbG9vayBsaWtlIHRoaXMgfCB8IHwgfCB8IHwgfCB8LlxuICAgICAgICAgLy8gQmVjYXVzZSB0aGUgc2VxdWVuY2UgaXMgaGFsdmVkLCB0byBtYXAgdGhlIG91dHB1dCBpbmRleCBiYWNrXG4gICAgICAgICAvLyB0byB0aGUgcHJldmlvdXMgc2VxdWVuY2UgdG8gZmluZCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSxcbiAgICAgICAgIC8vIHdlIG5lZWQgdG8gZG91YmxlIHRoZSBpbmRleC4gV2hlbiB3ZSBkb3VibGUgdGhlIGluZGV4LFxuICAgICAgICAgLy8gd2UgYmFzaWNhbGx5IGludGVycG9sYXRlIGEgcG9zaXRpb24sIHNvIDJpIGxvb2tzIGxpa2VcbiAgICAgICAgIC8vIHwgXyB8IF8gfCBfIHwgXyB8IF8gfCBfIHwgXy4gV2UgbW92ZSB0aGUgfCB0byB0aGUgZmlyc3QgayBwb3NpdGlvblxuICAgICAgICAgLy8gb2YgZWFjaCAyayBwb3NpdGlvbnMgYnkgLSBlbGVtSWR4ICUgay4gRS5nLiBmb3Igb3V0cHV0IGF0XG4gICAgICAgICAvLyBpbmRleCA0LDUsNiw3LCB3ZSB3YW50IHRvIGdldCB0aGUgY29ycmVzcG9uZGluZyBlbGVtZW50IGF0XG4gICAgICAgICAvLyBvcmlnaW5hbCBpbmRleCA4LDksMTAsMTEsIGZvciBvdXRwdXQgYXQgaW5kZXggOCw5LDEwLDExLFxuICAgICAgICAgLy8gd2Ugd2FudCB0byBnZXQgdGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBhdCBvcmlnaW5hbCBpbmRleFxuICAgICAgICAgLy8gMTYsMTcsMTgsMTksIHNvIG9uIGFuZCBzbyBmb3J0aC5cblxuICAgICAgICAgaW50IGkgPSBlbGVtSWR4IDwgayA/IGVsZW1JZHggOiAoZWxlbUlkeCAqIDIgLSBpbW9kKGVsZW1JZHgsIGspKTtcbiAgICAgICAgIGludCBpMCA9IGZpcnN0UGFzcyA9PSAxID8gaSA6IGludChnZXRJbmRpY2VzKGJhdGNoLCBpKSk7XG4gICAgICAgICBpbnQgaTEgPSBmaXJzdFBhc3MgPT0gMSA/IGkgKyBrIDogaW50KGdldEluZGljZXMoYmF0Y2gsIGkgKyBrKSk7XG5cbiAgICAgICAgIGZsb2F0IHgwID0gZ2V0WChiYXRjaCwgaTApO1xuICAgICAgICAgZmxvYXQgeDEgPSBpMSA8IG4gPyBnZXRYKGJhdGNoLCBpMSkgOiB4MDtcblxuICAgICAgICAgc2V0T3V0cHV0KHgwID49IHgxID8gZmxvYXQoaTApIDogZmxvYXQoaTEpKTtcbiAgICAgICB9XG4gICAgIGB9fTtmdW5jdGlvbiBxcyhlLHQpe3QhPT1udWxsJiZlLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHQpfWZ1bmN0aW9uIE5TKGUpe2xldCB0PTE7Zm9yKDt0PGU7KXQqPTI7cmV0dXJuIHR9ZnVuY3Rpb24gemxlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtrOnMsc29ydGVkOml9PWEsbz1HKCkuZ2V0TnVtYmVyKFwiVE9QS19MQVNUX0RJTV9DUFVfSEFORE9GRl9TSVpFX1RIUkVTSE9MRFwiKSxsPUcoKS5nZXROdW1iZXIoXCJUT1BLX0tfQ1BVX0hBTkRPRkZfVEhSRVNIT0xEXCIpLHU9ci5zaGFwZSxwPXVbdS5sZW5ndGgtMV07aWYobi5zaG91bGRFeGVjdXRlT25DUFUoW3JdKXx8cDxvfHxzPmwpe2xldCBGPW4ucmVhZFN5bmMoci5kYXRhSWQpLFtELCRdPVdRKEYsdSxyLmR0eXBlLHMsaSk7cmV0dXJuW24ubWFrZVRlbnNvckluZm8oRC5zaGFwZSxELmR0eXBlLEQudmFsdWVzKSxuLm1ha2VUZW5zb3JJbmZvKCQuc2hhcGUsJC5kdHlwZSwkLnZhbHVlcyldfWlmKHM9PT0wKXJldHVybiB1W3UubGVuZ3RoLTFdPTAsW24ubWFrZVRlbnNvckluZm8odSxyLmR0eXBlLFtdKSxuLm1ha2VUZW5zb3JJbmZvKHUsXCJpbnQzMlwiLFtdKV07aWYocD09PTEpcmV0dXJuW3IsJGQoe2F0dHJzOntzaGFwZTp1LGR0eXBlOlwiaW50MzJcIix2YWx1ZTowfSxiYWNrZW5kOm59KV07bGV0IGQ9bi50ZXhEYXRhLmdldChyLmRhdGFJZCksYz1kIT09bnVsbCYmZC5pc1BhY2tlZCxoPWM/bi51bnBhY2tUZW5zb3Iocik6cixtPXcuc2l6ZUZyb21TaGFwZSh1KS9wLGY9Y2Uoe2lucHV0czp7eDpofSxhdHRyczp7c2hhcGU6W20scF19LGJhY2tlbmQ6bn0pO2MmJnFzKG4saCk7bGV0IGc9TlMocyksYj1OUyhwKSx5PW51bGwseD0oKT0+eT09PW51bGw/W2YsZl06W2YseV0sdj0oRixELCQpPT57bGV0IFM9eCgpLE09bmV3IFBsZSgkKSxCPVtbcF0sW3k9PT1udWxsPzE6MF0sW051bWJlci5ORUdBVElWRV9JTkZJTklUWV0sW0ZdLFtEXV0sVT15O3k9bi5ydW5XZWJHTFByb2dyYW0oTSxTLFwiaW50MzJcIixCKSxxcyhuLFUpfTtmb3IobGV0IEY9MTtGPGc7Rio9Mil7bGV0IEQ9RioyO2ZvcihsZXQgJD1GOyQ+PTE7JC89Mil2KEQsJCxbbSxiXSl9Zm9yKGxldCBGPWI7Rj5nO0YvPTIpe2xldCBEPXgoKSwkPW5ldyBMbGUoW20sRi8yXSksUz1bW3BdLFt5PT09bnVsbD8xOjBdLFtnXV0sTT15O3k9bi5ydW5XZWJHTFByb2dyYW0oJCxELFwiaW50MzJcIixTKSxxcyhuLE0pO2xldCBCPWcvMixVPUIqMjtmb3IobGV0IEg9QjtIPj0xO0gvPTIpdihVLEgseS5zaGFwZSl9bGV0IEk9eTt5PWZwKHtpbnB1dHM6e3g6eX0sYmFja2VuZDpuLGF0dHJzOntiZWdpbjowLHNpemU6W20sc119fSkscXMobixJKTtsZXQgTj1RQSh7aW5wdXRzOnt4OmYsaW5kaWNlczp5fSxiYWNrZW5kOm4sYXR0cnM6e2F4aXM6MSxiYXRjaERpbXM6MX19KTtxcyhuLGYpO2xldCBDPXUuc2xpY2UoMCwtMSk7Qy5wdXNoKHMpLEk9eSx5PWNlKHtpbnB1dHM6e3g6eX0sYXR0cnM6e3NoYXBlOkN9LGJhY2tlbmQ6bn0pLHFzKG4sSSk7bGV0IF89TjtyZXR1cm4gTj1jZSh7aW5wdXRzOnt4Ok59LGF0dHJzOntzaGFwZTpDfSxiYWNrZW5kOm59KSxxcyhuLF8pLFtOLHldfXZhciBXbGU9e2tlcm5lbE5hbWU6cXUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6emxlfSxCbGU9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4sYSxyLHMpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJJbWFnZVwiLFwiVHJhbnNmb3Jtc1wiXSx0aGlzLm91dHB1dFNoYXBlPXM7bGV0IGk9bj09PVwibmVhcmVzdFwiPzE6MixvO3N3aXRjaChhKXtjYXNlXCJjb25zdGFudFwiOm89MTticmVhaztjYXNlXCJyZWZsZWN0XCI6bz0yO2JyZWFrO2Nhc2VcIndyYXBcIjpvPTM7YnJlYWs7Y2FzZVwibmVhcmVzdFwiOm89NDticmVhaztkZWZhdWx0Om89MTticmVha310aGlzLnVzZXJDb2RlPWBcbiAgICAgICAgICAgIGZsb2F0IG1hcENvb3JkKGZsb2F0IG91dENvb3JkLCBmbG9hdCBsZW4pIHtcbiAgICAgICAgICAgICAgZmxvYXQgaW5Db29yZCA9IG91dENvb3JkO1xuICAgICAgICAgICAgICBpZigke299ID09IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5Db29yZCA8IDAuMCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGxlbiA8PSAxLjApIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Db29yZCA9IDAuMDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHN6MiA9IDIuMCAqIGxlbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluQ29vcmQgPCBzejIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpbkNvb3JkID0gc3oyICogZmxvYXQoaW50KGZsb2F0KC1pbkNvb3JkIC8gc3oyKSkpICtcbiAgICAgICAgICAgICAgICAgICAgICBpbkNvb3JkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluQ29vcmQgPSBpbkNvb3JkIDwgLWxlbiA/IGluQ29vcmQgKyBzejIgOiAtaW5Db29yZCAtIDEuMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluQ29vcmQgPiBsZW4gLSAxLjApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gMS4wKSB7XG4gICAgICAgICAgICAgICAgICAgIGluQ29vcmQgPSAwLjA7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmbG9hdCBzejIgPSAyLjAgKiBsZW47XG4gICAgICAgICAgICAgICAgICAgIGluQ29vcmQgLT0gc3oyICogZmxvYXQoaW50KGZsb2F0KGluQ29vcmQgLyBzejIpKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbkNvb3JkID49IGxlbikge1xuICAgICAgICAgICAgICAgICAgICAgIGluQ29vcmQgPSBzejIgLSBpbkNvb3JkIC0gMS4wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGFtcChpbkNvb3JkLCAwLjAsIGxlbiAtIDEuMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHtvfSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluQ29vcmQgPCAwLjApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gMS4wKSB7XG4gICAgICAgICAgICAgICAgICAgIGluQ29vcmQgPSAwLjA7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmbG9hdCBzeiA9IGxlbiAtIDEuMDtcbiAgICAgICAgICAgICAgICAgICAgaW5Db29yZCArPSBsZW4gKiAoZmxvYXQoaW50KGZsb2F0KC1pbkNvb3JkIC8gc3opKSkgKyAxLjApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5Db29yZCA+IGxlbiAtIDEuMCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGxlbiA8PSAxLjApIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Db29yZCA9IDAuMDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHN6ID0gbGVuIC0gMS4wO1xuICAgICAgICAgICAgICAgICAgICBpbkNvb3JkIC09IGxlbiAqIGZsb2F0KGludChmbG9hdChpbkNvb3JkIC8gc3opKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGFtcChpbkNvb3JkLCAwLjAsIGxlbiAtIDEuMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHtvfSA9PSA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsYW1wKG91dENvb3JkLCAwLjAsIGxlbiAtIDEuMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dENvb3JkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZsb2F0IHJlYWRXaXRoRmlsbFZhbHVlKGludCBiYXRjaCwgaW50IGNvb3JkWSwgaW50IGNvb3JkWCxcbiAgICAgICAgICAgICAgaW50IGNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgZmxvYXQgb3V0cHV0VmFsdWU7XG4gICAgICAgICAgICAgIGlmICgwIDw9IGNvb3JkWSAmJiBjb29yZFkgPCAke2V9ICYmIDAgPD0gY29vcmRYICYmIGNvb3JkWCA8ICR7dH0pIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFZhbHVlID0gZ2V0SW1hZ2UoYmF0Y2gsIGNvb3JkWSwgY29vcmRYLCBjaGFubmVsKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRWYWx1ZSA9IGZsb2F0KCR7cn0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBvdXRwdXRWYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgICAgICAgZmxvYXQgb3V0cHV0VmFsdWU7XG4gICAgICAgICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcbiAgICAgICAgICAgICAgaW50IHggPSBjb29yZHNbMl07XG4gICAgICAgICAgICAgIGludCB5ID0gY29vcmRzWzFdO1xuICAgICAgICAgICAgICBpbnQgY2hhbm5lbCA9IGNvb3Jkc1szXTtcbiAgICAgICAgICAgICAgZmxvYXQgeGYgPSBmbG9hdCh4KTtcbiAgICAgICAgICAgICAgZmxvYXQgeWYgPSBmbG9hdCh5KTtcbiAgICAgICAgICAgICAgZmxvYXQgYTEgPSBnZXRUcmFuc2Zvcm1zKGJhdGNoLCAwKTtcbiAgICAgICAgICAgICAgZmxvYXQgYTIgPSBnZXRUcmFuc2Zvcm1zKGJhdGNoLCAxKTtcbiAgICAgICAgICAgICAgZmxvYXQgYTMgPSBnZXRUcmFuc2Zvcm1zKGJhdGNoLCAyKTtcbiAgICAgICAgICAgICAgZmxvYXQgYjEgPSBnZXRUcmFuc2Zvcm1zKGJhdGNoLCAzKTtcbiAgICAgICAgICAgICAgZmxvYXQgYjIgPSBnZXRUcmFuc2Zvcm1zKGJhdGNoLCA0KTtcbiAgICAgICAgICAgICAgZmxvYXQgYjMgPSBnZXRUcmFuc2Zvcm1zKGJhdGNoLCA1KTtcbiAgICAgICAgICAgICAgZmxvYXQgYzEgPSBnZXRUcmFuc2Zvcm1zKGJhdGNoLCA2KTtcbiAgICAgICAgICAgICAgZmxvYXQgYzIgPSBnZXRUcmFuc2Zvcm1zKGJhdGNoLCA3KTtcbiAgICAgICAgICAgICAgZmxvYXQgcHJvamVjdGlvbiA9IGMxICogeGYgKyBjMiAqIHlmICsgMS4wO1xuICAgICAgICAgICAgICBpZiAocHJvamVjdGlvbiA9PSAwLjApIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRWYWx1ZSA9IGZsb2F0KCR7cn0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZsb2F0IGluWCA9IChhMSAqIHhmICsgYTIgKiB5ZiArIGEzKSAvIHByb2plY3Rpb247XG4gICAgICAgICAgICAgICAgZmxvYXQgaW5ZID0gKGIxICogeGYgKyBiMiAqIHlmICsgYjMpIC8gcHJvamVjdGlvbjtcbiAgICAgICAgICAgICAgICBmbG9hdCBtYXBYID0gbWFwQ29vcmQoaW5YLCBmbG9hdCgke3R9KSk7XG4gICAgICAgICAgICAgICAgZmxvYXQgbWFwWSA9IG1hcENvb3JkKGluWSwgZmxvYXQoJHtlfSkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCR7aX0gPT0gMSkge1xuICAgICAgICAgICAgICAgICAgaW50IGNvb3JkWSA9IGludChyb3VuZChtYXBZKSk7XG4gICAgICAgICAgICAgICAgICBpbnQgY29vcmRYID0gaW50KHJvdW5kKG1hcFgpKTtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFZhbHVlID0gcmVhZFdpdGhGaWxsVmFsdWUoYmF0Y2gsIGNvb3JkWSwgY29vcmRYLFxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZmxvYXQgeUZsb29yID0gZmxvb3IobWFwWSk7XG4gICAgICAgICAgICAgICAgICBmbG9hdCB4Rmxvb3IgPSBmbG9vcihtYXBYKTtcbiAgICAgICAgICAgICAgICAgIGZsb2F0IHlDZWlsID0geUZsb29yICsgMS4wO1xuICAgICAgICAgICAgICAgICAgZmxvYXQgeENlaWwgPSB4Rmxvb3IgKyAxLjA7XG4gICAgICAgICAgICAgICAgICBmbG9hdCB2YWx1ZVlGbG9vciA9ICh4Q2VpbCAtIG1hcFgpICpcbiAgICAgICAgICAgICAgICAgIHJlYWRXaXRoRmlsbFZhbHVlKGJhdGNoLCBpbnQoeUZsb29yKSwgaW50KHhGbG9vciksIGNoYW5uZWwpICtcbiAgICAgICAgICAgICAgICAgIChtYXBYIC0geEZsb29yKSAqXG4gICAgICAgICAgICAgICAgICByZWFkV2l0aEZpbGxWYWx1ZShiYXRjaCwgaW50KHlGbG9vciksIGludCh4Q2VpbCksIGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgICAgZmxvYXQgdmFsdWVZQ2VpbCA9ICh4Q2VpbCAtIG1hcFgpICpcbiAgICAgICAgICAgICAgICAgIHJlYWRXaXRoRmlsbFZhbHVlKGJhdGNoLCBpbnQoeUNlaWwpLCBpbnQoeEZsb29yKSwgY2hhbm5lbCkgK1xuICAgICAgICAgICAgICAgICAgKG1hcFggLSB4Rmxvb3IpICpcbiAgICAgICAgICAgICAgICAgIHJlYWRXaXRoRmlsbFZhbHVlKGJhdGNoLCBpbnQoeUNlaWwpLCBpbnQoeENlaWwpLCBjaGFubmVsKTtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFZhbHVlID0gKHlDZWlsIC0gbWFwWSkgKiB2YWx1ZVlGbG9vciArXG4gICAgICAgICAgICAgICAgICAobWFwWSAtIHlGbG9vcikgKiB2YWx1ZVlDZWlsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzZXRPdXRwdXQob3V0cHV0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICBgfX07ZnVuY3Rpb24gVmxlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7aW1hZ2U6cix0cmFuc2Zvcm1zOnN9PXQse2ludGVycG9sYXRpb246aSxmaWxsTW9kZTpvLGZpbGxWYWx1ZTpsLG91dHB1dFNoYXBlOnV9PWEsW3AsZCxjLGhdPXIuc2hhcGUsW20sZl09dSE9bnVsbD91OltkLGNdLGc9W3AsbSxmLGhdLGI9bmV3IEJsZShkLGMsaSxvLGwsZyk7cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKGIsW3Isc10sXCJmbG9hdDMyXCIpfXZhciBVbGU9e2tlcm5lbE5hbWU6S3UsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6VmxlfTtmdW5jdGlvbiBHbGUoZSl7bGV0e2lucHV0czp0LGF0dHJzOm4sYmFja2VuZDphfT1lLHtheGlzOnJ9PW4se3g6c309dDtscChzLFwidW5pcXVlXCIpLGNvbnNvbGUud2FybihcIldBUk5JTkc6IFwiLFwiVUkgbWlnaHQgYmUgbG9ja2VkIHRlbXBvcmFyaWx5IGFzIGRhdGEgaXMgYmVpbmcgZG93bmxvYWRlZFwiKTtsZXQgaT1hLnJlYWRTeW5jKHMuZGF0YUlkKSx7b3V0cHV0VmFsdWVzOm8sb3V0cHV0U2hhcGU6bCxpbmRpY2VzOnV9PUJRKGkscixzLnNoYXBlLHMuZHR5cGUpO3JldHVyblthLm1ha2VUZW5zb3JJbmZvKGwscy5kdHlwZSxvKSxhLm1ha2VUZW5zb3JJbmZvKFt1Lmxlbmd0aF0sXCJpbnQzMlwiLHUpXX12YXIgSGxlPXtrZXJuZWxOYW1lOkpjLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkdsZX07ZnVuY3Rpb24gamxlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7dmFsdWU6cn09dCx7YXhpczpzfT1hO3M8MCYmKHMrPXIuc2hhcGUubGVuZ3RoKTtsZXQgaT1yLG89aS5zaGFwZS5sZW5ndGgsbD1yLnNoYXBlW3NdLHU9bmV3IEFycmF5KG8tMSkscD0wO2ZvcihsZXQgZj0wO2Y8bztmKyspZiE9PXMmJih1W3ArK109aS5zaGFwZVtmXSk7bGV0IGQ9W10sYz1uZXcgQXJyYXkobykuZmlsbCgwKSxoPWkuc2hhcGUuc2xpY2UoKTtoW3NdPTE7bGV0IG09bmV3IEFycmF5KGwpO2ZvcihsZXQgZj0wO2Y8bS5sZW5ndGg7ZisrKXtjW3NdPWY7bGV0IGc9ZnAoe2lucHV0czp7eDppfSxiYWNrZW5kOm4sYXR0cnM6e2JlZ2luOmMsc2l6ZTpofX0pLGI9Y2Uoe2lucHV0czp7eDpnfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOnV9fSk7bVtmXT1iLGQucHVzaChnKX1yZXR1cm4gZC5mb3JFYWNoKGY9Pm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZikpLG19dmFyIHFsZT17a2VybmVsTmFtZTpYdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpqbGV9LEtsZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJzZWdtZW50SWRzXCJdO2xldCBuPWUud2luZG93U2l6ZSxhPWUuYmF0Y2hTaXplLHI9ZS5pblNpemUscz1lLm51bVNlZ21lbnRzLGk9cypNYXRoLmNlaWwoci9uKTt0aGlzLm91dHB1dFNoYXBlPVthLGldO2xldCBvPVwiMC4wXCIsbD1cInN1bVZhbHVlXCIsdT1NYXRoLmZsb29yKG4vNCkqNCxwPW4lNCxkPWBcbiAgICAgICAgc3VtVmFsdWUgKz0gZG90KHZhbHVlcywgc2VnRmlsdGVyKTtcbiAgICBgLGM9XCJcIjtyJW4+MCYmKGM9YFxuICAgICAgICBpZiAoaW5JZHggPCAwIHx8IGluSWR4ID49ICR7cn0pIHtcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgYCk7bGV0IGg9XCJcIjtyJW4+MCYmKGg9YFxuICAgICAgICBpZiAoaW5JZHggPCAwIHx8IGluSWR4ID49ICR7cn0pIHtcbiAgICAgICAgICByZXR1cm4gLTEuMDtcbiAgICAgICAgfVxuICAgICAgYCksdGhpcy51c2VyQ29kZT1gXG4gICAgICBjb25zdCBmbG9hdCBpbml0aWFsaXphdGlvblZhbHVlID0gJHtvfTtcblxuICAgICAgZmxvYXQgZ2V0VmFsdWUoaW50IGJhdGNoLCBpbnQgaW5JZHgpIHtcbiAgICAgICAgJHtjfVxuICAgICAgICByZXR1cm4gZ2V0WChiYXRjaCwgaW5JZHgpO1xuICAgICAgfVxuXG4gICAgICBmbG9hdCBnZXRTZWdtZW50SWRBdEluZGV4KGludCBpbklkeCkge1xuICAgICAgICAke2h9XG4gICAgICAgIHJldHVybiBnZXRTZWdtZW50SWRzKGluSWR4KTtcbiAgICAgIH1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xuICAgICAgICBpbnQgb3V0SWR4ID0gY29vcmRzWzFdO1xuICAgICAgICBpbnQgaW5PZmZzZXQgPSBpbnQoZmxvb3IoZmxvYXQob3V0SWR4KSAvIGZsb2F0KFxuICAgICAgICAgICR7c30pKSAqIGZsb2F0KCR7bn0pKTtcbiAgICAgICAgaW50IGN1cnJlbnRTZWcgPSBpbnQobW9kKGZsb2F0KG91dElkeCksIGZsb2F0KCR7c30pKSk7XG5cbiAgICAgICAgZmxvYXQgc3VtVmFsdWUgPSAwLjA7XG5cbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke3V9OyBpICs9IDQpIHtcbiAgICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIGk7XG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMiksXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAzKVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICB2ZWM0IHNlZ0ZpbHRlciA9IHZlYzQoXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMSkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMikpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMykpID09IGN1cnJlbnRTZWcgPyAxIDogMFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAke2R9XG4gICAgICAgIH1cblxuICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArICR7dX07XG4gICAgICAgIGlmICgke3A9PT0xfSkge1xuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaW50IGluSWR4U2VnID0gaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHgpKTtcblxuICAgICAgICAgIHZlYzQgc2VnRmlsdGVyID0gdmVjNChcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4KSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwXG4gICAgICAgICAgKTtcblxuICAgICAgICAgICR7ZH1cbiAgICAgICAgfSBlbHNlIGlmICgke3A9PT0yfSkge1xuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHZlYzQgc2VnRmlsdGVyID0gdmVjNChcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4KSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAxKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAwXG4gICAgICAgICAgKTtcblxuICAgICAgICAgICR7ZH1cbiAgICAgICAgfSBlbHNlIGlmICgke3A9PT0zfSkge1xuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICB2ZWM0IHNlZ0ZpbHRlciA9IHZlYzQoXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMSkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMikpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcbiAgICAgICAgICAgIDBcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgJHtkfVxuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dCgke2x9KTtcbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24gWGxlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyLHNlZ21lbnRJZHM6c309dCx7bnVtU2VnbWVudHM6aX09YSxvPXIuc2hhcGUubGVuZ3RoLGw9W10sdT0wLHA9VC5nZXRBeGVzUGVybXV0YXRpb24oW3VdLG8pLGQ9cjtwIT1udWxsJiYoZD1Tbih7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bixhdHRyczp7cGVybTpwfX0pLGwucHVzaChkKSx1PVQuZ2V0SW5uZXJNb3N0QXhlcygxLG8pWzBdKTtsZXQgYz1ULnNlZ21lbnRfdXRpbC5jb21wdXRlT3V0U2hhcGUoZC5zaGFwZSx1LGkpLGg9dy5zaXplRnJvbVNoYXBlKFtkLnNoYXBlW3VdXSksbT1jZSh7aW5wdXRzOnt4OmR9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6Wy0xLGhdfX0pO2wucHVzaChtKTtsZXQgZj1NbShyLmR0eXBlKSxnPSh2LEksTixDLF8pPT57bGV0IEY9di5zaGFwZVswXSxEPXYuc2hhcGVbMV0sJD1ULnNlZ21lbnRfdXRpbC5zZWdPcENvbXB1dGVPcHRpbWFsV2luZG93U2l6ZShELF8pLFM9e3dpbmRvd1NpemU6JCxpblNpemU6RCxiYXRjaFNpemU6RixudW1TZWdtZW50czpffSxNPW5ldyBLbGUoUyxJKSxCPW4uY29tcGlsZUFuZFJ1bihNLFt2LE5dLEMpO2lmKGwucHVzaChCKSxCLnNoYXBlWzFdPT09XylyZXR1cm4gQjtsZXQgVT1pRih7YmFja2VuZDpuLGF0dHJzOntzdGFydDowLHN0b3A6XyxzdGVwOjEsZHR5cGU6XCJmbG9hdDMyXCJ9fSksSD1vRih7aW5wdXRzOnt4OlV9LGJhY2tlbmQ6bixhdHRyczp7cmVwczpbRC8kXX19KTtyZXR1cm4gbC5wdXNoKFUpLGwucHVzaChIKSxnKEIsSSxILEMsXyl9LGI9ZyhtLFwidW5zb3J0ZWRTZWdtZW50U3VtXCIscyxmLGkpLHk9Y2Uoe2lucHV0czp7eDpifSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOmN9fSkseD15O2lmKHAhPW51bGwpe2wucHVzaCh5KTtsZXQgdj1ULmdldFVuZG9BeGVzUGVybXV0YXRpb24ocCk7eD1Tbih7aW5wdXRzOnt4fSxiYWNrZW5kOm4sYXR0cnM6e3Blcm06dn19KX1yZXR1cm4gbC5mb3JFYWNoKHY9Pm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odikpLHh9dmFyIFlsZT17a2VybmVsTmFtZTpRYyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpYbGV9LFpsZT1bUmVlLE9lZSx6ZWUsVmVlLEdlZSxxZWUsWGVlLFplZSx0dGUsYXRlLGl0ZSx1dGUsZHRlLGd0ZSx4dGUsd3RlLEl0ZSxDdGUsX3RlLEZ0ZSxNdGUsVnRlLEd0ZSxLdGUsWXRlLG5uZSxybmUsbG5lLGJlZSxjbmUsZ25lLHZuZSxUbmUsX25lLEZuZSxEbmUsTW5lLHpuZSxWbmUsSG5lLHFuZSxYbmUsWm5lLGVhZSxuYWUsaWFlLGxhZSxjYWUsbWFlLGdhZSx2YWUsU2FlLEVhZSxGYWUsUmFlLE1hZSxQYWUsemFlLEJhZSxVYWUsSGFlLFhhZSxKYWUsdHJlLGFyZSxpcmUsdXJlLGhyZSxicmUsZ2VlLHhyZSxtbmUsa3JlLE5yZSxFcmUseGVlLCRyZSxPcmUsTHJlLFZyZSxIcmUsWHJlLEpyZSxuc2UsaXNlLHVzZSxjc2UsZnNlLGJzZSx4c2UsSXNlLE5zZSxDc2UsX3NlLEZzZSxNc2UsenNlLFVzZSxac2Usa2VlLHRpZSxyaWUsb2llLHBpZSxKdGUsaGllLGZpZSxiaWUsdmllLFNpZSx3ZWUsVGllLEVpZSxBaWUsJGllLERpZSxRdGUscXNlLE9pZSxXaWUsR2llLFNlZSxLaWUsWmllLHRvZSxyb2UsbG9lLHBvZSxob2UsZ29lLHhvZSxrb2UsTm9lLEVvZSwkb2UsTW9lLHpvZSxWb2UsV3RlLFhzZSxIb2UscW9lLFhvZSxab2UsUW9lLHRsZSxhbGUsc2xlLG9sZSxwbGUsZGxlLG1sZSxnbGUseGxlLHdsZSxJbGUsTmxlLEtzZSxGZWUsRWxlLEZsZSxEbGUsT2xlLFdsZSxVbGUsJGVlLEhsZSxxbGUsWWxlLG1pZV07Zm9yKGxldCBlIG9mIFpsZSllZChlKTt2YXIgUWU7KGZ1bmN0aW9uKGUpe2VbZS5mbG9hdDMyPTBdPVwiZmxvYXQzMlwiLGVbZS5pbnQzMj0xXT1cImludDMyXCIsZVtlLmJvb2w9Ml09XCJib29sXCIsZVtlLnN0cmluZz0zXT1cInN0cmluZ1wiLGVbZS5jb21wbGV4NjQ9NF09XCJjb21wbGV4NjRcIn0pKFFlfHwoUWU9e30pKTt2YXIgQWM7KGZ1bmN0aW9uKGUpe2VbZS5saW5lYXI9MF09XCJsaW5lYXJcIixlW2UucmVsdT0xXT1cInJlbHVcIixlW2UucmVsdTY9Ml09XCJyZWx1NlwiLGVbZS5wcmVsdT0zXT1cInByZWx1XCIsZVtlLmxlYWt5cmVsdT00XT1cImxlYWt5cmVsdVwiLGVbZS5zaWdtb2lkPTVdPVwic2lnbW9pZFwiLGVbZS5lbHU9Nl09XCJlbHVcIn0pKEFjfHwoQWM9e30pKTt2YXIgbEY7ZnVuY3Rpb24gSmxlKGUpe2xGPWUud2FzbS5jd3JhcChpaSxudWxsLFtcIm51bWJlclwiLFwiYXJyYXlcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIFFsZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2E6cixiOnMsYmlhczppLHByZWx1QWN0aXZhdGlvbldlaWdodHM6b309dDtpZihyLmR0eXBlIT09XCJmbG9hdDMyXCJ8fHMuZHR5cGUhPT1cImZsb2F0MzJcIil0aHJvdyBuZXcgRXJyb3IoXCJfRnVzZWRNYXRNdWwgZm9yIG5vbiBub24tZmxvYXQzMiB0ZW5zb3JzIG5vdCB5ZXQgc3VwcG9ydGVkLlwiKTtsZXR7dHJhbnNwb3NlQTpsLHRyYW5zcG9zZUI6dSxhY3RpdmF0aW9uOnAsbGVha3lyZWx1QWxwaGE6ZH09YSxjPW4uZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsaD1uLmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkLG09MDtpZihpIT1udWxsKXtsZXQgXz1uLmRhdGFJZE1hcC5nZXQoaS5kYXRhSWQpO2lmKF8uc2hhcGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoYF9GdXNlZE1hdE11bCBvbmx5IHN1cHBvcnRzIHJhbmstMSBiaWFzIGJ1dCBnb3QgcmFuayAke18uc2hhcGUubGVuZ3RofS5gKTttPV8uaWR9bGV0IGY9bz09bnVsbD8wOm4uZGF0YUlkTWFwLmdldChvLmRhdGFJZCkuaWQsZz1BY1twXTtpZihnPT1udWxsKXRocm93IG5ldyBFcnJvcihgJHtwfSBhY3RpdmF0aW9uIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBGdXNlZENvbnYyRCBpbiB0aGUgd2FzbSBiYWNrZW5kLmApO2xldCBiPWw/ci5zaGFwZVsyXTpyLnNoYXBlWzFdLHk9dT9zLnNoYXBlWzFdOnMuc2hhcGVbMl0seD1KdS5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShyLnNoYXBlLnNsaWNlKDAsLTIpLHMuc2hhcGUuc2xpY2UoMCwtMikpLHY9bi5tYWtlT3V0cHV0KFsuLi54LGIseV0sci5kdHlwZSksST1uLmRhdGFJZE1hcC5nZXQodi5kYXRhSWQpLmlkLE49bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkoci5zaGFwZSkuYnVmZmVyKSxDPW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KHMuc2hhcGUpLmJ1ZmZlcik7cmV0dXJuIGxGKGMsTixyLnNoYXBlLmxlbmd0aCxoLEMscy5zaGFwZS5sZW5ndGgsbCx1LGcsbSxmLGR8fDAsSSksdn12YXIgZXVlPXtrZXJuZWxOYW1lOmlpLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpKbGUsa2VybmVsRnVuYzpRbGV9O2Z1bmN0aW9uIFhlKGUsdCl7bGV0IG47ZnVuY3Rpb24gYShzKXtuPXMud2FzbS5jd3JhcChlLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gcihzKXtsZXR7YmFja2VuZDppLGlucHV0czp7eDpvfX09cyxsPWkuZGF0YUlkTWFwLmdldChvLmRhdGFJZCkuaWQsdT1pLm1ha2VPdXRwdXQoby5zaGFwZSx0fHxvLmR0eXBlKSxwPWkuZGF0YUlkTWFwLmdldCh1LmRhdGFJZCkuaWQ7cmV0dXJuIHcuc2l6ZUZyb21TaGFwZSh1LnNoYXBlKT09PTB8fG4obCxRZVtvLmR0eXBlXSxwKSx1fXJldHVybntrZXJuZWxOYW1lOmUsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOmEsa2VybmVsRnVuYzpyfX12YXIgdHVlPVhlKFlsKSxudWU9WGUoTmkpLGF1ZT1YZShUaSk7ZnVuY3Rpb24gVXQoZSx0LG4pe2xldCBhO2Z1bmN0aW9uIHIoaSl7YT1pLndhc20uY3dyYXAoZSxudWxsLFtcIm51bWJlclwiLFwiYXJyYXlcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gcyhpKXtsZXR7YmFja2VuZDpvLGlucHV0czpsfT1pLHthOnUsYjpwfT1sLGQ9by5kYXRhSWRNYXAuZ2V0KHUuZGF0YUlkKS5pZCxjPW8uZGF0YUlkTWFwLmdldChwLmRhdGFJZCkuaWQsaD1uIT1udWxsP246dS5kdHlwZSxtPVQuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUodS5zaGFwZSxwLnNoYXBlKSxmPW8ubWFrZU91dHB1dChtLGgpO2lmKHcuc2l6ZUZyb21TaGFwZShtKT09PTApcmV0dXJuIGY7bGV0IGc9bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkodS5zaGFwZSkuYnVmZmVyKSxiPW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KHAuc2hhcGUpLmJ1ZmZlcikseT1vLmRhdGFJZE1hcC5nZXQoZi5kYXRhSWQpLmlkO3JldHVybiBhKGQsZyx1LnNoYXBlLmxlbmd0aCxjLGIscC5zaGFwZS5sZW5ndGgsUWVbdS5kdHlwZV0seSksZn1yZXR1cm57a2VybmVsTmFtZTplLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpyLGtlcm5lbEZ1bmM6c319dmFyIHJ1ZT0hMCxzdWU9VXQodnMscnVlKSx1RjtmdW5jdGlvbiBpdWUoZSl7dUY9ZS53YXNtLmN3cmFwKENpLG51bGwsW1wiYXJyYXlcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIG91ZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLGE9bi5tYWtlT3V0cHV0KHRbMF0uc2hhcGUsdFswXS5kdHlwZSk7aWYody5zaXplRnJvbVNoYXBlKGEuc2hhcGUpPT09MClyZXR1cm4gYTtsZXQgcj10Lm1hcChvPT5uLmRhdGFJZE1hcC5nZXQoby5kYXRhSWQpLmlkKSxzPW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KHIpLmJ1ZmZlciksaT1uLmRhdGFJZE1hcC5nZXQoYS5kYXRhSWQpLmlkO3JldHVybiB1RihzLHIubGVuZ3RoLFFlW2EuZHR5cGVdLGkpLGF9dmFyIGx1ZT17a2VybmVsTmFtZTpDaSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6aXVlLGtlcm5lbEZ1bmM6b3VlfTtmdW5jdGlvbiBHZihlKXtsZXR7aW5wdXRzOnt4OnR9LGJhY2tlbmQ6bn09ZTtpZih0LmR0eXBlPT09XCJzdHJpbmdcIilyZXR1cm4gYm4obi5yZWFkU3luYyh0LmRhdGFJZCksdC5zaGFwZSx0LmR0eXBlKTtsZXQgYT1uLm1ha2VPdXRwdXQodC5zaGFwZSx0LmR0eXBlKSxyPW4udHlwZWRBcnJheUZyb21IZWFwKHQpO3JldHVybiBuLnR5cGVkQXJyYXlGcm9tSGVhcChhKS5zZXQociksYX12YXIgdXVlPXtrZXJuZWxOYW1lOmVvLGJhY2tlbmROYW1lOlwid2FzbVwiLGtlcm5lbEZ1bmM6R2Z9LHBGO2Z1bmN0aW9uIHB1ZShlKXtwRj1lLndhc20uY3dyYXAoQ3IsbnVsbCxbXCJudW1iZXJcIixcImFycmF5XCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJhcnJheVwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiB5cyhlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUsW3Isc109ZHVlKHQueC5zaGFwZSxhLnBlcm0pLGk9ITA7Zm9yKGxldCBtPTA7bTxzLmxlbmd0aDttKyspc1ttXSE9PW0mJihpPSExKTtsZXQgbz1jdWUodC54LnNoYXBlLGEucGVybSksbD17ZGF0YUlkOnQueC5kYXRhSWQsc2hhcGU6cixkdHlwZTp0LnguZHR5cGV9O2lmKGkpe2xldCBtPUdmKHtpbnB1dHM6dCxiYWNrZW5kOm59KTtyZXR1cm4gbS5zaGFwZT1vLG19bGV0IHU9bi5tYWtlT3V0cHV0KG8sbC5kdHlwZSkscD1uLmRhdGFJZE1hcC5nZXQobC5kYXRhSWQpLmlkLGQ9bi5kYXRhSWRNYXAuZ2V0KHUuZGF0YUlkKS5pZCxjPW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KHMpLmJ1ZmZlciksaD1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheShsLnNoYXBlKS5idWZmZXIpO3JldHVybiBwRihwLGgsbC5zaGFwZS5sZW5ndGgsUWVbbC5kdHlwZV0sZCxjLHMubGVuZ3RoKSx1fWZ1bmN0aW9uIGN1ZShlLHQpe2xldCBuPW5ldyBBcnJheShlLmxlbmd0aCk7Zm9yKGxldCBhPTA7YTxuLmxlbmd0aDthKyspblthXT1lW3RbYV1dO3JldHVybiBufWZ1bmN0aW9uIGR1ZShlLHQpe2xldCBuPVtdLGE9W107Zm9yKGxldCByPTA7cjxlLmxlbmd0aDsrK3IpZVtyXSE9PTEmJm4ucHVzaChlW3JdKSxlW3Rbcl1dIT09MSYmYS5wdXNoKHRbcl0pO2ZvcihsZXQgcj0wO3I8YS5sZW5ndGg7KytyKXtsZXQgcz0tMTtmb3IobGV0IGk9MDtpPGEubGVuZ3RoOysraSlhW2ldPj1yJiYocz09PS0xfHxhW3NdPmFbaV0pJiYocz1pKTthW3NdPXJ9cmV0dXJuW24sYV19dmFyIGh1ZT17a2VybmVsTmFtZTpDcixiYWNrZW5kTmFtZTpcIndhc21cIixrZXJuZWxGdW5jOnlzLHNldHVwRnVuYzpwdWV9O2Z1bmN0aW9uIERzKGUsdCxuKXtsZXQgYT1lLnNoYXBlLHI9ZS5zaGFwZS5sZW5ndGgscz13LnBhcnNlQXhpc1BhcmFtKHQsYSksaT1zLG89VC5nZXRBeGVzUGVybXV0YXRpb24oaSxyKSxsPW51bGwsdT0hMTtpZihvIT1udWxsKXtsZXQgcD1uZXcgQXJyYXkocik7Zm9yKGxldCBjPTA7YzxwLmxlbmd0aDtjKyspcFtjXT1hW29bY11dO2k9VC5nZXRJbm5lck1vc3RBeGVzKGkubGVuZ3RoLHIpLGw9eXMoe2lucHV0czp7eDplfSxhdHRyczp7cGVybTpvfSxiYWNrZW5kOm59KTtsZXQgZD1uLmRhdGFJZE1hcC5nZXQoZS5kYXRhSWQpLmlkO24uZGF0YUlkTWFwLmdldChsLmRhdGFJZCkuaWQhPT1kJiYodT0hMCl9cmV0dXJue3RyYW5zcG9zZWQ6bCxvcmlnaW5hbEF4ZXM6cyxheGVzOmksaW5wdXRXYXNUcmFuc3Bvc2VkOnV9fXZhciBjRjtmdW5jdGlvbiBtdWUoZSl7Y0Y9ZS53YXNtLmN3cmFwKFpsLG51bGwsW1wibnVtYmVyLCBudW1iZXIsIG51bWJlclwiXSl9ZnVuY3Rpb24gZnVlKGUpe2xldHtiYWNrZW5kOnQsaW5wdXRzOm4sYXR0cnM6YX09ZSx7YXhpczpyLGtlZXBEaW1zOnN9PWEse3g6aX09bixvPXQuZGF0YUlkTWFwLmdldChpLmRhdGFJZCkuaWQsbD1pLHt0cmFuc3Bvc2VkOnUsYXhlczpwLG9yaWdpbmFsQXhlczpkLGlucHV0V2FzVHJhbnNwb3NlZDpjfT1EcyhpLHIsdCk7aWYoYyl7bGV0IHk9dC5kYXRhSWRNYXAuZ2V0KHUuZGF0YUlkKS5pZDtsPXUsbz15fWxldCBoPWwuc2hhcGUubGVuZ3RoO1QuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJhbGxcIixwLGgpO2xldFttLGZdPVQuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhsLnNoYXBlLHApLGc9dy5zaXplRnJvbVNoYXBlKGYpLGI9dC5tYWtlT3V0cHV0KG0saS5kdHlwZSk7aWYody5zaXplRnJvbVNoYXBlKGwuc2hhcGUpIT09MCl7bGV0IHk9dC5kYXRhSWRNYXAuZ2V0KGIuZGF0YUlkKS5pZDtjRihvLGcseSl9aWYoYyYmdC5kaXNwb3NlRGF0YSh1LmRhdGFJZCkscyl7bGV0IHk9VC5leHBhbmRTaGFwZVRvS2VlcERpbShiLnNoYXBlLGQpO2Iuc2hhcGU9eX1yZXR1cm4gYn12YXIgZ3VlPXtrZXJuZWxOYW1lOlpsLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzptdWUsa2VybmVsRnVuYzpmdWV9LGRGO2Z1bmN0aW9uIGJ1ZShlKXtkRj1lLndhc20uY3dyYXAoSmwsbnVsbCxbXCJudW1iZXIsIG51bWJlciwgbnVtYmVyXCJdKX1mdW5jdGlvbiB5dWUoZSl7bGV0e2JhY2tlbmQ6dCxpbnB1dHM6bixhdHRyczphfT1lLHtheGlzOnIsa2VlcERpbXM6c309YSx7eDppfT1uLG89dC5kYXRhSWRNYXAuZ2V0KGkuZGF0YUlkKS5pZCxsPWkse3RyYW5zcG9zZWQ6dSxheGVzOnAsb3JpZ2luYWxBeGVzOmQsaW5wdXRXYXNUcmFuc3Bvc2VkOmN9PURzKGkscix0KTtpZihjKXtsZXQgeT10LmRhdGFJZE1hcC5nZXQodS5kYXRhSWQpLmlkO2w9dSxvPXl9bGV0IGg9bC5zaGFwZS5sZW5ndGg7VC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcImFueVwiLHAsaCk7bGV0W20sZl09VC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGwuc2hhcGUscCksZz13LnNpemVGcm9tU2hhcGUoZiksYj10Lm1ha2VPdXRwdXQobSxpLmR0eXBlKTtpZih3LnNpemVGcm9tU2hhcGUobC5zaGFwZSkhPT0wKXtsZXQgeT10LmRhdGFJZE1hcC5nZXQoYi5kYXRhSWQpLmlkO2RGKG8sZyx5KX1pZihjJiZ0LmRpc3Bvc2VEYXRhKHUuZGF0YUlkKSxzKXtsZXQgeT1ULmV4cGFuZFNoYXBlVG9LZWVwRGltKGIuc2hhcGUsZCk7Yi5zaGFwZT15fXJldHVybiBifXZhciB4dWU9e2tlcm5lbE5hbWU6SmwsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOmJ1ZSxrZXJuZWxGdW5jOnl1ZX07ZnVuY3Rpb24gaEYoZSl7bGV0IHQ7ZnVuY3Rpb24gbihyKXt0PXIud2FzbS5jd3JhcChlLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIGEocil7bGV0e2JhY2tlbmQ6cyxpbnB1dHM6aSxhdHRyczpvfT1yLHtheGlzOmx9PW8se3g6dX09aSxwPXMuZGF0YUlkTWFwLmdldCh1LmRhdGFJZCkuaWQsZD1wLGM9dSx7dHJhbnNwb3NlZDpoLGF4ZXM6bSxpbnB1dFdhc1RyYW5zcG9zZWQ6Zn09RHModSxsLHMpO2lmKGYpe2xldCBJPXMuZGF0YUlkTWFwLmdldChoLmRhdGFJZCkuaWQ7SSE9PXAmJihjPWgsZD1JKX1sZXQgZz1jLnNoYXBlLnNsaWNlKDAsLTEpLGI9cy5tYWtlT3V0cHV0KGcsXCJpbnQzMlwiKSx5PXMuZGF0YUlkTWFwLmdldChiLmRhdGFJZCkuaWQseD13LnNpemVGcm9tU2hhcGUoYi5zaGFwZSksdj1jLnNoYXBlW21bMF1dO3JldHVybiB0KGQsUWVbYy5kdHlwZV0seCx2LHkpLGYmJnMuZGlzcG9zZURhdGEoaC5kYXRhSWQpLGJ9cmV0dXJue2tlcm5lbE5hbWU6ZSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6bixrZXJuZWxGdW5jOmF9fXZhciB2dWU9aEYoUWwpLHd1ZT1oRihldSksa3VlPVhlKEVpKSxJdWU9WGUoX2kpLFN1ZT1YZShBaSksTnVlPVV0KCRpLCExKSxUdWU9WGUoRmkpLG1GO2Z1bmN0aW9uIEN1ZShlKXttRj1lLndhc20uY3dyYXAoRGksbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gRXVlKGUpe2xldHtpbnB1dHM6dCxhdHRyczpuLGJhY2tlbmQ6YX09ZSxyPXQueCxzPWEuZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQse2ZpbHRlclNpemU6aSxzdHJpZGVzOm8scGFkOmwsZGltUm91bmRpbmdNb2RlOnV9PW4scD1ULmNvbXB1dGVQb29sMkRJbmZvKHIuc2hhcGUsaSxvLDEsbCx1KSxkPXAuZmlsdGVySGVpZ2h0LGM9cC5maWx0ZXJXaWR0aCxoPXAucGFkSW5mby50b3AsbT1wLnBhZEluZm8ucmlnaHQsZj1wLnBhZEluZm8uYm90dG9tLGc9cC5wYWRJbmZvLmxlZnQsYj1wLnN0cmlkZUhlaWdodCx5PXAuc3RyaWRlV2lkdGgseD1wLmluQ2hhbm5lbHM7aWYocC5kYXRhRm9ybWF0IT09XCJjaGFubmVsc0xhc3RcIil0aHJvdyBuZXcgRXJyb3IoYHdhc20gYmFja2VuZCBkb2VzIG5vdCBzdXBwb3J0IGRhdGFGb3JtYXQ6JyR7cC5kYXRhRm9ybWF0fScuIFBsZWFzZSB1c2UgJ2NoYW5uZWxzTGFzdCcuYCk7aWYocC5kaWxhdGlvbldpZHRoIT09MXx8cC5kaWxhdGlvbkhlaWdodCE9PTEpdGhyb3cgbmV3IEVycm9yKGB3YXMgYmFja2VuZCBvbmx5IHN1cHBvcnRzIGF2ZXJhZ2UgcG9vbGluZyB3aXRoIGRpbGF0aW9uID0gWzEsIDFdLCBnb3QgWyR7cC5kaWxhdGlvbkhlaWdodH0sICR7cC5kaWxhdGlvbldpZHRofV0uYCk7bGV0IHY9YS5tYWtlT3V0cHV0KHAub3V0U2hhcGUsXCJmbG9hdDMyXCIpLEk9YS5kYXRhSWRNYXAuZ2V0KHYuZGF0YUlkKS5pZDtyZXR1cm4gbUYocyxyLnNoYXBlWzBdLHIuc2hhcGVbMV0sci5zaGFwZVsyXSxkLGMsaCxtLGYsZyxiLHkseCxJKSx2fXZhciBfdWU9e2tlcm5lbE5hbWU6RGksYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOkN1ZSxrZXJuZWxGdW5jOkV1ZX0sZkY7ZnVuY3Rpb24gQXVlKGUpe2ZGPWUud2FzbS5jd3JhcChcIkF2Z1Bvb2wzRFwiLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBGdWUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2ZpbHRlclNpemU6cyxzdHJpZGVzOmkscGFkOm8sZGltUm91bmRpbmdNb2RlOmwsZGF0YUZvcm1hdDp1fT1hLHA9VC5jb21wdXRlUG9vbDNESW5mbyhyLnNoYXBlLHMsaSwxLG8sbCx1KSxkPW4ubWFrZU91dHB1dChwLm91dFNoYXBlLHIuZHR5cGUpO3JldHVybiBmRihuLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLG4uZGF0YUlkTWFwLmdldChkLmRhdGFJZCkuaWQscC5iYXRjaFNpemUscC5pbkNoYW5uZWxzLHAuaW5EZXB0aCxwLmluSGVpZ2h0LHAuaW5XaWR0aCxwLm91dERlcHRoLHAub3V0SGVpZ2h0LHAub3V0V2lkdGgscC5zdHJpZGVEZXB0aCxwLnN0cmlkZUhlaWdodCxwLnN0cmlkZVdpZHRoLHAuZGlsYXRpb25EZXB0aCxwLmRpbGF0aW9uSGVpZ2h0LHAuZGlsYXRpb25XaWR0aCxwLmVmZmVjdGl2ZUZpbHRlckRlcHRoLHAuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LHAuZWZmZWN0aXZlRmlsdGVyV2lkdGgscC5wYWRJbmZvLmZyb250LHAucGFkSW5mby50b3AscC5wYWRJbmZvLmxlZnQpLGR9dmFyICR1ZT17a2VybmVsTmFtZTp0dSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6QXVlLGtlcm5lbEZ1bmM6RnVlfSxnRjtmdW5jdGlvbiBEdWUoZSl7Z0Y9ZS53YXNtLmN3cmFwKFwiQXZnUG9vbDNER3JhZFwiLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBSdWUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtkeTpyLGlucHV0OnN9PXQse2ZpbHRlclNpemU6aSxzdHJpZGVzOm8scGFkOmwsZGltUm91bmRpbmdNb2RlOnV9PWEscD1ULmNvbXB1dGVQb29sM0RJbmZvKHMuc2hhcGUsaSxvLDEsbCx1KSxkPW4ubWFrZU91dHB1dChzLnNoYXBlLHMuZHR5cGUpO3JldHVybiBnRihuLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLG4uZGF0YUlkTWFwLmdldChkLmRhdGFJZCkuaWQscC5iYXRjaFNpemUscC5pbkNoYW5uZWxzLHAuaW5EZXB0aCxwLmluSGVpZ2h0LHAuaW5XaWR0aCxwLm91dERlcHRoLHAub3V0SGVpZ2h0LHAub3V0V2lkdGgscC5zdHJpZGVEZXB0aCxwLnN0cmlkZUhlaWdodCxwLnN0cmlkZVdpZHRoLHAuZGlsYXRpb25EZXB0aCxwLmRpbGF0aW9uSGVpZ2h0LHAuZGlsYXRpb25XaWR0aCxwLmVmZmVjdGl2ZUZpbHRlckRlcHRoLHAuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LHAuZWZmZWN0aXZlRmlsdGVyV2lkdGgscC5wYWRJbmZvLmZyb250LHAucGFkSW5mby50b3AscC5wYWRJbmZvLmxlZnQscC5maWx0ZXJEZXB0aCxwLmZpbHRlckhlaWdodCxwLmZpbHRlcldpZHRoKSxkfXZhciBNdWU9e2tlcm5lbE5hbWU6UmMsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOkR1ZSxrZXJuZWxGdW5jOlJ1ZX0sYkY7ZnVuY3Rpb24gT3VlKGUpe2JGPWUud2FzbS5jd3JhcChcIkF2Z1Bvb2xHcmFkXCIsbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBQdWUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtkeTpyLGlucHV0OnN9PXQse2ZpbHRlclNpemU6aSxzdHJpZGVzOm8scGFkOmx9PWEsdT1ULmNvbXB1dGVQb29sMkRJbmZvKHMuc2hhcGUsaSxvLDEsbCkscD1uLm1ha2VPdXRwdXQocy5zaGFwZSxzLmR0eXBlKTtyZXR1cm4gYkYobi5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZCxuLmRhdGFJZE1hcC5nZXQocC5kYXRhSWQpLmlkLHUuYmF0Y2hTaXplLHUuaW5DaGFubmVscyx1LmluSGVpZ2h0LHUuaW5XaWR0aCx1Lm91dEhlaWdodCx1Lm91dFdpZHRoLHUuc3RyaWRlSGVpZ2h0LHUuc3RyaWRlV2lkdGgsdS5kaWxhdGlvbkhlaWdodCx1LmRpbGF0aW9uV2lkdGgsdS5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsdS5lZmZlY3RpdmVGaWx0ZXJXaWR0aCx1LnBhZEluZm8udG9wLHUucGFkSW5mby5sZWZ0LHUuZmlsdGVySGVpZ2h0LHUuZmlsdGVyV2lkdGgpLHB9dmFyIEx1ZT17a2VybmVsTmFtZTpEYyxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6T3VlLGtlcm5lbEZ1bmM6UHVlfTtmdW5jdGlvbiB6bihlKXtsZXR7aW5wdXRzOnQsYXR0cnM6bn09ZSx7eDphfT10LHtzaGFwZTpyfT1uLHM9dy5zaXplRnJvbVNoYXBlKGEuc2hhcGUpLGk9dy5pbmZlckZyb21JbXBsaWNpdFNoYXBlKHIscyk7cmV0dXJuIHcuYXNzZXJ0KHM9PT13LnNpemVGcm9tU2hhcGUoaSksKCk9PmBuZXcgc2hhcGU6ICR7aX0sIG9sZCBzaGFwZTogJHthLnNoYXBlfS4gTmV3IHNoYXBlIGFuZCBvbGQgc2hhcGUgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy5gKSxlLmJhY2tlbmQuaW5jUmVmKGEuZGF0YUlkKSx7ZGF0YUlkOmEuZGF0YUlkLHNoYXBlOmksZHR5cGU6YS5kdHlwZX19dmFyIHp1ZT17a2VybmVsTmFtZTpSdSxiYWNrZW5kTmFtZTpcIndhc21cIixrZXJuZWxGdW5jOnpufSx5RjtmdW5jdGlvbiBXdWUoZSl7eUY9ZS53YXNtLmN3cmFwKFJpLG51bGwsW1wibnVtYmVyXCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcImFycmF5XCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIEJ1ZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2E6cixiOnN9PXQse3RyYW5zcG9zZUE6aSx0cmFuc3Bvc2VCOm99PWE7aWYoci5kdHlwZSE9PVwiZmxvYXQzMlwifHxzLmR0eXBlIT09XCJmbG9hdDMyXCIpdGhyb3cgbmV3IEVycm9yKFwiQmF0Y2hNYXRNdWwgZm9yIG5vbiBub24tZmxvYXQzMiB0ZW5zb3JzIG5vdCB5ZXQgc3VwcG9ydGVkLlwiKTtsZXQgbD1yLnNoYXBlLmxlbmd0aCx1PXMuc2hhcGUubGVuZ3RoLHA9aT9yLnNoYXBlW2wtMl06ci5zaGFwZVtsLTFdLGQ9bz9zLnNoYXBlW3UtMV06cy5zaGFwZVt1LTJdLGM9aT9yLnNoYXBlW2wtMV06ci5zaGFwZVtsLTJdLGg9bz9zLnNoYXBlW3UtMl06cy5zaGFwZVt1LTFdLG09ci5zaGFwZS5zbGljZSgwLC0yKSxmPXMuc2hhcGUuc2xpY2UoMCwtMiksZz13LnNpemVGcm9tU2hhcGUobSksYj13LnNpemVGcm9tU2hhcGUoZikseT1KdS5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShyLnNoYXBlLnNsaWNlKDAsLTIpLHMuc2hhcGUuc2xpY2UoMCwtMikpLmNvbmNhdChbYyxoXSk7dy5hc3NlcnQocD09PWQsKCk9PmBFcnJvciBpbiBtYXRNdWw6IGlubmVyIHNoYXBlcyAoJHtwfSkgYW5kICgke2R9KSBvZiBUZW5zb3JzIHdpdGggc2hhcGVzICR7ci5zaGFwZX0gYW5kICR7cy5zaGFwZX0gYW5kIHRyYW5zcG9zZUE9JHtpfSBhbmQgdHJhbnNwb3NlQj0ke299IG11c3QgbWF0Y2guYCk7bGV0IHg9aT9bZyxwLGNdOltnLGMscF0sdj1vP1tiLGgsZF06W2IsZCxoXSxJPXpuKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTp4fX0pLE49em4oe2lucHV0czp7eDpzfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOnZ9fSksQz1uLmRhdGFJZE1hcC5nZXQoSS5kYXRhSWQpLmlkLF89bi5kYXRhSWRNYXAuZ2V0KE4uZGF0YUlkKS5pZCxGPWk/SS5zaGFwZVsyXTpJLnNoYXBlWzFdLEQ9bz9OLnNoYXBlWzFdOk4uc2hhcGVbMl0sJD1NYXRoLm1heChnLGIpLFM9bi5tYWtlT3V0cHV0KFskLEYsRF0sSS5kdHlwZSksTT1uLmRhdGFJZE1hcC5nZXQoUy5kYXRhSWQpLmlkLEI9bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkoSS5zaGFwZSkuYnVmZmVyKSxVPW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KE4uc2hhcGUpLmJ1ZmZlcik7cmV0dXJuIHlGKEMsQixJLnNoYXBlLmxlbmd0aCxfLFUsTi5zaGFwZS5sZW5ndGgsaSxvLE0pLG4uZGlzcG9zZURhdGEoSS5kYXRhSWQpLG4uZGlzcG9zZURhdGEoTi5kYXRhSWQpLFMuc2hhcGU9eSxTfXZhciBWdWU9e2tlcm5lbE5hbWU6UmksYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOld1ZSxrZXJuZWxGdW5jOkJ1ZX07ZnVuY3Rpb24gSWkoZSl7bGV0e2lucHV0czp7eDp0fSxhdHRyczp7YmVnaW46bixzaXplOmF9LGJhY2tlbmQ6cn09ZSxbcyxpXT1LdC5wYXJzZVNsaWNlUGFyYW1zKHQsbixhKSxvPUt0LmlzU2xpY2VDb250aW5vdXModC5zaGFwZSxzLGkpLGw9ci5yZWFkU3luYyh0LmRhdGFJZCksdT1yLm1ha2VPdXRwdXQoaSx0LmR0eXBlKSxwPXcuY29tcHV0ZVN0cmlkZXModC5zaGFwZSksZD1yLmRhdGFJZE1hcC5nZXQodS5kYXRhSWQpO2lmKG8pe2xldCBtPUt0LmNvbXB1dGVGbGF0T2Zmc2V0KHMscCk7cmV0dXJuIHQuZHR5cGU9PT1cInN0cmluZ1wiP2Quc3RyaW5nQnl0ZXM9bC5zbGljZShtLG0rdy5zaXplRnJvbVNoYXBlKGkpKTpyLnR5cGVkQXJyYXlGcm9tSGVhcCh1KS5zZXQobC5zdWJhcnJheShtLG0rdy5zaXplRnJvbVNoYXBlKGkpKSksdX1pZih0LmR0eXBlPT09XCJzdHJpbmdcIil7bGV0IG09dW0obCxzLGksdC5zaGFwZSx0LmR0eXBlKTtyZXR1cm4gZC5zdHJpbmdCeXRlcz1tLHV9bGV0IGM9ci50eXBlZEFycmF5RnJvbUhlYXAodSksaD10LnNoYXBlLmxlbmd0aDtpZihoPT09MilVdWUobCxwWzBdLGMscyxpKTtlbHNlIGlmKGg9PT0zKUd1ZShsLHBbMF0scFsxXSxjLHMsaSk7ZWxzZSBpZihoPT09NClIdWUobCxwWzBdLHBbMV0scFsyXSxjLHMsaSk7ZWxzZXtsZXQgbT11bShsLHMsaSx0LnNoYXBlLHQuZHR5cGUpO2Muc2V0KG0pfXJldHVybiB1fWZ1bmN0aW9uIFV1ZShlLHQsbixhLHIpe2xldCBzPTAsaT1hWzBdLG89YVsxXSxsPWkrclswXTtmb3IobGV0IHU9aTt1PGw7dSsrKXtsZXQgcD11KnQrbztuLnNldChlLnN1YmFycmF5KHAscCtyWzFdKSxzKSxzKz1yWzFdfX1mdW5jdGlvbiBHdWUoZSx0LG4sYSxyLHMpe2xldCBpPTAsbz1yWzBdLGw9clsxXSx1PXJbMl0scD1vK3NbMF0sZD1sK3NbMV07Zm9yKGxldCBjPW87YzxwO2MrKylmb3IobGV0IGg9bDtoPGQ7aCsrKXtsZXQgbT1jKnQraCpuK3U7YS5zZXQoZS5zdWJhcnJheShtLG0rc1syXSksaSksaSs9c1syXX19ZnVuY3Rpb24gSHVlKGUsdCxuLGEscixzLGkpe2xldCBvPTAsbD1zWzBdLHU9c1sxXSxwPXNbMl0sZD1sK2lbMF0sYz11K2lbMV0saD1wK2lbMl0sbT1zWzNdO2ZvcihsZXQgZj1sO2Y8ZDtmKyspZm9yKGxldCBnPXU7ZzxjO2crKylmb3IobGV0IGI9cDtiPGg7YisrKXtsZXQgeT1mKnQrZypuK2IqYSttO3Iuc2V0KGUuc3ViYXJyYXkoeSx5K2lbM10pLG8pLG8rPWlbM119fXZhciBqdWU9e2tlcm5lbE5hbWU6QnUsYmFja2VuZE5hbWU6XCJ3YXNtXCIsa2VybmVsRnVuYzpJaX07ZnVuY3Rpb24gcXVlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtibG9ja1NoYXBlOnMsY3JvcHM6aX09YSxvPXMucmVkdWNlKChiLHkpPT5iKnkpLGw9VC5nZXRSZXNoYXBlZChyLnNoYXBlLHMsbyksdT1ULmdldFBlcm11dGVkKGwubGVuZ3RoLHMubGVuZ3RoKSxwPVQuZ2V0UmVzaGFwZWRQZXJtdXRlZChyLnNoYXBlLHMsbyksZD1ULmdldFNsaWNlQmVnaW5Db29yZHMoaSxzLmxlbmd0aCksYz1ULmdldFNsaWNlU2l6ZShwLGkscy5sZW5ndGgpLGg9em4oe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOmx9fSksbT15cyh7aW5wdXRzOnt4Omh9LGJhY2tlbmQ6bixhdHRyczp7cGVybTp1fX0pLGY9em4oe2lucHV0czp7eDptfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOnB9fSksZz1JaSh7aW5wdXRzOnt4OmZ9LGJhY2tlbmQ6bixhdHRyczp7YmVnaW46ZCxzaXplOmN9fSk7cmV0dXJuIG4uZGlzcG9zZURhdGEoaC5kYXRhSWQpLG4uZGlzcG9zZURhdGEobS5kYXRhSWQpLG4uZGlzcG9zZURhdGEoZi5kYXRhSWQpLGd9dmFyIEt1ZT17a2VybmVsTmFtZTpudSxiYWNrZW5kTmFtZTpcIndhc21cIixrZXJuZWxGdW5jOnF1ZX0seEY7ZnVuY3Rpb24gWHVlKGUpe3hGPWUud2FzbS5jd3JhcChhdSxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJib29sZWFuXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBZdWUoZSl7bGV0e2JhY2tlbmQ6dCxpbnB1dHM6bixhdHRyczphfT1lLHt4OnIsd2VpZ2h0czpzfT1uLHtzaXplOml9PWEsbz1zLnNoYXBlLnJlZHVjZSgoZCxjKT0+ZCpjLDEpIT09MCxsPXIuc2hhcGUubGVuZ3RoPT09MT9baV06W3Iuc2hhcGVbMF0saV0sdT10Lm1ha2VPdXRwdXQobCxzLmR0eXBlKTtmdW5jdGlvbiBwKGQpe3JldHVybiB0LmRhdGFJZE1hcC5nZXQoZC5kYXRhSWQpLmlkfXJldHVybiB4RihwKHIpLGksbyxwKHMpLFFlW3MuZHR5cGVdLHAodSkpLHV9dmFyIFp1ZT17a2VybmVsTmFtZTphdSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6WHVlLGtlcm5lbEZ1bmM6WXVlfSxKdWU9ITAsUXVlPVV0KHJ1LEp1ZSk7ZnVuY3Rpb24gZXBlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse3MwOmEsczE6cn09dCxzPW4udHlwZWRBcnJheUZyb21IZWFwKGEpLGk9bi50eXBlZEFycmF5RnJvbUhlYXAociksbz1ULmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKEFycmF5LmZyb20ocyksQXJyYXkuZnJvbShpKSk7cmV0dXJuIG4ubWFrZU91dHB1dChbby5sZW5ndGhdLFwiaW50MzJcIix2b2lkIDAsbmV3IEludDMyQXJyYXkobykpfXZhciB0cGU9e2tlcm5lbE5hbWU6TWMsYmFja2VuZE5hbWU6XCJ3YXNtXCIsa2VybmVsRnVuYzplcGV9O2Z1bmN0aW9uIFJzKGUpe2xldHtpbnB1dHM6e3g6dH0sYXR0cnM6e2R0eXBlOm59LGJhY2tlbmQ6YX09ZSxyPWEubWFrZU91dHB1dCh0LnNoYXBlLG4pLHM9YS50eXBlZEFycmF5RnJvbUhlYXAodCk7cmV0dXJuIGEudHlwZWRBcnJheUZyb21IZWFwKHIpLnNldChzKSxyfXZhciBucGU9e2tlcm5lbE5hbWU6TWksYmFja2VuZE5hbWU6XCJ3YXNtXCIsa2VybmVsRnVuYzpSc30sYXBlPVhlKE9pKSx2RjtmdW5jdGlvbiBycGUoZSl7dkY9ZS53YXNtLmN3cmFwKHdzLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBzcGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2NsaXBWYWx1ZU1pbjpzLGNsaXBWYWx1ZU1heDppfT1hLG89bi5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZCxsPW4ubWFrZU91dHB1dChyLnNoYXBlLHIuZHR5cGUpLHU9bi5kYXRhSWRNYXAuZ2V0KGwuZGF0YUlkKS5pZDtyZXR1cm4gdkYobyxzLGksdSksbH12YXIgaXBlPXtrZXJuZWxOYW1lOndzLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpycGUsa2VybmVsRnVuYzpzcGV9O2Z1bmN0aW9uIHdGKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUsYT13LnBhcnNlQXhpc1BhcmFtKGUuYXR0cnMuYXhpcyx0WzBdLnNoYXBlKVswXSxyPXQubWFwKGg9Pmguc2hhcGUpO1QuYXNzZXJ0UGFyYW1zQ29uc2lzdGVudChyLGEpO2xldCBzPVQuY29tcHV0ZU91dFNoYXBlKHQubWFwKGg9Pmguc2hhcGUpLGEpLGk9dC5maWx0ZXIoaD0+dy5zaXplRnJvbVNoYXBlKGguc2hhcGUpPjApO2lmKGkubGVuZ3RoPT09MSlyZXR1cm4gR2Yoe2lucHV0czp7eDppWzBdfSxiYWNrZW5kOm59KTtsZXQgbz1uLm1ha2VPdXRwdXQocyx0WzBdLmR0eXBlKTtpZih3LnNpemVGcm9tU2hhcGUocyk9PT0wKXJldHVybiBvO2lmKGlbMF0uZHR5cGU9PT1cInN0cmluZ1wiKXtsZXQgaD1pLm1hcCh4PT57bGV0IHY9Wy0xLHcuc2l6ZUZyb21TaGFwZSh4LnNoYXBlLnNsaWNlKGEpKV07cmV0dXJuIHpuKHtpbnB1dHM6e3h9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6dn19KX0pLG09aC5tYXAoeD0+KHt2YWxzOm4ucmVhZFN5bmMoeC5kYXRhSWQpLHNoYXBlOnguc2hhcGV9KSk7cz1ULmNvbXB1dGVPdXRTaGFwZShoLm1hcCh4PT54LnNoYXBlKSwxKTtsZXQgZj1oWzBdLnNoYXBlWzBdPT09MSxnPUwxKG0scyx0WzBdLmR0eXBlLGYpLGI9VC5jb21wdXRlT3V0U2hhcGUoaS5tYXAoeD0+eC5zaGFwZSksYSk7by5zaGFwZT1iO2xldCB5PW4uZGF0YUlkTWFwLmdldChvLmRhdGFJZCk7cmV0dXJuIHkuc3RyaW5nQnl0ZXM9VC5mcm9tU3RyaW5nQXJyYXlUb1VpbnQ4KGcpLGguZm9yRWFjaCh4PT5uLmRpc3Bvc2VEYXRhKHguZGF0YUlkKSksb31sZXQgbD13LnNpemVGcm9tU2hhcGUoaVswXS5zaGFwZS5zbGljZSgwLGEpKSx1PTAscD1pLm1hcChoPT57bGV0IG09dy5zaXplRnJvbVNoYXBlKGguc2hhcGUuc2xpY2UoYSkpO3JldHVybiB1Kz1tLG19KSxkPWkubWFwKGg9Pm4udHlwZWRBcnJheUZyb21IZWFwKGgpKSxjPW4udHlwZWRBcnJheUZyb21IZWFwKG8pO2ZvcihsZXQgaD0wO2g8bDtoKyspe2xldCBtPWgqdTtmb3IobGV0IGY9MDtmPGQubGVuZ3RoO2YrKyl7bGV0IGc9cFtmXSxiPWgqZyx5PWRbZl0uc3ViYXJyYXkoYixiK2cpO2Muc2V0KHksbSksbSs9Z319cmV0dXJuIG99dmFyIG9wZT17a2VybmVsTmFtZTpzdSxiYWNrZW5kTmFtZTpcIndhc21cIixrZXJuZWxGdW5jOndGfSxrRjtmdW5jdGlvbiBscGUoZSl7a0Y9ZS53YXNtLmN3cmFwKFBpLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiB1cGUoZSl7bGV0e2lucHV0czp0LGF0dHJzOm4sYmFja2VuZDphfT1lLHt4OnIsZmlsdGVyOnN9PXQsaT1hLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLG89YS5kYXRhSWRNYXAuZ2V0KHMuZGF0YUlkKS5pZCx7c3RyaWRlczpsLGRpbGF0aW9uczp1LHBhZDpwLGRpbVJvdW5kaW5nTW9kZTpkLGRhdGFGb3JtYXQ6Y309bixoPVQuY29udmVydENvbnYyRERhdGFGb3JtYXQoYyksbT1ULmNvbXB1dGVDb252MkRJbmZvKHIuc2hhcGUscy5zaGFwZSxsLHUscCxkLCExLGgpLGY9bS5maWx0ZXJIZWlnaHQsZz1tLmZpbHRlcldpZHRoLGI9bS5wYWRJbmZvLnRvcCx5PW0ucGFkSW5mby5yaWdodCx4PW0ucGFkSW5mby5ib3R0b20sdj1tLnBhZEluZm8ubGVmdCxJPW0uZGlsYXRpb25IZWlnaHQsTj1tLmRpbGF0aW9uV2lkdGgsQz1tLnN0cmlkZUhlaWdodCxfPW0uc3RyaWRlV2lkdGgsRj1tLmluQ2hhbm5lbHMsRD1tLm91dENoYW5uZWxzLCQ9bS5wYWRJbmZvLnR5cGU9PT1cIlNBTUVcIj8xOjA7aWYobS5kYXRhRm9ybWF0IT09XCJjaGFubmVsc0xhc3RcIil0aHJvdyBuZXcgRXJyb3IoYHdhc20gYmFja2VuZCBDb252MkQgZG9lcyBub3Qgc3VwcG9ydCBkYXRhRm9ybWF0Oicke20uZGF0YUZvcm1hdH0nLiBQbGVhc2UgdXNlICdjaGFubmVsc0xhc3QnLmApO2xldCBTPWEubWFrZU91dHB1dChtLm91dFNoYXBlLFwiZmxvYXQzMlwiKSxNPWEuZGF0YUlkTWFwLmdldChTLmRhdGFJZCkuaWQ7cmV0dXJuIGtGKGksci5zaGFwZVswXSxyLnNoYXBlWzFdLHIuc2hhcGVbMl0sbyxmLGcsYix5LHgsdiwkLEksTixDLF8sRixELE0pLFN9dmFyIHBwZT17a2VybmVsTmFtZTpQaSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6bHBlLGtlcm5lbEZ1bmM6dXBlfSxJRjtmdW5jdGlvbiBjcGUoZSl7SUY9ZS53YXNtLmN3cmFwKExpLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gZHBlKGUpe2xldHtiYWNrZW5kOnQsaW5wdXRzOm4sYXR0cnM6YX09ZSx7ZHk6cixmaWx0ZXI6c309bix7c3RyaWRlczppLHBhZDpvLGRhdGFGb3JtYXQ6bCxkaW1Sb3VuZGluZ01vZGU6dSxpbnB1dFNoYXBlOnB9PWEsZD0xLGM9VC5jb252ZXJ0Q29udjJERGF0YUZvcm1hdChsKSxoPVQuY29tcHV0ZUNvbnYyREluZm8ocCxzLnNoYXBlLGksZCxvLHUsITEsYykse2JhdGNoU2l6ZTptLGZpbHRlckhlaWdodDpmLGZpbHRlcldpZHRoOmcsaW5DaGFubmVsczpiLGluSGVpZ2h0OnksaW5XaWR0aDp4LG91dENoYW5uZWxzOnYsb3V0SGVpZ2h0Okksb3V0V2lkdGg6TixzdHJpZGVIZWlnaHQ6QyxzdHJpZGVXaWR0aDpffT1oLEY9Zi0xLWgucGFkSW5mby50b3AsRD1nLTEtaC5wYWRJbmZvLmxlZnQsJD1oLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzTGFzdFwiLFM9dy5jb21wdXRlU3RyaWRlcyhoLmluU2hhcGUpLE09dy5jb21wdXRlU3RyaWRlcyhyLnNoYXBlKSxbQixVLEhdPXcuY29tcHV0ZVN0cmlkZXMocy5zaGFwZSkscT1TWzBdLEs9JD9TWzFdOlNbMl0sWj0kP1NbMl06MSxKPSQ/MTpTWzFdLGVlPU1bMF0sYWU9JD9NWzFdOk1bMl0sdGU9JD9NWzJdOjEsc2U9JD8xOk1bMV0saWU9dC5tYWtlT3V0cHV0KGguaW5TaGFwZSxcImZsb2F0MzJcIiksdmU9dC5kYXRhSWRNYXAuZ2V0KGllLmRhdGFJZCkuaWQsdWU9dC5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZCx5ZT10LmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkO3JldHVybiBJRih1ZSx5ZSxtLGYsZyx5LHgsYixJLE4sdixDLF8sRixELEIsVSxILHEsSyxaLEosZWUsYWUsdGUsc2UsdmUpLGllfXZhciBocGU9e2tlcm5lbE5hbWU6TGksYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOmNwZSxrZXJuZWxGdW5jOmRwZX0sU0Y7ZnVuY3Rpb24gbXBlKGUpe1NGPWUud2FzbS5jd3JhcCh6aSxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIGZwZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cixmaWx0ZXI6c309dCx7c3RyaWRlczppLHBhZDpvLGRpbGF0aW9uczpsfT1hO2lmKHIuZHR5cGUhPT1cImZsb2F0MzJcIil0aHJvdyBuZXcgRXJyb3IoYFRlbnNvciB4IG11c3QgaGF2ZSBkdHlwZSBmbG9hdDMyLCBnb3QgJHtyLmR0eXBlfWApO2lmKHMuZHR5cGUhPT1cImZsb2F0MzJcIil0aHJvdyBuZXcgRXJyb3IoYFRlbnNvciBmaWx0ZXIgbXVzdCBoYXZlIGR0eXBlIGZsb2F0MzIsIGdvdCAke3MuZHR5cGV9YCk7bGV0IHU9VC5jb21wdXRlQ29udjNESW5mbyhyLnNoYXBlLHMuc2hhcGUsaSxsLG8pLHA9bi5tYWtlT3V0cHV0KHUub3V0U2hhcGUsci5kdHlwZSk7cmV0dXJuIFNGKG4uZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsbi5kYXRhSWRNYXAuZ2V0KHMuZGF0YUlkKS5pZCxuLmRhdGFJZE1hcC5nZXQocC5kYXRhSWQpLmlkLHUuYmF0Y2hTaXplLHUuaW5EZXB0aCx1LmluSGVpZ2h0LHUuaW5XaWR0aCx1LmluQ2hhbm5lbHMsdS5vdXREZXB0aCx1Lm91dEhlaWdodCx1Lm91dFdpZHRoLHUub3V0Q2hhbm5lbHMsdS5zdHJpZGVEZXB0aCx1LnN0cmlkZUhlaWdodCx1LnN0cmlkZVdpZHRoLHUuZGlsYXRpb25EZXB0aCx1LmRpbGF0aW9uSGVpZ2h0LHUuZGlsYXRpb25XaWR0aCx1LmZpbHRlckRlcHRoLHUuZmlsdGVySGVpZ2h0LHUuZmlsdGVyV2lkdGgsdS5wYWRJbmZvLmZyb250LHUucGFkSW5mby50b3AsdS5wYWRJbmZvLmxlZnQpLHB9dmFyIGdwZT17a2VybmVsTmFtZTp6aSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6bXBlLGtlcm5lbEZ1bmM6ZnBlfSxORjtmdW5jdGlvbiBicGUoZSl7TkY9ZS53YXNtLmN3cmFwKGl1LG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24geXBlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyLGR5OnN9PXQse3N0cmlkZXM6aSxwYWQ6byxmaWx0ZXJTaGFwZTpsfT1hO2lmKHIuZHR5cGUhPT1cImZsb2F0MzJcIil0aHJvdyBuZXcgRXJyb3IoYFRlbnNvciBkeSBtdXN0IGhhdmUgZHR5cGUgZmxvYXQzMiwgZ290ICR7ci5kdHlwZX1gKTtpZihzLmR0eXBlIT09XCJmbG9hdDMyXCIpdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IgZmlsdGVyIG11c3QgaGF2ZSBkdHlwZSBmbG9hdDMyLCBnb3QgJHtzLmR0eXBlfWApO2xldCB1PVQuY29tcHV0ZUNvbnYzREluZm8oci5zaGFwZSxsLGksMSxvKSxwPW4ubWFrZU91dHB1dCh1LmZpbHRlclNoYXBlLHMuZHR5cGUpO3JldHVybiBORihuLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLG4uZGF0YUlkTWFwLmdldChzLmRhdGFJZCkuaWQsbi5kYXRhSWRNYXAuZ2V0KHAuZGF0YUlkKS5pZCx1LmJhdGNoU2l6ZSx1LmluRGVwdGgsdS5pbkhlaWdodCx1LmluV2lkdGgsdS5pbkNoYW5uZWxzLHUub3V0RGVwdGgsdS5vdXRIZWlnaHQsdS5vdXRXaWR0aCx1Lm91dENoYW5uZWxzLHUuc3RyaWRlRGVwdGgsdS5zdHJpZGVIZWlnaHQsdS5zdHJpZGVXaWR0aCx1LmRpbGF0aW9uRGVwdGgsdS5kaWxhdGlvbkhlaWdodCx1LmRpbGF0aW9uV2lkdGgsdS5maWx0ZXJEZXB0aCx1LmZpbHRlckhlaWdodCx1LmZpbHRlcldpZHRoLHUucGFkSW5mby5mcm9udCx1LnBhZEluZm8udG9wLHUucGFkSW5mby5sZWZ0KSxwfXZhciB4cGU9e2tlcm5lbE5hbWU6aXUsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOmJwZSxrZXJuZWxGdW5jOnlwZX0sVEY7ZnVuY3Rpb24gdnBlKGUpe1RGPWUud2FzbS5jd3JhcChvdSxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIHdwZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2R5OnIsZmlsdGVyOnN9PXQse3BhZDppLHN0cmlkZXM6byxpbnB1dFNoYXBlOmx9PWE7aWYoci5kdHlwZSE9PVwiZmxvYXQzMlwiKXRocm93IG5ldyBFcnJvcihgVGVuc29yIGR5IG11c3QgaGF2ZSBkdHlwZSBmbG9hdDMyLCBnb3QgJHtyLmR0eXBlfWApO2lmKHMuZHR5cGUhPT1cImZsb2F0MzJcIil0aHJvdyBuZXcgRXJyb3IoYFRlbnNvciBmaWx0ZXIgbXVzdCBoYXZlIGR0eXBlIGZsb2F0MzIsIGdvdCAke3MuZHR5cGV9YCk7bGV0IHU9VC5jb21wdXRlQ29udjNESW5mbyhsLHMuc2hhcGUsbywxLGkpLHA9bi5tYWtlT3V0cHV0KHUuaW5TaGFwZSxyLmR0eXBlKTtyZXR1cm4gVEYobi5kYXRhSWRNYXAuZ2V0KHMuZGF0YUlkKS5pZCxuLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLG4uZGF0YUlkTWFwLmdldChwLmRhdGFJZCkuaWQsdS5iYXRjaFNpemUsdS5pbkRlcHRoLHUuaW5IZWlnaHQsdS5pbldpZHRoLHUuaW5DaGFubmVscyx1Lm91dERlcHRoLHUub3V0SGVpZ2h0LHUub3V0V2lkdGgsdS5vdXRDaGFubmVscyx1LnN0cmlkZURlcHRoLHUuc3RyaWRlSGVpZ2h0LHUuc3RyaWRlV2lkdGgsdS5kaWxhdGlvbkRlcHRoLHUuZGlsYXRpb25IZWlnaHQsdS5kaWxhdGlvbldpZHRoLHUuZmlsdGVyRGVwdGgsdS5maWx0ZXJIZWlnaHQsdS5maWx0ZXJXaWR0aCx1LnBhZEluZm8uZnJvbnQsdS5wYWRJbmZvLnRvcCx1LnBhZEluZm8ubGVmdCkscH12YXIga3BlPXtrZXJuZWxOYW1lOm91LGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzp2cGUsa2VybmVsRnVuYzp3cGV9LElwZT1YZShXaSksU3BlPVhlKEJpKSxidjsoZnVuY3Rpb24oZSl7ZVtlLmJpbGluZWFyPTBdPVwiYmlsaW5lYXJcIixlW2UubmVhcmVzdD0xXT1cIm5lYXJlc3RcIn0pKGJ2fHwoYnY9e30pKTt2YXIgQ0Y7ZnVuY3Rpb24gTnBlKGUpe0NGPWUud2FzbS5jd3JhcCh1dSxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwiYXJyYXlcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBUcGUoZSl7bGV0e2JhY2tlbmQ6dCxpbnB1dHM6bixhdHRyczphfT1lLHttZXRob2Q6cixleHRyYXBvbGF0aW9uVmFsdWU6cyxjcm9wU2l6ZTppfT1hLHtpbWFnZTpvLGJveGVzOmwsYm94SW5kOnV9PW4scD1sLnNoYXBlWzBdLFtkLGNdPWksaD1bcCxkLGMsby5zaGFwZVszXV0sbT10LmRhdGFJZE1hcC5nZXQoby5kYXRhSWQpLGY7by5kdHlwZSE9PVwiZmxvYXQzMlwiJiYoZj1Scyh7YmFja2VuZDp0LGlucHV0czp7eDpvfSxhdHRyczp7ZHR5cGU6XCJmbG9hdDMyXCJ9fSksbT10LmRhdGFJZE1hcC5nZXQoZi5kYXRhSWQpKTtsZXQgZz1tLmlkLGI9dC5kYXRhSWRNYXAuZ2V0KGwuZGF0YUlkKS5pZCx5PXQuZGF0YUlkTWFwLmdldCh1LmRhdGFJZCkuaWQseD10Lm1ha2VPdXRwdXQoaCxcImZsb2F0MzJcIiksdj10LmRhdGFJZE1hcC5nZXQoeC5kYXRhSWQpLmlkLEk9bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkoby5zaGFwZSkuYnVmZmVyKTtyZXR1cm4gQ0YoZyxiLHkscCxJLGQsYyxidltyXSxzLHYpLGYhPW51bGwmJnQuZGlzcG9zZURhdGEoZi5kYXRhSWQpLHh9dmFyIENwZT17a2VybmVsTmFtZTp1dSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6TnBlLGtlcm5lbEZ1bmM6VHBlfSxFRjtmdW5jdGlvbiBFcGUoZSl7RUY9ZS53YXNtLmN3cmFwKGx1LG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gX3BlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtheGlzOnMsZXhjbHVzaXZlOmkscmV2ZXJzZTpvfT1hLGw9ci5zaGFwZS5sZW5ndGg7dy5hc3NlcnQoci5kdHlwZT09PVwiZmxvYXQzMlwifHxyLmR0eXBlPT09XCJpbnQzMlwiLCgpPT5gY3VtcHJvZCBkb2VzIG5vdCBzdXBwb3J0ICR7ci5kdHlwZX0gdGVuc29ycyBpbiB0aGUgV0FTTSBiYWNrZW5kYCk7bGV0IHU9VC5nZXRBeGVzUGVybXV0YXRpb24oW3NdLGwpLHA9cjt1IT09bnVsbCYmKHA9eXMoe2lucHV0czp7eDpyfSxhdHRyczp7cGVybTp1fSxiYWNrZW5kOm59KSk7bGV0IGQ9VC5nZXRJbm5lck1vc3RBeGVzKDEsbClbMF07VC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcImN1bXByb2RcIixbZF0sbCk7bGV0IGM9bi5tYWtlT3V0cHV0KHAuc2hhcGUscC5kdHlwZSksaD1wLnNoYXBlW2RdLG09bi5kYXRhSWRNYXAuZ2V0KHAuZGF0YUlkKS5pZCxmPW4uZGF0YUlkTWFwLmdldChjLmRhdGFJZCkuaWQ7RUYobSxpPzE6MCxvPzE6MCxoLGYsUWVbci5kdHlwZV0pO2xldCBnPWM7aWYodSE9PW51bGwpe2xldCBiPVQuZ2V0VW5kb0F4ZXNQZXJtdXRhdGlvbih1KTtnPXlzKHtpbnB1dHM6e3g6Y30sYXR0cnM6e3Blcm06Yn0sYmFja2VuZDpufSksbi5kaXNwb3NlRGF0YShwLmRhdGFJZCksbi5kaXNwb3NlRGF0YShjLmRhdGFJZCl9cmV0dXJuIGd9dmFyIEFwZT17a2VybmVsTmFtZTpsdSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6RXBlLGtlcm5lbEZ1bmM6X3BlfSxfRjtmdW5jdGlvbiBGcGUoZSl7X0Y9ZS53YXNtLmN3cmFwKFZpLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gJHBlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtheGlzOnMsZXhjbHVzaXZlOmkscmV2ZXJzZTpvfT1hLGw9ci5zaGFwZS5sZW5ndGg7dy5hc3NlcnQoci5kdHlwZT09PVwiZmxvYXQzMlwifHxyLmR0eXBlPT09XCJpbnQzMlwiLCgpPT5gY3Vtc3VtIGRvZXMgbm90IHN1cHBvcnQgJHtyLmR0eXBlfSB0ZW5zb3JzIGluIHRoZSBXQVNNIGJhY2tlbmRgKTtsZXQgdT1ULmdldEF4ZXNQZXJtdXRhdGlvbihbc10sbCkscD1yO3UhPT1udWxsJiYocD15cyh7aW5wdXRzOnt4OnJ9LGF0dHJzOntwZXJtOnV9LGJhY2tlbmQ6bn0pKTtsZXQgZD1ULmdldElubmVyTW9zdEF4ZXMoMSxsKVswXTtULmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwiY3Vtc3VtXCIsW2RdLGwpO2xldCBjPW4ubWFrZU91dHB1dChwLnNoYXBlLHAuZHR5cGUpLGg9cC5zaGFwZVtkXSxtPW4uZGF0YUlkTWFwLmdldChwLmRhdGFJZCkuaWQsZj1uLmRhdGFJZE1hcC5nZXQoYy5kYXRhSWQpLmlkO19GKG0saT8xOjAsbz8xOjAsaCxmLFFlW3IuZHR5cGVdKTtsZXQgZz1jO2lmKHUhPT1udWxsKXtsZXQgYj1ULmdldFVuZG9BeGVzUGVybXV0YXRpb24odSk7Zz15cyh7aW5wdXRzOnt4OmN9LGF0dHJzOntwZXJtOmJ9LGJhY2tlbmQ6bn0pLG4uZGlzcG9zZURhdGEocC5kYXRhSWQpLG4uZGlzcG9zZURhdGEoYy5kYXRhSWQpfXJldHVybiBnfXZhciBEcGU9e2tlcm5lbE5hbWU6VmksYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOkZwZSxrZXJuZWxGdW5jOiRwZX0sQUY7ZnVuY3Rpb24gUnBlKGUpe0FGPWUud2FzbS5jd3JhcChcIkRlbnNlQmluY291bnRcIixudWxsLFtcIm51bWJlclwiLFwiYXJyYXlcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJib29sZWFuXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwiYm9vbGVhblwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBNcGUoZSl7bGV0e2JhY2tlbmQ6dCxpbnB1dHM6bixhdHRyczphfT1lLHt4OnIsd2VpZ2h0czpzfT1uLHtzaXplOmksYmluYXJ5T3V0cHV0Om99PWEsbD1zLnNoYXBlLnJlZHVjZSgoYyxoKT0+YypoLDEpIT09MCx1PXIuc2hhcGUubGVuZ3RoPT09MT9baV06W3Iuc2hhcGVbMF0saV0scD10Lm1ha2VPdXRwdXQodSxzLmR0eXBlKTtmdW5jdGlvbiBkKGMpe3JldHVybiB0LmRhdGFJZE1hcC5nZXQoYy5kYXRhSWQpLmlkfXJldHVybiBBRihkKHIpLG5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KHIuc2hhcGUpLmJ1ZmZlciksci5zaGFwZS5sZW5ndGgsaSxsLGQocyksUWVbcy5kdHlwZV0sbyxkKHApKSxwfXZhciBPcGU9e2tlcm5lbE5hbWU6UGMsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOlJwZSxrZXJuZWxGdW5jOk1wZX0sRkY7ZnVuY3Rpb24gUHBlKGUpe0ZGPWUud2FzbS5jd3JhcChwdSxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcImFycmF5XCIsXCJudW1iZXJcIixcImFycmF5XCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIExwZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpuLGF0dHJzOmF9PWUse3g6cn09bix7YmxvY2tTaXplOnMsZGF0YUZvcm1hdDppfT1hLG89ci5zaGFwZVswXSxsPWk9PT1cIk5IV0NcIj9yLnNoYXBlWzFdOnIuc2hhcGVbMl0sdT1pPT09XCJOSFdDXCI/ci5zaGFwZVsyXTpyLnNoYXBlWzNdLHA9aT09PVwiTkhXQ1wiP3Iuc2hhcGVbM106ci5zaGFwZVsxXSxkPWwqcyxjPXUqcyxoPXAvKHMqcyksbT1pPT09XCJOSFdDXCI/W28sZCxjLGhdOltvLGgsZCxjXSxmPXQubWFrZU91dHB1dChtLFwiZmxvYXQzMlwiKSxnPXQuZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsYj1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheSh3LmNvbXB1dGVTdHJpZGVzKHIuc2hhcGUpKS5idWZmZXIpLHk9bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkobSkuYnVmZmVyKSx4PW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KHcuY29tcHV0ZVN0cmlkZXMobSkpLmJ1ZmZlciksdj10LmRhdGFJZE1hcC5nZXQoZi5kYXRhSWQpLmlkO3JldHVybiBGRihnLHMsaT09PVwiTkhXQ1wiPzE6MCxiLHIuc2hhcGUubGVuZ3RoLTEseSx4LG0ubGVuZ3RoLHYpLGZ9dmFyIHpwZT17a2VybmVsTmFtZTpwdSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6UHBlLGtlcm5lbEZ1bmM6THBlfSwkRjtmdW5jdGlvbiBXcGUoZSl7JEY9ZS53YXNtLmN3cmFwKFVpLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBCcGUoZSl7bGV0e2lucHV0czp0LGF0dHJzOm4sYmFja2VuZDphfT1lLHt4OnIsZmlsdGVyOnN9PXQsaT1hLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLG89YS5kYXRhSWRNYXAuZ2V0KHMuZGF0YUlkKS5pZCx7c3RyaWRlczpsLGRpbGF0aW9uczp1LHBhZDpwLGRpbVJvdW5kaW5nTW9kZTpkfT1uLGM9dT09bnVsbD9bMSwxXTp1LGg9VC5jb21wdXRlQ29udjJESW5mbyhyLnNoYXBlLHMuc2hhcGUsbCxjLHAsZCwhMCksbT1oLmZpbHRlckhlaWdodCxmPWguZmlsdGVyV2lkdGgsZz1oLnBhZEluZm8udG9wLGI9aC5wYWRJbmZvLnJpZ2h0LHk9aC5wYWRJbmZvLmJvdHRvbSx4PWgucGFkSW5mby5sZWZ0LHY9aC5kaWxhdGlvbkhlaWdodCxJPWguZGlsYXRpb25XaWR0aCxOPWguc3RyaWRlSGVpZ2h0LEM9aC5zdHJpZGVXaWR0aCxfPWguaW5DaGFubmVscyxGPWgub3V0Q2hhbm5lbHMsRD1oLnBhZEluZm8udHlwZT09PVwiU0FNRVwiPzE6MDtpZihoLmRhdGFGb3JtYXQhPT1cImNoYW5uZWxzTGFzdFwiKXRocm93IG5ldyBFcnJvcihgd2FzbSBiYWNrZW5kIERlcHRod2lzZUNvbnYyZE5hdGl2ZSBkb2VzIG5vdCBzdXBwb3J0IGRhdGFGb3JtYXQ6JyR7aC5kYXRhRm9ybWF0fScuIFBsZWFzZSB1c2UgJ2NoYW5uZWxzTGFzdCcuYCk7bGV0ICQ9YS5tYWtlT3V0cHV0KGgub3V0U2hhcGUsXCJmbG9hdDMyXCIpLFM9YS5kYXRhSWRNYXAuZ2V0KCQuZGF0YUlkKS5pZDtyZXR1cm4gJEYoaSxyLnNoYXBlWzBdLHIuc2hhcGVbMV0sci5zaGFwZVsyXSxvLG0sZixnLGIseSx4LEQsdixJLE4sQyxfLEYsUyksJH12YXIgVnBlPXtrZXJuZWxOYW1lOlVpLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpXcGUsa2VybmVsRnVuYzpCcGV9LERGO2Z1bmN0aW9uIFVwZShlKXtERj1lLndhc20uY3dyYXAoXCJEaWFnXCIsbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIEdwZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHt4OmF9PXQscj13LnNpemVGcm9tU2hhcGUoYS5zaGFwZSkscz1uLm1ha2VPdXRwdXQoWy4uLmEuc2hhcGUsLi4uYS5zaGFwZV0sYS5kdHlwZSk7cmV0dXJuIERGKG4uZGF0YUlkTWFwLmdldChhLmRhdGFJZCkuaWQsUWVbYS5kdHlwZV0scixuLmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkKSxzfXZhciBIcGU9e2tlcm5lbE5hbWU6TGMsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOlVwZSxrZXJuZWxGdW5jOkdwZX0sUkY7ZnVuY3Rpb24ganBlKGUpe1JGPWUud2FzbS5jd3JhcChHaSxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIHFwZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cixmaWx0ZXI6c309dCx7c3RyaWRlczppLHBhZDpvLGRpbGF0aW9uczpsfT1hO2lmKHIuZHR5cGUhPT1zLmR0eXBlKXRocm93IG5ldyBFcnJvcihgRGlsYXRpb24yRCBlcnJvcjogeCBtdXN0IGhhdmUgdGhlIHNhbWUgZHR5cGUgYXMgZmlsdGVyLiBHb3QgJHtyLmR0eXBlfSBhbmQgJHtzLmR0eXBlfWApO2xldCB1PVQuY29tcHV0ZURpbGF0aW9uMkRJbmZvKHIuc2hhcGUscy5zaGFwZSxpLG8sXCJOSFdDXCIsbCkscD1uLm1ha2VPdXRwdXQodS5vdXRTaGFwZSxyLmR0eXBlKTtyZXR1cm4gUkYobi5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZCxuLmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkLG4uZGF0YUlkTWFwLmdldChwLmRhdGFJZCkuaWQsUWVbci5kdHlwZV0sdS5iYXRjaFNpemUsdS5pbkNoYW5uZWxzLHUuaW5IZWlnaHQsdS5pbldpZHRoLHUub3V0SGVpZ2h0LHUub3V0V2lkdGgsdS5zdHJpZGVIZWlnaHQsdS5zdHJpZGVXaWR0aCx1LmRpbGF0aW9uSGVpZ2h0LHUuZGlsYXRpb25XaWR0aCx1LmZpbHRlckhlaWdodCx1LmZpbHRlcldpZHRoLHUucGFkSW5mby50b3AsdS5wYWRJbmZvLmxlZnQpLHB9dmFyIEtwZT17a2VybmVsTmFtZTpHaSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6anBlLGtlcm5lbEZ1bmM6cXBlfSxNRjtmdW5jdGlvbiBYcGUoZSl7TUY9ZS53YXNtLmN3cmFwKFJsLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBZcGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsZmlsdGVyOnMsZHk6aX09dCx7c3RyaWRlczpvLHBhZDpsLGRpbGF0aW9uczp1fT1hO2lmKHIuZHR5cGUhPT1zLmR0eXBlfHxyLmR0eXBlIT09aS5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoYERpbGF0aW9uMkRCYWNrcHJvcEZpbHRlciBlcnJvcjogeCBtdXN0IGhhdmUgdGhlIHNhbWUgZHR5cGUgYXMgZmlsdGVyIGFuZCBkeS4gR290ICR7ci5kdHlwZX0sICR7cy5kdHlwZX0sIGFuZCAke2kuZHR5cGV9YCk7bGV0IHA9VC5jb21wdXRlRGlsYXRpb24yREluZm8oci5zaGFwZSxzLnNoYXBlLG8sbCxcIk5IV0NcIix1KSxkPW4ubWFrZU91dHB1dChzLnNoYXBlLHMuZHR5cGUpO3JldHVybiBNRihuLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLG4uZGF0YUlkTWFwLmdldChzLmRhdGFJZCkuaWQsbi5kYXRhSWRNYXAuZ2V0KGkuZGF0YUlkKS5pZCxuLmRhdGFJZE1hcC5nZXQoZC5kYXRhSWQpLmlkLFFlW3IuZHR5cGVdLHAuYmF0Y2hTaXplLHAuaW5DaGFubmVscyxwLmluSGVpZ2h0LHAuaW5XaWR0aCxwLm91dEhlaWdodCxwLm91dFdpZHRoLHAuc3RyaWRlSGVpZ2h0LHAuc3RyaWRlV2lkdGgscC5kaWxhdGlvbkhlaWdodCxwLmRpbGF0aW9uV2lkdGgscC5maWx0ZXJIZWlnaHQscC5maWx0ZXJXaWR0aCxwLnBhZEluZm8udG9wLHAucGFkSW5mby5sZWZ0KSxkfXZhciBacGU9e2tlcm5lbE5hbWU6UmwsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOlhwZSxrZXJuZWxGdW5jOllwZX0sT0Y7ZnVuY3Rpb24gSnBlKGUpe09GPWUud2FzbS5jd3JhcChEbCxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gUXBlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyLGZpbHRlcjpzLGR5Oml9PXQse3N0cmlkZXM6byxwYWQ6bCxkaWxhdGlvbnM6dX09YTtpZihyLmR0eXBlIT09cy5kdHlwZXx8ci5kdHlwZSE9PWkuZHR5cGUpdGhyb3cgbmV3IEVycm9yKGBEaWxhdGlvbjJEQmFja3Byb3BJbnB1dCBlcnJvcjogeCBtdXN0IGhhdmUgdGhlIHNhbWUgZHR5cGUgYXMgZmlsdGVyIGFuZCBkeS4gR290ICR7ci5kdHlwZX0sICR7cy5kdHlwZX0sIGFuZCAke2kuZHR5cGV9YCk7bGV0IHA9VC5jb21wdXRlRGlsYXRpb24yREluZm8oci5zaGFwZSxzLnNoYXBlLG8sbCxcIk5IV0NcIix1KSxkPW4ubWFrZU91dHB1dChyLnNoYXBlLHIuZHR5cGUpO3JldHVybiBPRihuLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLG4uZGF0YUlkTWFwLmdldChzLmRhdGFJZCkuaWQsbi5kYXRhSWRNYXAuZ2V0KGkuZGF0YUlkKS5pZCxuLmRhdGFJZE1hcC5nZXQoZC5kYXRhSWQpLmlkLFFlW3IuZHR5cGVdLHAuYmF0Y2hTaXplLHAuaW5DaGFubmVscyxwLmluSGVpZ2h0LHAuaW5XaWR0aCxwLm91dEhlaWdodCxwLm91dFdpZHRoLHAuc3RyaWRlSGVpZ2h0LHAuc3RyaWRlV2lkdGgscC5kaWxhdGlvbkhlaWdodCxwLmRpbGF0aW9uV2lkdGgscC5maWx0ZXJIZWlnaHQscC5maWx0ZXJXaWR0aCxwLnBhZEluZm8udG9wLHAucGFkSW5mby5sZWZ0KSxkfXZhciBlY2U9e2tlcm5lbE5hbWU6RGwsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOkpwZSxrZXJuZWxGdW5jOlFwZX0sdGNlPVhlKGppKSxQRjtmdW5jdGlvbiBuY2UoZSl7UEY9ZS53YXNtLmN3cmFwKGN1LG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gYWNlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse2R5OmEseTpyfT10LHM9bi5tYWtlT3V0cHV0KHIuc2hhcGUsXCJmbG9hdDMyXCIpLGk9bz0+bi5kYXRhSWRNYXAuZ2V0KG8uZGF0YUlkKS5pZDtyZXR1cm4gUEYoaShyKSxpKGEpLGkocykpLHN9dmFyIHJjZT17a2VybmVsTmFtZTpjdSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6bmNlLGtlcm5lbEZ1bmM6YWNlfSxzY2U9ITEsaWNlPVV0KGR1LHNjZSxcImJvb2xcIiksb2NlPVhlKHFpKSxsY2U9WGUoS2ksXCJmbG9hdDMyXCIpO2Z1bmN0aW9uIHl2KGUpe2xldHtpbnB1dHM6dCxhdHRyczpuLGJhY2tlbmQ6YX09ZSx7aW5wdXQ6cn09dCx7ZGltOnN9PW4saT1yLnNoYXBlLmxlbmd0aCxvPXIuc2hhcGUuc2xpY2UoKSxsPXM7cmV0dXJuIHM8MCYmKHcuYXNzZXJ0KC0oaSsxKTw9cywoKT0+YEF4aXMgbXVzdCBiZSBpbiB0aGUgaW50ZXJ2YWwgWyR7LShpKzEpfSwgJHtpfV1gKSxsPWkrcysxKSxvLnNwbGljZShsLDAsMSksem4oe2lucHV0czp7eDpyfSxiYWNrZW5kOmEsYXR0cnM6e3NoYXBlOm99fSl9dmFyIHVjZT17a2VybmVsTmFtZTpodSxiYWNrZW5kTmFtZTpcIndhc21cIixrZXJuZWxGdW5jOnl2fSxwY2U9WGUoWGksXCJmbG9hdDMyXCIpO2Z1bmN0aW9uIExGKGUpe2xldHthdHRyczp7c2hhcGU6dCx2YWx1ZTpufSxiYWNrZW5kOmF9PWUse2F0dHJzOntkdHlwZTpyfX09ZTtyPXJ8fHcuaW5mZXJEdHlwZShuKTtsZXQgcz1hLm1ha2VPdXRwdXQodCxyKTtyZXR1cm4gYS50eXBlZEFycmF5RnJvbUhlYXAocykuZmlsbChuKSxzfXZhciBjY2U9e2tlcm5lbE5hbWU6emMsYmFja2VuZE5hbWU6XCJ3YXNtXCIsa2VybmVsRnVuYzpMRn0sekY7ZnVuY3Rpb24gZGNlKGUpe3pGPWUud2FzbS5jd3JhcChtdSxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIGhjZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHtpbWFnZTphfT10LHI9bi5tYWtlT3V0cHV0KGEuc2hhcGUsYS5kdHlwZSkscz1uLmRhdGFJZE1hcC5nZXQoYS5kYXRhSWQpLmlkLGk9bi5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZCxbbyxsLHUscF09YS5zaGFwZTtyZXR1cm4gekYocyxvLGwsdSxwLGkpLHJ9dmFyIG1jZT17a2VybmVsTmFtZTptdSxiYWNrZW5kTmFtZTpcIndhc21cIixrZXJuZWxGdW5jOmhjZSxzZXR1cEZ1bmM6ZGNlfSxmY2U9WGUoWWkpLGdjZT0hMSxiY2U9VXQoWmksZ2NlKSxXRjtmdW5jdGlvbiB5Y2UoZSl7V0Y9ZS53YXNtLmN3cmFwKEppLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiB4Y2UoZSl7bGV0e2JhY2tlbmQ6dCxpbnB1dHM6bixhdHRyczphfT1lLHt2YXJpYW5jZUVwc2lsb246cn09YSx7eDpzLG1lYW46aSx2YXJpYW5jZTpvLG9mZnNldDpsLHNjYWxlOnV9PW4scD10LmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkLGQ9dC5kYXRhSWRNYXAuZ2V0KGkuZGF0YUlkKS5pZCxjPXQuZGF0YUlkTWFwLmdldChvLmRhdGFJZCkuaWQsaD1sIT1udWxsP3QuZGF0YUlkTWFwLmdldChsLmRhdGFJZCkuaWQ6MCxtPXUhPW51bGw/dC5kYXRhSWRNYXAuZ2V0KHUuZGF0YUlkKS5pZDowLGY9dC5tYWtlT3V0cHV0KHMuc2hhcGUscy5kdHlwZSk7aWYody5zaXplRnJvbVNoYXBlKHMuc2hhcGUpPT09MClyZXR1cm4gZjtsZXQgZz10LmRhdGFJZE1hcC5nZXQoZi5kYXRhSWQpLmlkO3JldHVybiBXRihwLGQsYyxoLG0scixnKSxmfXZhciB2Y2U9e2tlcm5lbE5hbWU6SmksYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOnljZSxrZXJuZWxGdW5jOnhjZX0sQkY7ZnVuY3Rpb24gd2NlKGUpe0JGPWUud2FzbS5jd3JhcChvaSxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBrY2UoZSl7bGV0e2lucHV0czp0LGF0dHJzOm4sYmFja2VuZDphfT1lLHt4OnIsZmlsdGVyOnMsYmlhczppLHByZWx1QWN0aXZhdGlvbldlaWdodHM6b309dCx7c3RyaWRlczpsLHBhZDp1LGRpbGF0aW9uczpwLGRhdGFGb3JtYXQ6ZCxkaW1Sb3VuZGluZ01vZGU6YyxhY3RpdmF0aW9uOmgsbGVha3lyZWx1QWxwaGE6bX09bixmPVQuY29tcHV0ZUNvbnYyREluZm8oci5zaGFwZSxzLnNoYXBlLGwscCx1LGMpLGc9QWNbaF07aWYoZz09bnVsbCl0aHJvdyBuZXcgRXJyb3IoYCR7aH0gYWN0aXZhdGlvbiBub3QgeWV0IHN1cHBvcnRlZCBmb3IgRnVzZWRDb252MkQgaW4gdGhlIHdhc20gYmFja2VuZC5gKTtsZXQgYj1hLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLHk9YS5kYXRhSWRNYXAuZ2V0KHMuZGF0YUlkKS5pZCx4PWYub3V0Q2hhbm5lbHMsdj0wO2lmKGkhPW51bGwpe2xldCB0ZT1hLmRhdGFJZE1hcC5nZXQoaS5kYXRhSWQpO2lmKHRlLnNoYXBlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKGBGdXNlZENvbnYyRCBvbmx5IHN1cHBvcnRzIHJhbmstMSBiaWFzIGJ1dCBnb3QgcmFuayAke3RlLnNoYXBlLmxlbmd0aH0uYCk7aWYodGUuc2hhcGVbMF0hPT14KXRocm93IG5ldyBFcnJvcihgRnVzZWRDb252MkQgYmlhcyBzaGFwZSAoJHt0ZS5zaGFwZX0pIGRvZXMgbm90IG1hdGNoIHRoZSBudW1iZXIgb2Ygb3V0cHV0IGNoYW5uZWxzICgke3h9KWApO3Y9dGUuaWR9bGV0IEk9Zi5maWx0ZXJIZWlnaHQsTj1mLmZpbHRlcldpZHRoLEM9Zi5wYWRJbmZvLnRvcCxfPWYucGFkSW5mby5yaWdodCxGPWYucGFkSW5mby5ib3R0b20sRD1mLnBhZEluZm8ubGVmdCwkPWYuZGlsYXRpb25IZWlnaHQsUz1mLmRpbGF0aW9uV2lkdGgsTT1mLnN0cmlkZUhlaWdodCxCPWYuc3RyaWRlV2lkdGgsVT1mLmluQ2hhbm5lbHMsSD1mLnBhZEluZm8udHlwZT09PVwiU0FNRVwiPzE6MCxxPWYuYmF0Y2hTaXplLEs9Zi5pbkhlaWdodCxaPWYuaW5XaWR0aDtpZihkIT09XCJOSFdDXCIpdGhyb3cgbmV3IEVycm9yKGB3YXNtIGJhY2tlbmQgRnVzZWRDb252MkQgZG9lcyBub3Qgc3VwcG9ydCBkYXRhRm9ybWF0Oicke2R9Jy4gUGxlYXNlIHVzZSAnTkhXQycuYCk7bGV0IEo9YS5tYWtlT3V0cHV0KGYub3V0U2hhcGUsXCJmbG9hdDMyXCIpLGVlPWEuZGF0YUlkTWFwLmdldChKLmRhdGFJZCkuaWQsYWU9bz09bnVsbD8wOmEuZGF0YUlkTWFwLmdldChvLmRhdGFJZCkuaWQ7cmV0dXJuIEJGKGIscSxLLFoseSxJLE4sdixDLF8sRixELEgsJCxTLE0sQixVLHgsZyxhZSxtfHwwLGVlKSxKfXZhciBJY2U9e2tlcm5lbE5hbWU6b2ksYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOndjZSxrZXJuZWxGdW5jOmtjZX0sVkY7ZnVuY3Rpb24gU2NlKGUpe1ZGPWUud2FzbS5jd3JhcChsaSxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBOY2UoZSl7bGV0e2lucHV0czp0LGF0dHJzOm4sYmFja2VuZDphfT1lLHt4OnIsZmlsdGVyOnMsYmlhczppLHByZWx1QWN0aXZhdGlvbldlaWdodHM6b309dCx7c3RyaWRlczpsLHBhZDp1LGRpbGF0aW9uczpwLGRhdGFGb3JtYXQ6ZCxkaW1Sb3VuZGluZ01vZGU6YyxhY3RpdmF0aW9uOmgsbGVha3lyZWx1QWxwaGE6bX09bixmPVQuY29tcHV0ZUNvbnYyREluZm8oci5zaGFwZSxzLnNoYXBlLGwscCx1LGMsITApLGc9QWNbaF07aWYoZz09bnVsbCl0aHJvdyBuZXcgRXJyb3IoYCR7aH0gYWN0aXZhdGlvbiBub3QgeWV0IHN1cHBvcnRlZCBmb3IgRnVzZWREZXB0aHdpc2VDb252MkQgaW4gdGhlIHdhc20gYmFja2VuZC5gKTtsZXQgYj1hLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLHk9YS5kYXRhSWRNYXAuZ2V0KHMuZGF0YUlkKS5pZCx4PWYub3V0Q2hhbm5lbHMsdj0wO2lmKGkhPW51bGwpe2xldCB0ZT1hLmRhdGFJZE1hcC5nZXQoaS5kYXRhSWQpO2lmKHRlLnNoYXBlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKGBGdXNlZERlcHRod2lzZUNvbnYyRCBvbmx5IHN1cHBvcnRzIHJhbmstMSBiaWFzIGJ1dCBnb3QgcmFuayAke3RlLnNoYXBlLmxlbmd0aH0uYCk7aWYodGUuc2hhcGVbMF0hPT14KXRocm93IG5ldyBFcnJvcihgRnVzZWREZXB0aHdpc2VDb252MkQgYmlhcyBzaGFwZSAoJHt0ZS5zaGFwZX0pIGRvZXMgbm90IG1hdGNoIHRoZSBudW1iZXIgb2Ygb3V0cHV0IGNoYW5uZWxzICgke3h9KWApO3Y9dGUuaWR9bGV0IEk9Zi5maWx0ZXJIZWlnaHQsTj1mLmZpbHRlcldpZHRoLEM9Zi5wYWRJbmZvLnRvcCxfPWYucGFkSW5mby5yaWdodCxGPWYucGFkSW5mby5ib3R0b20sRD1mLnBhZEluZm8ubGVmdCwkPWYuZGlsYXRpb25IZWlnaHQsUz1mLmRpbGF0aW9uV2lkdGgsTT1mLnN0cmlkZUhlaWdodCxCPWYuc3RyaWRlV2lkdGgsVT1mLmluQ2hhbm5lbHMsSD1mLnBhZEluZm8udHlwZT09PVwiU0FNRVwiPzE6MCxxPWYuYmF0Y2hTaXplLEs9Zi5pbkhlaWdodCxaPWYuaW5XaWR0aDtpZihkIT09XCJOSFdDXCIpdGhyb3cgbmV3IEVycm9yKGB3YXNtIGJhY2tlbmQgRnVzZWREZXB0aHdpc2VDb252MkQgZG9lcyBub3Qgc3VwcG9ydCBkYXRhRm9ybWF0Oicke2R9Jy4gUGxlYXNlIHVzZSAnTkhXQycuYCk7bGV0IEo9YS5tYWtlT3V0cHV0KGYub3V0U2hhcGUsXCJmbG9hdDMyXCIpLGVlPWEuZGF0YUlkTWFwLmdldChKLmRhdGFJZCkuaWQsYWU9bz09bnVsbD8wOmEuZGF0YUlkTWFwLmdldChvLmRhdGFJZCkuaWQ7cmV0dXJuIFZGKGIscSxLLFoseSxJLE4sdixDLF8sRixELEgsJCxTLE0sQixVLHgsZyxhZSxtfHwwLGVlKSxKfXZhciBUY2U9e2tlcm5lbE5hbWU6bGksYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOlNjZSxrZXJuZWxGdW5jOk5jZX0sVUY7ZnVuY3Rpb24gQ2NlKGUpe1VGPWUud2FzbS5jd3JhcChndSxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcImFycmF5XCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIEVjZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpufT1lLHtwYXJhbXM6YSxpbmRpY2VzOnJ9PW4sW3MsaSxvLGxdPVl3LnByZXBhcmVBbmRWYWxpZGF0ZShhLHIpLHU9dC5tYWtlT3V0cHV0KHMsYS5kdHlwZSk7aWYoaT09PTApcmV0dXJuIHU7bGV0IHA9ci5zaGFwZSxkPXBbcC5sZW5ndGgtMV0sYz10LmRhdGFJZE1hcC5nZXQoYS5kYXRhSWQpLmlkLGg9dC5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZCxtPW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KGwpLmJ1ZmZlciksZj10LmRhdGFJZE1hcC5nZXQodS5kYXRhSWQpLmlkO3JldHVybiBVRihjLFFlW2EuZHR5cGVdLGgsaSxkLG8sbSxmKSx1fXZhciBfY2U9e2tlcm5lbE5hbWU6Z3UsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOkNjZSxrZXJuZWxGdW5jOkVjZX0sR0Y7ZnVuY3Rpb24gQWNlKGUpe0dGPWUud2FzbS5jd3JhcChcIkdhdGhlclwiLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcImFycmF5XCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJhcnJheVwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBGY2UoZSl7bGV0e2JhY2tlbmQ6dCxpbnB1dHM6bixhdHRyczphfT1lLHt4OnIsaW5kaWNlczpzfT1uLHtheGlzOmksYmF0Y2hEaW1zOm99PWEsbD13LnBhcnNlQXhpc1BhcmFtKGksci5zaGFwZSlbMF0sdT10LnJlYWRTeW5jKHMuZGF0YUlkKSxwPXIuc2hhcGVbbF07Zm9yKGxldCBDPTA7Qzx1Lmxlbmd0aDsrK0Mpe2xldCBfPXVbQ107dy5hc3NlcnQoXzw9cC0xJiZfPj0wLCgpPT5gR2F0aGVyVjI6IHRoZSBpbmRleCB2YWx1ZSAke199IGlzIG5vdCBpbiBbMCwgJHtwLTF9XWApfWxldCBkPVQuc2VnbWVudF91dGlsLmNvbGxlY3RHYXRoZXJPcFNoYXBlSW5mbyhyLHMsbCxvKSxjPXpuKHtpbnB1dHM6e3g6cn0sYXR0cnM6e3NoYXBlOltkLmJhdGNoU2l6ZSxkLm91dGVyU2l6ZSxkLmRpbVNpemUsZC5zbGljZVNpemVdfSxiYWNrZW5kOnR9KSxoPXcuc2l6ZUZyb21TaGFwZShzLnNoYXBlKSxtPXpuKHtpbnB1dHM6e3g6c30sYXR0cnM6e3NoYXBlOltkLmJhdGNoU2l6ZSxoL2QuYmF0Y2hTaXplXX0sYmFja2VuZDp0fSksZj1bZC5iYXRjaFNpemUsZC5vdXRlclNpemUsaC9kLmJhdGNoU2l6ZSxkLnNsaWNlU2l6ZV0sZz10Lm1ha2VPdXRwdXQoZixyLmR0eXBlKTtpZih3LnNpemVGcm9tU2hhcGUoci5zaGFwZSk9PT0wKXJldHVybiBnO2xldCBiPWMuc2hhcGUubGVuZ3RoLTEseT10LmRhdGFJZE1hcC5nZXQoYy5kYXRhSWQpLmlkLHg9dC5kYXRhSWRNYXAuZ2V0KG0uZGF0YUlkKS5pZCx2PXQuZGF0YUlkTWFwLmdldChnLmRhdGFJZCkuaWQsST1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheSh3LmNvbXB1dGVTdHJpZGVzKGMuc2hhcGUpKS5idWZmZXIpLE49bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkody5jb21wdXRlU3RyaWRlcyhmKSkuYnVmZmVyKTtyZXR1cm4gR0YoeSxRZVtyLmR0eXBlXSxJLGIseCxkLmJhdGNoU2l6ZSxOLHYpLHQuZGlzcG9zZURhdGEoYy5kYXRhSWQpLHQuZGlzcG9zZURhdGEobS5kYXRhSWQpLGcuc2hhcGU9ZC5vdXRwdXRTaGFwZSxnfXZhciAkY2U9e2tlcm5lbE5hbWU6ZnUsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOkFjZSxrZXJuZWxGdW5jOkZjZX0sRGNlPSExLFJjZT1VdChidSxEY2UsXCJib29sXCIpLE1jZT0hMSxPY2U9VXQoUWksTWNlLFwiYm9vbFwiKSxQY2U9WGUodG8sXCJib29sXCIpLExjZT1YZShubyxcImJvb2xcIiksemNlPVhlKGFvLFwiYm9vbFwiKSxIRjtmdW5jdGlvbiBXY2UoZSl7SEY9ZS53YXNtLmN3cmFwKHJvLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBCY2UoZSl7bGV0e2lucHV0czp7eDp0fSxhdHRyczp7YWxwaGE6bn0sYmFja2VuZDphfT1lLHI9YS5kYXRhSWRNYXAuZ2V0KHQuZGF0YUlkKS5pZCxzPWEubWFrZU91dHB1dCh0LnNoYXBlLFwiZmxvYXQzMlwiKTtpZih3LnNpemVGcm9tU2hhcGUodC5zaGFwZSkhPT0wKXtsZXQgaT1hLmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkO0hGKHIsUWVbdC5kdHlwZV0sbixpKX1yZXR1cm4gc312YXIgVmNlPXtrZXJuZWxOYW1lOnJvLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpXY2Usa2VybmVsRnVuYzpCY2V9LFVjZT0hMSxHY2U9VXQoeXUsVWNlLFwiYm9vbFwiKSxIY2U9ITEsamNlPVV0KHh1LEhjZSxcImJvb2xcIiksakY7ZnVuY3Rpb24gcWNlKGUpe2pGPWUud2FzbS5jd3JhcCh2dSxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gS2NlKGUpe2xldHthdHRyczp0LGJhY2tlbmQ6bn09ZSx7c3RhcnQ6YSxzdG9wOnIsbnVtOnN9PXQsaT1NYXRoLmZsb29yKHMpLG89bi5tYWtlT3V0cHV0KFtpXSxcImZsb2F0MzJcIik7cmV0dXJuIGpGKG4uZGF0YUlkTWFwLmdldChvLmRhdGFJZCkuaWQsYSxyLGkpLG99dmFyIFhjZT17a2VybmVsTmFtZTp2dSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6cWNlLGtlcm5lbEZ1bmM6S2NlfSxZY2U9WGUoc28pLFpjZT1YZShpbyksSmNlPSExLFFjZT1VdCh3dSxKY2UsXCJib29sXCIpLGVkZT1YZShrdSksdGRlPSExLG5kZT1VdChJdSx0ZGUsXCJib29sXCIpLGFkZT0hMSxyZGU9VXQoalMsYWRlLFwiYm9vbFwiKSxxRjtmdW5jdGlvbiBzZGUoZSl7cUY9ZS53YXNtLmN3cmFwKG9vLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBpZGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2RlcHRoUmFkaXVzOnMsYmlhczppLGFscGhhOm8sYmV0YTpsfT1hO2lmKHIuZHR5cGUhPT1cImZsb2F0MzJcIil0aHJvdyBuZXcgRXJyb3IoXCJMUk4gZXJyb3I6IHggbXVzdCBoYXZlIGR0eXBlIGZsb2F0MzJcIik7bGV0IHU9bi5tYWtlT3V0cHV0KHIuc2hhcGUsci5kdHlwZSk7cmV0dXJuIHFGKG4uZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsbi5kYXRhSWRNYXAuZ2V0KHUuZGF0YUlkKS5pZCxyLnNoYXBlWzNdLHMsaSxvLGwpLHV9dmFyIG9kZT17a2VybmVsTmFtZTpvbyxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6c2RlLGtlcm5lbEZ1bmM6aWRlfSxLRjtmdW5jdGlvbiBsZGUoZSl7S0Y9ZS53YXNtLmN3cmFwKFN1LG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gdWRlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyLHk6cyxkeTppfT10LHtkZXB0aFJhZGl1czpvLGJpYXM6bCxhbHBoYTp1LGJldGE6cH09YTtpZihyLmR0eXBlIT09XCJmbG9hdDMyXCJ8fHMuZHR5cGUhPT1cImZsb2F0MzJcInx8aS5kdHlwZSE9PVwiZmxvYXQzMlwiKXRocm93IG5ldyBFcnJvcihcIkxSTkdyYWQgZXJyb3I6IHgsIHksIGFuZCBkeSBtdXN0IGhhdmUgZHR5cGUgZmxvYXQzMlwiKTtsZXQgZD1uLm1ha2VPdXRwdXQoci5zaGFwZSxyLmR0eXBlKTtyZXR1cm4gS0Yobi5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZCxuLmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkLG4uZGF0YUlkTWFwLmdldChpLmRhdGFJZCkuaWQsbi5kYXRhSWRNYXAuZ2V0KGQuZGF0YUlkKS5pZCxpLnNoYXBlWzNdLG8sbCx1LHApLGR9dmFyIHBkZT17a2VybmVsTmFtZTpTdSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6bGRlLGtlcm5lbEZ1bmM6dWRlfSxYRjtmdW5jdGlvbiBjZGUoZSl7WEY9ZS53YXNtLmN3cmFwKGxvLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBkZGUoZSl7bGV0e2JhY2tlbmQ6dCxpbnB1dHM6bixhdHRyczphfT1lLHtyZWR1Y3Rpb25JbmRpY2VzOnIsa2VlcERpbXM6c309YSx7eDppfT1uLG89dC5kYXRhSWRNYXAuZ2V0KGkuZGF0YUlkKS5pZCxsPWkse3RyYW5zcG9zZWQ6dSxheGVzOnAsb3JpZ2luYWxBeGVzOmQsaW5wdXRXYXNUcmFuc3Bvc2VkOmN9PURzKGkscix0KTtpZihjKXtsZXQgeT10LmRhdGFJZE1hcC5nZXQodS5kYXRhSWQpLmlkO2w9dSxvPXl9bGV0IGg9bC5zaGFwZS5sZW5ndGg7VC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcIm1heFwiLHAsaCk7bGV0W20sZl09VC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGwuc2hhcGUscCksZz13LnNpemVGcm9tU2hhcGUoZiksYj10Lm1ha2VPdXRwdXQobSxpLmR0eXBlKTtpZih3LnNpemVGcm9tU2hhcGUobC5zaGFwZSkhPT0wKXtsZXQgeT10LmRhdGFJZE1hcC5nZXQoYi5kYXRhSWQpLmlkO1hGKG8sUWVbaS5kdHlwZV0sZyx5KX1pZihjJiZ0LmRpc3Bvc2VEYXRhKHUuZGF0YUlkKSxzKXtsZXQgeT1ULmV4cGFuZFNoYXBlVG9LZWVwRGltKGIuc2hhcGUsZCk7Yi5zaGFwZT15fXJldHVybiBifXZhciBoZGU9e2tlcm5lbE5hbWU6bG8sYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOmNkZSxrZXJuZWxGdW5jOmRkZX0sbWRlPSExLGZkZT1VdCh1byxtZGUpLFlGO2Z1bmN0aW9uIGdkZShlKXtZRj1lLndhc20uY3dyYXAocG8sbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gYmRlKGUpe2xldHtpbnB1dHM6dCxhdHRyczpuLGJhY2tlbmQ6YX09ZSxyPXQueCxzPWEuZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQ7dy5hc3NlcnQoci5kdHlwZT09PVwiZmxvYXQzMlwiLCgpPT5gRXJyb3IgaW4gTWF4UG9vbDogb25seSBmbG9hdDMyIGlucHV0IGlzIHN1cHBvcnRlZC4gR290ICR7ci5kdHlwZX0uYCk7bGV0e2ZpbHRlclNpemU6aSxzdHJpZGVzOm8scGFkOmwsZGltUm91bmRpbmdNb2RlOnV9PW4scD1ULmNvbXB1dGVQb29sMkRJbmZvKHIuc2hhcGUsaSxvLDEsbCx1KSxkPXAuZmlsdGVySGVpZ2h0LGM9cC5maWx0ZXJXaWR0aCxoPXAucGFkSW5mby50b3AsbT1wLnBhZEluZm8ucmlnaHQsZj1wLnBhZEluZm8uYm90dG9tLGc9cC5wYWRJbmZvLmxlZnQsYj1wLmRpbGF0aW9uSGVpZ2h0LHk9cC5kaWxhdGlvbldpZHRoLHg9cC5zdHJpZGVIZWlnaHQsdj1wLnN0cmlkZVdpZHRoLEk9cC5pbkNoYW5uZWxzLE49cC5vdXRDaGFubmVscztpZihwLmRhdGFGb3JtYXQhPT1cImNoYW5uZWxzTGFzdFwiKXRocm93IG5ldyBFcnJvcihgd2FzbSBiYWNrZW5kIGRvZXMgbm90IHN1cHBvcnQgZGF0YUZvcm1hdDonJHtwLmRhdGFGb3JtYXR9Jy4gUGxlYXNlIHVzZSAnY2hhbm5lbHNMYXN0Jy5gKTtsZXQgQz1hLm1ha2VPdXRwdXQocC5vdXRTaGFwZSxcImZsb2F0MzJcIiksXz1hLmRhdGFJZE1hcC5nZXQoQy5kYXRhSWQpLmlkO3JldHVybiBZRihzLHIuc2hhcGVbMF0sci5zaGFwZVsxXSxyLnNoYXBlWzJdLGQsYyxoLG0sZixnLGIseSx4LHYsSSxOLF8pLEN9dmFyIHlkZT17a2VybmVsTmFtZTpwbyxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6Z2RlLGtlcm5lbEZ1bmM6YmRlfSxaRjtmdW5jdGlvbiB4ZGUoZSl7WkY9ZS53YXNtLmN3cmFwKFwiTWF4UG9vbDNEXCIsbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIHZkZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7ZmlsdGVyU2l6ZTpzLHN0cmlkZXM6aSxwYWQ6byxkaW1Sb3VuZGluZ01vZGU6bCxkYXRhRm9ybWF0OnV9PWEscD1ULmNvbXB1dGVQb29sM0RJbmZvKHIuc2hhcGUscyxpLDEsbyxsLHUpLGQ9bi5tYWtlT3V0cHV0KHAub3V0U2hhcGUsci5kdHlwZSk7cmV0dXJuIFpGKG4uZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsbi5kYXRhSWRNYXAuZ2V0KGQuZGF0YUlkKS5pZCxwLmJhdGNoU2l6ZSxwLmluQ2hhbm5lbHMscC5pbkRlcHRoLHAuaW5IZWlnaHQscC5pbldpZHRoLHAub3V0RGVwdGgscC5vdXRIZWlnaHQscC5vdXRXaWR0aCxwLnN0cmlkZURlcHRoLHAuc3RyaWRlSGVpZ2h0LHAuc3RyaWRlV2lkdGgscC5kaWxhdGlvbkRlcHRoLHAuZGlsYXRpb25IZWlnaHQscC5kaWxhdGlvbldpZHRoLHAuZWZmZWN0aXZlRmlsdGVyRGVwdGgscC5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQscC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxwLnBhZEluZm8uZnJvbnQscC5wYWRJbmZvLnRvcCxwLnBhZEluZm8ubGVmdCksZH12YXIgd2RlPXtrZXJuZWxOYW1lOk51LGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzp4ZGUsa2VybmVsRnVuYzp2ZGV9LEpGO2Z1bmN0aW9uIGtkZShlKXtKRj1lLndhc20uY3dyYXAoXCJNYXhQb29sM0RHcmFkXCIsbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gSWRlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7ZHk6cixpbnB1dDpzfT10LHtmaWx0ZXJTaXplOmksc3RyaWRlczpvLHBhZDpsLGRpbVJvdW5kaW5nTW9kZTp1fT1hLHA9VC5jb21wdXRlUG9vbDNESW5mbyhzLnNoYXBlLGksbywxLGwsdSksZD1uLm1ha2VPdXRwdXQocy5zaGFwZSxzLmR0eXBlKTtyZXR1cm4gSkYobi5kYXRhSWRNYXAuZ2V0KHMuZGF0YUlkKS5pZCxuLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLG4uZGF0YUlkTWFwLmdldChkLmRhdGFJZCkuaWQscC5iYXRjaFNpemUscC5pbkNoYW5uZWxzLHAuaW5EZXB0aCxwLmluSGVpZ2h0LHAuaW5XaWR0aCxwLm91dERlcHRoLHAub3V0SGVpZ2h0LHAub3V0V2lkdGgscC5zdHJpZGVEZXB0aCxwLnN0cmlkZUhlaWdodCxwLnN0cmlkZVdpZHRoLHAuZGlsYXRpb25EZXB0aCxwLmRpbGF0aW9uSGVpZ2h0LHAuZGlsYXRpb25XaWR0aCxwLmVmZmVjdGl2ZUZpbHRlckRlcHRoLHAuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LHAuZWZmZWN0aXZlRmlsdGVyV2lkdGgscC5wYWRJbmZvLmZyb250LHAucGFkSW5mby50b3AscC5wYWRJbmZvLmxlZnQpLGR9dmFyIFNkZT17a2VybmVsTmFtZTpCYyxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6a2RlLGtlcm5lbEZ1bmM6SWRlfSxRRjtmdW5jdGlvbiBOZGUoZSl7UUY9ZS53YXNtLmN3cmFwKFwiTWF4UG9vbEdyYWRcIixudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBUZGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtkeTpyLGlucHV0OnN9PXQse2ZpbHRlclNpemU6aSxzdHJpZGVzOm8scGFkOmwsZGltUm91bmRpbmdNb2RlOnV9PWEscD1ULmNvbXB1dGVQb29sMkRJbmZvKHMuc2hhcGUsaSxvLDEsbCx1KSxkPW4ubWFrZU91dHB1dChzLnNoYXBlLHMuZHR5cGUpO3JldHVybiBRRihuLmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkLG4uZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsbi5kYXRhSWRNYXAuZ2V0KGQuZGF0YUlkKS5pZCxwLmJhdGNoU2l6ZSxwLmluQ2hhbm5lbHMscC5pbkhlaWdodCxwLmluV2lkdGgscC5vdXRIZWlnaHQscC5vdXRXaWR0aCxwLnN0cmlkZUhlaWdodCxwLnN0cmlkZVdpZHRoLHAuZGlsYXRpb25IZWlnaHQscC5kaWxhdGlvbldpZHRoLHAuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LHAuZWZmZWN0aXZlRmlsdGVyV2lkdGgscC5wYWRJbmZvLnRvcCxwLnBhZEluZm8ubGVmdCksZH12YXIgQ2RlPXtrZXJuZWxOYW1lOldjLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpOZGUsa2VybmVsRnVuYzpUZGV9LGUkO2Z1bmN0aW9uIEVkZShlKXtlJD1lLndhc20uY3dyYXAoXCJNYXhQb29sV2l0aEFyZ21heFwiLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJib29sZWFuXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gX2RlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtmaWx0ZXJTaXplOnMsc3RyaWRlczppLHBhZDpvLGluY2x1ZGVCYXRjaEluSW5kZXg6bH09YTt3LmFzc2VydChyLnNoYXBlLmxlbmd0aD09PTQsKCk9PmBFcnJvciBpbiBtYXhQb29sOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgJHtyLnNoYXBlLmxlbmd0aH0uYCk7bGV0IHU9WzEsMV07dy5hc3NlcnQoVC5laXRoZXJTdHJpZGVzT3JEaWxhdGlvbnNBcmVPbmUoaSx1KSwoKT0+YEVycm9yIGluIG1heFBvb2w6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzICR7aX0gYW5kIGRpbGF0aW9ucyAnJHt1fSdgKTtsZXQgcD1ULmNvbXB1dGVQb29sMkRJbmZvKHIuc2hhcGUscyxpLFsxLDFdLG8pLGQ9bi5tYWtlT3V0cHV0KHAub3V0U2hhcGUsci5kdHlwZSksYz1uLm1ha2VPdXRwdXQocC5vdXRTaGFwZSxcImludDMyXCIpO3JldHVybiBlJChuLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLG4uZGF0YUlkTWFwLmdldChkLmRhdGFJZCkuaWQsbi5kYXRhSWRNYXAuZ2V0KGMuZGF0YUlkKS5pZCxRZVtyLmR0eXBlXSxsLHAuYmF0Y2hTaXplLHAuaW5DaGFubmVscyxwLmluSGVpZ2h0LHAuaW5XaWR0aCxwLm91dEhlaWdodCxwLm91dFdpZHRoLHAuc3RyaWRlSGVpZ2h0LHAuc3RyaWRlV2lkdGgscC5kaWxhdGlvbkhlaWdodCxwLmRpbGF0aW9uV2lkdGgscC5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQscC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxwLnBhZEluZm8udG9wLHAucGFkSW5mby5sZWZ0KSxbZCxjXX12YXIgQWRlPXtrZXJuZWxOYW1lOlZjLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpFZGUsa2VybmVsRnVuYzpfZGV9LHQkO2Z1bmN0aW9uIEZkZShlKXt0JD1lLndhc20uY3dyYXAoY28sbnVsbCxbXCJudW1iZXIsIG51bWJlciwgbnVtYmVyXCJdKX1mdW5jdGlvbiAkZGUoZSl7bGV0e2JhY2tlbmQ6dCxpbnB1dHM6bixhdHRyczphfT1lLHtheGlzOnIsa2VlcERpbXM6c309YSx7eDppfT1uLG89dC5kYXRhSWRNYXAuZ2V0KGkuZGF0YUlkKS5pZCxsPW8sdT1pLHt0cmFuc3Bvc2VkOnAsYXhlczpkLG9yaWdpbmFsQXhlczpjLGlucHV0V2FzVHJhbnNwb3NlZDpofT1EcyhpLHIsdCksbT1kO2lmKGgpe2xldCB2PXQuZGF0YUlkTWFwLmdldChwLmRhdGFJZCkuaWQ7diE9PW8mJih1PXAsbD12LG09VC5nZXRJbm5lck1vc3RBeGVzKG0ubGVuZ3RoLHUuc2hhcGUubGVuZ3RoKSl9VC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcIm1lYW5cIixtLHUuc2hhcGUubGVuZ3RoKTtsZXRbZixnXT1ULmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXModS5zaGFwZSxtKSxiPXcuc2l6ZUZyb21TaGFwZShnKSx5PXU7dS5kdHlwZSE9PVwiZmxvYXQzMlwiJiYoeT1Scyh7YmFja2VuZDp0LGlucHV0czp7eDp1fSxhdHRyczp7ZHR5cGU6XCJmbG9hdDMyXCJ9fSksbD10LmRhdGFJZE1hcC5nZXQoeS5kYXRhSWQpLmlkKTtsZXQgeD10Lm1ha2VPdXRwdXQoZixcImZsb2F0MzJcIik7aWYody5zaXplRnJvbVNoYXBlKHUuc2hhcGUpIT09MCl7bGV0IHY9dC5kYXRhSWRNYXAuZ2V0KHguZGF0YUlkKS5pZDt0JChsLGIsdil9aWYoaCYmdC5kaXNwb3NlRGF0YShwLmRhdGFJZCkscyl7bGV0IHY9VC5leHBhbmRTaGFwZVRvS2VlcERpbSh4LnNoYXBlLGMpO3guc2hhcGU9dn1yZXR1cm4gdS5kdHlwZSE9PVwiZmxvYXQzMlwiJiZ0LmRpc3Bvc2VEYXRhKHkuZGF0YUlkKSx4fXZhciBEZGU9e2tlcm5lbE5hbWU6Y28sYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOkZkZSxrZXJuZWxGdW5jOiRkZX0sbiQ7ZnVuY3Rpb24gUmRlKGUpe24kPWUud2FzbS5jd3JhcChobyxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gTWRlKGUpe2xldHtiYWNrZW5kOnQsaW5wdXRzOm4sYXR0cnM6YX09ZSx7YXhpczpyLGtlZXBEaW1zOnN9PWEse3g6aX09bixvPXQuZGF0YUlkTWFwLmdldChpLmRhdGFJZCkuaWQsbD1vLHU9aSx7dHJhbnNwb3NlZDpwLGF4ZXM6ZCxvcmlnaW5hbEF4ZXM6YyxpbnB1dFdhc1RyYW5zcG9zZWQ6aH09RHMoaSxyLHQpO2lmKGgpe2xldCB4PXQuZGF0YUlkTWFwLmdldChwLmRhdGFJZCkuaWQ7eCE9PW8mJih1PXAsbD14KX1sZXQgbT11LnNoYXBlLmxlbmd0aDtULmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwibWluXCIsZCxtKTtsZXRbZixnXT1ULmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXModS5zaGFwZSxkKSxiPXcuc2l6ZUZyb21TaGFwZShnKSx5PXQubWFrZU91dHB1dChmLHUuZHR5cGUpO2lmKHcuc2l6ZUZyb21TaGFwZSh1LnNoYXBlKSE9PTApe2xldCB4PXQuZGF0YUlkTWFwLmdldCh5LmRhdGFJZCkuaWQ7biQobCxRZVtpLmR0eXBlXSxiLHgpfWlmKGgmJnQuZGlzcG9zZURhdGEocC5kYXRhSWQpLHMpe2xldCB4PVQuZXhwYW5kU2hhcGVUb0tlZXBEaW0oeS5zaGFwZSxjKTt5LnNoYXBlPXh9cmV0dXJuIHl9dmFyIE9kZT17a2VybmVsTmFtZTpobyxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6UmRlLGtlcm5lbEZ1bmM6TWRlfSxQZGU9ITEsTGRlPVV0KG1vLFBkZSkseHY7KGZ1bmN0aW9uKGUpe2VbZS5yZWZsZWN0PTBdPVwicmVmbGVjdFwiLGVbZS5zeW1tZXRyaWM9MV09XCJzeW1tZXRyaWNcIn0pKHh2fHwoeHY9e30pKTt2YXIgYSQ7ZnVuY3Rpb24gemRlKGUpe2EkPWUud2FzbS5jd3JhcChmbyxudWxsLFtcIm51bWJlclwiLFwiYXJyYXlcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJhcnJheVwiLFwiYXJyYXlcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBXZGUoZSl7bGV0e2lucHV0czp7eDp0fSxiYWNrZW5kOm4sYXR0cnM6e3BhZGRpbmdzOmEsbW9kZTpyfX09ZSxzPWEubWFwKChtLGYpPT5tWzBdK3Quc2hhcGVbZl0rbVsxXSksaT1uLmRhdGFJZE1hcC5nZXQodC5kYXRhSWQpLmlkLG89bi5tYWtlT3V0cHV0KHMsdC5kdHlwZSksbD1uLmRhdGFJZE1hcC5nZXQoby5kYXRhSWQpLmlkLHU9bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkodC5zaGFwZSkuYnVmZmVyKSxwPWEubWFwKG09Pm1bMF0pLGQ9YS5tYXAobT0+bVsxXSksYz1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheShwKS5idWZmZXIpLGg9bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkoZCkuYnVmZmVyKTtyZXR1cm4gYSQoaSx1LHQuc2hhcGUubGVuZ3RoLFFlW3QuZHR5cGVdLGMsaCx4dltyXSxsKSxvfXZhciBCZGU9e2tlcm5lbE5hbWU6Zm8sYmFja2VuZE5hbWU6XCJ3YXNtXCIsa2VybmVsRnVuYzpXZGUsc2V0dXBGdW5jOnpkZX0sciQ7ZnVuY3Rpb24gVmRlKGUpe3IkPWUud2FzbS5jd3JhcCh6byxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gcyQoZSl7bGV0e2JhY2tlbmQ6dCxpbnB1dHM6e2xvZ2l0czpufSxhdHRyczp7ZGltOmF9fT1lLHI9dC5kYXRhSWRNYXAuZ2V0KG4uZGF0YUlkKS5pZCxzPXQubWFrZU91dHB1dChuLnNoYXBlLG4uZHR5cGUpLGk9dC5kYXRhSWRNYXAuZ2V0KHMuZGF0YUlkKS5pZCxvPW4uc2hhcGVbYV0sbD13LnNpemVGcm9tU2hhcGUobi5zaGFwZSkvbztyZXR1cm4gdy5zaXplRnJvbVNoYXBlKHMuc2hhcGUpPT09MHx8ciQocixpLG8sbCksc312YXIgVWRlPXtrZXJuZWxOYW1lOnpvLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpWZGUsa2VybmVsRnVuYzpzJH0saSQ7ZnVuY3Rpb24gR2RlKGUpe2kkPWUud2FzbS5jd3JhcChUdSxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIEhkZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2xvZ2l0czpyfT10LHtudW1TYW1wbGVzOnMsc2VlZDppLG5vcm1hbGl6ZWQ6b309YTtpZihyLmR0eXBlIT09XCJmbG9hdDMyXCIpdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IgbG9naXRzIG11c3QgaGF2ZSBkdHlwZSBmbG9hdDMyLCBnb3QgJHtyLmR0eXBlfWApO2xldCBsPW8/cjpzJCh7aW5wdXRzOntsb2dpdHM6cn0sYmFja2VuZDpuLGF0dHJzOntkaW06ci5zaGFwZS5sZW5ndGgtMX19KSxbdSxwXT1sLnNoYXBlLGQ9bi5tYWtlT3V0cHV0KFt1LHNdLFwiaW50MzJcIik7cmV0dXJuIGkkKG4uZGF0YUlkTWFwLmdldChsLmRhdGFJZCkuaWQsdSxwLHMsaSxuLmRhdGFJZE1hcC5nZXQoZC5kYXRhSWQpLmlkKSxvfHxuLmRpc3Bvc2VEYXRhKGwuZGF0YUlkKSxkfXZhciBqZGU9e2tlcm5lbE5hbWU6VHUsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOkdkZSxrZXJuZWxGdW5jOkhkZX0scWRlPVV0KGdvLCEwKSxLZGU9ITAsWGRlPVV0KGJvLEtkZSksWWRlPVhlKEN1KTtmdW5jdGlvbiBoayhlLHQpe2xldCBuPW5ldyBJbnQzMkFycmF5KGUud2FzbS5IRUFQVTguYnVmZmVyLHQsNCksYT1uWzBdLHI9blsxXSxzPW5bMl0saT1uWzNdO3JldHVybiBlLndhc20uX2ZyZWUodCkse3BTZWxlY3RlZEluZGljZXM6YSxzZWxlY3RlZFNpemU6cixwU2VsZWN0ZWRTY29yZXM6cyxwVmFsaWRPdXRwdXRzOml9fXZhciBvJDtmdW5jdGlvbiBaZGUoZSl7byQ9ZS53YXNtLmN3cmFwKF91LFwibnVtYmVyXCIsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIEpkZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpuLGF0dHJzOmF9PWUse2lvdVRocmVzaG9sZDpyLG1heE91dHB1dFNpemU6cyxzY29yZVRocmVzaG9sZDppfT1hLHtib3hlczpvLHNjb3JlczpsfT1uLHU9dC5kYXRhSWRNYXAuZ2V0KG8uZGF0YUlkKS5pZCxwPXQuZGF0YUlkTWFwLmdldChsLmRhdGFJZCkuaWQsZD1vJCh1LHAscyxyLGkpLHtwU2VsZWN0ZWRJbmRpY2VzOmMsc2VsZWN0ZWRTaXplOmgscFNlbGVjdGVkU2NvcmVzOm0scFZhbGlkT3V0cHV0czpmfT1oayh0LGQpO3JldHVybiB0Lndhc20uX2ZyZWUobSksdC53YXNtLl9mcmVlKGYpLHQubWFrZU91dHB1dChbaF0sXCJpbnQzMlwiLGMpfXZhciBRZGU9e2tlcm5lbE5hbWU6X3UsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOlpkZSxrZXJuZWxGdW5jOkpkZX0sbCQ7ZnVuY3Rpb24gZWhlKGUpe2wkPWUud2FzbS5jd3JhcChBdSxcIm51bWJlclwiLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJib29sXCJdKX1mdW5jdGlvbiB0aGUoZSl7bGV0e2JhY2tlbmQ6dCxpbnB1dHM6bixhdHRyczphfT1lLHtpb3VUaHJlc2hvbGQ6cixtYXhPdXRwdXRTaXplOnMsc2NvcmVUaHJlc2hvbGQ6aSxwYWRUb01heE91dHB1dFNpemU6b309YSx7Ym94ZXM6bCxzY29yZXM6dX09bixwPXQuZGF0YUlkTWFwLmdldChsLmRhdGFJZCkuaWQsZD10LmRhdGFJZE1hcC5nZXQodS5kYXRhSWQpLmlkLGM9bCQocCxkLHMscixpLG8pLHtwU2VsZWN0ZWRJbmRpY2VzOmgsc2VsZWN0ZWRTaXplOm0scFNlbGVjdGVkU2NvcmVzOmYscFZhbGlkT3V0cHV0czpnfT1oayh0LGMpO3Qud2FzbS5fZnJlZShmKTtsZXQgYj10Lm1ha2VPdXRwdXQoW21dLFwiaW50MzJcIixoKSx5PXQubWFrZU91dHB1dChbXSxcImludDMyXCIsZyk7cmV0dXJuW2IseV19dmFyIG5oZT17a2VybmVsTmFtZTpBdSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6ZWhlLGtlcm5lbEZ1bmM6dGhlfSx1JDtmdW5jdGlvbiBhaGUoZSl7dSQ9ZS53YXNtLmN3cmFwKEZ1LFwibnVtYmVyXCIsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gcmhlKGUpe2xldHtiYWNrZW5kOnQsaW5wdXRzOm4sYXR0cnM6YX09ZSx7aW91VGhyZXNob2xkOnIsbWF4T3V0cHV0U2l6ZTpzLHNjb3JlVGhyZXNob2xkOmksc29mdE5tc1NpZ21hOm99PWEse2JveGVzOmwsc2NvcmVzOnV9PW4scD10LmRhdGFJZE1hcC5nZXQobC5kYXRhSWQpLmlkLGQ9dC5kYXRhSWRNYXAuZ2V0KHUuZGF0YUlkKS5pZCxjPXUkKHAsZCxzLHIsaSxvKSx7cFNlbGVjdGVkSW5kaWNlczpoLHNlbGVjdGVkU2l6ZTptLHBTZWxlY3RlZFNjb3JlczpmLHBWYWxpZE91dHB1dHM6Z309aGsodCxjKTt0Lndhc20uX2ZyZWUoZyk7bGV0IGI9dC5tYWtlT3V0cHV0KFttXSxcImludDMyXCIsaCkseT10Lm1ha2VPdXRwdXQoW21dLFwiZmxvYXQzMlwiLGYpO3JldHVybltiLHldfXZhciBzaGU9e2tlcm5lbE5hbWU6RnUsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOmFoZSxrZXJuZWxGdW5jOnJoZX0saWhlPSExLG9oZT1VdChFdSxpaGUsXCJib29sXCIpLHAkO2Z1bmN0aW9uIGxoZShlKXtwJD1lLndhc20uY3dyYXAoeW8sbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gdWhlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7aW5kaWNlczpyfT10LHtkdHlwZTpzLGRlcHRoOmksb25WYWx1ZTpvLG9mZlZhbHVlOmx9PWEsdT1uLm1ha2VPdXRwdXQoWy4uLnIuc2hhcGUsaV0scykscD1uLmRhdGFJZE1hcC5nZXQodS5kYXRhSWQpLmlkLGQ9bi5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZDtyZXR1cm4gcCQoZCxpLG8sbCxwKSx1fXZhciBwaGU9e2tlcm5lbE5hbWU6eW8sYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOmxoZSxrZXJuZWxGdW5jOnVoZX07ZnVuY3Rpb24gY2hlKGUpe2xldHtpbnB1dHM6e3g6dH0sYmFja2VuZDpufT1lLGE9bi5tYWtlT3V0cHV0KHQuc2hhcGUsdC5kdHlwZSk7cmV0dXJuIG4udHlwZWRBcnJheUZyb21IZWFwKGEpLmZpbGwoMSksYX12YXIgZGhlPXtrZXJuZWxOYW1lOiR1LGJhY2tlbmROYW1lOlwid2FzbVwiLGtlcm5lbEZ1bmM6Y2hlfTtmdW5jdGlvbiBoaGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtheGlzOnJ9PWE7aWYodC5sZW5ndGg9PT0xKXJldHVybiB5dih7aW5wdXRzOntpbnB1dDp0WzBdfSxiYWNrZW5kOm4sYXR0cnM6e2RpbTpyfX0pO2xldCBzPXRbMF0uc2hhcGUsaT10WzBdLmR0eXBlO3QuZm9yRWFjaChwPT57dy5hc3NlcnRTaGFwZXNNYXRjaChzLHAuc2hhcGUsXCJBbGwgdGVuc29ycyBwYXNzZWQgdG8gc3RhY2sgbXVzdCBoYXZlIG1hdGNoaW5nIHNoYXBlc1wiKSx3LmFzc2VydChpPT09cC5kdHlwZSwoKT0+XCJBbGwgdGVuc29ycyBwYXNzZWQgdG8gc3RhY2sgbXVzdCBoYXZlIG1hdGNoaW5nIGR0eXBlc1wiKX0pO2xldCBvPVtdLGw9dC5tYXAocD0+e2xldCBkPXl2KHtpbnB1dHM6e2lucHV0OnB9LGJhY2tlbmQ6bixhdHRyczp7ZGltOnJ9fSk7cmV0dXJuIG8ucHVzaChkKSxkfSksdT13Rih7aW5wdXRzOmwsYmFja2VuZDpuLGF0dHJzOntheGlzOnJ9fSk7cmV0dXJuIG8uZm9yRWFjaChwPT5uLmRpc3Bvc2VEYXRhKHAuZGF0YUlkKSksdX12YXIgbWhlPXtrZXJuZWxOYW1lOkR1LGJhY2tlbmROYW1lOlwid2FzbVwiLGtlcm5lbEZ1bmM6aGhlfSxjJDtmdW5jdGlvbiBmaGUoZSl7YyQ9ZS53YXNtLmN3cmFwKHhvLG51bGwsW1wibnVtYmVyXCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcImFycmF5XCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIGdoZShlKXtsZXR7aW5wdXRzOnt4OnR9LGJhY2tlbmQ6bixhdHRyczp7cGFkZGluZ3M6YSxjb25zdGFudFZhbHVlOnJ9fT1lLHM9YS5tYXAoKG0sZik9Pm1bMF0rdC5zaGFwZVtmXSttWzFdKTtpZih3LnNpemVGcm9tU2hhcGUodC5zaGFwZSk9PT0wKXJldHVybiBMRih7YmFja2VuZDpuLGF0dHJzOntzaGFwZTpzLHZhbHVlOnIsZHR5cGU6dC5kdHlwZX19KTtsZXQgaT1uLmRhdGFJZE1hcC5nZXQodC5kYXRhSWQpLmlkLG89bi5tYWtlT3V0cHV0KHMsdC5kdHlwZSksbD1uLmRhdGFJZE1hcC5nZXQoby5kYXRhSWQpLmlkLHU9bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkodC5zaGFwZSkuYnVmZmVyKSxwPWEubWFwKG09Pm1bMF0pLGQ9YS5tYXAobT0+bVsxXSksYz1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheShwKS5idWZmZXIpLGg9bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkoZCkuYnVmZmVyKTtyZXR1cm4gYyQoaSx1LHQuc2hhcGUubGVuZ3RoLFFlW3QuZHR5cGVdLGMsaCxyLGwpLG99dmFyIGQkPXtrZXJuZWxOYW1lOnhvLGJhY2tlbmROYW1lOlwid2FzbVwiLGtlcm5lbEZ1bmM6Z2hlLHNldHVwRnVuYzpmaGV9LGJoZT0hMSx5aGU9VXQodm8sYmhlKSxoJDtmdW5jdGlvbiB4aGUoZSl7aCQ9ZS53YXNtLmN3cmFwKHdvLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gdmhlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse3g6YSxhbHBoYTpyfT10LHM9bi5kYXRhSWRNYXAuZ2V0KGEuZGF0YUlkKS5pZCxpPW4uZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsbz1zLGw9YSx1PWw7bC5kdHlwZSE9PVwiZmxvYXQzMlwiJiYodT1Scyh7YmFja2VuZDpuLGlucHV0czp7eDphfSxhdHRyczp7ZHR5cGU6XCJmbG9hdDMyXCJ9fSksbz1uLmRhdGFJZE1hcC5nZXQodS5kYXRhSWQpLmlkKTtsZXQgcD1uLm1ha2VPdXRwdXQoYS5zaGFwZSxcImZsb2F0MzJcIiksZD1uLmRhdGFJZE1hcC5nZXQocC5kYXRhSWQpLmlkO3JldHVybiBoJChvLGksZCksbC5kdHlwZSE9PVwiZmxvYXQzMlwiJiZuLmRpc3Bvc2VEYXRhKHUuZGF0YUlkKSxwfXZhciB3aGU9e2tlcm5lbE5hbWU6d28sYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOnhoZSxrZXJuZWxGdW5jOnZoZX0sbSQ7ZnVuY3Rpb24ga2hlKGUpe20kPWUud2FzbS5jd3JhcChrbyxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gSWhlKGUpe2xldHtiYWNrZW5kOnQsaW5wdXRzOm4sYXR0cnM6YX09ZSx7YXhpczpyLGtlZXBEaW1zOnN9PWEse3g6aX09bixvPXQuZGF0YUlkTWFwLmdldChpLmRhdGFJZCkuaWQsbD1vLHU9aSx7dHJhbnNwb3NlZDpwLGF4ZXM6ZCxvcmlnaW5hbEF4ZXM6YyxpbnB1dFdhc1RyYW5zcG9zZWQ6aH09RHMoaSxyLHQpLG09ZDtpZihoKXtsZXQgeD10LmRhdGFJZE1hcC5nZXQocC5kYXRhSWQpLmlkO3ghPT1vJiYodT1wLGw9eCxtPVQuZ2V0SW5uZXJNb3N0QXhlcyhtLmxlbmd0aCx1LnNoYXBlLmxlbmd0aCkpfVQuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJwcm9kXCIsbSx1LnNoYXBlLmxlbmd0aCk7bGV0W2YsZ109VC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHUuc2hhcGUsbSksYj13LnNpemVGcm9tU2hhcGUoZykseT10Lm1ha2VPdXRwdXQoZix1LmR0eXBlKTtpZih3LnNpemVGcm9tU2hhcGUodS5zaGFwZSkhPT0wKXtsZXQgeD10LmRhdGFJZE1hcC5nZXQoeS5kYXRhSWQpLmlkO20kKGwsYixRZVt5LmR0eXBlXSx4KX1pZihoJiZ0LmRpc3Bvc2VEYXRhKHAuZGF0YUlkKSxzKXtsZXQgeD1ULmV4cGFuZFNoYXBlVG9LZWVwRGltKHkuc2hhcGUsYyk7eS5zaGFwZT14fXJldHVybiB5fXZhciBTaGU9e2tlcm5lbE5hbWU6a28sYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOmtoZSxrZXJuZWxGdW5jOkloZX0sTmhlPWU9PntsZXR7YmFja2VuZDp0LGF0dHJzOm59PWUse3N0YXJ0OmEsc3RvcDpyLHN0ZXA6cyxkdHlwZTppfT1uLG89QjEoYSxyLHMsaSksbD10Lm1ha2VPdXRwdXQoW28ubGVuZ3RoXSxpKTtyZXR1cm4gdC50eXBlZEFycmF5RnJvbUhlYXAobCkuc2V0KG8pLGx9LFRoZT17a2VybmVsTmFtZTpVYyxiYWNrZW5kTmFtZTpcIndhc21cIixrZXJuZWxGdW5jOk5oZX0sQ2hlPSEwLEVoZT1VdChIaSxDaGUpLF9oZT1YZShJbyksQWhlPVhlKFNvKSxGaGU9WGUoQ28pLGYkO2Z1bmN0aW9uICRoZShlKXtmJD1lLndhc20uY3dyYXAoVG8sbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIERoZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpuLGF0dHJzOmF9PWUse2ltYWdlczpyfT1uLHthbGlnbkNvcm5lcnM6cyxoYWxmUGl4ZWxDZW50ZXJzOmksc2l6ZTpvfT1hLFtsLHVdPW8sW3AsZCxjLGhdPXIuc2hhcGUsbT1bcCxsLHUsaF0sZj10LmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLGc7Zi5kdHlwZSE9PVwiZmxvYXQzMlwiJiYoZz1Scyh7YmFja2VuZDp0LGlucHV0czp7eDpyfSxhdHRyczp7ZHR5cGU6XCJmbG9hdDMyXCJ9fSksZj10LmRhdGFJZE1hcC5nZXQoZy5kYXRhSWQpKTtsZXQgYj1mLmlkLHk9dC5tYWtlT3V0cHV0KG0sXCJmbG9hdDMyXCIpO2lmKHcuc2l6ZUZyb21TaGFwZShyLnNoYXBlKT09PTApcmV0dXJuIHk7bGV0IHg9dC5kYXRhSWRNYXAuZ2V0KHkuZGF0YUlkKS5pZDtyZXR1cm4gZiQoYixwLGQsYyxoLGwsdSxzPzE6MCxpPzE6MCx4KSxnIT1udWxsJiZ0LmRpc3Bvc2VEYXRhKGcuZGF0YUlkKSx5fXZhciBSaGU9e2tlcm5lbE5hbWU6VG8sYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOiRoZSxrZXJuZWxGdW5jOkRoZX0sZyQ7ZnVuY3Rpb24gTWhlKGUpe2ckPWUud2FzbS5jd3JhcChPdSxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcImFycmF5XCIsXCJhcnJheVwiLFwiYm9vbGVhblwiXSl9ZnVuY3Rpb24gT2hlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7aW1hZ2VzOnIsZHk6c309dCx7YWxpZ25Db3JuZXJzOml9PWEsbz1uLm1ha2VPdXRwdXQoci5zaGFwZSxcImZsb2F0MzJcIiksbD1uLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLHU7cmV0dXJuIGwuZHR5cGUhPT1cImZsb2F0MzJcIiYmKHU9UnMoe2JhY2tlbmQ6bixpbnB1dHM6e3g6cn0sYXR0cnM6e2R0eXBlOlwiZmxvYXQzMlwifX0pLGw9bi5kYXRhSWRNYXAuZ2V0KHUuZGF0YUlkKSksZyQobi5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZCxuLmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkLG4uZGF0YUlkTWFwLmdldChvLmRhdGFJZCkuaWQsbmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkoci5zaGFwZSkuYnVmZmVyKSxuZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheShzLnNoYXBlKS5idWZmZXIpLGkpLHUhPW51bGwmJm4uZGlzcG9zZURhdGEodS5kYXRhSWQpLG99dmFyIFBoZT17a2VybmVsTmFtZTpPdSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6TWhlLGtlcm5lbEZ1bmM6T2hlfSxiJDtmdW5jdGlvbiBMaGUoZSl7YiQ9ZS53YXNtLmN3cmFwKE5vLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiB6aGUoZSl7bGV0e2JhY2tlbmQ6dCxpbnB1dHM6bixhdHRyczphfT1lLHtpbWFnZXM6cn09bix7YWxpZ25Db3JuZXJzOnMsaGFsZlBpeGVsQ2VudGVyczppLHNpemU6b309YSxbbCx1XT1vLFtwLGQsYyxoXT1yLnNoYXBlLG09W3AsbCx1LGhdLGY9dC5tYWtlT3V0cHV0KG0sXCJmbG9hdDMyXCIpO2lmKHcuc2l6ZUZyb21TaGFwZShyLnNoYXBlKT09PTApcmV0dXJuIGY7bGV0IGc9dC5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKSxiO2cuZHR5cGUhPT1cImZsb2F0MzJcIiYmKGI9UnMoe2JhY2tlbmQ6dCxpbnB1dHM6e3g6cn0sYXR0cnM6e2R0eXBlOlwiZmxvYXQzMlwifX0pLGc9dC5kYXRhSWRNYXAuZ2V0KGIuZGF0YUlkKSk7bGV0IHk9Zy5pZCx4PXQuZGF0YUlkTWFwLmdldChmLmRhdGFJZCkuaWQ7cmV0dXJuIGIkKHkscCxkLGMsaCxsLHUscz8xOjAsaT8xOjAseCksYiE9bnVsbCYmdC5kaXNwb3NlRGF0YShiLmRhdGFJZCksZn12YXIgV2hlPXtrZXJuZWxOYW1lOk5vLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpMaGUsa2VybmVsRnVuYzp6aGV9LHkkO2Z1bmN0aW9uIEJoZShlKXt5JD1lLndhc20uY3dyYXAoTXUsbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJhcnJheVwiLFwiYXJyYXlcIixcImJvb2xlYW5cIl0pfWZ1bmN0aW9uIFZoZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2ltYWdlczpyLGR5OnN9PXQse2FsaWduQ29ybmVyczppfT1hLG89bi5tYWtlT3V0cHV0KHIuc2hhcGUsXCJmbG9hdDMyXCIpLGw9bi5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKSx1O3JldHVybiBsLmR0eXBlIT09XCJmbG9hdDMyXCImJih1PVJzKHtiYWNrZW5kOm4saW5wdXRzOnt4OnJ9LGF0dHJzOntkdHlwZTpcImZsb2F0MzJcIn19KSxsPW4uZGF0YUlkTWFwLmdldCh1LmRhdGFJZCkpLHkkKG4uZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsbi5kYXRhSWRNYXAuZ2V0KHMuZGF0YUlkKS5pZCxuLmRhdGFJZE1hcC5nZXQoby5kYXRhSWQpLmlkLG5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KHIuc2hhcGUpLmJ1ZmZlciksbmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkocy5zaGFwZSkuYnVmZmVyKSxpKSx1IT1udWxsJiZuLmRpc3Bvc2VEYXRhKHUuZGF0YUlkKSxvfXZhciBVaGU9e2tlcm5lbE5hbWU6TXUsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOkJoZSxrZXJuZWxGdW5jOlZoZX0seCQ7ZnVuY3Rpb24gR2hlKGUpe3gkPWUud2FzbS5jd3JhcChFbyxudWxsLFtcIm51bWJlclwiLFwiYXJyYXlcIixcIm51bWJlclwiLFwiYXJyYXlcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBIaGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2RpbXM6c309YSxpPXcucGFyc2VBeGlzUGFyYW0ocyxyLnNoYXBlKTtpZihyLnNoYXBlLmxlbmd0aD09PTApcmV0dXJuIEdmKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpufSk7bGV0IG89bi5tYWtlT3V0cHV0KHIuc2hhcGUsci5kdHlwZSksbD1uLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLHU9bi5kYXRhSWRNYXAuZ2V0KG8uZGF0YUlkKS5pZCxwPW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KGkpLmJ1ZmZlciksZD1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheShyLnNoYXBlKS5idWZmZXIpO3gkKGwscCxpLmxlbmd0aCxkLHIuc2hhcGUubGVuZ3RoLHUpO2xldCBjPXpuKHtpbnB1dHM6e3g6b30sYXR0cnM6e3NoYXBlOnIuc2hhcGV9LGJhY2tlbmQ6bn0pO3JldHVybiBuLmRpc3Bvc2VEYXRhKG8uZGF0YUlkKSxjfXZhciBqaGU9e2tlcm5lbE5hbWU6RW8sYmFja2VuZE5hbWU6XCJ3YXNtXCIsa2VybmVsRnVuYzpIaGUsc2V0dXBGdW5jOkdoZX0sdiQ7ZnVuY3Rpb24gcWhlKGUpe3YkPWUud2FzbS5jd3JhcChadSxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIEtoZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2ltYWdlOnJ9PXQse3JhZGlhbnM6cyxmaWxsVmFsdWU6aSxjZW50ZXI6b309YSxsPW4ubWFrZU91dHB1dChyLnNoYXBlLHIuZHR5cGUpLHU9bi5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZCxwPW4uZGF0YUlkTWFwLmdldChsLmRhdGFJZCkuaWQsW2QsYyxoLG1dPXIuc2hhcGUsW2YsZ109VC5nZXRJbWFnZUNlbnRlcihvLGMsaCksYj1pPT09MCx5PTI1NSx4PXR5cGVvZiBpPT1cIm51bWJlclwiP1tpLGksaSxiPzA6eV06Wy4uLmkseV0sdj1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheSh4KS5idWZmZXIpO3JldHVybiB2JCh1LGQsYyxoLG0scyxmLGcsdix4Lmxlbmd0aCxwKSxsfXZhciBYaGU9e2tlcm5lbE5hbWU6WnUsYmFja2VuZE5hbWU6XCJ3YXNtXCIsa2VybmVsRnVuYzpLaGUsc2V0dXBGdW5jOnFoZX0sWWhlPVhlKF9vKSxaaGU9WGUoQW8pLHckO2Z1bmN0aW9uIEpoZShlKXt3JD1lLndhc20uY3dyYXAoUHUsbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIFFoZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpuLGF0dHJzOmF9PWUse2luZGljZXM6cix1cGRhdGVzOnN9PW4se3NoYXBlOml9PWEsbz10Lm1ha2VPdXRwdXQoaSxzLmR0eXBlKTtpZih3LnNpemVGcm9tU2hhcGUoaSk9PT0wKXJldHVybiBvO2xldHtzbGljZVJhbms6bCxudW1VcGRhdGVzOnUsc2xpY2VTaXplOnAsc3RyaWRlczpkLG91dHB1dFNpemU6Y309c2YuY2FsY3VsYXRlU2hhcGVzKHMscixpKSxoPXQuZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsbT10LmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkLGY9bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkoZCkuYnVmZmVyKSxnPXQuZGF0YUlkTWFwLmdldChvLmRhdGFJZCkuaWQ7cmV0dXJuIHckKGgsbSxRZVtzLmR0eXBlXSxsLHUscCxmLGMsZyksb312YXIgZW1lPXtrZXJuZWxOYW1lOlB1LGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpKaGUsa2VybmVsRnVuYzpRaGV9LGskO2Z1bmN0aW9uIHRtZShlKXtrJD1lLndhc20uY3dyYXAoenUsbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJib29sXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIG5tZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3NvcnRlZFNlcXVlbmNlOnIsdmFsdWVzOnN9PXQse3NpZGU6aX09YTtpZihyLmR0eXBlIT09cy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoYFNlYXJjaFNvcnRlZCBlcnJvcjogc29ydGVkX3NlcXVlbmNlIG11c3QgaGF2ZSB0aGUgc2FtZSBkdHlwZSBhcyB2YWx1ZXMuIEdvdCAke3IuZHR5cGV9IGFuZCAke3MuZHR5cGV9YCk7bGV0IG89bi5tYWtlT3V0cHV0KHMuc2hhcGUsXCJpbnQzMlwiKTtmdW5jdGlvbiBsKHUpe3JldHVybiBuLmRhdGFJZE1hcC5nZXQodS5kYXRhSWQpLmlkfXJldHVybiBrJChsKHIpLGwocyksci5zaGFwZVswXSxyLnNoYXBlWzFdLHMuc2hhcGVbMV0sUWVbci5kdHlwZV0saT09PVwibGVmdFwiLGwobykpLG99dmFyIGFtZT17a2VybmVsTmFtZTp6dSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6dG1lLGtlcm5lbEZ1bmM6bm1lfSxJJDtmdW5jdGlvbiBybWUoZSl7SSQ9ZS53YXNtLmN3cmFwKFwiU2VsZWN0VjJcIixudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBzbWUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7Y29uZGl0aW9uOmEsdDpyLGU6c309dCxpPW4uZGF0YUlkTWFwLmdldChhLmRhdGFJZCkuaWQsbz1uLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLGw9bi5kYXRhSWRNYXAuZ2V0KHMuZGF0YUlkKS5pZCx1PW4ubWFrZU91dHB1dChyLnNoYXBlLHIuZHR5cGUpLHA9bi5kYXRhSWRNYXAuZ2V0KHUuZGF0YUlkKS5pZCxkPWEuc2hhcGUubGVuZ3RoLGM9ci5zaGFwZS5sZW5ndGgsaD1kPT09MHx8ZD4xfHxjPT09MT8xOncuc2l6ZUZyb21TaGFwZShyLnNoYXBlLnNsaWNlKDEpKTtyZXR1cm4gSSQoaSxvLGwsaCxwKSx1fXZhciBpbWU9e2tlcm5lbE5hbWU6V3UsYmFja2VuZE5hbWU6XCJ3YXNtXCIsa2VybmVsRnVuYzpzbWUsc2V0dXBGdW5jOnJtZX0sb21lPVhlKEZvKSxTJDtmdW5jdGlvbiBsbWUoZSl7UyQ9ZS53YXNtLmN3cmFwKE1vLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIHVtZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czp7eDpufX09ZSxhPXQuZGF0YUlkTWFwLmdldChuLmRhdGFJZCkuaWQscj10Lm1ha2VPdXRwdXQobi5zaGFwZSxuLmR0eXBlKSxzPXQuZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQ7cmV0dXJuIHcuc2l6ZUZyb21TaGFwZShyLnNoYXBlKT09PTB8fFMkKGEscykscn12YXIgcG1lPXtrZXJuZWxOYW1lOlwiU2lnbW9pZFwiLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpsbWUsa2VybmVsRnVuYzp1bWV9LGNtZT1YZShSbyksZG1lPVhlKCRvKSxobWU9WGUoRG8pLG1tZT1YZShPbyk7ZnVuY3Rpb24gZm1lKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtibG9ja1NoYXBlOnMscGFkZGluZ3M6aX09YSxvPXcuc2l6ZUZyb21TaGFwZShzKSxsPVtbMCwwXV07bC5wdXNoKC4uLmkpO2ZvcihsZXQgZz0xK3MubGVuZ3RoO2c8ci5zaGFwZS5sZW5ndGg7KytnKWwucHVzaChbMCwwXSk7bGV0IHU9ZCQua2VybmVsRnVuYyh7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bixhdHRyczp7cGFkZGluZ3M6bCxjb25zdGFudFZhbHVlOjB9fSkscD1ULmdldFJlc2hhcGVkKHUuc2hhcGUscyxvLCExKSxkPVQuZ2V0UGVybXV0ZWQocC5sZW5ndGgscy5sZW5ndGgsITEpLGM9VC5nZXRSZXNoYXBlZFBlcm11dGVkKHUuc2hhcGUscyxvLCExKSxoPXpuKHtpbnB1dHM6e3g6dX0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpwfX0pLG09eXMoe2lucHV0czp7eDpofSxiYWNrZW5kOm4sYXR0cnM6e3Blcm06ZH19KSxmPXpuKHtpbnB1dHM6e3g6bX0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpjfX0pO3JldHVybiBuLmRpc3Bvc2VEYXRhKHUuZGF0YUlkKSxuLmRpc3Bvc2VEYXRhKGguZGF0YUlkKSxuLmRpc3Bvc2VEYXRhKG0uZGF0YUlkKSxmfXZhciBnbWU9e2tlcm5lbE5hbWU6VnUsYmFja2VuZE5hbWU6XCJ3YXNtXCIsa2VybmVsRnVuYzpmbWV9LE4kO2Z1bmN0aW9uIGJtZShlKXtOJD1lLndhc20uY3dyYXAoXCJTcGFyc2VGaWxsRW1wdHlSb3dzXCIsXCJudW1iZXJcIixbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiB5bWUoZSl7bGV0e2JhY2tlbmQ6dCxpbnB1dHM6bn09ZSx7aW5kaWNlczphLHZhbHVlczpyLGRlbnNlU2hhcGU6cyxkZWZhdWx0VmFsdWU6aX09bixvPWEuc2hhcGVbMF0sbD1hLnNoYXBlWzFdLHU9dC5yZWFkU3luYyhzLmRhdGFJZClbMF0scD1bbyt1LGxdLGQ9dC5kYXRhSWRNYXAuZ2V0KGEuZGF0YUlkKS5pZCxjPXQuZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsaD10LmRhdGFJZE1hcC5nZXQoaS5kYXRhSWQpLmlkLG09dC5tYWtlT3V0cHV0KHAsYS5kdHlwZSksZj10LmRhdGFJZE1hcC5nZXQobS5kYXRhSWQpLmlkLGc9dC5tYWtlT3V0cHV0KHAuc2xpY2UoMCwxKSxyLmR0eXBlKSxiPXQuZGF0YUlkTWFwLmdldChnLmRhdGFJZCkuaWQseT10Lm1ha2VPdXRwdXQoW3VdLFwiYm9vbFwiKSx4PXQuZGF0YUlkTWFwLmdldCh5LmRhdGFJZCkuaWQsdj10Lm1ha2VPdXRwdXQoW29dLGEuZHR5cGUpLEk9dC5kYXRhSWRNYXAuZ2V0KHYuZGF0YUlkKS5pZCxOPXQubWFrZU91dHB1dChbNF0sXCJpbnQzMlwiKSxDPXQuZGF0YUlkTWFwLmdldChOLmRhdGFJZCkuaWQsXz1OJChkLGMsUWVbci5kdHlwZV0sbyx1LGwsaCxmLGIseCxJLEMpLEY9dC5yZWFkU3luYyhOLmRhdGFJZCksRDtzd2l0Y2goRlswXSl7Y2FzZSAxOntEPVQuZ2V0U3BhcnNlRmlsbEVtcHR5Um93c0luZGljZXNEZW5zZVNoYXBlTWlzbWF0Y2goRlsxXSk7YnJlYWt9Y2FzZSAyOntEPVQuZ2V0U3BhcnNlRmlsbEVtcHR5Um93c05lZ2F0aXZlSW5kZXhFcnJvck1lc3NhZ2UoRlsxXSxGWzJdKTticmVha31jYXNlIDM6RD1ULmdldFNwYXJzZUZpbGxFbXB0eVJvd3NPdXRPZlJhbmdlSW5kZXhFcnJvck1lc3NhZ2UoRlsxXSxGWzJdLEZbM10pO2JyZWFrO2RlZmF1bHQ6RD1cIlwifWlmKHQuZGlzcG9zZURhdGEoTi5kYXRhSWQpLEQpdGhyb3cgdC5kaXNwb3NlRGF0YShtLmRhdGFJZCksdC5kaXNwb3NlRGF0YShnLmRhdGFJZCksdC5kaXNwb3NlRGF0YSh5LmRhdGFJZCksdC5kaXNwb3NlRGF0YSh2LmRhdGFJZCksbmV3IEVycm9yKEQpO2xldCAkPW0sUz1nO3JldHVybiBfIT09cFswXSYmKCQ9SWkoe2lucHV0czp7eDptfSxhdHRyczp7YmVnaW46MCxzaXplOltfLGxdfSxiYWNrZW5kOnR9KSxTPUlpKHtpbnB1dHM6e3g6Z30sYXR0cnM6e2JlZ2luOjAsc2l6ZTpffSxiYWNrZW5kOnR9KSx0LmRpc3Bvc2VEYXRhKG0uZGF0YUlkKSx0LmRpc3Bvc2VEYXRhKGcuZGF0YUlkKSksWyQsUyx5LHZdfXZhciB4bWU9e2tlcm5lbE5hbWU6R2MsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOmJtZSxrZXJuZWxGdW5jOnltZX0sVCQ7ZnVuY3Rpb24gdm1lKGUpe1QkPWUud2FzbS5jd3JhcChHdSxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gd21lKGUpe2xldHtiYWNrZW5kOnQsaW5wdXRzOm59PWUse2lucHV0SW5kaWNlczphLGlucHV0U2hhcGU6cixuZXdTaGFwZTpzfT1uO2lmKGEuc2hhcGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoYElucHV0IGluZGljZXMgc2hvdWxkIGJlIGEgbWF0cml4IGJ1dCByZWNlaXZlZCBzaGFwZVxuICAgICAgICAke2Euc2hhcGV9YCk7aWYoci5zaGFwZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihgSW5wdXQgc2hhcGUgc2hvdWxkIGJlIGEgdmVjdG9yIGJ1dCByZWNlaXZlZCBzaGFwZVxuICAgICAgICAke3Iuc2hhcGV9YCk7aWYocy5zaGFwZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihgVGFyZ2V0IHNoYXBlIHNob3VsZCBiZSBhIHZlY3RvciBidXQgcmVjZWl2ZWQgc2hhcGUgJHtzLnNoYXBlfWApO2xldCBpPXQuZGF0YUlkTWFwLmdldChhLmRhdGFJZCkuaWQsbz10LmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLGw9dC5kYXRhSWRNYXAuZ2V0KHMuZGF0YUlkKS5pZCx1PWEuc2hhcGVbMF0scD13LnNpemVGcm9tU2hhcGUocy5zaGFwZSksZD10Lm1ha2VPdXRwdXQoW3UscF0sYS5kdHlwZSksYz10LmRhdGFJZE1hcC5nZXQoZC5kYXRhSWQpLmlkLGg9dC5tYWtlT3V0cHV0KFtwXSxzLmR0eXBlKSxtPXQuZGF0YUlkTWFwLmdldChoLmRhdGFJZCkuaWQsZj10Lm1ha2VPdXRwdXQoWzNdLFwiaW50MzJcIiksZz10LmRhdGFJZE1hcC5nZXQoZi5kYXRhSWQpLmlkO1QkKGksbyxsLHUsYyxtLGcpO2xldCBiPXQucmVhZFN5bmMoZi5kYXRhSWQpLHk7c3dpdGNoKGJbMF0pe2Nhc2UgMDp7eT1ULmdldFNwYXJzZVJlc2hhcGVNdWx0aXBsZU5lZ2F0aXZlT25lT3V0cHV0RGltRXJyb3JNZXNzYWdlKGJbMV0sYlsyXSk7YnJlYWt9Y2FzZSAxOnt5PVQuZ2V0U3BhcnNlUmVzaGFwZU5lZ2F0aXZlT3V0cHV0RGltRXJyb3JNZXNzYWdlKGJbMV0sYlsyXSk7YnJlYWt9Y2FzZSAyOnk9VC5nZXRTcGFyc2VSZXNoYXBlRW1wdHlUZW5zb3JaZXJvT3V0cHV0RGltRXJyb3JNZXNzYWdlKCk7YnJlYWs7Y2FzZSAzOntsZXQgeD1BcnJheS5mcm9tKHQucmVhZFN5bmMoci5kYXRhSWQpKSx2PUFycmF5LmZyb20odC5yZWFkU3luYyhoLmRhdGFJZCkpO3k9VC5nZXRTcGFyc2VSZXNoYXBlSW5wdXRPdXRwdXRNdWx0aXBsZUVycm9yTWVzc2FnZSh4LHYpO2JyZWFrfWNhc2UgNDp7bGV0IHg9QXJyYXkuZnJvbSh0LnJlYWRTeW5jKHIuZGF0YUlkKSksdj1BcnJheS5mcm9tKHQucmVhZFN5bmMoaC5kYXRhSWQpKTt5PVQuZ2V0U3BhcnNlUmVzaGFwZUlucHV0T3V0cHV0TWlzbWF0Y2hFcnJvck1lc3NhZ2UoeCx2KTticmVha31kZWZhdWx0Onk9XCJcIn1pZih0LmRpc3Bvc2VEYXRhKGYuZGF0YUlkKSx5KXRocm93IHQuZGlzcG9zZURhdGEoZC5kYXRhSWQpLHQuZGlzcG9zZURhdGEoaC5kYXRhSWQpLG5ldyBFcnJvcih5KTtyZXR1cm5bZCxoXX12YXIga21lPXtrZXJuZWxOYW1lOkd1LGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzp2bWUsa2VybmVsRnVuYzp3bWV9LEMkO2Z1bmN0aW9uIEUkKGUpe0MkPWUud2FzbS5jd3JhcChcIlNwYXJzZVNlZ21lbnRSZWR1Y3Rpb25cIixudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIF8kKGUsdCl7bGV0e2JhY2tlbmQ6bixpbnB1dHM6YX09ZSx7ZGF0YTpyLGluZGljZXM6cyxzZWdtZW50SWRzOml9PWEsbz1zLnNoYXBlWzBdLGw9bi5yZWFkU3luYyhpLmRhdGFJZCxvLTEsbylbMF0sdT1vPjA/bCsxOjA7aWYodTwwKXRocm93IG5ldyBFcnJvcihULmdldFNwYXJzZVNlZ21lbnRSZWR1Y3Rpb25OZWdhdGl2ZVNlZ21lbnRJZHNFcnJvck1lc3NhZ2UoKSk7bGV0IHA9ci5zaGFwZS5zbGljZSgpO3BbMF09dTtsZXQgZD1uLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLGM9bi5kYXRhSWRNYXAuZ2V0KHMuZGF0YUlkKS5pZCxoPW4uZGF0YUlkTWFwLmdldChpLmRhdGFJZCkuaWQsbT1uLm1ha2VPdXRwdXQocCxyLmR0eXBlKSxmPW4uZGF0YUlkTWFwLmdldChtLmRhdGFJZCkuaWQsZz1uLm1ha2VPdXRwdXQoWzRdLFwiaW50MzJcIiksYj1uLmRhdGFJZE1hcC5nZXQoZy5kYXRhSWQpLmlkO0MkKGQsUWVbci5kdHlwZV0sci5zaGFwZVswXSxjLGgsZixiLHQsMCk7bGV0IHk9bi5yZWFkU3luYyhnLmRhdGFJZCkseDtzd2l0Y2goeVswXSl7Y2FzZSAwOnt4PVQuZ2V0U3BhcnNlU2VnbWVudFJlZHVjdGlvbk5lZ2F0aXZlU2VnbWVudElkc0Vycm9yTWVzc2FnZSgpO2JyZWFrfWNhc2UgMTp7eD1ULmdldFNwYXJzZVNlZ21lbnRSZWR1Y3Rpb25Ob25JbmNyZWFzaW5nU2VnbWVudElkc0Vycm9yTWVzc2FnZSgpO2JyZWFrfWNhc2UgMjp4PVQuZ2V0U3BhcnNlU2VnbWVudFJlZHVjdGlvblNlZ21lbnRJZE91dE9mUmFuZ2VFcnJvck1lc3NhZ2UoeVsxXSx5WzJdKTticmVhaztjYXNlIDM6eD1ULmdldFNwYXJzZVNlZ21lbnRSZWR1Y3Rpb25JbmRpY2VzT3V0T2ZSYW5nZUVycm9yTWVzc2FnZSh5WzFdLHlbMl0seVszXSk7YnJlYWs7ZGVmYXVsdDp4PVwiXCJ9aWYobi5kaXNwb3NlRGF0YShnLmRhdGFJZCkseCl0aHJvdyBuLmRpc3Bvc2VEYXRhKG0uZGF0YUlkKSxuZXcgRXJyb3IoeCk7cmV0dXJuIG19ZnVuY3Rpb24gSW1lKGUpe3JldHVybiBfJChlLCEwKX12YXIgU21lPXtrZXJuZWxOYW1lOkhjLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpFJCxrZXJuZWxGdW5jOkltZX07ZnVuY3Rpb24gTm1lKGUpe3JldHVybiBfJChlLCExKX12YXIgVG1lPXtrZXJuZWxOYW1lOmpjLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpFJCxrZXJuZWxGdW5jOk5tZX0sQSQ7ZnVuY3Rpb24gQ21lKGUpe0EkPWUud2FzbS5jd3JhcChIdSxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIEVtZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpuLGF0dHJzOmF9PWUse3NwYXJzZUluZGljZXM6cixzcGFyc2VWYWx1ZXM6cyxkZWZhdWx0VmFsdWU6aX09bix7b3V0cHV0U2hhcGU6b309YSxsPXQubWFrZU91dHB1dChvLGkuZHR5cGUpO2lmKHcuc2l6ZUZyb21TaGFwZShvKT09PTApcmV0dXJuIGw7bGV0e3NsaWNlUmFuazp1LG51bVVwZGF0ZXM6cCxzbGljZVNpemU6ZCxzdHJpZGVzOmMsb3V0cHV0U2l6ZTpofT1ULmNhbGN1bGF0ZVNoYXBlcyhzLHIsbyksbT10LmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLGY9dC5kYXRhSWRNYXAuZ2V0KHMuZGF0YUlkKS5pZCxnPXQuZGF0YUlkTWFwLmdldChpLmRhdGFJZCkuaWQsYj1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheShjKS5idWZmZXIpLHk9dC5kYXRhSWRNYXAuZ2V0KGwuZGF0YUlkKS5pZDtyZXR1cm4gQSQobSxmLHMuc2hhcGUubGVuZ3RoLGcsUWVbaS5kdHlwZV0sdSxwLGQsYixoLHkpLGx9dmFyIF9tZT17a2VybmVsTmFtZTpIdSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6Q21lLGtlcm5lbEZ1bmM6RW1lfTtmdW5jdGlvbiBBbWUoZSl7bGV0e2lucHV0czp0LGF0dHJzOm4sYmFja2VuZDphfT1lLHt4OnJ9PXQse251bU9yU2l6ZVNwbGl0czpzLGF4aXM6aX09bixvPXcucGFyc2VBeGlzUGFyYW0oaSxyLnNoYXBlKVswXSxsPVQucHJlcGFyZVNwbGl0U2l6ZShyLHMsbyksdT1uZXcgQXJyYXkoci5zaGFwZS5sZW5ndGgpLmZpbGwoMCkscD1yLnNoYXBlLnNsaWNlKCk7cmV0dXJuIGwubWFwKGQ9PntsZXQgYz1bLi4ucF07Y1tvXT1kO2xldCBoPUlpKHtpbnB1dHM6e3g6cn0sYXR0cnM6e2JlZ2luOnUsc2l6ZTpjfSxiYWNrZW5kOmF9KTtyZXR1cm4gdVtvXSs9ZCxofSl9dmFyIEZtZT17a2VybmVsTmFtZTpVdSxiYWNrZW5kTmFtZTpcIndhc21cIixrZXJuZWxGdW5jOkFtZX0sJG1lPVhlKFBvKSxEbWU9WGUocWMpLFJtZT0hMCxNbWU9VXQoV28sUm1lKSxGJDtmdW5jdGlvbiBPbWUoZSl7RiQ9ZS53YXNtLmN3cmFwKElzLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBQbWUoZSl7bGV0e2JhY2tlbmQ6dCxpbnB1dHM6bixhdHRyczphfT1lLHthbHBoYTpyfT1hLHt4OnN9PW4saT10LmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkLG89dC5tYWtlT3V0cHV0KHMuc2hhcGUscy5kdHlwZSksbD10LmRhdGFJZE1hcC5nZXQoby5kYXRhSWQpLmlkO3JldHVybiBGJChpLHIsUWVbcy5kdHlwZV0sbCksb312YXIgTG1lPXtrZXJuZWxOYW1lOklzLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpPbWUsa2VybmVsRnVuYzpQbWV9LCQkO2Z1bmN0aW9uIHptZShlKXskJD1lLndhc20uY3dyYXAoanUsbnVsbCxbXCJudW1iZXJcIixcImFycmF5XCIsXCJudW1iZXJcIixcImFycmF5XCIsXCJhcnJheVwiLFwiYXJyYXlcIixcImFycmF5XCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIFdtZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpuLGF0dHJzOmF9PWUse3g6cn09bix7YmVnaW46cyxlbmQ6aSxzdHJpZGVzOm8sYmVnaW5NYXNrOmwsZW5kTWFzazp1LGVsbGlwc2lzTWFzazpwLG5ld0F4aXNNYXNrOmQsc2hyaW5rQXhpc01hc2s6Y309YSx7ZmluYWxTaGFwZVNwYXJzZTpoLGZpbmFsU2hhcGU6bSxpc0lkZW50aXR5OmYsc2xpY2VEaW0wOmcsaXNTaW1wbGVTbGljZTpiLGJlZ2luOnksZW5kOngsc3RyaWRlczp2fT1LdC5zbGljZUluZm8oci5zaGFwZSxzLGksbyxsLHUscCxkLGMpLEk7aWYoZilJPXpuKHtpbnB1dHM6e3g6cn0sYmFja2VuZDp0LGF0dHJzOntzaGFwZTptfX0pO2Vsc2UgaWYoZ3x8Yil7dy5hc3NlcnQoci5zaGFwZS5sZW5ndGg+PTEsKCk9PmBJbnB1dCBtdXN0IGhhdmUgcmFuayBhdCBsZWFzdCAxLCBnb3Q6ICR7ci5zaGFwZS5sZW5ndGh9YCk7bGV0IE49S3QuY29tcHV0ZU91dFNoYXBlKHkseCx2KSxDPUlpKHtpbnB1dHM6e3g6cn0sYmFja2VuZDp0LGF0dHJzOntiZWdpbjp5LHNpemU6Tn19KTtJPXpuKHtpbnB1dHM6e3g6Q30sYmFja2VuZDp0LGF0dHJzOntzaGFwZTptfX0pLHQuZGlzcG9zZURhdGEoQy5kYXRhSWQpfWVsc2V7bGV0IE49dC5tYWtlT3V0cHV0KGgsXCJmbG9hdDMyXCIpLEM9dC5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZCxfPW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KHcuY29tcHV0ZVN0cmlkZXMoci5zaGFwZSkpLmJ1ZmZlciksRj1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheSh5KS5idWZmZXIpLEQ9bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkoeCkuYnVmZmVyKSwkPW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KHYpLmJ1ZmZlciksUz1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheShoKS5idWZmZXIpLE09bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkody5jb21wdXRlU3RyaWRlcyhoKSkuYnVmZmVyKSxCPXQuZGF0YUlkTWFwLmdldChOLmRhdGFJZCkuaWQ7JCQoQyxfLHIuc2hhcGUubGVuZ3RoLEYsRCwkLFMsTSxoLmxlbmd0aCxCKSxJPXpuKHtpbnB1dHM6e3g6Tn0sYmFja2VuZDp0LGF0dHJzOntzaGFwZTptfX0pLHQuZGlzcG9zZURhdGEoTi5kYXRhSWQpfXJldHVybiBJfXZhciBCbWU9e2tlcm5lbE5hbWU6anUsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOnptZSxrZXJuZWxGdW5jOldtZX07ZnVuY3Rpb24gVm1lKGUpe2xldHtiYWNrZW5kOnQsaW5wdXRzOm4sYXR0cnM6YX09ZSx7ZGF0YTpyLGRhdGFTcGxpdHM6c309bix7c2VwYXJhdG9yOmksbkdyYW1XaWR0aHM6byxsZWZ0UGFkOmwscmlnaHRQYWQ6dSxwYWRXaWR0aDpwLHByZXNlcnZlU2hvcnRTZXF1ZW5jZXM6ZH09YSxjPXQucmVhZFN5bmMoci5kYXRhSWQpLGg9dC5yZWFkU3luYyhzLmRhdGFJZCksW20sZl09VTEoYyxoLGksbyxsLHUscCxkKSxnPXQubWFrZU91dHB1dChbbS5sZW5ndGhdLFwic3RyaW5nXCIpLGI9dC5kYXRhSWRNYXAuZ2V0KGcuZGF0YUlkKTtiLnN0cmluZ0J5dGVzPW07bGV0IHk9dC5tYWtlT3V0cHV0KHMuc2hhcGUsXCJpbnQzMlwiKTtyZXR1cm4gdC50eXBlZEFycmF5RnJvbUhlYXAoeSkuc2V0KGYpLFtnLHldfXZhciBVbWU9e2tlcm5lbE5hbWU6WGMsYmFja2VuZE5hbWU6XCJ3YXNtXCIsa2VybmVsRnVuYzpWbWV9O2Z1bmN0aW9uIEdtZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpuLGF0dHJzOmF9PWUse2lucHV0OnIsZGVsaW1pdGVyOnN9PW4se3NraXBFbXB0eTppfT1hLG89dC5yZWFkU3luYyhyLmRhdGFJZCksbD10LnJlYWRTeW5jKHMuZGF0YUlkKSxbdSxwLGRdPUcxKG8sbFswXSxpKSxjPXAubGVuZ3RoLGg9dC5tYWtlT3V0cHV0KFtjLDJdLFwiaW50MzJcIik7dC50eXBlZEFycmF5RnJvbUhlYXAoaCkuc2V0KHUpO2xldCBtPXQubWFrZU91dHB1dChbY10sXCJzdHJpbmdcIiksZj10LmRhdGFJZE1hcC5nZXQobS5kYXRhSWQpO2Yuc3RyaW5nQnl0ZXM9cDtsZXQgZz10Lm1ha2VPdXRwdXQoWzJdLFwiaW50MzJcIik7cmV0dXJuIHQudHlwZWRBcnJheUZyb21IZWFwKGcpLnNldChkKSxbaCxtLGddfXZhciBIbWU9e2tlcm5lbE5hbWU6WWMsYmFja2VuZE5hbWU6XCJ3YXNtXCIsa2VybmVsRnVuYzpHbWV9O2Z1bmN0aW9uIGptZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpuLGF0dHJzOmF9PWUse2lucHV0OnJ9PW4se251bUJ1Y2tldHM6c309YSxpPXQucmVhZFN5bmMoci5kYXRhSWQpLG89SDEoaSxzKSxsPXQubWFrZU91dHB1dChyLnNoYXBlLFwiaW50MzJcIik7cmV0dXJuIHQudHlwZWRBcnJheUZyb21IZWFwKGwpLnNldChvKSxsfXZhciBxbWU9e2tlcm5lbE5hbWU6WmMsYmFja2VuZE5hbWU6XCJ3YXNtXCIsa2VybmVsRnVuYzpqbWV9LEttZT0hMCxYbWU9VXQoQm8sS21lKSxEJDtmdW5jdGlvbiBZbWUoZSl7RCQ9ZS53YXNtLmN3cmFwKExvLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBabWUoZSl7bGV0e2JhY2tlbmQ6dCxpbnB1dHM6bixhdHRyczphfT1lLHtheGlzOnIsa2VlcERpbXM6c309YSx7eDppfT1uLG89dC5kYXRhSWRNYXAuZ2V0KGkuZGF0YUlkKS5pZCxsPW8sdT1pLHt0cmFuc3Bvc2VkOnAsYXhlczpkLG9yaWdpbmFsQXhlczpjLGlucHV0V2FzVHJhbnNwb3NlZDpofT1EcyhpLHIsdCksbT1kO2lmKGgpe2xldCB4PXQuZGF0YUlkTWFwLmdldChwLmRhdGFJZCkuaWQ7eCE9PW8mJih1PXAsbD14LG09VC5nZXRJbm5lck1vc3RBeGVzKG0ubGVuZ3RoLHUuc2hhcGUubGVuZ3RoKSl9VC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcInN1bVwiLG0sdS5zaGFwZS5sZW5ndGgpO2xldFtmLGddPVQuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyh1LnNoYXBlLG0pLGI9dy5zaXplRnJvbVNoYXBlKGcpLHk9dC5tYWtlT3V0cHV0KGYsdS5kdHlwZSk7aWYody5zaXplRnJvbVNoYXBlKHUuc2hhcGUpIT09MCl7bGV0IHg9dC5kYXRhSWRNYXAuZ2V0KHkuZGF0YUlkKS5pZDtEJChsLGIsUWVbeS5kdHlwZV0seCl9aWYoaCYmdC5kaXNwb3NlRGF0YShwLmRhdGFJZCkscyl7bGV0IHg9VC5leHBhbmRTaGFwZVRvS2VlcERpbSh5LnNoYXBlLGMpO3kuc2hhcGU9eH1yZXR1cm4geX12YXIgSm1lPXtrZXJuZWxOYW1lOkxvLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpZbWUsa2VybmVsRnVuYzpabWV9LFFtZT1YZShWbyksZWZlPVhlKFVvKSxSJDtmdW5jdGlvbiB0ZmUoZSl7UiQ9ZS53YXNtLmN3cmFwKEx1LG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwiYXJyYXlcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIG5mZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpuLGF0dHJzOmF9PWUse3RlbnNvcjpyLGluZGljZXM6cyx1cGRhdGVzOml9PW4se309YSxvPXQubWFrZU91dHB1dChyLnNoYXBlLHIuZHR5cGUpO2lmKHcuc2l6ZUZyb21TaGFwZShyLnNoYXBlKT09PTApcmV0dXJuIG87bGV0e3NsaWNlUmFuazpsLG51bVVwZGF0ZXM6dSxzbGljZVNpemU6cCxzdHJpZGVzOmQsb3V0cHV0U2l6ZTpjfT1zZi5jYWxjdWxhdGVTaGFwZXMoaSxzLHIuc2hhcGUpLGg9dC5kYXRhSWRNYXAuZ2V0KHMuZGF0YUlkKS5pZCxtPXQuZGF0YUlkTWFwLmdldChpLmRhdGFJZCkuaWQsZj10LmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLGc9bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkoZCkuYnVmZmVyKSxiPXQuZGF0YUlkTWFwLmdldChvLmRhdGFJZCkuaWQ7cmV0dXJuIFIkKGgsbSxRZVtpLmR0eXBlXSxsLHUscCxnLGMsYixmKSxvfXZhciBhZmU9e2tlcm5lbE5hbWU6THUsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOnRmZSxrZXJuZWxGdW5jOm5mZX0sTSQ7ZnVuY3Rpb24gcmZlKGUpe00kPWUud2FzbS5jd3JhcChrcyxudWxsLFtcIm51bWJlclwiLFwiYXJyYXlcIixcIm51bWJlclwiLFwiYXJyYXlcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBzZmUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQscz1uLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLHtyZXBzOml9PWEsbz1uZXcgQXJyYXkoci5zaGFwZS5sZW5ndGgpO2ZvcihsZXQgYz0wO2M8by5sZW5ndGg7YysrKW9bY109ci5zaGFwZVtjXSppW2NdO2xldCBsPW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KHIuc2hhcGUpLmJ1ZmZlciksdT1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheShvKS5idWZmZXIpLHA9bi5tYWtlT3V0cHV0KG8sci5kdHlwZSksZD1uLmRhdGFJZE1hcC5nZXQocC5kYXRhSWQpLmlkO3JldHVybiBNJChzLGwsci5zaGFwZS5sZW5ndGgsdSxvLmxlbmd0aCxRZVtwLmR0eXBlXSxkKSxwfXZhciBpZmU9e2tlcm5lbE5hbWU6a3MsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOnJmZSxrZXJuZWxGdW5jOnNmZX0sTyQ7ZnVuY3Rpb24gb2ZlKGUpe08kPWUud2FzbS5jd3JhcChxdSxudWxsLFtcIm51bWJlclwiLFwiYXJyYXlcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcImJvb2xcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX12YXIgbGZlPSh7aW5wdXRzOmUsYmFja2VuZDp0LGF0dHJzOm59KT0+e2xldHt4OmF9PWUse2s6cixzb3J0ZWQ6c309bixpPXQuZGF0YUlkTWFwLmdldChhLmRhdGFJZCkuaWQsbz1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheShhLnNoYXBlKS5idWZmZXIpLGw9YS5zaGFwZS5zbGljZSgpO2xbbC5sZW5ndGgtMV09cjtsZXQgdT10Lm1ha2VPdXRwdXQobCxhLmR0eXBlKSxwPXQuZGF0YUlkTWFwLmdldCh1LmRhdGFJZCkuaWQsZD10Lm1ha2VPdXRwdXQobCxcImludDMyXCIpLGM9dC5kYXRhSWRNYXAuZ2V0KGQuZGF0YUlkKS5pZDtyZXR1cm4gTyQoaSxvLGEuc2hhcGUubGVuZ3RoLFFlW2EuZHR5cGVdLHIscyxwLGMpLFt1LGRdfSx1ZmU9e2tlcm5lbE5hbWU6cXUsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOm9mZSxrZXJuZWxGdW5jOmxmZX0sUCQ7ZnVuY3Rpb24gcGZlKGUpe1AkPWUud2FzbS5jd3JhcChLdSxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJib29sXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIGNmZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpuLGF0dHJzOmF9PWUse2ltYWdlOnIsdHJhbnNmb3JtczpzfT1uLHtpbnRlcnBvbGF0aW9uOmksZmlsbE1vZGU6byxmaWxsVmFsdWU6bCxvdXRwdXRTaGFwZTp1fT1hLFtwLGQsYyxoXT1yLnNoYXBlLFttLGZdPXUhPW51bGw/dTpbZCxjXSxnPVtwLG0sZixoXSxiPW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KHcuY29tcHV0ZVN0cmlkZXMoci5zaGFwZSkpLmJ1ZmZlcikseT1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheSh3LmNvbXB1dGVTdHJpZGVzKGcpKS5idWZmZXIpLHg9dC5tYWtlT3V0cHV0KGcsci5kdHlwZSksdj10LmRhdGFJZE1hcC5nZXQoeC5kYXRhSWQpLmlkLEk9dC5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZCxOPXQuZGF0YUlkTWFwLmdldChzLmRhdGFJZCkuaWQsQz1pPT09XCJuZWFyZXN0XCI/MToyLF87c3dpdGNoKG8pe2Nhc2VcImNvbnN0YW50XCI6Xz0xO2JyZWFrO2Nhc2VcInJlZmxlY3RcIjpfPTI7YnJlYWs7Y2FzZVwid3JhcFwiOl89MzticmVhaztjYXNlXCJuZWFyZXN0XCI6Xz00O2JyZWFrO2RlZmF1bHQ6Xz0xO2JyZWFrfXJldHVybiBQJChJLE4scy5zaGFwZVswXT4xLHAsbSxmLGgsYyxkLGIsci5zaGFwZS5sZW5ndGgtMSx5LGcubGVuZ3RoLTEsQyxfLGwsdikseH12YXIgZGZlPXtrZXJuZWxOYW1lOkt1LGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpwZmUsa2VybmVsRnVuYzpjZmV9O2Z1bmN0aW9uIGhmZShlKXtsZXR7aW5wdXRzOnQsYXR0cnM6bixiYWNrZW5kOmF9PWUse2F4aXM6cn09bix7eDpzfT10LHtvdXRwdXRWYWx1ZXM6aSxvdXRwdXRTaGFwZTpvLGluZGljZXM6bH09cTEoYS5yZWFkU3luYyhzLmRhdGFJZCkscixzLnNoYXBlLHMuZHR5cGUpO3JldHVyblthLm1ha2VPdXRwdXQobyxzLmR0eXBlLHZvaWQgMCxpKSxhLm1ha2VPdXRwdXQoW2wubGVuZ3RoXSxcImludDMyXCIsdm9pZCAwLGwpXX12YXIgbWZlPXtrZXJuZWxOYW1lOkpjLGJhY2tlbmROYW1lOlwid2FzbVwiLGtlcm5lbEZ1bmM6aGZlfTtmdW5jdGlvbiBmZmUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt2YWx1ZTpyfT10LHtheGlzOnN9PWE7czwwJiYocys9ci5zaGFwZS5sZW5ndGgpO2xldCBpPXIuc2hhcGVbc10sbz1yLnNoYXBlLmxlbmd0aCxsPW5ldyBBcnJheShvLTEpLHU9MDtmb3IobGV0IGg9MDtoPG87aCsrKWghPT1zJiYobFt1KytdPXIuc2hhcGVbaF0pO2xldCBwPW5ldyBBcnJheShpKSxkPW5ldyBBcnJheShvKS5maWxsKDApLGM9ci5zaGFwZS5zbGljZSgpO2Nbc109MTtmb3IobGV0IGg9MDtoPHAubGVuZ3RoO2grKylkW3NdPWgscFtoXT1JaSh7aW5wdXRzOnt4OnJ9LGF0dHJzOntiZWdpbjpkLHNpemU6Y30sYmFja2VuZDpufSk7cmV0dXJuIHAubWFwKCh7ZGF0YUlkOmgsZHR5cGU6bX0pPT4oe2RhdGFJZDpoLGR0eXBlOm0sc2hhcGU6bH0pKX12YXIgZ2ZlPXtrZXJuZWxOYW1lOlh1LGJhY2tlbmROYW1lOlwid2FzbVwiLGtlcm5lbEZ1bmM6ZmZlfTtmdW5jdGlvbiBiZmUoZSl7bGV0e2lucHV0czp7eDp0fSxiYWNrZW5kOm59PWUsYT1uLm1ha2VPdXRwdXQodC5zaGFwZSx0LmR0eXBlKTtyZXR1cm4gbi50eXBlZEFycmF5RnJvbUhlYXAoYSkuZmlsbCgwKSxhfXZhciB5ZmU9e2tlcm5lbE5hbWU6WXUsYmFja2VuZE5hbWU6XCJ3YXNtXCIsa2VybmVsRnVuYzpiZmV9LHhmZT1bZXVlLHR1ZSxudWUsYXVlLHN1ZSxsdWUsZ3VlLHh1ZSx2dWUsd3VlLGt1ZSxJdWUsU3VlLE51ZSxUdWUsX3VlLEx1ZSwkdWUsTXVlLFZ1ZSxLdWUsWnVlLFF1ZSx0cGUsbnBlLGFwZSxpcGUsb3BlLHBwZSxocGUsZ3BlLHhwZSxrcGUsSXBlLFNwZSxDcGUsQXBlLERwZSxPcGUsenBlLFZwZSxIcGUsS3BlLFpwZSxlY2UsdGNlLHJjZSxpY2Usb2NlLGxjZSx1Y2UscGNlLGNjZSxtY2UsZmNlLGJjZSx2Y2UsSWNlLFRjZSxfY2UsJGNlLFJjZSxPY2UsdXVlLFBjZSxMY2UsemNlLFZjZSxHY2UsamNlLFhjZSxaY2UsWWNlLFFjZSxlZGUsbmRlLHJkZSxvZGUscGRlLGhkZSxmZGUseWRlLHdkZSxTZGUsQ2RlLEFkZSxEZGUsT2RlLExkZSxCZGUsamRlLHFkZSxYZGUsWWRlLFFkZSxuaGUsc2hlLG9oZSxwaGUsZGhlLG1oZSxkJCx5aGUsd2hlLFNoZSxUaGUsRWhlLF9oZSxBaGUsRmhlLHp1ZSxSaGUsUGhlLFdoZSxVaGUsamhlLFhoZSxZaGUsWmhlLGVtZSxhbWUsaW1lLG9tZSxwbWUsY21lLGRtZSxobWUsanVlLFVkZSxtbWUsZ21lLHhtZSxrbWUsU21lLFRtZSxfbWUsRm1lLCRtZSxEbWUsTW1lLExtZSxCbWUsVW1lLEhtZSxxbWUsWG1lLEptZSxRbWUsZWZlLGFmZSxpZmUsdWZlLGRmZSxodWUsbWZlLGdmZSx5ZmVdO2ZvcihsZXQgZSBvZiB4ZmUpZWQoZSk7dmFyIHZ2PUcoKTt2di5yZWdpc3RlckZsYWcoXCJXQVNNX0hBU19TSU1EX1NVUFBPUlRcIixhc3luYygpPT57dHJ5e3JldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsOSwxLDcsMCw2NSwwLDI1MywxNSwyNiwxMV0pKX1jYXRjaChlKXtyZXR1cm4hMX19KTt2di5yZWdpc3RlckZsYWcoXCJXQVNNX0hBU19NVUxUSVRIUkVBRF9TVVBQT1JUXCIsYXN5bmMoKT0+e2lmKHZ2LmdldChcIklTX05PREVcIikpcmV0dXJuITE7dHJ5e3JldHVybiBuZXcgTWVzc2FnZUNoYW5uZWwoKS5wb3J0MS5wb3N0TWVzc2FnZShuZXcgU2hhcmVkQXJyYXlCdWZmZXIoMSkpLFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCw1LDQsMSwzLDEsMSwxMCwxMSwxLDksMCw2NSwwLDI1NCwxNiwyLDAsMjYsMTFdKSl9Y2F0Y2goZSl7cmV0dXJuITF9fSk7dmFyIFRTPXhzKFZSKCkpLHZmZT14cyhVUigpKSxDUz14cyhHUigpKSxFUz1UUy5kZWZhdWx0fHxUUyx3ZmU9Q1MuZGVmYXVsdHx8Q1MsTCQ9Y2xhc3MgZXh0ZW5kcyBGY3tjb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMud2FzbT1lLHRoaXMuZGF0YUlkTmV4dE51bWJlcj0xLHRoaXMud2FzbS50ZmpzLmluaXRXaXRoVGhyZWFkc0NvdW50KHokKSx3dj10aGlzLndhc20udGZqcy5nZXRUaHJlYWRzQ291bnQoKSx0aGlzLmRhdGFJZE1hcD1uZXcgeW0odGhpcyxUYSgpKX13cml0ZShlLHQsbil7bGV0IGE9e2lkOnRoaXMuZGF0YUlkTmV4dE51bWJlcisrfTtyZXR1cm4gdGhpcy5tb3ZlKGEsZSx0LG4sMSksYX1udW1EYXRhSWRzKCl7cmV0dXJuIHRoaXMuZGF0YUlkTWFwLm51bURhdGFJZHMoKX1hc3luYyB0aW1lKGUpe2xldCB0PXcubm93KCk7cmV0dXJuIGUoKSx7a2VybmVsTXM6dy5ub3coKS10fX1tb3ZlKGUsdCxuLGEscil7bGV0IHM9dGhpcy5kYXRhSWROZXh0TnVtYmVyKys7aWYoYT09PVwic3RyaW5nXCIpe2xldCB1PXQ7dGhpcy5kYXRhSWRNYXAuc2V0KGUse2lkOnMsc3RyaW5nQnl0ZXM6dSxzaGFwZTpuLGR0eXBlOmEsbWVtb3J5T2Zmc2V0Om51bGwscmVmQ291bnQ6cn0pO3JldHVybn1sZXQgaT13LnNpemVGcm9tU2hhcGUobiksbz1pKncuYnl0ZXNQZXJFbGVtZW50KGEpLGw9dGhpcy53YXNtLl9tYWxsb2Mobyk+Pj4wO3RoaXMuZGF0YUlkTWFwLnNldChlLHtpZDpzLG1lbW9yeU9mZnNldDpsLHNoYXBlOm4sZHR5cGU6YSxyZWZDb3VudDpyfSksdGhpcy53YXNtLnRmanMucmVnaXN0ZXJUZW5zb3IocyxpLGwpLHQhPW51bGwmJnRoaXMud2FzbS5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KHQuYnVmZmVyLHQuYnl0ZU9mZnNldCxvKSxsKX1hc3luYyByZWFkKGUpe3JldHVybiB0aGlzLnJlYWRTeW5jKGUpfXJlYWRTeW5jKGUsdCxuKXtsZXR7bWVtb3J5T2Zmc2V0OmEsZHR5cGU6cixzaGFwZTpzLHN0cmluZ0J5dGVzOml9PXRoaXMuZGF0YUlkTWFwLmdldChlKTtpZihyPT09XCJzdHJpbmdcIilyZXR1cm4odD09bnVsbHx8dD09PTApJiYobj09bnVsbHx8bj49aS5sZW5ndGgpP2k6aS5zbGljZSh0LG4pO3Q9dHx8MCxuPW58fHcuc2l6ZUZyb21TaGFwZShzKTtsZXQgbz13LmJ5dGVzUGVyRWxlbWVudChyKSxsPXRoaXMud2FzbS5IRUFQVTguc2xpY2UoYSt0Km8sYStuKm8pO3JldHVybiBTZmUobC5idWZmZXIscil9ZGlzcG9zZURhdGEoZSx0PSExKXtpZih0aGlzLmRhdGFJZE1hcC5oYXMoZSkpe2xldCBuPXRoaXMuZGF0YUlkTWFwLmdldChlKTtpZihuLnJlZkNvdW50LS0sIXQmJm4ucmVmQ291bnQ+MClyZXR1cm4hMTt0aGlzLndhc20uX2ZyZWUobi5tZW1vcnlPZmZzZXQpLHRoaXMud2FzbS50ZmpzLmRpc3Bvc2VEYXRhKG4uaWQpLHRoaXMuZGF0YUlkTWFwLmRlbGV0ZShlKX1yZXR1cm4hMH1yZWZDb3VudChlKXtyZXR1cm4gdGhpcy5kYXRhSWRNYXAuaGFzKGUpP3RoaXMuZGF0YUlkTWFwLmdldChlKS5yZWZDb3VudDowfWluY1JlZihlKXtsZXQgdD10aGlzLmRhdGFJZE1hcC5nZXQoZSk7dCE9bnVsbCYmdC5yZWZDb3VudCsrfWZsb2F0UHJlY2lzaW9uKCl7cmV0dXJuIDMyfWdldE1lbW9yeU9mZnNldChlKXtyZXR1cm4gdGhpcy5kYXRhSWRNYXAuZ2V0KGUpLm1lbW9yeU9mZnNldH1kaXNwb3NlKCl7dGhpcy53YXNtLnRmanMuZGlzcG9zZSgpLFwiUFRocmVhZFwiaW4gdGhpcy53YXNtJiZ0aGlzLndhc20uUFRocmVhZC50ZXJtaW5hdGVBbGxUaHJlYWRzKCksdGhpcy53YXNtPW51bGx9bWVtb3J5KCl7cmV0dXJue3VucmVsaWFibGU6ITF9fW1ha2VPdXRwdXQoZSx0LG4sYSl7bGV0IHI7aWYobj09bnVsbClyPXRoaXMud3JpdGUoYSE9bnVsbD9hOm51bGwsZSx0KTtlbHNle2xldCBzPXRoaXMuZGF0YUlkTmV4dE51bWJlcisrO3I9e2lkOnN9LHRoaXMuZGF0YUlkTWFwLnNldChyLHtpZDpzLG1lbW9yeU9mZnNldDpuLHNoYXBlOmUsZHR5cGU6dCxyZWZDb3VudDoxfSk7bGV0IGk9dy5zaXplRnJvbVNoYXBlKGUpO3RoaXMud2FzbS50ZmpzLnJlZ2lzdGVyVGVuc29yKHMsaSxuKX1yZXR1cm57ZGF0YUlkOnIsc2hhcGU6ZSxkdHlwZTp0fX10eXBlZEFycmF5RnJvbUhlYXAoe3NoYXBlOmUsZHR5cGU6dCxkYXRhSWQ6bn0pe2xldCBhPXRoaXMud2FzbS5IRUFQVTguYnVmZmVyLHttZW1vcnlPZmZzZXQ6cn09dGhpcy5kYXRhSWRNYXAuZ2V0KG4pLHM9dy5zaXplRnJvbVNoYXBlKGUpO3N3aXRjaCh0KXtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoYSxyLHMpO2Nhc2VcImludDMyXCI6cmV0dXJuIG5ldyBJbnQzMkFycmF5KGEscixzKTtjYXNlXCJib29sXCI6cmV0dXJuIG5ldyBVaW50OEFycmF5KGEscixzKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5rbm93biBkdHlwZSAke3R9YCl9fX07ZnVuY3Rpb24ga2ZlKGUpe3JldHVybih0LG4pPT4ody5mZXRjaChlLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKGE9PnthLm9rfHx0LmVudi5hKGBmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICcke2V9J2ApLGEuYXJyYXlCdWZmZXIoKS50aGVuKHI9PntXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShyLHQpLnRoZW4ocz0+e24ocy5pbnN0YW5jZSxzLm1vZHVsZSl9KX0pfSkse30pfWZ1bmN0aW9uIF9TKGUsdCxuKXtpZihnbSE9bnVsbClyZXR1cm4gZ207bGV0IGE9XCJ0ZmpzLWJhY2tlbmQtd2FzbS53YXNtXCI7cmV0dXJuIGUmJnQ/YT1cInRmanMtYmFja2VuZC13YXNtLXRocmVhZGVkLXNpbWQud2FzbVwiOmUmJihhPVwidGZqcy1iYWNrZW5kLXdhc20tc2ltZC53YXNtXCIpLGNjIT1udWxsJiZjY1thXSE9bnVsbD9jY1thXTpuK2F9YXN5bmMgZnVuY3Rpb24gSWZlKCl7bGV0W2UsdF09YXdhaXQgUHJvbWlzZS5hbGwoW0coKS5nZXRBc3luYyhcIldBU01fSEFTX1NJTURfU1VQUE9SVFwiKSxHKCkuZ2V0QXN5bmMoXCJXQVNNX0hBU19NVUxUSVRIUkVBRF9TVVBQT1JUXCIpXSk7cmV0dXJuIG5ldyBQcm9taXNlKChuLGEpPT57bGV0IHI9e307ci5sb2NhdGVGaWxlPShvLGwpPT57aWYoby5lbmRzV2l0aChcIi53b3JrZXIuanNcIikpe2xldCB1PXZmZS53YXNtV29ya2VyQ29udGVudHMucmVwbGFjZSgvXFxuL2csXCJcXFxcblwiKSxwPW5ldyBCbG9iKFt1XSx7dHlwZTpcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIn0pO3JldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKHApfXJldHVybiBvLmVuZHNXaXRoKFwiLndhc21cIik/X1MoZSx0LGxjIT1udWxsP2xjOmwpOmwrb30sbWsmJihyLmluc3RhbnRpYXRlV2FzbT1rZmUoX1MoZSx0LGxjIT1udWxsP2xjOlwiXCIpKSk7bGV0IHM9ITE7ci5vbkFib3J0PSgpPT57c3x8ZGN8fChkYz0hMCxhKHttZXNzYWdlOlwiTWFrZSBzdXJlIHRoZSBzZXJ2ZXIgY2FuIHNlcnZlIHRoZSBgLndhc21gIGZpbGUgcmVsYXRpdmUgdG8gdGhlIGJ1bmRsZWQganMgZmlsZS4gRm9yIG1vcmUgZGV0YWlscyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGZqcy9ibG9iL21hc3Rlci90ZmpzLWJhY2tlbmQtd2FzbS9SRUFETUUubWQjdXNpbmctYnVuZGxlcnNcIn0pKX07bGV0IGk7dCYmZSYmZ209PW51bGw/KHIubWFpblNjcmlwdFVybE9yQmxvYj1uZXcgQmxvYihbXCJ2YXIgV2FzbUJhY2tlbmRNb2R1bGVUaHJlYWRlZFNpbWQgPSBcIitFUy50b1N0cmluZygpXSx7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifSksaT1FUyhyKSk6aT13ZmUociksaS50aGVuKG89PntzPSEwLGRjPSExO2xldCBsPW51bGw7by50ZmpzPXtpbml0Om8uY3dyYXAoXCJpbml0XCIsbnVsbCxbXSksaW5pdFdpdGhUaHJlYWRzQ291bnQ6by5jd3JhcChcImluaXRfd2l0aF90aHJlYWRzX2NvdW50XCIsbnVsbCxbXCJudW1iZXJcIl0pLGdldFRocmVhZHNDb3VudDpvLmN3cmFwKFwiZ2V0X3RocmVhZHNfY291bnRcIixcIm51bWJlclwiLFtdKSxyZWdpc3RlclRlbnNvcjpvLmN3cmFwKFwicmVnaXN0ZXJfdGVuc29yXCIsbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKSxkaXNwb3NlRGF0YTpvLmN3cmFwKFwiZGlzcG9zZV9kYXRhXCIsbCxbXCJudW1iZXJcIl0pLGRpc3Bvc2U6by5jd3JhcChcImRpc3Bvc2VcIixsLFtdKX0sbih7d2FzbTpvfSl9KS5jYXRjaChhKX0pfWZ1bmN0aW9uIFNmZShlLHQpe3N3aXRjaCh0KXtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoZSk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gbmV3IEludDMyQXJyYXkoZSk7Y2FzZVwiYm9vbFwiOnJldHVybiBuZXcgVWludDhBcnJheShlKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5rbm93biBkdHlwZSAke3R9YCl9fXZhciBOZmU9W1widGZqcy1iYWNrZW5kLXdhc20ud2FzbVwiLFwidGZqcy1iYWNrZW5kLXdhc20tc2ltZC53YXNtXCIsXCJ0ZmpzLWJhY2tlbmQtd2FzbS10aHJlYWRlZC1zaW1kLndhc21cIl0sZ209bnVsbCxsYz1udWxsLGNjPXt9LGRjPSExLG1rPSExO2Z1bmN0aW9uIFRmZShlLHQ9ITEpe2lmKCR2KFwic2V0V2FzbVBhdGggaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBzZXRXYXNtUGF0aHMgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLlwiKSxkYyl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgV0FTTSBiYWNrZW5kIHdhcyBhbHJlYWR5IGluaXRpYWxpemVkLiBNYWtlIHN1cmUgeW91IGNhbGwgYHNldFdhc21QYXRoKClgIGJlZm9yZSB5b3UgY2FsbCBgdGYuc2V0QmFja2VuZCgpYCBvciBgdGYucmVhZHkoKWBcIik7Z209ZSxtaz10fWZ1bmN0aW9uIENmZShlLHQ9ITEpe2lmKGRjKXRocm93IG5ldyBFcnJvcihcIlRoZSBXQVNNIGJhY2tlbmQgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWQuIE1ha2Ugc3VyZSB5b3UgY2FsbCBgc2V0V2FzbVBhdGhzKClgIGJlZm9yZSB5b3UgY2FsbCBgdGYuc2V0QmFja2VuZCgpYCBvciBgdGYucmVhZHkoKWBcIik7aWYodHlwZW9mIGU9PVwic3RyaW5nXCIpbGM9ZTtlbHNle2NjPWU7bGV0IG49TmZlLmZpbHRlcihhPT5jY1thXT09bnVsbCk7aWYobi5sZW5ndGg+MCl0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIHdlcmUgbm8gZW50cmllcyBmb3VuZCBmb3IgdGhlIGZvbGxvd2luZyBiaW5hcmllczogJHtuLmpvaW4oXCIsXCIpfS4gUGxlYXNlIGVpdGhlciBjYWxsIHNldFdhc21QYXRocyB3aXRoIGEgbWFwIHByb3ZpZGluZyBhIHBhdGggZm9yIGVhY2ggYmluYXJ5LCBvciB3aXRoIGEgc3RyaW5nIGluZGljYXRpbmcgdGhlIGRpcmVjdG9yeSB3aGVyZSBhbGwgdGhlIGJpbmFyaWVzIGNhbiBiZSBmb3VuZC5gKX1taz10fXZhciB6JD0tMSx3dj0tMTtmdW5jdGlvbiBFZmUoZSl7eiQ9ZX1mdW5jdGlvbiBfZmUoKXtpZih3dj09PS0xKXRocm93IG5ldyBFcnJvcihcIldBU00gYmFja2VuZCBub3QgaW5pdGlhbGl6ZWQuXCIpO3JldHVybiB3dn12YXIgQWZlPVwiNC4yMi4wXCIsRmZlPTI7T20oXCJ3YXNtXCIsYXN5bmMoKT0+e2xldHt3YXNtOmV9PWF3YWl0IElmZSgpO3JldHVybiBuZXcgTCQoZSl9LEZmZSk7dmFyIEFTPVwiNC4yMi4wXCIsJGZlPVwiNC4yMi4wXCIsRGZlPVwiNC4yMi4wXCIsUmZlPVwiNC4yMi4wXCIsTWZlPVwiNC4yMi4wXCIsT2ZlPXt0ZmpzOkFTLFwidGZqcy1jb3JlXCI6QVMsXCJ0ZmpzLWNvbnZlcnRlclwiOiRmZSxcInRmanMtYmFja2VuZC1jcHVcIjpEZmUsXCJ0ZmpzLWJhY2tlbmQtd2ViZ2xcIjpSZmUsXCJ0ZmpzLWJhY2tlbmQtd2FzbVwiOk1mZX07dmFyIGlEPXt9O2F4KGlELHtBbmNob3JQb3NpdGlvbjooKT0+SWssRHJhd0JveDooKT0+T2QsRHJhd0JveE9wdGlvbnM6KCk9PlhmLERyYXdGYWNlTGFuZG1hcmtzOigpPT5vZyxEcmF3RmFjZUxhbmRtYXJrc09wdGlvbnM6KCk9PmlnLERyYXdUZXh0RmllbGQ6KCk9PnNsLERyYXdUZXh0RmllbGRPcHRpb25zOigpPT5JcCxkcmF3Q29udG91cjooKT0+UHIsZHJhd0RldGVjdGlvbnM6KCk9PlVmZSxkcmF3RmFjZUV4cHJlc3Npb25zOigpPT5HZmUsZHJhd0ZhY2VMYW5kbWFya3M6KCk9PmpmZX0pO2Z1bmN0aW9uIFByKGUsdCxuPSExKXtpZihlLmJlZ2luUGF0aCgpLHQuc2xpY2UoMSkuZm9yRWFjaCgoe3g6YSx5OnJ9LHMpPT57bGV0IGk9dFtzXTtlLm1vdmVUbyhpLngsaS55KSxlLmxpbmVUbyhhLHIpfSksbil7bGV0IGE9dFt0Lmxlbmd0aC0xXSxyPXRbMF07aWYoIWF8fCFyKXJldHVybjtlLm1vdmVUbyhhLngsYS55KSxlLmxpbmVUbyhyLngsci55KX1lLnN0cm9rZSgpfXZhciBXJD17fTtheChXJCx7Y29tcHV0ZVJlc2hhcGVkRGltZW5zaW9uczooKT0+YmssZ2V0Q2VudGVyUG9pbnQ6KCk9PmFsLGlzRGltZW5zaW9uczooKT0+amYsaXNFdmVuOigpPT5IZixpc0Zsb2F0OigpPT5nayxpc1RlbnNvcjooKT0+dGwsaXNUZW5zb3IxRDooKT0+UGZlLGlzVGVuc29yMkQ6KCk9PmZrLGlzVGVuc29yM0Q6KCk9PkxyLGlzVGVuc29yNEQ6KCk9PndhLGlzVmFsaWROdW1iZXI6KCk9PlhhLGlzVmFsaWRQcm9iYWJsaXRpeTooKT0+Z3AscmFuZ2U6KCk9PmdyLHJvdW5kOigpPT5ubH0pO3ZhciBhYT1jbGFzcyBle2NvbnN0cnVjdG9yKHQsbil7aWYoIVhhKHQpfHwhWGEobikpdGhyb3cgbmV3IEVycm9yKGBEaW1lbnNpb25zLmNvbnN0cnVjdG9yIC0gZXhwZWN0ZWQgd2lkdGggYW5kIGhlaWdodCB0byBiZSB2YWxpZCBudW1iZXJzLCBpbnN0ZWFkIGhhdmUgJHtKU09OLnN0cmluZ2lmeSh7d2lkdGg6dCxoZWlnaHQ6bn0pfWApO3RoaXMuX3dpZHRoPXQsdGhpcy5faGVpZ2h0PW59Z2V0IHdpZHRoKCl7cmV0dXJuIHRoaXMuX3dpZHRofWdldCBoZWlnaHQoKXtyZXR1cm4gdGhpcy5faGVpZ2h0fXJldmVyc2UoKXtyZXR1cm4gbmV3IGUoMS90aGlzLndpZHRoLDEvdGhpcy5oZWlnaHQpfX07ZnVuY3Rpb24gdGwoZSx0KXtyZXR1cm4gZSBpbnN0YW5jZW9mIENlJiZlLnNoYXBlLmxlbmd0aD09PXR9ZnVuY3Rpb24gUGZlKGUpe3JldHVybiB0bChlLDEpfWZ1bmN0aW9uIGZrKGUpe3JldHVybiB0bChlLDIpfWZ1bmN0aW9uIExyKGUpe3JldHVybiB0bChlLDMpfWZ1bmN0aW9uIHdhKGUpe3JldHVybiB0bChlLDQpfWZ1bmN0aW9uIGdrKGUpe3JldHVybiBlJTEhPT0wfWZ1bmN0aW9uIEhmKGUpe3JldHVybiBlJTI9PT0wfWZ1bmN0aW9uIG5sKGUsdD0yKXtsZXQgbj0xMCoqdDtyZXR1cm4gTWF0aC5mbG9vcihlKm4pL259ZnVuY3Rpb24gamYoZSl7cmV0dXJuIGUmJmUud2lkdGgmJmUuaGVpZ2h0fWZ1bmN0aW9uIGJrKHt3aWR0aDplLGhlaWdodDp0fSxuKXtsZXQgYT1uL01hdGgubWF4KHQsZSk7cmV0dXJuIG5ldyBhYShNYXRoLnJvdW5kKGUqYSksTWF0aC5yb3VuZCh0KmEpKX1mdW5jdGlvbiBhbChlKXtyZXR1cm4gZS5yZWR1Y2UoKHQsbik9PnQuYWRkKG4pLG5ldyBIZSgwLDApKS5kaXYobmV3IEhlKGUubGVuZ3RoLGUubGVuZ3RoKSl9ZnVuY3Rpb24gZ3IoZSx0LG4pe3JldHVybiBBcnJheShlKS5maWxsKDApLm1hcCgoYSxyKT0+dCtyKm4pfWZ1bmN0aW9uIFhhKGUpe3JldHVybiEhZSYmZSE9PTEvMCYmZSE9PS0xLzAmJiFOdW1iZXIuaXNOYU4oZSl8fGU9PT0wfWZ1bmN0aW9uIGdwKGUpe3JldHVybiBYYShlKSYmZT49MCYmZTw9MX12YXIgSGU9Y2xhc3MgZXtjb25zdHJ1Y3Rvcih0LG4pe3RoaXMuX3g9dCx0aGlzLl95PW59Z2V0IHgoKXtyZXR1cm4gdGhpcy5feH1nZXQgeSgpe3JldHVybiB0aGlzLl95fWFkZCh0KXtyZXR1cm4gbmV3IGUodGhpcy54K3QueCx0aGlzLnkrdC55KX1zdWIodCl7cmV0dXJuIG5ldyBlKHRoaXMueC10LngsdGhpcy55LXQueSl9bXVsKHQpe3JldHVybiBuZXcgZSh0aGlzLngqdC54LHRoaXMueSp0LnkpfWRpdih0KXtyZXR1cm4gbmV3IGUodGhpcy54L3QueCx0aGlzLnkvdC55KX1hYnMoKXtyZXR1cm4gbmV3IGUoTWF0aC5hYnModGhpcy54KSxNYXRoLmFicyh0aGlzLnkpKX1tYWduaXR1ZGUoKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCoqMit0aGlzLnkqKjIpfWZsb29yKCl7cmV0dXJuIG5ldyBlKE1hdGguZmxvb3IodGhpcy54KSxNYXRoLmZsb29yKHRoaXMueSkpfX07dmFyIG1uPWNsYXNzIGV7c3RhdGljIGlzUmVjdCh0KXtyZXR1cm4hIXQmJlt0LngsdC55LHQud2lkdGgsdC5oZWlnaHRdLmV2ZXJ5KFhhKX1zdGF0aWMgYXNzZXJ0SXNWYWxpZEJveCh0LG4sYT0hMSl7aWYoIWUuaXNSZWN0KHQpKXRocm93IG5ldyBFcnJvcihgJHtufSAtIGludmFsaWQgYm94OiAke0pTT04uc3RyaW5naWZ5KHQpfSwgZXhwZWN0ZWQgb2JqZWN0IHdpdGggcHJvcGVydGllcyB4LCB5LCB3aWR0aCwgaGVpZ2h0YCk7aWYoIWEmJih0LndpZHRoPDB8fHQuaGVpZ2h0PDApKXRocm93IG5ldyBFcnJvcihgJHtufSAtIHdpZHRoICgke3Qud2lkdGh9KSBhbmQgaGVpZ2h0ICgke3QuaGVpZ2h0fSkgbXVzdCBiZSBwb3NpdGl2ZSBudW1iZXJzYCl9Y29uc3RydWN0b3IodCxuPSEwKXtsZXQgYT10fHx7fSxyPVthLmxlZnQsYS50b3AsYS5yaWdodCxhLmJvdHRvbV0uZXZlcnkoWGEpLHM9W2EueCxhLnksYS53aWR0aCxhLmhlaWdodF0uZXZlcnkoWGEpO2lmKCFzJiYhcil0aHJvdyBuZXcgRXJyb3IoYEJveC5jb25zdHJ1Y3RvciAtIGV4cGVjdGVkIGJveCB0byBiZSBJQm91bmRpbmdCb3ggfCBJUmVjdCwgaW5zdGVhZCBoYXZlICR7SlNPTi5zdHJpbmdpZnkoYSl9YCk7bGV0W2ksbyxsLHVdPXM/W2EueCxhLnksYS53aWR0aCxhLmhlaWdodF06W2EubGVmdCxhLnRvcCxhLnJpZ2h0LWEubGVmdCxhLmJvdHRvbS1hLnRvcF07ZS5hc3NlcnRJc1ZhbGlkQm94KHt4OmkseTpvLHdpZHRoOmwsaGVpZ2h0OnV9LFwiQm94LmNvbnN0cnVjdG9yXCIsbiksdGhpcy5feD1pLHRoaXMuX3k9byx0aGlzLl93aWR0aD1sLHRoaXMuX2hlaWdodD11fWdldCB4KCl7cmV0dXJuIHRoaXMuX3h9Z2V0IHkoKXtyZXR1cm4gdGhpcy5feX1nZXQgd2lkdGgoKXtyZXR1cm4gdGhpcy5fd2lkdGh9Z2V0IGhlaWdodCgpe3JldHVybiB0aGlzLl9oZWlnaHR9Z2V0IGxlZnQoKXtyZXR1cm4gdGhpcy54fWdldCB0b3AoKXtyZXR1cm4gdGhpcy55fWdldCByaWdodCgpe3JldHVybiB0aGlzLngrdGhpcy53aWR0aH1nZXQgYm90dG9tKCl7cmV0dXJuIHRoaXMueSt0aGlzLmhlaWdodH1nZXQgYXJlYSgpe3JldHVybiB0aGlzLndpZHRoKnRoaXMuaGVpZ2h0fWdldCB0b3BMZWZ0KCl7cmV0dXJuIG5ldyBIZSh0aGlzLmxlZnQsdGhpcy50b3ApfWdldCB0b3BSaWdodCgpe3JldHVybiBuZXcgSGUodGhpcy5yaWdodCx0aGlzLnRvcCl9Z2V0IGJvdHRvbUxlZnQoKXtyZXR1cm4gbmV3IEhlKHRoaXMubGVmdCx0aGlzLmJvdHRvbSl9Z2V0IGJvdHRvbVJpZ2h0KCl7cmV0dXJuIG5ldyBIZSh0aGlzLnJpZ2h0LHRoaXMuYm90dG9tKX1yb3VuZCgpe2xldFt0LG4sYSxyXT1bdGhpcy54LHRoaXMueSx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0XS5tYXAocz0+TWF0aC5yb3VuZChzKSk7cmV0dXJuIG5ldyBlKHt4OnQseTpuLHdpZHRoOmEsaGVpZ2h0OnJ9KX1mbG9vcigpe2xldFt0LG4sYSxyXT1bdGhpcy54LHRoaXMueSx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0XS5tYXAocz0+TWF0aC5mbG9vcihzKSk7cmV0dXJuIG5ldyBlKHt4OnQseTpuLHdpZHRoOmEsaGVpZ2h0OnJ9KX10b1NxdWFyZSgpe2xldHt4OnQseTpuLHdpZHRoOmEsaGVpZ2h0OnJ9PXRoaXMscz1NYXRoLmFicyhhLXIpO3JldHVybiBhPHImJih0LT1zLzIsYSs9cykscjxhJiYobi09cy8yLHIrPXMpLG5ldyBlKHt4OnQseTpuLHdpZHRoOmEsaGVpZ2h0OnJ9KX1yZXNjYWxlKHQpe2xldCBuPWpmKHQpP3Qud2lkdGg6dCxhPWpmKHQpP3QuaGVpZ2h0OnQ7cmV0dXJuIG5ldyBlKHt4OnRoaXMueCpuLHk6dGhpcy55KmEsd2lkdGg6dGhpcy53aWR0aCpuLGhlaWdodDp0aGlzLmhlaWdodCphfSl9cGFkKHQsbil7bGV0W2EscixzLGldPVt0aGlzLngtdC8yLHRoaXMueS1uLzIsdGhpcy53aWR0aCt0LHRoaXMuaGVpZ2h0K25dO3JldHVybiBuZXcgZSh7eDphLHk6cix3aWR0aDpzLGhlaWdodDppfSl9Y2xpcEF0SW1hZ2VCb3JkZXJzKHQsbil7bGV0e3g6YSx5OnIscmlnaHQ6cyxib3R0b206aX09dGhpcyxvPU1hdGgubWF4KGEsMCksbD1NYXRoLm1heChyLDApLHU9cy1vLHA9aS1sLGQ9TWF0aC5taW4odSx0LW8pLGM9TWF0aC5taW4ocCxuLWwpO3JldHVybiBuZXcgZSh7eDpvLHk6bCx3aWR0aDpkLGhlaWdodDpjfSkuZmxvb3IoKX1zaGlmdCh0LG4pe2xldHt3aWR0aDphLGhlaWdodDpyfT10aGlzLHM9dGhpcy54K3QsaT10aGlzLnkrbjtyZXR1cm4gbmV3IGUoe3g6cyx5Omksd2lkdGg6YSxoZWlnaHQ6cn0pfXBhZEF0Qm9yZGVycyh0LG4pe2xldCBhPXRoaXMud2lkdGgrMSxyPXRoaXMuaGVpZ2h0KzEscz0xLGk9MSxvPWEsbD1yLHU9dGhpcy5sZWZ0LHA9dGhpcy50b3AsZD10aGlzLnJpZ2h0LGM9dGhpcy5ib3R0b207cmV0dXJuIGQ+biYmKG89LWQrbithLGQ9biksYz50JiYobD0tYyt0K3IsYz10KSx1PDEmJihsPTItdSx1PTEpLHA8MSYmKGw9Mi1wLHA9MSkse2R5OmksZWR5OmwsZHg6cyxlZHg6byx5OnAsZXk6Yyx4OnUsZXg6ZCx3OmEsaDpyfX1jYWxpYnJhdGUodCl7cmV0dXJuIG5ldyBlKHtsZWZ0OnRoaXMubGVmdCt0LmxlZnQqdGhpcy53aWR0aCx0b3A6dGhpcy50b3ArdC50b3AqdGhpcy5oZWlnaHQscmlnaHQ6dGhpcy5yaWdodCt0LnJpZ2h0KnRoaXMud2lkdGgsYm90dG9tOnRoaXMuYm90dG9tK3QuYm90dG9tKnRoaXMuaGVpZ2h0fSkudG9TcXVhcmUoKS5yb3VuZCgpfX07dmFyIGJwPWNsYXNzIGV4dGVuZHMgbW57Y29uc3RydWN0b3IodCxuLGEscixzPSExKXtzdXBlcih7bGVmdDp0LHRvcDpuLHJpZ2h0OmEsYm90dG9tOnJ9LHMpfX07dmFyIHlwPWNsYXNzIGV7Y29uc3RydWN0b3IodCxuLGEscixzKXt0aGlzLl9pbWFnZURpbXM9bmV3IGFhKHMud2lkdGgscy5oZWlnaHQpLHRoaXMuX3Njb3JlPXQsdGhpcy5fY2xhc3NTY29yZT1uLHRoaXMuX2NsYXNzTmFtZT1hLHRoaXMuX2JveD1uZXcgbW4ocikucmVzY2FsZSh0aGlzLl9pbWFnZURpbXMpfWdldCBzY29yZSgpe3JldHVybiB0aGlzLl9zY29yZX1nZXQgY2xhc3NTY29yZSgpe3JldHVybiB0aGlzLl9jbGFzc1Njb3JlfWdldCBjbGFzc05hbWUoKXtyZXR1cm4gdGhpcy5fY2xhc3NOYW1lfWdldCBib3goKXtyZXR1cm4gdGhpcy5fYm94fWdldCBpbWFnZURpbXMoKXtyZXR1cm4gdGhpcy5faW1hZ2VEaW1zfWdldCBpbWFnZVdpZHRoKCl7cmV0dXJuIHRoaXMuaW1hZ2VEaW1zLndpZHRofWdldCBpbWFnZUhlaWdodCgpe3JldHVybiB0aGlzLmltYWdlRGltcy5oZWlnaHR9Z2V0IHJlbGF0aXZlQm94KCl7cmV0dXJuIG5ldyBtbih0aGlzLl9ib3gpLnJlc2NhbGUodGhpcy5pbWFnZURpbXMucmV2ZXJzZSgpKX1mb3JTaXplKHQsbil7cmV0dXJuIG5ldyBlKHRoaXMuc2NvcmUsdGhpcy5jbGFzc1Njb3JlLHRoaXMuY2xhc3NOYW1lLHRoaXMucmVsYXRpdmVCb3gse3dpZHRoOnQsaGVpZ2h0Om59KX19O3ZhciBGdD1jbGFzcyBlIGV4dGVuZHMgeXB7Y29uc3RydWN0b3IodCxuLGEpe3N1cGVyKHQsdCxcIlwiLG4sYSl9Zm9yU2l6ZSh0LG4pe2xldHtzY29yZTphLHJlbGF0aXZlQm94OnIsaW1hZ2VEaW1zOnN9PXN1cGVyLmZvclNpemUodCxuKTtyZXR1cm4gbmV3IGUoYSxyLHMpfX07ZnVuY3Rpb24gQiQoZSx0LG49ITApe2xldCBhPU1hdGgubWF4KDAsTWF0aC5taW4oZS5yaWdodCx0LnJpZ2h0KS1NYXRoLm1heChlLmxlZnQsdC5sZWZ0KSkscj1NYXRoLm1heCgwLE1hdGgubWluKGUuYm90dG9tLHQuYm90dG9tKS1NYXRoLm1heChlLnRvcCx0LnRvcCkpLHM9YSpyO3JldHVybiBuP3MvKGUuYXJlYSt0LmFyZWEtcyk6cy9NYXRoLm1pbihlLmFyZWEsdC5hcmVhKX1mdW5jdGlvbiBWJChlKXtsZXQgdD1lLm1hcChvPT5vLngpLG49ZS5tYXAobz0+by55KSxhPXQucmVkdWNlKChvLGwpPT5sPG8/bDpvLDEvMCkscj1uLnJlZHVjZSgobyxsKT0+bDxvP2w6bywxLzApLHM9dC5yZWR1Y2UoKG8sbCk9Pm88bD9sOm8sMCksaT1uLnJlZHVjZSgobyxsKT0+bzxsP2w6bywwKTtyZXR1cm4gbmV3IGJwKGEscixzLGkpfWZ1bmN0aW9uIFUkKGUsdCxuLGE9ITApe2xldCByPXQubWFwKChpLG8pPT4oe3Njb3JlOmksYm94SW5kZXg6b30pKS5zb3J0KChpLG8pPT5pLnNjb3JlLW8uc2NvcmUpLm1hcChpPT5pLmJveEluZGV4KSxzPVtdO2Zvcig7ci5sZW5ndGg+MDspe2xldCBpPXIucG9wKCk7cy5wdXNoKGkpO2xldCBvPXIsbD1bXTtmb3IobGV0IHU9MDt1PG8ubGVuZ3RoO3UrKyl7bGV0IHA9b1t1XSxkPWVbaV0sYz1lW3BdO2wucHVzaChCJChkLGMsYSkpfXI9ci5maWx0ZXIoKHUscCk9PmxbcF08PW4pfXJldHVybiBzfWZ1bmN0aW9uIGJyKGUsdCl7cmV0dXJuIE8oKCk9PntsZXRbbixhLHJdPXQscz15bihbLi4uZS5zaGFwZS5zbGljZSgwLDMpLDFdLG4sXCJmbG9hdDMyXCIpLGk9eW4oWy4uLmUuc2hhcGUuc2xpY2UoMCwzKSwxXSxhLFwiZmxvYXQzMlwiKSxvPXluKFsuLi5lLnNoYXBlLnNsaWNlKDAsMyksMV0scixcImZsb2F0MzJcIiksbD1ldChbcyxpLG9dLDMpO3JldHVybiBwZShlLGwpfSl9ZnVuY3Rpb24gRyQoZSx0PSExKXtyZXR1cm4gTygoKT0+e2xldFtuLGFdPWUuc2hhcGUuc2xpY2UoMSk7aWYobj09PWEpcmV0dXJuIGU7bGV0IHI9TWF0aC5hYnMobi1hKSxzPU1hdGgucm91bmQocioodD8uNToxKSksaT1uPmE/MjoxLG89Yz0+e2xldCBoPWUuc2hhcGUuc2xpY2UoKTtyZXR1cm4gaFtpXT1jLHluKGgsMCxcImZsb2F0MzJcIil9LGw9byhzKSx1PXItbC5zaGFwZVtpXSxkPVt0JiZ1P28odSk6bnVsbCxlLGxdLmZpbHRlcihjPT4hIWMpLm1hcChjPT5yZShjLFwiZmxvYXQzMlwiKSk7cmV0dXJuIGV0KGQsaSl9KX1mdW5jdGlvbiB5MGUoZSl7bGV0IHQ9ZS5zbGljZSgpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+MDtuLS0pe2xldCBhPU1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoobisxKSkscj10W25dO3Rbbl09dFthXSx0W2FdPXJ9cmV0dXJuIHR9ZnVuY3Rpb24gcWYoZSl7cmV0dXJuIDEvKDErTWF0aC5leHAoLWUpKX1mdW5jdGlvbiB2MGUoZSl7cmV0dXJuIE1hdGgubG9nKGUvKDEtZSkpfXZhciB4cD1jbGFzcyBleHRlbmRzIG1ue2NvbnN0cnVjdG9yKHQsbixhLHIscz0hMSl7c3VwZXIoe3g6dCx5Om4sd2lkdGg6YSxoZWlnaHQ6cn0scyl9fTt2YXIgTGZlPS41LHpmZT0uNDMsV2ZlPS40NSxrYT1jbGFzc3tjb25zdHJ1Y3Rvcih0LG4sYT1uZXcgSGUoMCwwKSl7bGV0e3dpZHRoOnIsaGVpZ2h0OnN9PW47dGhpcy5faW1nRGltcz1uZXcgYWEocixzKSx0aGlzLl9zaGlmdD1hLHRoaXMuX3Bvc2l0aW9ucz10Lm1hcChpPT5pLm11bChuZXcgSGUocixzKSkuYWRkKGEpKX1nZXQgc2hpZnQoKXtyZXR1cm4gbmV3IEhlKHRoaXMuX3NoaWZ0LngsdGhpcy5fc2hpZnQueSl9Z2V0IGltYWdlV2lkdGgoKXtyZXR1cm4gdGhpcy5faW1nRGltcy53aWR0aH1nZXQgaW1hZ2VIZWlnaHQoKXtyZXR1cm4gdGhpcy5faW1nRGltcy5oZWlnaHR9Z2V0IHBvc2l0aW9ucygpe3JldHVybiB0aGlzLl9wb3NpdGlvbnN9Z2V0IHJlbGF0aXZlUG9zaXRpb25zKCl7cmV0dXJuIHRoaXMuX3Bvc2l0aW9ucy5tYXAodD0+dC5zdWIodGhpcy5fc2hpZnQpLmRpdihuZXcgSGUodGhpcy5pbWFnZVdpZHRoLHRoaXMuaW1hZ2VIZWlnaHQpKSl9Zm9yU2l6ZSh0LG4pe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnJlbGF0aXZlUG9zaXRpb25zLHt3aWR0aDp0LGhlaWdodDpufSl9c2hpZnRCeSh0LG4pe3JldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnJlbGF0aXZlUG9zaXRpb25zLHRoaXMuX2ltZ0RpbXMsbmV3IEhlKHQsbikpfXNoaWZ0QnlQb2ludCh0KXtyZXR1cm4gdGhpcy5zaGlmdEJ5KHQueCx0LnkpfWFsaWduKHQsbj17fSl7aWYodCl7bGV0IHM9dCBpbnN0YW5jZW9mIEZ0P3QuYm94LmZsb29yKCk6bmV3IG1uKHQpO3JldHVybiB0aGlzLnNoaWZ0Qnkocy54LHMueSkuYWxpZ24obnVsbCxuKX1sZXR7dXNlRGxpYkFsaWdubWVudDphLG1pbkJveFBhZGRpbmc6cn09e3VzZURsaWJBbGlnbm1lbnQ6ITEsbWluQm94UGFkZGluZzouMiwuLi5ufTtyZXR1cm4gYT90aGlzLmFsaWduRGxpYigpOnRoaXMuYWxpZ25NaW5CYm94KHIpfWFsaWduRGxpYigpe2xldCB0PXRoaXMuZ2V0UmVmUG9pbnRzRm9yQWxpZ25tZW50KCksW24sYSxyXT10LHM9ZD0+ci5zdWIoZCkubWFnbml0dWRlKCksaT0ocyhuKStzKGEpKS8yLG89TWF0aC5mbG9vcihpL1dmZSksbD1hbCh0KSx1PU1hdGguZmxvb3IoTWF0aC5tYXgoMCxsLngtTGZlKm8pKSxwPU1hdGguZmxvb3IoTWF0aC5tYXgoMCxsLnktemZlKm8pKTtyZXR1cm4gbmV3IHhwKHUscCxNYXRoLm1pbihvLHRoaXMuaW1hZ2VXaWR0aCt1KSxNYXRoLm1pbihvLHRoaXMuaW1hZ2VIZWlnaHQrcCkpfWFsaWduTWluQmJveCh0KXtsZXQgbj1WJCh0aGlzLnBvc2l0aW9ucyk7cmV0dXJuIG4ucGFkKG4ud2lkdGgqdCxuLmhlaWdodCp0KX1nZXRSZWZQb2ludHNGb3JBbGlnbm1lbnQoKXt0aHJvdyBuZXcgRXJyb3IoXCJnZXRSZWZQb2ludHNGb3JBbGlnbm1lbnQgbm90IGltcGxlbWVudGVkIGJ5IGJhc2UgY2xhc3NcIil9fTt2YXIgSCQ9Y2xhc3MgZXh0ZW5kcyBrYXtnZXRSZWZQb2ludHNGb3JBbGlnbm1lbnQoKXtsZXQgdD10aGlzLnBvc2l0aW9ucztyZXR1cm5bdFswXSx0WzFdLGFsKFt0WzNdLHRbNF1dKV19fTt2YXIgdnA9Y2xhc3MgZXh0ZW5kcyBrYXtnZXRKYXdPdXRsaW5lKCl7cmV0dXJuIHRoaXMucG9zaXRpb25zLnNsaWNlKDAsMTcpfWdldExlZnRFeWVCcm93KCl7cmV0dXJuIHRoaXMucG9zaXRpb25zLnNsaWNlKDE3LDIyKX1nZXRSaWdodEV5ZUJyb3coKXtyZXR1cm4gdGhpcy5wb3NpdGlvbnMuc2xpY2UoMjIsMjcpfWdldE5vc2UoKXtyZXR1cm4gdGhpcy5wb3NpdGlvbnMuc2xpY2UoMjcsMzYpfWdldExlZnRFeWUoKXtyZXR1cm4gdGhpcy5wb3NpdGlvbnMuc2xpY2UoMzYsNDIpfWdldFJpZ2h0RXllKCl7cmV0dXJuIHRoaXMucG9zaXRpb25zLnNsaWNlKDQyLDQ4KX1nZXRNb3V0aCgpe3JldHVybiB0aGlzLnBvc2l0aW9ucy5zbGljZSg0OCw2OCl9Z2V0UmVmUG9pbnRzRm9yQWxpZ25tZW50KCl7cmV0dXJuW3RoaXMuZ2V0TGVmdEV5ZSgpLHRoaXMuZ2V0UmlnaHRFeWUoKSx0aGlzLmdldE1vdXRoKCldLm1hcChhbCl9fTt2YXIgRGQ9Y2xhc3N7Y29uc3RydWN0b3IodCxuKXt0aGlzLl9sYWJlbD10LHRoaXMuX2Rpc3RhbmNlPW59Z2V0IGxhYmVsKCl7cmV0dXJuIHRoaXMuX2xhYmVsfWdldCBkaXN0YW5jZSgpe3JldHVybiB0aGlzLl9kaXN0YW5jZX10b1N0cmluZyh0PSEwKXtyZXR1cm5gJHt0aGlzLmxhYmVsfSR7dD9gICgke25sKHRoaXMuZGlzdGFuY2UpfSlgOlwiXCJ9YH19O3ZhciBSZD1jbGFzcyBleHRlbmRzIG1ue3N0YXRpYyBhc3NlcnRJc1ZhbGlkTGFiZWxlZEJveCh0LG4pe2lmKG1uLmFzc2VydElzVmFsaWRCb3godCxuKSwhWGEodC5sYWJlbCkpdGhyb3cgbmV3IEVycm9yKGAke259IC0gZXhwZWN0ZWQgcHJvcGVydHkgbGFiZWwgKCR7dC5sYWJlbH0pIHRvIGJlIGEgbnVtYmVyYCl9Y29uc3RydWN0b3IodCxuKXtzdXBlcih0KSx0aGlzLl9sYWJlbD1ufWdldCBsYWJlbCgpe3JldHVybiB0aGlzLl9sYWJlbH19O3ZhciBybD1jbGFzcyBle2NvbnN0cnVjdG9yKHQsbil7aWYodHlwZW9mIHQhPVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKFwiTGFiZWxlZEZhY2VEZXNjcmlwdG9ycyAtIGNvbnN0cnVjdG9yIGV4cGVjdGVkIGxhYmVsIHRvIGJlIGEgc3RyaW5nXCIpO2lmKCFBcnJheS5pc0FycmF5KG4pfHxuLnNvbWUoYT0+IShhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSkpdGhyb3cgbmV3IEVycm9yKFwiTGFiZWxlZEZhY2VEZXNjcmlwdG9ycyAtIGNvbnN0cnVjdG9yIGV4cGVjdGVkIGRlc2NyaXB0b3JzIHRvIGJlIGFuIGFycmF5IG9mIEZsb2F0MzJBcnJheVwiKTt0aGlzLl9sYWJlbD10LHRoaXMuX2Rlc2NyaXB0b3JzPW59Z2V0IGxhYmVsKCl7cmV0dXJuIHRoaXMuX2xhYmVsfWdldCBkZXNjcmlwdG9ycygpe3JldHVybiB0aGlzLl9kZXNjcmlwdG9yc310b0pTT04oKXtyZXR1cm57bGFiZWw6dGhpcy5sYWJlbCxkZXNjcmlwdG9yczp0aGlzLmRlc2NyaXB0b3JzLm1hcCh0PT5BcnJheS5mcm9tKHQpKX19c3RhdGljIGZyb21KU09OKHQpe2xldCBuPXQuZGVzY3JpcHRvcnMubWFwKGE9Pm5ldyBGbG9hdDMyQXJyYXkoYSkpO3JldHVybiBuZXcgZSh0LmxhYmVsLG4pfX07dmFyIGokPWNsYXNzIGV4dGVuZHMgUmR7c3RhdGljIGFzc2VydElzVmFsaWRQcmVkaWN0ZWRCb3godCxuKXtpZihSZC5hc3NlcnRJc1ZhbGlkTGFiZWxlZEJveCh0LG4pLCFncCh0LnNjb3JlKXx8IWdwKHQuY2xhc3NTY29yZSkpdGhyb3cgbmV3IEVycm9yKGAke259IC0gZXhwZWN0ZWQgcHJvcGVydGllcyBzY29yZSAoJHt0LnNjb3JlfSkgYW5kICgke3QuY2xhc3NTY29yZX0pIHRvIGJlIGEgbnVtYmVyIGJldHdlZW4gWzAsIDFdYCl9Y29uc3RydWN0b3IodCxuLGEscil7c3VwZXIodCxuKSx0aGlzLl9zY29yZT1hLHRoaXMuX2NsYXNzU2NvcmU9cn1nZXQgc2NvcmUoKXtyZXR1cm4gdGhpcy5fc2NvcmV9Z2V0IGNsYXNzU2NvcmUoKXtyZXR1cm4gdGhpcy5fY2xhc3NTY29yZX19O2Z1bmN0aW9uIHpyKGUpe3JldHVybiBlLmRldGVjdGlvbiBpbnN0YW5jZW9mIEZ0fWZ1bmN0aW9uIHdwKGUsdCl7cmV0dXJuey4uLmUsLi4ue2RldGVjdGlvbjp0fX19ZnVuY3Rpb24geWsoKXtsZXQgZT13aW5kb3cuZmV0Y2g7aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiZmV0Y2ggLSBtaXNzaW5nIGZldGNoIGltcGxlbWVudGF0aW9uIGZvciBicm93c2VyIGVudmlyb25tZW50XCIpO3JldHVybntDYW52YXM6SFRNTENhbnZhc0VsZW1lbnQsQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELEltYWdlOkhUTUxJbWFnZUVsZW1lbnQsSW1hZ2VEYXRhLFZpZGVvOkhUTUxWaWRlb0VsZW1lbnQsY3JlYXRlQ2FudmFzRWxlbWVudDooKT0+ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxjcmVhdGVJbWFnZUVsZW1lbnQ6KCk9PmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiksY3JlYXRlVmlkZW9FbGVtZW50OigpPT5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIiksZmV0Y2g6ZSxyZWFkRmlsZTooKT0+e3Rocm93IG5ldyBFcnJvcihcInJlYWRGaWxlIC0gZmlsZXN5c3RlbSBub3QgYXZhaWxhYmxlIGZvciBicm93c2VyIGVudmlyb25tZW50XCIpfX19ZnVuY3Rpb24gTWQoKXtyZXR1cm4gdHlwZW9mIGdsb2JhbD09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MhPVwidW5kZWZpbmVkXCImJnByb2Nlc3MudmVyc2lvbnMhPW51bGwmJnByb2Nlc3MudmVyc2lvbnMubm9kZSE9bnVsbH1mdW5jdGlvbiBLZihlKXtsZXQgdD1cIlwiO2lmKCFlJiZNZCgpKXRyeXtlPXdSKFwiZnNcIil9Y2F0Y2goYSl7dD1hLnRvU3RyaW5nKCl9cmV0dXJue3JlYWRGaWxlOmU/YT0+bmV3IFByb21pc2UoKHIscyk9PntlLnJlYWRGaWxlKGEsKGksbyk9Pmk/cyhpKTpyKG8pKX0pOigpPT57dGhyb3cgbmV3IEVycm9yKGByZWFkRmlsZSAtIGZhaWxlZCB0byByZXF1aXJlIGZzIGluIG5vZGVqcyBlbnZpcm9ubWVudCB3aXRoIGVycm9yOiAke3R9YCl9fX1mdW5jdGlvbiB4aygpe2xldCBlPWdsb2JhbC5DYW52YXN8fGdsb2JhbC5IVE1MQ2FudmFzRWxlbWVudCx0PWdsb2JhbC5JbWFnZXx8Z2xvYmFsLkhUTUxJbWFnZUVsZW1lbnQsbj1nbG9iYWwuVmlkZW98fGdsb2JhbC5IVE1MVmlkZW9FbGVtZW50LGE9KCk9PntpZihlKXJldHVybiBuZXcgZTt0aHJvdyBuZXcgRXJyb3IoXCJjcmVhdGVDYW52YXNFbGVtZW50IC0gbWlzc2luZyBDYW52YXMgaW1wbGVtZW50YXRpb24gZm9yIG5vZGVqcyBlbnZpcm9ubWVudFwiKX0scj0oKT0+e2lmKHQpcmV0dXJuIG5ldyB0O3Rocm93IG5ldyBFcnJvcihcImNyZWF0ZUltYWdlRWxlbWVudCAtIG1pc3NpbmcgSW1hZ2UgaW1wbGVtZW50YXRpb24gZm9yIG5vZGVqcyBlbnZpcm9ubWVudFwiKX0scz0oKT0+e2lmKG4pcmV0dXJuIG5ldyBuO3Rocm93IG5ldyBFcnJvcihcImNyZWF0ZVZpZGVvRWxlbWVudCAtIG1pc3NpbmcgVmlkZW8gaW1wbGVtZW50YXRpb24gZm9yIG5vZGVqcyBlbnZpcm9ubWVudFwiKX0saT1nbG9iYWwuZmV0Y2gsbz1LZigpO3JldHVybntDYW52YXM6ZXx8Y2xhc3N7fSxDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ6Z2xvYmFsLkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHx8Y2xhc3N7fSxJbWFnZTp0fHxjbGFzc3t9LEltYWdlRGF0YTpnbG9iYWwuSW1hZ2VEYXRhfHxjbGFzc3t9LFZpZGVvOmdsb2JhbC5IVE1MVmlkZW9FbGVtZW50fHxjbGFzc3t9LGNyZWF0ZUNhbnZhc0VsZW1lbnQ6YSxjcmVhdGVJbWFnZUVsZW1lbnQ6cixjcmVhdGVWaWRlb0VsZW1lbnQ6cyxmZXRjaDppLC4uLm99fWZ1bmN0aW9uIHZrKCl7cmV0dXJuIHR5cGVvZiB3aW5kb3c9PVwib2JqZWN0XCImJnR5cGVvZiBkb2N1bWVudCE9XCJ1bmRlZmluZWRcIiYmdHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQhPVwidW5kZWZpbmVkXCImJnR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCE9XCJ1bmRlZmluZWRcIiYmdHlwZW9mIEhUTUxWaWRlb0VsZW1lbnQhPVwidW5kZWZpbmVkXCImJnR5cGVvZiBJbWFnZURhdGEhPVwidW5kZWZpbmVkXCImJnR5cGVvZiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQhPVwidW5kZWZpbmVkXCJ9dmFyIGxuO2Z1bmN0aW9uIEJmZSgpe2lmKCFsbil0aHJvdyBuZXcgRXJyb3IoXCJnZXRFbnYgLSBlbnZpcm9ubWVudCBpcyBub3QgZGVmaW5lZCwgY2hlY2sgaXNOb2RlanMoKSBhbmQgaXNCcm93c2VyKClcIik7cmV0dXJuIGxufWZ1bmN0aW9uIHdrKGUpe2xuPWV9ZnVuY3Rpb24ga2soKXtyZXR1cm4gdmsoKT93ayh5aygpKTpNZCgpP3drKHhrKCkpOm51bGx9ZnVuY3Rpb24gVmZlKGUpe2lmKGxufHxraygpLCFsbil0aHJvdyBuZXcgRXJyb3IoXCJtb25rZXlQYXRjaCAtIGVudmlyb25tZW50IGlzIG5vdCBkZWZpbmVkLCBjaGVjayBpc05vZGVqcygpIGFuZCBpc0Jyb3dzZXIoKVwiKTtsZXR7Q2FudmFzOnQ9bG4uQ2FudmFzLEltYWdlOm49bG4uSW1hZ2V9PWU7bG4uQ2FudmFzPXQsbG4uSW1hZ2U9bixsbi5jcmVhdGVDYW52YXNFbGVtZW50PWUuY3JlYXRlQ2FudmFzRWxlbWVudHx8KCgpPT5uZXcgdCksbG4uY3JlYXRlSW1hZ2VFbGVtZW50PWUuY3JlYXRlSW1hZ2VFbGVtZW50fHwoKCk9Pm5ldyBuKSxsbi5JbWFnZURhdGE9ZS5JbWFnZURhdGF8fGxuLkltYWdlRGF0YSxsbi5WaWRlbz1lLlZpZGVvfHxsbi5WaWRlbyxsbi5mZXRjaD1lLmZldGNofHxsbi5mZXRjaCxsbi5yZWFkRmlsZT1lLnJlYWRGaWxlfHxsbi5yZWFkRmlsZX12YXIgYXQ9e2dldEVudjpCZmUsc2V0RW52OndrLGluaXRpYWxpemU6a2ssY3JlYXRlQnJvd3NlckVudjp5ayxjcmVhdGVGaWxlU3lzdGVtOktmLGNyZWF0ZU5vZGVqc0Vudjp4ayxtb25rZXlQYXRjaDpWZmUsaXNCcm93c2VyOnZrLGlzTm9kZWpzOk1kfTtraygpO2Z1bmN0aW9uIGtwKGUpe3JldHVybiFhdC5pc05vZGVqcygpJiZ0eXBlb2YgZT09XCJzdHJpbmdcIj9kb2N1bWVudC5nZXRFbGVtZW50QnlJZChlKTplfWZ1bmN0aW9uIHJhKGUpe2xldHtDYW52YXM6dCxDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ6bn09YXQuZ2V0RW52KCk7aWYoZSBpbnN0YW5jZW9mIG4pcmV0dXJuIGU7bGV0IGE9a3AoZSk7aWYoIShhIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IEVycm9yKFwicmVzb2x2ZUNvbnRleHQyZCAtIGV4cGVjdGVkIGNhbnZhcyB0byBiZSBvZiBpbnN0YW5jZSBvZiBDYW52YXNcIik7bGV0IHI9YS5nZXRDb250ZXh0KFwiMmRcIix7d2lsbFJlYWRGcmVxdWVudGx5OiEwfSk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwicmVzb2x2ZUNvbnRleHQyZCAtIGNhbnZhcyAyZCBjb250ZXh0IGlzIG51bGxcIik7cmV0dXJuIHJ9dmFyIElrPShyPT4oci5UT1BfTEVGVD1cIlRPUF9MRUZUXCIsci5UT1BfUklHSFQ9XCJUT1BfUklHSFRcIixyLkJPVFRPTV9MRUZUPVwiQk9UVE9NX0xFRlRcIixyLkJPVFRPTV9SSUdIVD1cIkJPVFRPTV9SSUdIVFwiLHIpKShJa3x8e30pLElwPWNsYXNze2NvbnN0cnVjdG9yKHQ9e30pe2xldHthbmNob3JQb3NpdGlvbjpuLGJhY2tncm91bmRDb2xvcjphLGZvbnRDb2xvcjpyLGZvbnRTaXplOnMsZm9udFN0eWxlOmkscGFkZGluZzpvfT10O3RoaXMuYW5jaG9yUG9zaXRpb249bnx8XCJUT1BfTEVGVFwiLHRoaXMuYmFja2dyb3VuZENvbG9yPWF8fFwicmdiYSgwLCAwLCAwLCAwLjUpXCIsdGhpcy5mb250Q29sb3I9cnx8XCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDEpXCIsdGhpcy5mb250U2l6ZT1zfHwxNCx0aGlzLmZvbnRTdHlsZT1pfHxcIkdlb3JnaWFcIix0aGlzLnBhZGRpbmc9b3x8NH19LHNsPWNsYXNzIGV7Y29uc3RydWN0b3IodCxuLGE9e30pe3RoaXMudGV4dD10eXBlb2YgdD09XCJzdHJpbmdcIj9bdF06dCBpbnN0YW5jZW9mIGU/dC50ZXh0OnQsdGhpcy5hbmNob3I9bix0aGlzLm9wdGlvbnM9bmV3IElwKGEpfW1lYXN1cmVXaWR0aCh0KXtsZXR7cGFkZGluZzpufT10aGlzLm9wdGlvbnM7cmV0dXJuIHRoaXMudGV4dC5tYXAoYT0+dC5tZWFzdXJlVGV4dChhKS53aWR0aCkucmVkdWNlKChhLHIpPT5hPHI/cjphLDApKzIqbn1tZWFzdXJlSGVpZ2h0KCl7bGV0e2ZvbnRTaXplOnQscGFkZGluZzpufT10aGlzLm9wdGlvbnM7cmV0dXJuIHRoaXMudGV4dC5sZW5ndGgqdCsyKm59Z2V0VXBwZXJMZWZ0KHQsbil7bGV0e2FuY2hvclBvc2l0aW9uOmF9PXRoaXMub3B0aW9ucyxyPWE9PT1cIkJPVFRPTV9SSUdIVFwifHxhPT09XCJUT1BfUklHSFRcIixzPWE9PT1cIkJPVFRPTV9MRUZUXCJ8fGE9PT1cIkJPVFRPTV9SSUdIVFwiLGk9dGhpcy5tZWFzdXJlV2lkdGgodCksbz10aGlzLm1lYXN1cmVIZWlnaHQoKSxsPXI/dGhpcy5hbmNob3IueC1pOnRoaXMuYW5jaG9yLngsdT1zP3RoaXMuYW5jaG9yLnktbzp0aGlzLmFuY2hvci55O2lmKG4pe2xldHt3aWR0aDpwLGhlaWdodDpkfT1uLGM9TWF0aC5tYXgoTWF0aC5taW4obCxwLWkpLDApLGg9TWF0aC5tYXgoTWF0aC5taW4odSxkLW8pLDApO3JldHVybnt4OmMseTpofX1yZXR1cm57eDpsLHk6dX19ZHJhdyh0KXtsZXQgbj1rcCh0KSxhPXJhKG4pLHtiYWNrZ3JvdW5kQ29sb3I6cixmb250Q29sb3I6cyxmb250U2l6ZTppLGZvbnRTdHlsZTpvLHBhZGRpbmc6bH09dGhpcy5vcHRpb25zO2EuZm9udD1gJHtpfXB4ICR7b31gO2xldCB1PXRoaXMubWVhc3VyZVdpZHRoKGEpLHA9dGhpcy5tZWFzdXJlSGVpZ2h0KCk7YS5maWxsU3R5bGU9cjtsZXQgZD10aGlzLmdldFVwcGVyTGVmdChhLG4pO2EuZmlsbFJlY3QoZC54LGQueSx1LHApLGEuZmlsbFN0eWxlPXMsdGhpcy50ZXh0LmZvckVhY2goKGMsaCk9PntsZXQgbT1sK2QueCxmPWwrZC55KyhoKzEpKmk7YS5maWxsVGV4dChjLG0sZil9KX19O3ZhciBYZj1jbGFzc3tjb25zdHJ1Y3Rvcih0PXt9KXtsZXR7Ym94Q29sb3I6bixsaW5lV2lkdGg6YSxsYWJlbDpyLGRyYXdMYWJlbE9wdGlvbnM6c309dDt0aGlzLmJveENvbG9yPW58fFwicmdiYSgwLCAwLCAyNTUsIDEpXCIsdGhpcy5saW5lV2lkdGg9YXx8Mix0aGlzLmxhYmVsPXI7bGV0IGk9e2FuY2hvclBvc2l0aW9uOlwiQk9UVE9NX0xFRlRcIixiYWNrZ3JvdW5kQ29sb3I6dGhpcy5ib3hDb2xvcn07dGhpcy5kcmF3TGFiZWxPcHRpb25zPW5ldyBJcCh7Li4uaSwuLi5zfSl9fSxPZD1jbGFzc3tjb25zdHJ1Y3Rvcih0LG49e30pe3RoaXMuYm94PW5ldyBtbih0KSx0aGlzLm9wdGlvbnM9bmV3IFhmKG4pfWRyYXcodCl7bGV0IG49cmEodCkse2JveENvbG9yOmEsbGluZVdpZHRoOnJ9PXRoaXMub3B0aW9ucyx7eDpzLHk6aSx3aWR0aDpvLGhlaWdodDpsfT10aGlzLmJveDtuLnN0cm9rZVN0eWxlPWEsbi5saW5lV2lkdGg9cixuLnN0cm9rZVJlY3QocyxpLG8sbCk7bGV0e2xhYmVsOnV9PXRoaXMub3B0aW9uczt1JiZuZXcgc2woW3VdLHt4OnMtci8yLHk6aX0sdGhpcy5vcHRpb25zLmRyYXdMYWJlbE9wdGlvbnMpLmRyYXcodCl9fTtmdW5jdGlvbiBVZmUoZSx0KXsoQXJyYXkuaXNBcnJheSh0KT90Olt0XSkuZm9yRWFjaChhPT57bGV0IHI9YSBpbnN0YW5jZW9mIEZ0P2Euc2NvcmU6enIoYSk/YS5kZXRlY3Rpb24uc2NvcmU6dm9pZCAwLHM9YSBpbnN0YW5jZW9mIEZ0P2EuYm94OnpyKGEpP2EuZGV0ZWN0aW9uLmJveDpuZXcgbW4oYSksaT1yP2Ake25sKHIpfWA6dm9pZCAwO25ldyBPZChzLHtsYWJlbDppfSkuZHJhdyhlKX0pfWZ1bmN0aW9uIFlmKGUpe2xldHtJbWFnZTp0LFZpZGVvOm59PWF0LmdldEVudigpO3JldHVybiBlIGluc3RhbmNlb2YgdCYmZS5jb21wbGV0ZXx8ZSBpbnN0YW5jZW9mIG4mJmUucmVhZHlTdGF0ZT49M31mdW5jdGlvbiBxJChlKXtyZXR1cm4gbmV3IFByb21pc2UoKHQsbik9PntpZihlIGluc3RhbmNlb2YgYXQuZ2V0RW52KCkuQ2FudmFzfHxZZihlKSl7dChudWxsKTtyZXR1cm59ZnVuY3Rpb24gYShzKXtzLmN1cnJlbnRUYXJnZXQmJihzLmN1cnJlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIixyKSxzLmN1cnJlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsYSksbihzKSl9ZnVuY3Rpb24gcihzKXtzLmN1cnJlbnRUYXJnZXQmJihzLmN1cnJlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIixyKSxzLmN1cnJlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsYSksdChzKSl9ZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLHIpLGUuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsYSl9KX1mdW5jdGlvbiBLJChlKXtyZXR1cm4gbmV3IFByb21pc2UoKHQsbik9PntlIGluc3RhbmNlb2YgQmxvYnx8bihuZXcgRXJyb3IoXCJidWZmZXJUb0ltYWdlIC0gZXhwZWN0ZWQgYnVmIHRvIGJlIG9mIHR5cGU6IEJsb2JcIikpO2xldCBhPW5ldyBGaWxlUmVhZGVyO2Eub25sb2FkPSgpPT57dHlwZW9mIGEucmVzdWx0IT1cInN0cmluZ1wiJiZuKG5ldyBFcnJvcihcImJ1ZmZlclRvSW1hZ2UgLSBleHBlY3RlZCByZWFkZXIucmVzdWx0IHRvIGJlIGEgc3RyaW5nLCBpbiBvbmxvYWRcIikpO2xldCByPWF0LmdldEVudigpLmNyZWF0ZUltYWdlRWxlbWVudCgpO3Iub25sb2FkPSgpPT50KHIpLHIub25lcnJvcj1uLHIuc3JjPWEucmVzdWx0fSxhLm9uZXJyb3I9bixhLnJlYWRBc0RhdGFVUkwoZSl9KX1mdW5jdGlvbiBTcChlKXtsZXR7SW1hZ2U6dCxWaWRlbzpufT1hdC5nZXRFbnYoKTtyZXR1cm4gZSBpbnN0YW5jZW9mIHQ/bmV3IGFhKGUubmF0dXJhbFdpZHRoLGUubmF0dXJhbEhlaWdodCk6ZSBpbnN0YW5jZW9mIG4/bmV3IGFhKGUudmlkZW9XaWR0aCxlLnZpZGVvSGVpZ2h0KTpuZXcgYWEoZS53aWR0aCxlLmhlaWdodCl9ZnVuY3Rpb24gTnAoe3dpZHRoOmUsaGVpZ2h0OnR9KXtsZXR7Y3JlYXRlQ2FudmFzRWxlbWVudDpufT1hdC5nZXRFbnYoKSxhPW4oKTtyZXR1cm4gYS53aWR0aD1lLGEuaGVpZ2h0PXQsYX1mdW5jdGlvbiBaZihlLHQpe2xldHtJbWFnZURhdGE6bn09YXQuZ2V0RW52KCk7aWYoIShlIGluc3RhbmNlb2YgbikmJiFZZihlKSl0aHJvdyBuZXcgRXJyb3IoXCJjcmVhdGVDYW52YXNGcm9tTWVkaWEgLSBtZWRpYSBoYXMgbm90IGZpbmlzaGVkIGxvYWRpbmcgeWV0XCIpO2xldHt3aWR0aDphLGhlaWdodDpyfT10fHxTcChlKSxzPU5wKHt3aWR0aDphLGhlaWdodDpyfSk7cmV0dXJuIGUgaW5zdGFuY2VvZiBuP3JhKHMpLnB1dEltYWdlRGF0YShlLDAsMCk6cmEocykuZHJhd0ltYWdlKGUsMCwwLGEsciksc31hc3luYyBmdW5jdGlvbiBYJChlLHQpe2xldCBuPXR8fGF0LmdldEVudigpLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSxbYSxyLHNdPWUuc2hhcGUuc2xpY2Uod2EoZSk/MTowKSxpPU8oKCk9PmUuYXMzRChhLHIscykudG9JbnQoKSk7cmV0dXJuIGF3YWl0IHFvLnRvUGl4ZWxzKGksbiksaS5kaXNwb3NlKCksbn1mdW5jdGlvbiBTayhlKXtsZXR7SW1hZ2U6dCxDYW52YXM6bixWaWRlbzphfT1hdC5nZXRFbnYoKTtyZXR1cm4gZSBpbnN0YW5jZW9mIHR8fGUgaW5zdGFuY2VvZiBufHxlIGluc3RhbmNlb2YgYX1mdW5jdGlvbiBZJChlLHQsbj0hMSl7bGV0e0ltYWdlOmEsQ2FudmFzOnJ9PWF0LmdldEVudigpO2lmKCEoZSBpbnN0YW5jZW9mIGF8fGUgaW5zdGFuY2VvZiByKSl0aHJvdyBuZXcgRXJyb3IoXCJpbWFnZVRvU3F1YXJlIC0gZXhwZWN0ZWQgYXJnMCB0byBiZSBIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnRcIik7aWYodDw9MClyZXR1cm4gTnAoe3dpZHRoOjEsaGVpZ2h0OjF9KTtsZXQgcz1TcChlKSxpPXQvTWF0aC5tYXgocy5oZWlnaHQscy53aWR0aCksbz1pKnMud2lkdGgsbD1pKnMuaGVpZ2h0LHU9TnAoe3dpZHRoOnQsaGVpZ2h0OnR9KSxwPWUgaW5zdGFuY2VvZiByP2U6WmYoZSksZD1NYXRoLmFicyhvLWwpLzIsYz1uJiZvPGw/ZDowLGg9biYmbDxvP2Q6MDtyZXR1cm4gcC53aWR0aD4wJiZwLmhlaWdodD4wJiZyYSh1KS5kcmF3SW1hZ2UocCxjLGgsbyxsKSx1fXZhciBXcj1jbGFzc3tjb25zdHJ1Y3Rvcih0LG49ITEpe3RoaXMuX2ltYWdlVGVuc29ycz1bXTt0aGlzLl9jYW52YXNlcz1bXTt0aGlzLl90cmVhdEFzQmF0Y2hJbnB1dD0hMTt0aGlzLl9pbnB1dERpbWVuc2lvbnM9W107dGhpcy5faW5wdXRTaXplPTA7aWYoIUFycmF5LmlzQXJyYXkodCkpdGhyb3cgbmV3IEVycm9yKGBOZXRJbnB1dC5jb25zdHJ1Y3RvciAtIGV4cGVjdGVkIGlucHV0cyB0byBiZSBhbiBBcnJheSBvZiBUUmVzb2x2ZWROZXRJbnB1dCBvciB0byBiZSBpbnN0YW5jZW9mIHRmLlRlbnNvcjRELCBpbnN0ZWFkIGhhdmUgJHt0fWApO3RoaXMuX3RyZWF0QXNCYXRjaElucHV0PW4sdGhpcy5fYmF0Y2hTaXplPXQubGVuZ3RoLHQuZm9yRWFjaCgoYSxyKT0+e2lmKExyKGEpKXt0aGlzLl9pbWFnZVRlbnNvcnNbcl09YSx0aGlzLl9pbnB1dERpbWVuc2lvbnNbcl09YS5zaGFwZTtyZXR1cm59aWYod2EoYSkpe2xldCBpPWEuc2hhcGVbMF07aWYoaSE9PTEpdGhyb3cgbmV3IEVycm9yKGBOZXRJbnB1dCAtIHRmLlRlbnNvcjREIHdpdGggYmF0Y2hTaXplICR7aX0gcGFzc2VkLCBidXQgbm90IHN1cHBvcnRlZCBpbiBpbnB1dCBhcnJheWApO3RoaXMuX2ltYWdlVGVuc29yc1tyXT1hLHRoaXMuX2lucHV0RGltZW5zaW9uc1tyXT1hLnNoYXBlLnNsaWNlKDEpO3JldHVybn1sZXQgcz1hIGluc3RhbmNlb2YgYXQuZ2V0RW52KCkuQ2FudmFzP2E6WmYoYSk7dGhpcy5fY2FudmFzZXNbcl09cyx0aGlzLl9pbnB1dERpbWVuc2lvbnNbcl09W3MuaGVpZ2h0LHMud2lkdGgsM119KX1nZXQgaW1hZ2VUZW5zb3JzKCl7cmV0dXJuIHRoaXMuX2ltYWdlVGVuc29yc31nZXQgY2FudmFzZXMoKXtyZXR1cm4gdGhpcy5fY2FudmFzZXN9Z2V0IGlzQmF0Y2hJbnB1dCgpe3JldHVybiB0aGlzLmJhdGNoU2l6ZT4xfHx0aGlzLl90cmVhdEFzQmF0Y2hJbnB1dH1nZXQgYmF0Y2hTaXplKCl7cmV0dXJuIHRoaXMuX2JhdGNoU2l6ZX1nZXQgaW5wdXREaW1lbnNpb25zKCl7cmV0dXJuIHRoaXMuX2lucHV0RGltZW5zaW9uc31nZXQgaW5wdXRTaXplKCl7cmV0dXJuIHRoaXMuX2lucHV0U2l6ZX1nZXQgcmVzaGFwZWRJbnB1dERpbWVuc2lvbnMoKXtyZXR1cm4gZ3IodGhpcy5iYXRjaFNpemUsMCwxKS5tYXAoKHQsbik9PnRoaXMuZ2V0UmVzaGFwZWRJbnB1dERpbWVuc2lvbnMobikpfWdldElucHV0KHQpe3JldHVybiB0aGlzLmNhbnZhc2VzW3RdfHx0aGlzLmltYWdlVGVuc29yc1t0XX1nZXRJbnB1dERpbWVuc2lvbnModCl7cmV0dXJuIHRoaXMuX2lucHV0RGltZW5zaW9uc1t0XX1nZXRJbnB1dEhlaWdodCh0KXtyZXR1cm4gdGhpcy5faW5wdXREaW1lbnNpb25zW3RdWzBdfWdldElucHV0V2lkdGgodCl7cmV0dXJuIHRoaXMuX2lucHV0RGltZW5zaW9uc1t0XVsxXX1nZXRSZXNoYXBlZElucHV0RGltZW5zaW9ucyh0KXtpZih0eXBlb2YgdGhpcy5pbnB1dFNpemUhPVwibnVtYmVyXCIpdGhyb3cgbmV3IEVycm9yKFwiZ2V0UmVzaGFwZWRJbnB1dERpbWVuc2lvbnMgLSBpbnB1dFNpemUgbm90IHNldCwgdG9CYXRjaFRlbnNvciBoYXMgbm90IGJlZW4gY2FsbGVkIHlldFwiKTtsZXQgbj10aGlzLmdldElucHV0V2lkdGgodCksYT10aGlzLmdldElucHV0SGVpZ2h0KHQpO3JldHVybiBiayh7d2lkdGg6bixoZWlnaHQ6YX0sdGhpcy5pbnB1dFNpemUpfXRvQmF0Y2hUZW5zb3IodCxuPSEwKXtyZXR1cm4gdGhpcy5faW5wdXRTaXplPXQsTygoKT0+e2xldCBhPWdyKHRoaXMuYmF0Y2hTaXplLDAsMSkubWFwKHM9PntsZXQgaT10aGlzLmdldElucHV0KHMpO2lmKGkgaW5zdGFuY2VvZiBDZSl7bGV0IG89d2EoaSk/aTpHdChpKTtyZXR1cm4gbz1HJChvLG4pLChvLnNoYXBlWzFdIT09dHx8by5zaGFwZVsyXSE9PXQpJiYobz1abi5yZXNpemVCaWxpbmVhcihvLFt0LHRdLCExLCExKSksby5hczNEKHQsdCwzKX1pZihpIGluc3RhbmNlb2YgYXQuZ2V0RW52KCkuQ2FudmFzKXJldHVybiBxby5mcm9tUGl4ZWxzKFkkKGksdCxuKSk7dGhyb3cgbmV3IEVycm9yKGB0b0JhdGNoVGVuc29yIC0gYXQgYmF0Y2hJZHggJHtzfSwgZXhwZWN0ZWQgaW5wdXQgdG8gYmUgaW5zdGFuY2VvZiB0Zi5UZW5zb3Igb3IgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCwgaW5zdGVhZCBoYXZlICR7aX1gKX0pO3JldHVybiBBdChhLm1hcChzPT5yZShzLFwiZmxvYXQzMlwiKSkpLmFzNEQodGhpcy5iYXRjaFNpemUsdCx0LDMpfSl9fTthc3luYyBmdW5jdGlvbiB2dChlKXtpZihlIGluc3RhbmNlb2YgV3IpcmV0dXJuIGU7bGV0IHQ9QXJyYXkuaXNBcnJheShlKT9lOltlXTtpZighdC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidG9OZXRJbnB1dCAtIGVtcHR5IGFycmF5IHBhc3NlZCBhcyBpbnB1dFwiKTtsZXQgbj1yPT5BcnJheS5pc0FycmF5KGUpP2AgYXQgaW5wdXQgaW5kZXggJHtyfTpgOlwiXCIsYT10Lm1hcChrcCk7cmV0dXJuIGEuZm9yRWFjaCgocixzKT0+e2lmKCFTayhyKSYmIUxyKHIpJiYhd2EocikpdGhyb3cgdHlwZW9mIHRbc109PVwic3RyaW5nXCI/bmV3IEVycm9yKGB0b05ldElucHV0IC0ke24ocyl9IHN0cmluZyBwYXNzZWQsIGJ1dCBjb3VsZCBub3QgcmVzb2x2ZSBIVE1MRWxlbWVudCBmb3IgZWxlbWVudCBpZCAke3Rbc119YCk6bmV3IEVycm9yKGB0b05ldElucHV0IC0ke24ocyl9IGV4cGVjdGVkIG1lZGlhIHRvIGJlIG9mIHR5cGUgSFRNTEltYWdlRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IHRmLlRlbnNvcjNELCBvciB0byBiZSBhbiBlbGVtZW50IGlkYCk7aWYod2Eocikpe2xldCBpPXIuc2hhcGVbMF07aWYoaSE9PTEpdGhyb3cgbmV3IEVycm9yKGB0b05ldElucHV0IC0ke24ocyl9IHRmLlRlbnNvcjREIHdpdGggYmF0Y2hTaXplICR7aX0gcGFzc2VkLCBidXQgbm90IHN1cHBvcnRlZCBpbiBpbnB1dCBhcnJheWApfX0pLGF3YWl0IFByb21pc2UuYWxsKGEubWFwKHI9PlNrKHIpJiZxJChyKSkpLG5ldyBXcihhLEFycmF5LmlzQXJyYXkoZSkpfWFzeW5jIGZ1bmN0aW9uIFBkKGUsdCl7bGV0e0NhbnZhczpufT1hdC5nZXRFbnYoKSxhPWU7aWYoIShlIGluc3RhbmNlb2Ygbikpe2xldCBpPWF3YWl0IHZ0KGUpO2lmKGkuYmF0Y2hTaXplPjEpdGhyb3cgbmV3IEVycm9yKFwiZXh0cmFjdEZhY2VzIC0gYmF0Y2hTaXplID4gMSBub3Qgc3VwcG9ydGVkXCIpO2xldCBvPWkuZ2V0SW5wdXQoMCk7YT1vIGluc3RhbmNlb2Ygbj9vOmF3YWl0IFgkKG8pfWxldCByPXJhKGEpO3JldHVybiB0Lm1hcChpPT5pIGluc3RhbmNlb2YgRnQ/aS5mb3JTaXplKGEud2lkdGgsYS5oZWlnaHQpLmJveC5mbG9vcigpOmkpLm1hcChpPT5pLmNsaXBBdEltYWdlQm9yZGVycyhhLndpZHRoLGEuaGVpZ2h0KSkubWFwKCh7eDppLHk6byx3aWR0aDpsLGhlaWdodDp1fSk9PntsZXQgcD1OcCh7d2lkdGg6bCxoZWlnaHQ6dX0pO3JldHVybiBsPjAmJnU+MCYmcmEocCkucHV0SW1hZ2VEYXRhKHIuZ2V0SW1hZ2VEYXRhKGksbyxsLHUpLDAsMCkscH0pfWFzeW5jIGZ1bmN0aW9uIExkKGUsdCl7aWYoIUxyKGUpJiYhd2EoZSkpdGhyb3cgbmV3IEVycm9yKFwiZXh0cmFjdEZhY2VUZW5zb3JzIC0gZXhwZWN0ZWQgaW1hZ2UgdGVuc29yIHRvIGJlIDNEIG9yIDREXCIpO2lmKHdhKGUpJiZlLnNoYXBlWzBdPjEpdGhyb3cgbmV3IEVycm9yKFwiZXh0cmFjdEZhY2VUZW5zb3JzIC0gYmF0Y2hTaXplID4gMSBub3Qgc3VwcG9ydGVkXCIpO3JldHVybiBPKCgpPT57bGV0W24sYSxyXT1lLnNoYXBlLnNsaWNlKHdhKGUpPzE6MCk7cmV0dXJuIHQubWFwKG89Pm8gaW5zdGFuY2VvZiBGdD9vLmZvclNpemUoYSxuKS5ib3g6bykubWFwKG89Pm8uY2xpcEF0SW1hZ2VCb3JkZXJzKGEsbikpLmZpbHRlcihvPT5vLndpZHRoPjAmJm8uaGVpZ2h0PjApLm1hcCgoe3g6byx5Omwsd2lkdGg6dSxoZWlnaHQ6cH0pPT5IbyhlLmFzM0QobixhLHIpLFtsLG8sMF0sW3AsdSxyXSkpfSl9YXN5bmMgZnVuY3Rpb24gTXMoZSx0KXtsZXR7ZmV0Y2g6bn09YXQuZ2V0RW52KCksYT1hd2FpdCBuKGUsdCk7aWYoIShhLnN0YXR1czw0MDApKXRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGZldGNoOiAoJHthLnN0YXR1c30pICR7YS5zdGF0dXNUZXh0fSwgZnJvbSB1cmw6ICR7YS51cmx9YCk7cmV0dXJuIGF9YXN5bmMgZnVuY3Rpb24gc0llKGUpe2xldCB0PWF3YWl0IE1zKGUpLG49YXdhaXQgdC5ibG9iKCk7aWYoIW4udHlwZS5zdGFydHNXaXRoKFwiaW1hZ2UvXCIpKXRocm93IG5ldyBFcnJvcihgZmV0Y2hJbWFnZSAtIGV4cGVjdGVkIGJsb2IgdHlwZSB0byBiZSBvZiB0eXBlIGltYWdlLyosIGluc3RlYWQgaGF2ZTogJHtuLnR5cGV9LCBmb3IgdXJsOiAke3QudXJsfWApO3JldHVybiBLJChuKX1hc3luYyBmdW5jdGlvbiBaJChlKXtyZXR1cm4oYXdhaXQgTXMoZSkpLmpzb24oKX1hc3luYyBmdW5jdGlvbiBwSWUoZSl7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoYXdhaXQoYXdhaXQgTXMoZSkpLmFycmF5QnVmZmVyKCkpfWZ1bmN0aW9uIEokKGUpe3JldHVybiBuZXcgUHJvbWlzZSgodCxuKT0+e2UgaW5zdGFuY2VvZiBCbG9ifHxuKG5ldyBFcnJvcihcImJ1ZmZlclRvVmlkZW8gLSBleHBlY3RlZCBidWYgdG8gYmUgb2YgdHlwZTogQmxvYlwiKSk7bGV0IGE9YXQuZ2V0RW52KCkuY3JlYXRlVmlkZW9FbGVtZW50KCk7YS5vbmNhbnBsYXk9KCk9PnQoYSksYS5vbmVycm9yPW4sYS5wbGF5c0lubGluZT0hMCxhLm11dGVkPSEwLGEuc3JjPVVSTC5jcmVhdGVPYmplY3RVUkwoZSksYS5wbGF5KCl9KX1hc3luYyBmdW5jdGlvbiBnSWUoZSl7bGV0IHQ9YXdhaXQgTXMoZSksbj1hd2FpdCB0LmJsb2IoKTtpZighbi50eXBlLnN0YXJ0c1dpdGgoXCJ2aWRlby9cIikpdGhyb3cgbmV3IEVycm9yKGBmZXRjaFZpZGVvIC0gZXhwZWN0ZWQgYmxvYiB0eXBlIHRvIGJlIG9mIHR5cGUgdmlkZW8vKiwgaW5zdGVhZCBoYXZlOiAke24udHlwZX0sIGZvciB1cmw6ICR7dC51cmx9YCk7cmV0dXJuIEokKG4pfWZ1bmN0aW9uIEpmKGUsdCl7bGV0IG49YCR7dH0td2VpZ2h0c19tYW5pZmVzdC5qc29uYDtpZighZSlyZXR1cm57bW9kZWxCYXNlVXJpOlwiXCIsbWFuaWZlc3RVcmk6bn07aWYoZT09PVwiL1wiKXJldHVybnttb2RlbEJhc2VVcmk6XCIvXCIsbWFuaWZlc3RVcmk6YC8ke259YH07bGV0IGE9ZS5zdGFydHNXaXRoKFwiaHR0cDovL1wiKT9cImh0dHA6Ly9cIjplLnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKT9cImh0dHBzOi8vXCI6XCJcIjtlPWUucmVwbGFjZShhLFwiXCIpO2xldCByPWUuc3BsaXQoXCIvXCIpLmZpbHRlcihvPT5vKSxzPWUuZW5kc1dpdGgoXCIuanNvblwiKT9yW3IubGVuZ3RoLTFdOm4saT1hKyhlLmVuZHNXaXRoKFwiLmpzb25cIik/ci5zbGljZSgwLHIubGVuZ3RoLTEpOnIpLmpvaW4oXCIvXCIpO3JldHVybiBpPWUuc3RhcnRzV2l0aChcIi9cIik/YC8ke2l9YDppLHttb2RlbEJhc2VVcmk6aSxtYW5pZmVzdFVyaTppPT09XCIvXCI/YC8ke3N9YDpgJHtpfS8ke3N9YH19YXN5bmMgZnVuY3Rpb24gUSQoZSx0KXtsZXR7bWFuaWZlc3RVcmk6bixtb2RlbEJhc2VVcmk6YX09SmYoZSx0KSxyPWF3YWl0IFokKG4pO3JldHVybiBqdC5sb2FkV2VpZ2h0cyhyLGEpfWZ1bmN0aW9uIElJZShlLHQsbj0hMSl7bGV0e3dpZHRoOmEsaGVpZ2h0OnJ9PW4/U3AodCk6dDtyZXR1cm4gZS53aWR0aD1hLGUuaGVpZ2h0PXIse3dpZHRoOmEsaGVpZ2h0OnJ9fXZhciBmbj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLl9wYXJhbXM9dm9pZCAwO3RoaXMuX3BhcmFtTWFwcGluZ3M9W107dGhpcy5fbmFtZT10fWdldCBwYXJhbXMoKXtyZXR1cm4gdGhpcy5fcGFyYW1zfWdldCBwYXJhbU1hcHBpbmdzKCl7cmV0dXJuIHRoaXMuX3BhcmFtTWFwcGluZ3N9Z2V0IGlzTG9hZGVkKCl7cmV0dXJuISF0aGlzLnBhcmFtc31nZXRQYXJhbUZyb21QYXRoKHQpe2xldHtvYmo6bixvYmpQcm9wOmF9PXRoaXMudHJhdmVyc2VQcm9wZXJ0eVBhdGgodCk7cmV0dXJuIG5bYV19cmVhc3NpZ25QYXJhbUZyb21QYXRoKHQsbil7bGV0e29iajphLG9ialByb3A6cn09dGhpcy50cmF2ZXJzZVByb3BlcnR5UGF0aCh0KTthW3JdLmRpc3Bvc2UoKSxhW3JdPW59Z2V0UGFyYW1MaXN0KCl7cmV0dXJuIHRoaXMuX3BhcmFtTWFwcGluZ3MubWFwKCh7cGFyYW1QYXRoOnR9KT0+KHtwYXRoOnQsdGVuc29yOnRoaXMuZ2V0UGFyYW1Gcm9tUGF0aCh0KX0pKX1nZXRUcmFpbmFibGVQYXJhbXMoKXtyZXR1cm4gdGhpcy5nZXRQYXJhbUxpc3QoKS5maWx0ZXIodD0+dC50ZW5zb3IgaW5zdGFuY2VvZiBvcyl9Z2V0RnJvemVuUGFyYW1zKCl7cmV0dXJuIHRoaXMuZ2V0UGFyYW1MaXN0KCkuZmlsdGVyKHQ9PiEodC50ZW5zb3IgaW5zdGFuY2VvZiBvcykpfXZhcmlhYmxlKCl7dGhpcy5nZXRGcm96ZW5QYXJhbXMoKS5mb3JFYWNoKCh7cGF0aDp0LHRlbnNvcjpufSk9Pnt0aGlzLnJlYXNzaWduUGFyYW1Gcm9tUGF0aCh0LG4udmFyaWFibGUoKSl9KX1mcmVlemUoKXt0aGlzLmdldFRyYWluYWJsZVBhcmFtcygpLmZvckVhY2goKHtwYXRoOnQsdGVuc29yOm59KT0+e2xldCBhPWJuKG4uZGF0YVN5bmMoKSk7bi5kaXNwb3NlKCksdGhpcy5yZWFzc2lnblBhcmFtRnJvbVBhdGgodCxhKX0pfWRpc3Bvc2UodD0hMCl7dGhpcy5nZXRQYXJhbUxpc3QoKS5mb3JFYWNoKG49PntpZih0JiZuLnRlbnNvci5pc0Rpc3Bvc2VkKXRocm93IG5ldyBFcnJvcihgcGFyYW0gdGVuc29yIGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQgZm9yIHBhdGggJHtuLnBhdGh9YCk7bi50ZW5zb3IuZGlzcG9zZSgpfSksdGhpcy5fcGFyYW1zPXZvaWQgMH1zZXJpYWxpemVQYXJhbXMoKXtyZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmdldFBhcmFtTGlzdCgpLm1hcCgoe3RlbnNvcjp0fSk9PkFycmF5LmZyb20odC5kYXRhU3luYygpKSkucmVkdWNlKCh0LG4pPT50LmNvbmNhdChuKSkpfWFzeW5jIGxvYWQodCl7aWYodCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSl7dGhpcy5leHRyYWN0V2VpZ2h0cyh0KTtyZXR1cm59YXdhaXQgdGhpcy5sb2FkRnJvbVVyaSh0KX1hc3luYyBsb2FkRnJvbVVyaSh0KXtpZih0JiZ0eXBlb2YgdCE9XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5fbmFtZX0ubG9hZEZyb21VcmkgLSBleHBlY3RlZCBtb2RlbCB1cmlgKTtsZXQgbj1hd2FpdCBRJCh0LHRoaXMuZ2V0RGVmYXVsdE1vZGVsTmFtZSgpKTt0aGlzLmxvYWRGcm9tV2VpZ2h0TWFwKG4pfWFzeW5jIGxvYWRGcm9tRGlzayh0KXtpZih0JiZ0eXBlb2YgdCE9XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5fbmFtZX0ubG9hZEZyb21EaXNrIC0gZXhwZWN0ZWQgbW9kZWwgZmlsZSBwYXRoYCk7bGV0e3JlYWRGaWxlOm59PWF0LmdldEVudigpLHttYW5pZmVzdFVyaTphLG1vZGVsQmFzZVVyaTpyfT1KZih0LHRoaXMuZ2V0RGVmYXVsdE1vZGVsTmFtZSgpKSxzPXU9PlByb21pc2UuYWxsKHUubWFwKHA9Pm4ocCkudGhlbihkPT50eXBlb2YgZD09XCJzdHJpbmdcIj9CdWZmZXIuZnJvbShkKTpkLmJ1ZmZlcikpKSxpPWp0LndlaWdodHNMb2FkZXJGYWN0b3J5KHMpLG89SlNPTi5wYXJzZSgoYXdhaXQgbihhKSkudG9TdHJpbmcoKSksbD1hd2FpdCBpKG8scik7dGhpcy5sb2FkRnJvbVdlaWdodE1hcChsKX1sb2FkRnJvbVdlaWdodE1hcCh0KXtsZXR7cGFyYW1NYXBwaW5nczpuLHBhcmFtczphfT10aGlzLmV4dHJhY3RQYXJhbXNGcm9tV2VpZ2h0TWFwKHQpO3RoaXMuX3BhcmFtTWFwcGluZ3M9bix0aGlzLl9wYXJhbXM9YX1leHRyYWN0V2VpZ2h0cyh0KXtsZXR7cGFyYW1NYXBwaW5nczpuLHBhcmFtczphfT10aGlzLmV4dHJhY3RQYXJhbXModCk7dGhpcy5fcGFyYW1NYXBwaW5ncz1uLHRoaXMuX3BhcmFtcz1hfXRyYXZlcnNlUHJvcGVydHlQYXRoKHQpe2lmKCF0aGlzLnBhcmFtcyl0aHJvdyBuZXcgRXJyb3IoXCJ0cmF2ZXJzZVByb3BlcnR5UGF0aCAtIG1vZGVsIGhhcyBubyBsb2FkZWQgcGFyYW1zXCIpO2xldCBuPXQuc3BsaXQoXCIvXCIpLnJlZHVjZSgocyxpKT0+e2lmKCFzLm5leHRPYmouaGFzT3duUHJvcGVydHkoaSkpdGhyb3cgbmV3IEVycm9yKGB0cmF2ZXJzZVByb3BlcnR5UGF0aCAtIG9iamVjdCBkb2VzIG5vdCBoYXZlIHByb3BlcnR5ICR7aX0sIGZvciBwYXRoICR7dH1gKTtyZXR1cm57b2JqOnMubmV4dE9iaixvYmpQcm9wOmksbmV4dE9iajpzLm5leHRPYmpbaV19fSx7bmV4dE9iajp0aGlzLnBhcmFtc30pLHtvYmo6YSxvYmpQcm9wOnJ9PW47aWYoIWF8fCFyfHwhKGFbcl1pbnN0YW5jZW9mIENlKSl0aHJvdyBuZXcgRXJyb3IoYHRyYXZlcnNlUHJvcGVydHlQYXRoIC0gcGFyYW1ldGVyIGlzIG5vdCBhIHRlbnNvciwgZm9yIHBhdGggJHt0fWApO3JldHVybntvYmo6YSxvYmpQcm9wOnJ9fX07ZnVuY3Rpb24gVW4oZSx0LG4pe3JldHVybiBPKCgpPT57bGV0IGE9X3MoZSx0LmRlcHRod2lzZV9maWx0ZXIsdC5wb2ludHdpc2VfZmlsdGVyLG4sXCJzYW1lXCIpO3JldHVybiBhPVgoYSx0LmJpYXMpLGF9KX1mdW5jdGlvbiBRZihlLHQsbj0hMSl7cmV0dXJuIE8oKCk9PntsZXQgYT1LZShuP1goJHQoZSx0LmNvbnYwLmZpbHRlcnMsWzIsMl0sXCJzYW1lXCIpLHQuY29udjAuYmlhcyk6VW4oZSx0LmNvbnYwLFsyLDJdKSkscj1VbihhLHQuY29udjEsWzEsMV0pLHM9S2UoWChhLHIpKSxpPVVuKHMsdC5jb252MixbMSwxXSk7cmV0dXJuIEtlKFgoYSxYKHIsaSkpKX0pfWZ1bmN0aW9uIHpkKGUsdCxuPSExLGE9ITApe3JldHVybiBPKCgpPT57bGV0IHI9S2Uobj9YKCR0KGUsdC5jb252MC5maWx0ZXJzLGE/WzIsMl06WzEsMV0sXCJzYW1lXCIpLHQuY29udjAuYmlhcyk6VW4oZSx0LmNvbnYwLGE/WzIsMl06WzEsMV0pKSxzPVVuKHIsdC5jb252MSxbMSwxXSksaT1LZShYKHIscykpLG89VW4oaSx0LmNvbnYyLFsxLDFdKSxsPUtlKFgocixYKHMsbykpKSx1PVVuKGwsdC5jb252MyxbMSwxXSk7cmV0dXJuIEtlKFgocixYKHMsWChvLHUpKSkpfSl9ZnVuY3Rpb24gaWwoZSx0LG49XCJzYW1lXCIsYT0hMSl7cmV0dXJuIE8oKCk9PntsZXQgcj1YKCR0KGUsdC5maWx0ZXJzLFsxLDFdLG4pLHQuYmlhcyk7cmV0dXJuIGE/S2Uocik6cn0pfWZ1bmN0aW9uIF9uKGUsdCl7T2JqZWN0LmtleXMoZSkuZm9yRWFjaChuPT57dC5zb21lKGE9PmEub3JpZ2luYWxQYXRoPT09bil8fGVbbl0uZGlzcG9zZSgpfSl9ZnVuY3Rpb24gVHAoZSx0KXtyZXR1cm4obixhLHIscyk9PntsZXQgaT1GYShlKG4qYSpyKnIpLFtyLHIsbixhXSksbz1qZShlKGEpKTtyZXR1cm4gdC5wdXNoKHtwYXJhbVBhdGg6YCR7c30vZmlsdGVyc2B9LHtwYXJhbVBhdGg6YCR7c30vYmlhc2B9KSx7ZmlsdGVyczppLGJpYXM6b319fWZ1bmN0aW9uIGVnKGUsdCl7cmV0dXJuKG4sYSxyKT0+e2xldCBzPUVhKGUobiphKSxbbixhXSksaT1qZShlKGEpKTtyZXR1cm4gdC5wdXNoKHtwYXJhbVBhdGg6YCR7cn0vd2VpZ2h0c2B9LHtwYXJhbVBhdGg6YCR7cn0vYmlhc2B9KSx7d2VpZ2h0czpzLGJpYXM6aX19fXZhciBXZD1jbGFzc3tjb25zdHJ1Y3Rvcih0LG4sYSl7dGhpcy5kZXB0aHdpc2VfZmlsdGVyPXQ7dGhpcy5wb2ludHdpc2VfZmlsdGVyPW47dGhpcy5iaWFzPWF9fTtmdW5jdGlvbiBDcChlLHQpe3JldHVybihuLGEscik9PntsZXQgcz1GYShlKDkqbiksWzMsMyxuLDFdKSxpPUZhKGUobiphKSxbMSwxLG4sYV0pLG89amUoZShhKSk7cmV0dXJuIHQucHVzaCh7cGFyYW1QYXRoOmAke3J9L2RlcHRod2lzZV9maWx0ZXJgfSx7cGFyYW1QYXRoOmAke3J9L3BvaW50d2lzZV9maWx0ZXJgfSx7cGFyYW1QYXRoOmAke3J9L2JpYXNgfSksbmV3IFdkKHMsaSxvKX19ZnVuY3Rpb24gRXAoZSl7cmV0dXJuIHQ9PntsZXQgbj1lKGAke3R9L2RlcHRod2lzZV9maWx0ZXJgLDQpLGE9ZShgJHt0fS9wb2ludHdpc2VfZmlsdGVyYCw0KSxyPWUoYCR7dH0vYmlhc2AsMSk7cmV0dXJuIG5ldyBXZChuLGEscil9fWZ1bmN0aW9uIHNhKGUsdCl7cmV0dXJuKG4sYSxyKT0+e2xldCBzPWVbbl07aWYoIXRsKHMsYSkpdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCB3ZWlnaHRNYXBbJHtufV0gdG8gYmUgYSBUZW5zb3Ike2F9RCwgaW5zdGVhZCBoYXZlICR7c31gKTtyZXR1cm4gdC5wdXNoKHtvcmlnaW5hbFBhdGg6bixwYXJhbVBhdGg6cnx8bn0pLHN9fWZ1bmN0aW9uIEFuKGUpe2xldCB0PWU7ZnVuY3Rpb24gbihyKXtsZXQgcz10LnNsaWNlKDAscik7cmV0dXJuIHQ9dC5zbGljZShyKSxzfWZ1bmN0aW9uIGEoKXtyZXR1cm4gdH1yZXR1cm57ZXh0cmFjdFdlaWdodHM6bixnZXRSZW1haW5pbmdXZWlnaHRzOmF9fWZ1bmN0aW9uIHRnKGUsdCl7bGV0IG49VHAoZSx0KSxhPUNwKGUsdCk7ZnVuY3Rpb24gcihpLG8sbCx1PSExKXtsZXQgcD11P24oaSxvLDMsYCR7bH0vY29udjBgKTphKGksbyxgJHtsfS9jb252MGApLGQ9YShvLG8sYCR7bH0vY29udjFgKSxjPWEobyxvLGAke2x9L2NvbnYyYCk7cmV0dXJue2NvbnYwOnAsY29udjE6ZCxjb252MjpjfX1mdW5jdGlvbiBzKGksbyxsLHU9ITEpe2xldHtjb252MDpwLGNvbnYxOmQsY29udjI6Y309cihpLG8sbCx1KSxoPWEobyxvLGAke2x9L2NvbnYzYCk7cmV0dXJue2NvbnYwOnAsY29udjE6ZCxjb252MjpjLGNvbnYzOmh9fXJldHVybntleHRyYWN0RGVuc2VCbG9jazNQYXJhbXM6cixleHRyYWN0RGVuc2VCbG9jazRQYXJhbXM6c319ZnVuY3Rpb24gZUQoZSl7bGV0IHQ9W10se2V4dHJhY3RXZWlnaHRzOm4sZ2V0UmVtYWluaW5nV2VpZ2h0czphfT1BbihlKSx7ZXh0cmFjdERlbnNlQmxvY2s0UGFyYW1zOnJ9PXRnKG4sdCkscz1yKDMsMzIsXCJkZW5zZTBcIiwhMCksaT1yKDMyLDY0LFwiZGVuc2UxXCIpLG89cig2NCwxMjgsXCJkZW5zZTJcIiksbD1yKDEyOCwyNTYsXCJkZW5zZTNcIik7aWYoYSgpLmxlbmd0aCE9PTApdGhyb3cgbmV3IEVycm9yKGB3ZWlnaHRzIHJlbWFpbmcgYWZ0ZXIgZXh0cmFjdDogJHthKCkubGVuZ3RofWApO3JldHVybntwYXJhbU1hcHBpbmdzOnQscGFyYW1zOntkZW5zZTA6cyxkZW5zZTE6aSxkZW5zZTI6byxkZW5zZTM6bH19fWZ1bmN0aW9uIG5nKGUpe3JldHVybiB0PT57bGV0IG49ZShgJHt0fS9maWx0ZXJzYCw0KSxhPWUoYCR7dH0vYmlhc2AsMSk7cmV0dXJue2ZpbHRlcnM6bixiaWFzOmF9fX1mdW5jdGlvbiBhZyhlLHQpe2xldCBuPXNhKGUsdCksYT1uZyhuKSxyPUVwKG4pO2Z1bmN0aW9uIHMobyxsPSExKXtsZXQgdT1sP2EoYCR7b30vY29udjBgKTpyKGAke299L2NvbnYwYCkscD1yKGAke299L2NvbnYxYCksZD1yKGAke299L2NvbnYyYCk7cmV0dXJue2NvbnYwOnUsY29udjE6cCxjb252MjpkfX1mdW5jdGlvbiBpKG8sbD0hMSl7bGV0IHU9bD9hKGAke299L2NvbnYwYCk6cihgJHtvfS9jb252MGApLHA9cihgJHtvfS9jb252MWApLGQ9cihgJHtvfS9jb252MmApLGM9cihgJHtvfS9jb252M2ApO3JldHVybntjb252MDp1LGNvbnYxOnAsY29udjI6ZCxjb252MzpjfX1yZXR1cm57ZXh0cmFjdERlbnNlQmxvY2szUGFyYW1zOnMsZXh0cmFjdERlbnNlQmxvY2s0UGFyYW1zOml9fWZ1bmN0aW9uIHREKGUpe2xldCB0PVtdLHtleHRyYWN0RGVuc2VCbG9jazRQYXJhbXM6bn09YWcoZSx0KSxhPXtkZW5zZTA6bihcImRlbnNlMFwiLCEwKSxkZW5zZTE6bihcImRlbnNlMVwiKSxkZW5zZTI6bihcImRlbnNlMlwiKSxkZW5zZTM6bihcImRlbnNlM1wiKX07cmV0dXJuIF9uKGUsdCkse3BhcmFtczphLHBhcmFtTWFwcGluZ3M6dH19dmFyIF9wPWNsYXNzIGV4dGVuZHMgZm57Y29uc3RydWN0b3IoKXtzdXBlcihcIkZhY2VGZWF0dXJlRXh0cmFjdG9yXCIpfWZvcndhcmRJbnB1dCh0KXtsZXR7cGFyYW1zOm59PXRoaXM7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiRmFjZUZlYXR1cmVFeHRyYWN0b3IgLSBsb2FkIG1vZGVsIGJlZm9yZSBpbmZlcmVuY2VcIik7cmV0dXJuIE8oKCk9PntsZXQgYT1yZSh0LnRvQmF0Y2hUZW5zb3IoMTEyLCEwKSxcImZsb2F0MzJcIikscz1icihhLFsxMjIuNzgyLDExNy4wMDEsMTA0LjI5OF0pLmRpdigyNTUpLGk9emQocyxuLmRlbnNlMCwhMCk7cmV0dXJuIGk9emQoaSxuLmRlbnNlMSksaT16ZChpLG4uZGVuc2UyKSxpPXpkKGksbi5kZW5zZTMpLGk9eWEoaSxbNyw3XSxbMiwyXSxcInZhbGlkXCIpLGl9KX1hc3luYyBmb3J3YXJkKHQpe3JldHVybiB0aGlzLmZvcndhcmRJbnB1dChhd2FpdCB2dCh0KSl9Z2V0RGVmYXVsdE1vZGVsTmFtZSgpe3JldHVyblwiZmFjZV9mZWF0dXJlX2V4dHJhY3Rvcl9tb2RlbFwifWV4dHJhY3RQYXJhbXNGcm9tV2VpZ2h0TWFwKHQpe3JldHVybiB0RCh0KX1leHRyYWN0UGFyYW1zKHQpe3JldHVybiBlRCh0KX19O2Z1bmN0aW9uIEJkKGUsdCl7cmV0dXJuIE8oKCk9PlgoJGUoZSx0LndlaWdodHMpLHQuYmlhcykpfWZ1bmN0aW9uIG5EKGUsdCxuKXtsZXQgYT1bXSx7ZXh0cmFjdFdlaWdodHM6cixnZXRSZW1haW5pbmdXZWlnaHRzOnN9PUFuKGUpLG89ZWcocixhKSh0LG4sXCJmY1wiKTtpZihzKCkubGVuZ3RoIT09MCl0aHJvdyBuZXcgRXJyb3IoYHdlaWdodHMgcmVtYWluZyBhZnRlciBleHRyYWN0OiAke3MoKS5sZW5ndGh9YCk7cmV0dXJue3BhcmFtTWFwcGluZ3M6YSxwYXJhbXM6e2ZjOm99fX1mdW5jdGlvbiBhRChlKXtsZXQgdD1bXSxuPXNhKGUsdCk7ZnVuY3Rpb24gYShzKXtsZXQgaT1uKGAke3N9L3dlaWdodHNgLDIpLG89bihgJHtzfS9iaWFzYCwxKTtyZXR1cm57d2VpZ2h0czppLGJpYXM6b319bGV0IHI9e2ZjOmEoXCJmY1wiKX07cmV0dXJuIF9uKGUsdCkse3BhcmFtczpyLHBhcmFtTWFwcGluZ3M6dH19ZnVuY3Rpb24gcmcoZSl7bGV0IHQ9e30sbj17fTtyZXR1cm4gT2JqZWN0LmtleXMoZSkuZm9yRWFjaChhPT57bGV0IHI9YS5zdGFydHNXaXRoKFwiZmNcIik/bjp0O3JbYV09ZVthXX0pLHtmZWF0dXJlRXh0cmFjdG9yTWFwOnQsY2xhc3NpZmllck1hcDpufX12YXIgQXA9Y2xhc3MgZXh0ZW5kcyBmbntjb25zdHJ1Y3Rvcih0LG4pe3N1cGVyKHQpLHRoaXMuX2ZhY2VGZWF0dXJlRXh0cmFjdG9yPW59Z2V0IGZhY2VGZWF0dXJlRXh0cmFjdG9yKCl7cmV0dXJuIHRoaXMuX2ZhY2VGZWF0dXJlRXh0cmFjdG9yfXJ1bk5ldCh0KXtsZXR7cGFyYW1zOm59PXRoaXM7aWYoIW4pdGhyb3cgbmV3IEVycm9yKGAke3RoaXMuX25hbWV9IC0gbG9hZCBtb2RlbCBiZWZvcmUgaW5mZXJlbmNlYCk7cmV0dXJuIE8oKCk9PntsZXQgYT10IGluc3RhbmNlb2YgV3I/dGhpcy5mYWNlRmVhdHVyZUV4dHJhY3Rvci5mb3J3YXJkSW5wdXQodCk6dDtyZXR1cm4gQmQoYS5hczJEKGEuc2hhcGVbMF0sLTEpLG4uZmMpfSl9ZGlzcG9zZSh0PSEwKXt0aGlzLmZhY2VGZWF0dXJlRXh0cmFjdG9yLmRpc3Bvc2UodCksc3VwZXIuZGlzcG9zZSh0KX1sb2FkQ2xhc3NpZmllclBhcmFtcyh0KXtsZXR7cGFyYW1zOm4scGFyYW1NYXBwaW5nczphfT10aGlzLmV4dHJhY3RDbGFzc2lmaWVyUGFyYW1zKHQpO3RoaXMuX3BhcmFtcz1uLHRoaXMuX3BhcmFtTWFwcGluZ3M9YX1leHRyYWN0Q2xhc3NpZmllclBhcmFtcyh0KXtyZXR1cm4gbkQodCx0aGlzLmdldENsYXNzaWZpZXJDaGFubmVsc0luKCksdGhpcy5nZXRDbGFzc2lmaWVyQ2hhbm5lbHNPdXQoKSl9ZXh0cmFjdFBhcmFtc0Zyb21XZWlnaHRNYXAodCl7bGV0e2ZlYXR1cmVFeHRyYWN0b3JNYXA6bixjbGFzc2lmaWVyTWFwOmF9PXJnKHQpO3JldHVybiB0aGlzLmZhY2VGZWF0dXJlRXh0cmFjdG9yLmxvYWRGcm9tV2VpZ2h0TWFwKG4pLGFEKGEpfWV4dHJhY3RQYXJhbXModCl7bGV0IG49dGhpcy5nZXRDbGFzc2lmaWVyQ2hhbm5lbHNJbigpLGE9dGhpcy5nZXRDbGFzc2lmaWVyQ2hhbm5lbHNPdXQoKSxyPWEqbithLHM9dC5zbGljZSgwLHQubGVuZ3RoLXIpLGk9dC5zbGljZSh0Lmxlbmd0aC1yKTtyZXR1cm4gdGhpcy5mYWNlRmVhdHVyZUV4dHJhY3Rvci5leHRyYWN0V2VpZ2h0cyhzKSx0aGlzLmV4dHJhY3RDbGFzc2lmaWVyUGFyYW1zKGkpfX07dmFyIHJEPVtcIm5ldXRyYWxcIixcImhhcHB5XCIsXCJzYWRcIixcImFuZ3J5XCIsXCJmZWFyZnVsXCIsXCJkaXNndXN0ZWRcIixcInN1cnByaXNlZFwiXSxPcz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLm5ldXRyYWw9MDt0aGlzLmhhcHB5PTA7dGhpcy5zYWQ9MDt0aGlzLmFuZ3J5PTA7dGhpcy5mZWFyZnVsPTA7dGhpcy5kaXNndXN0ZWQ9MDt0aGlzLnN1cnByaXNlZD0wO2lmKHQubGVuZ3RoIT09Nyl0aHJvdyBuZXcgRXJyb3IoYEZhY2VFeHByZXNzaW9ucy5jb25zdHJ1Y3RvciAtIGV4cGVjdGVkIHByb2JhYmlsaXRpZXMubGVuZ3RoIHRvIGJlIDcsIGhhdmU6ICR7dC5sZW5ndGh9YCk7ckQuZm9yRWFjaCgobixhKT0+e3RoaXNbbl09dFthXX0pfWFzU29ydGVkQXJyYXkoKXtyZXR1cm4gckQubWFwKHQ9Pih7ZXhwcmVzc2lvbjp0LHByb2JhYmlsaXR5OnRoaXNbdF19KSkuc29ydCgodCxuKT0+bi5wcm9iYWJpbGl0eS10LnByb2JhYmlsaXR5KX19O3ZhciBzZz1jbGFzcyBleHRlbmRzIEFwe2NvbnN0cnVjdG9yKHQ9bmV3IF9wKXtzdXBlcihcIkZhY2VFeHByZXNzaW9uTmV0XCIsdCl9Zm9yd2FyZElucHV0KHQpe3JldHVybiBPKCgpPT5xYSh0aGlzLnJ1bk5ldCh0KSkpfWFzeW5jIGZvcndhcmQodCl7cmV0dXJuIHRoaXMuZm9yd2FyZElucHV0KGF3YWl0IHZ0KHQpKX1hc3luYyBwcmVkaWN0RXhwcmVzc2lvbnModCl7bGV0IG49YXdhaXQgdnQodCksYT1hd2FpdCB0aGlzLmZvcndhcmRJbnB1dChuKSxyPWF3YWl0IFByb21pc2UuYWxsKGR0KGEpLm1hcChhc3luYyBpPT57bGV0IG89aS5kYXRhU3luYygpO3JldHVybiBpLmRpc3Bvc2UoKSxvfSkpO2EuZGlzcG9zZSgpO2xldCBzPXIubWFwKGk9Pm5ldyBPcyhpKSk7cmV0dXJuIG4uaXNCYXRjaElucHV0P3M6c1swXX1nZXREZWZhdWx0TW9kZWxOYW1lKCl7cmV0dXJuXCJmYWNlX2V4cHJlc3Npb25fbW9kZWxcIn1nZXRDbGFzc2lmaWVyQ2hhbm5lbHNJbigpe3JldHVybiAyNTZ9Z2V0Q2xhc3NpZmllckNoYW5uZWxzT3V0KCl7cmV0dXJuIDd9fTtmdW5jdGlvbiBzRChlKXtyZXR1cm4gZS5leHByZXNzaW9ucyBpbnN0YW5jZW9mIE9zfWZ1bmN0aW9uIE5rKGUsdCl7cmV0dXJuey4uLmUsLi4ue2V4cHJlc3Npb25zOnR9fX1mdW5jdGlvbiBHZmUoZSx0LG49LjEsYSl7KEFycmF5LmlzQXJyYXkodCk/dDpbdF0pLmZvckVhY2gocz0+e2xldCBpPXMgaW5zdGFuY2VvZiBPcz9zOnNEKHMpP3MuZXhwcmVzc2lvbnM6dm9pZCAwO2lmKCFpKXRocm93IG5ldyBFcnJvcihcImRyYXdGYWNlRXhwcmVzc2lvbnMgLSBleHBlY3RlZCBmYWNlRXhwcmVzc2lvbnMgdG8gYmUgRmFjZUV4cHJlc3Npb25zIHwgV2l0aEZhY2VFeHByZXNzaW9uczx7fT4gb3IgYXJyYXkgdGhlcmVvZlwiKTtsZXQgbD1pLmFzU29ydGVkQXJyYXkoKS5maWx0ZXIoZD0+ZC5wcm9iYWJpbGl0eT5uKSx1PXpyKHMpP3MuZGV0ZWN0aW9uLmJveC5ib3R0b21MZWZ0OmF8fG5ldyBIZSgwLDApO25ldyBzbChsLm1hcChkPT5gJHtkLmV4cHJlc3Npb259ICgke25sKGQucHJvYmFiaWxpdHkpfSlgKSx1KS5kcmF3KGUpfSl9ZnVuY3Rpb24gRnAoZSl7cmV0dXJuIHpyKGUpJiZlLmxhbmRtYXJrcyBpbnN0YW5jZW9mIGthJiZlLnVuc2hpZnRlZExhbmRtYXJrcyBpbnN0YW5jZW9mIGthJiZlLmFsaWduZWRSZWN0IGluc3RhbmNlb2YgRnR9ZnVuY3Rpb24gSGZlKGUpe2xldCB0PWw9PmwqMTgwL01hdGguUEksbj0obCx1KT0+TWF0aC5zcXJ0KChsLngtdS54KSoqMisobC55LXUueSkqKjIpLGE9e3JvbGw6dm9pZCAwLHBpdGNoOnZvaWQgMCx5YXc6dm9pZCAwfSxyPShsLHUscCk9PntsZXQgZD1NYXRoLmZsb29yKGwueC11LngpLGM9TWF0aC5mbG9vcih1LngtcC54KTtyZXR1cm4gZC1jfSxzPShsLHUpPT57bGV0IHA9TWF0aC5oeXBvdCh1LngtbC54LHUueS1sLnkpLGQ9dS55LWwueSxjPU1hdGguYXNpbihkL3ApLGg9dChjKSxtPU1hdGguZmxvb3IoOTAtaCksZj11LngtbC54PDA/LTE6MTtyZXR1cm4gbSpmfSxpPShsLHUscCk9PntsZXQgZD1uKGwscCksYz1uZXcgSGUoKGwueCtwLngpLzIsKGwueStwLnkpLzIpLGg9bih1LGMpLG09TWF0aC5hdGFuKGgvZCksZj1NYXRoLmZsb29yKHQobSkpLGc9Yy55LXUueTwwPy0xOjE7cmV0dXJuIGYqZ307aWYoIWV8fCFlLnBvc2l0aW9uc3x8ZS5wb3NpdGlvbnMubGVuZ3RoIT09NjgpcmV0dXJuIGE7bGV0IG89ZS5wb3NpdGlvbnM7cmV0dXJuIGEucm9sbD1zKG9bMjddLG9bNjZdKSxhLnBpdGNoPWkob1sxNF0sb1szMF0sb1syXSksYS55YXc9cihvWzE0XSxvWzMzXSxvWzJdKSxhfWZ1bmN0aW9uIFZkKGUsdCl7bGV0e2JveDpufT1lLmRldGVjdGlvbixhPXQuc2hpZnRCeShuLngsbi55KSxyPWEuYWxpZ24oKSx7aW1hZ2VEaW1zOnN9PWUuZGV0ZWN0aW9uLGk9bmV3IEZ0KGUuZGV0ZWN0aW9uLnNjb3JlLHIucmVzY2FsZShzLnJldmVyc2UoKSkscyksbz1IZmUodCk7cmV0dXJuey4uLmUsLi4ue2xhbmRtYXJrczphLHVuc2hpZnRlZExhbmRtYXJrczp0LGFsaWduZWRSZWN0OmksYW5nbGU6b319fXZhciBpZz1jbGFzc3tjb25zdHJ1Y3Rvcih0PXt9KXtsZXR7ZHJhd0xpbmVzOm49ITAsZHJhd1BvaW50czphPSEwLGxpbmVXaWR0aDpyLGxpbmVDb2xvcjpzLHBvaW50U2l6ZTppLHBvaW50Q29sb3I6b309dDt0aGlzLmRyYXdMaW5lcz1uLHRoaXMuZHJhd1BvaW50cz1hLHRoaXMubGluZVdpZHRoPXJ8fDEsdGhpcy5wb2ludFNpemU9aXx8Mix0aGlzLmxpbmVDb2xvcj1zfHxcInJnYmEoMCwgMjU1LCAyNTUsIDEpXCIsdGhpcy5wb2ludENvbG9yPW98fFwicmdiYSgyNTUsIDAsIDI1NSwgMSlcIn19LG9nPWNsYXNze2NvbnN0cnVjdG9yKHQsbj17fSl7dGhpcy5mYWNlTGFuZG1hcmtzPXQsdGhpcy5vcHRpb25zPW5ldyBpZyhuKX1kcmF3KHQpe2xldCBuPXJhKHQpLHtkcmF3TGluZXM6YSxkcmF3UG9pbnRzOnIsbGluZVdpZHRoOnMsbGluZUNvbG9yOmkscG9pbnRTaXplOm8scG9pbnRDb2xvcjpsfT10aGlzLm9wdGlvbnM7aWYoYSYmdGhpcy5mYWNlTGFuZG1hcmtzIGluc3RhbmNlb2YgdnAmJihuLnN0cm9rZVN0eWxlPWksbi5saW5lV2lkdGg9cyxQcihuLHRoaXMuZmFjZUxhbmRtYXJrcy5nZXRKYXdPdXRsaW5lKCkpLFByKG4sdGhpcy5mYWNlTGFuZG1hcmtzLmdldExlZnRFeWVCcm93KCkpLFByKG4sdGhpcy5mYWNlTGFuZG1hcmtzLmdldFJpZ2h0RXllQnJvdygpKSxQcihuLHRoaXMuZmFjZUxhbmRtYXJrcy5nZXROb3NlKCkpLFByKG4sdGhpcy5mYWNlTGFuZG1hcmtzLmdldExlZnRFeWUoKSwhMCksUHIobix0aGlzLmZhY2VMYW5kbWFya3MuZ2V0UmlnaHRFeWUoKSwhMCksUHIobix0aGlzLmZhY2VMYW5kbWFya3MuZ2V0TW91dGgoKSwhMCkpLHIpe24uc3Ryb2tlU3R5bGU9bCxuLmZpbGxTdHlsZT1sO2xldCB1PXA9PntuLmJlZ2luUGF0aCgpLG4uYXJjKHAueCxwLnksbywwLDIqTWF0aC5QSSksbi5maWxsKCl9O3RoaXMuZmFjZUxhbmRtYXJrcy5wb3NpdGlvbnMuZm9yRWFjaCh1KX19fTtmdW5jdGlvbiBqZmUoZSx0KXsoQXJyYXkuaXNBcnJheSh0KT90Olt0XSkuZm9yRWFjaChhPT57bGV0IHI9YSBpbnN0YW5jZW9mIGthP2E6RnAoYSk/YS5sYW5kbWFya3M6dm9pZCAwO2lmKCFyKXRocm93IG5ldyBFcnJvcihcImRyYXdGYWNlTGFuZG1hcmtzIC0gZXhwZWN0ZWQgZmFjZUV4cHJlc3Npb25zIHRvIGJlIEZhY2VMYW5kbWFya3MgfCBXaXRoRmFjZUxhbmRtYXJrczxXaXRoRmFjZURldGVjdGlvbjx7fT4+IG9yIGFycmF5IHRoZXJlb2ZcIik7bmV3IG9nKHIpLmRyYXcoZSl9KX12YXIgb0Q9XCIxLjcuMTVcIjtmdW5jdGlvbiBYZmUoZSx0KXtsZXQgbj1UcChlLHQpLGE9Q3AoZSx0KTtmdW5jdGlvbiByKGksbyxsKXtsZXQgdT1hKGksbyxgJHtsfS9zZXBhcmFibGVfY29udjBgKSxwPWEobyxvLGAke2x9L3NlcGFyYWJsZV9jb252MWApLGQ9bihpLG8sMSxgJHtsfS9leHBhbnNpb25fY29udmApO3JldHVybntzZXBhcmFibGVfY29udjA6dSxzZXBhcmFibGVfY29udjE6cCxleHBhbnNpb25fY29udjpkfX1mdW5jdGlvbiBzKGksbyl7bGV0IGw9YShpLGksYCR7b30vc2VwYXJhYmxlX2NvbnYwYCksdT1hKGksaSxgJHtvfS9zZXBhcmFibGVfY29udjFgKSxwPWEoaSxpLGAke299L3NlcGFyYWJsZV9jb252MmApO3JldHVybntzZXBhcmFibGVfY29udjA6bCxzZXBhcmFibGVfY29udjE6dSxzZXBhcmFibGVfY29udjI6cH19cmV0dXJue2V4dHJhY3RDb252UGFyYW1zOm4sZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXM6YSxleHRyYWN0UmVkdWN0aW9uQmxvY2tQYXJhbXM6cixleHRyYWN0TWFpbkJsb2NrUGFyYW1zOnN9fWZ1bmN0aW9uIGxEKGUsdCl7bGV0IG49W10se2V4dHJhY3RXZWlnaHRzOmEsZ2V0UmVtYWluaW5nV2VpZ2h0czpyfT1BbihlKSx7ZXh0cmFjdENvbnZQYXJhbXM6cyxleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtczppLGV4dHJhY3RSZWR1Y3Rpb25CbG9ja1BhcmFtczpvLGV4dHJhY3RNYWluQmxvY2tQYXJhbXM6bH09WGZlKGEsbiksdT1zKDMsMzIsMyxcImVudHJ5X2Zsb3cvY29udl9pblwiKSxwPW8oMzIsNjQsXCJlbnRyeV9mbG93L3JlZHVjdGlvbl9ibG9ja18wXCIpLGQ9byg2NCwxMjgsXCJlbnRyeV9mbG93L3JlZHVjdGlvbl9ibG9ja18xXCIpLGM9e2NvbnZfaW46dSxyZWR1Y3Rpb25fYmxvY2tfMDpwLHJlZHVjdGlvbl9ibG9ja18xOmR9LGg9e307Z3IodCwwLDEpLmZvckVhY2goYj0+e2hbYG1haW5fYmxvY2tfJHtifWBdPWwoMTI4LGBtaWRkbGVfZmxvdy9tYWluX2Jsb2NrXyR7Yn1gKX0pO2xldCBtPW8oMTI4LDI1NixcImV4aXRfZmxvdy9yZWR1Y3Rpb25fYmxvY2tcIiksZj1pKDI1Niw1MTIsXCJleGl0X2Zsb3cvc2VwYXJhYmxlX2NvbnZcIiksZz17cmVkdWN0aW9uX2Jsb2NrOm0sc2VwYXJhYmxlX2NvbnY6Zn07aWYocigpLmxlbmd0aCE9PTApdGhyb3cgbmV3IEVycm9yKGB3ZWlnaHRzIHJlbWFpbmcgYWZ0ZXIgZXh0cmFjdDogJHtyKCkubGVuZ3RofWApO3JldHVybntwYXJhbU1hcHBpbmdzOm4scGFyYW1zOntlbnRyeV9mbG93OmMsbWlkZGxlX2Zsb3c6aCxleGl0X2Zsb3c6Z319fWZ1bmN0aW9uIFlmZShlLHQpe2xldCBuPXNhKGUsdCksYT1uZyhuKSxyPUVwKG4pO2Z1bmN0aW9uIHMobyl7bGV0IGw9cihgJHtvfS9zZXBhcmFibGVfY29udjBgKSx1PXIoYCR7b30vc2VwYXJhYmxlX2NvbnYxYCkscD1hKGAke299L2V4cGFuc2lvbl9jb252YCk7cmV0dXJue3NlcGFyYWJsZV9jb252MDpsLHNlcGFyYWJsZV9jb252MTp1LGV4cGFuc2lvbl9jb252OnB9fWZ1bmN0aW9uIGkobyl7bGV0IGw9cihgJHtvfS9zZXBhcmFibGVfY29udjBgKSx1PXIoYCR7b30vc2VwYXJhYmxlX2NvbnYxYCkscD1yKGAke299L3NlcGFyYWJsZV9jb252MmApO3JldHVybntzZXBhcmFibGVfY29udjA6bCxzZXBhcmFibGVfY29udjE6dSxzZXBhcmFibGVfY29udjI6cH19cmV0dXJue2V4dHJhY3RDb252UGFyYW1zOmEsZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXM6cixleHRyYWN0UmVkdWN0aW9uQmxvY2tQYXJhbXM6cyxleHRyYWN0TWFpbkJsb2NrUGFyYW1zOml9fWZ1bmN0aW9uIHVEKGUsdCl7bGV0IG49W10se2V4dHJhY3RDb252UGFyYW1zOmEsZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXM6cixleHRyYWN0UmVkdWN0aW9uQmxvY2tQYXJhbXM6cyxleHRyYWN0TWFpbkJsb2NrUGFyYW1zOml9PVlmZShlLG4pLG89YShcImVudHJ5X2Zsb3cvY29udl9pblwiKSxsPXMoXCJlbnRyeV9mbG93L3JlZHVjdGlvbl9ibG9ja18wXCIpLHU9cyhcImVudHJ5X2Zsb3cvcmVkdWN0aW9uX2Jsb2NrXzFcIikscD17Y29udl9pbjpvLHJlZHVjdGlvbl9ibG9ja18wOmwscmVkdWN0aW9uX2Jsb2NrXzE6dX0sZD17fTtncih0LDAsMSkuZm9yRWFjaChmPT57ZFtgbWFpbl9ibG9ja18ke2Z9YF09aShgbWlkZGxlX2Zsb3cvbWFpbl9ibG9ja18ke2Z9YCl9KTtsZXQgYz1zKFwiZXhpdF9mbG93L3JlZHVjdGlvbl9ibG9ja1wiKSxoPXIoXCJleGl0X2Zsb3cvc2VwYXJhYmxlX2NvbnZcIiksbT17cmVkdWN0aW9uX2Jsb2NrOmMsc2VwYXJhYmxlX2NvbnY6aH07cmV0dXJuIF9uKGUsbikse3BhcmFtczp7ZW50cnlfZmxvdzpwLG1pZGRsZV9mbG93OmQsZXhpdF9mbG93Om19LHBhcmFtTWFwcGluZ3M6bn19ZnVuY3Rpb24gcEQoZSx0LG4pe3JldHVybiBYKCR0KGUsdC5maWx0ZXJzLG4sXCJzYW1lXCIpLHQuYmlhcyl9ZnVuY3Rpb24gVGsoZSx0LG49ITApe2xldCBhPW4/S2UoZSk6ZTtyZXR1cm4gYT1VbihhLHQuc2VwYXJhYmxlX2NvbnYwLFsxLDFdKSxhPVVuKEtlKGEpLHQuc2VwYXJhYmxlX2NvbnYxLFsxLDFdKSxhPUR0KGEsWzMsM10sWzIsMl0sXCJzYW1lXCIpLGE9WChhLHBEKGUsdC5leHBhbnNpb25fY29udixbMiwyXSkpLGF9ZnVuY3Rpb24gWmZlKGUsdCl7bGV0IG49VW4oS2UoZSksdC5zZXBhcmFibGVfY29udjAsWzEsMV0pO3JldHVybiBuPVVuKEtlKG4pLHQuc2VwYXJhYmxlX2NvbnYxLFsxLDFdKSxuPVVuKEtlKG4pLHQuc2VwYXJhYmxlX2NvbnYyLFsxLDFdKSxuPVgobixlKSxufXZhciBsZz1jbGFzcyBleHRlbmRzIGZue2NvbnN0cnVjdG9yKHQpe3N1cGVyKFwiVGlueVhjZXB0aW9uXCIpLHRoaXMuX251bU1haW5CbG9ja3M9dH1mb3J3YXJkSW5wdXQodCl7bGV0e3BhcmFtczpufT10aGlzO2lmKCFuKXRocm93IG5ldyBFcnJvcihcIlRpbnlYY2VwdGlvbiAtIGxvYWQgbW9kZWwgYmVmb3JlIGluZmVyZW5jZVwiKTtyZXR1cm4gTygoKT0+e2xldCBhPXJlKHQudG9CYXRjaFRlbnNvcigxMTIsITApLFwiZmxvYXQzMlwiKSxzPWJyKGEsWzEyMi43ODIsMTE3LjAwMSwxMDQuMjk4XSkuZGl2KDI1NSksaT1LZShwRChzLG4uZW50cnlfZmxvdy5jb252X2luLFsyLDJdKSk7cmV0dXJuIGk9VGsoaSxuLmVudHJ5X2Zsb3cucmVkdWN0aW9uX2Jsb2NrXzAsITEpLGk9VGsoaSxuLmVudHJ5X2Zsb3cucmVkdWN0aW9uX2Jsb2NrXzEpLGdyKHRoaXMuX251bU1haW5CbG9ja3MsMCwxKS5mb3JFYWNoKG89PntpPVpmZShpLG4ubWlkZGxlX2Zsb3dbYG1haW5fYmxvY2tfJHtvfWBdKX0pLGk9VGsoaSxuLmV4aXRfZmxvdy5yZWR1Y3Rpb25fYmxvY2spLGk9S2UoVW4oaSxuLmV4aXRfZmxvdy5zZXBhcmFibGVfY29udixbMSwxXSkpLGl9KX1hc3luYyBmb3J3YXJkKHQpe3JldHVybiB0aGlzLmZvcndhcmRJbnB1dChhd2FpdCB2dCh0KSl9Z2V0RGVmYXVsdE1vZGVsTmFtZSgpe3JldHVyblwidGlueV94Y2VwdGlvbl9tb2RlbFwifWV4dHJhY3RQYXJhbXNGcm9tV2VpZ2h0TWFwKHQpe3JldHVybiB1RCh0LHRoaXMuX251bU1haW5CbG9ja3MpfWV4dHJhY3RQYXJhbXModCl7cmV0dXJuIGxEKHQsdGhpcy5fbnVtTWFpbkJsb2Nrcyl9fTtmdW5jdGlvbiBjRChlKXtsZXQgdD1bXSx7ZXh0cmFjdFdlaWdodHM6bixnZXRSZW1haW5pbmdXZWlnaHRzOmF9PUFuKGUpLHI9ZWcobix0KSxzPXIoNTEyLDEsXCJmYy9hZ2VcIiksaT1yKDUxMiwyLFwiZmMvZ2VuZGVyXCIpO2lmKGEoKS5sZW5ndGghPT0wKXRocm93IG5ldyBFcnJvcihgd2VpZ2h0cyByZW1haW5nIGFmdGVyIGV4dHJhY3Q6ICR7YSgpLmxlbmd0aH1gKTtyZXR1cm57cGFyYW1NYXBwaW5nczp0LHBhcmFtczp7ZmM6e2FnZTpzLGdlbmRlcjppfX19fWZ1bmN0aW9uIGREKGUpe2xldCB0PVtdLG49c2EoZSx0KTtmdW5jdGlvbiBhKHMpe2xldCBpPW4oYCR7c30vd2VpZ2h0c2AsMiksbz1uKGAke3N9L2JpYXNgLDEpO3JldHVybnt3ZWlnaHRzOmksYmlhczpvfX1sZXQgcj17ZmM6e2FnZTphKFwiZmMvYWdlXCIpLGdlbmRlcjphKFwiZmMvZ2VuZGVyXCIpfX07cmV0dXJuIF9uKGUsdCkse3BhcmFtczpyLHBhcmFtTWFwcGluZ3M6dH19dmFyIENrPShuPT4obi5GRU1BTEU9XCJmZW1hbGVcIixuLk1BTEU9XCJtYWxlXCIsbikpKENrfHx7fSk7dmFyIHVnPWNsYXNzIGV4dGVuZHMgZm57Y29uc3RydWN0b3IodD1uZXcgbGcoMikpe3N1cGVyKFwiQWdlR2VuZGVyTmV0XCIpLHRoaXMuX2ZhY2VGZWF0dXJlRXh0cmFjdG9yPXR9Z2V0IGZhY2VGZWF0dXJlRXh0cmFjdG9yKCl7cmV0dXJuIHRoaXMuX2ZhY2VGZWF0dXJlRXh0cmFjdG9yfXJ1bk5ldCh0KXtsZXR7cGFyYW1zOm59PXRoaXM7aWYoIW4pdGhyb3cgbmV3IEVycm9yKGAke3RoaXMuX25hbWV9IC0gbG9hZCBtb2RlbCBiZWZvcmUgaW5mZXJlbmNlYCk7cmV0dXJuIE8oKCk9PntsZXQgYT10IGluc3RhbmNlb2YgV3I/dGhpcy5mYWNlRmVhdHVyZUV4dHJhY3Rvci5mb3J3YXJkSW5wdXQodCk6dCxyPXlhKGEsWzcsN10sWzIsMl0sXCJ2YWxpZFwiKS5hczJEKGEuc2hhcGVbMF0sLTEpLHM9QmQocixuLmZjLmFnZSkuYXMxRCgpLGk9QmQocixuLmZjLmdlbmRlcik7cmV0dXJue2FnZTpzLGdlbmRlcjppfX0pfWZvcndhcmRJbnB1dCh0KXtyZXR1cm4gTygoKT0+e2xldHthZ2U6bixnZW5kZXI6YX09dGhpcy5ydW5OZXQodCk7cmV0dXJue2FnZTpuLGdlbmRlcjpxYShhKX19KX1hc3luYyBmb3J3YXJkKHQpe3JldHVybiB0aGlzLmZvcndhcmRJbnB1dChhd2FpdCB2dCh0KSl9YXN5bmMgcHJlZGljdEFnZUFuZEdlbmRlcih0KXtsZXQgbj1hd2FpdCB2dCh0KSxhPWF3YWl0IHRoaXMuZm9yd2FyZElucHV0KG4pLHI9ZHQoYS5hZ2UpLHM9ZHQoYS5nZW5kZXIpLGk9ci5tYXAoKGwsdSk9Pih7YWdlVGVuc29yOmwsZ2VuZGVyVGVuc29yOnNbdV19KSksbz1hd2FpdCBQcm9taXNlLmFsbChpLm1hcChhc3luYyh7YWdlVGVuc29yOmwsZ2VuZGVyVGVuc29yOnV9KT0+e2xldCBwPWwuZGF0YVN5bmMoKVswXSxkPXUuZGF0YVN5bmMoKVswXSxjPWQ+LjUsaD1jP1wibWFsZVwiOlwiZmVtYWxlXCIsbT1jP2Q6MS1kO3JldHVybiBsLmRpc3Bvc2UoKSx1LmRpc3Bvc2UoKSx7YWdlOnAsZ2VuZGVyOmgsZ2VuZGVyUHJvYmFiaWxpdHk6bX19KSk7cmV0dXJuIGEuYWdlLmRpc3Bvc2UoKSxhLmdlbmRlci5kaXNwb3NlKCksbi5pc0JhdGNoSW5wdXQ/bzpvWzBdfWdldERlZmF1bHRNb2RlbE5hbWUoKXtyZXR1cm5cImFnZV9nZW5kZXJfbW9kZWxcIn1kaXNwb3NlKHQ9ITApe3RoaXMuZmFjZUZlYXR1cmVFeHRyYWN0b3IuZGlzcG9zZSh0KSxzdXBlci5kaXNwb3NlKHQpfWxvYWRDbGFzc2lmaWVyUGFyYW1zKHQpe2xldHtwYXJhbXM6bixwYXJhbU1hcHBpbmdzOmF9PXRoaXMuZXh0cmFjdENsYXNzaWZpZXJQYXJhbXModCk7dGhpcy5fcGFyYW1zPW4sdGhpcy5fcGFyYW1NYXBwaW5ncz1hfWV4dHJhY3RDbGFzc2lmaWVyUGFyYW1zKHQpe3JldHVybiBjRCh0KX1leHRyYWN0UGFyYW1zRnJvbVdlaWdodE1hcCh0KXtsZXR7ZmVhdHVyZUV4dHJhY3Rvck1hcDpuLGNsYXNzaWZpZXJNYXA6YX09cmcodCk7cmV0dXJuIHRoaXMuZmFjZUZlYXR1cmVFeHRyYWN0b3IubG9hZEZyb21XZWlnaHRNYXAobiksZEQoYSl9ZXh0cmFjdFBhcmFtcyh0KXtsZXQgYT10LnNsaWNlKDAsdC5sZW5ndGgtMTUzOSkscj10LnNsaWNlKHQubGVuZ3RoLTE1MzkpO3JldHVybiB0aGlzLmZhY2VGZWF0dXJlRXh0cmFjdG9yLmV4dHJhY3RXZWlnaHRzKGEpLHRoaXMuZXh0cmFjdENsYXNzaWZpZXJQYXJhbXMocil9fTt2YXIgJHA9Y2xhc3MgZXh0ZW5kcyBBcHtwb3N0UHJvY2Vzcyh0LG4sYSl7bGV0IHI9YS5tYXAoKHt3aWR0aDppLGhlaWdodDpvfSk9PntsZXQgbD1uL01hdGgubWF4KG8saSk7cmV0dXJue3dpZHRoOmkqbCxoZWlnaHQ6bypsfX0pLHM9ci5sZW5ndGg7cmV0dXJuIE8oKCk9PntsZXQgaT0oZCxjKT0+QXQoW3luKFs2OF0sZCxcImZsb2F0MzJcIikseW4oWzY4XSxjLFwiZmxvYXQzMlwiKV0sMSkuYXMyRCgxLDEzNikuYXMxRCgpLG89KGQsYyk9PntsZXR7d2lkdGg6aCxoZWlnaHQ6bX09cltkXTtyZXR1cm4gYyhoLG0pP01hdGguYWJzKGgtbSkvMjowfSxsPWQ9Pm8oZCwoYyxoKT0+YzxoKSx1PWQ9Pm8oZCwoYyxoKT0+aDxjKTtyZXR1cm4gdC5tdWwoeW4oW3MsMTM2XSxuLFwiZmxvYXQzMlwiKSkuc3ViKEF0KEFycmF5LmZyb20oQXJyYXkocyksKGQsYyk9PmkobChjKSx1KGMpKSkpKS5kaXYoQXQoQXJyYXkuZnJvbShBcnJheShzKSwoZCxjKT0+aShyW2NdLndpZHRoLHJbY10uaGVpZ2h0KSkpKX0pfWZvcndhcmRJbnB1dCh0KXtyZXR1cm4gTygoKT0+e2xldCBuPXRoaXMucnVuTmV0KHQpO3JldHVybiB0aGlzLnBvc3RQcm9jZXNzKG4sdC5pbnB1dFNpemUsdC5pbnB1dERpbWVuc2lvbnMubWFwKChbYSxyXSk9Pih7aGVpZ2h0OmEsd2lkdGg6cn0pKSl9KX1hc3luYyBmb3J3YXJkKHQpe3JldHVybiB0aGlzLmZvcndhcmRJbnB1dChhd2FpdCB2dCh0KSl9YXN5bmMgZGV0ZWN0TGFuZG1hcmtzKHQpe2xldCBuPWF3YWl0IHZ0KHQpLGE9TygoKT0+ZHQodGhpcy5mb3J3YXJkSW5wdXQobikpKSxyPWF3YWl0IFByb21pc2UuYWxsKGEubWFwKGFzeW5jKHMsaSk9PntsZXQgbz1BcnJheS5mcm9tKHMuZGF0YVN5bmMoKSksbD1vLmZpbHRlcigocCxkKT0+SGYoZCkpLHU9by5maWx0ZXIoKHAsZCk9PiFIZihkKSk7cmV0dXJuIG5ldyB2cChBcnJheSg2OCkuZmlsbCgwKS5tYXAoKHAsZCk9Pm5ldyBIZShsW2RdLHVbZF0pKSx7aGVpZ2h0Om4uZ2V0SW5wdXRIZWlnaHQoaSksd2lkdGg6bi5nZXRJbnB1dFdpZHRoKGkpfSl9KSk7cmV0dXJuIGEuZm9yRWFjaChzPT5zLmRpc3Bvc2UoKSksbi5pc0JhdGNoSW5wdXQ/cjpyWzBdfWdldENsYXNzaWZpZXJDaGFubmVsc091dCgpe3JldHVybiAxMzZ9fTt2YXIgRHA9Y2xhc3MgZXh0ZW5kcyAkcHtjb25zdHJ1Y3Rvcih0PW5ldyBfcCl7c3VwZXIoXCJGYWNlTGFuZG1hcms2OE5ldFwiLHQpfWdldERlZmF1bHRNb2RlbE5hbWUoKXtyZXR1cm5cImZhY2VfbGFuZG1hcmtfNjhfbW9kZWxcIn1nZXRDbGFzc2lmaWVyQ2hhbm5lbHNJbigpe3JldHVybiAyNTZ9fTtmdW5jdGlvbiBoRChlKXtsZXQgdD1bXSx7ZXh0cmFjdERlbnNlQmxvY2szUGFyYW1zOm59PWFnKGUsdCksYT17ZGVuc2UwOm4oXCJkZW5zZTBcIiwhMCksZGVuc2UxOm4oXCJkZW5zZTFcIiksZGVuc2UyOm4oXCJkZW5zZTJcIil9O3JldHVybiBfbihlLHQpLHtwYXJhbXM6YSxwYXJhbU1hcHBpbmdzOnR9fWZ1bmN0aW9uIG1EKGUpe2xldCB0PVtdLHtleHRyYWN0V2VpZ2h0czpuLGdldFJlbWFpbmluZ1dlaWdodHM6YX09QW4oZSkse2V4dHJhY3REZW5zZUJsb2NrM1BhcmFtczpyfT10ZyhuLHQpLHM9cigzLDMyLFwiZGVuc2UwXCIsITApLGk9cigzMiw2NCxcImRlbnNlMVwiKSxvPXIoNjQsMTI4LFwiZGVuc2UyXCIpO2lmKGEoKS5sZW5ndGghPT0wKXRocm93IG5ldyBFcnJvcihgd2VpZ2h0cyByZW1haW5nIGFmdGVyIGV4dHJhY3Q6ICR7YSgpLmxlbmd0aH1gKTtyZXR1cm57cGFyYW1NYXBwaW5nczp0LHBhcmFtczp7ZGVuc2UwOnMsZGVuc2UxOmksZGVuc2UyOm99fX12YXIgcGc9Y2xhc3MgZXh0ZW5kcyBmbntjb25zdHJ1Y3Rvcigpe3N1cGVyKFwiVGlueUZhY2VGZWF0dXJlRXh0cmFjdG9yXCIpfWZvcndhcmRJbnB1dCh0KXtsZXR7cGFyYW1zOm59PXRoaXM7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiVGlueUZhY2VGZWF0dXJlRXh0cmFjdG9yIC0gbG9hZCBtb2RlbCBiZWZvcmUgaW5mZXJlbmNlXCIpO3JldHVybiBPKCgpPT57bGV0IGE9cmUodC50b0JhdGNoVGVuc29yKDExMiwhMCksXCJmbG9hdDMyXCIpLHM9YnIoYSxbMTIyLjc4MiwxMTcuMDAxLDEwNC4yOThdKS5kaXYoMjU1KSxpPVFmKHMsbi5kZW5zZTAsITApO3JldHVybiBpPVFmKGksbi5kZW5zZTEpLGk9UWYoaSxuLmRlbnNlMiksaT15YShpLFsxNCwxNF0sWzIsMl0sXCJ2YWxpZFwiKSxpfSl9YXN5bmMgZm9yd2FyZCh0KXtyZXR1cm4gdGhpcy5mb3J3YXJkSW5wdXQoYXdhaXQgdnQodCkpfWdldERlZmF1bHRNb2RlbE5hbWUoKXtyZXR1cm5cImZhY2VfZmVhdHVyZV9leHRyYWN0b3JfdGlueV9tb2RlbFwifWV4dHJhY3RQYXJhbXNGcm9tV2VpZ2h0TWFwKHQpe3JldHVybiBoRCh0KX1leHRyYWN0UGFyYW1zKHQpe3JldHVybiBtRCh0KX19O3ZhciBjZz1jbGFzcyBleHRlbmRzICRwe2NvbnN0cnVjdG9yKHQ9bmV3IHBnKXtzdXBlcihcIkZhY2VMYW5kbWFyazY4VGlueU5ldFwiLHQpfWdldERlZmF1bHRNb2RlbE5hbWUoKXtyZXR1cm5cImZhY2VfbGFuZG1hcmtfNjhfdGlueV9tb2RlbFwifWdldENsYXNzaWZpZXJDaGFubmVsc0luKCl7cmV0dXJuIDEyOH19O3ZhciBmRD1jbGFzcyBleHRlbmRzIERwe307ZnVuY3Rpb24gZ0QoZSx0KXtyZXR1cm4gWCh6KGUsdC53ZWlnaHRzKSx0LmJpYXNlcyl9ZnVuY3Rpb24gRWsoZSx0LG4sYSxyPVwic2FtZVwiKXtsZXR7ZmlsdGVyczpzLGJpYXM6aX09dC5jb252LG89JHQoZSxzLG4scik7cmV0dXJuIG89WChvLGkpLG89Z0Qobyx0LnNjYWxlKSxhP0tlKG8pOm99ZnVuY3Rpb24gYkQoZSx0KXtyZXR1cm4gRWsoZSx0LFsxLDFdLCEwKX1mdW5jdGlvbiBfayhlLHQpe3JldHVybiBFayhlLHQsWzEsMV0sITEpfWZ1bmN0aW9uIGRnKGUsdCl7cmV0dXJuIEVrKGUsdCxbMiwyXSwhMCxcInZhbGlkXCIpfWZ1bmN0aW9uIEpmZShlLHQpe2Z1bmN0aW9uIG4obyxsLHUpe2xldCBwPWUobyksZD1wLmxlbmd0aC8obCp1KnUpO2lmKGdrKGQpKXRocm93IG5ldyBFcnJvcihgZGVwdGggaGFzIHRvIGJlIGFuIGludGVnZXI6ICR7ZH0sIHdlaWdodHMubGVuZ3RoOiAke3AubGVuZ3RofSwgbnVtRmlsdGVyczogJHtsfSwgZmlsdGVyU2l6ZTogJHt1fWApO3JldHVybiBPKCgpPT5EZShGYShwLFtsLGQsdSx1XSksWzIsMywxLDBdKSl9ZnVuY3Rpb24gYShvLGwsdSxwKXtsZXQgZD1uKG8sbCx1KSxjPWplKGUobCkpO3JldHVybiB0LnB1c2goe3BhcmFtUGF0aDpgJHtwfS9maWx0ZXJzYH0se3BhcmFtUGF0aDpgJHtwfS9iaWFzYH0pLHtmaWx0ZXJzOmQsYmlhczpjfX1mdW5jdGlvbiByKG8sbCl7bGV0IHU9amUoZShvKSkscD1qZShlKG8pKTtyZXR1cm4gdC5wdXNoKHtwYXJhbVBhdGg6YCR7bH0vd2VpZ2h0c2B9LHtwYXJhbVBhdGg6YCR7bH0vYmlhc2VzYH0pLHt3ZWlnaHRzOnUsYmlhc2VzOnB9fWZ1bmN0aW9uIHMobyxsLHUscCl7bGV0IGQ9YShvLGwsdSxgJHtwfS9jb252YCksYz1yKGwsYCR7cH0vc2NhbGVgKTtyZXR1cm57Y29udjpkLHNjYWxlOmN9fWZ1bmN0aW9uIGkobyxsLHUscCxkPSExKXtsZXQgYz1zKChkPy41OjEpKm8sbCx1LGAke3B9L2NvbnYxYCksaD1zKG8sbCx1LGAke3B9L2NvbnYyYCk7cmV0dXJue2NvbnYxOmMsY29udjI6aH19cmV0dXJue2V4dHJhY3RDb252TGF5ZXJQYXJhbXM6cyxleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtczppfX1mdW5jdGlvbiB5RChlKXtsZXR7ZXh0cmFjdFdlaWdodHM6dCxnZXRSZW1haW5pbmdXZWlnaHRzOm59PUFuKGUpLGE9W10se2V4dHJhY3RDb252TGF5ZXJQYXJhbXM6cixleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtczpzfT1KZmUodCxhKSxpPXIoNDcwNCwzMiw3LFwiY29udjMyX2Rvd25cIiksbz1zKDkyMTYsMzIsMyxcImNvbnYzMl8xXCIpLGw9cyg5MjE2LDMyLDMsXCJjb252MzJfMlwiKSx1PXMoOTIxNiwzMiwzLFwiY29udjMyXzNcIikscD1zKDM2ODY0LDY0LDMsXCJjb252NjRfZG93blwiLCEwKSxkPXMoMzY4NjQsNjQsMyxcImNvbnY2NF8xXCIpLGM9cygzNjg2NCw2NCwzLFwiY29udjY0XzJcIiksaD1zKDM2ODY0LDY0LDMsXCJjb252NjRfM1wiKSxtPXMoMTQ3NDU2LDEyOCwzLFwiY29udjEyOF9kb3duXCIsITApLGY9cygxNDc0NTYsMTI4LDMsXCJjb252MTI4XzFcIiksZz1zKDE0NzQ1NiwxMjgsMyxcImNvbnYxMjhfMlwiKSxiPXMoNTg5ODI0LDI1NiwzLFwiY29udjI1Nl9kb3duXCIsITApLHk9cyg1ODk4MjQsMjU2LDMsXCJjb252MjU2XzFcIikseD1zKDU4OTgyNCwyNTYsMyxcImNvbnYyNTZfMlwiKSx2PXMoNTg5ODI0LDI1NiwzLFwiY29udjI1Nl9kb3duX291dFwiKSxJPU8oKCk9PkRlKEVhKHQoMjU2KjEyOCksWzEyOCwyNTZdKSxbMSwwXSkpO2lmKGEucHVzaCh7cGFyYW1QYXRoOlwiZmNcIn0pLG4oKS5sZW5ndGghPT0wKXRocm93IG5ldyBFcnJvcihgd2VpZ2h0cyByZW1haW5nIGFmdGVyIGV4dHJhY3Q6ICR7bigpLmxlbmd0aH1gKTtyZXR1cm57cGFyYW1zOntjb252MzJfZG93bjppLGNvbnYzMl8xOm8sY29udjMyXzI6bCxjb252MzJfMzp1LGNvbnY2NF9kb3duOnAsY29udjY0XzE6ZCxjb252NjRfMjpjLGNvbnY2NF8zOmgsY29udjEyOF9kb3duOm0sY29udjEyOF8xOmYsY29udjEyOF8yOmcsY29udjI1Nl9kb3duOmIsY29udjI1Nl8xOnksY29udjI1Nl8yOngsY29udjI1Nl9kb3duX291dDp2LGZjOkl9LHBhcmFtTWFwcGluZ3M6YX19ZnVuY3Rpb24gUWZlKGUsdCl7bGV0IG49c2EoZSx0KTtmdW5jdGlvbiBhKGkpe2xldCBvPW4oYCR7aX0vc2NhbGUvd2VpZ2h0c2AsMSksbD1uKGAke2l9L3NjYWxlL2JpYXNlc2AsMSk7cmV0dXJue3dlaWdodHM6byxiaWFzZXM6bH19ZnVuY3Rpb24gcihpKXtsZXQgbz1uKGAke2l9L2NvbnYvZmlsdGVyc2AsNCksbD1uKGAke2l9L2NvbnYvYmlhc2AsMSksdT1hKGkpO3JldHVybntjb252OntmaWx0ZXJzOm8sYmlhczpsfSxzY2FsZTp1fX1mdW5jdGlvbiBzKGkpe3JldHVybntjb252MTpyKGAke2l9L2NvbnYxYCksY29udjI6cihgJHtpfS9jb252MmApfX1yZXR1cm57ZXh0cmFjdENvbnZMYXllclBhcmFtczpyLGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zOnN9fWZ1bmN0aW9uIHhEKGUpe2xldCB0PVtdLHtleHRyYWN0Q29udkxheWVyUGFyYW1zOm4sZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXM6YX09UWZlKGUsdCkscj1uKFwiY29udjMyX2Rvd25cIikscz1hKFwiY29udjMyXzFcIiksaT1hKFwiY29udjMyXzJcIiksbz1hKFwiY29udjMyXzNcIiksbD1hKFwiY29udjY0X2Rvd25cIiksdT1hKFwiY29udjY0XzFcIikscD1hKFwiY29udjY0XzJcIiksZD1hKFwiY29udjY0XzNcIiksYz1hKFwiY29udjEyOF9kb3duXCIpLGg9YShcImNvbnYxMjhfMVwiKSxtPWEoXCJjb252MTI4XzJcIiksZj1hKFwiY29udjI1Nl9kb3duXCIpLGc9YShcImNvbnYyNTZfMVwiKSxiPWEoXCJjb252MjU2XzJcIikseT1hKFwiY29udjI1Nl9kb3duX291dFwiKSx7ZmM6eH09ZTtpZih0LnB1c2goe29yaWdpbmFsUGF0aDpcImZjXCIscGFyYW1QYXRoOlwiZmNcIn0pLCFmayh4KSl0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIHdlaWdodE1hcFtmY10gdG8gYmUgYSBUZW5zb3IyRCwgaW5zdGVhZCBoYXZlICR7eH1gKTtsZXQgdj17Y29udjMyX2Rvd246cixjb252MzJfMTpzLGNvbnYzMl8yOmksY29udjMyXzM6byxjb252NjRfZG93bjpsLGNvbnY2NF8xOnUsY29udjY0XzI6cCxjb252NjRfMzpkLGNvbnYxMjhfZG93bjpjLGNvbnYxMjhfMTpoLGNvbnYxMjhfMjptLGNvbnYyNTZfZG93bjpmLGNvbnYyNTZfMTpnLGNvbnYyNTZfMjpiLGNvbnYyNTZfZG93bl9vdXQ6eSxmYzp4fTtyZXR1cm4gX24oZSx0KSx7cGFyYW1zOnYscGFyYW1NYXBwaW5nczp0fX1mdW5jdGlvbiBZYShlLHQpe2xldCBuPWJEKGUsdC5jb252MSk7cmV0dXJuIG49X2sobix0LmNvbnYyKSxuPVgobixlKSxuPUtlKG4pLG59ZnVuY3Rpb24gVWQoZSx0KXtsZXQgbj1kZyhlLHQuY29udjEpO249X2sobix0LmNvbnYyKTtsZXQgYT15YShlLDIsMixcInZhbGlkXCIpLHI9SXQoYS5zaGFwZSkscz1hLnNoYXBlWzNdIT09bi5zaGFwZVszXTtpZihhLnNoYXBlWzFdIT09bi5zaGFwZVsxXXx8YS5zaGFwZVsyXSE9PW4uc2hhcGVbMl0pe2xldCBvPVsuLi5uLnNoYXBlXTtvWzFdPTE7bGV0IGw9SXQobyk7bj1ldChbbixsXSwxKTtsZXQgdT1bLi4ubi5zaGFwZV07dVsyXT0xO2xldCBwPUl0KHUpO249ZXQoW24scF0sMil9cmV0dXJuIGE9cz9ldChbYSxyXSwzKTphLG49WChhLG4pLG49S2Uobiksbn12YXIgUnA9Y2xhc3MgZXh0ZW5kcyBmbntjb25zdHJ1Y3Rvcigpe3N1cGVyKFwiRmFjZVJlY29nbml0aW9uTmV0XCIpfWZvcndhcmRJbnB1dCh0KXtsZXR7cGFyYW1zOm59PXRoaXM7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiRmFjZVJlY29nbml0aW9uTmV0IC0gbG9hZCBtb2RlbCBiZWZvcmUgaW5mZXJlbmNlXCIpO3JldHVybiBPKCgpPT57bGV0IGE9cmUodC50b0JhdGNoVGVuc29yKDE1MCwhMCksXCJmbG9hdDMyXCIpLHM9YnIoYSxbMTIyLjc4MiwxMTcuMDAxLDEwNC4yOThdKS5kaXYoMjU1KSxpPWRnKHMsbi5jb252MzJfZG93bik7aT1EdChpLDMsMixcInZhbGlkXCIpLGk9WWEoaSxuLmNvbnYzMl8xKSxpPVlhKGksbi5jb252MzJfMiksaT1ZYShpLG4uY29udjMyXzMpLGk9VWQoaSxuLmNvbnY2NF9kb3duKSxpPVlhKGksbi5jb252NjRfMSksaT1ZYShpLG4uY29udjY0XzIpLGk9WWEoaSxuLmNvbnY2NF8zKSxpPVVkKGksbi5jb252MTI4X2Rvd24pLGk9WWEoaSxuLmNvbnYxMjhfMSksaT1ZYShpLG4uY29udjEyOF8yKSxpPVVkKGksbi5jb252MjU2X2Rvd24pLGk9WWEoaSxuLmNvbnYyNTZfMSksaT1ZYShpLG4uY29udjI1Nl8yKSxpPVVkKGksbi5jb252MjU2X2Rvd25fb3V0KTtsZXQgbz1pLm1lYW4oWzEsMl0pO3JldHVybiAkZShvLG4uZmMpfSl9YXN5bmMgZm9yd2FyZCh0KXtyZXR1cm4gdGhpcy5mb3J3YXJkSW5wdXQoYXdhaXQgdnQodCkpfWFzeW5jIGNvbXB1dGVGYWNlRGVzY3JpcHRvcih0KXt2YXIgcztpZigocz10PT1udWxsP3ZvaWQgMDp0LnNoYXBlKSE9bnVsbCYmcy5zb21lKGk9Pmk8PTApKXJldHVybiBuZXcgRmxvYXQzMkFycmF5KDEyOCk7bGV0IG49YXdhaXQgdnQodCksYT1PKCgpPT5kdCh0aGlzLmZvcndhcmRJbnB1dChuKSkpLHI9YXdhaXQgUHJvbWlzZS5hbGwoYS5tYXAoaT0+aS5kYXRhKCkpKTtyZXR1cm4gYS5mb3JFYWNoKGk9PmkuZGlzcG9zZSgpKSxuLmlzQmF0Y2hJbnB1dD9yOnJbMF19Z2V0RGVmYXVsdE1vZGVsTmFtZSgpe3JldHVyblwiZmFjZV9yZWNvZ25pdGlvbl9tb2RlbFwifWV4dHJhY3RQYXJhbXNGcm9tV2VpZ2h0TWFwKHQpe3JldHVybiB4RCh0KX1leHRyYWN0UGFyYW1zKHQpe3JldHVybiB5RCh0KX19O2Z1bmN0aW9uIFkyZShlKXtsZXQgdD1uZXcgUnA7cmV0dXJuIHQuZXh0cmFjdFdlaWdodHMoZSksdH1mdW5jdGlvbiBBayhlLHQpe3JldHVybnsuLi5lLC4uLntkZXNjcmlwdG9yOnR9fX1mdW5jdGlvbiBlQ2UoZSl7cmV0dXJuIHR5cGVvZiBlLmFnZT09XCJudW1iZXJcIn1mdW5jdGlvbiBGayhlLHQpe3JldHVybnsuLi5lLC4uLnthZ2U6dH19fWZ1bmN0aW9uIHJDZShlKXtyZXR1cm4oZS5nZW5kZXI9PT1cIm1hbGVcInx8ZS5nZW5kZXI9PT1cImZlbWFsZVwiKSYmZ3AoZS5nZW5kZXJQcm9iYWJpbGl0eSl9ZnVuY3Rpb24gJGsoZSx0LG4pe3JldHVybnsuLi5lLC4uLntnZW5kZXI6dCxnZW5kZXJQcm9iYWJpbGl0eTpufX19ZnVuY3Rpb24gZWdlKGUsdCl7ZnVuY3Rpb24gbihsLHUpe2xldCBwPUZhKGUoOSpsKSxbMywzLGwsMV0pLGQ9amUoZShsKSksYz1qZShlKGwpKSxoPWplKGUobCkpLG09amUoZShsKSk7cmV0dXJuIHQucHVzaCh7cGFyYW1QYXRoOmAke3V9L2ZpbHRlcnNgfSx7cGFyYW1QYXRoOmAke3V9L2JhdGNoX25vcm1fc2NhbGVgfSx7cGFyYW1QYXRoOmAke3V9L2JhdGNoX25vcm1fb2Zmc2V0YH0se3BhcmFtUGF0aDpgJHt1fS9iYXRjaF9ub3JtX21lYW5gfSx7cGFyYW1QYXRoOmAke3V9L2JhdGNoX25vcm1fdmFyaWFuY2VgfSkse2ZpbHRlcnM6cCxiYXRjaF9ub3JtX3NjYWxlOmQsYmF0Y2hfbm9ybV9vZmZzZXQ6YyxiYXRjaF9ub3JtX21lYW46aCxiYXRjaF9ub3JtX3ZhcmlhbmNlOm19fWZ1bmN0aW9uIGEobCx1LHAsZCxjKXtsZXQgaD1GYShlKGwqdSpwKnApLFtwLHAsbCx1XSksbT1qZShlKHUpKTtyZXR1cm4gdC5wdXNoKHtwYXJhbVBhdGg6YCR7ZH0vZmlsdGVyc2B9LHtwYXJhbVBhdGg6YCR7ZH0vJHtjP1wiYmF0Y2hfbm9ybV9vZmZzZXRcIjpcImJpYXNcIn1gfSkse2ZpbHRlcnM6aCxiaWFzOm19fWZ1bmN0aW9uIHIobCx1LHAsZCl7bGV0e2ZpbHRlcnM6YyxiaWFzOmh9PWEobCx1LHAsZCwhMCk7cmV0dXJue2ZpbHRlcnM6YyxiYXRjaF9ub3JtX29mZnNldDpofX1mdW5jdGlvbiBzKGwsdSxwKXtsZXQgZD1uKGwsYCR7cH0vZGVwdGh3aXNlX2NvbnZgKSxjPXIobCx1LDEsYCR7cH0vcG9pbnR3aXNlX2NvbnZgKTtyZXR1cm57ZGVwdGh3aXNlX2NvbnY6ZCxwb2ludHdpc2VfY29udjpjfX1mdW5jdGlvbiBpKCl7bGV0IGw9cigzLDMyLDMsXCJtb2JpbGVuZXR2MS9jb252XzBcIiksdT1zKDMyLDY0LFwibW9iaWxlbmV0djEvY29udl8xXCIpLHA9cyg2NCwxMjgsXCJtb2JpbGVuZXR2MS9jb252XzJcIiksZD1zKDEyOCwxMjgsXCJtb2JpbGVuZXR2MS9jb252XzNcIiksYz1zKDEyOCwyNTYsXCJtb2JpbGVuZXR2MS9jb252XzRcIiksaD1zKDI1NiwyNTYsXCJtb2JpbGVuZXR2MS9jb252XzVcIiksbT1zKDI1Niw1MTIsXCJtb2JpbGVuZXR2MS9jb252XzZcIiksZj1zKDUxMiw1MTIsXCJtb2JpbGVuZXR2MS9jb252XzdcIiksZz1zKDUxMiw1MTIsXCJtb2JpbGVuZXR2MS9jb252XzhcIiksYj1zKDUxMiw1MTIsXCJtb2JpbGVuZXR2MS9jb252XzlcIikseT1zKDUxMiw1MTIsXCJtb2JpbGVuZXR2MS9jb252XzEwXCIpLHg9cyg1MTIsNTEyLFwibW9iaWxlbmV0djEvY29udl8xMVwiKSx2PXMoNTEyLDEwMjQsXCJtb2JpbGVuZXR2MS9jb252XzEyXCIpLEk9cygxMDI0LDEwMjQsXCJtb2JpbGVuZXR2MS9jb252XzEzXCIpO3JldHVybntjb252XzA6bCxjb252XzE6dSxjb252XzI6cCxjb252XzM6ZCxjb252XzQ6Yyxjb252XzU6aCxjb252XzY6bSxjb252Xzc6Zixjb252Xzg6Zyxjb252Xzk6Yixjb252XzEwOnksY29udl8xMTp4LGNvbnZfMTI6dixjb252XzEzOkl9fWZ1bmN0aW9uIG8oKXtsZXQgbD1yKDEwMjQsMjU2LDEsXCJwcmVkaWN0aW9uX2xheWVyL2NvbnZfMFwiKSx1PXIoMjU2LDUxMiwzLFwicHJlZGljdGlvbl9sYXllci9jb252XzFcIikscD1yKDUxMiwxMjgsMSxcInByZWRpY3Rpb25fbGF5ZXIvY29udl8yXCIpLGQ9cigxMjgsMjU2LDMsXCJwcmVkaWN0aW9uX2xheWVyL2NvbnZfM1wiKSxjPXIoMjU2LDEyOCwxLFwicHJlZGljdGlvbl9sYXllci9jb252XzRcIiksaD1yKDEyOCwyNTYsMyxcInByZWRpY3Rpb25fbGF5ZXIvY29udl81XCIpLG09cigyNTYsNjQsMSxcInByZWRpY3Rpb25fbGF5ZXIvY29udl82XCIpLGY9cig2NCwxMjgsMyxcInByZWRpY3Rpb25fbGF5ZXIvY29udl83XCIpLGc9YSg1MTIsMTIsMSxcInByZWRpY3Rpb25fbGF5ZXIvYm94X3ByZWRpY3Rvcl8wL2JveF9lbmNvZGluZ19wcmVkaWN0b3JcIiksYj1hKDUxMiw5LDEsXCJwcmVkaWN0aW9uX2xheWVyL2JveF9wcmVkaWN0b3JfMC9jbGFzc19wcmVkaWN0b3JcIikseT1hKDEwMjQsMjQsMSxcInByZWRpY3Rpb25fbGF5ZXIvYm94X3ByZWRpY3Rvcl8xL2JveF9lbmNvZGluZ19wcmVkaWN0b3JcIikseD1hKDEwMjQsMTgsMSxcInByZWRpY3Rpb25fbGF5ZXIvYm94X3ByZWRpY3Rvcl8xL2NsYXNzX3ByZWRpY3RvclwiKSx2PWEoNTEyLDI0LDEsXCJwcmVkaWN0aW9uX2xheWVyL2JveF9wcmVkaWN0b3JfMi9ib3hfZW5jb2RpbmdfcHJlZGljdG9yXCIpLEk9YSg1MTIsMTgsMSxcInByZWRpY3Rpb25fbGF5ZXIvYm94X3ByZWRpY3Rvcl8yL2NsYXNzX3ByZWRpY3RvclwiKSxOPWEoMjU2LDI0LDEsXCJwcmVkaWN0aW9uX2xheWVyL2JveF9wcmVkaWN0b3JfMy9ib3hfZW5jb2RpbmdfcHJlZGljdG9yXCIpLEM9YSgyNTYsMTgsMSxcInByZWRpY3Rpb25fbGF5ZXIvYm94X3ByZWRpY3Rvcl8zL2NsYXNzX3ByZWRpY3RvclwiKSxfPWEoMjU2LDI0LDEsXCJwcmVkaWN0aW9uX2xheWVyL2JveF9wcmVkaWN0b3JfNC9ib3hfZW5jb2RpbmdfcHJlZGljdG9yXCIpLEY9YSgyNTYsMTgsMSxcInByZWRpY3Rpb25fbGF5ZXIvYm94X3ByZWRpY3Rvcl80L2NsYXNzX3ByZWRpY3RvclwiKSxEPWEoMTI4LDI0LDEsXCJwcmVkaWN0aW9uX2xheWVyL2JveF9wcmVkaWN0b3JfNS9ib3hfZW5jb2RpbmdfcHJlZGljdG9yXCIpLCQ9YSgxMjgsMTgsMSxcInByZWRpY3Rpb25fbGF5ZXIvYm94X3ByZWRpY3Rvcl81L2NsYXNzX3ByZWRpY3RvclwiKTtyZXR1cm57Y29udl8wOmwsY29udl8xOnUsY29udl8yOnAsY29udl8zOmQsY29udl80OmMsY29udl81OmgsY29udl82Om0sY29udl83OmYsYm94X3ByZWRpY3Rvcl8wOntib3hfZW5jb2RpbmdfcHJlZGljdG9yOmcsY2xhc3NfcHJlZGljdG9yOmJ9LGJveF9wcmVkaWN0b3JfMTp7Ym94X2VuY29kaW5nX3ByZWRpY3Rvcjp5LGNsYXNzX3ByZWRpY3Rvcjp4fSxib3hfcHJlZGljdG9yXzI6e2JveF9lbmNvZGluZ19wcmVkaWN0b3I6dixjbGFzc19wcmVkaWN0b3I6SX0sYm94X3ByZWRpY3Rvcl8zOntib3hfZW5jb2RpbmdfcHJlZGljdG9yOk4sY2xhc3NfcHJlZGljdG9yOkN9LGJveF9wcmVkaWN0b3JfNDp7Ym94X2VuY29kaW5nX3ByZWRpY3RvcjpfLGNsYXNzX3ByZWRpY3RvcjpGfSxib3hfcHJlZGljdG9yXzU6e2JveF9lbmNvZGluZ19wcmVkaWN0b3I6RCxjbGFzc19wcmVkaWN0b3I6JH19fXJldHVybntleHRyYWN0TW9iaWxlbmV0VjFQYXJhbXM6aSxleHRyYWN0UHJlZGljdGlvbkxheWVyUGFyYW1zOm99fWZ1bmN0aW9uIHZEKGUpe2xldCB0PVtdLHtleHRyYWN0V2VpZ2h0czpuLGdldFJlbWFpbmluZ1dlaWdodHM6YX09QW4oZSkse2V4dHJhY3RNb2JpbGVuZXRWMVBhcmFtczpyLGV4dHJhY3RQcmVkaWN0aW9uTGF5ZXJQYXJhbXM6c309ZWdlKG4sdCksaT1yKCksbz1zKCksdT17ZXh0cmFfZGltOnhkKG4oNTExOCo0KSxbMSw1MTE4LDRdKX07aWYodC5wdXNoKHtwYXJhbVBhdGg6XCJvdXRwdXRfbGF5ZXIvZXh0cmFfZGltXCJ9KSxhKCkubGVuZ3RoIT09MCl0aHJvdyBuZXcgRXJyb3IoYHdlaWdodHMgcmVtYWluZyBhZnRlciBleHRyYWN0OiAke2EoKS5sZW5ndGh9YCk7cmV0dXJue3BhcmFtczp7bW9iaWxlbmV0djE6aSxwcmVkaWN0aW9uX2xheWVyOm8sb3V0cHV0X2xheWVyOnV9LHBhcmFtTWFwcGluZ3M6dH19ZnVuY3Rpb24gdGdlKGUsdCl7bGV0IG49c2EoZSx0KTtmdW5jdGlvbiBhKHUscCxkKXtsZXQgYz1uKGAke3V9L0NvbnYyZF8ke3B9X3BvaW50d2lzZS93ZWlnaHRzYCw0LGAke2R9L2ZpbHRlcnNgKSxoPW4oYCR7dX0vQ29udjJkXyR7cH1fcG9pbnR3aXNlL2NvbnZvbHV0aW9uX2JuX29mZnNldGAsMSxgJHtkfS9iYXRjaF9ub3JtX29mZnNldGApO3JldHVybntmaWx0ZXJzOmMsYmF0Y2hfbm9ybV9vZmZzZXQ6aH19ZnVuY3Rpb24gcih1KXtsZXQgcD1gbW9iaWxlbmV0djEvY29udl8ke3V9YCxkPWBNb2JpbGVuZXRWMS9Db252MmRfJHt1fV9kZXB0aHdpc2VgLGM9YCR7cH0vZGVwdGh3aXNlX2NvbnZgLGg9YCR7cH0vcG9pbnR3aXNlX2NvbnZgLG09bihgJHtkfS9kZXB0aHdpc2Vfd2VpZ2h0c2AsNCxgJHtjfS9maWx0ZXJzYCksZj1uKGAke2R9L0JhdGNoTm9ybS9nYW1tYWAsMSxgJHtjfS9iYXRjaF9ub3JtX3NjYWxlYCksZz1uKGAke2R9L0JhdGNoTm9ybS9iZXRhYCwxLGAke2N9L2JhdGNoX25vcm1fb2Zmc2V0YCksYj1uKGAke2R9L0JhdGNoTm9ybS9tb3ZpbmdfbWVhbmAsMSxgJHtjfS9iYXRjaF9ub3JtX21lYW5gKSx5PW4oYCR7ZH0vQmF0Y2hOb3JtL21vdmluZ192YXJpYW5jZWAsMSxgJHtjfS9iYXRjaF9ub3JtX3ZhcmlhbmNlYCk7cmV0dXJue2RlcHRod2lzZV9jb252OntmaWx0ZXJzOm0sYmF0Y2hfbm9ybV9zY2FsZTpmLGJhdGNoX25vcm1fb2Zmc2V0OmcsYmF0Y2hfbm9ybV9tZWFuOmIsYmF0Y2hfbm9ybV92YXJpYW5jZTp5fSxwb2ludHdpc2VfY29udjphKFwiTW9iaWxlbmV0VjFcIix1LGgpfX1mdW5jdGlvbiBzKCl7cmV0dXJue2NvbnZfMDphKFwiTW9iaWxlbmV0VjFcIiwwLFwibW9iaWxlbmV0djEvY29udl8wXCIpLGNvbnZfMTpyKDEpLGNvbnZfMjpyKDIpLGNvbnZfMzpyKDMpLGNvbnZfNDpyKDQpLGNvbnZfNTpyKDUpLGNvbnZfNjpyKDYpLGNvbnZfNzpyKDcpLGNvbnZfODpyKDgpLGNvbnZfOTpyKDkpLGNvbnZfMTA6cigxMCksY29udl8xMTpyKDExKSxjb252XzEyOnIoMTIpLGNvbnZfMTM6cigxMyl9fWZ1bmN0aW9uIGkodSxwKXtsZXQgZD1uKGAke3V9L3dlaWdodHNgLDQsYCR7cH0vZmlsdGVyc2ApLGM9bihgJHt1fS9iaWFzZXNgLDEsYCR7cH0vYmlhc2ApO3JldHVybntmaWx0ZXJzOmQsYmlhczpjfX1mdW5jdGlvbiBvKHUpe2xldCBwPWkoYFByZWRpY3Rpb24vQm94UHJlZGljdG9yXyR7dX0vQm94RW5jb2RpbmdQcmVkaWN0b3JgLGBwcmVkaWN0aW9uX2xheWVyL2JveF9wcmVkaWN0b3JfJHt1fS9ib3hfZW5jb2RpbmdfcHJlZGljdG9yYCksZD1pKGBQcmVkaWN0aW9uL0JveFByZWRpY3Rvcl8ke3V9L0NsYXNzUHJlZGljdG9yYCxgcHJlZGljdGlvbl9sYXllci9ib3hfcHJlZGljdG9yXyR7dX0vY2xhc3NfcHJlZGljdG9yYCk7cmV0dXJue2JveF9lbmNvZGluZ19wcmVkaWN0b3I6cCxjbGFzc19wcmVkaWN0b3I6ZH19ZnVuY3Rpb24gbCgpe3JldHVybntjb252XzA6YShcIlByZWRpY3Rpb25cIiwwLFwicHJlZGljdGlvbl9sYXllci9jb252XzBcIiksY29udl8xOmEoXCJQcmVkaWN0aW9uXCIsMSxcInByZWRpY3Rpb25fbGF5ZXIvY29udl8xXCIpLGNvbnZfMjphKFwiUHJlZGljdGlvblwiLDIsXCJwcmVkaWN0aW9uX2xheWVyL2NvbnZfMlwiKSxjb252XzM6YShcIlByZWRpY3Rpb25cIiwzLFwicHJlZGljdGlvbl9sYXllci9jb252XzNcIiksY29udl80OmEoXCJQcmVkaWN0aW9uXCIsNCxcInByZWRpY3Rpb25fbGF5ZXIvY29udl80XCIpLGNvbnZfNTphKFwiUHJlZGljdGlvblwiLDUsXCJwcmVkaWN0aW9uX2xheWVyL2NvbnZfNVwiKSxjb252XzY6YShcIlByZWRpY3Rpb25cIiw2LFwicHJlZGljdGlvbl9sYXllci9jb252XzZcIiksY29udl83OmEoXCJQcmVkaWN0aW9uXCIsNyxcInByZWRpY3Rpb25fbGF5ZXIvY29udl83XCIpLGJveF9wcmVkaWN0b3JfMDpvKDApLGJveF9wcmVkaWN0b3JfMTpvKDEpLGJveF9wcmVkaWN0b3JfMjpvKDIpLGJveF9wcmVkaWN0b3JfMzpvKDMpLGJveF9wcmVkaWN0b3JfNDpvKDQpLGJveF9wcmVkaWN0b3JfNTpvKDUpfX1yZXR1cm57ZXh0cmFjdE1vYmlsZW5ldFYxUGFyYW1zOnMsZXh0cmFjdFByZWRpY3Rpb25MYXllclBhcmFtczpsfX1mdW5jdGlvbiB3RChlKXtsZXQgdD1bXSx7ZXh0cmFjdE1vYmlsZW5ldFYxUGFyYW1zOm4sZXh0cmFjdFByZWRpY3Rpb25MYXllclBhcmFtczphfT10Z2UoZSx0KSxyPWVbXCJPdXRwdXQvZXh0cmFfZGltXCJdO2lmKHQucHVzaCh7b3JpZ2luYWxQYXRoOlwiT3V0cHV0L2V4dHJhX2RpbVwiLHBhcmFtUGF0aDpcIm91dHB1dF9sYXllci9leHRyYV9kaW1cIn0pLCFMcihyKSl0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIHdlaWdodE1hcFsnT3V0cHV0L2V4dHJhX2RpbSddIHRvIGJlIGEgVGVuc29yM0QsIGluc3RlYWQgaGF2ZSAke3J9YCk7bGV0IHM9e21vYmlsZW5ldHYxOm4oKSxwcmVkaWN0aW9uX2xheWVyOmEoKSxvdXRwdXRfbGF5ZXI6e2V4dHJhX2RpbTpyfX07cmV0dXJuIF9uKGUsdCkse3BhcmFtczpzLHBhcmFtTWFwcGluZ3M6dH19ZnVuY3Rpb24gUmEoZSx0LG4pe3JldHVybiBPKCgpPT57bGV0IGE9JHQoZSx0LmZpbHRlcnMsbixcInNhbWVcIik7cmV0dXJuIGE9WChhLHQuYmF0Y2hfbm9ybV9vZmZzZXQpLGFuKGEsMCw2KX0pfXZhciBuZ2U9LjAwMTAwMDAwMDA0NzQ5NzQ1MTM7ZnVuY3Rpb24gYWdlKGUsdCxuKXtyZXR1cm4gTygoKT0+e2xldCBhPVRzKGUsdC5maWx0ZXJzLG4sXCJzYW1lXCIpO3JldHVybiBhPU5zKGEsdC5iYXRjaF9ub3JtX21lYW4sdC5iYXRjaF9ub3JtX3ZhcmlhbmNlLHQuYmF0Y2hfbm9ybV9vZmZzZXQsdC5iYXRjaF9ub3JtX3NjYWxlLG5nZSksYW4oYSwwLDYpfSl9ZnVuY3Rpb24gcmdlKGUpe3JldHVyblsyLDQsNiwxMl0uc29tZSh0PT50PT09ZSk/WzIsMl06WzEsMV19ZnVuY3Rpb24ga0QoZSx0KXtyZXR1cm4gTygoKT0+e2xldCBuLGE9UmEoZSx0LmNvbnZfMCxbMiwyXSk7aWYoW3QuY29udl8xLHQuY29udl8yLHQuY29udl8zLHQuY29udl80LHQuY29udl81LHQuY29udl82LHQuY29udl83LHQuY29udl84LHQuY29udl85LHQuY29udl8xMCx0LmNvbnZfMTEsdC5jb252XzEyLHQuY29udl8xM10uZm9yRWFjaCgocyxpKT0+e2xldCBvPWkrMSxsPXJnZShvKTthPWFnZShhLHMuZGVwdGh3aXNlX2NvbnYsbCksYT1SYShhLHMucG9pbnR3aXNlX2NvbnYsWzEsMV0pLG89PT0xMSYmKG49YSl9KSxuPT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJtb2JpbGVOZXRWMSAtIG91dHB1dCBvZiBjb252IGxheWVyIDExIGlzIG51bGxcIik7cmV0dXJue291dDphLGNvbnYxMTpufX0pfWZ1bmN0aW9uIHNnZShlLHQsbil7bGV0IGE9ZS5hcnJheVN5bmMoKSxyPU1hdGgubWluKGFbdF1bMF0sYVt0XVsyXSkscz1NYXRoLm1pbihhW3RdWzFdLGFbdF1bM10pLGk9TWF0aC5tYXgoYVt0XVswXSxhW3RdWzJdKSxvPU1hdGgubWF4KGFbdF1bMV0sYVt0XVszXSksbD1NYXRoLm1pbihhW25dWzBdLGFbbl1bMl0pLHU9TWF0aC5taW4oYVtuXVsxXSxhW25dWzNdKSxwPU1hdGgubWF4KGFbbl1bMF0sYVtuXVsyXSksZD1NYXRoLm1heChhW25dWzFdLGFbbl1bM10pLGM9KGktcikqKG8tcyksaD0ocC1sKSooZC11KTtpZihjPD0wfHxoPD0wKXJldHVybiAwO2xldCBtPU1hdGgubWF4KHIsbCksZj1NYXRoLm1heChzLHUpLGc9TWF0aC5taW4oaSxwKSxiPU1hdGgubWluKG8sZCkseT1NYXRoLm1heChnLW0sMCkqTWF0aC5tYXgoYi1mLDApO3JldHVybiB5LyhjK2gteSl9ZnVuY3Rpb24gSUQoZSx0LG4sYSxyKXtsZXQgcz1lLnNoYXBlWzBdLGk9TWF0aC5taW4obixzKSxvPXQubWFwKChwLGQpPT4oe3Njb3JlOnAsYm94SW5kZXg6ZH0pKS5maWx0ZXIocD0+cC5zY29yZT5yKS5zb3J0KChwLGQpPT5kLnNjb3JlLXAuc2NvcmUpLGw9cD0+cDw9YT8xOjAsdT1bXTtyZXR1cm4gby5mb3JFYWNoKHA9PntpZih1Lmxlbmd0aD49aSlyZXR1cm47bGV0IGQ9cC5zY29yZTtmb3IobGV0IGM9dS5sZW5ndGgtMTtjPj0wOy0tYyl7bGV0IGg9c2dlKGUscC5ib3hJbmRleCx1W2NdKTtpZihoIT09MCYmKHAuc2NvcmUqPWwoaCkscC5zY29yZTw9cikpYnJlYWt9ZD09PXAuc2NvcmUmJnUucHVzaChwLmJveEluZGV4KX0pLHV9ZnVuY3Rpb24gaWdlKGUpe2xldCB0PWR0KERlKGUsWzEsMF0pKSxuPVtwZSh0WzJdLHRbMF0pLHBlKHRbM10sdFsxXSldLGE9W1godFswXSxoZShuWzBdLDIpKSxYKHRbMV0saGUoblsxXSwyKSldO3JldHVybntzaXplczpuLGNlbnRlcnM6YX19ZnVuY3Rpb24gb2dlKGUsdCl7bGV0e3NpemVzOm4sY2VudGVyczphfT1pZ2UoZSkscj1kdChEZSh0LFsxLDBdKSkscz1oZSh6KGRuKGhlKHJbMl0sNSkpLG5bMF0pLDIpLGk9WCh6KGhlKHJbMF0sMTApLG5bMF0pLGFbMF0pLG89aGUoeihkbihoZShyWzNdLDUpKSxuWzFdKSwyKSxsPVgoeihoZShyWzFdLDEwKSxuWzFdKSxhWzFdKTtyZXR1cm4gRGUoQXQoW3BlKGkscykscGUobCxvKSxYKGkscyksWChsLG8pXSksWzEsMF0pfWZ1bmN0aW9uIFNEKGUsdCxuKXtyZXR1cm4gTygoKT0+e2xldCBhPWUuc2hhcGVbMF0scj1vZ2UoVyhPbihuLmV4dHJhX2RpbSxbYSwxLDFdKSxbLTEsNF0pLFcoZSxbLTEsNF0pKTtyPVcocixbYSxyLnNoYXBlWzBdL2EsNF0pO2xldCBzPWhhKFZlKHQsWzAsMCwxXSxbLTEsLTEsLTFdKSksaT1WZShzLFswLDAsMF0sWy0xLC0xLDFdKTtpPVcoaSxbYSxpLnNoYXBlWzFdXSk7bGV0IG89ZHQociksbD1kdChpKTtyZXR1cm57Ym94ZXM6byxzY29yZXM6bH19KX1mdW5jdGlvbiBvbChlLHQpe3JldHVybiBPKCgpPT57bGV0IG49ZS5zaGFwZVswXSxhPVcoaWwoZSx0LmJveF9lbmNvZGluZ19wcmVkaWN0b3IpLFtuLC0xLDEsNF0pLHI9VyhpbChlLHQuY2xhc3NfcHJlZGljdG9yKSxbbiwtMSwzXSk7cmV0dXJue2JveFByZWRpY3Rpb25FbmNvZGluZzphLGNsYXNzUHJlZGljdGlvbjpyfX0pfWZ1bmN0aW9uIE5EKGUsdCxuKXtyZXR1cm4gTygoKT0+e2xldCBhPVJhKGUsbi5jb252XzAsWzEsMV0pLHI9UmEoYSxuLmNvbnZfMSxbMiwyXSkscz1SYShyLG4uY29udl8yLFsxLDFdKSxpPVJhKHMsbi5jb252XzMsWzIsMl0pLG89UmEoaSxuLmNvbnZfNCxbMSwxXSksbD1SYShvLG4uY29udl81LFsyLDJdKSx1PVJhKGwsbi5jb252XzYsWzEsMV0pLHA9UmEodSxuLmNvbnZfNyxbMiwyXSksZD1vbCh0LG4uYm94X3ByZWRpY3Rvcl8wKSxjPW9sKGUsbi5ib3hfcHJlZGljdG9yXzEpLGg9b2wocixuLmJveF9wcmVkaWN0b3JfMiksbT1vbChpLG4uYm94X3ByZWRpY3Rvcl8zKSxmPW9sKGwsbi5ib3hfcHJlZGljdG9yXzQpLGc9b2wocCxuLmJveF9wcmVkaWN0b3JfNSksYj1ldChbZC5ib3hQcmVkaWN0aW9uRW5jb2RpbmcsYy5ib3hQcmVkaWN0aW9uRW5jb2RpbmcsaC5ib3hQcmVkaWN0aW9uRW5jb2RpbmcsbS5ib3hQcmVkaWN0aW9uRW5jb2RpbmcsZi5ib3hQcmVkaWN0aW9uRW5jb2RpbmcsZy5ib3hQcmVkaWN0aW9uRW5jb2RpbmddLDEpLHk9ZXQoW2QuY2xhc3NQcmVkaWN0aW9uLGMuY2xhc3NQcmVkaWN0aW9uLGguY2xhc3NQcmVkaWN0aW9uLG0uY2xhc3NQcmVkaWN0aW9uLGYuY2xhc3NQcmVkaWN0aW9uLGcuY2xhc3NQcmVkaWN0aW9uXSwxKTtyZXR1cm57Ym94UHJlZGljdGlvbnM6YixjbGFzc1ByZWRpY3Rpb25zOnl9fSl9dmFyIE1hPWNsYXNze2NvbnN0cnVjdG9yKHttaW5Db25maWRlbmNlOnQsbWF4UmVzdWx0czpufT17fSl7dGhpcy5fbmFtZT1cIlNzZE1vYmlsZW5ldHYxT3B0aW9uc1wiO2lmKHRoaXMuX21pbkNvbmZpZGVuY2U9dHx8LjUsdGhpcy5fbWF4UmVzdWx0cz1ufHwxMDAsdHlwZW9mIHRoaXMuX21pbkNvbmZpZGVuY2UhPVwibnVtYmVyXCJ8fHRoaXMuX21pbkNvbmZpZGVuY2U8PTB8fHRoaXMuX21pbkNvbmZpZGVuY2U+PTEpdGhyb3cgbmV3IEVycm9yKGAke3RoaXMuX25hbWV9IC0gZXhwZWN0ZWQgbWluQ29uZmlkZW5jZSB0byBiZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFgKTtpZih0eXBlb2YgdGhpcy5fbWF4UmVzdWx0cyE9XCJudW1iZXJcIil0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5fbmFtZX0gLSBleHBlY3RlZCBtYXhSZXN1bHRzIHRvIGJlIGEgbnVtYmVyYCl9Z2V0IG1pbkNvbmZpZGVuY2UoKXtyZXR1cm4gdGhpcy5fbWluQ29uZmlkZW5jZX1nZXQgbWF4UmVzdWx0cygpe3JldHVybiB0aGlzLl9tYXhSZXN1bHRzfX07dmFyIGxsPWNsYXNzIGV4dGVuZHMgZm57Y29uc3RydWN0b3IoKXtzdXBlcihcIlNzZE1vYmlsZW5ldHYxXCIpfWZvcndhcmRJbnB1dCh0KXtsZXR7cGFyYW1zOm59PXRoaXM7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiU3NkTW9iaWxlbmV0djEgLSBsb2FkIG1vZGVsIGJlZm9yZSBpbmZlcmVuY2VcIik7cmV0dXJuIE8oKCk9PntsZXQgYT1yZSh0LnRvQmF0Y2hUZW5zb3IoNTEyLCExKSxcImZsb2F0MzJcIikscj1wZShoZShhLDEyNy41KSwxKSxzPWtEKHIsbi5tb2JpbGVuZXR2MSkse2JveFByZWRpY3Rpb25zOmksY2xhc3NQcmVkaWN0aW9uczpvfT1ORChzLm91dCxzLmNvbnYxMSxuLnByZWRpY3Rpb25fbGF5ZXIpO3JldHVybiBTRChpLG8sbi5vdXRwdXRfbGF5ZXIpfSl9YXN5bmMgZm9yd2FyZCh0KXtyZXR1cm4gdGhpcy5mb3J3YXJkSW5wdXQoYXdhaXQgdnQodCkpfWFzeW5jIGxvY2F0ZUZhY2VzKHQsbj17fSl7bGV0e21heFJlc3VsdHM6YSxtaW5Db25maWRlbmNlOnJ9PW5ldyBNYShuKSxzPWF3YWl0IHZ0KHQpLHtib3hlczppLHNjb3JlczpvfT10aGlzLmZvcndhcmRJbnB1dChzKSxsPWlbMF0sdT1vWzBdO2ZvcihsZXQgeD0xO3g8aS5sZW5ndGg7eCsrKWlbeF0uZGlzcG9zZSgpLG9beF0uZGlzcG9zZSgpO2xldCBwPUFycmF5LmZyb20odS5kYXRhU3luYygpKSxjPUlEKGwscCxhLC41LHIpLGg9cy5nZXRSZXNoYXBlZElucHV0RGltZW5zaW9ucygwKSxtPXMuaW5wdXRTaXplLGY9bS9oLndpZHRoLGc9bS9oLmhlaWdodCxiPWwuYXJyYXlTeW5jKCkseT1jLm1hcCh4PT57bGV0W3YsSV09W01hdGgubWF4KDAsYlt4XVswXSksTWF0aC5taW4oMSxiW3hdWzJdKV0ubWFwKF89Pl8qZyksW04sQ109W01hdGgubWF4KDAsYlt4XVsxXSksTWF0aC5taW4oMSxiW3hdWzNdKV0ubWFwKF89Pl8qZik7cmV0dXJuIG5ldyBGdChwW3hdLG5ldyB4cChOLHYsQy1OLEktdikse2hlaWdodDpzLmdldElucHV0SGVpZ2h0KDApLHdpZHRoOnMuZ2V0SW5wdXRXaWR0aCgwKX0pfSk7cmV0dXJuIGwuZGlzcG9zZSgpLHUuZGlzcG9zZSgpLHl9Z2V0RGVmYXVsdE1vZGVsTmFtZSgpe3JldHVyblwic3NkX21vYmlsZW5ldHYxX21vZGVsXCJ9ZXh0cmFjdFBhcmFtc0Zyb21XZWlnaHRNYXAodCl7cmV0dXJuIHdEKHQpfWV4dHJhY3RQYXJhbXModCl7cmV0dXJuIHZEKHQpfX07ZnVuY3Rpb24gbGdlKGUpe2xldCB0PW5ldyBsbDtyZXR1cm4gdC5leHRyYWN0V2VpZ2h0cyhlKSx0fWZ1bmN0aW9uIFlDZShlKXtyZXR1cm4gbGdlKGUpfXZhciBURD1jbGFzcyBleHRlbmRzIGxse307dmFyIENEPS40LEVEPVtuZXcgSGUoLjczODc2OCwuODc0OTQ2KSxuZXcgSGUoMi40MjIwNCwyLjY1NzA0KSxuZXcgSGUoNC4zMDk3MSw3LjA0NDkzKSxuZXcgSGUoMTAuMjQ2LDQuNTk0MjgpLG5ldyBIZSgxMi42ODY4LDExLjg3NDEpXSxfRD1bbmV3IEhlKDEuNjAzMjMxLDIuMDk0NDY4KSxuZXcgSGUoNi4wNDExNDMsNy4wODAxMjYpLG5ldyBIZSgyLjg4MjQ1OSwzLjUxODA2MSksbmV3IEhlKDQuMjY2OTA2LDUuMTc4ODU3KSxuZXcgSGUoOS4wNDE3NjUsMTAuNjYzMDgpXSxBRD1bMTE3LjAwMSwxMTQuNjk3LDk3LjQwNF0sRkQ9XCJ0aW55X3lvbG92Ml9tb2RlbFwiLCREPVwidGlueV95b2xvdjJfc2VwYXJhYmxlX2NvbnZfbW9kZWxcIjt2YXIgaGc9ZT0+dHlwZW9mIGU9PVwibnVtYmVyXCI7ZnVuY3Rpb24gREQoZSl7aWYoIWUpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGNvbmZpZzogJHtlfWApO2lmKHR5cGVvZiBlLndpdGhTZXBhcmFibGVDb252cyE9XCJib29sZWFuXCIpdGhyb3cgbmV3IEVycm9yKGBjb25maWcud2l0aFNlcGFyYWJsZUNvbnZzIGhhcyB0byBiZSBhIGJvb2xlYW4sIGhhdmU6ICR7ZS53aXRoU2VwYXJhYmxlQ29udnN9YCk7aWYoIWhnKGUuaW91VGhyZXNob2xkKXx8ZS5pb3VUaHJlc2hvbGQ8MHx8ZS5pb3VUaHJlc2hvbGQ+MSl0aHJvdyBuZXcgRXJyb3IoYGNvbmZpZy5pb3VUaHJlc2hvbGQgaGFzIHRvIGJlIGEgbnVtYmVyIGJldHdlZW4gWzAsIDFdLCBoYXZlOiAke2UuaW91VGhyZXNob2xkfWApO2lmKCFBcnJheS5pc0FycmF5KGUuY2xhc3Nlcyl8fCFlLmNsYXNzZXMubGVuZ3RofHwhZS5jbGFzc2VzLmV2ZXJ5KHQ9PnR5cGVvZiB0PT1cInN0cmluZ1wiKSl0aHJvdyBuZXcgRXJyb3IoYGNvbmZpZy5jbGFzc2VzIGhhcyB0byBiZSBhbiBhcnJheSBjbGFzcyBuYW1lczogc3RyaW5nW10sIGhhdmU6ICR7SlNPTi5zdHJpbmdpZnkoZS5jbGFzc2VzKX1gKTtpZighQXJyYXkuaXNBcnJheShlLmFuY2hvcnMpfHwhZS5hbmNob3JzLmxlbmd0aHx8IWUuYW5jaG9ycy5tYXAodD0+dHx8e30pLmV2ZXJ5KHQ9PmhnKHQueCkmJmhnKHQueSkpKXRocm93IG5ldyBFcnJvcihgY29uZmlnLmFuY2hvcnMgaGFzIHRvIGJlIGFuIGFycmF5IG9mIHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfSwgaGF2ZTogJHtKU09OLnN0cmluZ2lmeShlLmFuY2hvcnMpfWApO2lmKGUubWVhblJnYiYmKCFBcnJheS5pc0FycmF5KGUubWVhblJnYil8fGUubWVhblJnYi5sZW5ndGghPT0zfHwhZS5tZWFuUmdiLmV2ZXJ5KGhnKSkpdGhyb3cgbmV3IEVycm9yKGBjb25maWcubWVhblJnYiBoYXMgdG8gYmUgYW4gYXJyYXkgb2Ygc2hhcGUgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBoYXZlOiAke0pTT04uc3RyaW5naWZ5KGUubWVhblJnYil9YCl9ZnVuY3Rpb24gTXAoZSl7cmV0dXJuIE8oKCk9PntsZXQgdD16KGUseGUoLjEwMDAwMDAwMTQ5MDExNjEyKSk7cmV0dXJuIFgoS2UocGUoZSx0KSksdCl9KX1mdW5jdGlvbiBCcihlLHQpe3JldHVybiBPKCgpPT57bGV0IG49eGEoZSxbWzAsMF0sWzEsMV0sWzEsMV0sWzAsMF1dKTtyZXR1cm4gbj0kdChuLHQuY29udi5maWx0ZXJzLFsxLDFdLFwidmFsaWRcIiksbj1wZShuLHQuYm4uc3ViKSxuPXoobix0LmJuLnRydWVkaXYpLG49WChuLHQuY29udi5iaWFzKSxNcChuKX0pfWZ1bmN0aW9uIFZyKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbj14YShlLFtbMCwwXSxbMSwxXSxbMSwxXSxbMCwwXV0pO3JldHVybiBuPV9zKG4sdC5kZXB0aHdpc2VfZmlsdGVyLHQucG9pbnR3aXNlX2ZpbHRlcixbMSwxXSxcInZhbGlkXCIpLG49WChuLHQuYmlhcyksTXAobil9KX1mdW5jdGlvbiB1Z2UoZSx0KXtsZXQgbj1UcChlLHQpO2Z1bmN0aW9uIGEoaSxvKXtsZXQgbD1qZShlKGkpKSx1PWplKGUoaSkpO3JldHVybiB0LnB1c2goe3BhcmFtUGF0aDpgJHtvfS9zdWJgfSx7cGFyYW1QYXRoOmAke299L3RydWVkaXZgfSkse3N1YjpsLHRydWVkaXY6dX19ZnVuY3Rpb24gcihpLG8sbCl7bGV0IHU9bihpLG8sMyxgJHtsfS9jb252YCkscD1hKG8sYCR7bH0vYm5gKTtyZXR1cm57Y29udjp1LGJuOnB9fWxldCBzPUNwKGUsdCk7cmV0dXJue2V4dHJhY3RDb252UGFyYW1zOm4sZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zOnIsZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXM6c319ZnVuY3Rpb24gUkQoZSx0LG4sYSl7bGV0e2V4dHJhY3RXZWlnaHRzOnIsZ2V0UmVtYWluaW5nV2VpZ2h0czpzfT1BbihlKSxpPVtdLHtleHRyYWN0Q29udlBhcmFtczpvLGV4dHJhY3RDb252V2l0aEJhdGNoTm9ybVBhcmFtczpsLGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zOnV9PXVnZShyLGkpLHA7aWYodC53aXRoU2VwYXJhYmxlQ29udnMpe2xldFtkLGMsaCxtLGYsZyxiLHkseF09YSx2PXQuaXNGaXJzdExheWVyQ29udjJkP28oZCxjLDMsXCJjb252MFwiKTp1KGQsYyxcImNvbnYwXCIpLEk9dShjLGgsXCJjb252MVwiKSxOPXUoaCxtLFwiY29udjJcIiksQz11KG0sZixcImNvbnYzXCIpLF89dShmLGcsXCJjb252NFwiKSxGPXUoZyxiLFwiY29udjVcIiksRD15P3UoYix5LFwiY29udjZcIik6dm9pZCAwLCQ9eD91KHkseCxcImNvbnY3XCIpOnZvaWQgMCxTPW8oeHx8eXx8Yiw1Km4sMSxcImNvbnY4XCIpO3A9e2NvbnYwOnYsY29udjE6SSxjb252MjpOLGNvbnYzOkMsY29udjQ6Xyxjb252NTpGLGNvbnY2OkQsY29udjc6JCxjb252ODpTfX1lbHNle2xldFtkLGMsaCxtLGYsZyxiLHkseF09YSx2PWwoZCxjLFwiY29udjBcIiksST1sKGMsaCxcImNvbnYxXCIpLE49bChoLG0sXCJjb252MlwiKSxDPWwobSxmLFwiY29udjNcIiksXz1sKGYsZyxcImNvbnY0XCIpLEY9bChnLGIsXCJjb252NVwiKSxEPWwoYix5LFwiY29udjZcIiksJD1sKHkseCxcImNvbnY3XCIpLFM9byh4LDUqbiwxLFwiY29udjhcIik7cD17Y29udjA6dixjb252MTpJLGNvbnYyOk4sY29udjM6Qyxjb252NDpfLGNvbnY1OkYsY29udjY6RCxjb252NzokLGNvbnY4OlN9fWlmKHMoKS5sZW5ndGghPT0wKXRocm93IG5ldyBFcnJvcihgd2VpZ2h0cyByZW1haW5nIGFmdGVyIGV4dHJhY3Q6ICR7cygpLmxlbmd0aH1gKTtyZXR1cm57cGFyYW1zOnAscGFyYW1NYXBwaW5nczppfX1mdW5jdGlvbiBwZ2UoZSx0KXtsZXQgbj1zYShlLHQpO2Z1bmN0aW9uIGEobyl7bGV0IGw9bihgJHtvfS9zdWJgLDEpLHU9bihgJHtvfS90cnVlZGl2YCwxKTtyZXR1cm57c3ViOmwsdHJ1ZWRpdjp1fX1mdW5jdGlvbiByKG8pe2xldCBsPW4oYCR7b30vZmlsdGVyc2AsNCksdT1uKGAke299L2JpYXNgLDEpO3JldHVybntmaWx0ZXJzOmwsYmlhczp1fX1mdW5jdGlvbiBzKG8pe2xldCBsPXIoYCR7b30vY29udmApLHU9YShgJHtvfS9ibmApO3JldHVybntjb252OmwsYm46dX19bGV0IGk9RXAobik7cmV0dXJue2V4dHJhY3RDb252UGFyYW1zOnIsZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zOnMsZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXM6aX19ZnVuY3Rpb24gTUQoZSx0KXtsZXQgbj1bXSx7ZXh0cmFjdENvbnZQYXJhbXM6YSxleHRyYWN0Q29udldpdGhCYXRjaE5vcm1QYXJhbXM6cixleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtczpzfT1wZ2UoZSxuKSxpO2lmKHQud2l0aFNlcGFyYWJsZUNvbnZzKXtsZXQgbz10LmZpbHRlclNpemVzJiZ0LmZpbHRlclNpemVzLmxlbmd0aHx8OTtpPXtjb252MDp0LmlzRmlyc3RMYXllckNvbnYyZD9hKFwiY29udjBcIik6cyhcImNvbnYwXCIpLGNvbnYxOnMoXCJjb252MVwiKSxjb252MjpzKFwiY29udjJcIiksY29udjM6cyhcImNvbnYzXCIpLGNvbnY0OnMoXCJjb252NFwiKSxjb252NTpzKFwiY29udjVcIiksY29udjY6bz43P3MoXCJjb252NlwiKTp2b2lkIDAsY29udjc6bz44P3MoXCJjb252N1wiKTp2b2lkIDAsY29udjg6YShcImNvbnY4XCIpfX1lbHNlIGk9e2NvbnYwOnIoXCJjb252MFwiKSxjb252MTpyKFwiY29udjFcIiksY29udjI6cihcImNvbnYyXCIpLGNvbnYzOnIoXCJjb252M1wiKSxjb252NDpyKFwiY29udjRcIiksY29udjU6cihcImNvbnY1XCIpLGNvbnY2OnIoXCJjb252NlwiKSxjb252NzpyKFwiY29udjdcIiksY29udjg6YShcImNvbnY4XCIpfTtyZXR1cm4gX24oZSxuKSx7cGFyYW1zOmkscGFyYW1NYXBwaW5nczpufX12YXIgeXI9Y2xhc3N7Y29uc3RydWN0b3Ioe2lucHV0U2l6ZTp0LHNjb3JlVGhyZXNob2xkOm59PXt9KXt0aGlzLl9uYW1lPVwiVGlueVlvbG92Mk9wdGlvbnNcIjtpZih0aGlzLl9pbnB1dFNpemU9dHx8NDE2LHRoaXMuX3Njb3JlVGhyZXNob2xkPW58fC41LHR5cGVvZiB0aGlzLl9pbnB1dFNpemUhPVwibnVtYmVyXCJ8fHRoaXMuX2lucHV0U2l6ZSUzMiE9PTApdGhyb3cgbmV3IEVycm9yKGAke3RoaXMuX25hbWV9IC0gZXhwZWN0ZWQgaW5wdXRTaXplIHRvIGJlIGEgbnVtYmVyIGRpdmlzaWJsZSBieSAzMmApO2lmKHR5cGVvZiB0aGlzLl9zY29yZVRocmVzaG9sZCE9XCJudW1iZXJcInx8dGhpcy5fc2NvcmVUaHJlc2hvbGQ8PTB8fHRoaXMuX3Njb3JlVGhyZXNob2xkPj0xKXRocm93IG5ldyBFcnJvcihgJHt0aGlzLl9uYW1lfSAtIGV4cGVjdGVkIHNjb3JlVGhyZXNob2xkIHRvIGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMWApfWdldCBpbnB1dFNpemUoKXtyZXR1cm4gdGhpcy5faW5wdXRTaXplfWdldCBzY29yZVRocmVzaG9sZCgpe3JldHVybiB0aGlzLl9zY29yZVRocmVzaG9sZH19O3ZhciBtZz1jbGFzcyBtZyBleHRlbmRzIGZue2NvbnN0cnVjdG9yKHQpe3N1cGVyKFwiVGlueVlvbG92MlwiKSxERCh0KSx0aGlzLl9jb25maWc9dH1nZXQgY29uZmlnKCl7cmV0dXJuIHRoaXMuX2NvbmZpZ31nZXQgd2l0aENsYXNzU2NvcmVzKCl7cmV0dXJuIHRoaXMuY29uZmlnLndpdGhDbGFzc1Njb3Jlc3x8dGhpcy5jb25maWcuY2xhc3Nlcy5sZW5ndGg+MX1nZXQgYm94RW5jb2RpbmdTaXplKCl7cmV0dXJuIDUrKHRoaXMud2l0aENsYXNzU2NvcmVzP3RoaXMuY29uZmlnLmNsYXNzZXMubGVuZ3RoOjApfXJ1blRpbnlZb2xvdjIodCxuKXtsZXQgYT1Ccih0LG4uY29udjApO3JldHVybiBhPUR0KGEsWzIsMl0sWzIsMl0sXCJzYW1lXCIpLGE9QnIoYSxuLmNvbnYxKSxhPUR0KGEsWzIsMl0sWzIsMl0sXCJzYW1lXCIpLGE9QnIoYSxuLmNvbnYyKSxhPUR0KGEsWzIsMl0sWzIsMl0sXCJzYW1lXCIpLGE9QnIoYSxuLmNvbnYzKSxhPUR0KGEsWzIsMl0sWzIsMl0sXCJzYW1lXCIpLGE9QnIoYSxuLmNvbnY0KSxhPUR0KGEsWzIsMl0sWzIsMl0sXCJzYW1lXCIpLGE9QnIoYSxuLmNvbnY1KSxhPUR0KGEsWzIsMl0sWzEsMV0sXCJzYW1lXCIpLGE9QnIoYSxuLmNvbnY2KSxhPUJyKGEsbi5jb252NyksaWwoYSxuLmNvbnY4LFwidmFsaWRcIiwhMSl9cnVuTW9iaWxlbmV0KHQsbil7bGV0IGE9dGhpcy5jb25maWcuaXNGaXJzdExheWVyQ29udjJkP01wKGlsKHQsbi5jb252MCxcInZhbGlkXCIsITEpKTpWcih0LG4uY29udjApO3JldHVybiBhPUR0KGEsWzIsMl0sWzIsMl0sXCJzYW1lXCIpLGE9VnIoYSxuLmNvbnYxKSxhPUR0KGEsWzIsMl0sWzIsMl0sXCJzYW1lXCIpLGE9VnIoYSxuLmNvbnYyKSxhPUR0KGEsWzIsMl0sWzIsMl0sXCJzYW1lXCIpLGE9VnIoYSxuLmNvbnYzKSxhPUR0KGEsWzIsMl0sWzIsMl0sXCJzYW1lXCIpLGE9VnIoYSxuLmNvbnY0KSxhPUR0KGEsWzIsMl0sWzIsMl0sXCJzYW1lXCIpLGE9VnIoYSxuLmNvbnY1KSxhPUR0KGEsWzIsMl0sWzEsMV0sXCJzYW1lXCIpLGE9bi5jb252Nj9WcihhLG4uY29udjYpOmEsYT1uLmNvbnY3P1ZyKGEsbi5jb252Nyk6YSxpbChhLG4uY29udjgsXCJ2YWxpZFwiLCExKX1mb3J3YXJkSW5wdXQodCxuKXtsZXR7cGFyYW1zOmF9PXRoaXM7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiVGlueVlvbG92MiAtIGxvYWQgbW9kZWwgYmVmb3JlIGluZmVyZW5jZVwiKTtyZXR1cm4gTygoKT0+e2xldCByPXJlKHQudG9CYXRjaFRlbnNvcihuLCExKSxcImZsb2F0MzJcIik7cmV0dXJuIHI9dGhpcy5jb25maWcubWVhblJnYj9icihyLHRoaXMuY29uZmlnLm1lYW5SZ2IpOnIscj1yLmRpdigyNTUpLHRoaXMuY29uZmlnLndpdGhTZXBhcmFibGVDb252cz90aGlzLnJ1bk1vYmlsZW5ldChyLGEpOnRoaXMucnVuVGlueVlvbG92MihyLGEpfSl9YXN5bmMgZm9yd2FyZCh0LG4pe3JldHVybiB0aGlzLmZvcndhcmRJbnB1dChhd2FpdCB2dCh0KSxuKX1hc3luYyBkZXRlY3QodCxuPXt9KXtsZXR7aW5wdXRTaXplOmEsc2NvcmVUaHJlc2hvbGQ6cn09bmV3IHlyKG4pLHM9YXdhaXQgdnQodCksaT1hd2FpdCB0aGlzLmZvcndhcmRJbnB1dChzLGEpLG89TygoKT0+ZHQoaSlbMF0uZXhwYW5kRGltcygpKSxsPXt3aWR0aDpzLmdldElucHV0V2lkdGgoMCksaGVpZ2h0OnMuZ2V0SW5wdXRIZWlnaHQoMCl9LHU9YXdhaXQgdGhpcy5leHRyYWN0Qm94ZXMobyxzLmdldFJlc2hhcGVkSW5wdXREaW1lbnNpb25zKDApLHIpO2kuZGlzcG9zZSgpLG8uZGlzcG9zZSgpO2xldCBwPXUubWFwKGc9PmcuYm94KSxkPXUubWFwKGc9Pmcuc2NvcmUpLGM9dS5tYXAoZz0+Zy5jbGFzc1Njb3JlKSxoPXUubWFwKGc9PnRoaXMuY29uZmlnLmNsYXNzZXNbZy5sYWJlbF0pO3JldHVybiBVJChwLm1hcChnPT5nLnJlc2NhbGUoYSkpLGQsdGhpcy5jb25maWcuaW91VGhyZXNob2xkLCEwKS5tYXAoZz0+bmV3IHlwKGRbZ10sY1tnXSxoW2ddLHBbZ10sbCkpfWdldERlZmF1bHRNb2RlbE5hbWUoKXtyZXR1cm5cIlwifWV4dHJhY3RQYXJhbXNGcm9tV2VpZ2h0TWFwKHQpe3JldHVybiBNRCh0LHRoaXMuY29uZmlnKX1leHRyYWN0UGFyYW1zKHQpe2xldCBuPXRoaXMuY29uZmlnLmZpbHRlclNpemVzfHxtZy5ERUZBVUxUX0ZJTFRFUl9TSVpFUyxhPW4/bi5sZW5ndGg6dm9pZCAwO2lmKGEhPT03JiZhIT09OCYmYSE9PTkpdGhyb3cgbmV3IEVycm9yKGBUaW55WW9sb3YyIC0gZXhwZWN0ZWQgNyB8IDggfCA5IGNvbnZvbHV0aW9uYWwgZmlsdGVycywgYnV0IGZvdW5kICR7YX0gZmlsdGVyU2l6ZXMgaW4gY29uZmlnYCk7cmV0dXJuIFJEKHQsdGhpcy5jb25maWcsdGhpcy5ib3hFbmNvZGluZ1NpemUsbil9YXN5bmMgZXh0cmFjdEJveGVzKHQsbixhKXtsZXR7d2lkdGg6cixoZWlnaHQ6c309bixpPU1hdGgubWF4KHIscyksbz1pL3IsbD1pL3MsdT10LnNoYXBlWzFdLHA9dGhpcy5jb25maWcuYW5jaG9ycy5sZW5ndGgsW2QsYyxoXT1PKCgpPT57bGV0IGI9dC5yZXNoYXBlKFt1LHUscCx0aGlzLmJveEVuY29kaW5nU2l6ZV0pLHk9Yi5zbGljZShbMCwwLDAsMF0sW3UsdSxwLDRdKSx4PWIuc2xpY2UoWzAsMCwwLDRdLFt1LHUscCwxXSksdj10aGlzLndpdGhDbGFzc1Njb3Jlcz9xYShiLnNsaWNlKFswLDAsMCw1XSxbdSx1LHAsdGhpcy5jb25maWcuY2xhc3Nlcy5sZW5ndGhdKSwzKTp4ZSgwKTtyZXR1cm5beSx4LHZdfSksbT1bXSxmPWF3YWl0IGMuYXJyYXkoKSxnPWF3YWl0IGQuYXJyYXkoKTtmb3IobGV0IGI9MDtiPHU7YisrKWZvcihsZXQgeT0wO3k8dTt5KyspZm9yKGxldCB4PTA7eDxwO3grKyl7bGV0IHY9cWYoZltiXVt5XVt4XVswXSk7aWYoIWF8fHY+YSl7bGV0IEk9KHkrcWYoZ1tiXVt5XVt4XVswXSkpL3UqbyxOPShiK3FmKGdbYl1beV1beF1bMV0pKS91KmwsQz1NYXRoLmV4cChnW2JdW3ldW3hdWzJdKSp0aGlzLmNvbmZpZy5hbmNob3JzW3hdLngvdSpvLF89TWF0aC5leHAoZ1tiXVt5XVt4XVszXSkqdGhpcy5jb25maWcuYW5jaG9yc1t4XS55L3UqbCxGPUktQy8yLEQ9Ti1fLzIsJD17cm93OmIsY29sOnksYW5jaG9yOnh9LHtjbGFzc1Njb3JlOlMsbGFiZWw6TX09dGhpcy53aXRoQ2xhc3NTY29yZXM/YXdhaXQgdGhpcy5leHRyYWN0UHJlZGljdGVkQ2xhc3MoaCwkKTp7Y2xhc3NTY29yZToxLGxhYmVsOjB9O20ucHVzaCh7Ym94Om5ldyBicChGLEQsRitDLEQrXyksc2NvcmU6dixjbGFzc1Njb3JlOnYqUyxsYWJlbDpNLC4uLiR9KX19cmV0dXJuIGQuZGlzcG9zZSgpLGMuZGlzcG9zZSgpLGguZGlzcG9zZSgpLG19YXN5bmMgZXh0cmFjdFByZWRpY3RlZENsYXNzKHQsbil7bGV0e3JvdzphLGNvbDpyLGFuY2hvcjpzfT1uLGk9YXdhaXQgdC5hcnJheSgpO3JldHVybiBBcnJheSh0aGlzLmNvbmZpZy5jbGFzc2VzLmxlbmd0aCkuZmlsbCgwKS5tYXAoKG8sbCk9PmlbYV1bcl1bc11bbF0pLm1hcCgobyxsKT0+KHtjbGFzc1Njb3JlOm8sbGFiZWw6bH0pKS5yZWR1Y2UoKG8sbCk9Pm8uY2xhc3NTY29yZT5sLmNsYXNzU2NvcmU/bzpsKX19O21nLkRFRkFVTFRfRklMVEVSX1NJWkVTPVszLDE2LDMyLDY0LDEyOCwyNTYsNTEyLDEwMjQsMTAyNF07dmFyIE9wPW1nO3ZhciBQcD1jbGFzcyBleHRlbmRzIE9we2NvbnN0cnVjdG9yKHQ9ITApe2xldCBuPXt3aXRoU2VwYXJhYmxlQ29udnM6dCxpb3VUaHJlc2hvbGQ6Q0QsY2xhc3NlczpbXCJmYWNlXCJdLC4uLnQ/e2FuY2hvcnM6X0QsbWVhblJnYjpBRH06e2FuY2hvcnM6RUQsd2l0aENsYXNzU2NvcmVzOiEwfX07c3VwZXIobil9Z2V0IHdpdGhTZXBhcmFibGVDb252cygpe3JldHVybiB0aGlzLmNvbmZpZy53aXRoU2VwYXJhYmxlQ29udnN9Z2V0IGFuY2hvcnMoKXtyZXR1cm4gdGhpcy5jb25maWcuYW5jaG9yc31hc3luYyBsb2NhdGVGYWNlcyh0LG4pe3JldHVybihhd2FpdCB0aGlzLmRldGVjdCh0LG4pKS5tYXAocj0+bmV3IEZ0KHIuc2NvcmUsci5yZWxhdGl2ZUJveCx7d2lkdGg6ci5pbWFnZVdpZHRoLGhlaWdodDpyLmltYWdlSGVpZ2h0fSkpfWdldERlZmF1bHRNb2RlbE5hbWUoKXtyZXR1cm4gdGhpcy53aXRoU2VwYXJhYmxlQ29udnM/JEQ6RkR9ZXh0cmFjdFBhcmFtc0Zyb21XZWlnaHRNYXAodCl7cmV0dXJuIHN1cGVyLmV4dHJhY3RQYXJhbXNGcm9tV2VpZ2h0TWFwKHQpfX07ZnVuY3Rpb24gQkVlKGUsdD0hMCl7bGV0IG49bmV3IFBwKHQpO3JldHVybiBuLmV4dHJhY3RXZWlnaHRzKGUpLG59dmFyIGZnPWNsYXNzIGV4dGVuZHMgeXJ7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpO3RoaXMuX25hbWU9XCJUaW55RmFjZURldGVjdG9yT3B0aW9uc1wifX07dmFyIE9hPWNsYXNze2FzeW5jIHRoZW4odCl7cmV0dXJuIHQoYXdhaXQgdGhpcy5ydW4oKSl9YXN5bmMgcnVuKCl7dGhyb3cgbmV3IEVycm9yKFwiQ29tcG9zYWJsZVRhc2sgLSBydW4gaXMgbm90IGltcGxlbWVudGVkXCIpfX07YXN5bmMgZnVuY3Rpb24gdWwoZSx0LG4sYSxyPSh7YWxpZ25lZFJlY3Q6c30pPT5zKXtsZXQgcz1lLm1hcChsPT5GcChsKT9yKGwpOmwuZGV0ZWN0aW9uKSxpPWF8fCh0IGluc3RhbmNlb2YgQ2U/YXdhaXQgTGQodCxzKTphd2FpdCBQZCh0LHMpKSxvPWF3YWl0IG4oaSk7cmV0dXJuIGkuZm9yRWFjaChsPT5sIGluc3RhbmNlb2YgQ2UmJmwuZGlzcG9zZSgpKSxvfWFzeW5jIGZ1bmN0aW9uIExwKGUsdCxuLGEscil7cmV0dXJuIHVsKFtlXSx0LGFzeW5jIHM9Pm4oc1swXSksYSxyKX12YXIgT0Q9LjQsUEQ9W25ldyBIZSgxLjYwMzIzMSwyLjA5NDQ2OCksbmV3IEhlKDYuMDQxMTQzLDcuMDgwMTI2KSxuZXcgSGUoMi44ODI0NTksMy41MTgwNjEpLG5ldyBIZSg0LjI2NjkwNiw1LjE3ODg1NyksbmV3IEhlKDkuMDQxNzY1LDEwLjY2MzA4KV0sTEQ9WzExNy4wMDEsMTE0LjY5Nyw5Ny40MDRdO3ZhciB6cD1jbGFzcyBleHRlbmRzIE9we2NvbnN0cnVjdG9yKCl7bGV0IHQ9e3dpdGhTZXBhcmFibGVDb252czohMCxpb3VUaHJlc2hvbGQ6T0QsY2xhc3NlczpbXCJmYWNlXCJdLGFuY2hvcnM6UEQsbWVhblJnYjpMRCxpc0ZpcnN0TGF5ZXJDb252MmQ6ITAsZmlsdGVyU2l6ZXM6WzMsMTYsMzIsNjQsMTI4LDI1Niw1MTJdfTtzdXBlcih0KX1nZXQgYW5jaG9ycygpe3JldHVybiB0aGlzLmNvbmZpZy5hbmNob3JzfWFzeW5jIGxvY2F0ZUZhY2VzKHQsbil7cmV0dXJuKGF3YWl0IHRoaXMuZGV0ZWN0KHQsbikpLm1hcChyPT5uZXcgRnQoci5zY29yZSxyLnJlbGF0aXZlQm94LHt3aWR0aDpyLmltYWdlV2lkdGgsaGVpZ2h0OnIuaW1hZ2VIZWlnaHR9KSl9Z2V0RGVmYXVsdE1vZGVsTmFtZSgpe3JldHVyblwidGlueV9mYWNlX2RldGVjdG9yX21vZGVsXCJ9ZXh0cmFjdFBhcmFtc0Zyb21XZWlnaHRNYXAodCl7cmV0dXJuIHN1cGVyLmV4dHJhY3RQYXJhbXNGcm9tV2VpZ2h0TWFwKHQpfX07dmFyIHJ0PXtzc2RNb2JpbGVuZXR2MTpuZXcgbGwsdGlueUZhY2VEZXRlY3RvcjpuZXcgenAsdGlueVlvbG92MjpuZXcgUHAsZmFjZUxhbmRtYXJrNjhOZXQ6bmV3IERwLGZhY2VMYW5kbWFyazY4VGlueU5ldDpuZXcgY2csZmFjZVJlY29nbml0aW9uTmV0Om5ldyBScCxmYWNlRXhwcmVzc2lvbk5ldDpuZXcgc2csYWdlR2VuZGVyTmV0Om5ldyB1Z30sY2dlPShlLHQpPT5ydC5zc2RNb2JpbGVuZXR2MS5sb2NhdGVGYWNlcyhlLHQpLGJfZT0oZSx0KT0+cnQudGlueUZhY2VEZXRlY3Rvci5sb2NhdGVGYWNlcyhlLHQpLHlfZT0oZSx0KT0+cnQudGlueVlvbG92Mi5sb2NhdGVGYWNlcyhlLHQpLGRnZT1lPT5ydC5mYWNlTGFuZG1hcms2OE5ldC5kZXRlY3RMYW5kbWFya3MoZSkseF9lPWU9PnJ0LmZhY2VMYW5kbWFyazY4VGlueU5ldC5kZXRlY3RMYW5kbWFya3MoZSksdl9lPWU9PnJ0LmZhY2VSZWNvZ25pdGlvbk5ldC5jb21wdXRlRmFjZURlc2NyaXB0b3IoZSksd19lPWU9PnJ0LmZhY2VFeHByZXNzaW9uTmV0LnByZWRpY3RFeHByZXNzaW9ucyhlKSxrX2U9ZT0+cnQuYWdlR2VuZGVyTmV0LnByZWRpY3RBZ2VBbmRHZW5kZXIoZSksaGdlPWU9PnJ0LnNzZE1vYmlsZW5ldHYxLmxvYWQoZSksSV9lPWU9PnJ0LnRpbnlGYWNlRGV0ZWN0b3IubG9hZChlKSxTX2U9ZT0+cnQudGlueVlvbG92Mi5sb2FkKGUpLE5fZT1lPT5ydC5mYWNlTGFuZG1hcms2OE5ldC5sb2FkKGUpLFRfZT1lPT5ydC5mYWNlTGFuZG1hcms2OFRpbnlOZXQubG9hZChlKSxDX2U9ZT0+cnQuZmFjZVJlY29nbml0aW9uTmV0LmxvYWQoZSksRV9lPWU9PnJ0LmZhY2VFeHByZXNzaW9uTmV0LmxvYWQoZSksX19lPWU9PnJ0LmFnZUdlbmRlck5ldC5sb2FkKGUpLEFfZT1oZ2UsRl9lPWNnZSwkX2U9ZGdlO3ZhciBnZz1jbGFzcyBleHRlbmRzIE9he2NvbnN0cnVjdG9yKG4sYSxyKXtzdXBlcigpO3RoaXMucGFyZW50VGFzaz1uO3RoaXMuaW5wdXQ9YTt0aGlzLmV4dHJhY3RlZEZhY2VzPXJ9fSxwbD1jbGFzcyBleHRlbmRzIGdne2FzeW5jIHJ1bigpe2xldCB0PWF3YWl0IHRoaXMucGFyZW50VGFzayxuPWF3YWl0IHVsKHQsdGhpcy5pbnB1dCxhc3luYyBhPT5Qcm9taXNlLmFsbChhLm1hcChyPT5ydC5mYWNlRXhwcmVzc2lvbk5ldC5wcmVkaWN0RXhwcmVzc2lvbnMocikpKSx0aGlzLmV4dHJhY3RlZEZhY2VzKTtyZXR1cm4gdC5tYXAoKGEscik9Pk5rKGEsbltyXSkpfXdpdGhBZ2VBbmRHZW5kZXIoKXtyZXR1cm4gbmV3IGRsKHRoaXMsdGhpcy5pbnB1dCl9fSxjbD1jbGFzcyBleHRlbmRzIGdne2FzeW5jIHJ1bigpe2xldCB0PWF3YWl0IHRoaXMucGFyZW50VGFzaztpZighdClyZXR1cm47bGV0IG49YXdhaXQgTHAodCx0aGlzLmlucHV0LGE9PnJ0LmZhY2VFeHByZXNzaW9uTmV0LnByZWRpY3RFeHByZXNzaW9ucyhhKSx0aGlzLmV4dHJhY3RlZEZhY2VzKTtyZXR1cm4gTmsodCxuKX13aXRoQWdlQW5kR2VuZGVyKCl7cmV0dXJuIG5ldyBobCh0aGlzLHRoaXMuaW5wdXQpfX0sUHM9Y2xhc3MgZXh0ZW5kcyBwbHt3aXRoQWdlQW5kR2VuZGVyKCl7cmV0dXJuIG5ldyB6cyh0aGlzLHRoaXMuaW5wdXQpfXdpdGhGYWNlRGVzY3JpcHRvcnMoKXtyZXR1cm4gbmV3IEJzKHRoaXMsdGhpcy5pbnB1dCl9fSxMcz1jbGFzcyBleHRlbmRzIGNse3dpdGhBZ2VBbmRHZW5kZXIoKXtyZXR1cm4gbmV3IFdzKHRoaXMsdGhpcy5pbnB1dCl9d2l0aEZhY2VEZXNjcmlwdG9yKCl7cmV0dXJuIG5ldyBWcyh0aGlzLHRoaXMuaW5wdXQpfX07dmFyIGJnPWNsYXNzIGV4dGVuZHMgT2F7Y29uc3RydWN0b3IobixhLHIpe3N1cGVyKCk7dGhpcy5wYXJlbnRUYXNrPW47dGhpcy5pbnB1dD1hO3RoaXMuZXh0cmFjdGVkRmFjZXM9cn19LGRsPWNsYXNzIGV4dGVuZHMgYmd7YXN5bmMgcnVuKCl7bGV0IHQ9YXdhaXQgdGhpcy5wYXJlbnRUYXNrLG49YXdhaXQgdWwodCx0aGlzLmlucHV0LGFzeW5jIGE9PlByb21pc2UuYWxsKGEubWFwKHI9PnJ0LmFnZUdlbmRlck5ldC5wcmVkaWN0QWdlQW5kR2VuZGVyKHIpKSksdGhpcy5leHRyYWN0ZWRGYWNlcyk7cmV0dXJuIHQubWFwKChhLHIpPT57bGV0e2FnZTpzLGdlbmRlcjppLGdlbmRlclByb2JhYmlsaXR5Om99PW5bcl07cmV0dXJuIEZrKCRrKGEsaSxvKSxzKX0pfXdpdGhGYWNlRXhwcmVzc2lvbnMoKXtyZXR1cm4gbmV3IHBsKHRoaXMsdGhpcy5pbnB1dCl9fSxobD1jbGFzcyBleHRlbmRzIGJne2FzeW5jIHJ1bigpe2xldCB0PWF3YWl0IHRoaXMucGFyZW50VGFzaztpZighdClyZXR1cm47bGV0e2FnZTpuLGdlbmRlcjphLGdlbmRlclByb2JhYmlsaXR5OnJ9PWF3YWl0IExwKHQsdGhpcy5pbnB1dCxzPT5ydC5hZ2VHZW5kZXJOZXQucHJlZGljdEFnZUFuZEdlbmRlcihzKSx0aGlzLmV4dHJhY3RlZEZhY2VzKTtyZXR1cm4gRmsoJGsodCxhLHIpLG4pfXdpdGhGYWNlRXhwcmVzc2lvbnMoKXtyZXR1cm4gbmV3IGNsKHRoaXMsdGhpcy5pbnB1dCl9fSx6cz1jbGFzcyBleHRlbmRzIGRse3dpdGhGYWNlRXhwcmVzc2lvbnMoKXtyZXR1cm4gbmV3IFBzKHRoaXMsdGhpcy5pbnB1dCl9d2l0aEZhY2VEZXNjcmlwdG9ycygpe3JldHVybiBuZXcgQnModGhpcyx0aGlzLmlucHV0KX19LFdzPWNsYXNzIGV4dGVuZHMgaGx7d2l0aEZhY2VFeHByZXNzaW9ucygpe3JldHVybiBuZXcgTHModGhpcyx0aGlzLmlucHV0KX13aXRoRmFjZURlc2NyaXB0b3IoKXtyZXR1cm4gbmV3IFZzKHRoaXMsdGhpcy5pbnB1dCl9fTt2YXIgeWc9Y2xhc3MgZXh0ZW5kcyBPYXtjb25zdHJ1Y3RvcihuLGEpe3N1cGVyKCk7dGhpcy5wYXJlbnRUYXNrPW47dGhpcy5pbnB1dD1hfX0sQnM9Y2xhc3MgZXh0ZW5kcyB5Z3thc3luYyBydW4oKXtsZXQgdD1hd2FpdCB0aGlzLnBhcmVudFRhc2s7cmV0dXJuKGF3YWl0IHVsKHQsdGhpcy5pbnB1dCxhPT5Qcm9taXNlLmFsbChhLm1hcChyPT5ydC5mYWNlUmVjb2duaXRpb25OZXQuY29tcHV0ZUZhY2VEZXNjcmlwdG9yKHIpKSksbnVsbCxhPT5hLmxhbmRtYXJrcy5hbGlnbihudWxsLHt1c2VEbGliQWxpZ25tZW50OiEwfSkpKS5tYXAoKGEscik9PkFrKHRbcl0sYSkpfXdpdGhGYWNlRXhwcmVzc2lvbnMoKXtyZXR1cm4gbmV3IFBzKHRoaXMsdGhpcy5pbnB1dCl9d2l0aEFnZUFuZEdlbmRlcigpe3JldHVybiBuZXcgenModGhpcyx0aGlzLmlucHV0KX19LFZzPWNsYXNzIGV4dGVuZHMgeWd7YXN5bmMgcnVuKCl7bGV0IHQ9YXdhaXQgdGhpcy5wYXJlbnRUYXNrO2lmKCF0KXJldHVybjtsZXQgbj1hd2FpdCBMcCh0LHRoaXMuaW5wdXQsYT0+cnQuZmFjZVJlY29nbml0aW9uTmV0LmNvbXB1dGVGYWNlRGVzY3JpcHRvcihhKSxudWxsLGE9PmEubGFuZG1hcmtzLmFsaWduKG51bGwse3VzZURsaWJBbGlnbm1lbnQ6ITB9KSk7cmV0dXJuIEFrKHQsbil9d2l0aEZhY2VFeHByZXNzaW9ucygpe3JldHVybiBuZXcgTHModGhpcyx0aGlzLmlucHV0KX13aXRoQWdlQW5kR2VuZGVyKCl7cmV0dXJuIG5ldyBXcyh0aGlzLHRoaXMuaW5wdXQpfX07dmFyIHhnPWNsYXNzIGV4dGVuZHMgT2F7Y29uc3RydWN0b3IobixhLHIpe3N1cGVyKCk7dGhpcy5wYXJlbnRUYXNrPW47dGhpcy5pbnB1dD1hO3RoaXMudXNlVGlueUxhbmRtYXJrTmV0PXJ9Z2V0IGxhbmRtYXJrTmV0KCl7cmV0dXJuIHRoaXMudXNlVGlueUxhbmRtYXJrTmV0P3J0LmZhY2VMYW5kbWFyazY4VGlueU5ldDpydC5mYWNlTGFuZG1hcms2OE5ldH19LHZnPWNsYXNzIGV4dGVuZHMgeGd7YXN5bmMgcnVuKCl7bGV0IHQ9YXdhaXQgdGhpcy5wYXJlbnRUYXNrLG49dC5tYXAoaT0+aS5kZXRlY3Rpb24pLGE9dGhpcy5pbnB1dCBpbnN0YW5jZW9mIENlP2F3YWl0IExkKHRoaXMuaW5wdXQsbik6YXdhaXQgUGQodGhpcy5pbnB1dCxuKSxyPWF3YWl0IFByb21pc2UuYWxsKGEubWFwKGk9PnRoaXMubGFuZG1hcmtOZXQuZGV0ZWN0TGFuZG1hcmtzKGkpKSk7cmV0dXJuIGEuZm9yRWFjaChpPT5pIGluc3RhbmNlb2YgQ2UmJmkuZGlzcG9zZSgpKSx0LmZpbHRlcigoaSxvKT0+cltvXSkubWFwKChpLG8pPT5WZChpLHJbb10pKX13aXRoRmFjZUV4cHJlc3Npb25zKCl7cmV0dXJuIG5ldyBQcyh0aGlzLHRoaXMuaW5wdXQpfXdpdGhBZ2VBbmRHZW5kZXIoKXtyZXR1cm4gbmV3IHpzKHRoaXMsdGhpcy5pbnB1dCl9d2l0aEZhY2VEZXNjcmlwdG9ycygpe3JldHVybiBuZXcgQnModGhpcyx0aGlzLmlucHV0KX19LHdnPWNsYXNzIGV4dGVuZHMgeGd7YXN5bmMgcnVuKCl7bGV0IHQ9YXdhaXQgdGhpcy5wYXJlbnRUYXNrO2lmKCF0KXJldHVybjtsZXR7ZGV0ZWN0aW9uOm59PXQsYT10aGlzLmlucHV0IGluc3RhbmNlb2YgQ2U/YXdhaXQgTGQodGhpcy5pbnB1dCxbbl0pOmF3YWl0IFBkKHRoaXMuaW5wdXQsW25dKSxyPWF3YWl0IHRoaXMubGFuZG1hcmtOZXQuZGV0ZWN0TGFuZG1hcmtzKGFbMF0pO3JldHVybiBhLmZvckVhY2gocz0+cyBpbnN0YW5jZW9mIENlJiZzLmRpc3Bvc2UoKSksVmQodCxyKX13aXRoRmFjZUV4cHJlc3Npb25zKCl7cmV0dXJuIG5ldyBMcyh0aGlzLHRoaXMuaW5wdXQpfXdpdGhBZ2VBbmRHZW5kZXIoKXtyZXR1cm4gbmV3IFdzKHRoaXMsdGhpcy5pbnB1dCl9d2l0aEZhY2VEZXNjcmlwdG9yKCl7cmV0dXJuIG5ldyBWcyh0aGlzLHRoaXMuaW5wdXQpfX07dmFyIGtnPWNsYXNzIGV4dGVuZHMgT2F7Y29uc3RydWN0b3IobixhPW5ldyBNYSl7c3VwZXIoKTt0aGlzLmlucHV0PW47dGhpcy5vcHRpb25zPWF9fSxHZD1jbGFzcyBleHRlbmRzIGtne2FzeW5jIHJ1bigpe2xldHtpbnB1dDp0LG9wdGlvbnM6bn09dGhpcyxhO2lmKG4gaW5zdGFuY2VvZiBmZylhPXJ0LnRpbnlGYWNlRGV0ZWN0b3IubG9jYXRlRmFjZXModCxuKTtlbHNlIGlmKG4gaW5zdGFuY2VvZiBNYSlhPXJ0LnNzZE1vYmlsZW5ldHYxLmxvY2F0ZUZhY2VzKHQsbik7ZWxzZSBpZihuIGluc3RhbmNlb2YgeXIpYT1ydC50aW55WW9sb3YyLmxvY2F0ZUZhY2VzKHQsbik7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJkZXRlY3RGYWNlcyAtIGV4cGVjdGVkIG9wdGlvbnMgdG8gYmUgaW5zdGFuY2Ugb2YgVGlueUZhY2VEZXRlY3Rvck9wdGlvbnMgfCBTc2RNb2JpbGVuZXR2MU9wdGlvbnMgfCBUaW55WW9sb3YyT3B0aW9uc1wiKTtyZXR1cm4gYX1ydW5BbmRFeHRlbmRXaXRoRmFjZURldGVjdGlvbnMoKXtyZXR1cm4gbmV3IFByb21pc2UoKHQsbik9Pnt0aGlzLnJ1bigpLnRoZW4oYT0+dChhLm1hcChyPT53cCh7fSxyKSkpKS5jYXRjaChhPT5uKGEpKX0pfXdpdGhGYWNlTGFuZG1hcmtzKHQ9ITEpe3JldHVybiBuZXcgdmcodGhpcy5ydW5BbmRFeHRlbmRXaXRoRmFjZURldGVjdGlvbnMoKSx0aGlzLmlucHV0LHQpfXdpdGhGYWNlRXhwcmVzc2lvbnMoKXtyZXR1cm4gbmV3IHBsKHRoaXMucnVuQW5kRXh0ZW5kV2l0aEZhY2VEZXRlY3Rpb25zKCksdGhpcy5pbnB1dCl9d2l0aEFnZUFuZEdlbmRlcigpe3JldHVybiBuZXcgZGwodGhpcy5ydW5BbmRFeHRlbmRXaXRoRmFjZURldGVjdGlvbnMoKSx0aGlzLmlucHV0KX19LElnPWNsYXNzIGV4dGVuZHMga2d7YXN5bmMgcnVuKCl7bGV0IHQ9YXdhaXQgbmV3IEdkKHRoaXMuaW5wdXQsdGhpcy5vcHRpb25zKSxuPXRbMF07cmV0dXJuIHQuZm9yRWFjaChhPT57YS5zY29yZT5uLnNjb3JlJiYobj1hKX0pLG59cnVuQW5kRXh0ZW5kV2l0aEZhY2VEZXRlY3Rpb24oKXtyZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgdD0+e2xldCBuPWF3YWl0IHRoaXMucnVuKCk7dChuP3dwKHt9LG4pOnZvaWQgMCl9KX13aXRoRmFjZUxhbmRtYXJrcyh0PSExKXtyZXR1cm4gbmV3IHdnKHRoaXMucnVuQW5kRXh0ZW5kV2l0aEZhY2VEZXRlY3Rpb24oKSx0aGlzLmlucHV0LHQpfXdpdGhGYWNlRXhwcmVzc2lvbnMoKXtyZXR1cm4gbmV3IGNsKHRoaXMucnVuQW5kRXh0ZW5kV2l0aEZhY2VEZXRlY3Rpb24oKSx0aGlzLmlucHV0KX13aXRoQWdlQW5kR2VuZGVyKCl7cmV0dXJuIG5ldyBobCh0aGlzLnJ1bkFuZEV4dGVuZFdpdGhGYWNlRGV0ZWN0aW9uKCksdGhpcy5pbnB1dCl9fTtmdW5jdGlvbiBfQWUoZSx0PW5ldyBNYSl7cmV0dXJuIG5ldyBJZyhlLHQpfWZ1bmN0aW9uIERrKGUsdD1uZXcgTWEpe3JldHVybiBuZXcgR2QoZSx0KX1hc3luYyBmdW5jdGlvbiBtZ2UoZSx0KXtyZXR1cm4gRGsoZSxuZXcgTWEodD97bWluQ29uZmlkZW5jZTp0fTp7fSkpLndpdGhGYWNlTGFuZG1hcmtzKCkud2l0aEZhY2VEZXNjcmlwdG9ycygpfWFzeW5jIGZ1bmN0aW9uIE1BZShlLHQ9e30pe3JldHVybiBEayhlLG5ldyB5cih0KSkud2l0aEZhY2VMYW5kbWFya3MoKS53aXRoRmFjZURlc2NyaXB0b3JzKCl9dmFyIE9BZT1tZ2U7ZnVuY3Rpb24gekQoZSx0KXtpZihlLmxlbmd0aCE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImV1Y2xpZGVhbkRpc3RhbmNlOiBhcnIxLmxlbmd0aCAhPT0gYXJyMi5sZW5ndGhcIik7bGV0IG49QXJyYXkuZnJvbShlKSxhPUFycmF5LmZyb20odCk7cmV0dXJuIE1hdGguc3FydChuLm1hcCgocixzKT0+ci1hW3NdKS5yZWR1Y2UoKHIscyk9PnIrcypzLDApKX12YXIgV0Q9Y2xhc3MgZXtjb25zdHJ1Y3Rvcih0LG49LjYpe3RoaXMuX2Rpc3RhbmNlVGhyZXNob2xkPW47bGV0IGE9QXJyYXkuaXNBcnJheSh0KT90Olt0XTtpZighYS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRmFjZVJlY29nbml6ZXIuY29uc3RydWN0b3IgLSBleHBlY3RlZCBhdGxlYXN0IG9uZSBpbnB1dFwiKTtsZXQgcj0xLHM9KCk9PmBwZXJzb24gJHtyKyt9YDt0aGlzLl9sYWJlbGVkRGVzY3JpcHRvcnM9YS5tYXAoaT0+e2lmKGkgaW5zdGFuY2VvZiBybClyZXR1cm4gaTtpZihpIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KXJldHVybiBuZXcgcmwocygpLFtpXSk7aWYoaS5kZXNjcmlwdG9yJiZpLmRlc2NyaXB0b3IgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpcmV0dXJuIG5ldyBybChzKCksW2kuZGVzY3JpcHRvcl0pO3Rocm93IG5ldyBFcnJvcihcIkZhY2VSZWNvZ25pemVyLmNvbnN0cnVjdG9yIC0gZXhwZWN0ZWQgaW5wdXRzIHRvIGJlIG9mIHR5cGUgTGFiZWxlZEZhY2VEZXNjcmlwdG9ycyB8IFdpdGhGYWNlRGVzY3JpcHRvcjxhbnk+IHwgRmxvYXQzMkFycmF5IHwgQXJyYXk8TGFiZWxlZEZhY2VEZXNjcmlwdG9ycyB8IFdpdGhGYWNlRGVzY3JpcHRvcjxhbnk+IHwgRmxvYXQzMkFycmF5PlwiKX0pfWdldCBsYWJlbGVkRGVzY3JpcHRvcnMoKXtyZXR1cm4gdGhpcy5fbGFiZWxlZERlc2NyaXB0b3JzfWdldCBkaXN0YW5jZVRocmVzaG9sZCgpe3JldHVybiB0aGlzLl9kaXN0YW5jZVRocmVzaG9sZH1jb21wdXRlTWVhbkRpc3RhbmNlKHQsbil7cmV0dXJuIG4ubWFwKGE9PnpEKGEsdCkpLnJlZHVjZSgoYSxyKT0+YStyLDApLyhuLmxlbmd0aHx8MSl9bWF0Y2hEZXNjcmlwdG9yKHQpe3JldHVybiB0aGlzLmxhYmVsZWREZXNjcmlwdG9ycy5tYXAoKHtkZXNjcmlwdG9yczpuLGxhYmVsOmF9KT0+bmV3IERkKGEsdGhpcy5jb21wdXRlTWVhbkRpc3RhbmNlKHQsbikpKS5yZWR1Y2UoKG4sYSk9Pm4uZGlzdGFuY2U8YS5kaXN0YW5jZT9uOmEpfWZpbmRCZXN0TWF0Y2godCl7bGV0IG49dGhpcy5tYXRjaERlc2NyaXB0b3IodCk7cmV0dXJuIG4uZGlzdGFuY2U8dGhpcy5fZGlzdGFuY2VUaHJlc2hvbGQ/bjpuZXcgRGQoXCJ1bmtub3duXCIsbi5kaXN0YW5jZSl9dG9KU09OKCl7cmV0dXJue2Rpc3RhbmNlVGhyZXNob2xkOnRoaXMuX2Rpc3RhbmNlVGhyZXNob2xkLGxhYmVsZWREZXNjcmlwdG9yczp0aGlzLl9sYWJlbGVkRGVzY3JpcHRvcnMubWFwKHQ9PnQudG9KU09OKCkpfX1zdGF0aWMgZnJvbUpTT04odCl7bGV0IG49dC5sYWJlbGVkRGVzY3JpcHRvcnMubWFwKGE9PnJsLmZyb21KU09OKGEpKTtyZXR1cm4gbmV3IGUobix0LmRpc3RhbmNlVGhyZXNob2xkKX19O2Z1bmN0aW9uIGVGZShlKXtsZXQgdD1uZXcgenA7cmV0dXJuIHQuZXh0cmFjdFdlaWdodHMoZSksdH1mdW5jdGlvbiBmZ2UoZSx0KXtsZXR7d2lkdGg6bixoZWlnaHQ6YX09bmV3IGFhKHQud2lkdGgsdC5oZWlnaHQpO2lmKG48PTB8fGE8PTApdGhyb3cgbmV3IEVycm9yKGByZXNpemVSZXN1bHRzIC0gaW52YWxpZCBkaW1lbnNpb25zOiAke0pTT04uc3RyaW5naWZ5KHt3aWR0aDpuLGhlaWdodDphfSl9YCk7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZS5tYXAocj0+ZmdlKHIse3dpZHRoOm4saGVpZ2h0OmF9KSk7aWYoRnAoZSkpe2xldCByPWUuZGV0ZWN0aW9uLmZvclNpemUobixhKSxzPWUudW5zaGlmdGVkTGFuZG1hcmtzLmZvclNpemUoci5ib3gud2lkdGgsci5ib3guaGVpZ2h0KTtyZXR1cm4gVmQod3AoZSxyKSxzKX1yZXR1cm4genIoZSk/d3AoZSxlLmRldGVjdGlvbi5mb3JTaXplKG4sYSkpOmUgaW5zdGFuY2VvZiBrYXx8ZSBpbnN0YW5jZW9mIEZ0P2UuZm9yU2l6ZShuLGEpOmV9dmFyIGNGZT1vRDtleHBvcnR7dWcgYXMgQWdlR2VuZGVyTmV0LGJwIGFzIEJvdW5kaW5nQm94LG1uIGFzIEJveCxPYSBhcyBDb21wb3NhYmxlVGFzayxCcyBhcyBDb21wdXRlQWxsRmFjZURlc2NyaXB0b3JzVGFzayx5ZyBhcyBDb21wdXRlRmFjZURlc2NyaXB0b3JzVGFza0Jhc2UsVnMgYXMgQ29tcHV0ZVNpbmdsZUZhY2VEZXNjcmlwdG9yVGFzayx2ZyBhcyBEZXRlY3RBbGxGYWNlTGFuZG1hcmtzVGFzayxHZCBhcyBEZXRlY3RBbGxGYWNlc1Rhc2sseGcgYXMgRGV0ZWN0RmFjZUxhbmRtYXJrc1Rhc2tCYXNlLGtnIGFzIERldGVjdEZhY2VzVGFza0Jhc2Usd2cgYXMgRGV0ZWN0U2luZ2xlRmFjZUxhbmRtYXJrc1Rhc2ssSWcgYXMgRGV0ZWN0U2luZ2xlRmFjZVRhc2ssYWEgYXMgRGltZW5zaW9ucyxyRCBhcyBGQUNFX0VYUFJFU1NJT05fTEFCRUxTLEZ0IGFzIEZhY2VEZXRlY3Rpb24sVEQgYXMgRmFjZURldGVjdGlvbk5ldCxzZyBhcyBGYWNlRXhwcmVzc2lvbk5ldCxPcyBhcyBGYWNlRXhwcmVzc2lvbnMsRHAgYXMgRmFjZUxhbmRtYXJrNjhOZXQsY2cgYXMgRmFjZUxhbmRtYXJrNjhUaW55TmV0LGZEIGFzIEZhY2VMYW5kbWFya05ldCxrYSBhcyBGYWNlTGFuZG1hcmtzLEgkIGFzIEZhY2VMYW5kbWFya3M1LHZwIGFzIEZhY2VMYW5kbWFya3M2OCxEZCBhcyBGYWNlTWF0Y2gsV0QgYXMgRmFjZU1hdGNoZXIsUnAgYXMgRmFjZVJlY29nbml0aW9uTmV0LENrIGFzIEdlbmRlcixSZCBhcyBMYWJlbGVkQm94LHJsIGFzIExhYmVsZWRGYWNlRGVzY3JpcHRvcnMsV3IgYXMgTmV0SW5wdXQsZm4gYXMgTmV1cmFsTmV0d29yayx5cCBhcyBPYmplY3REZXRlY3Rpb24sSGUgYXMgUG9pbnQsaiQgYXMgUHJlZGljdGVkQm94LHhwIGFzIFJlY3QsbGwgYXMgU3NkTW9iaWxlbmV0djEsTWEgYXMgU3NkTW9iaWxlbmV0djFPcHRpb25zLHpwIGFzIFRpbnlGYWNlRGV0ZWN0b3IsZmcgYXMgVGlueUZhY2VEZXRlY3Rvck9wdGlvbnMsUHAgYXMgVGlueVlvbG92Mix5ciBhcyBUaW55WW9sb3YyT3B0aW9ucyxPQWUgYXMgYWxsRmFjZXMsbWdlIGFzIGFsbEZhY2VzU3NkTW9iaWxlbmV0djEsTUFlIGFzIGFsbEZhY2VzVGlueVlvbG92MixxJCBhcyBhd2FpdE1lZGlhTG9hZGVkLEskIGFzIGJ1ZmZlclRvSW1hZ2Usdl9lIGFzIGNvbXB1dGVGYWNlRGVzY3JpcHRvcixOcCBhcyBjcmVhdGVDYW52YXMsWmYgYXMgY3JlYXRlQ2FudmFzRnJvbU1lZGlhLFlDZSBhcyBjcmVhdGVGYWNlRGV0ZWN0aW9uTmV0LFkyZSBhcyBjcmVhdGVGYWNlUmVjb2duaXRpb25OZXQsbGdlIGFzIGNyZWF0ZVNzZE1vYmlsZW5ldHYxLGVGZSBhcyBjcmVhdGVUaW55RmFjZURldGVjdG9yLEJFZSBhcyBjcmVhdGVUaW55WW9sb3YyLERrIGFzIGRldGVjdEFsbEZhY2VzLGRnZSBhcyBkZXRlY3RGYWNlTGFuZG1hcmtzLHhfZSBhcyBkZXRlY3RGYWNlTGFuZG1hcmtzVGlueSwkX2UgYXMgZGV0ZWN0TGFuZG1hcmtzLF9BZSBhcyBkZXRlY3RTaW5nbGVGYWNlLGlEIGFzIGRyYXcsYXQgYXMgZW52LHpEIGFzIGV1Y2xpZGVhbkRpc3RhbmNlLEZrIGFzIGV4dGVuZFdpdGhBZ2UsQWsgYXMgZXh0ZW5kV2l0aEZhY2VEZXNjcmlwdG9yLHdwIGFzIGV4dGVuZFdpdGhGYWNlRGV0ZWN0aW9uLE5rIGFzIGV4dGVuZFdpdGhGYWNlRXhwcmVzc2lvbnMsVmQgYXMgZXh0ZW5kV2l0aEZhY2VMYW5kbWFya3MsJGsgYXMgZXh0ZW5kV2l0aEdlbmRlcixMZCBhcyBleHRyYWN0RmFjZVRlbnNvcnMsUGQgYXMgZXh0cmFjdEZhY2VzLHNJZSBhcyBmZXRjaEltYWdlLFokIGFzIGZldGNoSnNvbixwSWUgYXMgZmV0Y2hOZXRXZWlnaHRzLE1zIGFzIGZldGNoT3JUaHJvdyxnSWUgYXMgZmV0Y2hWaWRlbyxyYSBhcyBnZXRDb250ZXh0MmRPclRocm93LFNwIGFzIGdldE1lZGlhRGltZW5zaW9ucyxYJCBhcyBpbWFnZVRlbnNvclRvQ2FudmFzLFkkIGFzIGltYWdlVG9TcXVhcmUsdjBlIGFzIGludmVyc2VTaWdtb2lkLEIkIGFzIGlvdSxTayBhcyBpc01lZGlhRWxlbWVudCxZZiBhcyBpc01lZGlhTG9hZGVkLGVDZSBhcyBpc1dpdGhBZ2UsenIgYXMgaXNXaXRoRmFjZURldGVjdGlvbixzRCBhcyBpc1dpdGhGYWNlRXhwcmVzc2lvbnMsRnAgYXMgaXNXaXRoRmFjZUxhbmRtYXJrcyxyQ2UgYXMgaXNXaXRoR2VuZGVyLF9fZSBhcyBsb2FkQWdlR2VuZGVyTW9kZWwsQV9lIGFzIGxvYWRGYWNlRGV0ZWN0aW9uTW9kZWwsRV9lIGFzIGxvYWRGYWNlRXhwcmVzc2lvbk1vZGVsLE5fZSBhcyBsb2FkRmFjZUxhbmRtYXJrTW9kZWwsVF9lIGFzIGxvYWRGYWNlTGFuZG1hcmtUaW55TW9kZWwsQ19lIGFzIGxvYWRGYWNlUmVjb2duaXRpb25Nb2RlbCxoZ2UgYXMgbG9hZFNzZE1vYmlsZW5ldHYxTW9kZWwsSV9lIGFzIGxvYWRUaW55RmFjZURldGVjdG9yTW9kZWwsU19lIGFzIGxvYWRUaW55WW9sb3YyTW9kZWwsUSQgYXMgbG9hZFdlaWdodE1hcCxGX2UgYXMgbG9jYXRlRmFjZXMsSUllIGFzIG1hdGNoRGltZW5zaW9ucyxWJCBhcyBtaW5CYm94LHJ0IGFzIG5ldHMsVSQgYXMgbm9uTWF4U3VwcHJlc3Npb24sYnIgYXMgbm9ybWFsaXplLEckIGFzIHBhZFRvU3F1YXJlLGtfZSBhcyBwcmVkaWN0QWdlQW5kR2VuZGVyLHdfZSBhcyByZWNvZ25pemVGYWNlRXhwcmVzc2lvbnMsZmdlIGFzIHJlc2l6ZVJlc3VsdHMsa3AgYXMgcmVzb2x2ZUlucHV0LHkwZSBhcyBzaHVmZmxlQXJyYXkscWYgYXMgc2lnbW9pZCxjZ2UgYXMgc3NkTW9iaWxlbmV0djEsUGUgYXMgdGYsYl9lIGFzIHRpbnlGYWNlRGV0ZWN0b3IseV9lIGFzIHRpbnlZb2xvdjIsdnQgYXMgdG9OZXRJbnB1dCxXJCBhcyB1dGlscyxERCBhcyB2YWxpZGF0ZUNvbmZpZyxjRmUgYXMgdmVyc2lvbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mYWNlLWFwaS5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/@vladmandic/face-api/dist/face-api.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/announcement/components/FaceDetectorComponent.tsx":
/*!***************************************************************!*\
  !*** ./app/announcement/components/FaceDetectorComponent.tsx ***!
  \***************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FaceDetectorComponent)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_FaceDetector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../lib/FaceDetector */ \"(app-pages-browser)/./lib/FaceDetector.ts\");\n// components/FaceDetectorComponent.tsx\n/* __next_internal_client_entry_do_not_use__ default auto */ var _s = $RefreshSig$();\n\n\nfunction FaceDetectorComponent(param) {\n    let { onFaceEnter, onFaceLeave } = param;\n    _s();\n    const detectorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"FaceDetectorComponent.useEffect\": ()=>{\n            const detector = new _lib_FaceDetector__WEBPACK_IMPORTED_MODULE_1__.FaceDetector({\n                \"FaceDetectorComponent.useEffect\": (faces)=>{\n                    if (faces > 0 && onFaceEnter) onFaceEnter();\n                    else if (faces === 0 && onFaceLeave) onFaceLeave();\n                }\n            }[\"FaceDetectorComponent.useEffect\"]);\n            detector.loadModels(\"/models\").then({\n                \"FaceDetectorComponent.useEffect\": ()=>detector.start()\n            }[\"FaceDetectorComponent.useEffect\"]);\n            detectorRef.current = detector;\n            return ({\n                \"FaceDetectorComponent.useEffect\": ()=>{\n                    var _detectorRef_current;\n                    return (_detectorRef_current = detectorRef.current) === null || _detectorRef_current === void 0 ? void 0 : _detectorRef_current.stop();\n                }\n            })[\"FaceDetectorComponent.useEffect\"];\n        }\n    }[\"FaceDetectorComponent.useEffect\"], [\n        onFaceEnter,\n        onFaceLeave\n    ]);\n    return null; // ไม่ต้อง render UI\n}\n_s(FaceDetectorComponent, \"uwNsnoBQmkG+R+DFW4lJg1hT5DI=\");\n_c = FaceDetectorComponent;\nvar _c;\n$RefreshReg$(_c, \"FaceDetectorComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9hbm5vdW5jZW1lbnQvY29tcG9uZW50cy9GYWNlRGV0ZWN0b3JDb21wb25lbnQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSx1Q0FBdUM7O0FBR0c7QUFDZTtBQU8xQyxTQUFTRyxzQkFBc0IsS0FBbUM7UUFBbkMsRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQVMsR0FBbkM7O0lBQzVDLE1BQU1DLGNBQWNMLDZDQUFNQSxDQUFzQjtJQUVoREQsZ0RBQVNBOzJDQUFDO1lBQ1IsTUFBTU8sV0FBVyxJQUFJTCwyREFBWUE7bURBQUMsQ0FBQ007b0JBQ2pDLElBQUlBLFFBQVEsS0FBS0osYUFBYUE7eUJBQ3pCLElBQUlJLFVBQVUsS0FBS0gsYUFBYUE7Z0JBQ3ZDOztZQUVBRSxTQUFTRSxVQUFVLENBQUMsV0FBV0MsSUFBSTttREFBQyxJQUFNSCxTQUFTSSxLQUFLOztZQUN4REwsWUFBWU0sT0FBTyxHQUFHTDtZQUV0QjttREFBTzt3QkFBTUQ7NEJBQUFBLHVCQUFBQSxZQUFZTSxPQUFPLGNBQW5CTiwyQ0FBQUEscUJBQXFCTyxJQUFJOzs7UUFDeEM7MENBQUc7UUFBQ1Q7UUFBYUM7S0FBWTtJQUU3QixPQUFPLE1BQU0sb0JBQW9CO0FBQ25DO0dBaEJ3QkY7S0FBQUEiLCJzb3VyY2VzIjpbIkQ6XFxOZXh0SnNQcm9qZWN0c1xcc21hcnQtcHJvbW9cXGZyb250ZW5kXFxhcHBcXGFubm91bmNlbWVudFxcY29tcG9uZW50c1xcRmFjZURldGVjdG9yQ29tcG9uZW50LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjb21wb25lbnRzL0ZhY2VEZXRlY3RvckNvbXBvbmVudC50c3hcclxuXCJ1c2UgY2xpZW50XCI7XHJcblxyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyBGYWNlRGV0ZWN0b3IgfSBmcm9tIFwiLi4vLi4vLi4vbGliL0ZhY2VEZXRlY3RvclwiO1xyXG5cclxudHlwZSBQcm9wcyA9IHtcclxuICBvbkZhY2VFbnRlcj86ICgpID0+IHZvaWQ7XHJcbiAgb25GYWNlTGVhdmU/OiAoKSA9PiB2b2lkO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmFjZURldGVjdG9yQ29tcG9uZW50KHsgb25GYWNlRW50ZXIsIG9uRmFjZUxlYXZlIH06IFByb3BzKSB7XHJcbiAgY29uc3QgZGV0ZWN0b3JSZWYgPSB1c2VSZWY8RmFjZURldGVjdG9yIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBkZXRlY3RvciA9IG5ldyBGYWNlRGV0ZWN0b3IoKGZhY2VzKSA9PiB7XHJcbiAgICAgIGlmIChmYWNlcyA+IDAgJiYgb25GYWNlRW50ZXIpIG9uRmFjZUVudGVyKCk7XHJcbiAgICAgIGVsc2UgaWYgKGZhY2VzID09PSAwICYmIG9uRmFjZUxlYXZlKSBvbkZhY2VMZWF2ZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGV0ZWN0b3IubG9hZE1vZGVscyhcIi9tb2RlbHNcIikudGhlbigoKSA9PiBkZXRlY3Rvci5zdGFydCgpKTtcclxuICAgIGRldGVjdG9yUmVmLmN1cnJlbnQgPSBkZXRlY3RvcjtcclxuXHJcbiAgICByZXR1cm4gKCkgPT4gZGV0ZWN0b3JSZWYuY3VycmVudD8uc3RvcCgpO1xyXG4gIH0sIFtvbkZhY2VFbnRlciwgb25GYWNlTGVhdmVdKTtcclxuXHJcbiAgcmV0dXJuIG51bGw7IC8vIOC5hOC4oeC5iOC4leC5ieC4reC4hyByZW5kZXIgVUlcclxufVxyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwiRmFjZURldGVjdG9yIiwiRmFjZURldGVjdG9yQ29tcG9uZW50Iiwib25GYWNlRW50ZXIiLCJvbkZhY2VMZWF2ZSIsImRldGVjdG9yUmVmIiwiZGV0ZWN0b3IiLCJmYWNlcyIsImxvYWRNb2RlbHMiLCJ0aGVuIiwic3RhcnQiLCJjdXJyZW50Iiwic3RvcCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/announcement/components/FaceDetectorComponent.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/FaceDetector.ts":
/*!*****************************!*\
  !*** ./lib/FaceDetector.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FaceDetector: () => (/* binding */ FaceDetector)\n/* harmony export */ });\n/* harmony import */ var _vladmandic_face_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vladmandic/face-api */ \"(app-pages-browser)/../node_modules/@vladmandic/face-api/dist/face-api.esm.js\");\n// lib/FaceDetector.ts\n\nclass FaceDetector {\n    async loadModels() {\n        let path = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"/models\";\n        await _vladmandic_face_api__WEBPACK_IMPORTED_MODULE_0__.nets.tinyFaceDetector.loadFromUri(path);\n    }\n    async start() {\n        this.stream = await navigator.mediaDevices.getUserMedia({\n            video: true\n        });\n        this.video = document.createElement(\"video\");\n        this.video.autoplay = true;\n        this.video.muted = true;\n        this.video.playsInline = true;\n        this.video.srcObject = this.stream;\n        await this.video.play();\n        this.stopped = false;\n        this.detectLoop();\n    }\n    async detectLoop() {\n        if (!this.video || this.stopped) return;\n        const detections = await _vladmandic_face_api__WEBPACK_IMPORTED_MODULE_0__.detectAllFaces(this.video, new _vladmandic_face_api__WEBPACK_IMPORTED_MODULE_0__.TinyFaceDetectorOptions());\n        const faceCount = detections.length;\n        if (faceCount > 0 && this.prevFaceCount === 0) {\n            var _this_callback, _this;\n            (_this_callback = (_this = this).callback) === null || _this_callback === void 0 ? void 0 : _this_callback.call(_this, faceCount); // คนเข้ามา\n        } else if (faceCount === 0 && this.prevFaceCount > 0) {\n            var _this_callback1, _this1;\n            (_this_callback1 = (_this1 = this).callback) === null || _this_callback1 === void 0 ? void 0 : _this_callback1.call(_this1, faceCount); // คนออกไปหมด\n        }\n        this.prevFaceCount = faceCount;\n        requestAnimationFrame(()=>this.detectLoop());\n    }\n    stop() {\n        var _this_video;\n        this.stopped = true;\n        if ((_this_video = this.video) === null || _this_video === void 0 ? void 0 : _this_video.srcObject) {\n            this.video.srcObject.getTracks().forEach((t)=>t.stop());\n        }\n        this.video = null;\n        this.stream = null;\n    }\n    constructor(callback){\n        this.video = null;\n        this.stream = null;\n        this.prevFaceCount = 0;\n        this.stopped = false;\n        this.callback = callback;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9GYWNlRGV0ZWN0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxzQkFBc0I7QUFDMEI7QUFJekMsTUFBTUM7SUFXWCxNQUFNQyxhQUE2QjtZQUFsQkMsT0FBQUEsaUVBQU87UUFDdEIsTUFBTUgsc0RBQVksQ0FBQ0ssZ0JBQWdCLENBQUNDLFdBQVcsQ0FBQ0g7SUFDbEQ7SUFFQSxNQUFNSSxRQUFRO1FBQ1osSUFBSSxDQUFDQyxNQUFNLEdBQUcsTUFBTUMsVUFBVUMsWUFBWSxDQUFDQyxZQUFZLENBQUM7WUFBRUMsT0FBTztRQUFLO1FBQ3RFLElBQUksQ0FBQ0EsS0FBSyxHQUFHQyxTQUFTQyxhQUFhLENBQUM7UUFDcEMsSUFBSSxDQUFDRixLQUFLLENBQUNHLFFBQVEsR0FBRztRQUN0QixJQUFJLENBQUNILEtBQUssQ0FBQ0ksS0FBSyxHQUFHO1FBQ25CLElBQUksQ0FBQ0osS0FBSyxDQUFDSyxXQUFXLEdBQUc7UUFDekIsSUFBSSxDQUFDTCxLQUFLLENBQUNNLFNBQVMsR0FBRyxJQUFJLENBQUNWLE1BQU07UUFFbEMsTUFBTSxJQUFJLENBQUNJLEtBQUssQ0FBQ08sSUFBSTtRQUNyQixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsVUFBVTtJQUNqQjtJQUVBLE1BQWNBLGFBQWE7UUFDekIsSUFBSSxDQUFDLElBQUksQ0FBQ1QsS0FBSyxJQUFJLElBQUksQ0FBQ1EsT0FBTyxFQUFFO1FBRWpDLE1BQU1FLGFBQWEsTUFBTXRCLGdFQUFzQixDQUM3QyxJQUFJLENBQUNZLEtBQUssRUFDVixJQUFJWix5RUFBK0I7UUFHckMsTUFBTXlCLFlBQVlILFdBQVdJLE1BQU07UUFDbkMsSUFBSUQsWUFBWSxLQUFLLElBQUksQ0FBQ0UsYUFBYSxLQUFLLEdBQUc7Z0JBQzdDO2FBQUEsOEJBQUksRUFBQ0MsUUFBUSxjQUFiLGdFQUFnQkgsWUFBWSxXQUFXO1FBQ3pDLE9BQU8sSUFBSUEsY0FBYyxLQUFLLElBQUksQ0FBQ0UsYUFBYSxHQUFHLEdBQUc7Z0JBQ3BEO2FBQUEsZ0NBQUksRUFBQ0MsUUFBUSxjQUFiLG1FQUFnQkgsWUFBWSxhQUFhO1FBQzNDO1FBQ0EsSUFBSSxDQUFDRSxhQUFhLEdBQUdGO1FBRXJCSSxzQkFBc0IsSUFBTSxJQUFJLENBQUNSLFVBQVU7SUFDN0M7SUFFQVMsT0FBTztZQUVEO1FBREosSUFBSSxDQUFDVixPQUFPLEdBQUc7UUFDZixLQUFJLGtCQUFJLENBQUNSLEtBQUssY0FBViw4Q0FBWU0sU0FBUyxFQUFFO1lBQ3hCLElBQUksQ0FBQ04sS0FBSyxDQUFDTSxTQUFTLENBQWlCYSxTQUFTLEdBQUdDLE9BQU8sQ0FBQyxDQUFDQyxJQUFNQSxFQUFFSCxJQUFJO1FBQ3pFO1FBQ0EsSUFBSSxDQUFDbEIsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDSixNQUFNLEdBQUc7SUFDaEI7SUEvQ0EsWUFBWW9CLFFBQStCLENBQUU7YUFOckNoQixRQUFpQzthQUNqQ0osU0FBNkI7YUFFN0JtQixnQkFBZ0I7YUFDaEJQLFVBQVU7UUFHaEIsSUFBSSxDQUFDUSxRQUFRLEdBQUdBO0lBQ2xCO0FBOENGIiwic291cmNlcyI6WyJEOlxcTmV4dEpzUHJvamVjdHNcXHNtYXJ0LXByb21vXFxmcm9udGVuZFxcbGliXFxGYWNlRGV0ZWN0b3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbGliL0ZhY2VEZXRlY3Rvci50c1xyXG5pbXBvcnQgKiBhcyBmYWNlYXBpIGZyb20gXCJAdmxhZG1hbmRpYy9mYWNlLWFwaVwiO1xyXG5cclxudHlwZSBGYWNlRGV0ZWN0b3JDYWxsYmFjayA9IChmYWNlczogbnVtYmVyKSA9PiB2b2lkO1xyXG5cclxuZXhwb3J0IGNsYXNzIEZhY2VEZXRlY3RvciB7XHJcbiAgcHJpdmF0ZSB2aWRlbzogSFRNTFZpZGVvRWxlbWVudCB8IG51bGwgPSBudWxsO1xyXG4gIHByaXZhdGUgc3RyZWFtOiBNZWRpYVN0cmVhbSB8IG51bGwgPSBudWxsO1xyXG4gIHByaXZhdGUgY2FsbGJhY2s/OiBGYWNlRGV0ZWN0b3JDYWxsYmFjaztcclxuICBwcml2YXRlIHByZXZGYWNlQ291bnQgPSAwO1xyXG4gIHByaXZhdGUgc3RvcHBlZCA9IGZhbHNlO1xyXG5cclxuICBjb25zdHJ1Y3RvcihjYWxsYmFjaz86IEZhY2VEZXRlY3RvckNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgfVxyXG5cclxuICBhc3luYyBsb2FkTW9kZWxzKHBhdGggPSBcIi9tb2RlbHNcIikge1xyXG4gICAgYXdhaXQgZmFjZWFwaS5uZXRzLnRpbnlGYWNlRGV0ZWN0b3IubG9hZEZyb21VcmkocGF0aCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBzdGFydCgpIHtcclxuICAgIHRoaXMuc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyB2aWRlbzogdHJ1ZSB9KTtcclxuICAgIHRoaXMudmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XHJcbiAgICB0aGlzLnZpZGVvLmF1dG9wbGF5ID0gdHJ1ZTtcclxuICAgIHRoaXMudmlkZW8ubXV0ZWQgPSB0cnVlO1xyXG4gICAgdGhpcy52aWRlby5wbGF5c0lubGluZSA9IHRydWU7XHJcbiAgICB0aGlzLnZpZGVvLnNyY09iamVjdCA9IHRoaXMuc3RyZWFtO1xyXG5cclxuICAgIGF3YWl0IHRoaXMudmlkZW8ucGxheSgpO1xyXG4gICAgdGhpcy5zdG9wcGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLmRldGVjdExvb3AoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZGV0ZWN0TG9vcCgpIHtcclxuICAgIGlmICghdGhpcy52aWRlbyB8fCB0aGlzLnN0b3BwZWQpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBkZXRlY3Rpb25zID0gYXdhaXQgZmFjZWFwaS5kZXRlY3RBbGxGYWNlcyhcclxuICAgICAgdGhpcy52aWRlbyxcclxuICAgICAgbmV3IGZhY2VhcGkuVGlueUZhY2VEZXRlY3Rvck9wdGlvbnMoKVxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBmYWNlQ291bnQgPSBkZXRlY3Rpb25zLmxlbmd0aDtcclxuICAgIGlmIChmYWNlQ291bnQgPiAwICYmIHRoaXMucHJldkZhY2VDb3VudCA9PT0gMCkge1xyXG4gICAgICB0aGlzLmNhbGxiYWNrPy4oZmFjZUNvdW50KTsgLy8g4LiE4LiZ4LmA4LiC4LmJ4Liy4Lih4LiyXHJcbiAgICB9IGVsc2UgaWYgKGZhY2VDb3VudCA9PT0gMCAmJiB0aGlzLnByZXZGYWNlQ291bnQgPiAwKSB7XHJcbiAgICAgIHRoaXMuY2FsbGJhY2s/LihmYWNlQ291bnQpOyAvLyDguITguJnguK3guK3guIHguYTguJvguKvguKHguJRcclxuICAgIH1cclxuICAgIHRoaXMucHJldkZhY2VDb3VudCA9IGZhY2VDb3VudDtcclxuXHJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5kZXRlY3RMb29wKCkpO1xyXG4gIH1cclxuXHJcbiAgc3RvcCgpIHtcclxuICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XHJcbiAgICBpZiAodGhpcy52aWRlbz8uc3JjT2JqZWN0KSB7XHJcbiAgICAgICh0aGlzLnZpZGVvLnNyY09iamVjdCBhcyBNZWRpYVN0cmVhbSkuZ2V0VHJhY2tzKCkuZm9yRWFjaCgodCkgPT4gdC5zdG9wKCkpO1xyXG4gICAgfVxyXG4gICAgdGhpcy52aWRlbyA9IG51bGw7XHJcbiAgICB0aGlzLnN0cmVhbSA9IG51bGw7XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJmYWNlYXBpIiwiRmFjZURldGVjdG9yIiwibG9hZE1vZGVscyIsInBhdGgiLCJuZXRzIiwidGlueUZhY2VEZXRlY3RvciIsImxvYWRGcm9tVXJpIiwic3RhcnQiLCJzdHJlYW0iLCJuYXZpZ2F0b3IiLCJtZWRpYURldmljZXMiLCJnZXRVc2VyTWVkaWEiLCJ2aWRlbyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImF1dG9wbGF5IiwibXV0ZWQiLCJwbGF5c0lubGluZSIsInNyY09iamVjdCIsInBsYXkiLCJzdG9wcGVkIiwiZGV0ZWN0TG9vcCIsImRldGVjdGlvbnMiLCJkZXRlY3RBbGxGYWNlcyIsIlRpbnlGYWNlRGV0ZWN0b3JPcHRpb25zIiwiZmFjZUNvdW50IiwibGVuZ3RoIiwicHJldkZhY2VDb3VudCIsImNhbGxiYWNrIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic3RvcCIsImdldFRyYWNrcyIsImZvckVhY2giLCJ0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/FaceDetector.ts\n"));

/***/ })

}]);